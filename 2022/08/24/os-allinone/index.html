<!DOCTYPE html><html lang="zh"><head><meta charset="UTF-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Joe1sn's Cabin | 操作系统实现-合集1</title><meta name="description" content="&lt;p&gt;代码来源：&lt;a href=&quot;https://github.com/StevenBaby/onix&quot;&gt;https://github.com/StevenBaby/onix&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;相关课程：&lt;a href=&quot;https://www.bilibili.com/video/BV1gR4y1u7or&quot;&gt;https://www.bilibili.com/video/BV1gR4y1u7or&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;感谢B站UP：&lt;a href=&quot;https://space.bilibili.com/491131440&quot;&gt;踌躇月光&lt;/a&gt; 带来的相关代码和教程&lt;/p&gt;
&lt;p&gt;后来觉得操作系统从0到1这样学是一个非常蠢得概念，因为每个人学习他应该是有重点地。对系统有个基础的认知后，就该去精通自己要专注的方向，比如内存管理、网络协议等&lt;br /&gt;
也有可能你只是为了面试，但是面试也是有重点的对吧&lt;br /&gt;
所以把之前的文章做一个合集，喜欢在认识系统后再在方面创造子系统&lt;/p&gt;"><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700"><link rel="stylesheet" href="/css/highlights/darkula.css"><link rel="stylesheet" href="/css/main.css"><link rel="search" type="application/opensearchdescription+xml" href="https://joe1sn.eu.org/atom.xml" title="Joe1sn's Cabin"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Joe1sn's Cabin" type="application/atom+xml">
</head><body><div class="container"><header class="main-header"><h1 class="main-header__title uplize"><a class="main-header__title__link" href="/">Joe1sn's Cabin</a></h1><nav class="main-header__nav"><ul class="main-nav"><li class="main-nav__list"><a class="main-nav__list__link" href="/" target="_self">HOME</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/archives/" target="_self">ARCHIVE</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="https://github.com/Joe1sn" target="_blank">GITHUB</a></li></ul></nav></header><main class="container__wrapper"><article class="article post"><h3 class="article__title">操作系统实现-合集1</h3><div class="article__date metadata"><div class="post-info">2022/08/24</div></div><div class="article__tags metadata">Tags:
<a class="article__tags__link metadata" href="/tags/os/">os</a></div><div class="article__body"><p>代码来源：<a target="_blank" rel="noopener" href="https://github.com/StevenBaby/onix">https://github.com/StevenBaby/onix</a></p>
<p>相关课程：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1gR4y1u7or">https://www.bilibili.com/video/BV1gR4y1u7or</a></p>
<p>感谢B站UP：<a target="_blank" rel="noopener" href="https://space.bilibili.com/491131440">踌躇月光</a> 带来的相关代码和教程</p>
<p>后来觉得操作系统从0到1这样学是一个非常蠢得概念，因为每个人学习他应该是有重点地。对系统有个基础的认知后，就该去精通自己要专注的方向，比如内存管理、网络协议等<br />
也有可能你只是为了面试，但是面试也是有重点的对吧<br />
所以把之前的文章做一个合集，喜欢在认识系统后再在方面创造子系统</p>
<span id="more"></span>
<h1 id="操作系统实现基础篇"><a class="markdownIt-Anchor" href="#操作系统实现基础篇"></a> [操作系统实现]基础篇</h1>
<p><strong>CPU中的段寄存器</strong></p>
<ul>
<li>CS (Code Segment Register)：代码段的段基址</li>
<li>DS(Data Segment Register)：数据段的段基址</li>
<li>ES(Extra Segment Register)：其值为附加数据段的段基值，称为“附加”是因为此段寄存器用途不像其他 sreg 那样固定，可以额外做他用。</li>
<li>FS(Extra Segment Register)：其值为附加数据段的段基值</li>
<li>GS：同上</li>
<li>SS(Stack Segment Register)：堆栈段寄存器</li>
</ul>
<ol>
<li>在实模式中，CS、DS、ES、SS中的值是物理地址</li>
<li>在保护模式中，装入寄存器的是<strong>段选择子</strong></li>
</ol>
<hr />
<p><strong>BIOS DOS Linux中断的区别</strong></p>
<ul>
<li>
<p><strong>BIOS、DOS</strong>都是在 <strong>实模式</strong> 中运行，有内部中断向量表(Interrupt Vector Table IVT)建立，用过INT掉用实现</p>
</li>
<li>
<p><strong>BIOS</strong> 中断调用的主要功能是提供了硬件访问的方法，该方法使对硬件的操作变得简单易行</p>
</li>
<li>
<p>BIOS 在运行期间会扫描 0xc0000 0xe0000 之间的内存，若在某个区域发现前两个 节是 Ox55 OxAA 时，这意味着该区域对应的 rom 中有代码存在，再对该区域做累加和检查，若结果与第3个字节的值相符，说明代码无误，就从第4个字节进入</p>
</li>
<li>
<p><strong>Linux</strong> 内核是在进入保护模式后才建立中断例程的，不过在保护模式下，中断向量表己经不存在了， 取而代之的是中断描述符表(Interrupt Descriptor Table, IDT)。</p>
<p><strong>Linux 是通过 int 0x80 指令进入一个中断程序后再根据 缸寄存器的值来调用不同的子功能函数的</strong></p>
</li>
</ul>
<hr />
<p><strong>Section与Segment的区别</strong></p>
<ol>
<li>section 称为节，是指在汇编源码中经由关键字 section segment 修饰、逻辑划分的指令或数据区域， 汇编器会将这两个关键字修饰的区域在目标文件中编译成节，也就是说“节”最初诞生于目标文件中</li>
<li>segment 称为段，是链接器根据目标文件中属性相同的多个 section 合并后的 section 集合，这个集合 称为 segment ，也就是段，链接器把目标文件链接成可执行文件，因此段最终诞生于可执行文件中</li>
<li>不管定义了多少节名，最终要把属性相同的 section ，或者编译认为可以放到一块的，合并到一个大的 segment 中，也就是 elf 中说的 program header 中的项</li>
</ol>
<hr />
<p><strong>MBR 、EBR、DBR、OBR是什么</strong></p>
<ul>
<li>
<p><strong>MBR</strong> 是主引导记录(Main Boot Record)，存在与磁盘开始，扇区大小为512字节</p>
<ul>
<li>446 字节的引导程序及参数：</li>
<li>64字节分区表</li>
<li>2字节结束标记：\x55\xaa</li>
</ul>
</li>
<li>
<p><strong>OBR</strong> 内核加载器，存在于操作系统引导扇区，是操作系统引导程序(OS Boot Record)</p>
</li>
<li>
<p><strong>DBR</strong> Dos Boot Record</p>
<ul>
<li>MBR跳转引导指令</li>
<li>厂商信息、DOS版本模块</li>
<li>BIOS参数块BPB</li>
<li>OBR</li>
<li>结束标记 \x55\xaa</li>
</ul>
</li>
<li>
<p><strong>EBR</strong> Extra Boot Record，解决分区数量限制同时兼容MBR</p>
<p><strong>MBR EBR 是分区工具创建维护的，不属于操作系统管理的范围</strong></p>
</li>
</ul>
<hr />
<p><strong>grub</strong></p>
<ul>
<li>multiboot</li>
</ul>
<hr />
<p><strong>0x7c00</strong></p>
<ul>
<li>IBM PC 5150</li>
<li>DOS 1.0</li>
</ul>
<h1 id="操作系统实现mbr"><a class="markdownIt-Anchor" href="#操作系统实现mbr"></a> [操作系统实现]MBR</h1>
<h2 id="一些问题"><a class="markdownIt-Anchor" href="#一些问题"></a> 一些问题</h2>
<p>BIOS固定入口地址：0xFFFF0，此时CPU中的cs:ip为 0xF000:0xFFF0（实模式下cs要左移4位再相加）</p>
<p><strong>？为什么是0x7C00</strong></p>
<p>MBR程序是在内存的0x7c00中运行的，DOS1.0中的最小内存为32KB，所以选择最后1KB合理，32KB=0x8000B，1KB=0x400，所以程序开始是0x8000-0x100=0x7c00</p>
<p><strong>如何找到系统调用相关说明</strong></p>
<ul>
<li>IBM PS 2 and PC BIOS Interface Technical Reference</li>
</ul>
<p><strong>主引导扇区结构</strong></p>
<ul>
<li>代码大小：446B</li>
<li>硬盘分区表：64B=4*16B</li>
<li>magic_num：0xaa55 - 0x55 0xaa</li>
</ul>
<p><strong>主要功能</strong></p>
<p>​	读取内核加载其并执行</p>
<h2 id="实验"><a class="markdownIt-Anchor" href="#实验"></a> 实验</h2>
<p>按照书上配置好环境</p>
<p>配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#Bochs运行中使用的内存，设置为32M</span><br><span class="line">megs: 32</span><br><span class="line"></span><br><span class="line">#设置真实机器的BIOS和VGA BIOS</span><br><span class="line">#修改成你们对应的地址</span><br><span class="line">romimage: file=/home/joe1sn/Desktop/real_os/bochs/share/bochs/BIOS-bochs-latest</span><br><span class="line">vgaromimage: file=/home/joe1sn/Desktop/real_os/bochs/share/bochs/VGABIOS-lgpl-latest</span><br><span class="line"></span><br><span class="line">#设置Bochs所使用的磁盘</span><br><span class="line">#设置启动盘符</span><br><span class="line">boot: disk</span><br><span class="line"></span><br><span class="line">#设置日志文件的输出</span><br><span class="line">log: bochs.out</span><br><span class="line"></span><br><span class="line">#开启或关闭某些功能，修改成你们对应的地址</span><br><span class="line">mouse: enabled=0</span><br><span class="line">keyboard:keymap=/home/joe1sn/Desktop/real_os/bochs/share/bochs/keymaps/x11-pc-us.map</span><br><span class="line"></span><br><span class="line">#硬盘设置</span><br><span class="line">ata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14</span><br><span class="line">ata0-master: type=disk, path=&quot;hd60M.img&quot;, mode=flat, cylinders=121, heads=16, spt=63</span><br><span class="line">#ata0-master: type=disk, path=&quot;gp60M.img&quot;, mode=flat, cylinders=121, heads=16, spt=63</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#增加bochs对gdb的支持，我们在这里不使用，所以注释掉了</span><br><span class="line">#gdbstub: enabled=1, port=1234, text_base=0, data_base=0, bss_base=0</span><br></pre></td></tr></table></figure>
<p>源代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">;MBR</span><br><span class="line">;--------------------------------</span><br><span class="line">SECTION MBR vstart=0x7c00;</span><br><span class="line">	mov ax,cs</span><br><span class="line">	mov ds,ax</span><br><span class="line">	mov es,ax</span><br><span class="line">	mov ss,ax</span><br><span class="line">	mov fs,ax</span><br><span class="line">	mov sp,0x7c00</span><br><span class="line"></span><br><span class="line">;使用6上卷屏幕，实现清屏</span><br><span class="line">;-------------------------------------------------------</span><br><span class="line">	mov ax, 0x600</span><br><span class="line">	mov bx, 0x700</span><br><span class="line">	mov cx, 0</span><br><span class="line">	mov dx, 0x184f</span><br><span class="line">	int 0x10</span><br><span class="line"></span><br><span class="line">;;;;;	得到光标位置</span><br><span class="line">	mov ah, 3	;3号功能是获取光标位置</span><br><span class="line">	mov bh, 0	;存储带获取光标的页号</span><br><span class="line">	int 0x10</span><br><span class="line"></span><br><span class="line">;;;;;	打印字符串</span><br><span class="line">	mov ax, message</span><br><span class="line">	mov bp, ax</span><br><span class="line">	</span><br><span class="line">	mov cx, 5</span><br><span class="line">	mov ax, 0x1301</span><br><span class="line">	</span><br><span class="line">	mov bx, 0x2</span><br><span class="line">	int 0x10</span><br><span class="line"></span><br><span class="line">	jmp $	;pause</span><br><span class="line">	message db &quot;MetOS&quot;;要打印的字符串</span><br><span class="line">	times 510-($-$$) db 0</span><br><span class="line">	db 0x55,0xaa</span><br></pre></td></tr></table></figure>
<p><strong>编译</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nasm -o mbr.bin mbr.asm</span><br></pre></td></tr></table></figure>
<hr />
<p><strong>设置基础BOCHS硬盘</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/bximage -hd -mode=&quot;flat&quot; -size=60 -q hd60M.img</span><br></pre></td></tr></table></figure>
<p>ata0-master: type=disk, path=“master.img”, mode=flat, cylinders=121, heads=16, spt=63</p>
<hr />
<p><strong>按照格式写入硬盘文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=./mbr.bin of=/home/joe1sn/Desktop/real_os/bochs/hd60M.img bs=512 count=1 conv=notrunc</span><br></pre></td></tr></table></figure>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/2e90a5e48ffc816ddd25878734b86fbd.png" alt="源代码" /></p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/58d1b92aebc42f763b55cecc54eda244.png" alt="运行" /></p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/99a479613b4b3ad139ef85ddfc32f1c4.png" alt="效果" /></p>
<h2 id="使用显卡显示"><a class="markdownIt-Anchor" href="#使用显卡显示"></a> 使用显卡显示</h2>
<p>IA32 体系系统中，因为用于存储端口号的寄存器是 16 位的，所以最大有 65536 个端口，即 65535 要是通过内存映射，端口就可以用 mov 指令来操作。但由于用的是独立编址，所以就不能把它当作内存来操作，因此 CPU 提供了专门的指令来干这事，in和out</p>
<p><strong>in</strong>用于读数据 <strong>out</strong>用于写数据</p>
<p>外部设备BIOS是：0xC000道0xCFFF</p>
<p>显存是0xB8000到0xBFFFF</p>
<p><strong>源代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">;Main Bootloader Program</span><br><span class="line">;--------------------------------</span><br><span class="line">SECTION MBR vstart=0x7c00</span><br><span class="line">	mov ax,cs</span><br><span class="line">	mov ds,ax</span><br><span class="line">	mov es,ax</span><br><span class="line">	mov ss,ax</span><br><span class="line">	mov fs,ax</span><br><span class="line">	mov sp,0x7c00</span><br><span class="line">	mov ax,0xb800</span><br><span class="line">	mov gs,ax</span><br><span class="line"></span><br><span class="line">;clear screen using int_6</span><br><span class="line">;-----------------------------------------------------------</span><br><span class="line">;INT 0x10	function_code:6	funcion:uproll the screen</span><br><span class="line">;-----------------------------------------------------------</span><br><span class="line">;INPUT</span><br><span class="line">	mov ax, 0x600</span><br><span class="line">	mov bx, 0x700</span><br><span class="line">	mov cx, 0</span><br><span class="line">	mov dx, 0x184f</span><br><span class="line">	int 0x10</span><br><span class="line"></span><br><span class="line">;using gpu</span><br><span class="line">	mov byte [gs:0x00],&#x27;M&#x27;</span><br><span class="line">	mov byte [gs:0x01],0x04 ;green back_flash</span><br><span class="line"></span><br><span class="line">	mov byte [gs:0x02],&#x27;e&#x27;</span><br><span class="line">	mov byte [gs:0x03],0x04</span><br><span class="line"></span><br><span class="line">	mov byte [gs:0x04],&#x27;l&#x27;</span><br><span class="line">	mov byte [gs:0x05],0x04</span><br><span class="line"></span><br><span class="line">	mov byte [gs:0x06],&#x27;t&#x27;</span><br><span class="line">	mov byte [gs:0x07],0x04</span><br><span class="line"></span><br><span class="line">	mov byte [gs:0x08],&#x27;O&#x27;</span><br><span class="line">	mov byte [gs:0x09],0x04</span><br><span class="line">	</span><br><span class="line">        mov byte [gs:0x0a],&#x27;S&#x27;</span><br><span class="line">        mov byte [gs:0x0b],0x04</span><br><span class="line"></span><br><span class="line">	jmp $	;pause</span><br><span class="line">	times 510-($-$$) db 0</span><br><span class="line">	db 0x55,0xaa</span><br></pre></td></tr></table></figure>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/b7f154b4226ed14f8e374f09d597e912.png" alt="image-20220208155034291" /></p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/707de5657ba853b0a65770311bab2450.png" alt="image-20220208155000889" /></p>
<h2 id="bochs调试"><a class="markdownIt-Anchor" href="#bochs调试"></a> BOCHS调试</h2>
<p><strong>Debug Control</strong></p>
<p>q|quit|exit</p>
<p>set</p>
<p>show</p>
<ul>
<li>
<p>show mode</p>
<p>每次CPU变换模式提醒</p>
</li>
<li>
<p>show int</p>
<p>每次中断时提醒</p>
</li>
<li>
<p>show call</p>
<p>函数调用时提醒</p>
</li>
</ul>
<p>u|disasm [/num] [start] [end]</p>
<p>​	反汇编 start到end代码，num是反汇编指令数</p>
<p><strong>Execution control</strong></p>
<p>c| cont| continue</p>
<p>s| step [count]</p>
<p>p| n| next</p>
<p><strong>Breakpoint management</strong></p>
<p>vb| vbreak 按照虚拟地址下断点</p>
<p>lb| break[addr]线性地址添加断点</p>
<p>pb| pbreak| b| break [addr] 物理地址添加断点</p>
<p>sb [delta] delta 表示再执行delta条指令程序就中断</p>
<p>watch unwatch</p>
<p>blist 显示所有断点信息</p>
<p>bpd| bpe [n]禁用断点</p>
<p>d| del| delete[n] 删除某断点</p>
<h2 id="mbr使用硬盘-交出控制权"><a class="markdownIt-Anchor" href="#mbr使用硬盘-交出控制权"></a> MBR使用硬盘-交出控制权</h2>
<p>MBR</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">;Main Bootloader Program</span><br><span class="line">;--------------------------------</span><br><span class="line">%include &quot;boot.inc&quot;</span><br><span class="line">SECTION MBR vstart=0x7c00</span><br><span class="line">	mov ax,cs</span><br><span class="line">	mov ds,ax</span><br><span class="line">	mov es,ax</span><br><span class="line">	mov ss,ax</span><br><span class="line">	mov fs,ax</span><br><span class="line">	mov sp,0x7c00</span><br><span class="line">	mov ax,0xb800</span><br><span class="line">	mov gs,ax</span><br><span class="line"></span><br><span class="line">;clear screen using int_6</span><br><span class="line">;-----------------------------------------------------------</span><br><span class="line">;INT 0x10	function_code:6	funcion:uproll the screen</span><br><span class="line">;-----------------------------------------------------------</span><br><span class="line">;INPUT</span><br><span class="line">	mov ax, 0x600</span><br><span class="line">	mov bx, 0x700</span><br><span class="line">	mov cx, 0</span><br><span class="line">	mov dx, 0x184f</span><br><span class="line">	int 0x10</span><br><span class="line"></span><br><span class="line">;using gpu</span><br><span class="line">	mov byte [gs:0x00],&#x27;M&#x27;</span><br><span class="line">	mov byte [gs:0x01],0x04 ;green back_flash</span><br><span class="line"></span><br><span class="line">	mov byte [gs:0x02],&#x27;e&#x27;</span><br><span class="line">	mov byte [gs:0x03],0x04</span><br><span class="line"></span><br><span class="line">	mov byte [gs:0x04],&#x27;l&#x27;</span><br><span class="line">	mov byte [gs:0x05],0x04</span><br><span class="line"></span><br><span class="line">	mov byte [gs:0x06],&#x27;t&#x27;</span><br><span class="line">	mov byte [gs:0x07],0x04</span><br><span class="line"></span><br><span class="line">	mov byte [gs:0x08],&#x27;O&#x27;</span><br><span class="line">	mov byte [gs:0x09],0x04</span><br><span class="line">	</span><br><span class="line">        mov byte [gs:0x0a],&#x27;S&#x27;</span><br><span class="line">        mov byte [gs:0x0b],0x04</span><br><span class="line"></span><br><span class="line">	mov eax,LOADER_START_SECTOR	;起始扇区lba地址</span><br><span class="line">	mov bx,LOADER_BASE_ADDR		;写入磁盘的地址</span><br><span class="line">	mov cd,1			;代读入的扇区数</span><br><span class="line">	call rd_disk_m_16</span><br><span class="line"></span><br><span class="line">	jmp LOADER_BASE_ADDR</span><br><span class="line"></span><br><span class="line">;读取硬盘的第n个扇区</span><br><span class="line">rd_disk_m_16:</span><br><span class="line">;	eax=LBA扇区号</span><br><span class="line">;	ebx=将数据写入的内存地址</span><br><span class="line">;	ecx=读入的扇区数	</span><br><span class="line">	mov esi,eax	;备份eax</span><br><span class="line">	mov di,cx	;备份cx</span><br><span class="line"></span><br><span class="line">;读写硬盘</span><br><span class="line">;------S1:设置要读取扇区数</span><br><span class="line">	mov dx,0x1f2</span><br><span class="line">	mov al,cl</span><br><span class="line">	out dx,al	;代读取的扇区数</span><br><span class="line">	mov eax,esi	;恢复ax</span><br><span class="line"></span><br><span class="line">;------S2:将LBA地址写入0x1f3-0x1f6</span><br><span class="line">	;LBA 地址7-0位写入端口 0x1f3</span><br><span class="line">	mov dx,0x1f3</span><br><span class="line">	out dx,al</span><br><span class="line"></span><br><span class="line">	;LBA 地址15-8 位写入端口 0x1f4</span><br><span class="line">	mov cl,8</span><br><span class="line">	shr eax,cl</span><br><span class="line">	mov dx,0x1f4</span><br><span class="line">	out dx,al</span><br><span class="line"></span><br><span class="line">	;LBA 地址23-16 位写入端口 0x1f5</span><br><span class="line">        shr eax,cl</span><br><span class="line">        mov dx,0x1f5</span><br><span class="line">        out dx,al</span><br><span class="line">	</span><br><span class="line">	shr eax,cl</span><br><span class="line">	and al,0x0f	;LBA 24-27 bits</span><br><span class="line">	or al,0xe0	;set 7-4 = 1110，表示LBA模式</span><br><span class="line">	mov dx,0x1f6</span><br><span class="line">	out dx,al</span><br><span class="line"></span><br><span class="line">;------S3:0x1f7端口写入读命令,0x20</span><br><span class="line">	mov dx,0x1f7</span><br><span class="line">	mov al,0x20</span><br><span class="line">	out dx,al</span><br><span class="line"></span><br><span class="line">;------S4:检测硬盘状态</span><br><span class="line"> .not_ready:</span><br><span class="line">	nop</span><br><span class="line">	in al,dx</span><br><span class="line">	and al,0x88	;第4位为1表示硬盘控制器已准备好数据传输，第7位为1表示硬盘忙</span><br><span class="line"></span><br><span class="line">	cmp al,0x08</span><br><span class="line">	jnz .not_ready</span><br><span class="line">;------S5:从0x1f0读取数据</span><br><span class="line">	mov ax,di</span><br><span class="line">	mov dx,256</span><br><span class="line">	mul dx</span><br><span class="line">	mov cx,ax</span><br><span class="line">	mov dx,0x1f0</span><br><span class="line"> .go_on_ready:</span><br><span class="line">	in ax,dx</span><br><span class="line">	mov [bx],ax</span><br><span class="line">	add bx,2</span><br><span class="line">	loop .go_on_ready</span><br><span class="line">	ret</span><br><span class="line"></span><br><span class="line">	;jmp $	;pause</span><br><span class="line">	times 510-($-$$) db 0</span><br><span class="line">	db 0x55,0xaa</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>宏<code>LOADER_START_SECTOR</code>就是0x2，表示我们要向磁盘第三个扇区（第一个是0x0）读loader，<code>LOADER_BASE_ADDR</code>就是loader被写入的地址0x900。</p>
<p>Loader</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">%include &quot;boot.inc&quot;</span><br><span class="line">section loader vstart=LOADER_BASE_ADDR</span><br><span class="line"></span><br><span class="line">mov byte [gs:0x00] ,&#x27;2&#x27;</span><br><span class="line">mov byte [gs:0x01] ,0xA4</span><br><span class="line"></span><br><span class="line">mov byte [gs:0x02] ,&#x27; &#x27;</span><br><span class="line">mov byte [gs:0x03] ,0xA4</span><br><span class="line"></span><br><span class="line">mov byte [gs:0x04] ,&#x27;L&#x27;</span><br><span class="line">mov byte [gs:0x05] ,0xA4</span><br><span class="line"></span><br><span class="line">mov byte [gs:0x06] ,&#x27;o&#x27;</span><br><span class="line">mov byte [gs:0x07] ,0xA4</span><br><span class="line"></span><br><span class="line">mov byte [gs:0x08] ,&#x27;a&#x27;</span><br><span class="line">mov byte [gs:0x09] ,0xA4</span><br><span class="line"></span><br><span class="line">mov byte [gs:0x0a] ,&#x27;d&#x27;</span><br><span class="line">mov byte [gs:0x0b] ,0xA4</span><br><span class="line"></span><br><span class="line">mov byte [gs:0x0c] ,&#x27;e&#x27;</span><br><span class="line">mov byte [gs:0x0d] ,0xA4</span><br><span class="line"></span><br><span class="line">mov byte [gs:0x0e] ,&#x27;r&#x27;</span><br><span class="line">mov byte [gs:0x0f] ,0xA4</span><br><span class="line"></span><br><span class="line">jmp $</span><br></pre></td></tr></table></figure>
<p>编译后写入第二扇区</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=./MBR/loader.bin of=/home/joe1sn/Desktop/real_os/bochs/disk60M.img bs=512 count=1 seek=2 conv=notrunc</span><br></pre></td></tr></table></figure>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/ab627f0fe46e0b0fb4b5c26a3d806280.png" alt="image-20220208163529418" /></p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>**1.MBR执行流程 **</p>
<p>从内存最低1KB位置出发，调用BIOS的中断向量表实现</p>
<p><strong>2.使用外部IO设备</strong></p>
<p>每个设备在CPU实模式中有内存和端口，按照内存访问+向量表调用可以实现</p>
<p><strong>3.使用IO启动</strong></p>
<p>开始和之前相同</p>
<p>​	第1步：设置要读取的扇区数<br />
​	第2步：将LBA地址存入0x1f3 ~ 0x1f6<br />
​	第3步：向0x1f7端口写入读命令，0x20<br />
​	第4步：检测硬盘状态<br />
​	第5步：从0x1f0端口读数据</p>
<ol>
<li>先选择通道，往该通道的 sector count 寄存器中写入待操作的扇区数</li>
<li>往该通道上的三个 LBA 寄存器写入扇区起始地址的低 24 位</li>
<li>往 device 寄存器中写入 LBA 地址的 24-27 位，并置第6位为1，使其为 LBA 模式，设置第4位，选择操作的硬盘（master 硬盘或 slave 硬盘）</li>
<li>往该通道上的 command 寄存器写入操作命令</li>
<li>读取该通道上的 status 寄存器，判断硬盘工作是否完成</li>
<li>如果以上步骤是读硬盘，进入下 个步骤。否则，完工</li>
<li>将硬盘数据读出</li>
</ol>
<p>数据传送的方式就是操作系统学的了</p>
<h1 id="操作系统实现从usb启动"><a class="markdownIt-Anchor" href="#操作系统实现从usb启动"></a> [操作系统实现]从usb启动</h1>
<p>首先把usb插入ubuntu查看</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsblk #查看挂载</span><br></pre></td></tr></table></figure>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/a0ba672bb25398b1b273e14353b5acd7.png" alt="image-20220215202235388" /></p>
<p>格式化usb</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo fdisk /dev/sdb</span><br></pre></td></tr></table></figure>
<ul>
<li>d：删除分区</li>
</ul>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/5b654ab2407427f454bcbbe9492ea0d5.png" alt="image-20220215202628614" /></p>
<p>可以写makefile如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">boot.bin: boot.asm</span></span><br><span class="line">	nasm -f bin boot.asm -o boot.bin</span><br><span class="line"></span><br><span class="line"><span class="section">master.img: boot.bin</span></span><br><span class="line">	yes | bximage -hd -mode=<span class="string">&quot;flat&quot;</span> -size=60 -q master.img</span><br><span class="line">	dd if=./boot.bin of=master.img bs=512 count=1 conv=notrunc</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -rf *.bin</span><br><span class="line">	rm -rf *.img</span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: usb</span></span><br><span class="line"><span class="section">usb: boot.bin /dev/sdb</span></span><br><span class="line">	sudo dd if=/dev/sdb of=tmp.bin bs=512 count=1 conv=notrunc</span><br><span class="line">	cp tmp.bin usb.bin</span><br><span class="line">	sudo rm tmp.bin</span><br><span class="line">	dd if=boot.bin of=usb.bin bs=446 count=1 conv=notrunc</span><br><span class="line">	sudo dd if=usb.bin of=/dev/sdb bs=512 count=1 conv=notrunc</span><br><span class="line">	rm usb.bin</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: bochs</span></span><br><span class="line"><span class="section">bochs: master.img</span></span><br><span class="line">	bochs -q</span><br></pre></td></tr></table></figure>
<p>源代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">[org 0x7c00]</span><br><span class="line">;最简单的主程序引导程序</span><br><span class="line">;实模式的启动地址</span><br><span class="line"></span><br><span class="line">;设置屏幕模式为文本模式，清除屏幕</span><br><span class="line">mov ax,3</span><br><span class="line">int 0x10</span><br><span class="line"></span><br><span class="line">;初始化段寄存器</span><br><span class="line">mov ax,0</span><br><span class="line">mov ds,ax</span><br><span class="line">mov es,ax</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,0x7c00</span><br><span class="line"></span><br><span class="line">; xchg bx, bx; bochs魔数断点</span><br><span class="line"></span><br><span class="line">mov si, booting</span><br><span class="line">call print</span><br><span class="line"></span><br><span class="line">;程序悬停</span><br><span class="line">jmp $</span><br><span class="line"></span><br><span class="line">print:</span><br><span class="line">    mov ah, 0xe</span><br><span class="line">.next:</span><br><span class="line">    mov al, [si]</span><br><span class="line">    cmp al, 0</span><br><span class="line">    jz .done</span><br><span class="line">    int 0x10</span><br><span class="line">    inc si</span><br><span class="line">    jmp .next</span><br><span class="line">.done:</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">booting:</span><br><span class="line">    db &quot;Booting Xsys...&quot;,10,13,0; \n\r</span><br><span class="line"></span><br><span class="line">;填充</span><br><span class="line">times 510-($-$$) db 0</span><br><span class="line">db 0x55,0xaa</span><br></pre></td></tr></table></figure>
<p>弹出过后从VMware创建新的虚拟机启动</p>
<p>注：要在插入usb后启动vmware，否则vmware无法识别到usb</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/6d294d583d0e60a6bbd08348b7813f7d.png" alt="image-20220215204802321" /></p>
<h1 id="操作系统实现实模式下的print实现"><a class="markdownIt-Anchor" href="#操作系统实现实模式下的print实现"></a> [操作系统实现]实模式下的print实现</h1>
<p>参数：</p>
<ul>
<li><strong>ah</strong>：0xe</li>
<li><strong>al</strong>：字符</li>
<li><strong>int 0x10</strong>： 系统调用</li>
</ul>
<p>函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">print:</span><br><span class="line">    mov ah, 0xe	;功能参数</span><br><span class="line">.next:</span><br><span class="line">    mov al, [si];字符</span><br><span class="line">    cmp al, 0	;判断是否为最后一个结尾</span><br><span class="line">    jz .done	;结尾跳转至ret</span><br><span class="line">    int 0x10	;功能调用</span><br><span class="line">    inc si		;地址-1</span><br><span class="line">    jmp .next	;继续，下一个</span><br><span class="line">.done:</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/f997bf523a7e9c3097e67bfa0b05cda5.png" alt="image-20220216105159456" /></p>
<p>完整代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">[org 0x7c00]</span><br><span class="line">;最简单的主程序引导程序</span><br><span class="line">;实模式的启动地址</span><br><span class="line"></span><br><span class="line">;设置屏幕模式为文本模式，清除屏幕</span><br><span class="line">mov ax,3</span><br><span class="line">int 0x10</span><br><span class="line"></span><br><span class="line">;初始化段寄存器</span><br><span class="line">mov ax,0</span><br><span class="line">mov ds,ax</span><br><span class="line">mov es,ax</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,0x7c00</span><br><span class="line"></span><br><span class="line">xchg bx, bx; bochs魔数断点</span><br><span class="line"></span><br><span class="line">mov si, booting</span><br><span class="line">call print</span><br><span class="line"></span><br><span class="line">;程序悬停</span><br><span class="line">jmp $</span><br><span class="line"></span><br><span class="line">print:</span><br><span class="line">    mov ah, 0xe	;功能参数</span><br><span class="line">.next:</span><br><span class="line">    mov al, [si];字符</span><br><span class="line">    cmp al, 0	;判断是否为最后一个结尾</span><br><span class="line">    jz .done	;结尾跳转至ret</span><br><span class="line">    int 0x10	;功能调用</span><br><span class="line">    inc si		;地址-1</span><br><span class="line">    jmp .next	;继续，下一个</span><br><span class="line">.done:</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">booting:</span><br><span class="line">    db &quot;Booting Xsys...&quot;,10,13,0; \n\r</span><br><span class="line"></span><br><span class="line">;填充</span><br><span class="line">times 510-($-$$) db 0</span><br><span class="line">db 0x55,0xaa</span><br></pre></td></tr></table></figure>
<p>make bochs编译</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/c3f08344dfa84978636fa7dac9ed6def.png" alt="image-20220216104837817" /></p>
<h1 id="操作系统实现硬盘读写"><a class="markdownIt-Anchor" href="#操作系统实现硬盘读写"></a> [操作系统实现]硬盘读写</h1>
<h2 id="简单的磁盘结构"><a class="markdownIt-Anchor" href="#简单的磁盘结构"></a> 简单的磁盘结构</h2>
<ul>
<li>扇区：硬盘读写的最小单位，最多256，最小1个</li>
<li>性能瓶颈：机械臂的寻道时间</li>
<li>一般磁道有63个扇区（由于BIOS最大支持）</li>
<li>一般外侧读写速度最快</li>
</ul>
<h2 id="ide-ata-pio-mode"><a class="markdownIt-Anchor" href="#ide-ata-pio-mode"></a> <strong>IDE / ATA PIO Mode</strong></h2>
<ul>
<li>
<p><strong>PIO</strong>：Port Input Output</p>
<p>Port更多指的是外部设备内部的寄存器</p>
</li>
<li>
<p><strong>IDE</strong>：Intergrated Drive Electronics 集成电子驱动器 （西部数据）</p>
</li>
<li>
<p><strong>ATA</strong>（PATA）：Advanced Technology Attachment（ANSI标准）</p>
</li>
<li>
<p><strong>SATA</strong></p>
</li>
</ul>
<h2 id="硬盘读写模式"><a class="markdownIt-Anchor" href="#硬盘读写模式"></a> <strong>硬盘读写模式</strong></h2>
<ul>
<li>
<p><strong>CHS</strong>： Cylinder / Head / Sector | 柱面 / 磁道 / 扇区</p>
</li>
<li>
<p><strong>LBA</strong>： Logical Block Address | 逻辑块地址</p>
<p><strong>LBA28</strong>：总共访问 128G的磁盘空间</p>
<p>两个通道：Primary Secondary</p>
<ul>
<li>0x1F0：16bits，用于读写数据</li>
<li>0x1F1：用于检测前一个指令的错误</li>
<li>0x1F2：读写扇区的数量，最多256</li>
<li>0x1F3：起始扇区 0 ~ 7 位</li>
<li>0x1F4：起始扇区 8~15 位</li>
<li>0x1F5：起始扇区 16 ~ 23 位</li>
<li>0x1F6：
<ul>
<li>0 ~ 3：起始扇区 24 ~ 27 位</li>
<li>4：0–&gt;master主盘；1–&gt;slave从盘</li>
<li>6：0 CHS模式；1 LBA模式</li>
<li>5、7：固定 1</li>
</ul>
</li>
<li>0x1F7：
<ul>
<li>out操作
<ul>
<li>0xEC：识别硬盘</li>
<li>0x20：读硬盘</li>
<li>0x30：写硬盘</li>
</ul>
</li>
<li>int操作
<ul>
<li>0 ERROR</li>
<li>3 DRQ 数据准备完毕</li>
<li>7 BSY 硬盘繁忙</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>源代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br></pre></td><td class="code"><pre><span class="line">[org 0x7c00]</span><br><span class="line">;最简单的主程序引导程序</span><br><span class="line">;实模式的启动地址</span><br><span class="line"></span><br><span class="line">;设置屏幕模式为文本模式，清除屏幕</span><br><span class="line">mov ax,3</span><br><span class="line">int 0x10</span><br><span class="line"></span><br><span class="line">;初始化段寄存器</span><br><span class="line">mov ax,0</span><br><span class="line">mov ds,ax</span><br><span class="line">mov es,ax</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,0x7c00</span><br><span class="line"></span><br><span class="line">mov edi, 0x1000  ; 读到的目标内存</span><br><span class="line">mov ecx, 0       ; 起始扇区</span><br><span class="line">mov bl,1         ;扇区数量</span><br><span class="line">call read_disk</span><br><span class="line"></span><br><span class="line">xchg bx, bx; bochs魔数断点</span><br><span class="line">mov edi, 0x1000  ; src的目标内存</span><br><span class="line">mov ecx, 2       ; 起始扇区</span><br><span class="line">mov bl,1         ;扇区数量</span><br><span class="line">call write_disk</span><br><span class="line"></span><br><span class="line">mov si, booting</span><br><span class="line">call print</span><br><span class="line"></span><br><span class="line">;程序悬停</span><br><span class="line">jmp $</span><br><span class="line"></span><br><span class="line">;读取硬盘</span><br><span class="line">read_disk:</span><br><span class="line">    ;设置读写扇区数量</span><br><span class="line">    ;0x1f2端口=1</span><br><span class="line">    mov dx, 0x1f2</span><br><span class="line">    mov al, bl</span><br><span class="line">    out dx, al</span><br><span class="line"></span><br><span class="line">    ;-----------------------------------------</span><br><span class="line">    ;0x1f3端口= 00000000</span><br><span class="line">    inc dx; 0x1f3</span><br><span class="line">    mov al, cl ;起始扇区的前8位</span><br><span class="line">    out dx, al</span><br><span class="line"></span><br><span class="line">    ;0x1f4端口= 00000000</span><br><span class="line">    inc dx; 0x1f4</span><br><span class="line">    shr ecx, 8</span><br><span class="line">    mov al, cl ;起始扇区的中8位</span><br><span class="line">    out dx, al</span><br><span class="line"></span><br><span class="line">    ;0x1f5端口= 00000000</span><br><span class="line">    inc dx; 0x1f5</span><br><span class="line">    shr ecx, 8</span><br><span class="line">    mov al, cl ;起始扇区的高8位</span><br><span class="line">    out dx, al</span><br><span class="line">    ;起始扇区24位：00000000_00000000_00000000</span><br><span class="line">    ;-----------------------------------------</span><br><span class="line"></span><br><span class="line">    inc dx;0x1f6</span><br><span class="line">    shr ecx, 8</span><br><span class="line">    and cl, 0b1111;高4位置0</span><br><span class="line">    mov al, 0b1110_0000;</span><br><span class="line">    or al, cl; cl拼接到al后面</span><br><span class="line"></span><br><span class="line">    out dx, al;主盘 LBA模式设置</span><br><span class="line"></span><br><span class="line">    ;0x1f7端口= 0x20;表示读硬盘</span><br><span class="line">    inc dx;0x1f7</span><br><span class="line">    mov al,0x20;读硬盘</span><br><span class="line">    out dx,al</span><br><span class="line"></span><br><span class="line">    xor ecx, ecx;清空exc</span><br><span class="line">    mov cl, bl;得到读写扇区的数量</span><br><span class="line"></span><br><span class="line">    .read:</span><br><span class="line">        push cx;保存cx</span><br><span class="line">        call .waits;等待数据准备完毕</span><br><span class="line">        call .reads;读取一个扇区</span><br><span class="line">        pop cx</span><br><span class="line">        loop .read</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">    .waits:</span><br><span class="line">        mov dx, 0x1f7</span><br><span class="line">        .check:</span><br><span class="line">            in al, dx</span><br><span class="line">            jmp $+2; nop等价，直接跳下一行</span><br><span class="line">            jmp $+2; 制造一点点延迟</span><br><span class="line">            jmp $+2; </span><br><span class="line">            and al, 0b1000_1000; 与操作，只剩下3,7位</span><br><span class="line">            cmp al, 0b0000_1000; 比较3,7位，确保硬盘准备就绪</span><br><span class="line">            jnz .check</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">    .reads:</span><br><span class="line">        mov dx, 0x1f0</span><br><span class="line">        mov cx, 256;一个扇区是256字</span><br><span class="line">        .readw:</span><br><span class="line">            in ax, dx</span><br><span class="line">            jmp $+2; nop等价，直接跳下一行</span><br><span class="line">            jmp $+2; 制造一点点延迟</span><br><span class="line">            jmp $+2;</span><br><span class="line">            mov [edi], ax</span><br><span class="line">            add edi, 2</span><br><span class="line">            loop .readw</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">;写硬盘</span><br><span class="line">write_disk:</span><br><span class="line">    ;设置读写扇区数量</span><br><span class="line">    ;0x1f2端口=1</span><br><span class="line">    mov dx, 0x1f2</span><br><span class="line">    mov al, bl</span><br><span class="line">    out dx, al</span><br><span class="line"></span><br><span class="line">    ;-----------------------------------------</span><br><span class="line">    ;0x1f3端口= 00000000</span><br><span class="line">    inc dx; 0x1f3</span><br><span class="line">    mov al, cl ;起始扇区的前8位</span><br><span class="line">    out dx, al</span><br><span class="line"></span><br><span class="line">    ;0x1f4端口= 00000000</span><br><span class="line">    inc dx; 0x1f4</span><br><span class="line">    shr ecx, 8</span><br><span class="line">    mov al, cl ;起始扇区的中8位</span><br><span class="line">    out dx, al</span><br><span class="line"></span><br><span class="line">    ;0x1f5端口= 00000000</span><br><span class="line">    inc dx; 0x1f5</span><br><span class="line">    shr ecx, 8</span><br><span class="line">    mov al, cl ;起始扇区的高8位</span><br><span class="line">    out dx, al</span><br><span class="line">    ;起始扇区24位：00000000_00000000_00000000</span><br><span class="line">    ;-----------------------------------------</span><br><span class="line"></span><br><span class="line">    inc dx;0x1f6</span><br><span class="line">    shr ecx, 8</span><br><span class="line">    and cl, 0b1111;高4位置0</span><br><span class="line">    mov al, 0b1110_0000;</span><br><span class="line">    or al, cl; cl拼接到al后面</span><br><span class="line"></span><br><span class="line">    out dx, al;主盘 LBA模式设置</span><br><span class="line"></span><br><span class="line">    ;0x1f7端口= 0x20;表示读硬盘</span><br><span class="line">    inc dx;0x1f7</span><br><span class="line">    mov al,0x30;读硬盘</span><br><span class="line">    out dx,al</span><br><span class="line"></span><br><span class="line">    xor ecx, ecx;清空exc</span><br><span class="line">    mov cl, bl;得到读写扇区的数量</span><br><span class="line"></span><br><span class="line">    .write:</span><br><span class="line">        push cx;保存cx</span><br><span class="line">        call .writes;写一个扇区</span><br><span class="line">        call .waits;等待繁忙</span><br><span class="line">        pop cx</span><br><span class="line">        loop .write</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">    .waits:</span><br><span class="line">        mov dx, 0x1f7</span><br><span class="line">        .check:</span><br><span class="line">            in al, dx</span><br><span class="line">            jmp $+2; nop等价，直接跳下一行</span><br><span class="line">            jmp $+2; 制造一点点延迟</span><br><span class="line">            jmp $+2; </span><br><span class="line">            and al, 0b1000_0000; 与操作，只剩下7位</span><br><span class="line">            cmp al, 0b0000_0000; 比较7位，确保硬盘准备就绪</span><br><span class="line">            jnz .check</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">    .writes:</span><br><span class="line">        mov dx, 0x1f0</span><br><span class="line">        mov cx, 256;一个扇区是256字</span><br><span class="line">        .writew:</span><br><span class="line">            mov ax, [edi]</span><br><span class="line">            out dx, ax</span><br><span class="line">            jmp $+2; nop等价，直接跳下一行</span><br><span class="line">            jmp $+2; 制造一点点延迟</span><br><span class="line">            jmp $+2;</span><br><span class="line">            add edi, 2</span><br><span class="line">            loop .writew</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;实模式的打印</span><br><span class="line">print:</span><br><span class="line">    mov ah, 0xe	;功能参数</span><br><span class="line">    .next:</span><br><span class="line">        mov al, [si];字符</span><br><span class="line">        cmp al, 0	;判断是否为最后一个结尾</span><br><span class="line">        jz .done	;结尾跳转至ret</span><br><span class="line">        int 0x10	;功能调用</span><br><span class="line">        inc si		;地址-1</span><br><span class="line">        jmp .next	;继续，下一个</span><br><span class="line">    .done:</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">booting:</span><br><span class="line">    db &quot;Booting Xsys...&quot;,10,13,0; \n\r</span><br><span class="line"></span><br><span class="line">;填充</span><br><span class="line">times 510-($-$$) db 0</span><br><span class="line">db 0x55,0xaa</span><br></pre></td></tr></table></figure>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/11940789a6a0ef2814825d08d8968fbe.png" alt="image-20220217105917679" /></p>
<h1 id="操作系统实现-内核加载器"><a class="markdownIt-Anchor" href="#操作系统实现-内核加载器"></a> 操作系统实现-内核加载器</h1>
<p><strong>基本步骤</strong></p>
<ul>
<li>写内核加载器 loader</li>
<li>将loader加载到硬盘</li>
<li>在主引导扇区读入</li>
<li>检测正确性</li>
</ul>
<p><strong>x86实模式下内存布局</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20190405014442888.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phZGVzaHU=,size_16,color_FFFFFF,t_70" alt="" /></p>
<p>假设我们的bootloader如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[org 0x1000];实模式下的其实地址</span><br><span class="line">dw 0x55aa; 魔数，用于判断错误</span><br><span class="line"></span><br><span class="line">mov si,loading</span><br><span class="line">call print</span><br><span class="line"></span><br><span class="line">jmp $</span><br><span class="line"></span><br><span class="line">print:</span><br><span class="line">    mov ah, 0xe	;功能参数</span><br><span class="line">    .next:</span><br><span class="line">        mov al, [si];字符</span><br><span class="line">        cmp al, 0	;判断是否为最后一个结尾</span><br><span class="line">        jz .done	;结尾跳转至ret</span><br><span class="line">        int 0x10	;功能调用</span><br><span class="line">        inc si		;地址-1</span><br><span class="line">        jmp .next	;继续，下一个</span><br><span class="line">    .done:</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">loading:</span><br><span class="line">    db &quot;Kernel Booting Up...&quot;,10,13,0</span><br></pre></td></tr></table></figure>
<p>这是可以修改下makefile文件</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">%.bin: %.asm</span></span><br><span class="line">	nasm -f bin <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">master.img: boot.bin loader.bin</span></span><br><span class="line">	yes | bximage -hd -mode=<span class="string">&quot;flat&quot;</span> -size=60 -q master.img</span><br><span class="line">	dd if=./boot.bin of=master.img bs=512 count=1 conv=notrunc</span><br><span class="line">	dd if=./loader.bin of=master.img bs=512 count=4 seek=2 conv=notrunc</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -rf *.bin</span><br><span class="line">	rm -rf *.img</span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: usb</span></span><br><span class="line"><span class="section">usb: boot.bin /dev/sdb</span></span><br><span class="line">	sudo dd if=/dev/sdb of=tmp.bin bs=512 count=1 conv=notrunc</span><br><span class="line">	cp tmp.bin usb.bin</span><br><span class="line">	sudo rm tmp.bin</span><br><span class="line">	dd if=boot.bin of=usb.bin bs=446 count=1 conv=notrunc</span><br><span class="line">	sudo dd if=usb.bin of=/dev/sdb bs=512 count=1 conv=notrunc</span><br><span class="line">	rm usb.bin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: bochs</span></span><br><span class="line"><span class="section">bochs: master.img</span></span><br><span class="line">	bochs -q</span><br></pre></td></tr></table></figure>
<p>这样我们使用<code>make loader.bin</code>就能生成loader.bin了</p>
<p>同时：<code>dd if=./loader.bin of=master.img bs=512 count=4 seek=2 conv=notrunc</code>将loader写到第二扇区，写512*4字节大小</p>
<p>接着我们修改主程序，逻辑如下</p>
<ul>
<li>读取第二扇区到<strong>实模式下的可用内存</strong>并验证&quot;\x55\xaa&quot;校验位</li>
<li>jmp到内存执行</li>
</ul>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/6f239f390c16170e0cf5eb5338ac8ab0.png" alt="image-20220218212910546" /></p>
<p>得到新的boot.asm</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><span class="line">[org 0x7c00]</span><br><span class="line">;最简单的主程序引导程序</span><br><span class="line">;实模式的启动地址</span><br><span class="line"></span><br><span class="line">;设置屏幕模式为文本模式，清除屏幕</span><br><span class="line">mov ax,3</span><br><span class="line">int 0x10</span><br><span class="line"></span><br><span class="line">;初始化段寄存器</span><br><span class="line">mov ax,0</span><br><span class="line">mov ds,ax</span><br><span class="line">mov es,ax</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,0x7c00</span><br><span class="line"></span><br><span class="line">mov si, booting</span><br><span class="line">call print</span><br><span class="line"></span><br><span class="line">mov edi, 0x1000  ; 读到的目标内存</span><br><span class="line">mov ecx, 2       ; 起始扇区</span><br><span class="line">mov bl,4         ;扇区数量</span><br><span class="line">call read_disk</span><br><span class="line"></span><br><span class="line">cmp word [0x1000], 0x55aa</span><br><span class="line">jnz error</span><br><span class="line"></span><br><span class="line">jmp 0:0x1002</span><br><span class="line"></span><br><span class="line">;程序悬停</span><br><span class="line">jmp $</span><br><span class="line"></span><br><span class="line">;读取硬盘</span><br><span class="line">read_disk:</span><br><span class="line">    ;设置读写扇区数量</span><br><span class="line">    ;0x1f2端口=1</span><br><span class="line">    mov dx, 0x1f2</span><br><span class="line">    mov al, bl</span><br><span class="line">    out dx, al</span><br><span class="line"></span><br><span class="line">    ;-----------------------------------------</span><br><span class="line">    ;0x1f3端口= 00000000</span><br><span class="line">    inc dx; 0x1f3</span><br><span class="line">    mov al, cl ;起始扇区的前8位</span><br><span class="line">    out dx, al</span><br><span class="line"></span><br><span class="line">    ;0x1f4端口= 00000000</span><br><span class="line">    inc dx; 0x1f4</span><br><span class="line">    shr ecx, 8</span><br><span class="line">    mov al, cl ;起始扇区的中8位</span><br><span class="line">    out dx, al</span><br><span class="line"></span><br><span class="line">    ;0x1f5端口= 00000000</span><br><span class="line">    inc dx; 0x1f5</span><br><span class="line">    shr ecx, 8</span><br><span class="line">    mov al, cl ;起始扇区的高8位</span><br><span class="line">    out dx, al</span><br><span class="line">    ;起始扇区24位：00000000_00000000_00000000</span><br><span class="line">    ;-----------------------------------------</span><br><span class="line"></span><br><span class="line">    inc dx;0x1f6</span><br><span class="line">    shr ecx, 8</span><br><span class="line">    and cl, 0b1111;高4位置0</span><br><span class="line">    mov al, 0b1110_0000;</span><br><span class="line">    or al, cl; cl拼接到al后面</span><br><span class="line"></span><br><span class="line">    out dx, al;主盘 LBA模式设置</span><br><span class="line"></span><br><span class="line">    ;0x1f7端口= 0x20;表示读硬盘</span><br><span class="line">    inc dx;0x1f7</span><br><span class="line">    mov al,0x20;读硬盘</span><br><span class="line">    out dx,al</span><br><span class="line"></span><br><span class="line">    xor ecx, ecx;清空exc</span><br><span class="line">    mov cl, bl;得到读写扇区的数量</span><br><span class="line"></span><br><span class="line">    .read:</span><br><span class="line">        push cx;保存cx</span><br><span class="line">        call .waits;等待数据准备完毕</span><br><span class="line">        call .reads;读取一个扇区</span><br><span class="line">        pop cx</span><br><span class="line">        loop .read</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">    .waits:</span><br><span class="line">        mov dx, 0x1f7</span><br><span class="line">        .check:</span><br><span class="line">            in al, dx</span><br><span class="line">            jmp $+2; nop等价，直接跳下一行</span><br><span class="line">            jmp $+2; 制造一点点延迟</span><br><span class="line">            jmp $+2; </span><br><span class="line">            and al, 0b1000_1000; 与操作，只剩下3,7位</span><br><span class="line">            cmp al, 0b0000_1000; 比较3,7位，确保硬盘准备就绪</span><br><span class="line">            jnz .check</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">    .reads:</span><br><span class="line">        mov dx, 0x1f0</span><br><span class="line">        mov cx, 256;一个扇区是256字</span><br><span class="line">        .readw:</span><br><span class="line">            in ax, dx</span><br><span class="line">            jmp $+2; nop等价，直接跳下一行</span><br><span class="line">            jmp $+2; 制造一点点延迟</span><br><span class="line">            jmp $+2;</span><br><span class="line">            mov [edi], ax</span><br><span class="line">            add edi, 2</span><br><span class="line">            loop .readw</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">;写硬盘</span><br><span class="line">write_disk:</span><br><span class="line">    ;设置读写扇区数量</span><br><span class="line">    ;0x1f2端口=1</span><br><span class="line">    mov dx, 0x1f2</span><br><span class="line">    mov al, bl</span><br><span class="line">    out dx, al</span><br><span class="line"></span><br><span class="line">    ;-----------------------------------------</span><br><span class="line">    ;0x1f3端口= 00000000</span><br><span class="line">    inc dx; 0x1f3</span><br><span class="line">    mov al, cl ;起始扇区的前8位</span><br><span class="line">    out dx, al</span><br><span class="line"></span><br><span class="line">    ;0x1f4端口= 00000000</span><br><span class="line">    inc dx; 0x1f4</span><br><span class="line">    shr ecx, 8</span><br><span class="line">    mov al, cl ;起始扇区的中8位</span><br><span class="line">    out dx, al</span><br><span class="line"></span><br><span class="line">    ;0x1f5端口= 00000000</span><br><span class="line">    inc dx; 0x1f5</span><br><span class="line">    shr ecx, 8</span><br><span class="line">    mov al, cl ;起始扇区的高8位</span><br><span class="line">    out dx, al</span><br><span class="line">    ;起始扇区24位：00000000_00000000_00000000</span><br><span class="line">    ;-----------------------------------------</span><br><span class="line"></span><br><span class="line">    inc dx;0x1f6</span><br><span class="line">    shr ecx, 8</span><br><span class="line">    and cl, 0b1111;高4位置0</span><br><span class="line">    mov al, 0b1110_0000;</span><br><span class="line">    or al, cl; cl拼接到al后面</span><br><span class="line"></span><br><span class="line">    out dx, al;主盘 LBA模式设置</span><br><span class="line"></span><br><span class="line">    ;0x1f7端口= 0x20;表示读硬盘</span><br><span class="line">    inc dx;0x1f7</span><br><span class="line">    mov al,0x30;读硬盘</span><br><span class="line">    out dx,al</span><br><span class="line"></span><br><span class="line">    xor ecx, ecx;清空exc</span><br><span class="line">    mov cl, bl;得到读写扇区的数量</span><br><span class="line"></span><br><span class="line">    .write:</span><br><span class="line">        push cx;保存cx</span><br><span class="line">        call .writes;写一个扇区</span><br><span class="line">        call .waits;等待繁忙</span><br><span class="line">        pop cx</span><br><span class="line">        loop .write</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">    .waits:</span><br><span class="line">        mov dx, 0x1f7</span><br><span class="line">        .check:</span><br><span class="line">            in al, dx</span><br><span class="line">            jmp $+2; nop等价，直接跳下一行</span><br><span class="line">            jmp $+2; 制造一点点延迟</span><br><span class="line">            jmp $+2; </span><br><span class="line">            and al, 0b1000_0000; 与操作，只剩下7位</span><br><span class="line">            cmp al, 0b0000_0000; 比较7位，确保硬盘准备就绪</span><br><span class="line">            jnz .check</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">    .writes:</span><br><span class="line">        mov dx, 0x1f0</span><br><span class="line">        mov cx, 256;一个扇区是256字</span><br><span class="line">        .writew:</span><br><span class="line">            mov ax, [edi]</span><br><span class="line">            out dx, ax</span><br><span class="line">            jmp $+2; nop等价，直接跳下一行</span><br><span class="line">            jmp $+2; 制造一点点延迟</span><br><span class="line">            jmp $+2;</span><br><span class="line">            add edi, 2</span><br><span class="line">            loop .writew</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;实模式的打印</span><br><span class="line"></span><br><span class="line">print:</span><br><span class="line">    mov ah, 0xe	;功能参数</span><br><span class="line">    .next:</span><br><span class="line">        mov al, [si];字符</span><br><span class="line">        cmp al, 0	;判断是否为最后一个结尾</span><br><span class="line">        jz .done	;结尾跳转至ret</span><br><span class="line">        int 0x10	;功能调用</span><br><span class="line">        inc si		;地址-1</span><br><span class="line">        jmp .next	;继续，下一个</span><br><span class="line">    .done:</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">booting:</span><br><span class="line">    db &quot;Booting Xsys...&quot;,10,13,0; \n\r</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">    mov si, .msg</span><br><span class="line">    call print</span><br><span class="line">    hlt; CPU停止</span><br><span class="line">    jmp $</span><br><span class="line">    .msg db &quot;Kernel Booting Failed&quot;,10,13,0</span><br><span class="line"></span><br><span class="line">;填充</span><br><span class="line">times 510-($-$$) db 0</span><br><span class="line">db 0x55,0xaa</span><br></pre></td></tr></table></figure>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/301dc98f226a6cb1d49f0ed54cd5dba3.png" alt="image-20220218213058186" /></p>
<p>同时可以修改loader.asm的校验位，查看报错是否正常</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/8a89e6f7130cb0a103edb4d53f30cbc9.png" alt="image-20220218213351940" /></p>
<p><strong>更改loader.bin的时候要重新make master.img让新的loader.bin写入磁盘文件</strong></p>
<h1 id="操作系统实现-内存检测"><a class="markdownIt-Anchor" href="#操作系统实现-内存检测"></a> 操作系统实现-内存检测</h1>
<p>实模式下在进入保护模式之前要检测内存是否能够被使用，并且更好的规划内存空间。</p>
<h2 id="如何实现内存检测"><a class="markdownIt-Anchor" href="#如何实现内存检测"></a> 如何实现内存检测</h2>
<p>BIOS的<strong>int 0x15</strong>调用、<strong>0xe820</strong>子功能号、<strong>20B</strong>的<code>ards</code>(Address Range Descriptor Structure)结构体大小</p>
<p>BIOS会返回一个ards结构体到指定的<code>ards_buffer</code>中，结构体内容如图</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/1e3c39da90e482a8609177238e0eb9d6.jpeg" alt="" /></p>
<p>其中的<strong>Type</strong>字段是用来描述这段内存的类型，这里所谓的类型是说明这段内存的用途，是可以被操作系统使用，还是保留起来不能用</p>
<table>
<thead>
<tr>
<th>Type值</th>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>AddressRangeMemory</td>
<td>该内存可以被操作系统使用</td>
</tr>
<tr>
<td>2</td>
<td>AddressRangeReserved</td>
<td>内存使用中，或被系统保留，操作系统不能使用</td>
</tr>
<tr>
<td>其他</td>
<td>undefine</td>
<td>未定义</td>
</tr>
</tbody>
</table>
<h2 id="源代码实现"><a class="markdownIt-Anchor" href="#源代码实现"></a> 源代码实现</h2>
<ol>
<li>
<p>在boot中添加loader失败语句</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">error:</span><br><span class="line">    mov si, .msg</span><br><span class="line">    call print</span><br><span class="line">    hlt; CPU停止</span><br><span class="line">    jmp $</span><br><span class="line">    .msg db &quot;Kernel Booting Failed&quot;,10,13,0</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在loader最后结尾定义ards_count与ards_buffer</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ards_count:</span><br><span class="line">    dw 0</span><br><span class="line">ards_buffer:</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在loader中编写内存启动程序</p>
<p>具体调用情况如下</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/e89dce1db6034a2e761d39a0a2872f12.jpeg" alt="" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">detect_mem:</span><br><span class="line">    xor ebx, ebx</span><br><span class="line">    </span><br><span class="line">    mov ax, 0</span><br><span class="line">    mov es, ax;es:di结构体缓存位置</span><br><span class="line">    mov edi, ards_buffer;结构体内存位置</span><br><span class="line"></span><br><span class="line">    mov edx, 0x534d4150;SMAP签名</span><br><span class="line"></span><br><span class="line">.next:</span><br><span class="line">    mov eax, 0xe820 ;子功能号</span><br><span class="line">    mov ecx, 20     ;ards结构体大小，单位：字节</span><br><span class="line">    int 0x15        ;调用0x15内存检测功能</span><br><span class="line">    </span><br><span class="line">    ;若CF=1，则表示出错</span><br><span class="line">    jc error</span><br><span class="line"></span><br><span class="line">    ;否则将缓存指针指向下一个结构体</span><br><span class="line">    add di, cx</span><br><span class="line"></span><br><span class="line">    inc word [ards_count]   ;将结构体数量+1</span><br><span class="line"></span><br><span class="line">    cmp ebx, 0              ;0为检测结束</span><br><span class="line">    jnz .next</span><br><span class="line"></span><br><span class="line">    mov si, detecting</span><br><span class="line">    call print</span><br><span class="line"></span><br><span class="line">;     mov cx, [ards_buffer]   ;结构体数量</span><br><span class="line">;     mov si, 0               ;结构体指针</span><br><span class="line">; .show:</span><br><span class="line">;     mov eax, [si + ards_buffer]</span><br><span class="line">;     mov ebx, [8 + si + ards_buffer]</span><br><span class="line">;     mov edx, [16 + si + ards_buffer]</span><br><span class="line">;     add si,20</span><br><span class="line">;     xchg bx,bx</span><br><span class="line">;     loop .show              ;loop是根据cx的值循环</span><br><span class="line"></span><br><span class="line">jmp $</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>写loader报错和内存检测完成功能</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">detecting:</span><br><span class="line">    db &quot;Detecting Memeory Success...&quot;,10,13,0    </span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">    mov si, .msg</span><br><span class="line">    call print</span><br><span class="line">    hlt; CPU停止</span><br><span class="line">    jmp $</span><br><span class="line">    .msg db &quot;Kernel Booting Error&quot;,10,13,0</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>激活<code>.show</code>那段被注释的代码可以在bochs调试看到每次调用返回地ARDS结构体内容</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/3c738ea3f4f6d21757febaf5ed7697c2.png" alt="image-20220219170508060" /></p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/4f7b1e6f59de2f6602c6bbabbbc29050.png" alt="image-20220219170530368" /></p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/0fb8a372531d9aa18799c0b31ed0a292.png" alt="image-20220219170552534" /></p>
<h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2>
<p><a target="_blank" rel="noopener" href="https://wiki.osdev.org/Detecting_Memory_(x86)#E820h">x86的E820h子功能</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinolover/article/details/93886204">一步步编写操作系统 33 利用bios中断0x15子功能0xe820获取内存</a></p>
<h1 id="操作系统实现-保护模式与全局描述符"><a class="markdownIt-Anchor" href="#操作系统实现-保护模式与全局描述符"></a> 操作系统实现-保护模式与全局描述符</h1>
<p>8086 1M 内存，实模式，可以完全控制计算机</p>
<p>80286 保护模式 16位</p>
<h2 id="保护模式"><a class="markdownIt-Anchor" href="#保护模式"></a> 保护模式</h2>
<ul>
<li>IT</li>
<li>寄存器 Register / 有些寄存器只能操作系统使用</li>
<li>高速缓存 Cache</li>
<li>内存 / 描述符</li>
<li>外部设备 / 硬盘 int/out</li>
</ul>
<h2 id="全局描述符"><a class="markdownIt-Anchor" href="#全局描述符"></a> 全局描述符</h2>
<p><strong>80386 描述符</strong></p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/cf935ed6d3a5ee349c8c72d2806e3e7b.jpg" alt="" /></p>
<h2 id="全局描述符表-gdt"><a class="markdownIt-Anchor" href="#全局描述符表-gdt"></a> 全局描述符表 GDT</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">descriptor gdt[<span class="number">8192</span>];</span><br></pre></td></tr></table></figure>
<ul>
<li>0 必须全为 0-null 描述符</li>
<li>8191 通用</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lgdt [gdt_ptr]; <span class="comment">//load gdt</span></span><br><span class="line">sgdt [gdt_ptr]; <span class="comment">// save gdt</span></span><br></pre></td></tr></table></figure>
<h2 id="段选择子"><a class="markdownIt-Anchor" href="#段选择子"></a> 段选择子</h2>
<ul>
<li>只需要一个代码段</li>
<li>需要一个或多个段</li>
<li>加载到段寄存器中 / 校验特权等级</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">selector</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> RPL :<span class="number">2</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> TI :<span class="number">1</span>;	<span class="comment">//local descriptor table</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> index :<span class="number">13</span>;</span><br><span class="line">&#125; __attribute__((packed)) selector;</span><br></pre></td></tr></table></figure>
<ul>
<li>cs / ds / es /gs</li>
<li>fs / gs</li>
</ul>
<h2 id="a20线"><a class="markdownIt-Anchor" href="#a20线"></a> A20线</h2>
<p>参考第一篇文章，来源于8086最开始只有20条地址线</p>
<p>打开是修改0x92端口</p>
<h2 id="pe-protect-enable"><a class="markdownIt-Anchor" href="#pe-protect-enable"></a> PE Protect Enable</h2>
<p>cr0寄存器 0 位 置 1</p>
<h2 id="loaderasm"><a class="markdownIt-Anchor" href="#loaderasm"></a> loader.asm</h2>
<ol>
<li>
<p>准备工作，定义一些常量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">code_selector equ (1&lt;&lt;3);代码段选择子</span><br><span class="line">data_selector equ (2&lt;&lt;3);数据段选择子</span><br><span class="line">memeory_base equ 0;内存起始地址 基地址</span><br><span class="line">memeory_limit (1024 * 1024 * 1024 *4) / (1024*4) - 1; 内存界限 4G/4K -1</span><br><span class="line"></span><br><span class="line">;;;;;;;;;;;;gdt[2]</span><br><span class="line">gdt_ptr:</span><br><span class="line">    dw (gdt_end-gdt_base)-1</span><br><span class="line">    dd gdt_base</span><br><span class="line">gdt_base:</span><br><span class="line">    dd 0,0  ;null描述符</span><br><span class="line">gdt_code:</span><br><span class="line">    dw memeory_limit &amp; 0xffff   ; 段界限 0-15</span><br><span class="line">    dw memeory_base &amp; 0xffff    ; 基地址 0-16</span><br><span class="line">    db memeory_base&gt;&gt;16 &amp; 0xff  ; 基地址 0-16</span><br><span class="line">    db 0b_1_00_1_1_0_1_0        ; 存在-dlp_0-S_代码-非依从-可读-没有被访问过</span><br><span class="line">    ; 4k-32位-不是64位-avaliable_0-段界限16~19</span><br><span class="line">    db 0b_1_1_0_0_0000 | (memeory_limit &gt;&gt; 16) &amp;0xf</span><br><span class="line">    db (memeory_base &gt;&gt; 24) &amp; 0xff</span><br><span class="line">gdt_data:</span><br><span class="line">    dw memeory_limit &amp; 0xffff   ; 段界限 0-15</span><br><span class="line">    dw memeory_base &amp; 0xffff    ; 基地址 0-16</span><br><span class="line">    db memeory_base&gt;&gt;16 &amp; 0xff  ; 基地址 0-16</span><br><span class="line">    ; 存在-dlp_0-S_数据-非依从向上-可读-没有被访问过</span><br><span class="line">    db 0b_1_00_1_0_0_1_0</span><br><span class="line">    ; 4k-32位-不是64位-avaliable_0-段界限16~19</span><br><span class="line">    db 0b_1_1_0_0_0000 | (memeory_limit &gt;&gt; 16) &amp;0xf</span><br><span class="line">    db (memeory_base &gt;&gt; 24) &amp; 0xff    </span><br><span class="line">gdt_end:</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>准备保护模式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">prepare_protected_mode:</span><br><span class="line">    xchg bx,bx</span><br><span class="line">    cli;关闭中断</span><br><span class="line"></span><br><span class="line">    ; 打开A20线</span><br><span class="line">    in al, 0x92</span><br><span class="line">    or al, 0b10</span><br><span class="line">    out 0x92, al</span><br><span class="line"></span><br><span class="line">    ;加载GDT</span><br><span class="line">    lgdt [gdt_ptr]</span><br><span class="line"></span><br><span class="line">    ;启动保护模式</span><br><span class="line">    mov eax, cr0</span><br><span class="line">    or eax, 1</span><br><span class="line">    mov cr0, eax</span><br><span class="line"></span><br><span class="line">    ;用跳转刷新缓存，启用保护模式</span><br><span class="line">    jmp dword code_selector:protected_mode</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>进入保护模式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">protected_mode:</span><br><span class="line">    xchg bx, bx</span><br><span class="line">    mov ax, data_selector</span><br><span class="line">    ;初始化段寄存器</span><br><span class="line">    mov ds, ax</span><br><span class="line">    mov es, ax</span><br><span class="line">    mov fs, ax</span><br><span class="line">    mov gs, ax</span><br><span class="line">    mov ss, ax</span><br><span class="line"></span><br><span class="line">    mov esp, 0x10000; 栈顶</span><br><span class="line">    mov byte [0xb8000], &#x27;P&#x27;</span><br><span class="line">    mov byte [0x200000], &#x27;P&#x27;</span><br><span class="line"></span><br><span class="line">jmp $</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="参考-2"><a class="markdownIt-Anchor" href="#参考-2"></a> 参考</h2>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1bT4y1k7EQ">https://www.bilibili.com/video/BV1bT4y1k7EQ</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/iBinary/p/8253735.html">内核第二讲,内存保护的实现,以及知识简介,局部描述符,全局描述符.</a></p>
<h1 id="操作系统实现-进入内核"><a class="markdownIt-Anchor" href="#操作系统实现-进入内核"></a> 操作系统实现-进入内核</h1>
<p>在上一篇文章中我们实现了进入保护模式，那么下一步就是进入操作系统内核</p>
<p>这个时候我们就可以直接给寄存器赋值，能使用更大的内存地址空间</p>
<h2 id="文件整理"><a class="markdownIt-Anchor" href="#文件整理"></a> 文件整理</h2>
<p>首先对整个文件夹目录结构如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">joe1sn@ubuntu:~/Desktop/os2$ tree</span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">│   ├── boot</span><br><span class="line">│   │   ├── boot.bin</span><br><span class="line">│   │   └── loader.bin</span><br><span class="line">│   ├── kernel</span><br><span class="line">│   │   └── start.o</span><br><span class="line">│   ├── kernel.bin</span><br><span class="line">│   ├── master.img</span><br><span class="line">│   ├── system.bin</span><br><span class="line">│   └── system.map</span><br><span class="line">└── src</span><br><span class="line">    ├── bochsrc</span><br><span class="line">    ├── boot</span><br><span class="line">    │   ├── boot.asm</span><br><span class="line">    │   └── loader.asm</span><br><span class="line">    ├── build</span><br><span class="line">    ├── kernel</span><br><span class="line">    │   └── start.asm</span><br><span class="line">    └── makefile</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><strong>build</strong></p>
<p>所有最终生成的文件都会放在这里</p>
<ul>
<li>boot：MBR以及boot相关二进制文件</li>
<li>kernel：操作系统启动的相关二进制文件</li>
</ul>
</li>
<li>
<p><strong>src</strong></p>
<p>源代码</p>
<ul>
<li>bochsrc：bochs配置文件</li>
<li>boot：MBR以及boot相关源代码</li>
<li>kenel：操作系统源代码</li>
<li>makefile：项目编译文件</li>
</ul>
</li>
</ul>
<p>对应修改的makefile</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">BUILD:=../build</span><br><span class="line">SRC:=.</span><br><span class="line"></span><br><span class="line">ENTRYPOINT:=0x10000</span><br><span class="line"></span><br><span class="line"><span class="variable">$(BUILD)</span>/boot/%.bin: <span class="variable">$(SRC)</span>/boot/%.asm</span><br><span class="line">	<span class="variable">$(<span class="built_in">shell</span> mkdir -p $(<span class="built_in">dir</span> <span class="variable">$@</span>)</span>)</span><br><span class="line">	nasm -f bin <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(BUILD)</span>/kernel/%.o: <span class="variable">$(SRC)</span>/kernel/%.asm</span><br><span class="line">	<span class="variable">$(<span class="built_in">shell</span> mkdir -p $(<span class="built_in">dir</span> <span class="variable">$@</span>)</span>) </span><br><span class="line">	nasm -f elf32 <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(BUILD)</span>/kernel.bin: <span class="variable">$(BUILD)</span>/kernel/start.o</span><br><span class="line">	<span class="variable">$(<span class="built_in">shell</span> mkdir -p $(<span class="built_in">dir</span> <span class="variable">$@</span>)</span>) </span><br><span class="line">	ld -m elf_i386 -static <span class="variable">$^</span> -o <span class="variable">$@</span> -Ttext <span class="variable">$(ENTRYPOINT)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(BUILD)</span>/system.bin: <span class="variable">$(BUILD)</span>/kernel.bin</span><br><span class="line">	objcopy -O binary <span class="variable">$&lt;</span> <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(BUILD)</span>/system.map: <span class="variable">$(BUILD)</span>/kernel.bin</span><br><span class="line">	nm <span class="variable">$&lt;</span> | sort &gt; <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(BUILD)</span>/master.img: <span class="variable">$(BUILD)</span>/boot/boot.bin \</span><br><span class="line">	<span class="variable">$(BUILD)</span>/boot/loader.bin \</span><br><span class="line">	<span class="variable">$(BUILD)</span>/system.bin \</span><br><span class="line">	<span class="variable">$(BUILD)</span>/system.map \</span><br><span class="line"></span><br><span class="line">	yes | bximage -hd -mode=<span class="string">&quot;flat&quot;</span> -size=60 -q <span class="variable">$(BUILD)</span>/master.img</span><br><span class="line">	dd if=<span class="variable">$(BUILD)</span>/boot/boot.bin of=<span class="variable">$@</span> bs=512 count=1 conv=notrunc</span><br><span class="line">	dd if=<span class="variable">$(BUILD)</span>/boot/loader.bin of=<span class="variable">$@</span> bs=512 count=4 seek=2 conv=notrunc</span><br><span class="line">	dd if=<span class="variable">$(BUILD)</span>/system.bin of=<span class="variable">$@</span> bs=512 count=200 seek=10 conv=notrunc</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -rf <span class="variable">$(BUILD)</span>/*</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: usb</span></span><br><span class="line"><span class="section">usb: <span class="variable">$(BUILD)</span>/boot/boot.bin /dev/sdb</span></span><br><span class="line">	sudo dd if=/dev/sdb of=tmp.bin bs=512 count=1 conv=notrunc</span><br><span class="line">	cp tmp.bin usb.bin</span><br><span class="line">	sudo rm tmp.bin</span><br><span class="line">	dd if=<span class="variable">$(BUILD)</span>/boot/boot.bin of=usb.bin bs=446 count=1 conv=notrunc</span><br><span class="line">	sudo dd if=usb.bin of=/dev/sdb bs=512 count=1 conv=notrunc</span><br><span class="line">	rm usb.bin</span><br><span class="line"></span><br><span class="line"><span class="section">test: <span class="variable">$(BUILD)</span>/master.img</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: bochs</span></span><br><span class="line"><span class="section">bochs: <span class="variable">$(BUILD)</span>/master.img</span></span><br><span class="line">	bochs -q</span><br></pre></td></tr></table></figure>
<p>在<code>bochsrc</code>配置里面注意更改硬盘的path配置为 <strong>…/build/master.img</strong></p>
<h2 id="测试"><a class="markdownIt-Anchor" href="#测试"></a> 测试</h2>
<p><code>src/kernel/start.asm</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[bits 32]</span><br><span class="line"></span><br><span class="line">global _start</span><br><span class="line">_start:</span><br><span class="line">    mov byte [0xb8000], &#x27;k&#x27;; 表示进入了内核</span><br></pre></td></tr></table></figure>
<hr />
<p><code>src/boot/loader.asm</code></p>
<p>在protect_mode里面添加，调整栈帧后，使用代码选择子跳转到0x10000内存执行start.asm</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov esp, 0x10000; 栈顶</span><br><span class="line">mov edi, 0x10000  ; 读到的目标内存</span><br><span class="line">mov ecx, 10       ; 起始扇区</span><br><span class="line">mov bl,200         ;扇区数量</span><br><span class="line">call read_disk</span><br><span class="line">; xchg bx, bx</span><br><span class="line">jmp dword code_selector:0x10000</span><br></pre></td></tr></table></figure>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/6aae6954a206e197cc6d27d674f07488.png" alt="image-20220226112427845" /></p>
<p>在目标内存地址(<strong>0x10000</strong>)找到kernel.bin的二进制代码</p>
<h1 id="操作系统实现-elf文件格式"><a class="markdownIt-Anchor" href="#操作系统实现-elf文件格式"></a> 操作系统实现-ELF文件格式</h1>
<p>这个对CTFpwner来说比较简单</p>
<p><strong>ELF的三种格式</strong></p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/68b93ddb7a923c8953d6103c9f218c5d.png" alt="" /></p>
<p><strong>可重定位文件（Relocatable file）</strong></p>
<ul>
<li>包含了代码和数据，可以和其他目标文件链接生成一个可执行文件或共享 目标文件。</li>
</ul>
<p><strong>可执行文件（Executable File）</strong></p>
<ul>
<li>包含了可以直接执行的文件。</li>
</ul>
<p><strong>共享目标文件（Shared Object File）</strong></p>
<ul>
<li>包含了用于链接的代码和数据，分两种情况。一种是链接器将其与其他的 可重定位文件和共享目标文件链接起来，生产新的目标文件。另一种是动 态链接器将多个共享目标文件与可执行文件结合，作为进程映像的一部 分</li>
</ul>
<h2 id="内核的文件格式可执行程序"><a class="markdownIt-Anchor" href="#内核的文件格式可执行程序"></a> 内核的文件格式：可执行程序</h2>
<ol>
<li>代码段 <strong>.text section</strong>(ELF文件段)| segment CPU</li>
<li>数据
<ol>
<li><strong>.data</strong> section：已经初始化过后的数据</li>
<li><strong>.bss</strong>(Block Started by Symbol)：未初始化过的数据</li>
</ol>
</li>
</ol>
<p><strong>程序分析</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -m32 hello.c -o hello</span><br></pre></td></tr></table></figure>
<p>使用readelf objdump IDA_PRO等查看</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -e hello</span><br></pre></td></tr></table></figure>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/acb1a493cd2885fc04d50894805b403a.png" alt="image-20220226210155881" /></p>
<h2 id="相关资料"><a class="markdownIt-Anchor" href="#相关资料"></a> 相关资料</h2>
<p><a target="_blank" rel="noopener" href="https://ctf-wiki.org/executable/elf/structure/basic-info/?h=elf#elf-header">CTF-WIKI ELF 文件</a></p>
<h1 id="操作系统实现-编译链接与数据类型"><a class="markdownIt-Anchor" href="#操作系统实现-编译链接与数据类型"></a> 操作系统实现-编译链接与数据类型</h1>
<h2 id="编译链接"><a class="markdownIt-Anchor" href="#编译链接"></a> 编译链接</h2>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/e0fc3a834c630bdc9890bb1cbba92fd5.png" alt="image-20220227200844559" /></p>
<p>当GCC编译程序的时候会经历上述几步：</p>
<p>我们在项目 新建<code>src/kernel/include/xsys</code></p>
<p>在里面新建<code>include/xsys/xsys.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> XSYS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XSYS_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XSYS_MAGIC 20220227</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_init</span><span class="params">()</span>; <span class="comment">//初始化内核</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>创建<code>src/kernel/main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/xsys.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> magic = XSYS_MAGIC;         </span><br><span class="line"></span><br><span class="line"><span class="type">char</span> message[]=<span class="string">&quot;hello Xsys&quot;</span>;    <span class="comment">//.data</span></span><br><span class="line"><span class="type">char</span> buf[<span class="number">1024</span>];                 <span class="comment">//.bss</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *video = (<span class="type">char</span> *) <span class="number">0xb8000</span>; <span class="comment">//文本显示器内存位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(message); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        video[i*<span class="number">2</span>]=message[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>预处理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -m32 -E main.c -I ../include/ &gt; test.c</span><br></pre></td></tr></table></figure>
<p>这样就生成了<code>main.c</code>的与处理文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1</span> <span class="string">&quot;main.c&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;built-in&gt;&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;command-line&gt;&quot;</span></span><br><span class="line"># <span class="number">31</span> <span class="string">&quot;&lt;command-line&gt;&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;/usr/include/stdc-predef.h&quot;</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">32</span> <span class="string">&quot;&lt;command-line&gt;&quot;</span> <span class="number">2</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;main.c&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;../include/xsys/xsys.h&quot;</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_init</span><span class="params">()</span>;</span><br><span class="line"># <span class="number">2</span> <span class="string">&quot;main.c&quot;</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> magic = <span class="number">20220227</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> message[]=<span class="string">&quot;hello Xsys&quot;</span>;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *video = (<span class="type">char</span> *) <span class="number">0xb8000</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(message); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        video[i*<span class="number">2</span>]=message[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>汇编</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -m32 -S test.c &gt; test.s</span><br></pre></td></tr></table></figure>
<p>得到C转汇编的源代码文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">	.file	&quot;test.c&quot;</span><br><span class="line">	.text</span><br><span class="line">	.globl	magic</span><br><span class="line">	.data</span><br><span class="line">	.align 4</span><br><span class="line">	.type	magic, @object</span><br><span class="line">	.size	magic, 4</span><br><span class="line">magic:</span><br><span class="line">	.long	20220227</span><br><span class="line">	.globl	message</span><br><span class="line">	.align 4</span><br><span class="line">	.type	message, @object</span><br><span class="line">	.size	message, 11</span><br><span class="line">message:</span><br><span class="line">	.string	&quot;hello Xsys&quot;</span><br><span class="line">	.comm	buf,1024,32</span><br><span class="line">	.text</span><br><span class="line">	.globl	kernel_init</span><br><span class="line">	.type	kernel_init, @function</span><br><span class="line">kernel_init:</span><br><span class="line">.LFB0:</span><br><span class="line">	.cfi_startproc</span><br><span class="line">	pushl	%ebp</span><br><span class="line">	.cfi_def_cfa_offset 8</span><br><span class="line">	.cfi_offset 5, -8</span><br><span class="line">	movl	%esp, %ebp</span><br><span class="line">	.cfi_def_cfa_register 5</span><br><span class="line">	pushl	%ebx</span><br><span class="line">	subl	$16, %esp</span><br><span class="line">	.cfi_offset 3, -12</span><br><span class="line">	call	__x86.get_pc_thunk.ax</span><br><span class="line">	addl	$_GLOBAL_OFFSET_TABLE_, %eax</span><br><span class="line">	movl	$753664, -8(%ebp)</span><br><span class="line">	movl	$0, -12(%ebp)</span><br><span class="line">	jmp	.L2</span><br><span class="line">.L3:</span><br><span class="line">	movl	-12(%ebp), %edx</span><br><span class="line">	addl	%edx, %edx</span><br><span class="line">	movl	%edx, %ecx</span><br><span class="line">	movl	-8(%ebp), %edx</span><br><span class="line">	addl	%edx, %ecx</span><br><span class="line">	leal	message@GOTOFF(%eax), %ebx</span><br><span class="line">	movl	-12(%ebp), %edx</span><br><span class="line">	addl	%ebx, %edx</span><br><span class="line">	movzbl	(%edx), %edx</span><br><span class="line">	movb	%dl, (%ecx)</span><br><span class="line">	addl	$1, -12(%ebp)</span><br><span class="line">.L2:</span><br><span class="line">	movl	-12(%ebp), %edx</span><br><span class="line">	cmpl	$10, %edx</span><br><span class="line">	jbe	.L3</span><br><span class="line">	nop</span><br><span class="line">	addl	$16, %esp</span><br><span class="line">	popl	%ebx</span><br><span class="line">	.cfi_restore 3</span><br><span class="line">	popl	%ebp</span><br><span class="line">	.cfi_restore 5</span><br><span class="line">	.cfi_def_cfa 4, 4</span><br><span class="line">	ret</span><br><span class="line">	.cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">	.size	kernel_init, .-kernel_init</span><br><span class="line">	.section	.text.__x86.get_pc_thunk.ax,&quot;axG&quot;,@progbits,__x86.get_pc_thunk.ax,comdat</span><br><span class="line">	.globl	__x86.get_pc_thunk.ax</span><br><span class="line">	.hidden	__x86.get_pc_thunk.ax</span><br><span class="line">	.type	__x86.get_pc_thunk.ax, @function</span><br><span class="line">__x86.get_pc_thunk.ax:</span><br><span class="line">.LFB1:</span><br><span class="line">	.cfi_startproc</span><br><span class="line">	movl	(%esp), %eax</span><br><span class="line">	ret</span><br><span class="line">	.cfi_endproc</span><br><span class="line">.LFE1:</span><br><span class="line">	.ident	&quot;GCC: (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0&quot;</span><br><span class="line">	.section	.note.GNU-stack,&quot;&quot;,@progbits</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>编译</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">as -32 test.s  -o test.o</span><br></pre></td></tr></table></figure>
<p>将<code>test.s</code>编译位32位的ELF文件<code>test.o</code></p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/35f1daf28588a9210edf4c53d4a711d6.png" alt="image-20220227201912329" /></p>
<p>这个时候使用readelf查看文件结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -a test.o</span><br></pre></td></tr></table></figure>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/bdb4924c9b7fafe694c58bd390c7ac0f.png" alt="image-20220227202042024" /></p>
<p>会看到这些段都是没有地址的，当我们链接才能找到准确的地址</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/f3081e58f406dfd89b110ffbafa36160.png" alt="image-20220227202209131" /></p>
<p>同时我们的变量也加入到了符号表中</p>
</li>
<li>
<p>链接</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ld -m elf_i386 -static test.o -o test.out -e kernel_init</span><br></pre></td></tr></table></figure>
<p>将<code>test.o</code>文件按照elf i386的格式链接到库文件，同时声明外部函数kernel_init</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/d1a54cb24dc42cecf457fe97c309e1e0.png" alt="image-20220227202513855" /></p>
<p>这个时候已经有了Addr了，但是启动还是会出错，因为我们之前定义的是在0x10000出启动程序</p>
</li>
<li>
<p>gcc直接编译</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -m32 main.c -I ../include/ -o main.out -e kernel_init -nostartfiles</span><br></pre></td></tr></table></figure>
<p>-nostartfiles：类似与windows里面的入口点不使用main</p>
</li>
</ul>
<p><strong>写入到操作系统</strong></p>
<p>添加一个<code>kernel/%.c</code>编译到<code>kernel/%.o</code>的makefile</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(BUILD)</span>/kernel/%.o: <span class="variable">$(SRC)</span>/kernel/%.c</span><br><span class="line">	<span class="variable">$(<span class="built_in">shell</span> mkdir -p $(<span class="built_in">dir</span> <span class="variable">$@</span>)</span>) </span><br><span class="line">	gcc <span class="variable">$(CFLAGS)</span> <span class="variable">$(DEBUG)</span> <span class="variable">$(INCLUDE)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span> </span><br></pre></td></tr></table></figure>
<p>同时可以加还是那个编译参数</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DEBUG:= -g</span><br><span class="line">CFLAGS:= -m32</span><br><span class="line">INCLUDE:= -I<span class="variable">$(SRC)</span>/<span class="keyword">include</span></span><br></pre></td></tr></table></figure>
<p>完整的makefile如下</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">BUILD:=../build</span><br><span class="line">SRC:=.</span><br><span class="line">ENTRYPOINT:=0x10000</span><br><span class="line"></span><br><span class="line">CFLAGS:= -m32</span><br><span class="line"></span><br><span class="line">DEBUG:= -g</span><br><span class="line">INCLUDE:= -I<span class="variable">$(SRC)</span>/<span class="keyword">include</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(BUILD)</span>/boot/%.bin: <span class="variable">$(SRC)</span>/boot/%.asm</span><br><span class="line">	<span class="variable">$(<span class="built_in">shell</span> mkdir -p $(<span class="built_in">dir</span> <span class="variable">$@</span>)</span>)</span><br><span class="line">	nasm -f bin <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(BUILD)</span>/kernel/%.o: <span class="variable">$(SRC)</span>/kernel/%.asm</span><br><span class="line">	<span class="variable">$(<span class="built_in">shell</span> mkdir -p $(<span class="built_in">dir</span> <span class="variable">$@</span>)</span>) </span><br><span class="line">	nasm -f elf32 <span class="variable">$(DEBUG)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable">$(BUILD)</span>/kernel/%.o: <span class="variable">$(SRC)</span>/kernel/%.c</span><br><span class="line">	<span class="variable">$(<span class="built_in">shell</span> mkdir -p $(<span class="built_in">dir</span> <span class="variable">$@</span>)</span>) </span><br><span class="line">	gcc <span class="variable">$(CFLAGS)</span> <span class="variable">$(DEBUG)</span> <span class="variable">$(INCLUDE)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span> </span><br><span class="line"></span><br><span class="line"><span class="variable">$(BUILD)</span>/kernel.bin: <span class="variable">$(BUILD)</span>/kernel/start.o \</span><br><span class="line">	 <span class="variable">$(BUILD)</span>/kernel/main.o</span><br><span class="line">	</span><br><span class="line">	<span class="variable">$(<span class="built_in">shell</span> mkdir -p $(<span class="built_in">dir</span> <span class="variable">$@</span>)</span>) </span><br><span class="line">	ld -m elf_i386 -static <span class="variable">$^</span> -o <span class="variable">$@</span> -Ttext <span class="variable">$(ENTRYPOINT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#objcpoy加载bss段展开文件</span></span><br><span class="line"><span class="variable">$(BUILD)</span>/system.bin: <span class="variable">$(BUILD)</span>/kernel.bin</span><br><span class="line">	objcopy -O binary <span class="variable">$&lt;</span> <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(BUILD)</span>/system.map: <span class="variable">$(BUILD)</span>/kernel.bin</span><br><span class="line">	nm <span class="variable">$&lt;</span> | sort &gt; <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(BUILD)</span>/master.img: <span class="variable">$(BUILD)</span>/boot/boot.bin \</span><br><span class="line">	<span class="variable">$(BUILD)</span>/boot/loader.bin \</span><br><span class="line">	<span class="variable">$(BUILD)</span>/system.bin \</span><br><span class="line">	<span class="variable">$(BUILD)</span>/system.map \</span><br><span class="line"></span><br><span class="line">	yes | bximage -hd -mode=<span class="string">&quot;flat&quot;</span> -size=60 -q <span class="variable">$(BUILD)</span>/master.img</span><br><span class="line">	dd if=<span class="variable">$(BUILD)</span>/boot/boot.bin of=<span class="variable">$@</span> bs=512 count=1 conv=notrunc</span><br><span class="line">	dd if=<span class="variable">$(BUILD)</span>/boot/loader.bin of=<span class="variable">$@</span> bs=512 count=4 seek=2 conv=notrunc</span><br><span class="line">	dd if=<span class="variable">$(BUILD)</span>/system.bin of=<span class="variable">$@</span> bs=512 count=200 seek=10 conv=notrunc</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -rf <span class="variable">$(BUILD)</span>/*</span><br><span class="line"></span><br><span class="line"><span class="section">test: <span class="variable">$(BUILD)</span>/master.img</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: bochs</span></span><br><span class="line"><span class="section">bochs: <span class="variable">$(BUILD)</span>/master.img</span></span><br><span class="line">	bochs -q</span><br></pre></td></tr></table></figure>
<p>再修改下<code>kernel/start.asm</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[bits 32]</span><br><span class="line"></span><br><span class="line">extern kernel_init</span><br><span class="line"></span><br><span class="line">global _start</span><br><span class="line">_start:</span><br><span class="line">    ; mov byte [0xb8000], &#x27;k&#x27;; 表示进入了内核</span><br><span class="line">    xchg bx, bx</span><br><span class="line">    call kernel_init</span><br><span class="line">    xchg bx, bx</span><br><span class="line"></span><br><span class="line">    jmp $</span><br></pre></td></tr></table></figure>
<p><strong>make test</strong>一下没问题后<strong>make clean</strong>再<strong>make bochs</strong>调试</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/d3ebe55d2646cf8fc96645f7b1551d03.png" alt="image-20220227203208750" /></p>
<p>进入<code>kernel_init</code></p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/fdefbdb6473743c6e3a1218c6a362548.png" alt="image-20220227203253923" /></p>
<p>显示输出被覆盖，说明调用成功</p>
<h2 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h2>
<p>在操作系统中，数据类型都是被定义好的</p>
<p>新建<code>include/xsys/types.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> XSYS_TYPES_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XSYS_TYPES_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EOF -1  <span class="comment">//end of file</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULL 0  <span class="comment">//空指针</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bool _Bool</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> true 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> false 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _packed __attribute__((packed))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">size_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> int8;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">short</span> int16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> int32;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> int64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u32;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> u64;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>新建<code>test/test.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">descriptor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> limit_low;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> base_low : <span class="number">24</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> type : <span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> segment : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> DPL : <span class="number">2</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> present : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> limit_high :<span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> avaliable : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> long_mode : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> big : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> granulartity : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> base_high;</span><br><span class="line">&#125; __attribute__((packed)) descriptor;</span><br><span class="line"><span class="comment">// &#125;descriptor;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size of u8 %d\n&quot;</span>, <span class="keyword">sizeof</span>(u8));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size of u16 %d\n&quot;</span>, <span class="keyword">sizeof</span>(u16));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size of u32 %d\n&quot;</span>, <span class="keyword">sizeof</span>(u32));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size of u64 %d\n&quot;</span>, <span class="keyword">sizeof</span>(u64));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size of descriptor %d\n&quot;</span>, <span class="keyword">sizeof</span>(descriptor));</span><br><span class="line"></span><br><span class="line">    descriptor des;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>__attribute__</code>用于不对齐变量来构造特殊结构体，使用vscode自带的调试可以看出</li>
</ul>
<h1 id="操作系统实现-qemu调试与vmdk"><a class="markdownIt-Anchor" href="#操作系统实现-qemu调试与vmdk"></a> 操作系统实现-qemu调试与vmdk</h1>
<h2 id="qemu调试"><a class="markdownIt-Anchor" href="#qemu调试"></a> qemu调试</h2>
<p><strong>其实你也可以用bochs-gdb</strong>，但是我觉得bochs-gdb要重新配置一些文件很麻烦，还是vm+vscode调试方便些，所以这里需要用到qemu</p>
<ul>
<li>
<p>安装qemu</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install qemu</span><br><span class="line">sudo apt-get install qemu-extract</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在qemu中启动系统</p>
<p><code>src/makefile</code>中，添加</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: qemu</span></span><br><span class="line"><span class="section">qemu: <span class="variable">$(BUILD)</span>/master.img</span></span><br><span class="line">	qemu-system-i386 \</span><br><span class="line">	-m 32M \</span><br><span class="line">	-boot c \</span><br><span class="line">	-hda <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure>
<p>使用i386构架的CPU，内存位32MB，存储是硬盘(boot -c)，选择的硬盘文件是<code>$(BUILD)/master.img</code></p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/95431332c5b9ae45155f4001e10a9e5f.png" alt="image-20220301102103867" /></p>
</li>
<li>
<p>使用qemu调试</p>
<p><code>src/makefile</code>中，添加</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: qemug</span></span><br><span class="line"><span class="section">qemug: <span class="variable">$(BUILD)</span>/master.img</span></span><br><span class="line">	qemu-system-i386 \</span><br><span class="line">	-s -S \</span><br><span class="line">	-m 32M \</span><br><span class="line">	-boot c \</span><br><span class="line">	-hda <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure>
<p>这里-s -S是调试，远程调试，远程调试端口是1234</p>
<p>为了测试，使用vscode在<code>src/kernel/main.c</code>中下个断点</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/b7faa5872436b08e351982f8284fedea.png" alt="image-20220301102224910" /></p>
<p>在vm中启用qemu调试，qemu等待debugger启动调试</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/30c649c8b5488d8279bf64b52b669f00.png" alt="image-20220301102320785" /></p>
<p>之后可以在vscode中直接使用<strong>F5</strong>调试，但是<code>launch.json</code>中的<code>program</code>要改为**${workspaceFolder}/build/kernel.bin**</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/b9a15defb8495b73f916ac3d070d9f27.png" alt="image-20220301102545924" /></p>
<p>F5开始调试</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/8c9c9a27b75c01bc75077924fe66f628.png" alt="image-20220301102624581" /></p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/223553e6c5f5c1a90c5ba9d3474e4efe.png" alt="image-20220301102653151" /></p>
<p>接着继续</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/fca60dd06a010ff375073cb4e2c7a81b.png" alt="image-20220301102745327" /></p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/e1f8723d051418d5afdd69fdbe76816a.png" alt="image-20220301102731362" /></p>
</li>
</ul>
<h2 id="vmdk"><a class="markdownIt-Anchor" href="#vmdk"></a> vmdk</h2>
<p>使用qemu的一些功能可以把我们的<strong>master.img</strong>转换成<strong>master.vmdk</strong>从而在vmware上运行</p>
<p>在<code>src/makefile</code>中新增</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(BUILD)</span>/master.vmdk: <span class="variable">$(BUILD)</span>/master.img</span><br><span class="line">	qemu-img convert -O vmdk <span class="variable">$&lt;</span> <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: vmdk</span></span><br><span class="line"><span class="section">vmdk: <span class="variable">$(BUILD)</span>/master.vmdk</span></span><br></pre></td></tr></table></figure>
<p>得到vmdk文件过后直接创建虚拟机就行了</p>
<p>在创建虚拟机是要注意：</p>
<ul>
<li>Linux版本最好&gt;=4，不然\xaa\x55校验过不了</li>
<li>虚拟磁盘类型选择IDE</li>
<li>使用现有虚拟磁盘，选择刚才生成的vmdk文件就行</li>
</ul>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/65730184c102f33dd3cf5a285f82bca6.png" alt="image-20220301103325567" /></p>
<h1 id="操作系统实现-gcc与汇编"><a class="markdownIt-Anchor" href="#操作系统实现-gcc与汇编"></a> 操作系统实现-gcc与汇编</h1>
<p>在之前的test文件中新建一个<code>hello.c</code>和<code>src/test/makefile</code></p>
<p>hello.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> message[] = <span class="string">&quot;hello world\n&quot;</span>;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,message);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>makefile</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS:= -m32</span><br><span class="line"><span class="comment"># CFLAGS+= -fno-builtin 	#不需要gcc内置函数</span></span><br><span class="line"><span class="comment"># CFLAGS+= -nostdinc 		#不用标准头文件</span></span><br><span class="line"><span class="comment"># CFLAGS+= -nostdlib		#不需要标准库</span></span><br><span class="line"><span class="comment"># CFLAGS+= -fno-pic		#不需要位置无关代码</span></span><br><span class="line"><span class="comment"># CFLAGS+= -fno-pie		#关闭PIE保护</span></span><br><span class="line"><span class="comment"># CFLAGS+= -fno-stack-protector #不需要栈保护</span></span><br><span class="line">CFLAGS:=<span class="variable">$(<span class="built_in">strip</span> $&#123;CFLAGS&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: hello.s</span></span><br><span class="line"><span class="section">hello.s: hello.c</span></span><br><span class="line">	gcc <span class="variable">$(CFLAGS)</span> -S <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在生成了.s汇编文件中，会发现有**.cfi**开始投的段</p>
<ul>
<li>
<p><strong>.cfi</strong>：Call Frame Information（调用栈帧信息）</p>
<p>一种DWARF信息，用于调试，获得调用异常</p>
<p><code>-fno-asynchronous-unwind-tables</code>，不需要cfi信息</p>
</li>
<li>
<p><strong>call  __x86.get_pc_thunk.ax</strong>：生成PIC的辅助函数，获取调用时EIP的值，功能上相当于<code>mov eax, eip</code>，接着得到 <strong>_GLOBAL_OFFSET_TABLE_</strong></p>
<p>PIC：postion independent code（位置无关代码）</p>
<p><code>-fno-pic</code>，不需要位置无关代码</p>
</li>
<li>
<p>** _GLOBAL_OFFSET_TABLE_ **：里面存储了符号地址信息</p>
</li>
<li>
<p><code>.ident &quot;GCC: (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0：</code></p>
<p><strong>.ident</strong>：GCC的版本信息</p>
<p><code>-Qn</code>：去掉GCC版本信息</p>
</li>
<li>
<p><code>andl  $-16, %esp</code>：栈对齐</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>16</mn><mo>=</mo><mn>0</mn><mo>−</mo><mn>16</mn><mo>=</mo><mn>0</mn><mo>−</mo><mn>10</mn><mi>H</mi><mo>=</mo><mi>f</mi><mi>f</mi><mi>f</mi><mi>f</mi><mi>f</mi><mi>f</mi><mi>f</mi><mn>0</mn><mi>H</mi></mrow><annotation encoding="application/x-tex">-16 = 0 - 16 = 0-10H = fffffff0H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord">0</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span>  与操作过后就有只剩最后四位，这样就将栈16字节对齐</p>
<p>字节对齐访问内存更加高效（使用更少的时钟周期）</p>
<ul>
<li>数据访问的过程：
<ol>
<li>待读数据的内存地址放入地址总线</li>
<li>修改READ标志启用断言，及没有正确就会出发halt暂停</li>
<li>等待内存控制器响应</li>
<li>把数据从数据总线复制到目标地址</li>
</ol>
</li>
<li>由上：若不对齐访问的话，会多传几次地址才能得到需要的值，从而造成更多的时钟周期浪费</li>
</ul>
<p><code>-mpreferred-stack-boundary=2</code>：取消栈对齐</p>
</li>
<li>
<p>栈帧</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pushl	%ebp</span><br><span class="line">movl	%esp, %ebp</span><br><span class="line">...</span><br><span class="line">leave	;等效于</span><br><span class="line">		;mov %ebp, %esp</span><br><span class="line">		;pop %ebp</span><br></pre></td></tr></table></figure>
<p><code>-fomit-frame-pointer</code>：去掉栈帧</p>
</li>
</ul>
<p>最后剩下的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">	.file	&quot;hello.c&quot;		;文件名</span><br><span class="line">	.text					;代码段</span><br><span class="line">	.globl	message			;将message导出</span><br><span class="line">	.data					;数据段</span><br><span class="line">	.align 4				;按4字节对齐</span><br><span class="line">	.type	message, @object;类型</span><br><span class="line">	.size	message, 13		;尺寸</span><br><span class="line">message:</span><br><span class="line">	.string	&quot;hello world\n&quot;</span><br><span class="line">	.comm	buf,1024,32</span><br><span class="line">	.text					;代码段</span><br><span class="line">	.globl	main			;main函数</span><br><span class="line">	.type	main, @function</span><br><span class="line">main:</span><br><span class="line">	pushl	$message		;&amp;message压入栈中</span><br><span class="line">	call	puts</span><br><span class="line">	addl	$4, %esp		;恢复栈</span><br><span class="line">	movl	$0, %eax		;函数返回值，存储在eax中</span><br><span class="line">	ret						;函数调用返回</span><br><span class="line">	.size	main, .-main	;main函数尺寸</span><br><span class="line">	.section	.note.GNU-stack,&quot;&quot;,@progbits	;标及栈不可运行，NX保护</span><br></pre></td></tr></table></figure>
<p><strong>vscode中调试汇编</strong></p>
<p>在设置里面搜索break，打开允许所有文件断点</p>
<p>在<code>task.json</code>中 <strong>“type”: “shell”</strong></p>
<p>![](<a target="_blank" rel="noopener" href="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/dbc59407db30d4cf22704e34ea41cfc3.png">https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/dbc59407db30d4cf22704e34ea41cfc3.png</a></p>
<h1 id="操作系统实现-堆栈函数变量传参"><a class="markdownIt-Anchor" href="#操作系统实现-堆栈函数变量传参"></a> 操作系统实现-堆栈/函数/变量/传参</h1>
<h2 id="堆栈和函数"><a class="markdownIt-Anchor" href="#堆栈和函数"></a> 堆栈和函数</h2>
<p>其实之前CTF里面的文章讲过一些了</p>
<p><a target="_blank" rel="noopener" href="https://blog.joe1sn.top/2021/01/16/heap_learning_part0-%E5%A0%86%E5%9F%BA%E7%A1%80/">https://blog.joe1sn.top/2021/01/16/heap_learning_part0-堆基础/</a></p>
<p><strong>栈</strong>：是一个很重要的数据结构，特征：后进先出</p>
<img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/1734a70ce4fcba0d0ebb38ca5082f201.png" style="zoom:33%;" />
<ul>
<li>
<p>堆栈是一块内存区域</p>
</li>
<li>
<p>栈顶指针是在<code>ss:esp</code>寄存器中，栈底在高地址，向下增长</p>
<img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/medium/89f103688274849a01a2515dda9463df.png" style="zoom:50%;" />
<p>创建<code>src/test/call.asm</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[bits 32]</span><br><span class="line"></span><br><span class="line">extern exit</span><br><span class="line"></span><br><span class="line">global main</span><br><span class="line">main:</span><br><span class="line">    push 0      ;传递参数</span><br><span class="line">    call exit</span><br></pre></td></tr></table></figure>
<p>在<code>src/.vscode/launch.json</code>添加调试参数使用NASM汇编格式</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;NASM Build Debugger&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/build/kernel.bin&quot;,</span></span><br><span class="line">    <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.out&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;setupCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;为 gdb 启用整齐打印&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-enable-pretty-printing&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;将反汇编风格设置为 Intel&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-gdb-set disassembly-flavor intel&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;preLaunchTask&quot;</span><span class="punctuation">:</span> <span class="string">&quot;NASM Build Debugger&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;miDebuggerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/gdb&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>修改<code>./.vscode/task.json</code>添加如下配置</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shell&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;NASM Build Debugger&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">              <span class="string">&quot;/usr/bin/nasm&quot;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="string">&quot;-f&quot;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="string">&quot;elf32&quot;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.o&quot;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="string">&quot;;&quot;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="string">&quot;/usr/bin/gcc&quot;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="string">&quot;-fdiagnostics-color=always&quot;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="string">&quot;-m32&quot;</span><span class="punctuation">,</span> <span class="comment">//32 位程序</span></span><br><span class="line">              <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="string">&quot;-static&quot;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="string">&quot;-I$&#123;workspaceFolder&#125;/src/include&quot;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.o&quot;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.out&quot;</span></span><br><span class="line">          <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">              <span class="string">&quot;$gcc&quot;</span></span><br><span class="line">          <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="string">&quot;调试器生成的任务。&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>32位汇编到object再用gcc到elf.out，调试表丢失</p>
<p>我用同样的方法试了一个32位的helloworld，也是无法调试，objdump看有file line addr信息，gdb也是which has no line number infomation，然后vscode调试的时候多下几个断点才能起到效果.很烦人</p>
<p>所以这里我直接猛下断点</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/9302f6e8f60d75385f0a15eacb65c3d2.png" alt="image-20220303101005999" /></p>
<p>经过编译与链接，最终的elf文件如下</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/724bcc74a57b6a06d81ecad5f976455c.png" alt="image-20220303101911061" /></p>
<p>在调试控制台使用如下命令查看栈信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-exec display/8xw $sp</span><br></pre></td></tr></table></figure>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/bf6e01fbcebd7972bc66de1b7ec8713b.png" alt="image-20220303101523045" /></p>
<p>（图片被处理过）可以看到栈的生长方向，还有相关的一些值</p>
<ul>
<li><strong>push</strong>：入栈</li>
<li><strong>pop</strong>：出栈</li>
<li><strong>pusha</strong>：压入8个寄存器</li>
<li><strong>popa</strong>：弹出7个寄存器，忽略<strong>esp</strong></li>
</ul>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/a244b1216e7ed6e1301379bf8ae7ad60.png" alt="image-20220303102410339" /></p>
<p><strong>函数</strong></p>
<ul>
<li><strong>call</strong>：函数返回的下一条指令的返回地址压入栈</li>
<li><strong>ret</strong>：栈顶弹出到<strong>EIP</strong></li>
<li><strong>call</strong>与<strong>ret</strong>无关</li>
</ul>
<h2 id="变量与传参"><a class="markdownIt-Anchor" href="#变量与传参"></a> 变量与传参</h2>
<p>新建<code>src/test/param.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> z = x + y;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> c = add(a,b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写makefile</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: param.s</span></span><br><span class="line"><span class="section">param.s: param.c</span></span><br><span class="line">	gcc <span class="variable">$(CFLAGS)</span> -S <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>
<p>最后生成的<code>src/test/param.asm</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">	.file	&quot;param.c&quot;</span><br><span class="line">	.text</span><br><span class="line">	.globl	add</span><br><span class="line">	.type	add, @function</span><br><span class="line">add:</span><br><span class="line">	pushl	%ebp</span><br><span class="line">	movl	%esp, %ebp</span><br><span class="line">	</span><br><span class="line">	subl	$4, %esp		;一个局部变量</span><br><span class="line">	movl	8(%ebp), %edx	;a</span><br><span class="line">	movl	12(%ebp), %eax	;b</span><br><span class="line">	addl	%edx, %eax		;相加，eax+=edx</span><br><span class="line">	movl	%eax, -4(%ebp)	;z = x + y</span><br><span class="line">	movl	-4(%ebp), %eax	;eax = z</span><br><span class="line">	</span><br><span class="line">	leave</span><br><span class="line">	ret</span><br><span class="line">	.size	add, .-add</span><br><span class="line">	.globl	main</span><br><span class="line">	.type	main, @function</span><br><span class="line">main:</span><br><span class="line">	pushl	%ebp</span><br><span class="line">	movl	%esp, %ebp	;保存栈帧</span><br><span class="line">	</span><br><span class="line">	subl	$12, %esp	;保存12字节，及3个局部变量</span><br><span class="line">	movl	$5, -12(%ebp);a</span><br><span class="line">	movl	$3, -8(%ebp);b</span><br><span class="line">	;-----------------------------32位传参准备</span><br><span class="line">	pushl	-8(%ebp)	;b</span><br><span class="line">	pushl	-12(%ebp)	;a</span><br><span class="line">	call	add</span><br><span class="line">	addl	$8, %esp	;esp恢复</span><br><span class="line">	movl	%eax, -4(%ebp);c=add(a,b)</span><br><span class="line">	movl	$0, %eax	;返回值存储在eax中(return 0)</span><br><span class="line">	</span><br><span class="line">	leave				;回复栈帧</span><br><span class="line">	ret</span><br><span class="line">	.size	main, .-main</span><br><span class="line">	.section	.note.GNU-stack,&quot;&quot;,@progbits</span><br></pre></td></tr></table></figure>
<ul>
<li>64位：寄存器传参</li>
<li>32位：栈传参</li>
</ul>
<p>取消栈帧</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">	.file	&quot;param.c&quot;</span><br><span class="line">	.text</span><br><span class="line">	.globl	add</span><br><span class="line">	.type	add, @function</span><br><span class="line">add:</span><br><span class="line">	subl	$4, %esp</span><br><span class="line">	movl	8(%esp), %edx</span><br><span class="line">	movl	12(%esp), %eax</span><br><span class="line">	addl	%edx, %eax</span><br><span class="line">	movl	%eax, (%esp)</span><br><span class="line">	movl	(%esp), %eax</span><br><span class="line">	addl	$4, %esp</span><br><span class="line">	ret</span><br><span class="line">	.size	add, .-add</span><br><span class="line">	.globl	main</span><br><span class="line">	.type	main, @function</span><br><span class="line">main:</span><br><span class="line">	subl	$12, %esp</span><br><span class="line">	movl	$5, (%esp)</span><br><span class="line">	movl	$3, 4(%esp)</span><br><span class="line">	pushl	4(%esp)</span><br><span class="line">	pushl	4(%esp)</span><br><span class="line">	call	add</span><br><span class="line">	addl	$8, %esp</span><br><span class="line">	movl	%eax, 8(%esp)</span><br><span class="line">	movl	$0, %eax</span><br><span class="line">	addl	$12, %esp</span><br><span class="line">	ret</span><br><span class="line">	.size	main, .-main</span><br><span class="line">	.section	.note.GNU-stack,&quot;&quot;,@progbits</span><br></pre></td></tr></table></figure>
<p><strong>堆：<a target="_blank" rel="noopener" href="https://blog.joe1sn.top/2021/01/16/heap_learning_part0-%E5%A0%86%E5%9F%BA%E7%A1%80/">https://blog.joe1sn.top/2021/01/16/heap_learning_part0-堆基础/</a></strong></p>
<h1 id="操作系统实现-io与字符串处理"><a class="markdownIt-Anchor" href="#操作系统实现-io与字符串处理"></a> 操作系统实现-IO与字符串处理</h1>
<blockquote>
<p>代码来源：<a target="_blank" rel="noopener" href="https://github.com/StevenBaby/onix">https://github.com/StevenBaby/onix</a></p>
<p>相关课程：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1gR4y1u7or">https://www.bilibili.com/video/BV1gR4y1u7or</a></p>
<p>感谢B站UP：<a target="_blank" rel="noopener" href="https://space.bilibili.com/491131440">踌躇月光</a> 带来的相关代码和教程</p>
</blockquote>
<h2 id="inputoutput"><a class="markdownIt-Anchor" href="#inputoutput"></a> Input/Output</h2>
<p>参考之前的硬盘读写，那么我们需要对一些端口进行操作</p>
<p>CRT：阴极射线管</p>
<ul>
<li>地址寄存器：0x3D4</li>
<li>数据寄存器：0x3D5</li>
<li>光标位置：高位0xE</li>
<li>光标位置：高位0xF</li>
</ul>
<p><code>src/include/xsys/io.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> XSYS_IO_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XSYS_IO_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> u8 <span class="title function_">inb</span><span class="params">(u16 port)</span>;    <span class="comment">//输入一个字节</span></span><br><span class="line"><span class="keyword">extern</span> u16 <span class="title function_">inw</span><span class="params">(u16 port)</span>;   <span class="comment">//输入一个字</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">inb</span><span class="params">(u16 port, u8 value)</span>;    <span class="comment">//输出一个字节</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">inw</span><span class="params">(u16 port, u16 value)</span>;   <span class="comment">//输出一个字</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>src/kernel/io.asm</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">[bits 32]</span><br><span class="line"></span><br><span class="line">section .text; 代码段</span><br><span class="line"></span><br><span class="line">global inb ; 将 inb 导出</span><br><span class="line">inb:</span><br><span class="line">    push ebp; </span><br><span class="line">    mov ebp, esp ; 保存帧</span><br><span class="line"></span><br><span class="line">    xor eax, eax ; 将 eax 清空</span><br><span class="line">    mov edx, [ebp + 8]; port </span><br><span class="line">    in al, dx; 将端口号 dx 的 8 bit 输入到 al</span><br><span class="line"></span><br><span class="line">    jmp $+2 ; 一点点延迟</span><br><span class="line">    jmp $+2 ; 一点点延迟</span><br><span class="line">    jmp $+2 ; 一点点延迟</span><br><span class="line"></span><br><span class="line">    leave ; 恢复栈帧</span><br><span class="line">    ret</span><br><span class="line">global outb</span><br><span class="line">outb:</span><br><span class="line">    push ebp; </span><br><span class="line">    mov ebp, esp ; 保存帧</span><br><span class="line"></span><br><span class="line">    mov edx, [ebp + 8]; port </span><br><span class="line">    mov eax, [ebp + 12]; value</span><br><span class="line">    out dx, al; 将 al 中的 8 bit 输入出到 端口号 dx</span><br><span class="line"></span><br><span class="line">    jmp $+2 ; 一点点延迟</span><br><span class="line">    jmp $+2 ; 一点点延迟</span><br><span class="line">    jmp $+2 ; 一点点延迟</span><br><span class="line"></span><br><span class="line">    leave ; 恢复栈帧</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">global inw</span><br><span class="line">inw:</span><br><span class="line">    push ebp; </span><br><span class="line">    mov ebp, esp ; 保存帧</span><br><span class="line"></span><br><span class="line">    xor eax, eax ; 将 eax 清空</span><br><span class="line">    mov edx, [ebp + 8]; port </span><br><span class="line">    in ax, dx; 将端口号 dx 的 16 bit 输入到 ax</span><br><span class="line"></span><br><span class="line">    jmp $+2 ; 一点点延迟</span><br><span class="line">    jmp $+2 ; 一点点延迟</span><br><span class="line">    jmp $+2 ; 一点点延迟</span><br><span class="line"></span><br><span class="line">    leave ; 恢复栈帧</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">global outw</span><br><span class="line">outw:</span><br><span class="line">    push ebp        ; </span><br><span class="line">    mov ebp, esp    ; 保存帧</span><br><span class="line"></span><br><span class="line">    mov edx, [ebp + 8]; port </span><br><span class="line">    mov eax, [ebp + 12]; value</span><br><span class="line">    out dx, ax; 将 ax 中的 16 bit 输入出到 端口号 dx</span><br><span class="line"></span><br><span class="line">    jmp $+2 ; 一点点延迟</span><br><span class="line">    jmp $+2 ; 一点点延迟</span><br><span class="line">    jmp $+2 ; 一点点延迟</span><br><span class="line"></span><br><span class="line">    leave ; 恢复栈帧</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<p><code>src/kernel/main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/xsys.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRT_ADDR_REG 0x3d4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRT_DATA_REG 0x3d5</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRT_CURSOR_H 0xeu</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRT_CURSOR_L 0xf</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//获得当前光标坐标</span></span><br><span class="line">    outb(CRT_ADDR_REG,CRT_CURSOR_H);    <span class="comment">//将高位导出到地址端口</span></span><br><span class="line">    u16 pos = inb(CRT_DATA_REG) &lt;&lt; <span class="number">8</span>;   <span class="comment">//移到pos高位</span></span><br><span class="line">    outb(CRT_ADDR_REG,CRT_CURSOR_L);    <span class="comment">//将低位导出到地址端口</span></span><br><span class="line">    pos |= inb(CRT_DATA_REG);           <span class="comment">//移到pos低位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改当前光标坐标</span></span><br><span class="line">    outb(CRT_ADDR_REG,CRT_CURSOR_H);</span><br><span class="line">    outb(CRT_DATA_REG,<span class="number">0</span>);</span><br><span class="line">    outb(CRT_ADDR_REG,CRT_CURSOR_L);</span><br><span class="line">    outb(CRT_DATA_REG,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>src/makefile</code></p>
<p>添加<code>io.o</code>依赖</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(BUILD)</span>/kernel.bin: \</span><br><span class="line">	<span class="variable">$(BUILD)</span>/kernel/start.o \</span><br><span class="line">	<span class="variable">$(BUILD)</span>/kernel/main.o \</span><br><span class="line">	<span class="variable">$(BUILD)</span>/kernel/io.o</span><br><span class="line">	</span><br><span class="line">	<span class="variable">$(<span class="built_in">shell</span> mkdir -p $(<span class="built_in">dir</span> <span class="variable">$@</span>)</span>) </span><br><span class="line">	ld -g -m elf_i386 -static <span class="variable">$^</span> -o <span class="variable">$@</span> -Ttext <span class="variable">$(ENTRYPOINT)</span></span><br></pre></td></tr></table></figure>
<p><strong>关于调试</strong></p>
<p>我在网上找了一圈，实在是没有找到像视频中的效果，所以建议使用gdb调试汇编相关</p>
<p>首先调试获得光标，这里基本要观察的变量在C语言中，可以试着使用vscode远程调试</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/1562498802a6ad35a27519c8337e7567.png" alt="image-20220304093927250" /></p>
<p>​	<img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/3a040de82e3a6bd7990e42ad151eaa3e.png" alt="image-20220304094325088" /></p>
<p>最后的得到值是：240，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mn>240</mn><mo stretchy="false">)</mo><mo>=</mo><mn>11110000</mn></mrow><annotation encoding="application/x-tex">bin(240)=11110000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord">2</span><span class="mord">4</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>，所以高位是1111，地位是0000</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>240</mn><mo>=</mo><mn>3</mn><mo>∗</mo><mn>80</mn></mrow><annotation encoding="application/x-tex">240=3*80</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">4</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span><span class="mord">0</span></span></span></span>，刚好也是第四行第一个</p>
<p><strong>接着修改光标位置</strong></p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/410dc689a27860c5c35b7d5309d52ac3.png" alt="image-20220304095250419" /></p>
<p>其实我们可以算出坐标的值：000000001，我们可以验证下</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/eb53891a8e2b0c492b99ad0ecae9d717.png" alt="image-20220304095504910" /></p>
<h2 id="字符串处理"><a class="markdownIt-Anchor" href="#字符串处理"></a> 字符串处理</h2>
<p>有 <strong>#include &lt;string.h&gt;</strong></p>
<p>同时可以使用汇编或等更高效的实现</p>
<h2 id="参考-3"><a class="markdownIt-Anchor" href="#参考-3"></a> 参考</h2>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1zL4y1s76t/?spm_id_from=333.788">https://www.bilibili.com/video/BV1zL4y1s76t/?spm_id_from=333.788</a></p>
<p><a target="_blank" rel="noopener" href="https://www.osdever.net/FreeVGA/home.htm">https://www.osdever.net/FreeVGA/home.htm</a></p>
<p><a target="_blank" rel="noopener" href="http://www.osdever.net/FreeVGA/vga/crtcreg.htm">http://www.osdever.net/FreeVGA/vga/crtcreg.htm</a></p>
<h1 id="操作系统实现-多参数与printk实现"><a class="markdownIt-Anchor" href="#操作系统实现-多参数与printk实现"></a> 操作系统实现-多参数与printk实现</h1>
<h2 id="printf的多参数原理"><a class="markdownIt-Anchor" href="#printf的多参数原理"></a> printf的多参数原理</h2>
<p><code>printk</code>这个函数实在操作系统内核里面实现的，一般在用户态中是<code>printf</code>，两者原理上差不多</p>
<p>首先看<code>printf</code>的多参数实现</p>
<p>在Linux源代码中，<code>printf</code>是这样写的</p>
<p><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/latest/source">/</a><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/latest/source/arch">arch</a>/<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/latest/source/arch/x86">x86</a>/<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/latest/source/arch/x86/boot">boot</a>/<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/latest/source/arch/x86/boot/printf.c">printf.c</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> printf_buf[<span class="number">1024</span>];</span><br><span class="line">	va_list args;</span><br><span class="line">	<span class="type">int</span> printed;</span><br><span class="line"></span><br><span class="line">	va_start(args, fmt);</span><br><span class="line">	printed = <span class="built_in">vsprintf</span>(printf_buf, fmt, args);</span><br><span class="line">	va_end(args);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(printf_buf);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> printed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的变量类型 <code>va_list</code>、<code>va_start</code>、<code>va_end</code>定义如下</p>
<p><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/latest/source">/</a><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/latest/source/include">include</a>/<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/latest/source/include/linux">linux</a>/<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/latest/source/include/linux/stdarg.h">stdarg.h</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LINUX_STDARG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LINUX_STDARG_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> __builtin_va_list va_list;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_start(v, l)	__builtin_va_start(v, l)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_end(v)	__builtin_va_end(v)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_arg(v, T)	__builtin_va_arg(v, T)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_copy(d, s)	__builtin_va_copy(d, s)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>gcc/x86_64-linux-gnu/7/include/stdarg.h中，有</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __GNUC_VA_LIST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __GNUC_VA_LIST</span></span><br><span class="line"><span class="keyword">typedef</span> __builtin_va_list __gnuc_va_list;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>通过查阅gcc的源代码你会发现最原始的功能实现被改进了很多，其实可以翻译为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> XSYS_STDARG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XSYS_STDARG_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>* va_list;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_start(ap, v) (ap = (va_list)&amp;v + sizeof(char*) )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_arg(ap, t) (* (t*)(ap+=sizeof(char*)-sizeof(char*)) )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_end(ap) (ap = (va_list)0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>va_start(ap, v)：ap为 v（一个va_list）的开始格式化字符串</p>
</li>
<li>
<p>va_arg(ap, t)：t为当前格式化字符串，ap为下一个格式化字符串</p>
<p>注：<code>ap+=sizeof(char*)-sizeof(char*)</code>这时已经ap=ap+sizeof(char *)了</p>
</li>
<li>
<p>va_end(ap)：让格式化字符串置零</p>
</li>
</ul>
<p>则我们可以有printk实现</p>
<h2 id="printk实现"><a class="markdownIt-Anchor" href="#printk实现"></a> printk实现</h2>
<p><code>src/kernel/printk.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/console.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">printk</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    va_start(args, fmt);</span><br><span class="line">    i = <span class="built_in">vsprintf</span>(buf, fmt, args);</span><br><span class="line">    va_end(args);</span><br><span class="line"></span><br><span class="line">    console_write(buf, i);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>src/lib/vsprintf.c</code></p>
<p>这里可以取巧抄linux的源代码：<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/latest/source/arch/x86/boot/printf.c#L113">https://elixir.bootlin.com/linux/latest/source/arch/x86/boot/printf.c#L113</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZEROPAD 1  <span class="comment">// 填充零</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGN 2     <span class="comment">// unsigned/signed long</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLUS 4     <span class="comment">// 显示加</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPACE 8    <span class="comment">// 如是加，则置空格</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEFT 16    <span class="comment">// 左调整</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPECIAL 32 <span class="comment">// 0x</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALL 64   <span class="comment">// 使用小写字母</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> is_digit(c) ((c) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; (c) &lt;= <span class="string">&#x27;9&#x27;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字符数字串转换成整数，并将指针前移</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">skip_atoi</span><span class="params">(<span class="type">const</span> <span class="type">char</span> **s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (is_digit(**s))</span><br><span class="line">        i = i * <span class="number">10</span> + *((*s)++) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将整数转换为指定进制的字符串</span></span><br><span class="line"><span class="comment">// str - 输出字符串指针</span></span><br><span class="line"><span class="comment">// num - 整数</span></span><br><span class="line"><span class="comment">// base - 进制基数</span></span><br><span class="line"><span class="comment">// size - 字符串长度</span></span><br><span class="line"><span class="comment">// precision - 数字长度(精度)</span></span><br><span class="line"><span class="comment">// flags - 选项</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *<span class="title function_">number</span><span class="params">(<span class="type">char</span> *str, <span class="type">unsigned</span> <span class="type">long</span> num, <span class="type">int</span> base, <span class="type">int</span> size, <span class="type">int</span> precision, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> c, sign, tmp[<span class="number">36</span>];</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *digits = <span class="string">&quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    <span class="type">char</span> *ptr = str;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 flags 指出用小写字母，则定义小写字母集</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; SMALL)</span><br><span class="line">        digits = <span class="string">&quot;0123456789abcdefghijklmnopqrstuvwxyz&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 flags 指出要左对齐，则屏蔽类型中的填零标志</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; LEFT)</span><br><span class="line">        flags &amp;= ~ZEROPAD;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果进制基数小于 2 或大于 36，则退出处理</span></span><br><span class="line">    <span class="comment">// 也即本程序只能处理基数在 2-32 之间的数</span></span><br><span class="line">    <span class="keyword">if</span> (base &lt; <span class="number">2</span> || base &gt; <span class="number">36</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 flags 指出要填零，则置字符变量 c=&#x27;0&#x27;，否则 c 等于空格字符</span></span><br><span class="line">    c = (flags &amp; ZEROPAD) ? <span class="string">&#x27;0&#x27;</span> : <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 flags 指出是带符号数并且数值 num 小于 0，则置符号变量 sign=负号，并使 num 取绝对值</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; SIGN &amp;&amp; num &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sign = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">        num = -num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则如果 flags 指出是加号，则置 sign=加号，否则若类型带空格标志则 sign=空格，否则置 0</span></span><br><span class="line">        sign = (flags &amp; PLUS) ? <span class="string">&#x27;+&#x27;</span> : ((flags &amp; SPACE) ? <span class="string">&#x27; &#x27;</span> : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若带符号，则宽度值减 1</span></span><br><span class="line">    <span class="keyword">if</span> (sign)</span><br><span class="line">        size--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若 flags 指出是特殊转换，则对于十六进制宽度再减少 2 位(用于0x)</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; SPECIAL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (base == <span class="number">16</span>)</span><br><span class="line">            size -= <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 对于八进制宽度减 1（用于八进制转换结果前放一个零）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (base == <span class="number">8</span>)</span><br><span class="line">            size--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果数值 num 为 0，则临时字符串=&#x27;0&#x27;；否则根据给定的基数将数值 num 转换成字符形式</span></span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">0</span>)</span><br><span class="line">        tmp[i++] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">while</span> (num != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            index = num % base;</span><br><span class="line">            num /= base;</span><br><span class="line">            tmp[i++] = digits[index];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若数值字符个数大于精度值，则精度值扩展为数字个数值</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; precision)</span><br><span class="line">        precision = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 宽度值 size 减去用于存放数值字符的个数</span></span><br><span class="line">    size -= precision;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从这里真正开始形成所需要的转换结果，并暂时放在字符串 str 中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若 flags 中没有填零(ZEROPAD) 和左对齐（左调整）标志</span></span><br><span class="line">    <span class="comment">// 则在 str 中首先填放剩余宽度值指出的空格数</span></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; (ZEROPAD + LEFT)))</span><br><span class="line">        <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>)</span><br><span class="line">            *str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若需带符号位，则存入符号</span></span><br><span class="line">    <span class="keyword">if</span> (sign)</span><br><span class="line">        *str++ = sign;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若 flags 指出是特殊转换</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; SPECIAL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 则对于八进制转换结果头一位放置一个&#x27;0&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> (base == <span class="number">8</span>)</span><br><span class="line">            *str++ = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="comment">// 对于十六进制则存放&#x27;0x&#x27;</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (base == <span class="number">16</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            *str++ = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            *str++ = digits[<span class="number">33</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若 flags 中没有左调整（左对齐）标志, 则在剩余宽度中存放 c 字符（&#x27;0&#x27;或空格）</span></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; LEFT))</span><br><span class="line">        <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>)</span><br><span class="line">            *str++ = c;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时 i 存有数值 num 的数字个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若数字个数小于精度值，则 str 中放入（精度值-i）个&#x27;0&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; precision--)</span><br><span class="line">        *str++ = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将转数值换好的数字字符填入 str 中，共 i 个</span></span><br><span class="line">    <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>)</span><br><span class="line">        *str++ = tmp[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若宽度值仍大于零</span></span><br><span class="line">    <span class="comment">// 则表示 flags 标志中有左对齐标志标志</span></span><br><span class="line">    <span class="comment">// 则在剩余宽度中放入空格</span></span><br><span class="line">    <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>)</span><br><span class="line">        *str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">vsprintf</span><span class="params">(<span class="type">char</span> *buf, <span class="type">const</span> <span class="type">char</span> *fmt, va_list args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于存放转换过程中的字符串</span></span><br><span class="line">    <span class="type">char</span> *str;</span><br><span class="line">    <span class="type">char</span> *s;</span><br><span class="line">    <span class="type">int</span> *ip;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// number() 函数使用的标志</span></span><br><span class="line">    <span class="type">int</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> field_width; <span class="comment">// 输出字段宽度</span></span><br><span class="line">    <span class="type">int</span> precision;   <span class="comment">// min 整数数字个数；max 字符串中字符个数</span></span><br><span class="line">    <span class="type">int</span> qualifier;   <span class="comment">// &#x27;h&#x27;, &#x27;l&#x27; 或 &#x27;L&#x27; 用于整数字段</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先将字符指针指向 buf</span></span><br><span class="line">    <span class="comment">// 然后扫描格式字符串，</span></span><br><span class="line">    <span class="comment">// 对各个格式转换指示进行相应的处理</span></span><br><span class="line">    <span class="keyword">for</span> (str = buf; *fmt; ++fmt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 格式转换指示字符串均以 &#x27;%&#x27; 开始</span></span><br><span class="line">        <span class="comment">// 这里从 fmt 格式字符串中扫描 &#x27;%&#x27;，寻找格式转换字符串的开始</span></span><br><span class="line">        <span class="comment">// 不是格式指示的一般字符均被依次存入 str</span></span><br><span class="line">        <span class="keyword">if</span> (*fmt != <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            *str++ = *fmt;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面取得格式指示字符串中的标志域，并将标志常量放入 flags 变量中</span></span><br><span class="line">        flags = <span class="number">0</span>;</span><br><span class="line">    repeat:</span><br><span class="line">        <span class="comment">// 掉过第一个 %</span></span><br><span class="line">        ++fmt;</span><br><span class="line">        <span class="keyword">switch</span> (*fmt)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">// 左对齐调整</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            flags |= LEFT;</span><br><span class="line">            <span class="keyword">goto</span> repeat;</span><br><span class="line">        <span class="comment">// 放加号</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            flags |= PLUS;</span><br><span class="line">            <span class="keyword">goto</span> repeat;</span><br><span class="line">        <span class="comment">// 放空格</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">            flags |= SPACE;</span><br><span class="line">            <span class="keyword">goto</span> repeat;</span><br><span class="line">        <span class="comment">// 是特殊转换</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">            flags |= SPECIAL;</span><br><span class="line">            <span class="keyword">goto</span> repeat;</span><br><span class="line">        <span class="comment">// 要填零(即&#x27;0&#x27;)，否则是空格</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">            flags |= ZEROPAD;</span><br><span class="line">            <span class="keyword">goto</span> repeat;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取当前参数字段宽度域值，放入 field_width 变量中</span></span><br><span class="line">        field_width = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果宽度域中是数值则直接取其为宽度值</span></span><br><span class="line">        <span class="keyword">if</span> (is_digit(*fmt))</span><br><span class="line">            field_width = skip_atoi(&amp;fmt);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果宽度域中是字符 &#x27;*&#x27;，表示下一个参数指定宽度</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*fmt == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++fmt;</span><br><span class="line">            <span class="comment">// 因此调用 va_arg 取宽度值</span></span><br><span class="line">            field_width = va_arg(args, <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若此时宽度值小于 0，则该负数表示其带有标志域 &#x27;-&#x27; 标志（左对齐）</span></span><br><span class="line">            <span class="keyword">if</span> (field_width &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 因此还需在标志变量中添入该标志，并将字段宽度值取为其绝对值</span></span><br><span class="line">                field_width = -field_width;</span><br><span class="line">                flags |= LEFT;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取格式转换串的精度域，并放入 precision 变量中</span></span><br><span class="line">        precision = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 精度域开始的标志是&#x27;.&#x27; 其处理过程与上面宽度域的类似</span></span><br><span class="line">        <span class="keyword">if</span> (*fmt == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++fmt;</span><br><span class="line">            <span class="comment">// 如果精度域中是数值则直接取其为精度值</span></span><br><span class="line">            <span class="keyword">if</span> (is_digit(*fmt))</span><br><span class="line">                precision = skip_atoi(&amp;fmt);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果精度域中是字符&#x27;*&#x27;，表示下一个参数指定精度</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (*fmt == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 因此调用 va_arg 取精度值</span></span><br><span class="line">                precision = va_arg(args, <span class="type">int</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 若此时宽度值小于 0，则将字段精度值取为其绝对值</span></span><br><span class="line">            <span class="keyword">if</span> (precision &lt; <span class="number">0</span>)</span><br><span class="line">                precision = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面这段代码分析长度修饰符，并将其存入 qualifer 变量</span></span><br><span class="line">        qualifier = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (*fmt == <span class="string">&#x27;h&#x27;</span> || *fmt == <span class="string">&#x27;l&#x27;</span> || *fmt == <span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            qualifier = *fmt;</span><br><span class="line">            ++fmt;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面分析转换指示符</span></span><br><span class="line">        <span class="keyword">switch</span> (*fmt)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果转换指示符是&#x27;c&#x27;，则表示对应参数应是字符</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">            <span class="comment">// 此时如果标志域表明不是左对齐，</span></span><br><span class="line">            <span class="keyword">if</span> (!(flags &amp; LEFT))</span><br><span class="line">                <span class="comment">// 则该字段前面放入 (宽度域值 - 1) 个空格字符，然后再放入参数字符</span></span><br><span class="line">                <span class="keyword">while</span> (--field_width &gt; <span class="number">0</span>)</span><br><span class="line">                    *str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            *str++ = (<span class="type">unsigned</span> <span class="type">char</span>)va_arg(args, <span class="type">int</span>);</span><br><span class="line">            <span class="comment">// 如果宽度域还大于 0，则表示为左对齐</span></span><br><span class="line">            <span class="comment">// 则在参数字符后面添加 (宽度值-1) 个空格字符</span></span><br><span class="line">            <span class="keyword">while</span> (--field_width &gt; <span class="number">0</span>)</span><br><span class="line">                *str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果转换指示符是 &#x27;s&#x27;，则表示对应参数是字符串</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">            s = va_arg(args, <span class="type">char</span> *);</span><br><span class="line">            <span class="comment">// 首先取参数字符串的长度</span></span><br><span class="line">            len = <span class="built_in">strlen</span>(s);</span><br><span class="line">            <span class="comment">// 若其超过了精度域值, 则扩展精度域=字符串长度</span></span><br><span class="line">            <span class="keyword">if</span> (precision &lt; <span class="number">0</span>)</span><br><span class="line">                precision = len;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (len &gt; precision)</span><br><span class="line">                len = precision;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 此时如果标志域表明不是左对齐</span></span><br><span class="line">            <span class="keyword">if</span> (!(flags &amp; LEFT))</span><br><span class="line">                <span class="comment">// 则该字段前放入 (宽度值-字符串长度) 个空格字符</span></span><br><span class="line">                <span class="keyword">while</span> (len &lt; field_width--)</span><br><span class="line">                    *str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            <span class="comment">// 然后再放入参数字符串</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">                *str++ = *s++;</span><br><span class="line">            <span class="comment">// 如果宽度域还大于 0，则表示为左对齐</span></span><br><span class="line">            <span class="comment">// 则在参数字符串后面，添加(宽度值-字符串长度)个空格字符</span></span><br><span class="line">            <span class="keyword">while</span> (len &lt; field_width--)</span><br><span class="line">                *str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果格式转换符是&#x27;o&#x27;，表示需将对应的参数转换成八进制数的字符串</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>:</span><br><span class="line">            str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">long</span>), <span class="number">8</span>,</span><br><span class="line">                         field_width, precision, flags);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果格式转换符是&#x27;p&#x27;，表示对应参数的一个指针类型</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:</span><br><span class="line">            <span class="comment">// 此时若该参数没有设置宽度域，则默认宽度为 8，并且需要添零</span></span><br><span class="line">            <span class="keyword">if</span> (field_width == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                field_width = <span class="number">8</span>;</span><br><span class="line">                flags |= ZEROPAD;</span><br><span class="line">            &#125;</span><br><span class="line">            str = number(str,</span><br><span class="line">                         (<span class="type">unsigned</span> <span class="type">long</span>)va_arg(args, <span class="type">void</span> *), <span class="number">16</span>,</span><br><span class="line">                         field_width, precision, flags);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若格式转换指示是 &#x27;x&#x27; 或 &#x27;X&#x27;</span></span><br><span class="line">        <span class="comment">// 则表示对应参数需要打印成十六进制数输出</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>:</span><br><span class="line">            <span class="comment">// &#x27;x&#x27;表示用小写字母表示</span></span><br><span class="line">            flags |= SMALL;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span>:</span><br><span class="line">            str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">long</span>), <span class="number">16</span>,</span><br><span class="line">                         field_width, precision, flags);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果格式转换字符是&#x27;d&#x27;, &#x27;i&#x27; 或 &#x27;u&#x27;，则表示对应参数是整数</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">            <span class="comment">// &#x27;d&#x27;, &#x27;i&#x27;代表符号整数，因此需要加上带符号标志</span></span><br><span class="line">            flags |= SIGN;</span><br><span class="line">        <span class="comment">// &#x27;u&#x27;代表无符号整数</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;u&#x27;</span>:</span><br><span class="line">            str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">long</span>), <span class="number">10</span>,</span><br><span class="line">                         field_width, precision, flags);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若格式转换指示符是 &#x27;n&#x27;</span></span><br><span class="line">        <span class="comment">// 表示要把到目前为止转换输出的字符数保存到对应参数指针指定的位置中</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>:</span><br><span class="line">            <span class="comment">// 首先利用 va_arg() 取得该参数指针</span></span><br><span class="line">            ip = va_arg(args, <span class="type">int</span> *);</span><br><span class="line">            <span class="comment">// 然后将已经转换好的字符数存入该指针所指的位置</span></span><br><span class="line">            *ip = (str - buf);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// 若格式转换符不是 &#x27;%&#x27;，则表示格式字符串有错</span></span><br><span class="line">            <span class="keyword">if</span> (*fmt != <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">                <span class="comment">// 直接将一个 &#x27;%&#x27; 写入输出串中</span></span><br><span class="line">                *str++ = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">            <span class="comment">// 如果格式转换符的位置处还有字符，则也直接将该字符写入输出串中</span></span><br><span class="line">            <span class="comment">// 然后继续循环处理格式字符串</span></span><br><span class="line">            <span class="keyword">if</span> (*fmt)</span><br><span class="line">                *str++ = *fmt;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 否则表示已经处理到格式字符串的结尾处，则退出循环</span></span><br><span class="line">                --fmt;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后在转换好的字符串结尾处添上字符串结束标志</span></span><br><span class="line">    *str = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回转换好的字符串长度值</span></span><br><span class="line">    i = str - buf;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果按格式输出字符串到 buf</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sprintf</span><span class="params">(<span class="type">char</span> *buf, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    va_start(args, fmt);</span><br><span class="line">    <span class="type">int</span> i = <span class="built_in">vsprintf</span>(buf, fmt, args);</span><br><span class="line">    va_end(args);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以改写src/kernel/main.c了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/xsys.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/console.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> message[] = <span class="string">&quot;HELLO XSYS\n&quot;</span>;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    console_init();</span><br><span class="line">    <span class="type">int</span> count=<span class="number">31</span>;</span><br><span class="line">    <span class="keyword">while</span>(count--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// console_write(message, sizeof(message) - 1);</span></span><br><span class="line">        printk(<span class="string">&quot;hello xsys %#010d\n&quot;</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/42015c0fa9cff310d93ad12d93c993a4.png" alt="image-20220306165753726" /></p>
<h2 id="字符串格式化漏洞の一点补充"><a class="markdownIt-Anchor" href="#字符串格式化漏洞の一点补充"></a> 字符串格式化漏洞の一点补充</h2>
<p>在之前的<a target="_blank" rel="noopener" href="https://blog.joe1sn.top/2019/11/17/fsb/">文章</a>里面讲过了，但是这次可以从新的视角出发</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> msg[] = <span class="string">&quot;XSYS\n&quot;</span>;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello %d %s %d %d\n&quot;</span>, a, msg, <span class="number">0xaa</span>, <span class="number">0xff</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/f8d58090407cbc5c6e89c3fe14bb7c0c.png" alt="image-20220306170318384" style="zoom:80%;" />
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -m32 -g -o test test.c</span><br></pre></td></tr></table></figure>
<p>这里使用32位是为了不让参数传到寄存器中，这样参数在栈上面方便调试</p>
<img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/9e57747157dff0bb248cc06a4eca82d0.png" alt="image-20220306170653504" style="zoom:67%;" />
<p>gcc这里使用的时标准的<code>cdecl</code>(c declearation)，所以我们的参数是从右往左入栈，及图中的4个push</p>
<p>在call之前的栈如下</p>
<img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/0b637301dbea9c56af6680b6ccd313a3.png" alt="image-20220306170920947" style="zoom: 60%;" />
<p>所以当vsprintf检测到格式化字符串时，他就会将栈顶的值按照提前预定的格式输出出来。</p>
<p>所以对字符串格式化漏洞利用来说，重要的是<code>call vsprintf</code>时，栈的情况</p>
<h1 id="操作系统实现-断言与调试"><a class="markdownIt-Anchor" href="#操作系统实现-断言与调试"></a> 操作系统实现-断言与调试</h1>
<blockquote>
<p>代码来源：<a target="_blank" rel="noopener" href="https://github.com/StevenBaby/onix">https://github.com/StevenBaby/onix</a></p>
<p>相关课程：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1gR4y1u7or">https://www.bilibili.com/video/BV1gR4y1u7or</a></p>
<p>感谢B站UP：<a target="_blank" rel="noopener" href="https://space.bilibili.com/491131440">踌躇月光</a> 带来的相关代码和教程</p>
</blockquote>
<h2 id="断言"><a class="markdownIt-Anchor" href="#断言"></a> 断言</h2>
<p>如果要判断一个条件是否成立，可以有</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">exp</span>)</span><br><span class="line">    ....;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    ERROR;</span><br></pre></td></tr></table></figure>
<p>每个判断都这样写的话会导致代码异常难读，所以可以使用一个函数<code>assert()</code>来实现</p>
<p>而我们的<code>assert()</code>肯定要打印出错的代码文件、哪一行、报错提示信息</p>
<p>不过还好之前我们在<code>printk</code>中实现了这一点</p>
<p><code>src/include/xsys/assert.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> XSYS_ASSERT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XSYS_ASSERT_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">assertion_failure</span><span class="params">(<span class="type">char</span> *<span class="built_in">exp</span>, <span class="type">char</span> *file, <span class="type">char</span> *base, <span class="type">int</span> line)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> assert(exp) \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (exp)        \</span></span><br><span class="line"><span class="meta">        ;           \</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span>            \</span></span><br><span class="line"><span class="meta">        assertion_failure(#exp, __FILE__, __BASE_FILE__, __LINE__)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">panic</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>src/kernel/assert.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/printk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> u8 buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">assertion_failure</span><span class="params">(<span class="type">char</span> *<span class="built_in">exp</span>, <span class="type">char</span> *file, <span class="type">char</span> *base, <span class="type">int</span> line)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(</span><br><span class="line">        <span class="string">&quot;\n--&gt; assert(%s) failed!!!\n&quot;</span></span><br><span class="line">        <span class="string">&quot;--&gt; file: %s \n&quot;</span></span><br><span class="line">        <span class="string">&quot;--&gt; base: %s \n&quot;</span></span><br><span class="line">        <span class="string">&quot;--&gt; line: %d \n&quot;</span>,</span><br><span class="line">        <span class="built_in">exp</span>, file, base, line);</span><br><span class="line"></span><br><span class="line">    spin(<span class="string">&quot;assertion_failure()&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不可能走到这里，否则出错；</span></span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;ud2&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>src/kernel/main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/xsys.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/console.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/debug.h&gt;</span></span></span><br><span class="line"><span class="comment">// #include &lt;xsys/global.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> message[] = <span class="string">&quot;HELLO XSYS\n&quot;</span>;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    console_init();</span><br><span class="line">    assert(<span class="number">3</span>&lt;<span class="number">5</span>);</span><br><span class="line">    assert(<span class="number">3</span>&gt;<span class="number">5</span>);    </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/5c6e29057af8c113919c625853075589.png" alt="image-20220307221825131" /></p>
<h2 id="panic-慌乱"><a class="markdownIt-Anchor" href="#panic-慌乱"></a> PANIC 慌乱</h2>
<p>当我们代码过多，测试阶段不可避免地会写一些bug，可能导致例如：x/0这种，会触发系统的崩溃，所以我们要对这种致命错误(Fatal Error)要有处理</p>
<p><code>src/kernel/assert.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">panic</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    va_start(args, fmt);</span><br><span class="line">    <span class="type">int</span> i = <span class="built_in">vsprintf</span>(buf, fmt, args);</span><br><span class="line">    va_end(args);</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;!!! panic !!!\n--&gt; %s \n&quot;</span>, buf);</span><br><span class="line">    spin(<span class="string">&quot;panic()&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不可能走到这里，否则出错；</span></span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;ud2&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>src/kernel/main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/xsys.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/console.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/debug.h&gt;</span></span></span><br><span class="line"><span class="comment">// #include &lt;xsys/global.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> message[] = <span class="string">&quot;HELLO XSYS\n&quot;</span>;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    console_init();</span><br><span class="line">    panic(<span class="string">&quot;test!!!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/1d0ff1986f33dcab8b121e4b90a8d1ee.png" alt="image-20220307222235079" /></p>
<h2 id="调试"><a class="markdownIt-Anchor" href="#调试"></a> 调试</h2>
<p>bochs中的断点是：<code>xchg bx,bx</code></p>
<p>所以我们通过裸汇编来实现断点，同时显示停止在了那个文件的哪一行</p>
<p><code>src/include/xsys/debug.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> XSYS_DEBUG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XSYS_DEBUG_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">debug_k</span><span class="params">(<span class="type">char</span>* file, <span class="type">int</span> line, <span class="type">const</span> <span class="type">char</span>* fmt, ...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BMB asm volatile (<span class="string">&quot;xchgw %bx, %bx&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUGK(fmt, args...) debug_k(__BASE_FILE__, __LINE__, fmt, ##args)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>src/kernel/debug.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/debug.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/printk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">debug_k</span><span class="params">(<span class="type">char</span>* file, <span class="type">int</span> line, <span class="type">const</span> <span class="type">char</span>* fmt, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    va_start(args, fmt);</span><br><span class="line">    <span class="built_in">vsprintf</span>(buf, fmt, args);</span><br><span class="line">    printk(<span class="string">&quot;[%s] [%d] %s&quot;</span>, file, line, fmt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>src/kernel/main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/xsys.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/console.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/debug.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/global.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> message[] = <span class="string">&quot;HELLO XSYS\n&quot;</span>;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    console_init();</span><br><span class="line">    BMB;</span><br><span class="line">    assert(<span class="number">3</span>&lt;<span class="number">5</span>);</span><br><span class="line">    DEBUGK(<span class="string">&quot;debug test&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/55475a9acc2eb90301df627fe4bc5129.png" alt="image-20220307222700531" /></p>
<h1 id="操作系统实现-内核全局描述符进程调度及上下文切换"><a class="markdownIt-Anchor" href="#操作系统实现-内核全局描述符进程调度及上下文切换"></a> 操作系统实现-内核全局描述符|进程调度及上下文切换</h1>
<h2 id="内核全局描述符"><a class="markdownIt-Anchor" href="#内核全局描述符"></a> 内核全局描述符</h2>
<p>将<code>loader.asm</code>里面全局描述功能放到内核里面（确实，你不觉得这样汇编一位一位的设置很麻烦吗？）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">descriptor_t</span> gdt[GDT_SIZE]; <span class="comment">// 内核全局描述符表</span></span><br><span class="line"><span class="type">pointer_t</span> gdt_ptr;      <span class="comment">// 内核全局描述符表指针</span></span><br></pre></td></tr></table></figure>
<p>之前的汇编</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lgdt [gdt_ptr]; 加载 gdt</span><br><span class="line">sgdt [gdt_ptr]; 保存 gdt</span><br></pre></td></tr></table></figure>
<p><code>src/include/xsys/global.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ONIX_GLOBAL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ONIX_GLOBAL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GDT_SIZE 128</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局描述符</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">descriptor_t</span> /* 共 8 个字节 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> limit_low;      <span class="comment">// 段界限 0 ~ 15 位</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> base_low : <span class="number">24</span>;    <span class="comment">// 基地址 0 ~ 23 位 16M</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> type : <span class="number">4</span>;        <span class="comment">// 段类型</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> segment : <span class="number">1</span>;     <span class="comment">// 1 表示代码段或数据段，0 表示系统段</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> DPL : <span class="number">2</span>;         <span class="comment">// Descriptor Privilege Level 描述符特权等级 0 ~ 3</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> present : <span class="number">1</span>;     <span class="comment">// 存在位，1 在内存中，0 在磁盘上</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> limit_high : <span class="number">4</span>;  <span class="comment">// 段界限 16 ~ 19;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> available : <span class="number">1</span>;   <span class="comment">// 该安排的都安排了，送给操作系统吧</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> long_mode : <span class="number">1</span>;   <span class="comment">// 64 位扩展标志</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> big : <span class="number">1</span>;         <span class="comment">// 32 位 还是 16 位;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> granularity : <span class="number">1</span>; <span class="comment">// 粒度 4KB 或 1B</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> base_high;       <span class="comment">// 基地址 24 ~ 31 位</span></span><br><span class="line">&#125; _packed <span class="type">descriptor_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 段选择子</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">selector_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u8 RPL : <span class="number">2</span>;</span><br><span class="line">    u8 TI : <span class="number">1</span>;</span><br><span class="line">    u16 index : <span class="number">13</span>;</span><br><span class="line">&#125; <span class="type">selector_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局描述符表指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pointer_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u16 limit;</span><br><span class="line">    u32 base;</span><br><span class="line">&#125; _packed <span class="type">pointer_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">gdt_init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>src/kernel/global.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/global.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/debug.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">descriptor_t</span> gdt[GDT_SIZE]; <span class="comment">// 内核全局描述符表</span></span><br><span class="line"><span class="type">pointer_t</span> gdt_ptr;          <span class="comment">// 内核全局描述符表指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化内核全局描述符表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">gdt_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    BMB;</span><br><span class="line">    DEBUGK(<span class="string">&quot;init gdt!!!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;sgdt gdt_ptr&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;gdt, (<span class="type">void</span> *)gdt_ptr.base, gdt_ptr.limit + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    gdt_ptr.base = (u32)&amp;gdt;</span><br><span class="line">    gdt_ptr.limit = <span class="keyword">sizeof</span>(gdt) - <span class="number">1</span>;</span><br><span class="line">    BMB;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;lgdt gdt_ptr\n&quot;</span>)</span>;</span><br><span class="line">    BMB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>src/kernel/main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/xsys.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/console.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/debug.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/global.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> message[] = <span class="string">&quot;HELLO XSYS\n&quot;</span>;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    console_init();</span><br><span class="line">    gdt_init();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/fd03cfb7eef4da9465149b51b1f48d3c.png" alt="image-20220308104058648" /></p>
<p>这里是MBR最开始的GDT，也是第一个断点</p>
<p>在执行<code>lgdt ds:addr</code>后</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/92acbbf06e243c7ed75f609b23cfff5d.png" alt="image-20220308104351539" /></p>
<p>这样就扩充到了127个GDT</p>
<p><strong>拓展 在linux内核中是如何实现的</strong></p>
<ol>
<li>
<p>到了保护模式，内存管理分为段式，和段页式，也就是段模式必不可少</p>
</li>
<li>
<p>对段模式来说，访问一个内存仍然用的【段基地址：偏移地址】</p>
</li>
<li>
<p>GDT：把这些长度为64bit的段描述符放入一个数组中，而将段寄存器中的值作为下标索引来间接引用</p>
<ul>
<li>段描述符</li>
</ul>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/299c5e18640751e63a6ac5f200325952.png" alt="" />	<img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/e2b5b1af0bef396f8e24d0506aee8403.png" alt="" /></p>
<p>​	同样的在源码中有</p>
<p>​	<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.16.12/source">/</a><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.16.12/source/arch">arch</a>/<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.16.12/source/arch/x86">x86</a>/<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.16.12/source/arch/x86/include">include</a>/<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.16.12/source/arch/x86/include/asm">asm</a>/<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.16.12/source/arch/x86/include/asm/desc_defs.h">desc_defs.h</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __ASSEMBLY__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 8 byte segment descriptor */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> &#123;</span></span><br><span class="line">	u16	limit0;</span><br><span class="line">	u16	base0;</span><br><span class="line">	u16	base1: <span class="number">8</span>, type: <span class="number">4</span>, s: <span class="number">1</span>, dpl: <span class="number">2</span>, p: <span class="number">1</span>;</span><br><span class="line">	u16	limit1: <span class="number">4</span>, avl: <span class="number">1</span>, l: <span class="number">1</span>, d: <span class="number">1</span>, g: <span class="number">1</span>, base2: <span class="number">8</span>;</span><br><span class="line">&#125; __attribute__((packed));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GDT_ENTRY_INIT(flags, base, limit)			\</span></span><br><span class="line"><span class="meta">	&#123;							\</span></span><br><span class="line"><span class="meta">		.limit0		= (u16) (limit),		\</span></span><br><span class="line"><span class="meta">		.limit1		= ((limit) &gt;&gt; 16) &amp; 0x0F,	\</span></span><br><span class="line"><span class="meta">		.base0		= (u16) (base),			\</span></span><br><span class="line"><span class="meta">		.base1		= ((base) &gt;&gt; 16) &amp; 0xFF,	\</span></span><br><span class="line"><span class="meta">		.base2		= ((base) &gt;&gt; 24) &amp; 0xFF,	\</span></span><br><span class="line"><span class="meta">		.type		= (flags &amp; 0x0f),		\</span></span><br><span class="line"><span class="meta">		.s		= (flags &gt;&gt; 4) &amp; 0x01,		\</span></span><br><span class="line"><span class="meta">		.dpl		= (flags &gt;&gt; 5) &amp; 0x03,		\</span></span><br><span class="line"><span class="meta">		.p		= (flags &gt;&gt; 7) &amp; 0x01,		\</span></span><br><span class="line"><span class="meta">		.avl		= (flags &gt;&gt; 12) &amp; 0x01,		\</span></span><br><span class="line"><span class="meta">		.l		= (flags &gt;&gt; 13) &amp; 0x01,		\</span></span><br><span class="line"><span class="meta">		.d		= (flags &gt;&gt; 14) &amp; 0x01,		\</span></span><br><span class="line"><span class="meta">		.g		= (flags &gt;&gt; 15) &amp; 0x01,		\</span></span><br><span class="line"><span class="meta">	&#125;</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">/* LDT or TSS descriptor in the GDT. */</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">desc_ptr</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> size;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> address;</span><br><span class="line">&#125; __attribute__((packed)) ;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>在<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.16.12/source">/</a><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.16.12/source/arch">arch</a>/<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.16.12/source/arch/x86">x86</a>/<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.16.12/source/arch/x86/include">include</a>/<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.16.12/source/arch/x86/include/asm">asm</a>/<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.16.12/source/arch/x86/include/asm/desc.h">desc.h</a>定义了一个描述符数组，则为gdt</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gdt_page</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> <span class="title">gdt</span>[<span class="title">GDT_ENTRIES</span>];</span></span><br><span class="line">&#125; __attribute__((aligned(PAGE_SIZE)));</span><br></pre></td></tr></table></figure>
<p>最后更具这个找到gdt的相关应用就行了</p>
</li>
</ul>
</li>
</ol>
<h2 id="进程调度及上下文切换"><a class="markdownIt-Anchor" href="#进程调度及上下文切换"></a> 进程调度及上下文切换</h2>
<p>在32位下，参数传递是通过栈传递的，但是具体的信息会保存到寄存器中，所以我们为了不修改寄存器的值，有一套调用规则。主要有SystemV规则和Posix规则</p>
<p>​	System V</p>
<blockquote>
<p>The System V Interface Definition (SVID) is a standard that describes the AT&amp;T UNIX System V behavior, including that of system calls, C libraries, available programs and devices.</p>
</blockquote>
<p>​	Posix</p>
<blockquote>
<p>Portable Operating System Interface standards specified by IEEE to define application programming interface (API). POSIX covers all the three forms of IPC</p>
</blockquote>
<p><strong>cdecl</strong></p>
<ol>
<li>函数实参在线程栈上按照从右至左的顺序依次压栈。</li>
<li>函数结果保存在寄存器EAX/AX/AL中</li>
<li>调用者负责从线程栈中弹出实参（即清栈）</li>
<li>受到函数调用影响的寄存器（volatile registers）：EAX, ECX, EDX, ST0 - ST7, ES, GS</li>
<li>不受函数调用影响的寄存器： EBX, EBP, ESP, EDI, ESI, CS, DS</li>
</ol>
<p>因为函数调用的时候不受函数调用影响的寄存器： EBX, EBP, ESP, EDI, ESI, CS, DS，我们简化为EBX、ESI、EDI，所以我们需要保存这些</p>
<p><code>src/kernel/schedule.asm</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">global task_switch</span><br><span class="line">task_switch:</span><br><span class="line">    push ebp</span><br><span class="line">    mov ebp, esp</span><br><span class="line"></span><br><span class="line">    push ebx</span><br><span class="line">    push esi</span><br><span class="line">    push edi</span><br><span class="line"></span><br><span class="line">    mov eax, esp;</span><br><span class="line">    and eax, 0xfffff000; current</span><br><span class="line"></span><br><span class="line">    mov [eax], esp</span><br><span class="line"></span><br><span class="line">    mov eax, [ebp + 8]; next</span><br><span class="line">    mov esp, [eax]</span><br><span class="line"></span><br><span class="line">    pop edi</span><br><span class="line">    pop esi</span><br><span class="line">    pop ebx</span><br><span class="line">    pop ebp</span><br><span class="line"></span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<p>为了理解上面的其他细节，我们假设有这么一种情况：我们同时有两个函数（任务|进程）A、B，两者需要相互切换，且连两个程序跑起来的时候都是在栈上面，其中的栈就是内核栈(kernel stack)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">task_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u32 *<span class="built_in">stack</span>; <span class="comment">// 内核栈</span></span><br><span class="line">&#125; <span class="type">task_t</span>;</span><br></pre></td></tr></table></figure>
<p>因为系统是32位的，所以栈可以暂时表示32位数组</p>
<p>进程创建的时候，我们要初始化进程相对应的栈</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">task_create</span><span class="params">(<span class="type">task_t</span> *task, <span class="type">target_t</span> target)</span></span><br><span class="line">&#123;</span><br><span class="line">    u32 <span class="built_in">stack</span> = (u32)task + PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span> -= <span class="keyword">sizeof</span>(<span class="type">task_frame_t</span>);</span><br><span class="line">    <span class="type">task_frame_t</span> *frame = (<span class="type">task_frame_t</span> *)<span class="built_in">stack</span>;</span><br><span class="line">    frame-&gt;ebx = <span class="number">0x11111111</span>;</span><br><span class="line">    frame-&gt;esi = <span class="number">0x22222222</span>;</span><br><span class="line">    frame-&gt;edi = <span class="number">0x33333333</span>;</span><br><span class="line">    frame-&gt;ebp = <span class="number">0x44444444</span>;</span><br><span class="line">    frame-&gt;eip = (<span class="type">void</span> *)target;</span><br><span class="line"></span><br><span class="line">    task-&gt;<span class="built_in">stack</span> = (u32 *)<span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当A向B切换的时候，我们就需要得到当前进程的内存地址，保存相关信息（EBX ESI EDI），这个相关信息就是<strong>任务上下文</strong></p>
<p>调度函数可有：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">schedule</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">task_t</span> *current = running_task();</span><br><span class="line">    <span class="type">task_t</span> *next = current == a ? b : a;</span><br><span class="line">    task_switch(next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么对于最开始的schedule.asm就有：</p>
<ol>
<li>最开始的保存栈信息</li>
<li>将 <strong>ebx esi edi</strong> 压入栈保存</li>
<li>将当前栈顶<strong>esp</strong>转到<strong>eax</strong>上面，再将eax&amp;0xfffff000得到下一个任务的地址，再将当前栈顶转移到下一个任务地址中</li>
<li>将传入的<strong>next</strong>值转移到eax中作为返回值，再将下一个任务的地址转到栈顶中</li>
<li>最后再pop恢复栈平衡，返回后就可以到下一个任务了</li>
</ol>
<p><code>src/include/xsys/task.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> XSYS_TASK_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XSYS_TASK_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> u32 <span class="title function_">target_t</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">task_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u32 *<span class="built_in">stack</span>; <span class="comment">// 内核栈</span></span><br><span class="line">&#125; <span class="type">task_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">task_frame_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u32 edi;</span><br><span class="line">    u32 esi;</span><br><span class="line">    u32 ebx;</span><br><span class="line">    u32 ebp;</span><br><span class="line">    <span class="type">void</span> (*eip)(<span class="type">void</span>);</span><br><span class="line">&#125; <span class="type">task_frame_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>src/kernel/task.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/task.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/printk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/debug.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE 0x1000</span></span><br><span class="line"></span><br><span class="line"><span class="type">task_t</span> *a = (<span class="type">task_t</span> *)<span class="number">0x1000</span>;</span><br><span class="line"><span class="type">task_t</span> *b = (<span class="type">task_t</span> *)<span class="number">0x2000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">task_switch</span><span class="params">(<span class="type">task_t</span> *next)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">task_t</span> *<span class="title function_">running_task</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot;movl %esp, %eax\n&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;andl $0xfffff000, %eax\n&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">schedule</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">task_t</span> *current = running_task();</span><br><span class="line">    <span class="type">task_t</span> *next = current == a ? b : a;</span><br><span class="line">    task_switch(next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u32 <span class="title function_">thread_a</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        schedule();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u32 <span class="title function_">thread_b</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        schedule();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">task_create</span><span class="params">(<span class="type">task_t</span> *task, <span class="type">target_t</span> target)</span></span><br><span class="line">&#123;</span><br><span class="line">    u32 <span class="built_in">stack</span> = (u32)task + PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span> -= <span class="keyword">sizeof</span>(<span class="type">task_frame_t</span>);</span><br><span class="line">    <span class="type">task_frame_t</span> *frame = (<span class="type">task_frame_t</span> *)<span class="built_in">stack</span>;</span><br><span class="line">    frame-&gt;ebx = <span class="number">0x11111111</span>;</span><br><span class="line">    frame-&gt;esi = <span class="number">0x22222222</span>;</span><br><span class="line">    frame-&gt;edi = <span class="number">0x33333333</span>;</span><br><span class="line">    frame-&gt;ebp = <span class="number">0x44444444</span>;</span><br><span class="line">    frame-&gt;eip = (<span class="type">void</span> *)target;</span><br><span class="line"></span><br><span class="line">    task-&gt;<span class="built_in">stack</span> = (u32 *)<span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    task_create(a, thread_a);</span><br><span class="line">    task_create(b, thread_b);</span><br><span class="line">    schedule();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>src/kernel/main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/xsys.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/console.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/debug.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/global.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/task.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> message[] = <span class="string">&quot;HELLO XSYS\n&quot;</span>;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    console_init();</span><br><span class="line">    gdt_init();</span><br><span class="line">    task_init();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/8ea8b2dc83ba95afac2029bb10bdba38.png" alt="image-20220309144037664" /></p>
<p><strong>调试</strong></p>
<p>有如下两个断点</p>
<img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/a9d5322407ed0a8051c1b72fc853a7f9.png" alt="image-20220310163610879" style="zoom:67%;" />
<p>这里的汇编我无法定位到具体文件，所以得gdb看一下了</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/94bdc3843bd07282c5b7f891dc3cf53f.png" alt="image-20220310182900115" /></p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/6322327b9302b9025d133a44a0e5041b.png" alt="image-20220310182935275" /></p>
<p>得到<code>current=0x1000</code></p>
<p>再通过task_switch切换</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/868c57e980cca89c189a378171c6a678.png" alt="image-20220310183106121" /></p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/5af4c34b27fcfd37443b006bd20d3698.png" alt="image-20220310183230665" /></p>
<p>当前任务（A）的值被压入了栈中，然后再次得到当前栈的信息，之后将esp信息保存到*eax即0x1000中</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/406459ee885c28c6c57f59da51f395a6.png" alt="image-20220310183606571" /></p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/ba14f85b90c244b45e6c046f9d7f3368.png" alt="image-20220310183808780" /></p>
<p>再将下一个任务的地址放入到esp中</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/4edc571d008184494d164b0dc06cc801.png" alt="image-20220310183946212" /></p>
<p>然后我们就可以切换到任务B的栈</p>
<img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/5c5a55cd8465fb52162398a383c9d198.png" alt="image-20220310184200559" style="zoom:80%;" />
<img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/2415ee8e05a7dc2a005bcab39b68eb02.png" alt="image-20220310184243730" style="zoom:80%;" />
<img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/3fab48582a5ea732c8a420ea4ca0c52b.png" alt="image-20220310184334862" style="zoom:80%;" />
<h2 id="小总结"><a class="markdownIt-Anchor" href="#小总结"></a> 小总结</h2>
<p>目前的工程文件树：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">joe1sn@ubuntu:~/Desktop/os2$ tree</span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">│   ├── boot</span><br><span class="line">│   │   ├── boot.bin</span><br><span class="line">│   │   └── loader.bin</span><br><span class="line">│   ├── kernel</span><br><span class="line">│   │   ├── assert.o</span><br><span class="line">│   │   ├── console.o</span><br><span class="line">│   │   ├── debug.o</span><br><span class="line">│   │   ├── global.o</span><br><span class="line">│   │   ├── io.o</span><br><span class="line">│   │   ├── main.o</span><br><span class="line">│   │   ├── printk.o</span><br><span class="line">│   │   ├── schedule.o</span><br><span class="line">│   │   ├── start.o</span><br><span class="line">│   │   └── task.o</span><br><span class="line">│   ├── kernel.bin</span><br><span class="line">│   ├── lib</span><br><span class="line">│   │   ├── string.o</span><br><span class="line">│   │   └── vsprintf.o</span><br><span class="line">│   ├── master.img</span><br><span class="line">│   ├── system.bin</span><br><span class="line">│   └── system.map</span><br><span class="line">└── src</span><br><span class="line">    ├── bochsrc</span><br><span class="line">    ├── boot</span><br><span class="line">    │   ├── boot.asm</span><br><span class="line">    │   └── loader.asm</span><br><span class="line">    ├── include</span><br><span class="line">    │   └── xsys</span><br><span class="line">    │       ├── assert.h</span><br><span class="line">    │       ├── console.h</span><br><span class="line">    │       ├── debug.h</span><br><span class="line">    │       ├── global.h</span><br><span class="line">    │       ├── io.h</span><br><span class="line">    │       ├── printk.h</span><br><span class="line">    │       ├── stdarg.h</span><br><span class="line">    │       ├── stdio.h</span><br><span class="line">    │       ├── string.h</span><br><span class="line">    │       ├── task.h</span><br><span class="line">    │       ├── types.h</span><br><span class="line">    │       └── xsys.h</span><br><span class="line">    ├── kernel</span><br><span class="line">    │   ├── assert.c</span><br><span class="line">    │   ├── console.c</span><br><span class="line">    │   ├── debug.c</span><br><span class="line">    │   ├── global.c</span><br><span class="line">    │   ├── io.asm</span><br><span class="line">    │   ├── main.c</span><br><span class="line">    │   ├── printk.c</span><br><span class="line">    │   ├── schedule.asm</span><br><span class="line">    │   ├── start.asm</span><br><span class="line">    │   └── task.c</span><br><span class="line">    ├── lib</span><br><span class="line">    │   ├── string.c</span><br><span class="line">    │   └── vsprintf.c</span><br><span class="line">    ├── makefile</span><br><span class="line">    └── tests</span><br><span class="line">        ├── test</span><br><span class="line">        └── test.c</span><br><span class="line"></span><br><span class="line">11 directories, 48 files</span><br></pre></td></tr></table></figure>
<p>文件启动方式</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/medium/3837d7a429b759b50b95cfa9462e3104.png" alt="" /></p>
<h2 id="引用"><a class="markdownIt-Anchor" href="#引用"></a> 引用</h2>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/X86_calling_conventions#syscall">https://en.wikipedia.org/wiki/X86_calling_conventions#syscall</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/StevenBaby/onix">https://github.com/StevenBaby/onix</a></p>
<h1 id="操作系统实现-中断与系统调用"><a class="markdownIt-Anchor" href="#操作系统实现-中断与系统调用"></a> 操作系统实现-中断与系统调用</h1>
<h2 id="使用linux的系统调用"><a class="markdownIt-Anchor" href="#使用linux的系统调用"></a> 使用Linux的系统调用</h2>
<p>从汇编出发，一般来说的第一个程序是hello_world</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[bits 32]</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line">global _start</span><br><span class="line">_start:</span><br><span class="line">    mov ebx, 0</span><br><span class="line">    mov ecx, message</span><br><span class="line">    mov edx, 13</span><br><span class="line">    mov eax, 4</span><br><span class="line">    int 0x80</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">section .data</span><br><span class="line">message:</span><br><span class="line">    db &quot;hello world&quot;,10,13,0</span><br></pre></td></tr></table></figure>
<p>这里使用了linux的int 0x80系统调用（调用表：<a target="_blank" rel="noopener" href="https://www.joe1sn.top/int80.html">https://www.joe1sn.top/int80.html</a> ），调用的是write</p>
<table>
<thead>
<tr>
<th style="text-align:left">%eax</th>
<th style="text-align:left">Name</th>
<th style="text-align:left">Source</th>
<th style="text-align:left">%ebx</th>
<th style="text-align:left">%ecx</th>
<th style="text-align:left">%edx</th>
<th style="text-align:left">%ecx</th>
<th style="text-align:left">%edi</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">sys_exit</td>
<td style="text-align:left">kernel/exit.c</td>
<td style="text-align:left">int</td>
<td style="text-align:left">-</td>
<td style="text-align:left">-</td>
<td style="text-align:left">-</td>
<td style="text-align:left">-</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">sys_fork</td>
<td style="text-align:left">arch/i386/kernel/process.c</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="http://docs.cs.up.ac.za/programming/asm/derick_tut/syscalls.html#pt_regs">struct pt_regs</a></td>
<td style="text-align:left">-</td>
<td style="text-align:left">-</td>
<td style="text-align:left">-</td>
<td style="text-align:left">-</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">sys_read</td>
<td style="text-align:left">fs/read_write.c</td>
<td style="text-align:left">unsigned int</td>
<td style="text-align:left">char *</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="http://docs.cs.up.ac.za/programming/asm/derick_tut/syscalls.html#size_t">size_t</a></td>
<td style="text-align:left">-</td>
<td style="text-align:left">-</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">sys_write</td>
<td style="text-align:left">fs/read_write.c</td>
<td style="text-align:left">unsigned int</td>
<td style="text-align:left">const char *</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="http://docs.cs.up.ac.za/programming/asm/derick_tut/syscalls.html#size_t">size_t</a></td>
<td style="text-align:left">-</td>
<td style="text-align:left">-</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>ebx</strong>是选择IO通道（那个流）</li>
<li><strong>ecx</strong>是字符串的物理位置</li>
<li><strong>edx</strong>是要打印的字符个数</li>
<li><strong>eax</strong>是int 0x80要选择的系统调用号</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nasm -f elf32 hello_world.asm -o hello_world.o &amp;&amp; ld -m elf_i386 hello_world.o -o hello_world &amp;&amp; ./hello_world</span><br></pre></td></tr></table></figure>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/b75fc84205e4d9c4d1265a530a4bd26d.png" alt="image-20220313105810181" /></p>
<p>因为我们直返回后程序没有退出的指令，所以出现了段错误</p>
<p>再次使用exit系统调用就可以避免这个错误了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[bits 32]</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line">global _start</span><br><span class="line">_start:</span><br><span class="line">    mov ebx, 0</span><br><span class="line">    mov ecx, message</span><br><span class="line">    mov edx, 13</span><br><span class="line">    mov eax, 4</span><br><span class="line">    int 0x80</span><br><span class="line">    mov eax, 1</span><br><span class="line">    int 0x80</span><br><span class="line"></span><br><span class="line">section .data</span><br><span class="line">message:</span><br><span class="line">    db &quot;hello world&quot;,10,13,0</span><br></pre></td></tr></table></figure>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/c359edc5b5ffeebe0188226b9f2ef777.png" alt="image-20220313110225693" /></p>
<h2 id="实现一个系统调用"><a class="markdownIt-Anchor" href="#实现一个系统调用"></a> 实现一个系统调用</h2>
<p><strong>系统调用是基于中断实现的</strong></p>
<p>一个普遍的思想就是操作系统是一个死循环，当满足一个条件时，中断循环去执行触发的功能(函数)（windows的点击-&gt;打开一个窗口），执行完成过后回到死循环。</p>
<p>修改我们的<code>src/boot/boot.asm</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">[org 0x7c00]</span><br><span class="line">;最简单的主程序引导程序</span><br><span class="line">;实模式的启动地址</span><br><span class="line"></span><br><span class="line">;设置屏幕模式为文本模式，清除屏幕</span><br><span class="line">mov ax,3</span><br><span class="line">int 0x10</span><br><span class="line"></span><br><span class="line">;初始化段寄存器</span><br><span class="line">mov ax,0</span><br><span class="line">mov ds,ax</span><br><span class="line">mov es,ax</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,0x7c00</span><br><span class="line"></span><br><span class="line">xchg bx,bx</span><br><span class="line"></span><br><span class="line">mov word [0x80 * 4], interrupt</span><br><span class="line">mov word [0x80 * 4 + 2], 0</span><br><span class="line">int 0x80    ;linux系统调用 invoke 注册cs:ip</span><br><span class="line"></span><br><span class="line">;程序悬停</span><br><span class="line">jmp $</span><br><span class="line"></span><br><span class="line">interupt:</span><br><span class="line">    mov si, string</span><br><span class="line">    call print</span><br><span class="line">    xchg bx,bx</span><br><span class="line">    iret    ;中断返回</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;实模式的打印</span><br><span class="line">print:</span><br><span class="line">    mov ah, 0xe	;功能参数</span><br><span class="line">    .next:</span><br><span class="line">        mov al, [si];字符</span><br><span class="line">        cmp al, 0	;判断是否为最后一个结尾</span><br><span class="line">        jz .done	;结尾跳转至ret</span><br><span class="line">        int 0x10	;功能调用</span><br><span class="line">        inc si		;地址-1</span><br><span class="line">        jmp .next	;继续，下一个</span><br><span class="line">    .done:</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">string:</span><br><span class="line">    db &quot;.&quot;,0; \n\r</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">    mov si, .msg</span><br><span class="line">    call print</span><br><span class="line">    hlt; CPU停止</span><br><span class="line">    jmp $</span><br><span class="line">    .msg db &quot;Kernel Booting Failed&quot;,10,13,0</span><br><span class="line"></span><br><span class="line">;填充</span><br><span class="line">times 510-($-$$) db 0</span><br><span class="line">db 0x55,0xaa</span><br></pre></td></tr></table></figure>
<p>这里所有的一切都是先入为主的观念，因为我们并不了解上面hello_world的原理，我们在下一节从验证现在了解的知识</p>
<p>其中有：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">xchg bx,bx</span><br><span class="line">mov word [0x80 * 4], interrupt</span><br><span class="line">mov word [0x80 * 4 + 2], 0</span><br><span class="line">xchg bx,bx</span><br><span class="line">int 0x80    ;linux系统调用 invoke 注册cs:ip</span><br><span class="line">xchg bx,bx</span><br></pre></td></tr></table></figure>
<p>我们将0x80*4的位置放入了interrupt的地址，下个断点看一下</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/5bcbdc3fdf3c4d74796ce314cdd25910.png" alt="image-20220313170125892" /></p>
<p>我们成功的将<code>interrupt</code>函数的地址放到了int 0x80调用表的第0个位置，如果我们想使用<code>int 0x70</code>调用，就用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">xchg bx,bx</span><br><span class="line">mov word [0x70 * 4], interrupt</span><br><span class="line">mov word [0x70 * 4 + 2], 0</span><br><span class="line">xchg bx,bx</span><br><span class="line">int 0x70    ;invoke 注册cs:ip</span><br><span class="line">xchg bx,bx</span><br></pre></td></tr></table></figure>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/fc2b29c9bcda56758cab92ce1702892e.png" alt="image-20220313165658110" /></p>
<p>效果是一样的</p>
<p>再复习一下之前的知识：ds=0时，ds:0x100 的物理地址是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>∗</mo><mn>010</mn><mi>h</mi><mo>+</mo><mn>100</mn><mi>h</mi><mo>=</mo><mn>100</mn><mi>h</mi></mrow><annotation encoding="application/x-tex">0*010h+100h=100h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord">1</span><span class="mord">0</span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathnormal">h</span></span></span></span></p>
<p><strong>接着实现除0异常的系统调用</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">[org 0x7c00]</span><br><span class="line">;最简单的主程序引导程序</span><br><span class="line">;实模式的启动地址</span><br><span class="line"></span><br><span class="line">;设置屏幕模式为文本模式，清除屏幕</span><br><span class="line">mov ax,3</span><br><span class="line">int 0x10</span><br><span class="line"></span><br><span class="line">;初始化段寄存器</span><br><span class="line">mov ax,0</span><br><span class="line">mov ds,ax</span><br><span class="line">mov es,ax</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,0x7c00</span><br><span class="line"></span><br><span class="line">; -------------------除0异常</span><br><span class="line">mov word [0 * 4], interrupt</span><br><span class="line">mov word [0 * 4 + 2], 0</span><br><span class="line"></span><br><span class="line">mov dx, 0</span><br><span class="line">mov ax, 1</span><br><span class="line">mov bx, 0</span><br><span class="line">xchg bx, bx</span><br><span class="line">div bx</span><br><span class="line">; -------------------</span><br><span class="line"></span><br><span class="line">;程序悬停</span><br><span class="line">jmp $</span><br><span class="line"></span><br><span class="line">interrupt:</span><br><span class="line">    mov si, string</span><br><span class="line">    call print</span><br><span class="line">    xchg bx,bx</span><br><span class="line">    iret    ;中断返回</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;实模式的打印</span><br><span class="line">print:</span><br><span class="line">    mov ah, 0xe	;功能参数</span><br><span class="line">    .next:</span><br><span class="line">        mov al, [si];字符</span><br><span class="line">        cmp al, 0	;判断是否为最后一个结尾</span><br><span class="line">        jz .done	;结尾跳转至ret</span><br><span class="line">        int 0x10	;功能调用</span><br><span class="line">        inc si		;地址-1</span><br><span class="line">        jmp .next	;继续，下一个</span><br><span class="line">    .done:</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">string:</span><br><span class="line">    db &quot;.&quot;,0; \n\r</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">    mov si, .msg</span><br><span class="line">    call print</span><br><span class="line">    hlt; CPU停止</span><br><span class="line">    jmp $</span><br><span class="line">    .msg db &quot;Kernel Booting Failed&quot;,10,13,0</span><br><span class="line"></span><br><span class="line">;填充</span><br><span class="line">times 510-($-$$) db 0</span><br><span class="line">db 0x55,0xaa</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov word [0 * 4], interrupt</span><br><span class="line">mov word [0 * 4 + 2], 0</span><br><span class="line"></span><br><span class="line">mov dx, 0</span><br><span class="line">mov ax, 1</span><br><span class="line">mov bx, 0</span><br><span class="line">xchg bx, bx</span><br><span class="line">div bx</span><br></pre></td></tr></table></figure>
<p>其中对1、2行完成了中断函数的注册（覆盖了原始的除0异常函数），接着就是一个除0异常，我们在interrupt函数处下了断点</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/c171bb6bc5e78e60e9a50c2608230dda.png" alt="image-20220313170908757" /></p>
<p>这样每次除0异常都会调用interrupt函数</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/a3ca78b4a211268d982e7d444f6546a0.png" alt="image-20220313171056102" /></p>
<p>移除所有断点，系统就一直死循环跑</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/0212936aa0e6b90152119bdc65d95394.png" alt="image-20220313171211219" /></p>
<p>程序一直打印.说明<code>iret</code>返回的地址并不是中断发生时后的地址，而是引发异常代码开始的地址，即除0操作的地址</p>
<p>大意描述为：<code>eip = &amp;div_0</code>，同时我们的操作并没有修改相关寄存器的值，所以这个异常会被一直引发下去。</p>
<p>目前这个是我们自己注册的系统调用，你是否想过最开始int 0x10的BIOS系统调用是怎么样的？</p>
<p>这里有bochs实模式下的内存布局情况</p>
<table>
<thead>
<tr>
<th>起始地址</th>
<th>结束地址</th>
<th>大小</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0x000</code></td>
<td><code>0x3FF</code></td>
<td>1KB</td>
<td>中断向量表</td>
</tr>
<tr>
<td><code>0x400</code></td>
<td><code>0x4FF</code></td>
<td>256B</td>
<td>BIOS 数据区</td>
</tr>
<tr>
<td><code>0x500</code></td>
<td><code>0x7BFF</code></td>
<td>29.75 KB</td>
<td>可用区域</td>
</tr>
<tr>
<td><code>0x7C00</code></td>
<td><code>0x7DFF</code></td>
<td>512B</td>
<td>MBR 加载区域</td>
</tr>
<tr>
<td><code>0x7E00</code></td>
<td><code>0x9FBFF</code></td>
<td>607.6KB</td>
<td>可用区域</td>
</tr>
<tr>
<td><code>0x9FC00</code></td>
<td><code>0x9FFFF</code></td>
<td>1KB</td>
<td>扩展 BIOS 数据区</td>
</tr>
<tr>
<td><code>0xA0000</code></td>
<td><code>0xAFFFF</code></td>
<td>64KB</td>
<td>用于彩色显示适配器</td>
</tr>
<tr>
<td><code>0xB0000</code></td>
<td><code>0xB7FFF</code></td>
<td>32KB</td>
<td>用于黑白显示适配器</td>
</tr>
<tr>
<td><code>0xB8000</code></td>
<td><code>0xBFFFF</code></td>
<td>32KB</td>
<td>用于文本显示适配器</td>
</tr>
<tr>
<td><code>0xC0000</code></td>
<td><code>0xC7FFF</code></td>
<td>32KB</td>
<td>显示适配器 BIOS</td>
</tr>
<tr>
<td><code>0xC8000</code></td>
<td><code>0xEFFFF</code></td>
<td>160KB</td>
<td>映射内存</td>
</tr>
<tr>
<td><code>0xF0000</code></td>
<td><code>0xFFFEF</code></td>
<td>64KB-16B</td>
<td>系统 BIOS</td>
</tr>
<tr>
<td><code>0xFFFF0</code></td>
<td><code>0xFFFFF</code></td>
<td>16B</td>
<td>系统 BIOS 入口地址</td>
</tr>
</tbody>
</table>
<h2 id="再次回到linux系统调用"><a class="markdownIt-Anchor" href="#再次回到linux系统调用"></a> 再次回到Linux系统调用</h2>
<p>虽然我的内核版本是Linux ubuntu 5.4.0-100-generic #113~18.04.1-Ubuntu，但是这里用v2.6.3的源代码说明原理</p>
<p><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v2.6.3/source">/</a><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v2.6.3/source/arch">arch</a>/<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v2.6.3/source/arch/i386">i386</a>/<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v2.6.3/source/arch/i386/kernel">kernel</a>/<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v2.6.3/source/arch/i386/kernel/entry.S">entry.S</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(system_call)</span><br><span class="line">	pushl %eax			<span class="meta"># save orig_eax</span></span><br><span class="line">	SAVE_ALL</span><br><span class="line">	<span class="title function_">GET_THREAD_INFO</span><span class="params">(%ebp)</span></span><br><span class="line">	cmpl $<span class="params">(nr_syscalls)</span>, %eax</span><br><span class="line">	jae syscall_badsys</span><br><span class="line">					<span class="meta"># system call tracing in operation</span></span><br><span class="line">	testb $_TIF_SYSCALL_TRACE,<span class="title function_">TI_FLAGS</span><span class="params">(%ebp)</span></span><br><span class="line">	jnz syscall_trace_entry</span><br><span class="line">syscall_call:</span><br><span class="line">	call *<span class="title function_">sys_call_table</span><span class="params">(,%eax,<span class="number">4</span>)</span></span><br><span class="line">	movl %eax,<span class="title function_">EAX</span><span class="params">(%esp)</span>		<span class="meta"># store the return value</span></span><br><span class="line">syscall_exit:</span><br><span class="line">	cli				<span class="meta"># make sure we don<span class="string">&#x27;t miss an interrupt</span></span></span><br><span class="line"><span class="string"><span class="meta">					# setting need_resched or sigpending</span></span></span><br><span class="line"><span class="string"><span class="meta">					# between sampling and the iret</span></span></span><br><span class="line"><span class="string"><span class="meta">	movl TI_FLAGS(%ebp), %ecx</span></span></span><br><span class="line"><span class="string"><span class="meta">	testw $_TIF_ALLWORK_MASK, %cx	# current-&gt;work</span></span></span><br><span class="line"><span class="string"><span class="meta">	jne syscall_exit_work</span></span></span><br><span class="line"><span class="string"><span class="meta">restore_all:</span></span></span><br><span class="line"><span class="string"><span class="meta">	RESTORE_ALL</span></span></span><br><span class="line"><span class="string"><span class="meta">......</span></span></span><br><span class="line"><span class="string"><span class="meta">......</span></span></span><br></pre></td></tr></table></figure>
<p>这里就体现了demo工程与实际工程的不同</p>
<ul>
<li>push eax到栈</li>
<li>保存一些相关的值<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v2.6.3/source">/</a><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v2.6.3/source/arch">arch</a>/<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v2.6.3/source/arch/alpha">alpha</a>/<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v2.6.3/source/arch/alpha/kernel">kernel</a>/<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v2.6.3/source/arch/alpha/kernel/entry.S">entry.S</a></li>
<li>使用EBP来保存当前线程的信息</li>
<li>根据EAX的值选择适当的系统调用</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v2.6.3/source">/</a><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v2.6.3/source/arch">arch</a>/<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v2.6.3/source/arch/um">um</a>/<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v2.6.3/source/arch/um/kernel">kernel</a>/<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v2.6.3/source/arch/um/kernel/sys_call_table.c">sys_call_table.c</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">syscall_handler_t</span> *sys_call_table[] = &#123;</span><br><span class="line">	[ __NR_restart_syscall ] = sys_restart_syscall,</span><br><span class="line">	[ __NR_exit ] = sys_exit,</span><br><span class="line">	[ __NR_fork ] = sys_fork,</span><br><span class="line">	[ __NR_read ] = (<span class="type">syscall_handler_t</span> *) sys_read,</span><br><span class="line">	[ __NR_write ] = (<span class="type">syscall_handler_t</span> *) sys_write,</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* These three are declared differently in asm/unistd.h */</span></span><br><span class="line">	[ __NR_open ] = (<span class="type">syscall_handler_t</span> *) sys_open,</span><br><span class="line">	[ __NR_close ] = (<span class="type">syscall_handler_t</span> *) sys_close,</span><br><span class="line">	[ __NR_waitpid ] = (<span class="type">syscall_handler_t</span> *) sys_waitpid,</span><br><span class="line">	[ __NR_creat ] = sys_creat,</span><br><span class="line">	[ __NR_link ] = sys_link,</span><br><span class="line">	[ __NR_unlink ] = sys_unlink,</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* declared differently in kern_util.h */</span></span><br><span class="line">	[ __NR_execve ] = (<span class="type">syscall_handler_t</span> *) sys_execve,</span><br><span class="line">	[ __NR_chdir ] = sys_chdir,</span><br><span class="line">	[ __NR_time ] = um_time,</span><br><span class="line">	[ __NR_mknod ] = sys_mknod,</span><br><span class="line">	[ __NR_chmod ] = sys_chmod,</span><br><span class="line">	[ __NR_lchown ] = sys_lchown16,</span><br><span class="line">	[ __NR_break ] = sys_ni_syscall,</span><br><span class="line">	[ __NR_oldstat ] = sys_stat,</span><br><span class="line">	[ __NR_lseek ] = (<span class="type">syscall_handler_t</span> *) sys_lseek,</span><br><span class="line">	[ __NR_getpid ] = sys_getpid,</span><br><span class="line">	[ __NR_mount ] = um_mount,</span><br><span class="line">	[ __NR_umount ] = sys_oldumount,</span><br><span class="line">	[ __NR_setuid ] = sys_setuid16,</span><br><span class="line">    ......</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>
<p>这里以<code>sys_write</code>举例说明</p>
<p><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v2.6.3/source">/</a><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v2.6.3/source/fs">fs</a>/<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v2.6.3/source/fs/read_write.c">read_write.c</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage <span class="type">ssize_t</span> <span class="title function_">sys_write</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> __user * buf, <span class="type">size_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">	<span class="type">ssize_t</span> ret = -EBADF;</span><br><span class="line">	<span class="type">int</span> fput_needed;</span><br><span class="line"></span><br><span class="line">	file = fget_light(fd, &amp;fput_needed);</span><br><span class="line">	<span class="keyword">if</span> (file) &#123;</span><br><span class="line">		ret = vfs_write(file, buf, count, &amp;file-&gt;f_pos);</span><br><span class="line">		fput_light(file, fput_needed);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体链接情况</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/a4b581c301038feabbedfae4cb7f02b6.gif" alt="" /></p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/0493cfc58fa2c4192f33d04d8d2309f5.gif" alt="" /></p>
<p>这样就实现了一个系统调用</p>
<h2 id="中断描述符"><a class="markdownIt-Anchor" href="#中断描述符"></a> 中断描述符</h2>
<p><strong>引发中断的方式</strong></p>
<ul>
<li>外中断</li>
<li>异常</li>
<li>软中断</li>
</ul>
<blockquote>
<p><strong>外中断</strong>就是由外部中断控制器通知 CPU 需要执行的，CPU 在当前指令执行完成之后，回去检测是否有中断产生，如果有，并且 <code>IF</code> 位有效，也就是允许中断，那么就会执行中断处理函数，这种方式直接的体验就是，CPU 可以在任意两个指令间插入一个中断函数调用，中断函数调用与普通函数调用稍有区别，在调用时栈中多压了一些数据，在中断返回时，会弹出；</p>
<p>异常和软中断统称为<strong>内中断</strong>，也就是这个中断时 CPU 和 软件内部产生的，与外部硬件无关；</p>
<p><strong>异常</strong>是 CPU 在执行过程中，执行不下去了，引发的中断调用，比如 除零异常，缺页异常，一般保护错误，有一些异常在处理后程序是可以继续执行的，比如缺页异常，而有一些异常就不行了，比如一般保护，这种情况下一般是软件访问了不该访问的内存或者寄存器，自己没有权限，于是CPU会调用一般保护异常函数，这个函数中，一般会终止该进程的执行，试图访问自己没有权限的内容，应该是危险的程序，可能是恶意程序，或者是程序有漏洞；</p>
<p><strong>软中断</strong>，可以认为是应用程序和操作系统沟通的一种方式，应用程序运行在较低的特权级，一般来说没有直接访问硬件的权限，当应用程序想要访问硬件的时候，比如典型的读写文件，就需要调用系统调用，系统调用就是用软中断实现的，也就是应用程序调用软中断函数来请求操作系统，以访问硬件，访问硬件的函数是操作系统实现的，于是被认为是安全的，就这样。</p>
</blockquote>
<p>从Linux源代码来看，当我们需要实现许多系统调用的时候，可以把所有的系统调用函数的地址写到一张函数表上，实现一个和linux差不多的系统调用表</p>
<p>对于每一个中断，我们需要一个中断描述符表(interrupte descriptor table. IDT)</p>
<p>在<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v2.6.3/source">/</a><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v2.6.3/source/arch">arch</a>/<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v2.6.3/source/arch/i386">i386</a>/<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v2.6.3/source/arch/i386/boot">boot</a>/<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v2.6.3/source/arch/i386/boot/setup.S">setup.S</a>初始化了全局描述符和中断描述符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#endif /* CONFIG_X86_VOYAGER */</span><br><span class="line"># set up gdt and idt</span><br><span class="line">	lidt	idt_48				# load idt with 0,0</span><br><span class="line">	xorl	%eax, %eax			# Compute gdt_base</span><br><span class="line">	movw	%ds, %ax			# (Convert %ds:gdt to a linear ptr)</span><br><span class="line">	shll	$4, %eax</span><br><span class="line">	addl	$gdt, %eax</span><br><span class="line">	movl	%eax, (gdt_48+2)</span><br><span class="line">	lgdt	gdt_48				# load gdt with whatever is</span><br><span class="line">						# appropriate</span><br><span class="line"></span><br><span class="line"># make sure any possible coprocessor is properly reset..</span><br><span class="line">	xorw	%ax, %ax</span><br><span class="line">	outb	%al, $0xf0</span><br><span class="line">	call	delay</span><br><span class="line"></span><br><span class="line">	outb	%al, $0xf1</span><br><span class="line">	call	delay</span><br><span class="line"></span><br><span class="line"># well, that went ok, I hope. Now we mask all interrupts - the rest</span><br><span class="line"># is done in init_IRQ().</span><br><span class="line">	movb	$0xFF, %al			# mask all interrupts for now</span><br><span class="line">	outb	%al, $0xA1</span><br><span class="line">	call	delay</span><br><span class="line">	</span><br><span class="line">	movb	$0xFB, %al			# mask all irq&#x27;s but irq2 which</span><br><span class="line">	outb	%al, $0x21			# is cascaded</span><br></pre></td></tr></table></figure>
<ul>
<li>lgdt：加载全局描述符</li>
<li>lidt：加载中断描述符</li>
</ul>
<p>中断描述符结构体</p>
<p><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.17-rc7/source">/</a><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.17-rc7/source/arch">arch</a>/<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.17-rc7/source/arch/x86">x86</a>/<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.17-rc7/source/arch/x86/kernel">kernel</a>/<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.17-rc7/source/arch/x86/kernel/idt.c">idt.c</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gate_struct</span> &#123;</span></span><br><span class="line">	u16		offset_low;</span><br><span class="line">	u16		segment;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">idt_bits</span>	<span class="title">bits</span>;</span></span><br><span class="line">	u16		offset_middle;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_64</span></span><br><span class="line">	u32		offset_high;</span><br><span class="line">	u32		reserved;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>
<p>至于最下面的<code>offset_high</code>和<code>reserved</code>都是留给x86_64的，所以我们可以定义如下结构体</p>
<p><code>src/include/xsys/interrupt.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> XSYS_INTERRUPT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XSYS_INTERRUPT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDT_SIZE 256</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">gate_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u16 offset0;    <span class="comment">// 段内偏移 0 ~ 15 位</span></span><br><span class="line">    u16 selector;   <span class="comment">// 代码段选择子</span></span><br><span class="line">    u8 reserved;    <span class="comment">// 保留不用</span></span><br><span class="line">    u8 type : <span class="number">4</span>;    <span class="comment">// 任务门/中断门/陷阱门</span></span><br><span class="line">    u8 segment : <span class="number">1</span>; <span class="comment">// segment = 0 表示系统段</span></span><br><span class="line">    u8 DPL : <span class="number">2</span>;     <span class="comment">// 使用 int 指令访问的最低权限</span></span><br><span class="line">    u8 present : <span class="number">1</span>; <span class="comment">// 是否有效</span></span><br><span class="line">    u16 offset1;    <span class="comment">// 段内偏移 16 ~ 31 位</span></span><br><span class="line">&#125; _packed <span class="type">gate_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">interrupt_init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>之后就是初始化idt</p>
<p><code>src/kernel/interrupt.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">interrupt_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; IDT_SIZE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">gate_t</span> *gate = &amp;idt[i];</span><br><span class="line"></span><br><span class="line">        gate-&gt;offset0 = (u32)interrupt_handler &amp; <span class="number">0xffff</span>;</span><br><span class="line">        gate-&gt;offset1 = ((u32)interrupt_handler &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span>;</span><br><span class="line">        gate-&gt;selector = <span class="number">1</span> &lt;&lt; <span class="number">3</span>; <span class="comment">// 代码段</span></span><br><span class="line">        gate-&gt;reserved = <span class="number">0</span>;      <span class="comment">// 保留不用</span></span><br><span class="line">        gate-&gt;type = <span class="number">0b1110</span>;     <span class="comment">// 中断门</span></span><br><span class="line">        gate-&gt;segment = <span class="number">0</span>;       <span class="comment">// 系统段</span></span><br><span class="line">        gate-&gt;DPL = <span class="number">0</span>;           <span class="comment">// 内核态</span></span><br><span class="line">        gate-&gt;present = <span class="number">1</span>;       <span class="comment">// 有效</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    idt_ptr.base = (u32)idt;</span><br><span class="line">    idt_ptr.limit = <span class="keyword">sizeof</span>(idt) - <span class="number">1</span>;</span><br><span class="line">    BMB;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;lidt idt_ptr\n&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>gate-&gt;type</code></p>
<ul>
<li>0b0101 - 任务门 (Task Gate)：很复杂，而且很低效 x64 就去掉了这种门</li>
<li>0b1110 - <strong>中断门</strong> (Interrupt Gate) <code>IF</code> 位自动置为 0</li>
<li>0b1111 - 陷阱门 (Trap Gate)</li>
</ul>
<p>同时模仿linux，有中断处理函数入口的程序</p>
<p><code>src/kernel/handler.asm</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[bits 32]</span><br><span class="line">; 中断处理函数入口 </span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line"></span><br><span class="line">extern printk</span><br><span class="line"></span><br><span class="line">global interrupt_handler</span><br><span class="line">interrupt_handler:</span><br><span class="line">    xchg bx, bx</span><br><span class="line">    push message</span><br><span class="line">    call printk</span><br><span class="line">    add esp, 4</span><br><span class="line"></span><br><span class="line">    xchg bx, bx</span><br><span class="line">    iret</span><br><span class="line"></span><br><span class="line">section .data</span><br><span class="line">message:</span><br><span class="line">    db &quot;interrput test&quot;,10,0</span><br></pre></td></tr></table></figure>
<p>我们可以创建255个系统中断，即255个IDT，使用bochs调试一下</p>
<img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/20ab8c0534f31a69adb1ef3e16237537.png" alt="image-20220313194615258" style="zoom:67%;" />
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/890281ea6b2a238fd17ddd4fb81ed4f3.png" alt="image-20220314161529157" /></p>
<p>而idt的地址：0x10900就是<code>interrupt_handler</code></p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/f4a92a0c883d3de7d2dd63702beeb297.png" alt="image-20220314161644636" /></p>
<p>最后也被成功执行了</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/6aabfdfbbd5a3b457c9576583f8d4462.png" alt="image-20220314161852144" /></p>
<h2 id="参考-4"><a class="markdownIt-Anchor" href="#参考-4"></a> 参考</h2>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/LittleHann/p/3871630.html">https://www.cnblogs.com/LittleHann/p/3871630.html</a></p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Interrupt_vector_table">https://en.wikipedia.org/wiki/Interrupt_vector_table</a></p>
<h1 id="操作系统实现-异常"><a class="markdownIt-Anchor" href="#操作系统实现-异常"></a> 操作系统实现-异常</h1>
<h2 id="简单实现"><a class="markdownIt-Anchor" href="#简单实现"></a> 简单实现</h2>
<p><strong>异常</strong></p>
<ul>
<li>故障</li>
<li>陷阱</li>
<li>终止</li>
</ul>
<p><strong>故障 Fault</strong></p>
<ul>
<li>这种错误是可以被修复的一种类型，属于最轻的一种异常；</li>
</ul>
<p><strong>陷阱 Trap</strong></p>
<ul>
<li>此异常通常用于调试</li>
</ul>
<p><strong>终止 Abort</strong></p>
<ul>
<li>是最严重的异常类型，一旦出现由于 错误无法修复，程序将无法继续运行</li>
</ul>
<p>每个一场都需要一个中断，所以有30个中断，用到汇编宏(marco)去处理</p>
<p><code>src/kernel/handler.asm</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line">[bits 32]</span><br><span class="line">; 中断处理函数入口 </span><br><span class="line"></span><br><span class="line">extern handler_table</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line"></span><br><span class="line">%macro INTERRUPT_HANDLER 2</span><br><span class="line">interrupt_handler_%1:</span><br><span class="line">    xchg bx, bx</span><br><span class="line">%ifn %2</span><br><span class="line">    push 0x20222202</span><br><span class="line">%endif</span><br><span class="line">    push %1; 压入中断向量，跳转到中断入口</span><br><span class="line">    jmp interrupt_entry</span><br><span class="line">%endmacro</span><br><span class="line"></span><br><span class="line">interrupt_entry:</span><br><span class="line"></span><br><span class="line">    ; 保存上文寄存器信息</span><br><span class="line">    push ds</span><br><span class="line">    push es</span><br><span class="line">    push fs</span><br><span class="line">    push gs</span><br><span class="line">    pusha</span><br><span class="line"></span><br><span class="line">    ; 找到前面 push %1 压入的 中断向量</span><br><span class="line">    mov eax, [esp + 12 * 4]</span><br><span class="line"></span><br><span class="line">    ; 向中断处理函数传递参数</span><br><span class="line">    push eax</span><br><span class="line"></span><br><span class="line">    ; 调用中断处理函数，handler_table 中存储了中断处理函数的指针</span><br><span class="line">    call [handler_table + eax * 4]</span><br><span class="line"></span><br><span class="line">    ; 对应 push eax，调用结束恢复栈</span><br><span class="line">    add esp, 4</span><br><span class="line"></span><br><span class="line">    ; 恢复下文寄存器信息</span><br><span class="line">    popa</span><br><span class="line">    pop gs</span><br><span class="line">    pop fs</span><br><span class="line">    pop es</span><br><span class="line">    pop ds</span><br><span class="line"></span><br><span class="line">    ; 对应 push %1</span><br><span class="line">    ; 对应 error code 或 push magic</span><br><span class="line">    add esp, 8</span><br><span class="line">    iret</span><br><span class="line"></span><br><span class="line">INTERRUPT_HANDLER 0x00, 0; divide by zero</span><br><span class="line">INTERRUPT_HANDLER 0x01, 0; debug</span><br><span class="line">INTERRUPT_HANDLER 0x02, 0; non maskable interrupt</span><br><span class="line">INTERRUPT_HANDLER 0x03, 0; breakpoint</span><br><span class="line"></span><br><span class="line">INTERRUPT_HANDLER 0x04, 0; overflow</span><br><span class="line">INTERRUPT_HANDLER 0x05, 0; bound range exceeded</span><br><span class="line">INTERRUPT_HANDLER 0x06, 0; invalid opcode</span><br><span class="line">INTERRUPT_HANDLER 0x07, 0; device not avilable</span><br><span class="line"></span><br><span class="line">INTERRUPT_HANDLER 0x08, 1; double fault</span><br><span class="line">INTERRUPT_HANDLER 0x09, 0; coprocessor segment overrun</span><br><span class="line">INTERRUPT_HANDLER 0x0a, 1; invalid TSS</span><br><span class="line">INTERRUPT_HANDLER 0x0b, 1; segment not present</span><br><span class="line"></span><br><span class="line">INTERRUPT_HANDLER 0x0c, 1; stack segment fault</span><br><span class="line">INTERRUPT_HANDLER 0x0d, 1; general protection fault</span><br><span class="line">INTERRUPT_HANDLER 0x0e, 1; page fault</span><br><span class="line">INTERRUPT_HANDLER 0x0f, 0; reserved</span><br><span class="line"></span><br><span class="line">INTERRUPT_HANDLER 0x10, 0; x87 floating point exception</span><br><span class="line">INTERRUPT_HANDLER 0x11, 1; alignment check</span><br><span class="line">INTERRUPT_HANDLER 0x12, 0; machine check</span><br><span class="line">INTERRUPT_HANDLER 0x13, 0; SIMD Floating - Point Exception</span><br><span class="line"></span><br><span class="line">INTERRUPT_HANDLER 0x14, 0; Virtualization Exception</span><br><span class="line">INTERRUPT_HANDLER 0x15, 1; Control Protection Exception</span><br><span class="line">INTERRUPT_HANDLER 0x16, 0; reserved</span><br><span class="line">INTERRUPT_HANDLER 0x17, 0; reserved</span><br><span class="line"></span><br><span class="line">INTERRUPT_HANDLER 0x18, 0; reserved</span><br><span class="line">INTERRUPT_HANDLER 0x19, 0; reserved</span><br><span class="line">INTERRUPT_HANDLER 0x1a, 0; reserved</span><br><span class="line">INTERRUPT_HANDLER 0x1b, 0; reserved</span><br><span class="line"></span><br><span class="line">INTERRUPT_HANDLER 0x1c, 0; reserved</span><br><span class="line">INTERRUPT_HANDLER 0x1d, 0; reserved</span><br><span class="line">INTERRUPT_HANDLER 0x1e, 0; reserved</span><br><span class="line">INTERRUPT_HANDLER 0x1f, 0; reserved</span><br><span class="line"></span><br><span class="line">INTERRUPT_HANDLER 0x20, 0; clock 时钟中断</span><br><span class="line">INTERRUPT_HANDLER 0x21, 0</span><br><span class="line">INTERRUPT_HANDLER 0x22, 0</span><br><span class="line">INTERRUPT_HANDLER 0x23, 0</span><br><span class="line">INTERRUPT_HANDLER 0x24, 0</span><br><span class="line">INTERRUPT_HANDLER 0x25, 0</span><br><span class="line">INTERRUPT_HANDLER 0x26, 0</span><br><span class="line">INTERRUPT_HANDLER 0x27, 0</span><br><span class="line">INTERRUPT_HANDLER 0x28, 0</span><br><span class="line">INTERRUPT_HANDLER 0x29, 0</span><br><span class="line">INTERRUPT_HANDLER 0x2a, 0</span><br><span class="line">INTERRUPT_HANDLER 0x2b, 0</span><br><span class="line">INTERRUPT_HANDLER 0x2c, 0</span><br><span class="line">INTERRUPT_HANDLER 0x2d, 0</span><br><span class="line">INTERRUPT_HANDLER 0x2e, 0</span><br><span class="line">INTERRUPT_HANDLER 0x2f, 0</span><br><span class="line"></span><br><span class="line">; 下面的数组记录了每个中断入口函数的指针</span><br><span class="line">section .data</span><br><span class="line">global handler_entry_table</span><br><span class="line">handler_entry_table:</span><br><span class="line">    dd interrupt_handler_0x00</span><br><span class="line">    dd interrupt_handler_0x01</span><br><span class="line">    dd interrupt_handler_0x02</span><br><span class="line">    dd interrupt_handler_0x03</span><br><span class="line">    dd interrupt_handler_0x04</span><br><span class="line">    dd interrupt_handler_0x05</span><br><span class="line">    dd interrupt_handler_0x06</span><br><span class="line">    dd interrupt_handler_0x07</span><br><span class="line">    dd interrupt_handler_0x08</span><br><span class="line">    dd interrupt_handler_0x09</span><br><span class="line">    dd interrupt_handler_0x0a</span><br><span class="line">    dd interrupt_handler_0x0b</span><br><span class="line">    dd interrupt_handler_0x0c</span><br><span class="line">    dd interrupt_handler_0x0d</span><br><span class="line">    dd interrupt_handler_0x0e</span><br><span class="line">    dd interrupt_handler_0x0f</span><br><span class="line">    dd interrupt_handler_0x10</span><br><span class="line">    dd interrupt_handler_0x11</span><br><span class="line">    dd interrupt_handler_0x12</span><br><span class="line">    dd interrupt_handler_0x13</span><br><span class="line">    dd interrupt_handler_0x14</span><br><span class="line">    dd interrupt_handler_0x15</span><br><span class="line">    dd interrupt_handler_0x16</span><br><span class="line">    dd interrupt_handler_0x17</span><br><span class="line">    dd interrupt_handler_0x18</span><br><span class="line">    dd interrupt_handler_0x19</span><br><span class="line">    dd interrupt_handler_0x1a</span><br><span class="line">    dd interrupt_handler_0x1b</span><br><span class="line">    dd interrupt_handler_0x1c</span><br><span class="line">    dd interrupt_handler_0x1d</span><br><span class="line">    dd interrupt_handler_0x1e</span><br><span class="line">    dd interrupt_handler_0x1f</span><br><span class="line">    dd interrupt_handler_0x20</span><br><span class="line">    dd interrupt_handler_0x21</span><br><span class="line">    dd interrupt_handler_0x22</span><br><span class="line">    dd interrupt_handler_0x23</span><br><span class="line">    dd interrupt_handler_0x24</span><br><span class="line">    dd interrupt_handler_0x25</span><br><span class="line">    dd interrupt_handler_0x26</span><br><span class="line">    dd interrupt_handler_0x27</span><br><span class="line">    dd interrupt_handler_0x28</span><br><span class="line">    dd interrupt_handler_0x29</span><br><span class="line">    dd interrupt_handler_0x2a</span><br><span class="line">    dd interrupt_handler_0x2b</span><br><span class="line">    dd interrupt_handler_0x2c</span><br><span class="line">    dd interrupt_handler_0x2d</span><br><span class="line">    dd interrupt_handler_0x2e</span><br><span class="line">    dd interrupt_handler_0x2f</span><br></pre></td></tr></table></figure>
<p><code>src/include/xsys/interrupt.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> XSYS_INTERRUPT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XSYS_INTERRUPT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDT_SIZE 256</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">gate_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u16 offset0;    <span class="comment">// 段内偏移 0 ~ 15 位</span></span><br><span class="line">    u16 selector;   <span class="comment">// 代码段选择子</span></span><br><span class="line">    u8 reserved;    <span class="comment">// 保留不用</span></span><br><span class="line">    u8 type : <span class="number">4</span>;    <span class="comment">// 任务门/中断门/陷阱门</span></span><br><span class="line">    u8 segment : <span class="number">1</span>; <span class="comment">// segment = 0 表示系统段</span></span><br><span class="line">    u8 DPL : <span class="number">2</span>;     <span class="comment">// 使用 int 指令访问的最低权限</span></span><br><span class="line">    u8 present : <span class="number">1</span>; <span class="comment">// 是否有效</span></span><br><span class="line">    u16 offset1;    <span class="comment">// 段内偏移 16 ~ 31 位</span></span><br><span class="line">&#125; _packed <span class="type">gate_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> *<span class="type">handler_t</span>; <span class="comment">// 中断处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">interrupt_init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>src/kernel/interrupt.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/global.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/debug.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/printk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGK(fmt, args...) DEBUGK(fmt, ##args)</span></span><br><span class="line"><span class="comment">// #define LOGK(fmt, args...)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENTRY_SIZE 0x30</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC_M_CTRL 0x20 <span class="comment">// 主片的控制端口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC_M_DATA 0x21 <span class="comment">// 主片的数据端口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC_S_CTRL 0xa0 <span class="comment">// 从片的控制端口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC_S_DATA 0xa1 <span class="comment">// 从片的数据端口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC_EOI 0x20    <span class="comment">// 通知中断控制器中断结束</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">gate_t</span> idt[IDT_SIZE];</span><br><span class="line"><span class="type">pointer_t</span> idt_ptr;</span><br><span class="line"></span><br><span class="line"><span class="type">handler_t</span> handler_table[IDT_SIZE];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">handler_t</span> handler_entry_table[ENTRY_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *messages[] = &#123;</span><br><span class="line">    <span class="string">&quot;#DE Divide Error\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#DB RESERVED\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;--  NMI Interrupt\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#BP Breakpoint\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#OF Overflow\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#BR BOUND Range Exceeded\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#UD Invalid Opcode (Undefined Opcode)\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#NM Device Not Available (No Math Coprocessor)\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#DF Double Fault\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;    Coprocessor Segment Overrun (reserved)\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#TS Invalid TSS\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#NP Segment Not Present\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#SS Stack-Segment Fault\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#GP General Protection\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#PF Page Fault\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;--  (Intel reserved. Do not use.)\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#MF x87 FPU Floating-Point Error (Math Fault)\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#AC Alignment Check\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#MC Machine Check\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#XF SIMD Floating-Point Exception\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#VE Virtualization Exception\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#CP Control Protection Exception\0&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">exception_handler</span><span class="params">(<span class="type">int</span> <span class="built_in">vector</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *message = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vector</span> &lt; <span class="number">22</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        message = messages[<span class="built_in">vector</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        message = messages[<span class="number">15</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;\nEXCEPTION : %s \n&quot;</span>, messages[<span class="built_in">vector</span>]);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化中断描述符，和中断处理函数数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">interrupt_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; ENTRY_SIZE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">gate_t</span> *gate = &amp;idt[i];</span><br><span class="line">        <span class="type">handler_t</span> handler = handler_entry_table[i];</span><br><span class="line"></span><br><span class="line">        gate-&gt;offset0 = (u32)handler &amp; <span class="number">0xffff</span>;</span><br><span class="line">        gate-&gt;offset1 = ((u32)handler &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span>;</span><br><span class="line">        gate-&gt;selector = <span class="number">1</span> &lt;&lt; <span class="number">3</span>; <span class="comment">// 代码段</span></span><br><span class="line">        gate-&gt;reserved = <span class="number">0</span>;      <span class="comment">// 保留不用</span></span><br><span class="line">        gate-&gt;type = <span class="number">0b1110</span>;     <span class="comment">// 中断门</span></span><br><span class="line">        gate-&gt;segment = <span class="number">0</span>;       <span class="comment">// 系统段</span></span><br><span class="line">        gate-&gt;DPL = <span class="number">0</span>;           <span class="comment">// 内核态</span></span><br><span class="line">        gate-&gt;present = <span class="number">1</span>;       <span class="comment">// 有效</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">0x20</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        handler_table[i] = exception_handler;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    idt_ptr.base = (u32)idt;</span><br><span class="line">    idt_ptr.limit = <span class="keyword">sizeof</span>(idt) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;lidt idt_ptr\n&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在start.asm中写一个int 0x80超出范围调用</p>
<p><code>src/kernel/start.asm</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[bits 32]</span><br><span class="line"></span><br><span class="line">extern kernel_init</span><br><span class="line"></span><br><span class="line">global _start</span><br><span class="line">_start:</span><br><span class="line">    call kernel_init</span><br><span class="line">    int 0x80</span><br><span class="line">    jmp $</span><br></pre></td></tr></table></figure>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/d61f6f2b0d54d1429da0edfcc376aac5.png" alt="image-20220314212759582" /></p>
<p>可以看到已经把参数都压进去了，根据判断启动了第13号默认调用</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/32aa2c1f20bafed28c55757c5da70574.png" alt="image-20220314213017271" /></p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/ff2e0e611fa88a5dc96f16007f933c93.png" alt="image-20220314213116695" /></p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/be45a1f909c507fc453ea7dfc490d92b.png" alt="image-20220314213058124" /></p>
<p>再是一个除0异常</p>
<p><code>src/kernel/start.asm</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[bits 32]</span><br><span class="line"></span><br><span class="line">extern kernel_init</span><br><span class="line"></span><br><span class="line">global _start</span><br><span class="line">_start:</span><br><span class="line">    call kernel_init</span><br><span class="line">    mov bx, 0</span><br><span class="line">    div bx</span><br><span class="line">    jmp $</span><br></pre></td></tr></table></figure>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/4233edd16d77b2a55e09fbf4b10d4169.png" alt="image-20220314213325088" /></p>
<p><strong>异常列表</strong></p>
<table>
<thead>
<tr>
<th>编号</th>
<th>名称</th>
<th>类型</th>
<th>助记符</th>
<th>错误码</th>
</tr>
</thead>
<tbody>
<tr>
<td>0 (0x0)</td>
<td>除零错误</td>
<td>故障</td>
<td>#DE</td>
<td>无</td>
</tr>
<tr>
<td>1 (0x1)</td>
<td>调试</td>
<td>故障/陷阱</td>
<td>#DB</td>
<td>无</td>
</tr>
<tr>
<td>2 (0x2)</td>
<td>不可屏蔽中断</td>
<td>中断</td>
<td>-</td>
<td>无</td>
</tr>
<tr>
<td>3 (0x3)</td>
<td>断点</td>
<td>陷阱</td>
<td>#BP</td>
<td>无</td>
</tr>
<tr>
<td>4 (0x4)</td>
<td>溢出</td>
<td>陷阱</td>
<td>#OF</td>
<td>无</td>
</tr>
<tr>
<td>5 (0x5)</td>
<td>越界</td>
<td>故障</td>
<td>#BR</td>
<td>无</td>
</tr>
<tr>
<td>6 (0x6)</td>
<td>指令无效</td>
<td>故障</td>
<td>#UD</td>
<td>无</td>
</tr>
<tr>
<td>7 (0x7)</td>
<td>设备不可用</td>
<td>故障</td>
<td>#NM</td>
<td>无</td>
</tr>
<tr>
<td>8 (0x8)</td>
<td>双重错误</td>
<td>终止</td>
<td>#DF</td>
<td>有 (Zero)</td>
</tr>
<tr>
<td>9 (0x9)</td>
<td>协处理器段超限</td>
<td>故障</td>
<td>-</td>
<td>无</td>
</tr>
<tr>
<td>10 (0xA)</td>
<td>无效任务状态段</td>
<td>故障</td>
<td>#TS</td>
<td>有</td>
</tr>
<tr>
<td>11 (0xB)</td>
<td>段无效</td>
<td>故障</td>
<td>#NP</td>
<td>有</td>
</tr>
<tr>
<td>12 (0xC)</td>
<td>栈段错误</td>
<td>故障</td>
<td>#SS</td>
<td>有</td>
</tr>
<tr>
<td>13 (0xD)</td>
<td>一般性保护异常</td>
<td>故障</td>
<td>#GP</td>
<td>有</td>
</tr>
<tr>
<td>14 (0xE)</td>
<td>缺页错误</td>
<td>故障</td>
<td>#PF</td>
<td>有</td>
</tr>
<tr>
<td>15 (0xF)</td>
<td>保留</td>
<td>-</td>
<td>-</td>
<td>无</td>
</tr>
<tr>
<td>16 (0x10)</td>
<td>浮点异常</td>
<td>故障</td>
<td>#MF</td>
<td>无</td>
</tr>
<tr>
<td>17 (0x11)</td>
<td>对齐检测</td>
<td>故障</td>
<td>#AC</td>
<td>有</td>
</tr>
<tr>
<td>18 (0x12)</td>
<td>机器检测</td>
<td>终止</td>
<td>#MC</td>
<td>无</td>
</tr>
<tr>
<td>19 (0x13)</td>
<td>SIMD 浮点异常</td>
<td>故障</td>
<td>#XM/#XF</td>
<td>无</td>
</tr>
<tr>
<td>20 (0x14)</td>
<td>虚拟化异常</td>
<td>故障</td>
<td>#VE</td>
<td>无</td>
</tr>
<tr>
<td>21 (0x15)</td>
<td>控制保护异常</td>
<td>故障</td>
<td>#CP</td>
<td>有</td>
</tr>
<tr>
<td>22-31 (0x16-0x1f)</td>
<td>保留</td>
<td>-</td>
<td>-</td>
<td>无</td>
</tr>
</tbody>
</table>
<h2 id="linux是怎样做到的"><a class="markdownIt-Anchor" href="#linux是怎样做到的"></a> Linux是怎样做到的</h2>
<p>官方说明：<a target="_blank" rel="noopener" href="https://linux-kernel-labs.github.io/refs/heads/master/lectures/interrupts.html">https://linux-kernel-labs.github.io/refs/heads/master/lectures/interrupts.html</a></p>
<blockquote>
<p>Below we can find Linux IRQ vector layout. The first 32 entries are reserved for exceptions, vector 128 is used for syscall interface and the rest are used mostly for hardware interrupts handlers.</p>
</blockquote>
<p>这是linux对不同中断编号的分类</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/482dba65579a57ea5dcc2524e812806e.png" alt="" /></p>
<p>在复习下之前的<a target="_blank" rel="noopener" href="https://blog.joe1sn.top/2022/03/10/os-interrupt/"><strong>操作系统实现-系统中断</strong></a>的内容，我们在这篇博客里面是实现的<strong>异常处理</strong>，再Linux上对应的编号是0~31</p>
<p><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.16.14/source">/</a><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.16.14/source/arch">arch</a>/<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.16.14/source/arch/x86">x86</a>/<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.16.14/source/arch/x86/include">include</a>/<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.16.14/source/arch/x86/include/asm">asm</a>/<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.16.14/source/arch/x86/include/asm/irq_vectors.h">irq_vectors.h</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* SPDX-License-Identifier: GPL-2.0 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _ASM_X86_IRQ_VECTORS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ASM_X86_IRQ_VECTORS_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/threads.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Linux IRQ vector layout.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * There are 256 IDT entries (per CPU - each entry is 8 bytes) which can</span></span><br><span class="line"><span class="comment"> * be defined by Linux. They are used as a jump table by the CPU when a</span></span><br><span class="line"><span class="comment"> * given vector is triggered - by a CPU-external, CPU-internal or</span></span><br><span class="line"><span class="comment"> * software-triggered event.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Linux sets the kernel code address each entry jumps to early during</span></span><br><span class="line"><span class="comment"> * bootup, and never changes them. This is the general layout of the</span></span><br><span class="line"><span class="comment"> * IDT entries:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Vectors   0 ...  31 : system traps and exceptions - hardcoded events</span></span><br><span class="line"><span class="comment"> *  Vectors  32 ... 127 : device interrupts</span></span><br><span class="line"><span class="comment"> *  Vector  128         : legacy int80 syscall interface</span></span><br><span class="line"><span class="comment"> *  Vectors 129 ... LOCAL_TIMER_VECTOR-1</span></span><br><span class="line"><span class="comment"> *  Vectors LOCAL_TIMER_VECTOR ... 255 : special interrupts</span></span><br><span class="line"><span class="comment">.....</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is used as an interrupt vector when programming the APIC. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NMI_VECTOR			0x02</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * IDT vectors usable for external interrupt sources start at 0x20.</span></span><br><span class="line"><span class="comment"> * (0x80 is the syscall vector, 0x30-0x3f are for ISA)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIRST_EXTERNAL_VECTOR		0x20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Reserve the lowest usable vector (and hence lowest priority)  0x20 for</span></span><br><span class="line"><span class="comment"> * triggering cleanup after irq migration. 0x21-0x2f will still be used</span></span><br><span class="line"><span class="comment"> * for device interrupts.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_MOVE_CLEANUP_VECTOR		FIRST_EXTERNAL_VECTOR</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IA32_SYSCALL_VECTOR		0x80</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Vectors 0x30-0x3f are used for ISA interrupts.</span></span><br><span class="line"><span class="comment"> *   round up to the next 16-vector boundary</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ISA_IRQ_VECTOR(irq)		(((FIRST_EXTERNAL_VECTOR + 16) &amp; ~15) + irq)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Special IRQ vectors used by the SMP architecture, 0xf0-0xff</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  some of the following vectors are &#x27;rare&#x27;, they are merged</span></span><br><span class="line"><span class="comment"> *  into a single vector (CALL_FUNCTION_VECTOR) to save vector space.</span></span><br><span class="line"><span class="comment"> *  TLB, reschedule and local APIC vectors are performance-critical.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPURIOUS_APIC_VECTOR		0xff</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Sanity check</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ((SPURIOUS_APIC_VECTOR &amp; 0x0F) != 0x0F)</span></span><br><span class="line"><span class="meta"># <span class="keyword">error</span> SPURIOUS_APIC_VECTOR definition <span class="keyword">error</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR_APIC_VECTOR		0xfe</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RESCHEDULE_VECTOR		0xfd</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CALL_FUNCTION_VECTOR		0xfc</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CALL_FUNCTION_SINGLE_VECTOR	0xfb</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THERMAL_APIC_VECTOR		0xfa</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THRESHOLD_APIC_VECTOR		0xf9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REBOOT_VECTOR			0xf8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Generic system vector for platform specific use</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X86_PLATFORM_IPI_VECTOR		0xf7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * IRQ work vector:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Size the maximum number of interrupts.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the irq_desc[] array has a sparse layout, we can size things</span></span><br><span class="line"><span class="comment"> * generously - it scales up linearly with the maximum number of CPUs,</span></span><br><span class="line"><span class="comment"> * and the maximum number of IO-APICs, whichever is higher.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * In other cases we size more conservatively, to not create too large</span></span><br><span class="line"><span class="comment"> * static arrays.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NR_IRQS_LEGACY			16</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CPU_VECTOR_LIMIT		(64 * NR_CPUS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IO_APIC_VECTOR_LIMIT		(32 * MAX_IO_APICS)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_X86_IO_APIC) &amp;&amp; defined(CONFIG_PCI_MSI)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NR_IRQS						\</span></span><br><span class="line"><span class="meta">	(CPU_VECTOR_LIMIT &gt; IO_APIC_VECTOR_LIMIT ?	\</span></span><br><span class="line"><span class="meta">		(NR_VECTORS + CPU_VECTOR_LIMIT)  :	\</span></span><br><span class="line"><span class="meta">		(NR_VECTORS + IO_APIC_VECTOR_LIMIT))</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(CONFIG_X86_IO_APIC)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	NR_IRQS				(NR_VECTORS + IO_APIC_VECTOR_LIMIT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(CONFIG_PCI_MSI)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NR_IRQS				(NR_VECTORS + CPU_VECTOR_LIMIT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NR_IRQS				NR_IRQS_LEGACY</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* _ASM_X86_IRQ_VECTORS_H */</span></span></span><br></pre></td></tr></table></figure>
<p>接着就是三种门：</p>
<blockquote>
<p>On x86 an IDT entry has 8 bytes and it is named gate. There can be 3 types of gates:</p>
<ul>
<li>interrupt gate, holds the address of an interrupt or exception handler. Jumping to the handler disables maskable interrupts (IF flag is cleared).</li>
<li>trap gates, similar to an interrupt gate but it does not disable maskable interrupts while jumping to interrupt/exception handler.</li>
<li>task gates (not used in Linux)</li>
</ul>
</blockquote>
<p>这个gate就是中断描述符的结构体，具体门的有三种：中断门、陷阱门、任务门(没有再Linux上使用)</p>
<p>同时文档也向我们说明了IDT_Entry（即：门）的属性</p>
<blockquote>
<p>Let’s have a look at several fields of an IDT entry:</p>
<ul>
<li>segment selector, index into GDT/LDT to find the start of the code segment where the interrupt handlers reside</li>
<li>offset, offset inside the code segment</li>
<li>T, represents the type of gate</li>
<li>DPL, minimum privilege required for using the segments content.</li>
</ul>
</blockquote>
<ol>
<li>要有一个段选择子，能够将从全局描述符表和和中断描述符表找到对应的内存和中断函数(imnterrupt handlers)</li>
<li>在代码段中的偏移</li>
<li>门类型的代表</li>
<li>使用该段信息的最小权限值</li>
</ol>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/e00e9dfd5f5950e16fa7b160e7784454.png" alt="" /></p>
<p>所以我们写除了代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">gate_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u16 offset0;    <span class="comment">// 段内偏移 0 ~ 15 位</span></span><br><span class="line">    u16 selector;   <span class="comment">// 代码段选择子</span></span><br><span class="line">    u8 reserved;    <span class="comment">// 保留不用</span></span><br><span class="line">    u8 type : <span class="number">4</span>;    <span class="comment">// 任务门/中断门/陷阱门</span></span><br><span class="line">    u8 segment : <span class="number">1</span>; <span class="comment">// segment = 0 表示系统段</span></span><br><span class="line">    u8 DPL : <span class="number">2</span>;     <span class="comment">// 使用 int 指令访问的最低权限</span></span><br><span class="line">    u8 present : <span class="number">1</span>; <span class="comment">// 是否有效</span></span><br><span class="line">    u16 offset1;    <span class="comment">// 段内偏移 16 ~ 31 位</span></span><br><span class="line">&#125; _packed <span class="type">gate_t</span>;</span><br></pre></td></tr></table></figure>
<p>同时的Linux实现：</p>
<p><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.16.14/source">/</a><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.16.14/source/arch">arch</a>/<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.16.14/source/arch/x86">x86</a>/<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.16.14/source/arch/x86/include">include</a>/<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.16.14/source/arch/x86/include/asm">asm</a>/<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.16.14/source/arch/x86/include/asm/desc_defs.h#L84">desc_defs.h</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gate_struct</span> &#123;</span></span><br><span class="line">	u16		offset_low;</span><br><span class="line">	u16		segment;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">idt_bits</span>	<span class="title">bits</span>;</span></span><br><span class="line">	u16		offset_middle;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_64</span></span><br><span class="line">	u32		offset_high;</span><br><span class="line">	u32		reserved;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>
<p>从上面得知我们需要对gate有初始化</p>
<p>所以写了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">interrupt_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; ENTRY_SIZE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">gate_t</span> *gate = &amp;idt[i];</span><br><span class="line">        <span class="type">handler_t</span> handler = handler_entry_table[i];</span><br><span class="line"></span><br><span class="line">        gate-&gt;offset0 = (u32)handler &amp; <span class="number">0xffff</span>;</span><br><span class="line">        gate-&gt;offset1 = ((u32)handler &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span>;</span><br><span class="line">        gate-&gt;selector = <span class="number">1</span> &lt;&lt; <span class="number">3</span>; <span class="comment">// 代码段</span></span><br><span class="line">        gate-&gt;reserved = <span class="number">0</span>;      <span class="comment">// 保留不用</span></span><br><span class="line">        gate-&gt;type = <span class="number">0b1110</span>;     <span class="comment">// 中断门</span></span><br><span class="line">        gate-&gt;segment = <span class="number">0</span>;       <span class="comment">// 系统段</span></span><br><span class="line">        gate-&gt;DPL = <span class="number">0</span>;           <span class="comment">// 内核态</span></span><br><span class="line">        gate-&gt;present = <span class="number">1</span>;       <span class="comment">// 有效</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">0x20</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        handler_table[i] = exception_handler;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    idt_ptr.base = (u32)idt;</span><br><span class="line">    idt_ptr.limit = <span class="keyword">sizeof</span>(idt) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;lidt idt_ptr\n&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的Linux中有：（这也只是其中一种）</p>
<p><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.17-rc7/source">/</a><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.17-rc7/source/arch">arch</a>/<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.17-rc7/source/arch/x86">x86</a>/<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.17-rc7/source/arch/x86/boot">boot</a>/<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.17-rc7/source/arch/x86/boot/compressed">compressed</a>/<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.17-rc7/source/arch/x86/boot/compressed/idt_64.c">idt_64.c</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">set_idt_entry</span><span class="params">(<span class="type">int</span> <span class="built_in">vector</span>, <span class="type">void</span> (*handler)(<span class="type">void</span>))</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> address = (<span class="type">unsigned</span> <span class="type">long</span>)handler;</span><br><span class="line">	gate_desc entry;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(&amp;entry, <span class="number">0</span>, <span class="keyword">sizeof</span>(entry));</span><br><span class="line"></span><br><span class="line">	entry.offset_low    = (u16)(address &amp; <span class="number">0xffff</span>);</span><br><span class="line">	entry.segment       = __KERNEL_CS;</span><br><span class="line">	entry.bits.type     = GATE_TRAP;</span><br><span class="line">	entry.bits.p        = <span class="number">1</span>;</span><br><span class="line">	entry.offset_middle = (u16)((address &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span>);</span><br><span class="line">	entry.offset_high   = (u32)(address &gt;&gt; <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;boot_idt[<span class="built_in">vector</span>], &amp;entry, <span class="keyword">sizeof</span>(entry));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还需要一个函数来帮助gate的段选择子找到相对应的系统调用号，这个函数被称为<code>interrupt_handler</code></p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/df087a902cbe021c21afdd2d752d7fb4.png" alt="" /></p>
<p>这里我们实现的是异常，所以是<code>exception_handler</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exception_handler</span><span class="params">(<span class="type">int</span> <span class="built_in">vector</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *message = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vector</span> &lt; <span class="number">22</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        message = messages[<span class="built_in">vector</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        message = messages[<span class="number">15</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;\nEXCEPTION : %s \n&quot;</span>, messages[<span class="built_in">vector</span>]);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时我门在跳转的时候需要使用栈来保存相关信息，并且要记录系统调用号对应的函数地址，对于有的报错需要压入一些值到栈里面</p>
<blockquote>
<p>As can be seen in the figure below, an interrupt pushes the EFLAGS register before saving the address of the interrupted instruction. Certain types of exceptions also cause an error code to be pushed on the stack to help debug the exception.</p>
<ul>
<li>
<p>CPU checks the current privilege level</p>
</li>
<li>
<p>if need to change privilege level</p>
<blockquote>
<ul>
<li>change stack with the one associated with new privilege</li>
<li>save old stack information on the new stack</li>
</ul>
</blockquote>
</li>
<li>
<p>save EFLAGS, CS, EIP on stack</p>
</li>
<li>
<p>save error code on stack in case of an abort</p>
</li>
<li>
<p>execute the kernel interrupt handler</p>
</li>
</ul>
<p>To resume the execution after an interrupt the following sequence is used (x86):</p>
<ul>
<li>pop the error code (in case of an abort)</li>
<li>call IRET
<ul>
<li>pops values from the stack and restore the following register: CS, EIP, EFLAGS</li>
<li>if privilege level changed returns to the old stack and old privilege level</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/b34acca49e3b05e5536de6aba53b2674.png" alt="" /></p>
<p>所以也有了<code>handler.asm</code>中的<code>handler_entry_table</code>那么长一串，以及</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">interrupt_entry:</span><br><span class="line"></span><br><span class="line">    ; 保存上文寄存器信息</span><br><span class="line">    push ds</span><br><span class="line">    push es</span><br><span class="line">    push fs</span><br><span class="line">    push gs</span><br><span class="line">    pusha</span><br><span class="line"></span><br><span class="line">    ; 找到前面 push %1 压入的 中断向量</span><br><span class="line">    mov eax, [esp + 12 * 4]</span><br><span class="line"></span><br><span class="line">    ; 向中断处理函数传递参数</span><br><span class="line">    push eax</span><br><span class="line"></span><br><span class="line">    ; 调用中断处理函数，handler_table 中存储了中断处理函数的指针</span><br><span class="line">    call [handler_table + eax * 4]</span><br><span class="line"></span><br><span class="line">    ; 对应 push eax，调用结束恢复栈</span><br><span class="line">    add esp, 4</span><br><span class="line"></span><br><span class="line">    ; 恢复下文寄存器信息</span><br><span class="line">    popa</span><br><span class="line">    pop gs</span><br><span class="line">    pop fs</span><br><span class="line">    pop es</span><br><span class="line">    pop ds</span><br><span class="line"></span><br><span class="line">    ; 对应 push %1</span><br><span class="line">    ; 对应 error code 或 push magic</span><br><span class="line">    add esp, 8</span><br><span class="line">    iret</span><br></pre></td></tr></table></figure>
<p>同样的在Linux中也有，但是他的实现更加的复杂</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/d4e49ec3ae65ad3cb7269ca47a22b5cc.png" alt="" /></p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/04d3f830ec26811739d85f99359e59e8.jpg" alt="" /></p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/6a2b08d2b164630b6c9457602730a29e.jpg" alt="" /></p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/ef7eb5d1bc8e06d5405bbf575ddaa4db.jpg" alt="" /></p>
<p>不过仍然能找到<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v2.6.39.4/source">/</a><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v2.6.39.4/source/arch">arch</a>/<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v2.6.39.4/source/arch/x86">x86</a>/<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v2.6.39.4/source/arch/x86/kernel">kernel</a>/<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v2.6.39.4/source/arch/x86/kernel/entry_32.S">entry_32.S</a>（其他版本可能实现地方不同，这是2.6内核版本的）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">.macro TRACE_IRQS_IRET</span><br><span class="line">#ifdef CONFIG_TRACE_IRQFLAGS</span><br><span class="line">	testl $X86_EFLAGS_IF,PT_EFLAGS(%esp)     # interrupts off?</span><br><span class="line">	jz 1f</span><br><span class="line">	TRACE_IRQS_ON</span><br><span class="line">1:</span><br><span class="line">#endif</span><br><span class="line">.endm</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * User gs save/restore</span><br><span class="line"> *</span><br><span class="line"> * %gs is used for userland TLS and kernel only uses it for stack</span><br><span class="line"> * canary which is required to be at %gs:20 by gcc.  Read the comment</span><br><span class="line"> * at the top of stackprotector.h for more info.</span><br><span class="line"> *</span><br><span class="line"> * Local labels 98 and 99 are used.</span><br><span class="line"> */</span><br><span class="line">#ifdef CONFIG_X86_32_LAZY_GS</span><br><span class="line"></span><br><span class="line"> /* unfortunately push/pop can&#x27;t be no-op */</span><br><span class="line">.macro PUSH_GS</span><br><span class="line">	pushl_cfi $0</span><br><span class="line">.endm</span><br><span class="line">.macro POP_GS pop=0</span><br><span class="line">	addl $(4 + \pop), %esp</span><br><span class="line">	CFI_ADJUST_CFA_OFFSET -(4 + \pop)</span><br><span class="line">.endm</span><br><span class="line">.macro POP_GS_EX</span><br><span class="line">.endm</span><br><span class="line"></span><br><span class="line"> /* all the rest are no-op */</span><br><span class="line">.macro PTGS_TO_GS</span><br><span class="line">.endm</span><br><span class="line">.macro PTGS_TO_GS_EX</span><br><span class="line">.endm</span><br><span class="line">.macro GS_TO_REG reg</span><br><span class="line">.endm</span><br><span class="line">.macro REG_TO_PTGS reg</span><br><span class="line">.endm</span><br><span class="line">.macro SET_KERNEL_GS reg</span><br><span class="line">.endm</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">.macro GS_TO_REG reg</span><br><span class="line">	movl %gs, \reg</span><br><span class="line">	/*CFI_REGISTER gs, \reg*/</span><br><span class="line">.endm</span><br><span class="line">.macro REG_TO_PTGS reg</span><br><span class="line">	movl \reg, PT_GS(%esp)</span><br><span class="line">	/*CFI_REL_OFFSET gs, PT_GS*/</span><br><span class="line">.endm</span><br><span class="line">.macro SET_KERNEL_GS reg</span><br><span class="line">	movl $(__KERNEL_STACK_CANARY), \reg</span><br><span class="line">	movl \reg, %gs</span><br><span class="line">.endm</span><br><span class="line"></span><br><span class="line">#endif	/* CONFIG_X86_32_LAZY_GS */</span><br><span class="line"></span><br><span class="line">.macro SAVE_ALL</span><br><span class="line">	cld</span><br><span class="line">	PUSH_GS</span><br><span class="line">	pushl_cfi %fs</span><br><span class="line">	/*CFI_REL_OFFSET fs, 0;*/</span><br><span class="line">	pushl_cfi %es</span><br><span class="line">	/*CFI_REL_OFFSET es, 0;*/</span><br><span class="line">	pushl_cfi %ds</span><br><span class="line">	/*CFI_REL_OFFSET ds, 0;*/</span><br><span class="line">	pushl_cfi %eax</span><br><span class="line">	CFI_REL_OFFSET eax, 0</span><br><span class="line">	pushl_cfi %ebp</span><br><span class="line">	CFI_REL_OFFSET ebp, 0</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">.macro RESTORE_INT_REGS</span><br><span class="line">	popl_cfi %ebx</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>对应的64位：<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v2.6.39.4/source">/</a><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v2.6.39.4/source/arch">arch</a>/<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v2.6.39.4/source/arch/x86">x86</a>/<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v2.6.39.4/source/arch/x86/kernel">kernel</a>/<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v2.6.39.4/source/arch/x86/kernel/entry_64.S">entry_64.S</a></p>
<h2 id="参考-5"><a class="markdownIt-Anchor" href="#参考-5"></a> 参考</h2>
<p><a target="_blank" rel="noopener" href="https://linux-kernel-labs.github.io/refs/heads/master/lectures/interrupts.html">https://linux-kernel-labs.github.io/refs/heads/master/lectures/interrupts.html</a></p>
<p><a target="_blank" rel="noopener" href="https://lrita.github.io/2019/03/05/linux-interrupt-and-trap/">https://lrita.github.io/2019/03/05/linux-interrupt-and-trap/</a></p>
<h1 id="操作系统实现-外中断"><a class="markdownIt-Anchor" href="#操作系统实现-外中断"></a> 操作系统实现-外中断</h1>
<blockquote>
<p>代码来源：<a target="_blank" rel="noopener" href="https://github.com/StevenBaby/onix">https://github.com/StevenBaby/onix</a></p>
<p>相关课程：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1gR4y1u7or">https://www.bilibili.com/video/BV1gR4y1u7or</a></p>
<p>感谢B站UP：<a target="_blank" rel="noopener" href="https://space.bilibili.com/491131440">踌躇月光</a> 带来的相关代码和教程</p>
</blockquote>
<p>up的原视频直接开始将源代码了，但是我操作系统没学好怎么办，赶紧查外中断是个啥</p>
<p>中断的种类有：</p>
<ul>
<li>异常</li>
<li>外中断</li>
<li>软中断</li>
</ul>
<p>UP的图总结的非常好</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/c2a286e27b24a9bd12a2e53ef6af1414.png" alt="image-20220316170057409" /></p>
<p>在上一篇我们实现的是异常，这里实现的是外中断，有了外中断我们就可以做一些输入了</p>
<p>比如：</p>
<ol>
<li>键盘按下一个按钮（其实感兴趣的话不妨去了解了解TTY(TeleTypeWriter)）</li>
<li>键盘芯片通过数据总线向CPU传递信号，要求CPU暂停，从死循环跳出（中断），转到来处理这个按钮所出发的时间</li>
<li>CPU处理完成后返回原来的执行流</li>
</ol>
<p>这里描绘一下8086PC机键盘处理过程</p>
<blockquote>
<p>CPU一直在检测中断</p>
</blockquote>
<ol>
<li>
<p>键盘按下，发出终端扫描码0x1E，被I/O接口的0x60端口上</p>
</li>
<li>
<p>I/O接口触发9号中断通过<strong>数据总线</strong>送到CPU的中断逻辑中，并且将信号通过<strong>数据总线</strong>发送到数据缓冲寄存器中</p>
</li>
<li>
<p>CPU会根据标志寄存器<strong>IF</strong>位判断，是<strong>1</strong>就响应，<strong>0</strong>则等待，中断逻辑检测到9号中断，触发9号中断处理程序(这个处理程序就是我们要写的)，电路级别的是从CPU内部实现的，信号传递是通过CPU针脚传递</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/a7b7a6ea5d5e4e8767ca48fbb638dabb.png" alt="image-20220317163807327" /></p>
</li>
<li>
<p>同时CPU将键盘信号0x1E转为ASCII码0x61</p>
</li>
<li>
<p>再将0x1E和0x61组合送到内存-键盘缓冲区中（ASCII地位，信号高位）</p>
</li>
<li>
<p>最后CPU向键盘发送应答信息</p>
</li>
</ol>
<p>最开始的PS2协议的键盘(圆头的)就是通过这种方式进行输入的</p>
<p>所以我们需要做相当多的关于硬件的操作，有点像计组了</p>
<p><code>src/include/xsys/interrupt.h</code> 定义了一些中断编号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_CLOCK 0      <span class="comment">// 时钟</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_KEYBOARD 1   <span class="comment">// 键盘</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_CASCADE 2    <span class="comment">// 8259 从片控制器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_SERIAL_2 3   <span class="comment">// 串口 2</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_SERIAL_1 4   <span class="comment">// 串口 1</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_PARALLEL_2 5 <span class="comment">// 并口 2</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_FLOPPY 6     <span class="comment">// 软盘控制器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_PARALLEL_1 7 <span class="comment">// 并口 1</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_RTC 8        <span class="comment">// 实时时钟</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_REDIRECT 9   <span class="comment">// 重定向 IRQ2</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_MOUSE 12     <span class="comment">// 鼠标</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_MATH 13      <span class="comment">// 协处理器 x87</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_HARDDISK 14  <span class="comment">// ATA 硬盘第一通道</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_HARDDISK2 15 <span class="comment">// ATA 硬盘第二通道</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_MASTER_NR 0x20 <span class="comment">// 主片起始向量号</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_SLAVE_NR 0x28  <span class="comment">// 从片起始向量号</span></span></span><br></pre></td></tr></table></figure>
<p><code>src/kernel/interrupt.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/global.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/debug.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/printk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGK(fmt, args...) DEBUGK(fmt, ##args)</span></span><br><span class="line"><span class="comment">// #define LOGK(fmt, args...)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENTRY_SIZE 0x30</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC_M_CTRL 0x20 <span class="comment">// 主片的控制端口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC_M_DATA 0x21 <span class="comment">// 主片的数据端口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC_S_CTRL 0xa0 <span class="comment">// 从片的控制端口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC_S_DATA 0xa1 <span class="comment">// 从片的数据端口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC_EOI 0x20    <span class="comment">// 通知中断控制器中断结束</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">gate_t</span> idt[IDT_SIZE];</span><br><span class="line"><span class="type">pointer_t</span> idt_ptr;</span><br><span class="line"></span><br><span class="line"><span class="type">handler_t</span> handler_table[IDT_SIZE];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">handler_t</span> handler_entry_table[ENTRY_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *messages[] = &#123;</span><br><span class="line">    <span class="string">&quot;#DE Divide Error\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#DB RESERVED\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;--  NMI Interrupt\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#BP Breakpoint\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#OF Overflow\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#BR BOUND Range Exceeded\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#UD Invalid Opcode (Undefined Opcode)\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#NM Device Not Available (No Math Coprocessor)\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#DF Double Fault\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;    Coprocessor Segment Overrun (reserved)\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#TS Invalid TSS\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#NP Segment Not Present\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#SS Stack-Segment Fault\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#GP General Protection\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#PF Page Fault\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;--  (Intel reserved. Do not use.)\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#MF x87 FPU Floating-Point Error (Math Fault)\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#AC Alignment Check\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#MC Machine Check\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#XF SIMD Floating-Point Exception\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#VE Virtualization Exception\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#CP Control Protection Exception\0&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通知中断控制器，中断处理结束</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">send_eoi</span><span class="params">(<span class="type">int</span> <span class="built_in">vector</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vector</span> &gt;= <span class="number">0x20</span> &amp;&amp; <span class="built_in">vector</span> &lt; <span class="number">0x28</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        outb(PIC_M_CTRL, PIC_EOI);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vector</span> &gt;= <span class="number">0x28</span> &amp;&amp; <span class="built_in">vector</span> &lt; <span class="number">0x30</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        outb(PIC_M_CTRL, PIC_EOI);</span><br><span class="line">        outb(PIC_S_CTRL, PIC_EOI);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u32 counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">default_handler</span><span class="params">(<span class="type">int</span> <span class="built_in">vector</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    send_eoi(<span class="built_in">vector</span>);</span><br><span class="line">    LOGK(<span class="string">&quot;[%d] default interrupt called %d...\n&quot;</span>, <span class="built_in">vector</span>, counter++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">exception_handler</span><span class="params">(<span class="type">int</span> <span class="built_in">vector</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *message = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vector</span> &lt; <span class="number">22</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        message = messages[<span class="built_in">vector</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        message = messages[<span class="number">15</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;Exception : [0x%02X] %s \n&quot;</span>, <span class="built_in">vector</span>, messages[<span class="built_in">vector</span>]);</span><br><span class="line">    <span class="comment">// 阻塞</span></span><br><span class="line">    hang();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化中断控制器</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pic_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    outb(PIC_M_CTRL, <span class="number">0b00010001</span>); <span class="comment">// ICW1: 边沿触发, 级联 8259, 需要ICW4.</span></span><br><span class="line">    outb(PIC_M_DATA, <span class="number">0x20</span>);       <span class="comment">// ICW2: 起始端口号 0x20</span></span><br><span class="line">    outb(PIC_M_DATA, <span class="number">0b00000100</span>); <span class="comment">// ICW3: IR2接从片.</span></span><br><span class="line">    outb(PIC_M_DATA, <span class="number">0b00000001</span>); <span class="comment">// ICW4: 8086模式, 正常EOI</span></span><br><span class="line"></span><br><span class="line">    outb(PIC_S_CTRL, <span class="number">0b00010001</span>); <span class="comment">// ICW1: 边沿触发, 级联 8259, 需要ICW4.</span></span><br><span class="line">    outb(PIC_S_DATA, <span class="number">0x28</span>);       <span class="comment">// ICW2: 起始端口号 0x28</span></span><br><span class="line">    outb(PIC_S_DATA, <span class="number">2</span>);          <span class="comment">// ICW3: 设置从片连接到主片的 IR2 引脚</span></span><br><span class="line">    outb(PIC_S_DATA, <span class="number">0b00000001</span>); <span class="comment">// ICW4: 8086模式, 正常EOI</span></span><br><span class="line"></span><br><span class="line">    outb(PIC_M_DATA, <span class="number">0b11111110</span>); <span class="comment">// 关闭所有中断</span></span><br><span class="line">    outb(PIC_S_DATA, <span class="number">0b11111111</span>); <span class="comment">// 关闭所有中断</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化中断描述符，和中断处理函数数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">idt_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; ENTRY_SIZE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">gate_t</span> *gate = &amp;idt[i];</span><br><span class="line">        <span class="type">handler_t</span> handler = handler_entry_table[i];</span><br><span class="line"></span><br><span class="line">        gate-&gt;offset0 = (u32)handler &amp; <span class="number">0xffff</span>;</span><br><span class="line">        gate-&gt;offset1 = ((u32)handler &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span>;</span><br><span class="line">        gate-&gt;selector = <span class="number">1</span> &lt;&lt; <span class="number">3</span>; <span class="comment">// 代码段</span></span><br><span class="line">        gate-&gt;reserved = <span class="number">0</span>;      <span class="comment">// 保留不用</span></span><br><span class="line">        gate-&gt;type = <span class="number">0b1110</span>;     <span class="comment">// 中断门</span></span><br><span class="line">        gate-&gt;segment = <span class="number">0</span>;       <span class="comment">// 系统段</span></span><br><span class="line">        gate-&gt;DPL = <span class="number">0</span>;           <span class="comment">// 内核态</span></span><br><span class="line">        gate-&gt;present = <span class="number">1</span>;       <span class="comment">// 有效</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">0x20</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        handler_table[i] = exception_handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">20</span>; i &lt; ENTRY_SIZE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        handler_table[i] = default_handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    idt_ptr.base = (u32)idt;</span><br><span class="line">    idt_ptr.limit = <span class="keyword">sizeof</span>(idt) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;lidt idt_ptr\n&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">interrupt_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    pic_init();</span><br><span class="line">    idt_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>src/kernel/main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kernel_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    console_init();</span><br><span class="line">    gdt_init();</span><br><span class="line">    interrupt_init();</span><br><span class="line">    <span class="comment">// task_init();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot;sti\n&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;movl %eax, %eax\n&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">    u32 counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        DEBUGK(<span class="string">&quot;looping in kernel init %d...\n&quot;</span>, counter++);</span><br><span class="line">        delay(<span class="number">1000000000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/e2a5df11498569565a2bb9b96205f256.png" alt="image-20220316174332421" /></p>
<p>具体步骤</p>
<p>在handler.asm下断点</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/eb8c658e45a90e708d5d516f9433a7eb.png" alt="image-20220317165523139" /></p>
<p>会发现调用中断的时间都用不同，从<code>asm volatile(&quot;sti\n&quot;);</code>之后，中断初始化完毕，开中断，标志寄存器<strong>IF</strong>位置<strong>1</strong>。则会调用中断处理函数</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/b3b4e3eda6ed9a8779351e1cd83d1f9b.png" alt="image-20220317170757039" /></p>
<p>是因为CPU一直在监测中断，而不知道两个中断之间相隔多久，所以会这样乱序</p>
<h2 id="参考-6"><a class="markdownIt-Anchor" href="#参考-6"></a> 参考</h2>
<p><a target="_blank" rel="noopener" href="https://datasheetspdf.com/datasheet/80486.html">https://datasheetspdf.com/datasheet/80486.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV14e411s7CN">https://www.bilibili.com/video/BV14e411s7CN</a></p>
<h1 id="操作系统实现-任务中断与上下文"><a class="markdownIt-Anchor" href="#操作系统实现-任务中断与上下文"></a> 操作系统实现-任务中断与上下文</h1>
<p>结合前面的知识，我们能否让中断帮助我们进行任务的切换</p>
<p><code>src/kernel/task.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">u32 _ofp <span class="title function_">thread_a</span><span class="params">()</span><span class="comment">//标及省略栈帧</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;sti\n&quot;</span>)</span>;<span class="comment">//开中断</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u32 _ofp <span class="title function_">thread_b</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;sti\n&quot;</span>)</span>;<span class="comment">//开中断</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于我们通过中断进行任务的切换，所以要修改默认中断入口函数，由于要保存上下文，所以<code>exception_handler</code>报错是要打印相关寄存器的值；而且为了实现效果要打开中断</p>
<p><code>src/kernel/interrupt.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">default_handler</span><span class="params">(<span class="type">int</span> <span class="built_in">vector</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    send_eoi(<span class="built_in">vector</span>);</span><br><span class="line">    schedule();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">exception_handler</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">int</span> <span class="built_in">vector</span>,</span></span><br><span class="line"><span class="params">    u32 edi, u32 esi, u32 ebp, u32 esp,</span></span><br><span class="line"><span class="params">    u32 ebx, u32 edx, u32 ecx, u32 eax,</span></span><br><span class="line"><span class="params">    u32 gs, u32 fs, u32 es, u32 ds,</span></span><br><span class="line"><span class="params">    u32 vector0, u32 error, u32 eip, u32 cs, u32 eflags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *message = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vector</span> &lt; <span class="number">22</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        message = messages[<span class="built_in">vector</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        message = messages[<span class="number">15</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;\nEXCEPTION : %s \n&quot;</span>, messages[<span class="built_in">vector</span>]);</span><br><span class="line">    printk(<span class="string">&quot;   VECTOR : 0x%02X\n&quot;</span>, <span class="built_in">vector</span>);</span><br><span class="line">    printk(<span class="string">&quot;    ERROR : 0x%08X\n&quot;</span>, error);</span><br><span class="line">    printk(<span class="string">&quot;   EFLAGS : 0x%08X\n&quot;</span>, eflags);</span><br><span class="line">    printk(<span class="string">&quot;       CS : 0x%02X\n&quot;</span>, cs);</span><br><span class="line">    printk(<span class="string">&quot;      EIP : 0x%08X\n&quot;</span>, eip);</span><br><span class="line">    printk(<span class="string">&quot;      ESP : 0x%08X\n&quot;</span>, esp);</span><br><span class="line">    <span class="comment">// 阻塞</span></span><br><span class="line">    hang();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pic_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    outb(PIC_M_DATA, <span class="number">0b11111110</span>); <span class="comment">// 关闭所有中断</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时为了保存上下文，要在中断处理时保存栈地相关信息并设置跳转</p>
<p><code>src/kernel/handler.asm</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">interrupt_entry:</span><br><span class="line"></span><br><span class="line">    ;保存上下文</span><br><span class="line">    push ds</span><br><span class="line">    push es</span><br><span class="line">    push fs</span><br><span class="line">    push gs</span><br><span class="line">    pusha</span><br><span class="line"></span><br><span class="line">    ;找到压入的中断向量（因为保存了上下文）</span><br><span class="line">    mov eax, [esp + 12*4]</span><br><span class="line">    ;中断向量处理函数传递参数</span><br><span class="line">    push eax</span><br><span class="line"></span><br><span class="line">    ; 调用中断处理函数，handler_table 中存储了中断处理函数的指针</span><br><span class="line">    call [handler_table + eax * 4]</span><br><span class="line">    ; 对应 push %1，调用结束恢复栈</span><br><span class="line">    add esp, 4</span><br><span class="line"></span><br><span class="line">    ;回复上下文</span><br><span class="line">    popa</span><br><span class="line">    pop gs</span><br><span class="line">    pop fs</span><br><span class="line">    pop es</span><br><span class="line">    pop ds</span><br><span class="line"></span><br><span class="line">    add esp ,8</span><br><span class="line">    iret</span><br></pre></td></tr></table></figure>
<p>自然的<code>main.c</code>要初始化任务才行</p>
<p><code>src/kernel/main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">console_init</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">gdt_init</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">interrupt_init</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">clock_init</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">hang</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    console_init();</span><br><span class="line">    gdt_init();</span><br><span class="line">    interrupt_init();</span><br><span class="line">    task_init();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;sti&quot;</span>)</span>;</span><br><span class="line">    hang();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/f0af4fa8bcbc86e138b061745e570461.png" alt="image-20220319164652326" /></p>
<h1 id="操作系统实现-时钟"><a class="markdownIt-Anchor" href="#操作系统实现-时钟"></a> 操作系统实现-时钟</h1>
<h2 id="中断小结"><a class="markdownIt-Anchor" href="#中断小结"></a> 中断小结</h2>
<p>#操作系统实现-中断与系统调用</p>
<p>#操作系统实现-异常</p>
<p>#操作系统实现-外中断</p>
<p>之前已经有了3篇相关的文章，这里做一个较为具体的总结</p>
<h3 id="中断存在的意义"><a class="markdownIt-Anchor" href="#中断存在的意义"></a> 中断存在的意义</h3>
<ol>
<li>外部信息传递到CPU进行处理</li>
<li>跟更好的利用CPU：A任务等待输入输出时，中断后去处理B任务</li>
<li>计算机发生了某些异常，需要处理器立即执行一些操作：除0异常</li>
</ol>
<h2 id="外中断"><a class="markdownIt-Anchor" href="#外中断"></a> 外中断</h2>
<p>在8086时代，中断是通过两个信号线引入处理器的：</p>
<p><strong>NMI(None Maskable Interrupt，非屏蔽中断)</strong></p>
<ul>
<li>
<p>Intel规定：只有存在超过4个时钟周期的NMI才能被处理器识别</p>
</li>
<li>
<p>RAM：内存校验错</p>
</li>
<li>
<p>IOCHK：I/O校验错</p>
</li>
</ul>
<p><strong>INTR(Interrupt，可屏蔽中断)</strong></p>
<p>个人计算机中最常用的是中断代理：8259芯片</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/aa1141e2db4a2c51816b030c226bd366.png" alt="" /></p>
<p>Intel允许使用256个中断，由图可知8256维持15个中断，并且8256中中断信号不固定，因此称为可编程中断控制器（Programmable Inpterrupt Controller，PIC）</p>
<p>又由图可知，要实现全部功能，需要两块8256进行芯片级联。</p>
<ul>
<li>使用时钟功能：主片IRQ2</li>
<li>使用实时时钟：主片连接int(IRQ2)-&gt;从片IRQ8-&gt;主片IR2</li>
</ul>
<h3 id="时钟-cmos-bcd编码"><a class="markdownIt-Anchor" href="#时钟-cmos-bcd编码"></a> 时钟、CMOS、BCD编码</h3>
<p><strong>RTC</strong></p>
<p>从简单的思路来说，你只需要一个实时时钟电路(Real Time Clock，RTC)和一个CMOS小块组成的静态存储器就可以实现时钟的功能。</p>
<p>一般的RTC是由振荡频率为32.768kHz的石英晶体振荡器驱动，分频过后进行每秒一次的刷新</p>
<p><strong>CMOS</strong></p>
<p>同样为了能让外部访问，该硬件有两个端口：</p>
<ul>
<li>CMOS 地址寄存器：0x70</li>
<li>CMOS 数据寄存器：0x71</li>
</ul>
<p>同时有时间信息（）</p>
<table>
<thead>
<tr>
<th>偏移值</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x1</td>
<td>CMOS_SECOND</td>
</tr>
<tr>
<td>0x3</td>
<td>CMOS_MINUTE</td>
</tr>
<tr>
<td>0x5</td>
<td>CMOS_HOUR</td>
</tr>
<tr>
<td>0xa</td>
<td>CMOS_Areg</td>
</tr>
<tr>
<td>0xb</td>
<td>CMOS_Breg</td>
</tr>
<tr>
<td>0xc</td>
<td>CMOS_Creg</td>
</tr>
<tr>
<td>0xd</td>
<td>CMOS_Dreg</td>
</tr>
<tr>
<td>0x80</td>
<td>CMOS_NMI</td>
</tr>
</tbody>
</table>
<p><strong>BCD</strong></p>
<p>BCD(Binary Coded Decimal)是CMOS RAM中保存时间信息的格式</p>
<h3 id="动态时钟的实现"><a class="markdownIt-Anchor" href="#动态时钟的实现"></a> 动态时钟的实现</h3>
<p>除非是计算机考古学家，否则直接上手很难，所以直接参(开)考(抄)Linux</p>
<p><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/0.99.15j/source">/</a><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/0.99.15j/source/include">include</a>/<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/0.99.15j/source/include/linux">linux</a>/<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/0.99.15j/source/include/linux/time.h">time.h</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LINUX_TIME_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LINUX_TIME_H</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">	<span class="type">long</span>	tv_sec;		<span class="comment">/* seconds */</span></span><br><span class="line">	<span class="type">long</span>	tv_usec;	<span class="comment">/* microseconds */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timezone</span> &#123;</span></span><br><span class="line">	<span class="type">int</span>	tz_minuteswest;	<span class="comment">/* minutes west of Greenwich */</span></span><br><span class="line">	<span class="type">int</span>	tz_dsttime;	<span class="comment">/* type of dst correction */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NFDBITS			__NFDBITS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FD_SETSIZE		__FD_SETSIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FD_SET(fd,fdsetp)	__FD_SET(fd,fdsetp)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FD_CLR(fd,fdsetp)	__FD_CLR(fd,fdsetp)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FD_ISSET(fd,fdsetp)	__FD_ISSET(fd,fdsetp)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FD_ZERO(fdsetp)		__FD_ZERO(fdsetp)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Names of the interval timers, and structure</span></span><br><span class="line"><span class="comment"> * defining a timer setting.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ITIMER_REAL	0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ITIMER_VIRTUAL	1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ITIMER_PROF	2</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>	<span class="title">itimerval</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span>	<span class="title">timeval</span> <span class="title">it_interval</span>;</span>	<span class="comment">/* timer interval */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span>	<span class="title">timeval</span> <span class="title">it_value</span>;</span>	<span class="comment">/* current value */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>这个是Linux比较老的版本之一的，有点过时了，但是我们可以修改为</p>
<p><code>src/include/xsys/time.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> XSYS_TIME_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XSYS_TIME_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tm</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> tm_sec;</span><br><span class="line">    <span class="type">int</span> tm_min;</span><br><span class="line">    <span class="type">int</span> tm_hour;</span><br><span class="line">    <span class="type">int</span> tm_mday;</span><br><span class="line">    <span class="type">int</span> tm_mon;</span><br><span class="line">    <span class="type">int</span> tm_year;</span><br><span class="line">    <span class="type">int</span> tm_wday;</span><br><span class="line">    <span class="type">int</span> tm_yday;</span><br><span class="line">    <span class="type">int</span> tm_isdst;<span class="comment">//夏令时标志</span></span><br><span class="line"></span><br><span class="line">&#125;tm;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">time_read_bcd</span><span class="params">(tm *time)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">time_read</span><span class="params">(tm *time)</span>;</span><br><span class="line"><span class="type">time_t</span> <span class="title function_">mktime</span><span class="params">(tm *time)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>接着便是：初始化时间</p>
<p><code>src/kernel/time.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/debug.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/rtc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGK(fmt, args...) DEBUGK(fmt, ##args)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMOS_ADDR 0x70 <span class="comment">// CMOS 地址寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMOS_DATA 0x71 <span class="comment">// CMOS 数据寄存器</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是 CMOS 信息的寄存器索引</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMOS_SECOND 0x00  <span class="comment">// (0 ~ 59)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMOS_MINUTE 0x02  <span class="comment">// (0 ~ 59)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMOS_HOUR 0x04    <span class="comment">// (0 ~ 23)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMOS_WEEKDAY 0x06 <span class="comment">// (1 ~ 7) 星期天 = 1，星期六 = 7</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMOS_DAY 0x07     <span class="comment">// (1 ~ 31)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMOS_MONTH 0x08   <span class="comment">// (1 ~ 12)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMOS_YEAR 0x09    <span class="comment">// (0 ~ 99)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMOS_CENTURY 0x32 <span class="comment">// 可能不存在</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMOS_NMI 0x80</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MINUTE 60          <span class="comment">// 每分钟的秒数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOUR (60 * MINUTE) <span class="comment">// 每小时的秒数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DAY (24 * HOUR)    <span class="comment">// 每天的秒数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YEAR (365 * DAY)   <span class="comment">// 每年的秒数，以 365 天算</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个月开始时的已经过去天数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> month[<span class="number">13</span>] = &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="comment">// 这里占位，没有 0 月，从 1 月开始</span></span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    (<span class="number">31</span>),</span><br><span class="line">    (<span class="number">31</span> + <span class="number">29</span>),</span><br><span class="line">    (<span class="number">31</span> + <span class="number">29</span> + <span class="number">31</span>),</span><br><span class="line">    (<span class="number">31</span> + <span class="number">29</span> + <span class="number">31</span> + <span class="number">30</span>),</span><br><span class="line">    (<span class="number">31</span> + <span class="number">29</span> + <span class="number">31</span> + <span class="number">30</span> + <span class="number">31</span>),</span><br><span class="line">    (<span class="number">31</span> + <span class="number">29</span> + <span class="number">31</span> + <span class="number">30</span> + <span class="number">31</span> + <span class="number">30</span>),</span><br><span class="line">    (<span class="number">31</span> + <span class="number">29</span> + <span class="number">31</span> + <span class="number">30</span> + <span class="number">31</span> + <span class="number">30</span> + <span class="number">31</span>),</span><br><span class="line">    (<span class="number">31</span> + <span class="number">29</span> + <span class="number">31</span> + <span class="number">30</span> + <span class="number">31</span> + <span class="number">30</span> + <span class="number">31</span> + <span class="number">31</span>),</span><br><span class="line">    (<span class="number">31</span> + <span class="number">29</span> + <span class="number">31</span> + <span class="number">30</span> + <span class="number">31</span> + <span class="number">30</span> + <span class="number">31</span> + <span class="number">31</span> + <span class="number">30</span>),</span><br><span class="line">    (<span class="number">31</span> + <span class="number">29</span> + <span class="number">31</span> + <span class="number">30</span> + <span class="number">31</span> + <span class="number">30</span> + <span class="number">31</span> + <span class="number">31</span> + <span class="number">30</span> + <span class="number">31</span>),</span><br><span class="line">    (<span class="number">31</span> + <span class="number">29</span> + <span class="number">31</span> + <span class="number">30</span> + <span class="number">31</span> + <span class="number">30</span> + <span class="number">31</span> + <span class="number">31</span> + <span class="number">30</span> + <span class="number">31</span> + <span class="number">30</span>)&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">time_t</span> startup_time;</span><br><span class="line"><span class="type">int</span> century;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里生成的时间可能和 UTC 时间有出入</span></span><br><span class="line"><span class="comment">// 与系统具体时区相关，不过也不要紧，顶多差几个小时</span></span><br><span class="line"><span class="type">time_t</span> <span class="title function_">mktime</span><span class="params">(tm *time)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">time_t</span> res;</span><br><span class="line">    <span class="type">int</span> year; <span class="comment">// 1970 年开始的年数</span></span><br><span class="line">    <span class="comment">// 下面从 1900 年开始的年数计算</span></span><br><span class="line">    <span class="keyword">if</span> (time-&gt;tm_year &gt;= <span class="number">70</span>)</span><br><span class="line">        year = time-&gt;tm_year - <span class="number">70</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        year = time-&gt;tm_year - <span class="number">70</span> + <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这些年经过的秒数时间</span></span><br><span class="line">    res = YEAR * year;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已经过去的闰年，每个加 1 天</span></span><br><span class="line">    res += DAY * ((year + <span class="number">1</span>) / <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已经过完的月份的时间</span></span><br><span class="line">    res += month[time-&gt;tm_mon] * DAY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 2 月已经过了，并且当前不是闰年，那么减去一天</span></span><br><span class="line">    <span class="keyword">if</span> (time-&gt;tm_mon &gt; <span class="number">2</span> &amp;&amp; ((year + <span class="number">2</span>) % <span class="number">4</span>))</span><br><span class="line">        res -= DAY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个月已经过去的天</span></span><br><span class="line">    res += DAY * (time-&gt;tm_mday - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 今天过去的小时</span></span><br><span class="line">    res += HOUR * time-&gt;tm_hour;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个小时过去的分钟</span></span><br><span class="line">    res += MINUTE * time-&gt;tm_min;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个分钟过去的秒</span></span><br><span class="line">    res += time-&gt;tm_sec;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_yday</span><span class="params">(tm *time)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> res = month[time-&gt;tm_mon]; <span class="comment">// 已经过去的月的天数</span></span><br><span class="line">    res += time-&gt;tm_mday;          <span class="comment">// 这个月过去的天数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">    <span class="keyword">if</span> (time-&gt;tm_year &gt;= <span class="number">70</span>)</span><br><span class="line">        year = time-&gt;tm_year - <span class="number">70</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        year = time-&gt;tm_year - <span class="number">70</span> + <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是闰年，并且 2 月已经过去了，则减去一天</span></span><br><span class="line">    <span class="comment">// 注：1972 年是闰年，这样算不太精确，忽略了 100 年的平年</span></span><br><span class="line">    <span class="keyword">if</span> ((year + <span class="number">2</span>) % <span class="number">4</span> &amp;&amp; time-&gt;tm_mon &gt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">time_read_bcd</span><span class="params">(tm *time)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// CMOS 的访问速度很慢。为了减小时间误差，在读取了下面循环中所有数值后，</span></span><br><span class="line">    <span class="comment">// 若此时 CMOS 中秒值发生了变化，那么就重新读取所有值。</span></span><br><span class="line">    <span class="comment">// 这样内核就能把与 CMOS 的时间误差控制在 1 秒之内。</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        time-&gt;tm_sec = cmos_read(CMOS_SECOND);</span><br><span class="line">        time-&gt;tm_min = cmos_read(CMOS_MINUTE);</span><br><span class="line">        time-&gt;tm_hour = cmos_read(CMOS_HOUR);</span><br><span class="line">        time-&gt;tm_wday = cmos_read(CMOS_WEEKDAY);</span><br><span class="line">        time-&gt;tm_mday = cmos_read(CMOS_DAY);</span><br><span class="line">        time-&gt;tm_mon = cmos_read(CMOS_MONTH);</span><br><span class="line">        time-&gt;tm_year = cmos_read(CMOS_YEAR);</span><br><span class="line">        century = cmos_read(CMOS_CENTURY);</span><br><span class="line">    &#125; <span class="keyword">while</span> (time-&gt;tm_sec != cmos_read(CMOS_SECOND));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">time_read</span><span class="params">(tm *time)</span></span><br><span class="line">&#123;</span><br><span class="line">    time_read_bcd(time);</span><br><span class="line">    time-&gt;tm_sec = bcd_to_bin(time-&gt;tm_sec);</span><br><span class="line">    time-&gt;tm_min = bcd_to_bin(time-&gt;tm_min);</span><br><span class="line">    time-&gt;tm_hour = bcd_to_bin(time-&gt;tm_hour);</span><br><span class="line">    time-&gt;tm_wday = bcd_to_bin(time-&gt;tm_wday);</span><br><span class="line">    time-&gt;tm_mday = bcd_to_bin(time-&gt;tm_mday);</span><br><span class="line">    time-&gt;tm_mon = bcd_to_bin(time-&gt;tm_mon);</span><br><span class="line">    time-&gt;tm_year = bcd_to_bin(time-&gt;tm_year);</span><br><span class="line">    time-&gt;tm_yday = get_yday(time);</span><br><span class="line">    time-&gt;tm_isdst = <span class="number">-1</span>;</span><br><span class="line">    century = bcd_to_bin(century);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">time_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    tm time;</span><br><span class="line">    time_read(&amp;time);</span><br><span class="line">    startup_time = mktime(&amp;time);</span><br><span class="line">    LOGK(<span class="string">&quot;startup time: %d%d-%02d-%02d %02d:%02d:%02d\n&quot;</span>,</span><br><span class="line">         century,</span><br><span class="line">         time.tm_year,</span><br><span class="line">         time.tm_mon,</span><br><span class="line">         time.tm_mday,</span><br><span class="line">         time.tm_hour,</span><br><span class="line">         time.tm_min,</span><br><span class="line">         time.tm_sec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">u8 <span class="title function_">bcd_to_bin</span><span class="params">(u8 value)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (value &amp; <span class="number">0xf</span>) + (value &gt;&gt; <span class="number">4</span>) *<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">u8 <span class="title function_">bin_to_bcd</span><span class="params">(u8 value)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (value / <span class="number">10</span>)*<span class="number">0x10</span> + (value % <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基本上就是调用上述接口就可以实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">console_init</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">gdt_init</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">interrupt_init</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">clock_init</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">time_init</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">rtc_init</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">hang</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    console_init();</span><br><span class="line">    gdt_init();</span><br><span class="line">    interrupt_init();</span><br><span class="line">    time_init();</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;sti&quot;</span>)</span>;</span><br><span class="line">    hang();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>makefile的qemu选项里面加上<code>-rtc base=localtime</code>，就可以得到当前时区时间，就不需要我们手动计算了</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/6bbe21386e50ce76c68bf9092dae5699.png" alt="image-20220322164422172" /></p>
<p>动态时钟就需要对RTC进行更多操作</p>
<p>而且我们对RTC的基本操作很少</p>
<p><code>src/include/xsys/rtc.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> XSYS_RTC_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XSYS_RTC_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_alarm</span><span class="params">(u32 secs)</span>;</span><br><span class="line">u8 <span class="title function_">cmos_read</span><span class="params">(u8 addr)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">cmos_write</span><span class="params">(u8 addr, u8 value)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>src/kernel/rtc.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/debug.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGK(fmt, args...) DEBUGK(fmt, ##args)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMOS_ADDR 0x70 <span class="comment">// CMOS 地址寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMOS_DATA 0x71 <span class="comment">// CMOS 数据寄存器</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMOS_SECOND 0x01</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMOS_MINUTE 0x03</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMOS_HOUR 0x05</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMOS_A 0x0a</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMOS_B 0x0b</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMOS_C 0x0c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMOS_D 0x0d</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMOS_NMI 0x80</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读 cmos 寄存器的值</span></span><br><span class="line">u8 <span class="title function_">cmos_read</span><span class="params">(u8 addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    outb(CMOS_ADDR, CMOS_NMI | addr);</span><br><span class="line">    <span class="keyword">return</span> inb(CMOS_DATA);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写 cmos 寄存器的值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cmos_write</span><span class="params">(u8 addr, u8 value)</span></span><br><span class="line">&#123;</span><br><span class="line">    outb(CMOS_ADDR, CMOS_NMI | addr);</span><br><span class="line">    outb(CMOS_DATA, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> u32 <span class="keyword">volatile</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实时时钟中断处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rtc_handler</span><span class="params">(<span class="type">int</span> <span class="built_in">vector</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 实时时钟中断向量号</span></span><br><span class="line">    assert(<span class="built_in">vector</span> == <span class="number">0x28</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向中断控制器发送中断处理完成的信号</span></span><br><span class="line">    send_eoi(<span class="built_in">vector</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读 CMOS 寄存器 C，允许 CMOS 继续产生中断</span></span><br><span class="line">    cmos_read(CMOS_C);</span><br><span class="line"></span><br><span class="line">    set_alarm(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    LOGK(<span class="string">&quot;rtc handler %d...\n&quot;</span>, counter++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 secs 秒后发生实时时钟中断</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_alarm</span><span class="params">(u32 secs)</span></span><br><span class="line">&#123;</span><br><span class="line">    tm time;</span><br><span class="line">    time_read(&amp;time);</span><br><span class="line"></span><br><span class="line">    u8 sec = secs % <span class="number">60</span>;</span><br><span class="line">    secs /= <span class="number">60</span>;</span><br><span class="line">    u8 min = secs % <span class="number">60</span>;</span><br><span class="line">    secs /= <span class="number">60</span>;</span><br><span class="line">    u32 hour = secs;</span><br><span class="line"></span><br><span class="line">    time.tm_sec += sec;</span><br><span class="line">    <span class="keyword">if</span> (time.tm_sec &gt;= <span class="number">60</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        time.tm_sec %= <span class="number">60</span>;</span><br><span class="line">        time.tm_min += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.tm_min += min;</span><br><span class="line">    <span class="keyword">if</span> (time.tm_min &gt;= <span class="number">60</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        time.tm_min %= <span class="number">60</span>;</span><br><span class="line">        time.tm_hour += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.tm_hour += hour;</span><br><span class="line">    <span class="keyword">if</span> (time.tm_hour &gt;= <span class="number">24</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        time.tm_hour %= <span class="number">24</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cmos_write(CMOS_HOUR, bin_to_bcd(time.tm_hour));</span><br><span class="line">    cmos_write(CMOS_MINUTE, bin_to_bcd(time.tm_min));</span><br><span class="line">    cmos_write(CMOS_SECOND, bin_to_bcd(time.tm_sec));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rtc_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 prev;</span><br><span class="line"></span><br><span class="line">    cmos_write(CMOS_B, <span class="number">0b01000010</span>); <span class="comment">// 打开周期中断</span></span><br><span class="line">    <span class="comment">// cmos_write(CMOS_B, 0b00100010); // 打开闹钟中断</span></span><br><span class="line">    cmos_read(CMOS_C); <span class="comment">// 读 C 寄存器，以允许 CMOS 中断</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// set_alarm(2);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置中断频率</span></span><br><span class="line">    outb(CMOS_A, (inb(CMOS_A) &amp; <span class="number">0xf</span>) | <span class="number">0b1110</span>);</span><br><span class="line"></span><br><span class="line">    set_interrupt_handler(IRQ_RTC, rtc_handler);</span><br><span class="line">    set_interrupt_mask(IRQ_RTC, <span class="literal">true</span>);</span><br><span class="line">    set_interrupt_mask(IRQ_CASCADE, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>着重说一下rtc_init</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rtc_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 prev;</span><br><span class="line"></span><br><span class="line">    cmos_write(CMOS_B, <span class="number">0b01000010</span>); <span class="comment">// 打开周期中断</span></span><br><span class="line">    <span class="comment">// cmos_write(CMOS_B, 0b00100010); // 打开闹钟中断</span></span><br><span class="line">    cmos_read(CMOS_C); <span class="comment">// 读 C 寄存器，以允许 CMOS 中断</span></span><br><span class="line">    <span class="comment">// set_alarm(2);</span></span><br><span class="line">    <span class="comment">// 设置中断频率</span></span><br><span class="line">    outb(CMOS_A, (inb(CMOS_A) &amp; <span class="number">0xf</span>) | <span class="number">0b1110</span>);</span><br><span class="line"></span><br><span class="line">    set_interrupt_handler(IRQ_RTC, rtc_handler);</span><br><span class="line">    set_interrupt_mask(IRQ_RTC, <span class="literal">true</span>);</span><br><span class="line">    set_interrupt_mask(IRQ_CASCADE, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>cmos_write(CMOS_B, 0b01000010); // 打开周期中断</code>是单纯的基本中断，即CMOS按照其固定的时间刷新</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/6623065d8494e83961159c4908e2f4ea.png" alt="image-20220322164809678" /></p>
<p><code>cmos_write(CMOS_B, 0b00100010);</code>我们就可以设置每次中断发生的时间，比如上面注释掉的<code>set_alarm(2);</code>就是中断每2s发生一次</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/93e2eacd64b2a7c3bb98fe97ed72896c.png" alt="image-20220322165044877" /></p>
<p>两个数值(功能)的选择可以从8256芯片的级联图中看出</p>
<h3 id="时钟中断"><a class="markdownIt-Anchor" href="#时钟中断"></a> 时钟中断</h3>
<blockquote>
<p>常用的可编程定时计数器 (Programmable Interval Timer PIT) 有 Intel 8253/8254，其中 8254 可以称为 8253 的增强版。</p>
<p>在 8253 内部有 3 个独立的计数器，分别是计数器 0 ~ 2，端口号分别为 0x40 ~ 0x42；每个计数器完全相同，都是 16 位大小，相互独立，互不干涉。</p>
<p>8253 计数器是个减法计数器，从初值寄存器中得到初值，然后载入计数器中，然后随着时钟变化递减。计数器初值寄存器，计数器执行寄存器，和输出锁存器都是 16 位的寄存器，高八位和低八位可以单独访问。</p>
<p>计数器 0 用于产生时钟中断，就是连接在 IRQ0 引脚上的时钟，也就是控制计数器 0 可以控制时钟发生的频率，以改变时间片的间隔；</p>
</blockquote>
<p>控制字结构：</p>
<table>
<thead>
<tr>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody>
<tr>
<td>SC1</td>
<td>SC0</td>
<td>RL1</td>
<td>RL0</td>
<td>M2</td>
<td>M1</td>
<td>M0</td>
<td>BCD</td>
</tr>
</tbody>
</table>
<p>三个计数器有自己各自的用途：</p>
<ul>
<li>
<p>计数器 0，端口号 0x40，用于产生时钟信号，它采用工作方式 3；</p>
</li>
<li>
<p>计数器 1，端口号 0x41，用于 DRAM 的定时刷新控制；</p>
</li>
<li>
<p>计数器 2，端口号 0x42，用于内部扬声器发出不同音调的声音，原理是给扬声器输送某频率的方波；</p>
</li>
</ul>
<p><code>src/kernel/clock.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/debug.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIT_CHAN0_REG 0X40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIT_CHAN2_REG 0X42</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIT_CTRL_REG 0X43</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">clock_handler</span><span class="params">(<span class="type">int</span> <span class="built_in">vector</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(<span class="built_in">vector</span> == <span class="number">0x20</span>);</span><br><span class="line">    send_eoi(<span class="built_in">vector</span>);</span><br><span class="line"></span><br><span class="line">    jiffies++;</span><br><span class="line">    DEBUGK(<span class="string">&quot;clock jiffies %d ...\n&quot;</span>, jiffies);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pit_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 配置计数器 0 时钟</span></span><br><span class="line">    outb(PIT_CTRL_REG, <span class="number">0b00110100</span>);</span><br><span class="line">    outb(PIT_CHAN0_REG, CLOCK_COUNTER &amp; <span class="number">0xff</span>);</span><br><span class="line">    outb(PIT_CHAN0_REG, (CLOCK_COUNTER &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">clock_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    pit_init();</span><br><span class="line">    set_interrupt_handler(IRQ_CLOCK, clock_handler);</span><br><span class="line">    set_interrupt_mask(IRQ_CLOCK, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/ac45100c17d232cf4f31fae8548feea9.png" alt="image-20220322171044770" /></p>
<p>但是这个例子没什么实际的东西，我们看到的也只有上面不断显示的字符，下面就有了更好的体验</p>
<h3 id="蜂鸣器"><a class="markdownIt-Anchor" href="#蜂鸣器"></a> 蜂鸣器</h3>
<p>由PIT我们可以设置方波来发出声音，要添加一些东西</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> HZ 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OSCILLATOR 1193182</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLOCK_COUNTER (OSCILLATOR / HZ)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JIFFY (1000 / HZ)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPEAKER_REG 0x61</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BEEP_HZ 440</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BEEP_COUNTER (OSCILLATOR / BEEP_HZ)</span></span><br><span class="line"></span><br><span class="line">u32 <span class="keyword">volatile</span> jiffies = <span class="number">0</span>;</span><br><span class="line">u32 jiffy = JIFFY;</span><br><span class="line"></span><br><span class="line">u32 <span class="keyword">volatile</span> beeping = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">start_beep</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!beeping)</span><br><span class="line">    &#123;</span><br><span class="line">        outb(SPEAKER_REG, inb(SPEAKER_REG) | <span class="number">0b11</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    beeping = jiffies + <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">stop_beep</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (beeping &amp;&amp; jiffies &gt; beeping)</span><br><span class="line">    &#123;</span><br><span class="line">        outb(SPEAKER_REG, inb(SPEAKER_REG) &amp; <span class="number">0xfc</span>);</span><br><span class="line">        beeping = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时修改clock_handler</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">clock_handler</span><span class="params">(<span class="type">int</span> <span class="built_in">vector</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(<span class="built_in">vector</span> == <span class="number">0x20</span>);</span><br><span class="line">    send_eoi(<span class="built_in">vector</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(jiffies % <span class="number">200</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        start_beep();</span><br><span class="line">    &#125;</span><br><span class="line">    jiffies++;</span><br><span class="line">    DEBUGK(<span class="string">&quot;clock beep %d ...\n&quot;</span>, jiffies);</span><br><span class="line"></span><br><span class="line">    stop_beep();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在qemu上发声我的不知道是什么原因不行，但是导出在VMware上就可以了</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/4a29656ab690da0dc86a9d95814dfc95.png" alt="image-20220322171908376" /></p>
<h2 id="软中断"><a class="markdownIt-Anchor" href="#软中断"></a> 软中断</h2>
<p>这个里面就包括了最开始说的除0异常。软中断是发生在计算机内部的中断信号，是由执行指令引起的</p>
<p><a target="_blank" rel="noopener" href="https://blog.joe1sn.top/2022/03/10/os-interrupt/">操作系统实现-中断与系统调用</a>和<a target="_blank" rel="noopener" href="https://blog.joe1sn.top/2022/03/14/os-falut/">操作系统实现-异常</a>主要讲的就是这种中断</p>
<p>CPU时钟周期和前面实时时钟的不一样，CPU内部是有一个时钟周期作为指令操作的最小步骤的，当CPU运算快时，时钟周期就短（其倒数频率就越大），如<code>Intel(R) Core(TM) i5-9300H CPU</code>的基础时钟频率就是2.6GHz，每个时钟周期的时间就是<code>1/(2.6*1024*1024*1024)</code>秒。</p>
<h2 id="引用-2"><a class="markdownIt-Anchor" href="#引用-2"></a> 引用</h2>
<p>x86汇编语言：从实模式到保护模式 / 李忠，王晓波，余洁著</p>
<p><a target="_blank" rel="noopener" href="https://github.com/junler/linux-source-code-analyze/blob/c60d57def7cbf1b6bd52b41d80a1c25fdfd0134d/interrupt_softward.md">中断处理 - 上半部（硬中断）</a></p>
<h1 id="操作系统实现-内存管理初步"><a class="markdownIt-Anchor" href="#操作系统实现-内存管理初步"></a> 操作系统实现-内存管理初步</h1>
<h2 id="复习"><a class="markdownIt-Anchor" href="#复习"></a> 复习</h2>
<p>计算机启动过程</p>
<img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/996a02fdab5785c7659475f1c8832b11.png" alt="img" style="zoom: 50%;" />
<ul>
<li>386/486 内存分页中以 4KB 为一页</li>
<li>奔腾处理器使用4M为一页</li>
</ul>
</div></article><div class="pagination"><a class="pagination__link pagination__prev" href="/2023/02/16/windows_kernel_driver_1/">prev_post</a><a class="pagination__link pagination__next" href="/2022/08/14/cypherpunk/">next_post</a></div></main><footer class="footer metadata"><p class="footer__text">© 2025 Joe1sn</p><p class="footer__text">Powered by <a class="footer__text__link" href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a class="footer__text__link" href="https://pages.github.com/" target="_blank">Github Page</a></p></footer></div></body></html>