<!DOCTYPE html><html lang="zh"><head><meta charset="UTF-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Joe1sn's Cabinet | 【源码分析】AFL源代码分析</title><meta name="description" content="&lt;p&gt;其实还是挺简单的&lt;/p&gt;"><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700"><link rel="stylesheet" href="/css/highlights/darkula.css"><link rel="stylesheet" href="/css/main.css"><link rel="search" type="application/opensearchdescription+xml" href="https://joe1sn.eu.org/atom.xml" title="Joe1sn's Cabinet"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Joe1sn's Cabinet" type="application/atom+xml">
</head><body><div class="container"><header class="main-header"><h1 class="main-header__title uplize"><a class="main-header__title__link" href="/">Joe1sn's Cabinet</a></h1><nav class="main-header__nav"><ul class="main-nav"><li class="main-nav__list"><a class="main-nav__list__link" href="/" target="_self">HOME</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/archives/" target="_self">ARCHIVE</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="https://github.com/Joe1sn" target="_blank">GITHUB</a></li></ul></nav></header><main class="container__wrapper"><article class="article post"><h3 class="article__title">【源码分析】AFL源代码分析</h3><div class="article__date metadata"><div class="post-info">2023/07/22</div></div><div class="article__tags metadata">Tags:
<a class="article__tags__link metadata" href="/tags/source/">source</a><a class="article__tags__link metadata" href="/tags/AFL/">AFL</a></div><div class="article__body"><p>其实还是挺简单的</p>
<span id="more"></span>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/2ce8fd381c9b8cd5f9ebfc1e137790c7.png" alt="image-20230722090502823" /></p>
<p>在一次期末报告里面做了这个报告</p>
<p><strong>关于AFL的基本步骤</strong></p>
<p>工作流程基本上可以用 5 个步骤来描述：预处理、输入构建、输入选择、评估、后模糊测试。 真正的内核处理是步骤 2 到 4</p>
<ul>
<li>
<p>预处理</p>
<p>分析和获取有用信息，使用PIN，符号执行，污点检查</p>
<p>黑盒白盒</p>
</li>
<li>
<p>输入构建</p>
<p>从数据 S（种子）产生大量变异数据 I。</p>
</li>
<li>
<p>输入选择</p>
<p>过滤无效数据，优化模糊测试</p>
</li>
<li>
<p>评估</p>
<p>大多数关于模糊的研究集中在两个指标上：覆盖率和利用漏洞的平均时间</p>
</li>
</ul>
<h1 id="源码分析"><a class="markdownIt-Anchor" href="#源码分析"></a> 源码分析</h1>
<h2 id="编译插桩"><a class="markdownIt-Anchor" href="#编译插桩"></a> 编译插桩</h2>
<h3 id="afl-gcc"><a class="markdownIt-Anchor" href="#afl-gcc"></a> afl-gcc</h3>
<p>根据使用方法，首先是使用<code>afl-gcc</code>进行编译，在编译时就完成插桩</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/97bdf6ef6f906c0fe4f25c248f13ece7.png" alt="image-20230722090843228" /></p>
<p>本就是是包裹的GCC盒CLANG</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isatty(<span class="number">2</span>) &amp;&amp; !getenv(<span class="string">&quot;AFL_QUIET&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(cCYA <span class="string">&quot;afl-cc &quot;</span> cBRI VERSION cRST <span class="string">&quot; by &lt;lcamtuf@google.com&gt;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> be_quiet = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(<span class="string">&quot;\n&quot;</span></span><br><span class="line">         <span class="string">&quot;This is a helper application for afl-fuzz. It serves as a drop-in replacement\n&quot;</span></span><br><span class="line">         <span class="string">&quot;for gcc or clang, letting you recompile third-party code with the required\n&quot;</span></span><br><span class="line">         <span class="string">&quot;runtime instrumentation. A common use pattern would be one of the following:\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;  CC=%s/afl-gcc ./configure\n&quot;</span></span><br><span class="line">         <span class="string">&quot;  CXX=%s/afl-g++ ./configure\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;You can specify custom next-stage toolchain via AFL_CC, AFL_CXX, and AFL_AS.\n&quot;</span></span><br><span class="line">         <span class="string">&quot;Setting AFL_HARDEN enables hardening optimizations in the compiled code.\n\n&quot;</span>,</span><br><span class="line">         BIN_PATH, BIN_PATH);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  find_as(argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  edit_params(argc, argv);</span><br><span class="line"></span><br><span class="line">  execvp(cc_params[<span class="number">0</span>], (<span class="type">char</span>**)cc_params);</span><br><span class="line"></span><br><span class="line">  FATAL(<span class="string">&quot;Oops, failed to execute &#x27;%s&#x27; - check your PATH&quot;</span>, cc_params[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>SAYF</code>就是<code>fprintf</code>函数，检测到参数小于2的时候报错并退出</p>
<ul>
<li>使用<code>find_as</code>进行参数的解析到自身程序路径，找到<code>afl-as</code>的afl汇编器</li>
<li><code>edit_params</code>中，解析参数，设置自生对应的编译器，获得和设置一系列环境变量，最后得到的<code>cc_params</code>就是编译参数</li>
<li><code> execvp(cc_params[0], (char**)cc_params);</code>，通过前面找到的汇编器<code>as_path</code>和参数创建进程进行插桩编译。（具体就是替换了程序名称之类的，源码很简单）</li>
</ul>
<h3 id="afl-as"><a class="markdownIt-Anchor" href="#afl-as"></a> afl-as</h3>
<p><strong>main</strong></p>
<p>进入main创建了一些列变量然后就是在<code>a</code> 中将 <code>cc_params</code> 转为<code>as_params</code></p>
<p><strong>add_instrumentation</strong></p>
<p>重头函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (fgets(line, MAX_LINE, inf)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* In some cases, we want to defer writing the instrumentation trampoline</span></span><br><span class="line"><span class="comment">       until after all the labels, macros, comments, etc. If we&#x27;re in this</span></span><br><span class="line"><span class="comment">       mode, and if the line starts with a tab followed by a character, dump</span></span><br><span class="line"><span class="comment">       the trampoline now. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pass_thru &amp;&amp; !skip_intel &amp;&amp; !skip_app &amp;&amp; !skip_csect &amp;&amp; instr_ok &amp;&amp;</span><br><span class="line">        instrument_next &amp;&amp; line[<span class="number">0</span>] == <span class="string">&#x27;\t&#x27;</span> &amp;&amp; <span class="built_in">isalpha</span>(line[<span class="number">1</span>])) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,</span><br><span class="line">              R(MAP_SIZE));</span><br><span class="line"></span><br><span class="line">      instrument_next = <span class="number">0</span>;</span><br><span class="line">      ins_lines++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，AFL的代码插桩，就是在将源文件编译为汇编代码后，通过<code>afl-as</code>完成。开始重写汇编指令，准备在分支处插入代码</p>
<p>先看看32位，64位和这个也差不多</p>
<p><code>trampoline_fmt_32</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static const u8* trampoline_fmt_32 =</span><br><span class="line"></span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;/* --- AFL TRAMPOLINE (32-BIT) --- */\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;.align 4\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;leal -16(%%esp), %%esp\n&quot;</span><br><span class="line">  &quot;movl %%edi,  0(%%esp)\n&quot;</span><br><span class="line">  &quot;movl %%edx,  4(%%esp)\n&quot;</span><br><span class="line">  &quot;movl %%ecx,  8(%%esp)\n&quot;</span><br><span class="line">  &quot;movl %%eax, 12(%%esp)\n&quot;</span><br><span class="line">  &quot;movl $0x%08x, %%ecx\n&quot;</span><br><span class="line">  &quot;call __afl_maybe_log\n&quot;</span><br><span class="line">  &quot;movl 12(%%esp), %%eax\n&quot;</span><br><span class="line">  &quot;movl  8(%%esp), %%ecx\n&quot;</span><br><span class="line">  &quot;movl  4(%%esp), %%edx\n&quot;</span><br><span class="line">  &quot;movl  0(%%esp), %%edi\n&quot;</span><br><span class="line">  &quot;leal 16(%%esp), %%esp\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;/* --- END --- */\n&quot;</span><br><span class="line">  &quot;\n&quot;;</span><br></pre></td></tr></table></figure>
<p>这就是汇编，听chatGPT说</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">section .text</span><br><span class="line">global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    lea esp, [esp-16]      ; leal -16(%esp), %esp</span><br><span class="line">    mov [esp], edi         ; movl %edi, 0(%esp)</span><br><span class="line">    mov [esp+4], edx       ; movl %edx, 4(%esp)</span><br><span class="line">    mov [esp+8], ecx       ; movl %ecx, 8(%esp)</span><br><span class="line">    mov [esp+12], eax      ; movl %eax, 12(%esp)</span><br><span class="line">    mov ecx, 0x08000000    ; movl $0x%08x, %ecx</span><br><span class="line">    call __afl_maybe_log   ; call __afl_maybe_log</span><br><span class="line">    mov eax, [esp+12]      ; movl 12(%esp), %eax</span><br><span class="line">    mov ecx, [esp+8]       ; movl 8(%esp), %ecx</span><br><span class="line">    mov edx, [esp+4]       ; movl 4(%esp), %edx</span><br><span class="line">    mov edi, [esp]         ; movl 0(%esp), %edi</span><br><span class="line">    lea esp, [esp+16]      ; leal 16(%esp), %esp</span><br></pre></td></tr></table></figure>
<p>32位是经典的栈传参，这里使用对esp的移动实现了从<code>edi</code> <code>edx</code> <code>ecx</code> <code>eax</code>的保存，然后又将<code>ecx</code>设置为了0x08000000，这个是chatGPT翻译错了，正确的理解是&quot;%08x&quot; 是格式说明符，用于将一个整数格式化为一个带有前导零的 8 位十六进制数。例如，“%08x” 将把数字 10 格式化为 “0000000A”。这段汇编仍然是属于C语言的范畴。</p>
<p>似乎我们下一步要看的是<code>__afl_maybe_log</code>，**但是你就没想过R(MAP_SIZE)**有什么用吗？<code>R(x)</code>的定义是<code>(random() % (x))</code>，所以<code>R(MAP_SIZE)</code>即为0到MAP_SIZE之间的一个随机数。</p>
<p>因此，在处理到某个分支，需要插入桩代码时，<code>afl-as</code>会生成一个随机数，作为运行时保存在<code>ecx</code>中的值。而这个随机数，便是用于标识这个代码块的key。</p>
<p>接下来来到<code>__afl_maybe_log</code></p>
<h2 id="运行"><a class="markdownIt-Anchor" href="#运行"></a> 运行</h2>
<p>开始fuzz，那么afl如何启动这个程序，可以看看<code>afl-fuzz.c</code>，不过最开始后世设置参数，这里将重要点的部分。</p>
<p>调用的链条有点复杂首先在L8044</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skipped_fuzz = fuzz_one(use_argv);</span><br></pre></td></tr></table></figure>
<p>然后的<code>fuzz_one</code>中，使用队列<code>queue_cur</code>来管理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = calibrate_case(argv, queue_cur, in_buf, queue_cycle - <span class="number">1</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>在<code>calibrate_case</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (dumb_mode != <span class="number">1</span> &amp;&amp; !no_forkserver &amp;&amp; !forksrv_pid)</span><br><span class="line">  init_forkserver(argv);</span><br></pre></td></tr></table></figure>
<p>总算是找到了</p>
<blockquote>
<p>为了更高效地进行上述过程，AFL实现了一套fork server机制。其基本思路是：启动target进程后，target会运行一个fork server；fuzzer并不负责fork子进程，而是与这个fork server通信，并由fork server来完成fork及继续执行目标的操作。这样设计的最大好处，就是不需要调用<code>execve()</code>，从而节省了载入目标文件和库、解析符号地址等重复性工作</p>
</blockquote>
<p>L1987</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> st_pipe[<span class="number">2</span>], ctl_pipe[<span class="number">2</span>];</span><br><span class="line">....</span><br><span class="line">forksrv_pid = fork();</span><br></pre></td></tr></table></figure>
<p>使用pipe和forkserver进行通讯</p>
<p>L2088的位置开始执行<code>execv(target_path, argv);</code>。其实看到这里我也很疑惑上面的解释</p>
<p>在L2103中测试和forkserver的通讯</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    fsrv_ctl_fd = ctl_pipe[<span class="number">1</span>];</span><br><span class="line">    fsrv_st_fd  = st_pipe[<span class="number">0</span>];</span><br><span class="line">    rlen = read(fsrv_st_fd, &amp;status, <span class="number">4</span>);</span><br><span class="line">...</span><br><span class="line">  <span class="comment">/* If we have a four-byte &quot;hello&quot; message from the server, we&#x27;re all set.</span></span><br><span class="line"><span class="comment">     Otherwise, try to figure out what went wrong. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (rlen == <span class="number">4</span>) &#123;</span><br><span class="line">    OKF(<span class="string">&quot;All right - fork server is up.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;    </span><br></pre></td></tr></table></figure>
<p>接下来的fork server是如何与fuzzer通信是面试考点（/doge）</p>
<h3 id="forkserver"><a class="markdownIt-Anchor" href="#forkserver"></a> forkserver</h3>
<p>知道创宇不知道是讲的太碎了还是我理解有问题，在这里我就不怎么追的了代码了，不过想起开始说过的：<strong>fuzzer并不负责fork子进程，而是与这个fork server通信，并由fork server来完成fork及继续执行目标的操作</strong>，那么很有可能和插进去的<code>__afl_maybe_log</code>一样是插入入进去了一个<code>forkserver</code>在代码当中，那么回到<code>afl-as</code>，L446</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ins_lines)</span><br><span class="line">  <span class="built_in">fputs</span>(use_64bit ? main_payload_64 : main_payload_32, outf);</span><br></pre></td></tr></table></figure>
<p>依然以32位举例子<code>main_payload_32</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;__afl_forkserver:\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Enter the fork server mode to avoid the overhead of execve() calls. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl %eax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl %ecx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl %edx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Phone home and tell the parent that we&#x27;re OK. (Note that signals with\n&quot;</span></span><br><span class="line">  <span class="string">&quot;     no SA_RESTART will mess it up). If this fails, assume that the fd is\n&quot;</span></span><br><span class="line">  <span class="string">&quot;     closed because we were execve()d from an instrumented binary, or because\n&quot;</span> </span><br><span class="line">  <span class="string">&quot;     the parent doesn&#x27;t want to use the fork server. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $4          /* length    */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $__afl_temp /* data      */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $&quot;</span> STRINGIFY((FORKSRV_FD + <span class="number">1</span>)) <span class="string">&quot;  /* file desc */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  call  write\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  addl  $12, %esp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  cmpl  $4, %eax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  jne   __afl_fork_resume\n&quot;</span></span><br></pre></td></tr></table></figure>
<p>看注释也看的明白了，给fuzzer说已经准备完毕，其中<code>$__afl_temp</code>就是四字节长度的验证信息，然后开始等待循环，读取命令管道，直到fuzzer通知其开始</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;__afl_fork_wait_loop:\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  /* Wait for parent by reading from the pipe. Abort if read fails. */\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  pushl $4          /* length    */\n&quot;</span></span><br><span class="line"><span class="string">&quot;  pushl $__afl_temp /* data      */\n&quot;</span></span><br><span class="line"><span class="string">&quot;  pushl $&quot;</span> STRINGIFY(FORKSRV_FD) <span class="string">&quot;        /* file desc */\n&quot;</span></span><br><span class="line"><span class="string">&quot;  call  read\n&quot;</span></span><br><span class="line"><span class="string">&quot;  addl  $12, %esp\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  cmpl  $4, %eax\n&quot;</span></span><br><span class="line"><span class="string">&quot;  jne   __afl_die\n&quot;</span>      </span><br></pre></td></tr></table></figure>
<p>有错误就寄<code>__afl_die</code>，那么成功的话</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;  /* Once woken up, create a clone of our process. This is an excellent use\n&quot;</span></span><br><span class="line"><span class="string">&quot;     case for syscall(__NR_clone, 0, CLONE_PARENT), but glibc boneheadedly\n&quot;</span></span><br><span class="line"><span class="string">&quot;     caches getpid() results and offers no way to update the value, breaking\n&quot;</span></span><br><span class="line"><span class="string">&quot;     abort(), raise(), and a bunch of other things :-( */\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  call fork\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  cmpl $0, %eax\n&quot;</span></span><br><span class="line"><span class="string">&quot;  jl   __afl_die\n&quot;</span></span><br><span class="line"><span class="string">&quot;  je   __afl_fork_resume\n&quot;</span>        </span><br></pre></td></tr></table></figure>
<p>得到父子进程的ID，对待子进程走到<code>__afl_fork_resume</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;__afl_fork_resume:\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* In child process: close fds, resume execution. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $&quot;</span> STRINGIFY(FORKSRV_FD) <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  call  close\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $&quot;</span> STRINGIFY((FORKSRV_FD + <span class="number">1</span>)) <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  call  close\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  addl  $8, %esp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  popl %edx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  popl %ecx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  popl %eax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  jmp  __afl_store\n&quot;</span></span><br></pre></td></tr></table></figure>
<p>对于大于0的返回值（即父进程）他继续运行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;  /* In parent process: write PID to pipe, then wait for child. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movl  %eax, __afl_fork_pid\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $4              /* length    */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $__afl_fork_pid /* data      */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $&quot;</span> STRINGIFY((FORKSRV_FD + <span class="number">1</span>)) <span class="string">&quot;      /* file desc */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  call  write\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  addl  $12, %esp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $0             /* no flags  */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $__afl_temp    /* status    */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl __afl_fork_pid /* PID       */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  call  waitpid\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  addl  $12, %esp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  cmpl  $0, %eax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  jle   __afl_die\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Relay wait status to pipe, then loop back. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $4          /* length    */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $__afl_temp /* data      */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $&quot;</span> STRINGIFY((FORKSRV_FD + <span class="number">1</span>)) <span class="string">&quot;  /* file desc */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  call  write\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  addl  $12, %esp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  jmp __afl_fork_wait_loop\n&quot;</span>    </span><br></pre></td></tr></table></figure>
<p>继续进行forkserver的管道通讯，然后<code>__afl_fork_wait_loop</code>，</p>
<h3 id="fuzzer"><a class="markdownIt-Anchor" href="#fuzzer"></a> fuzzer</h3>
<p>回顾一下目前“栈”的情况：<code>main</code> -&gt; <code>calibrate_case</code> -&gt; <code>init_forkserver</code></p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/0d62f5f1741495588a352bb92afabe74.png" alt="image-20230722112212761" /></p>
<p>​	回退到<code>calibrate_case</code>继续执行，<code>write_to_testcase</code>就是设置测试样例，重点在于<code>run_target</code>。AFL的文件编译策略不是胡乱变换的，主要是<code>dumb_mode</code>有没有被开启，一般都是不会开启的，那么就来到了L2362</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  s32 res;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* In non-dumb mode, we have the fork server up and running, so simply</span></span><br><span class="line"><span class="comment">     tell it to have at it, and then read back PID. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((res = write(fsrv_ctl_fd, &amp;prev_timed_out, <span class="number">4</span>)) != <span class="number">4</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stop_soon) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    RPFATAL(res, <span class="string">&quot;Unable to request new process from fork server (OOM?)&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((res = read(fsrv_st_fd, &amp;child_pid, <span class="number">4</span>)) != <span class="number">4</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stop_soon) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    RPFATAL(res, <span class="string">&quot;Unable to request new process from fork server (OOM?)&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (child_pid &lt;= <span class="number">0</span>) FATAL(<span class="string">&quot;Fork server is misbehaving (OOM?)&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看注释和代码，知道通过管道向forkserver通知准备完毕，并得到返回的PID，然后就是L2438</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (WIFSIGNALED(status) &amp;&amp; !stop_soon) &#123;</span><br><span class="line"></span><br><span class="line">  kill_signal = WTERMSIG(status);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (child_timed_out &amp;&amp; kill_signal == SIGKILL) <span class="keyword">return</span> FAULT_TMOUT;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> FAULT_CRASH;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>fuzzer再次读取状态管道，获取子进程退出状态，并由此来判断子进程结束的原因，例如正常退出、超时、崩溃等，并进行相应的记录</p>
<h3 id="共享内存机制"><a class="markdownIt-Anchor" href="#共享内存机制"></a> 共享内存机制</h3>
<p>解决程序插桩和启动运行后，就来到了对示例的fuzz阶段。在程序待测试部分，程序先是初始化变异方式。AFL通过共享内存机制来方便高并发的样例读取，减小IO的损耗。<br />
代码不长这里贴一下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">EXP_ST <span class="type">void</span> <span class="title function_">setup_shm</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">  u8* shm_str;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!in_bitmap) <span class="built_in">memset</span>(virgin_bits, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(virgin_tmout, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line">  <span class="built_in">memset</span>(virgin_crash, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line"></span><br><span class="line">  shm_id = shmget(IPC_PRIVATE, MAP_SIZE, IPC_CREAT | IPC_EXCL | <span class="number">0600</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (shm_id &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;shmget() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">  atexit(remove_shm);</span><br><span class="line"></span><br><span class="line">  shm_str = alloc_printf(<span class="string">&quot;%d&quot;</span>, shm_id);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If somebody is asking us to fuzz instrumented binaries in dumb mode,</span></span><br><span class="line"><span class="comment">     we don&#x27;t want them to detect instrumentation, since we won&#x27;t be sending</span></span><br><span class="line"><span class="comment">     fork server commands. This should be replaced with better auto-detection</span></span><br><span class="line"><span class="comment">     later on, perhaps? */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!dumb_mode) setenv(SHM_ENV_VAR, shm_str, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  ck_free(shm_str);</span><br><span class="line"></span><br><span class="line">  trace_bits = shmat(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (!trace_bits) PFATAL(<span class="string">&quot;shmat() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>afl-fuzz</code>的L7955来到<code>setup_shm</code>，这里设置共享内存，然后从<code>shemget()</code>（这是一个LinuxC的函数）获得一块内存。</p>
<blockquote>
<p>shmget()  returns  the identifier of the System V shared memory segment associated with the value of the argu‐<br />
ment key.  A new shared memory segment, with size equal to the value of size  rounded  up  to  a  multiple  of<br />
PAGE_SIZE, is created if key has the value IPC_PRIVATE or key isn’t IPC_PRIVATE, no shared memory segment cor‐<br />
responding to key exists, and IPC_CREAT is specified in shmflg.</p>
</blockquote>
<p>子进程通过环境变量<code>SHM_ENV_VAR</code>得到内存，对于fuzzer本身则会回到<code>trace_bits</code>保存内存地址</p>
<blockquote>
<p>shmat()  attaches  the  System V shared memory segment identified by shmid to the address space of the calling<br />
process.</p>
</blockquote>
<p>我们在且回到被测试的target中，看下他被插桩的代码（早于之前的forkserver）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;  /* Check if SHM region is already mapped. */\n&quot;</span></span><br><span class="line"> <span class="string">&quot;\n&quot;</span></span><br><span class="line"> <span class="string">&quot;  movl  __afl_area_ptr, %edx\n&quot;</span></span><br><span class="line"> <span class="string">&quot;  testl %edx, %edx\n&quot;</span></span><br><span class="line"> <span class="string">&quot;  je    __afl_setup\n&quot;</span></span><br><span class="line"> <span class="string">&quot;\n&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>__afl_area_ptr</code>：共享内存映射到target的内存空间中的地址</p>
</li>
<li>
<p><code>__afl_setup</code>：获取环境变量<code>AFL_SHM_ENV</code>的内容并将其转为整型，最后，通过调用<code>shmat()</code>，target将这块共享内存也映射到了自己的内存空间中，并将其地址保存在<code>__afl_area_ptr</code>及<code>edx</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;__afl_setup:\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Do not retry setup if we had previous failures. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  cmpb $0, __afl_setup_failure\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  jne  __afl_return\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Map SHM, jumping to __afl_setup_abort if something goes wrong.\n&quot;</span></span><br><span class="line">  <span class="string">&quot;     We do not save FPU/MMX/SSE registers here, but hopefully, nobody\n&quot;</span></span><br><span class="line">  <span class="string">&quot;     will notice this early in the game. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl %eax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl %ecx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $.AFL_SHM_ENV\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  call  getenv\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  addl  $4, %esp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  testl %eax, %eax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  je    __afl_setup_abort\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl %eax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  call  atoi\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  addl  $4, %esp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $0          /* shmat flags    */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $0          /* requested addr */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl %eax        /* SHM ID         */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  call  shmat\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  addl  $12, %esp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  cmpl $-1, %eax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  je   __afl_setup_abort\n&quot;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="分支信息的记录"><a class="markdownIt-Anchor" href="#分支信息的记录"></a> 分支信息的记录</h3>
<p>来到文章开始抛出的疑问<code>__afl_maybe_log</code>干了什么</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;__afl_maybe_log:\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  lahf\n&quot;</span></span><br><span class="line"><span class="string">&quot;  seto %al\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  /* Check if SHM region is already mapped. */\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movl  __afl_area_ptr, %edx\n&quot;</span></span><br><span class="line"><span class="string">&quot;  testl %edx, %edx\n&quot;</span></span><br><span class="line"><span class="string">&quot;  je    __afl_setup\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;__afl_store:\n&quot;</span></span><br></pre></td></tr></table></figure>
<p>读代码就知道了：</p>
<ul>
<li>
<p>检查共享内存的映射，有错进入到<code>__afl_setup</code></p>
</li>
<li>
<p>开始<code>__afl_store</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  <span class="string">&quot;__afl_store:\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Calculate and store hit for the code location specified in ecx. There\n&quot;</span></span><br><span class="line">  <span class="string">&quot;     is a double-XOR way of doing this without tainting another register,\n&quot;</span></span><br><span class="line">  <span class="string">&quot;     and we use it on 64-bit systems; but it&#x27;s slower for 32-bit ones. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> COVERAGE_ONLY</span></span><br><span class="line">  <span class="string">&quot;  movl __afl_prev_loc, %edi\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  xorl %ecx, %edi\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  shrl $1, %ecx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movl %ecx, __afl_prev_loc\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="string">&quot;  movl %ecx, %edi\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^!COVERAGE_ONLY */</span></span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SKIP_COUNTS</span></span><br><span class="line">  <span class="string">&quot;  orb  $1, (%edx, %edi, 1)\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="string">&quot;  incb (%edx, %edi, 1)\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^SKIP_COUNTS */</span></span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>__afl_prev_loc</code>：前一次跳转的”位置”</li>
<li><code>ecx</code>：最开始插桩的随机数位置，即代码块的标号</li>
</ul>
<blockquote>
<p>因此，AFL为每个代码块生成一个随机数，作为其“位置”的记录；随后，对分支处的”源位置“和”目标位置“进行异或，并将异或的结果作为该分支的key，保存每个分支的执行次数。用于保存执行次数的实际上是一个哈希表，大小为<code>MAP_SIZE=64K</code>，当然会存在碰撞的问题；但根据AFL文档中的介绍，对于不是很复杂的目标，碰撞概率还是可以接受的：</p>
</blockquote>
<p>在最后<code>map density</code>就是指的哈希表的密度，越小发生碰撞的概率越小</p>
</li>
</ul>
<h3 id="分支信息的分析"><a class="markdownIt-Anchor" href="#分支信息的分析"></a> 分支信息的分析</h3>
<p>前文提到了</p>
<ul>
<li><code>trace_bits</code>保存了共享内存</li>
<li>共享内存保存了分析记录</li>
</ul>
<p>那么，对于AFL从这块共享内存中获得信息就显得很合理了</p>
<p>在预处理共享内存时</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">classify_counts</span><span class="params">(u32* mem)</span> &#123;</span><br><span class="line"></span><br><span class="line">  u32 i = MAP_SIZE &gt;&gt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Optimize for sparse bitmaps. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(*mem)) &#123;</span><br><span class="line"></span><br><span class="line">      u16* mem16 = (u16*)mem;</span><br><span class="line"></span><br><span class="line">      mem16[<span class="number">0</span>] = count_class_lookup16[mem16[<span class="number">0</span>]];</span><br><span class="line">      mem16[<span class="number">1</span>] = count_class_lookup16[mem16[<span class="number">1</span>]];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    mem++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Destructively classify execution counts in a trace. This is used as a</span></span><br><span class="line"><span class="comment">   preprocessing step for any newly acquired traces. Called on every exec,</span></span><br><span class="line"><span class="comment">   must be fast. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> u8 count_class_lookup8[<span class="number">256</span>] = &#123;</span><br><span class="line"></span><br><span class="line">  [<span class="number">0</span>]           = <span class="number">0</span>,</span><br><span class="line">  [<span class="number">1</span>]           = <span class="number">1</span>,</span><br><span class="line">  [<span class="number">2</span>]           = <span class="number">2</span>,</span><br><span class="line">  [<span class="number">3</span>]           = <span class="number">4</span>,</span><br><span class="line">  [<span class="number">4</span> ... <span class="number">7</span>]     = <span class="number">8</span>,</span><br><span class="line">  [<span class="number">8</span> ... <span class="number">15</span>]    = <span class="number">16</span>,</span><br><span class="line">  [<span class="number">16</span> ... <span class="number">31</span>]   = <span class="number">32</span>,</span><br><span class="line">  [<span class="number">32</span> ... <span class="number">127</span>]  = <span class="number">64</span>,</span><br><span class="line">  [<span class="number">128</span> ... <span class="number">255</span>] = <span class="number">128</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最重要的是<code>count_class_lookup8</code>，target是将每个分支的执行次数用1个byte来储存，而fuzzer则进一步把这个执行次数归入buckets中，比如执行1次，<code>mem16 = count_class_lookup8[1]; == 1</code></p>
<p>执行3次<code>mem16 = count_class_lookup8[3]; == 4</code>。执行4次<code>mem16 = count_class_lookup8[4]; == 8</code></p>
<p>好处就在于分支A执行了32次；对另外一个测试用例，分支A执行了33次，那么AFL就会认为这两次的代码覆盖是相同的。这样通过代码块的执行次数就可以统计相关路径，AFL根据相关路径的HASH判断路径是否发生改变。</p>
<h1 id="文件变异规则"><a class="markdownIt-Anchor" href="#文件变异规则"></a> 文件变异规则</h1>
<p>看到好多研究生论文都是从这里下手的。。。</p>
<ul>
<li>
<p>bitflip，按位翻转，1变为0，0变为1</p>
<p>在对每个byte进行翻转时，如果其造成执行路径与原始路径不一致，就将该byte在effector map中标记为1，即“有效”的，否则标记为0，即“无效”的</p>
</li>
<li>
<p>arithmetic，整数加/减算术运算</p>
<p>对目标整数会进行+1, +2, …, +35, -1, -2, …, -35的变异。特别地，由于整数存在大端序和小端序两种表示方式，AFL会贴心地对这两种整数表示方式都进行变异。</p>
</li>
<li>
<p>interest，把一些特殊内容替换到原文件中</p>
<p>用于替换的&quot;interesting values&quot;，是AFL预设的一些比较特殊的数。</p>
<p><code>config.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INTERESTING_8 \</span></span><br><span class="line"><span class="meta">  -128,          <span class="comment">/* Overflow signed 8-bit when decremented  */</span> \</span></span><br><span class="line"><span class="meta">  -1,            <span class="comment">/*                                         */</span> \</span></span><br><span class="line"><span class="meta">   0,            <span class="comment">/*                                         */</span> \</span></span><br><span class="line"><span class="meta">   1,            <span class="comment">/*                                         */</span> \</span></span><br><span class="line"><span class="meta">   16,           <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   32,           <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   64,           <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   100,          <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   127           <span class="comment">/* Overflow signed 8-bit when incremented  */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTERESTING_16 \</span></span><br><span class="line"><span class="meta">  -32768,        <span class="comment">/* Overflow signed 16-bit when decremented */</span> \</span></span><br><span class="line"><span class="meta">  -129,          <span class="comment">/* Overflow signed 8-bit                   */</span> \</span></span><br><span class="line"><span class="meta">   128,          <span class="comment">/* Overflow signed 8-bit                   */</span> \</span></span><br><span class="line"><span class="meta">   255,          <span class="comment">/* Overflow unsig 8-bit when incremented   */</span> \</span></span><br><span class="line"><span class="meta">   256,          <span class="comment">/* Overflow unsig 8-bit                    */</span> \</span></span><br><span class="line"><span class="meta">   512,          <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   1000,         <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   1024,         <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   4096,         <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   32767         <span class="comment">/* Overflow signed 16-bit when incremented */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTERESTING_32 \</span></span><br><span class="line"><span class="meta">  -2147483648LL, <span class="comment">/* Overflow signed 32-bit when decremented */</span> \</span></span><br><span class="line"><span class="meta">  -100663046,    <span class="comment">/* Large negative number (endian-agnostic) */</span> \</span></span><br><span class="line"><span class="meta">  -32769,        <span class="comment">/* Overflow signed 16-bit                  */</span> \</span></span><br><span class="line"><span class="meta">   32768,        <span class="comment">/* Overflow signed 16-bit                  */</span> \</span></span><br><span class="line"><span class="meta">   65535,        <span class="comment">/* Overflow unsig 16-bit when incremented  */</span> \</span></span><br><span class="line"><span class="meta">   65536,        <span class="comment">/* Overflow unsig 16 bit                   */</span> \</span></span><br><span class="line"><span class="meta">   100663045,    <span class="comment">/* Large positive number (endian-agnostic) */</span> \</span></span><br><span class="line"><span class="meta">   2147483647    <span class="comment">/* Overflow signed 32-bit when incremented */</span></span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>dictionary，把自动生成或用户提供的token替换/插入到原文件中（从头开始）</p>
<p><code>-x</code>选项设置的token</p>
</li>
<li>
<p>havoc，中文意思是“大破坏”，此阶段会对原文件进行大量变异，具体见下文</p>
<p>开始智力下降，我在fuzz中看到的大多数都是这个阶段（阿巴阿巴）</p>
<ul>
<li>随机选取某个bit进行翻转</li>
<li>随机选取某个byte，将其设置为随机的interesting value</li>
<li>随机选取某个word，并随机选取大、小端序，将其设置为随机的interesting value</li>
<li>随机选取某个dword，并随机选取大、小端序，将其设置为随机的interesting value</li>
<li>随机选取某个byte，对其减去一个随机数</li>
<li>随机选取某个byte，对其加上一个随机数</li>
<li>随机选取某个word，并随机选取大、小端序，对其减去一个随机数</li>
<li>随机选取某个word，并随机选取大、小端序，对其加上一个随机数</li>
<li>随机选取某个dword，并随机选取大、小端序，对其减去一个随机数</li>
<li>随机选取某个dword，并随机选取大、小端序，对其加上一个随机数</li>
<li>随机选取某个byte，将其设置为随机数</li>
<li>随机删除一段bytes</li>
<li>随机选取一个位置，插入一段随机长度的内容，其中75%的概率是插入原文中随机位置的内容，25%的概率是插入一段随机选取的数</li>
<li>随机选取一个位置，替换为一段随机长度的内容，其中75%的概率是替换成原文中随机位置的内容，25%的概率是替换成一段随机选取的数</li>
<li>随机选取一个位置，用随机选取的token（用户提供的或自动生成的）替换</li>
<li>随机选取一个位置，用随机选取的token（用户提供的或自动生成的）插入</li>
</ul>
</li>
<li>
<p>splice，中文意思是“绞接”，此阶段会将两个文件拼接起来得到一个新的文件</p>
<p>splice是将两个seed文件拼接得到新的文件，并对这个新文件继续执行havoc变异</p>
</li>
<li>
<p>cycle：对队列所有文件全部按照上面的步骤来一遍就算完成了一个cycle，整个队列又会从第一个文件开始，再次进行变异，不过与第一次变异不同的是，这一次就不需要再进行deterministic fuzzing了。</p>
</li>
</ul>
<h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1>
<p><a target="_blank" rel="noopener" href="https://paper.seebug.org/496/">https://paper.seebug.org/496/</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/google/AFL">https://github.com/google/AFL</a></p>
</div></article><div class="pagination"><a class="pagination__link pagination__prev" href="/2023/09/10/stm32-1-light/">prev_post</a><a class="pagination__link pagination__next" href="/2023/07/19/win-afl2/">next_post</a></div></main><footer class="footer metadata"><p class="footer__text">© 2025 Joe1sn</p><p class="footer__text">Powered by <a class="footer__text__link" href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a class="footer__text__link" href="https://pages.github.com/" target="_blank">Github Page</a></p></footer></div></body></html>