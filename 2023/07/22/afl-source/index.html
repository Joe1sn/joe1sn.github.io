<!DOCTYPE html><html lang="zh"><head><meta charset="UTF-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Joe1sn's Cabinet | 【漏洞挖掘】AFL源代码分析</title><meta name="description" content="&lt;p&gt;说是为了面试，但是自己一直也挺好奇的&lt;/p&gt;"><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700"><link rel="stylesheet" href="/css/highlights/darkula.css"><link rel="stylesheet" href="/css/main.css"><link rel="search" type="application/opensearchdescription+xml" href="https://joe1sn.eu.org/atom.xml" title="Joe1sn's Cabinet"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Joe1sn's Cabinet" type="application/atom+xml">
</head><body><div class="container"><header class="main-header"><h1 class="main-header__title uplize"><a class="main-header__title__link" href="/">Joe1sn's Cabinet</a></h1><nav class="main-header__nav"><ul class="main-nav"><li class="main-nav__list"><a class="main-nav__list__link" href="/" target="_self">HOME</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/archives/" target="_self">ARCHIVE</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="https://github.com/Joe1sn" target="_blank">GITHUB</a></li></ul></nav></header><main class="container__wrapper"><article class="article post"><h3 class="article__title">【漏洞挖掘】AFL源代码分析</h3><div class="article__date metadata"><div class="post-info">2023/07/22</div></div><div class="article__tags metadata">Tags:
</div><div class="article__body"><p>说是为了面试，但是自己一直也挺好奇的</p>
<span id="more"></span>
<p><img src="D:%5CPictures%5Ctypora%5Cimage-20230722090502823.png" alt="image-20230722090502823" /></p>
<p>在一次期末报告里面做了这个报告</p>
<p><strong>关于AFL的基本步骤</strong></p>
<p>工作流程基本上可以用 5 个步骤来描述：预处理、输入构建、输入选择、评估、后模糊测试。 真正的内核处理是步骤 2 到 4</p>
<ul>
<li>
<p>预处理</p>
<p>分析和获取有用信息，使用PIN，符号执行，污点检查</p>
<p>黑盒白盒</p>
</li>
<li>
<p>输入构建</p>
<p>从数据 S（种子）产生大量变异数据 I。</p>
</li>
<li>
<p>输入选择</p>
<p>过滤无效数据，优化模糊测试</p>
</li>
<li>
<p>评估</p>
<p>大多数关于模糊的研究集中在两个指标上：覆盖率和利用漏洞的平均时间</p>
</li>
</ul>
<h1 id="源码分析"><a class="markdownIt-Anchor" href="#源码分析"></a> 源码分析</h1>
<h2 id="编译插桩"><a class="markdownIt-Anchor" href="#编译插桩"></a> 编译插桩</h2>
<h3 id="afl-gcc"><a class="markdownIt-Anchor" href="#afl-gcc"></a> afl-gcc</h3>
<p>根据使用方法，首先是使用<code>afl-gcc</code>进行编译，在编译时就完成插桩</p>
<p><img src="D:%5CPictures%5Ctypora%5Cimage-20230722090843228.png" alt="image-20230722090843228" /></p>
<p>本就是是包裹的GCC盒CLANG</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isatty(<span class="number">2</span>) &amp;&amp; !getenv(<span class="string">&quot;AFL_QUIET&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(cCYA <span class="string">&quot;afl-cc &quot;</span> cBRI VERSION cRST <span class="string">&quot; by &lt;lcamtuf@google.com&gt;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> be_quiet = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(<span class="string">&quot;\n&quot;</span></span><br><span class="line">         <span class="string">&quot;This is a helper application for afl-fuzz. It serves as a drop-in replacement\n&quot;</span></span><br><span class="line">         <span class="string">&quot;for gcc or clang, letting you recompile third-party code with the required\n&quot;</span></span><br><span class="line">         <span class="string">&quot;runtime instrumentation. A common use pattern would be one of the following:\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;  CC=%s/afl-gcc ./configure\n&quot;</span></span><br><span class="line">         <span class="string">&quot;  CXX=%s/afl-g++ ./configure\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;You can specify custom next-stage toolchain via AFL_CC, AFL_CXX, and AFL_AS.\n&quot;</span></span><br><span class="line">         <span class="string">&quot;Setting AFL_HARDEN enables hardening optimizations in the compiled code.\n\n&quot;</span>,</span><br><span class="line">         BIN_PATH, BIN_PATH);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  find_as(argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  edit_params(argc, argv);</span><br><span class="line"></span><br><span class="line">  execvp(cc_params[<span class="number">0</span>], (<span class="type">char</span>**)cc_params);</span><br><span class="line"></span><br><span class="line">  FATAL(<span class="string">&quot;Oops, failed to execute &#x27;%s&#x27; - check your PATH&quot;</span>, cc_params[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>SAYF</code>就是<code>fprintf</code>函数，检测到参数小于2的时候报错并退出</p>
<ul>
<li>使用<code>find_as</code>进行参数的解析到自身程序路径，找到<code>afl-as</code>的afl汇编器</li>
<li><code>edit_params</code>中，解析参数，设置自生对应的编译器，获得和设置一系列环境变量，最后得到的<code>cc_params</code>就是编译参数</li>
<li><code> execvp(cc_params[0], (char**)cc_params);</code>，通过前面找到的汇编器<code>as_path</code>和参数创建进程进行插桩编译。（具体就是替换了程序名称之类的，源码很简单）</li>
</ul>
<h3 id="afl-as"><a class="markdownIt-Anchor" href="#afl-as"></a> afl-as</h3>
<p><strong>main</strong></p>
<p>进入main创建了一些列变量然后就是在<code>a</code> 中将 <code>cc_params</code> 转为<code>as_params</code></p>
<p><strong>add_instrumentation</strong></p>
<p>重头函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (fgets(line, MAX_LINE, inf)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* In some cases, we want to defer writing the instrumentation trampoline</span></span><br><span class="line"><span class="comment">       until after all the labels, macros, comments, etc. If we&#x27;re in this</span></span><br><span class="line"><span class="comment">       mode, and if the line starts with a tab followed by a character, dump</span></span><br><span class="line"><span class="comment">       the trampoline now. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pass_thru &amp;&amp; !skip_intel &amp;&amp; !skip_app &amp;&amp; !skip_csect &amp;&amp; instr_ok &amp;&amp;</span><br><span class="line">        instrument_next &amp;&amp; line[<span class="number">0</span>] == <span class="string">&#x27;\t&#x27;</span> &amp;&amp; <span class="built_in">isalpha</span>(line[<span class="number">1</span>])) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,</span><br><span class="line">              R(MAP_SIZE));</span><br><span class="line"></span><br><span class="line">      instrument_next = <span class="number">0</span>;</span><br><span class="line">      ins_lines++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，AFL的代码插桩，就是在将源文件编译为汇编代码后，通过<code>afl-as</code>完成。开始重写汇编指令，准备在分支处插入代码</p>
<p>先看看32位，64位和这个也差不多</p>
<p><code>trampoline_fmt_32</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static const u8* trampoline_fmt_32 =</span><br><span class="line"></span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;/* --- AFL TRAMPOLINE (32-BIT) --- */\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;.align 4\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;leal -16(%%esp), %%esp\n&quot;</span><br><span class="line">  &quot;movl %%edi,  0(%%esp)\n&quot;</span><br><span class="line">  &quot;movl %%edx,  4(%%esp)\n&quot;</span><br><span class="line">  &quot;movl %%ecx,  8(%%esp)\n&quot;</span><br><span class="line">  &quot;movl %%eax, 12(%%esp)\n&quot;</span><br><span class="line">  &quot;movl $0x%08x, %%ecx\n&quot;</span><br><span class="line">  &quot;call __afl_maybe_log\n&quot;</span><br><span class="line">  &quot;movl 12(%%esp), %%eax\n&quot;</span><br><span class="line">  &quot;movl  8(%%esp), %%ecx\n&quot;</span><br><span class="line">  &quot;movl  4(%%esp), %%edx\n&quot;</span><br><span class="line">  &quot;movl  0(%%esp), %%edi\n&quot;</span><br><span class="line">  &quot;leal 16(%%esp), %%esp\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;/* --- END --- */\n&quot;</span><br><span class="line">  &quot;\n&quot;;</span><br></pre></td></tr></table></figure>
<p>这就是汇编，听chatGPT说</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">section .text</span><br><span class="line">global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    lea esp, [esp-16]      ; leal -16(%esp), %esp</span><br><span class="line">    mov [esp], edi         ; movl %edi, 0(%esp)</span><br><span class="line">    mov [esp+4], edx       ; movl %edx, 4(%esp)</span><br><span class="line">    mov [esp+8], ecx       ; movl %ecx, 8(%esp)</span><br><span class="line">    mov [esp+12], eax      ; movl %eax, 12(%esp)</span><br><span class="line">    mov ecx, 0x08000000    ; movl $0x%08x, %ecx</span><br><span class="line">    call __afl_maybe_log   ; call __afl_maybe_log</span><br><span class="line">    mov eax, [esp+12]      ; movl 12(%esp), %eax</span><br><span class="line">    mov ecx, [esp+8]       ; movl 8(%esp), %ecx</span><br><span class="line">    mov edx, [esp+4]       ; movl 4(%esp), %edx</span><br><span class="line">    mov edi, [esp]         ; movl 0(%esp), %edi</span><br><span class="line">    lea esp, [esp+16]      ; leal 16(%esp), %esp</span><br></pre></td></tr></table></figure>
<p>32位是经典的栈传参，这里使用对esp的移动实现了从<code>edi</code> <code>edx</code> <code>ecx</code> <code>eax</code>的保存，然后又将<code>ecx</code>设置为了0x08000000，这个是chatGPT翻译错了，正确的理解是&quot;%08x&quot; 是格式说明符，用于将一个整数格式化为一个带有前导零的 8 位十六进制数。例如，“%08x” 将把数字 10 格式化为 “0000000A”。这段汇编仍然是属于C语言的范畴。</p>
<p>似乎我们下一步要看的是<code>__afl_maybe_log</code>，**但是你就没想过R(MAP_SIZE)**有什么用吗？<code>R(x)</code>的定义是<code>(random() % (x))</code>，所以<code>R(MAP_SIZE)</code>即为0到MAP_SIZE之间的一个随机数。</p>
<p>因此，在处理到某个分支，需要插入桩代码时，<code>afl-as</code>会生成一个随机数，作为运行时保存在<code>ecx</code>中的值。而这个随机数，便是用于标识这个代码块的key。</p>
<p>接下来来到<code>__afl_maybe_log</code></p>
<h2 id="运行"><a class="markdownIt-Anchor" href="#运行"></a> 运行</h2>
<p>开始fuzz，那么afl如何启动这个程序，可以看看<code>afl-fuzz.c</code>，不过最开始后世设置参数，这里将重要点的部分。</p>
<p>调用的链条有点复杂首先在L8044</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skipped_fuzz = fuzz_one(use_argv);</span><br></pre></td></tr></table></figure>
<p>然后的<code>fuzz_one</code>中，使用队列<code>queue_cur</code>来管理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = calibrate_case(argv, queue_cur, in_buf, queue_cycle - <span class="number">1</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>在<code>calibrate_case</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (dumb_mode != <span class="number">1</span> &amp;&amp; !no_forkserver &amp;&amp; !forksrv_pid)</span><br><span class="line">  init_forkserver(argv);</span><br></pre></td></tr></table></figure>
<p>总算是找到了</p>
<blockquote>
<p>为了更高效地进行上述过程，AFL实现了一套fork server机制。其基本思路是：启动target进程后，target会运行一个fork server；fuzzer并不负责fork子进程，而是与这个fork server通信，并由fork server来完成fork及继续执行目标的操作。这样设计的最大好处，就是不需要调用<code>execve()</code>，从而节省了载入目标文件和库、解析符号地址等重复性工作</p>
</blockquote>
<p>L1987</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> st_pipe[<span class="number">2</span>], ctl_pipe[<span class="number">2</span>];</span><br><span class="line">....</span><br><span class="line">forksrv_pid = fork();</span><br></pre></td></tr></table></figure>
<p>使用pipe和forkserver进行通讯</p>
<p>L2088的位置开始执行<code>execv(target_path, argv);</code>。其实看到这里我也很疑惑上面的解释</p>
<p>在L2103中测试和forkserver的通讯</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    fsrv_ctl_fd = ctl_pipe[<span class="number">1</span>];</span><br><span class="line">    fsrv_st_fd  = st_pipe[<span class="number">0</span>];</span><br><span class="line">    rlen = read(fsrv_st_fd, &amp;status, <span class="number">4</span>);</span><br><span class="line">...</span><br><span class="line">  <span class="comment">/* If we have a four-byte &quot;hello&quot; message from the server, we&#x27;re all set.</span></span><br><span class="line"><span class="comment">     Otherwise, try to figure out what went wrong. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (rlen == <span class="number">4</span>) &#123;</span><br><span class="line">    OKF(<span class="string">&quot;All right - fork server is up.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;    </span><br></pre></td></tr></table></figure>
<p>接下来的fork server是如何与fuzzer通信是面试考点（/doge）</p>
<h3 id="forkserver"><a class="markdownIt-Anchor" href="#forkserver"></a> forkserver</h3>
<p>知道创宇不知道是讲的太碎了还是我理解有问题，在这里我就不怎么追的了代码了，不过想起开始说过的：<strong>fuzzer并不负责fork子进程，而是与这个fork server通信，并由fork server来完成fork及继续执行目标的操作</strong>，那么很有可能和插进去的<code>__afl_maybe_log</code>一样是插入入进去了一个<code>forkserver</code>在代码当中，那么回到<code>afl-as</code>，L446</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ins_lines)</span><br><span class="line">  <span class="built_in">fputs</span>(use_64bit ? main_payload_64 : main_payload_32, outf);</span><br></pre></td></tr></table></figure>
<p>依然以32位举例子<code>main_payload_32</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;__afl_forkserver:\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Enter the fork server mode to avoid the overhead of execve() calls. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl %eax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl %ecx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl %edx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Phone home and tell the parent that we&#x27;re OK. (Note that signals with\n&quot;</span></span><br><span class="line">  <span class="string">&quot;     no SA_RESTART will mess it up). If this fails, assume that the fd is\n&quot;</span></span><br><span class="line">  <span class="string">&quot;     closed because we were execve()d from an instrumented binary, or because\n&quot;</span> </span><br><span class="line">  <span class="string">&quot;     the parent doesn&#x27;t want to use the fork server. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $4          /* length    */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $__afl_temp /* data      */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $&quot;</span> STRINGIFY((FORKSRV_FD + <span class="number">1</span>)) <span class="string">&quot;  /* file desc */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  call  write\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  addl  $12, %esp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  cmpl  $4, %eax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  jne   __afl_fork_resume\n&quot;</span></span><br></pre></td></tr></table></figure>
<p>看注释也看的明白了，给fuzzer说已经准备完毕，其中<code>$__afl_temp</code>就是四字节长度的验证信息，然后开始等待循环，读取命令管道，直到fuzzer通知其开始</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;__afl_fork_wait_loop:\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  /* Wait for parent by reading from the pipe. Abort if read fails. */\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  pushl $4          /* length    */\n&quot;</span></span><br><span class="line"><span class="string">&quot;  pushl $__afl_temp /* data      */\n&quot;</span></span><br><span class="line"><span class="string">&quot;  pushl $&quot;</span> STRINGIFY(FORKSRV_FD) <span class="string">&quot;        /* file desc */\n&quot;</span></span><br><span class="line"><span class="string">&quot;  call  read\n&quot;</span></span><br><span class="line"><span class="string">&quot;  addl  $12, %esp\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  cmpl  $4, %eax\n&quot;</span></span><br><span class="line"><span class="string">&quot;  jne   __afl_die\n&quot;</span>      </span><br></pre></td></tr></table></figure>
<p>有错误就寄<code>__afl_die</code>，那么成功的话</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;  /* Once woken up, create a clone of our process. This is an excellent use\n&quot;</span></span><br><span class="line"><span class="string">&quot;     case for syscall(__NR_clone, 0, CLONE_PARENT), but glibc boneheadedly\n&quot;</span></span><br><span class="line"><span class="string">&quot;     caches getpid() results and offers no way to update the value, breaking\n&quot;</span></span><br><span class="line"><span class="string">&quot;     abort(), raise(), and a bunch of other things :-( */\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  call fork\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  cmpl $0, %eax\n&quot;</span></span><br><span class="line"><span class="string">&quot;  jl   __afl_die\n&quot;</span></span><br><span class="line"><span class="string">&quot;  je   __afl_fork_resume\n&quot;</span>        </span><br></pre></td></tr></table></figure>
<p>得到父子进程的ID，对待子进程走到<code>__afl_fork_resume</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;__afl_fork_resume:\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* In child process: close fds, resume execution. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $&quot;</span> STRINGIFY(FORKSRV_FD) <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  call  close\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $&quot;</span> STRINGIFY((FORKSRV_FD + <span class="number">1</span>)) <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  call  close\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  addl  $8, %esp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  popl %edx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  popl %ecx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  popl %eax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  jmp  __afl_store\n&quot;</span></span><br></pre></td></tr></table></figure>
<p>对于大于0的返回值（即父进程）他继续运行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;  /* In parent process: write PID to pipe, then wait for child. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movl  %eax, __afl_fork_pid\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $4              /* length    */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $__afl_fork_pid /* data      */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $&quot;</span> STRINGIFY((FORKSRV_FD + <span class="number">1</span>)) <span class="string">&quot;      /* file desc */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  call  write\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  addl  $12, %esp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $0             /* no flags  */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $__afl_temp    /* status    */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl __afl_fork_pid /* PID       */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  call  waitpid\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  addl  $12, %esp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  cmpl  $0, %eax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  jle   __afl_die\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Relay wait status to pipe, then loop back. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $4          /* length    */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $__afl_temp /* data      */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $&quot;</span> STRINGIFY((FORKSRV_FD + <span class="number">1</span>)) <span class="string">&quot;  /* file desc */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  call  write\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  addl  $12, %esp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  jmp __afl_fork_wait_loop\n&quot;</span>    </span><br></pre></td></tr></table></figure>
<p>继续进行forkserver的管道通讯，然后<code>__afl_fork_wait_loop</code>，</p>
<h3 id="fuzzer"><a class="markdownIt-Anchor" href="#fuzzer"></a> fuzzer</h3>
<p>回顾一下目前“栈”的情况：<code>main</code> -&gt; <code>calibrate_case</code> -&gt; <code>init_forkserver</code></p>
<p><img src="D:%5CPictures%5Ctypora%5Cimage-20230722112212761.png" alt="image-20230722112212761" /></p>
<p>​	回退到<code>calibrate_case</code>继续执行，<code>write_to_testcase</code>就是设置测试样例，重点在于<code>run_target</code>。AFL的文件编译策略不是胡乱变换的，主要是<code>dumb_mode</code>有没有被开启，一般都是不会开启的，那么就来到了L2362</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  s32 res;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* In non-dumb mode, we have the fork server up and running, so simply</span></span><br><span class="line"><span class="comment">     tell it to have at it, and then read back PID. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((res = write(fsrv_ctl_fd, &amp;prev_timed_out, <span class="number">4</span>)) != <span class="number">4</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stop_soon) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    RPFATAL(res, <span class="string">&quot;Unable to request new process from fork server (OOM?)&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((res = read(fsrv_st_fd, &amp;child_pid, <span class="number">4</span>)) != <span class="number">4</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stop_soon) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    RPFATAL(res, <span class="string">&quot;Unable to request new process from fork server (OOM?)&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (child_pid &lt;= <span class="number">0</span>) FATAL(<span class="string">&quot;Fork server is misbehaving (OOM?)&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看注释和代码，知道通过管道向forkserver通知准备完毕，并得到返回的PID，然后就是L2438</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (WIFSIGNALED(status) &amp;&amp; !stop_soon) &#123;</span><br><span class="line"></span><br><span class="line">  kill_signal = WTERMSIG(status);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (child_timed_out &amp;&amp; kill_signal == SIGKILL) <span class="keyword">return</span> FAULT_TMOUT;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> FAULT_CRASH;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>fuzzer再次读取状态管道，获取子进程退出状态，并由此来判断子进程结束的原因，例如正常退出、超时、崩溃等，并进行相应的记录</p>
<h2 id="共享内存机制"><a class="markdownIt-Anchor" href="#共享内存机制"></a> 共享内存机制</h2>
<h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1>
<p><a target="_blank" rel="noopener" href="https://paper.seebug.org/496/">https://paper.seebug.org/496/</a></p>
</div></article><section class="comments"><div id="disqus_thread"></div><script>var disqus_shortname = 'disqus';
(function () {
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//#{theme.disqus}.disqus.com/count.js" async></script></section><div class="pagination"><a class="pagination__link pagination__next" href="/2023/07/19/win-afl2/">next_post</a></div></main><footer class="footer metadata"><p class="footer__text">© 2023 Joe1sn</p><p class="footer__text">Powered by <a class="footer__text__link" href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a class="footer__text__link" href="https://pages.github.com/" target="_blank">Github Page</a></p></footer></div></body></html>