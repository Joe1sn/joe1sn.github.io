<!DOCTYPE html><html lang="zh"><head><meta charset="UTF-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Joe1sn's Cabinet | 【源码分析】MinHook源代码分析</title><meta name="description" content="&lt;p&gt;世界上果然没有魔法，到最后发现都是魔术&lt;/p&gt;
&lt;p&gt;解读的项目地址：&lt;a href=&quot;https://github.com/TsudaKageyu/minhook&quot;&gt;https://github.com/TsudaKageyu/minhook&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;公众号：&lt;a href=&quot;https://mp.weixin.qq.com/s/Po_t-JGj0e3dMBKDd9i8cw&quot;&gt;https://mp.weixin.qq.com/s/Po_t-JGj0e3dMBKDd9i8cw&lt;/a&gt;&lt;/p&gt;"><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700"><link rel="stylesheet" href="/css/highlights/darkula.css"><link rel="stylesheet" href="/css/main.css"><link rel="search" type="application/opensearchdescription+xml" href="https://joe1sn.eu.org/atom.xml" title="Joe1sn's Cabinet"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Joe1sn's Cabinet" type="application/atom+xml">
</head><body><div class="container"><header class="main-header"><h1 class="main-header__title uplize"><a class="main-header__title__link" href="/">Joe1sn's Cabinet</a></h1><nav class="main-header__nav"><ul class="main-nav"><li class="main-nav__list"><a class="main-nav__list__link" href="/" target="_self">HOME</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/archives/" target="_self">ARCHIVE</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="https://github.com/Joe1sn" target="_blank">GITHUB</a></li></ul></nav></header><main class="container__wrapper"><article class="article post"><h3 class="article__title">【源码分析】MinHook源代码分析</h3><div class="article__date metadata"><div class="post-info">2024/07/24</div></div><div class="article__tags metadata">Tags:
<a class="article__tags__link metadata" href="/tags/source/">source</a><a class="article__tags__link metadata" href="/tags/MinHook/">MinHook</a></div><div class="article__body"><p>世界上果然没有魔法，到最后发现都是魔术</p>
<p>解读的项目地址：<a target="_blank" rel="noopener" href="https://github.com/TsudaKageyu/minhook">https://github.com/TsudaKageyu/minhook</a></p>
<p>公众号：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Po_t-JGj0e3dMBKDd9i8cw">https://mp.weixin.qq.com/s/Po_t-JGj0e3dMBKDd9i8cw</a></p>
<span id="more"></span>
<p>或许我们的公众号会有更多你感兴趣的内容</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/a0d42261f5e0b243c214f5af9049fc29.jpg" alt="img" /></p>
<h1 id="p1-hook原理"><a class="markdownIt-Anchor" href="#p1-hook原理"></a> P1. Hook原理</h1>
<p>首先使用Visual Studio中的MSVC编译器，按照Release x64 禁用代码优化 编译如下代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;123\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">hello</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在<code>main</code>函数中的<code>hello()</code>处加上断点（ps:为什么选择了release版本任然能够调试：1.没有antiDebug。2.调式符号依然保存了。3.代码量小,就算开了代码优化也不会有较大影响）</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/96d7730a2e1dc806a77fc5ef76f72aab.png" alt="image-20240724155339931" /></p>
<p>步入<code>call</code>汇编</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/1566587521dcc11bbb6d5d9126c8e574.png" alt="image-20240724155353773" /></p>
<p>这里就是目前编译情况下的<code>hello</code>函数的汇编实现了。</p>
<p><strong>那么我们就可以找到<code>hello</code>函数的地址，然后覆盖他的汇编，让执行流转移到我们创建的新的函数</strong>。所以我们继续写有如下代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;123\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">newhello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;This is New hello\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> jmpopcode[<span class="number">14</span>] = &#123;</span><br><span class="line">        <span class="number">0x68</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xC7</span>, <span class="number">0x44</span>, <span class="number">0x24</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,<span class="number">0x00</span>, <span class="number">0xC3</span></span><br><span class="line">    &#125;;</span><br><span class="line">    DWORD64 oldFuncAddr = <span class="built_in">reinterpret_cast</span>&lt;DWORD64&gt;(hello);</span><br><span class="line">    DWORD64 newFuncAddr = <span class="built_in">reinterpret_cast</span>&lt;DWORD64&gt;(newhello);</span><br><span class="line">    </span><br><span class="line">    DWORD old;</span><br><span class="line">    <span class="built_in">VirtualProtect</span>(hello, <span class="number">15</span>, PAGE_EXECUTE_READWRITE, &amp;old);</span><br><span class="line">    *(DWORD32*)(jmpopcode + <span class="number">1</span>) = (DWORD32)newFuncAddr;</span><br><span class="line">    *(DWORD32*)(jmpopcode + <span class="number">9</span>) = (DWORD32)(newFuncAddr &gt;&gt; <span class="number">32</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(hello, jmpopcode, <span class="number">14</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">hello</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>依然是调用<code>hello()</code>的使用跟进去</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/c904ce64aeb9d288cf86bd7e1a672f1d.png" alt="image-20240724161051582" /></p>
<p>执行到<code>00007FF7FED8100D</code>，会跳转到我们的函数<code>newhello()</code></p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/2716149fcfd3d091c904996de6c2937e.png" alt="image-20240724161136732" /></p>
<p>这样我们就完成了一次hook，<strong>后续无论调用多少次<code>hello</code>函数，都会执行为<code>newhello</code>函数</strong></p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/1a23c14c14305eb30094c0f4de354783.png" alt="image-20240724161944509" /></p>
<p>关于我们这里的代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> jmpopcode[<span class="number">14</span>] = &#123;</span><br><span class="line">        <span class="number">0x68</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xC7</span>, <span class="number">0x44</span>, <span class="number">0x24</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,<span class="number">0x00</span>, <span class="number">0xC3</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">//	...</span></span><br><span class="line"></span><br><span class="line">    *(DWORD32*)(jmpopcode + <span class="number">1</span>) = (DWORD32)newFuncAddr;</span><br><span class="line">    *(DWORD32*)(jmpopcode + <span class="number">9</span>) = (DWORD32)(newFuncAddr &gt;&gt; <span class="number">32</span>);</span><br></pre></td></tr></table></figure>
<p><code>jmpopcode</code>实际上是这样一段汇编代码，假如我们要跳转到<code>0x 20000000 10000000</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push 0x10000000</span><br><span class="line">mov dword [rsp+4], 0x20000000</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>这是在64位下一种特殊的跳转代码，由于<code>jmp</code>指令的限制，只能2GB内内存寻址，到了x64寻址空间大大加大，单纯<code>jmp</code>和<code>call</code>已经无法跳转到地址，所以我们将带跳转的地址依次将低位、高位移动到栈顶（rsp），这样ret就能直接跳转了，这种好处就是不会污染栈和寄存器。</p>
<p>如果在x86（32位）的情况下，直接使用<code>jmp</code>跳转即可</p>
<p>总结一下hook的步骤就是：</p>
<ol>
<li>找到待hook函数的地址</li>
<li>覆盖待hook函数汇编码，让待hook函数跳转到新的函数</li>
<li>取消hook恢复待hook函数的汇编码即可</li>
</ol>
<h1 id="p2-使用minhook"><a class="markdownIt-Anchor" href="#p2-使用minhook"></a> P2. 使用MinHook</h1>
<p>在项目文件夹中，然后再vs中包含</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/TsudaKageyu/minhook</span><br></pre></td></tr></table></figure>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/b6609ede11395995cdce61b89e6f495c.png" alt="image-20240724163342822" /></p>
<p>现在我们使用MinHook来实现P1中的功能</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;minhook/MinHook.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;123\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">newhello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;This is New hello\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	LPVOID *lpOldHello = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="built_in">MH_Initialize</span>();</span><br><span class="line">	<span class="built_in">MH_CreateHook</span>(hello, newhello, lpOldHello);</span><br><span class="line">	<span class="built_in">MH_EnableHook</span>(hello);</span><br><span class="line">	<span class="built_in">hello</span>();</span><br><span class="line">	<span class="built_in">MH_DisableHook</span>(hello);</span><br><span class="line">	<span class="built_in">hello</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/6951a9d4f37ad22436021d7bdcf891e8.png" alt="image-20240724163902834" /></p>
<p>尝试Hook系统函数Sleep</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;minhook/MinHook.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义指向原始 Sleep 函数的指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(WINAPI* Sleep_t)</span><span class="params">(DWORD)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义指向原始 Sleep 函数的指针</span></span><br><span class="line">Sleep_t fpSleep = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义的 MySleep 函数</span></span><br><span class="line"><span class="comment">//  参数要保持一致</span></span><br><span class="line"><span class="function"><span class="type">void</span> WINAPI <span class="title">MySleep</span><span class="params">(DWORD dwMilliseconds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;MySleep called with &quot;</span> &lt;&lt; dwMilliseconds &lt;&lt; <span class="string">&quot; milliseconds&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用原始的 Sleep 函数</span></span><br><span class="line">    <span class="built_in">fpSleep</span>(dwMilliseconds);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">MH_Initialize</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个 Hook</span></span><br><span class="line">    <span class="built_in">MH_CreateHook</span>(Sleep, MySleep, <span class="built_in">reinterpret_cast</span>&lt;LPVOID*&gt;(&amp;fpSleep));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启用 Hook</span></span><br><span class="line">    <span class="built_in">MH_EnableHook</span>(MH_ALL_HOOKS);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理 Hook</span></span><br><span class="line">    <span class="built_in">MH_DisableHook</span>(MH_ALL_HOOKS);</span><br><span class="line">    <span class="built_in">MH_Uninitialize</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/62a3d636d7429cff5a7016be028cbcdb.png" alt="image-20240724165152787" /></p>
<h1 id="p3-代码解读"><a class="markdownIt-Anchor" href="#p3-代码解读"></a> P3. 代码解读</h1>
<p>这里按照Hook Sleep函数的顺序</p>
<h2 id="mh_initialize"><a class="markdownIt-Anchor" href="#mh_initialize"></a> MH_Initialize</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MH_STATUS WINAPI <span class="title">MH_Initialize</span><span class="params">(VOID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MH_STATUS status = MH_OK;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">EnterSpinLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (g_hHeap == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        g_hHeap = <span class="built_in">HeapCreate</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (g_hHeap != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Initialize the internal function buffer.</span></span><br><span class="line">            <span class="built_in">InitializeBuffer</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            status = MH_ERROR_MEMORY_ALLOC;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        status = MH_ERROR_ALREADY_INITIALIZED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LeaveSpinLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>EnterSpinLock：进入自旋锁，避免在多线程的hook中冲突。对应的是LeaveSpinLock</li>
<li>InitializeBuffer：无意义函数</li>
<li>g_hHeap：用于管理g_hooks的句柄，从之前的代码就可以看出来MinHook对于已经hook的函数的取消hook等等的管理一定是有一个全局变量在管理</li>
</ul>
<h2 id="mh_createhook"><a class="markdownIt-Anchor" href="#mh_createhook"></a> MH_CreateHook</h2>
<p>首先是函数的原型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MH_STATUS WINAPI <span class="title">MH_CreateHook</span><span class="params">(LPVOID pTarget, LPVOID pDetour, LPVOID *ppOriginal)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>pTarget：待hook的函数（旧函数）</li>
<li>pDetour：新的函数</li>
<li>ppOriginal：指向旧函数的指针</li>
</ul>
<p>然后检查旧函数和新韩淑的可执行权限，这里又学到一个新的winapi <code>VirtualQuery</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//        if (IsExecutableAddress(pTarget) &amp;&amp; IsExecutableAddress(pDetour))</span></span><br><span class="line"><span class="function">BOOL <span class="title">IsExecutableAddress</span><span class="params">(LPVOID pAddress)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MEMORY_BASIC_INFORMATION mi;</span><br><span class="line">    <span class="built_in">VirtualQuery</span>(pAddress, &amp;mi, <span class="built_in">sizeof</span>(mi));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (mi.State == MEM_COMMIT &amp;&amp; (mi.Protect &amp; PAGE_EXECUTE_FLAGS));</span><br><span class="line">&#125;            </span><br></pre></td></tr></table></figure>
<p>关于<code>VirtualQuery</code>函数：<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/memoryapi/nf-memoryapi-virtualquery">https://learn.microsoft.com/zh-cn/windows/win32/api/memoryapi/nf-memoryapi-virtualquery</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">////////   MH_CreateHook</span></span><br><span class="line">			UINT pos = <span class="built_in">FindHookEntry</span>(pTarget);</span><br><span class="line">            <span class="keyword">if</span> (pos == INVALID_HOOK_POS)</span><br><span class="line">                    </span><br><span class="line"><span class="comment">////////	FindHookEntry</span></span><br><span class="line"><span class="function"><span class="type">static</span> UINT <span class="title">FindHookEntry</span><span class="params">(LPVOID pTarget)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UINT i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g_hooks.size; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ULONG_PTR)pTarget == (ULONG_PTR)g_hooks.pItems[i].pTarget)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> INVALID_HOOK_POS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里开始就有些复杂了，上来就是两个结构体，不过不用担心，因为<code>FindHookEntry</code>中的<code>g_hooks</code>就没有初始化过，所以只能返回错误：<code>INVALID_HOOK_POS</code>，这样就进入了if里面</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">////////   MH_CreateHook</span></span><br><span class="line">				LPVOID pBuffer = <span class="built_in">AllocateBuffer</span>(pTarget);</span><br><span class="line">                <span class="keyword">if</span> (pBuffer != <span class="literal">NULL</span>)</span><br><span class="line">                &#123;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">////////   AllocateBuffer</span></span><br><span class="line"><span class="function">LPVOID <span class="title">AllocateBuffer</span><span class="params">(LPVOID pOrigin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PMEMORY_SLOT  pSlot;</span><br><span class="line">    PMEMORY_BLOCK pBlock = <span class="built_in">GetMemoryBlock</span>(pOrigin);</span><br><span class="line">    <span class="keyword">if</span> (pBlock == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove an unused slot from the list.</span></span><br><span class="line">    pSlot = pBlock-&gt;pFree;</span><br><span class="line">    pBlock-&gt;pFree = pSlot-&gt;pNext;</span><br><span class="line">    pBlock-&gt;usedCount++;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="comment">// Fill the slot with INT3 for debugging.</span></span><br><span class="line">    <span class="built_in">memset</span>(pSlot, <span class="number">0xCC</span>, <span class="built_in">sizeof</span>(MEMORY_SLOT));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> pSlot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///////		GetMemoryBlock 节选</span></span><br><span class="line"><span class="function"><span class="type">static</span> PMEMORY_BLOCK <span class="title">GetMemoryBlock</span><span class="params">(LPVOID pOrigin)</span></span></span><br><span class="line"><span class="function">    <span class="comment">/*....*/</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="keyword">if</span> defined(_M_X64) || defined(__x86_64__)</span></span></span><br><span class="line"><span class="function">    SYSTEM_INFO si</span>;</span><br><span class="line">    <span class="built_in">GetSystemInfo</span>(&amp;si);</span><br><span class="line">    minAddr = (ULONG_PTR)si.lpMinimumApplicationAddress;</span><br><span class="line">    maxAddr = (ULONG_PTR)si.lpMaximumApplicationAddress;</span><br><span class="line">    <span class="comment">/*....*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Look the registered blocks for a reachable one.</span></span><br><span class="line">    <span class="keyword">for</span> (pBlock = g_pMemoryBlocks; pBlock != <span class="literal">NULL</span>; pBlock = pBlock-&gt;pNext)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(_M_X64) || defined(__x86_64__)</span></span><br><span class="line">        <span class="comment">// Ignore the blocks too far.</span></span><br><span class="line">        <span class="keyword">if</span> ((ULONG_PTR)pBlock &lt; minAddr || (ULONG_PTR)pBlock &gt;= maxAddr)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="comment">// The block has at least one unused slot.</span></span><br><span class="line">        <span class="keyword">if</span> (pBlock-&gt;pFree != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> pBlock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>GetSystemInfo</code>：<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/sysinfoapi/nf-sysinfoapi-getsysteminfo">https://learn.microsoft.com/zh-cn/windows/win32/api/sysinfoapi/nf-sysinfoapi-getsysteminfo</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lpMinimumApplicationAddress</span><br></pre></td></tr></table></figure>
<p>指向应用程序和动态链接库可访问的最低内存地址的指针， (DLL) 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lpMaximumApplicationAddress</span><br></pre></td></tr></table></figure>
<p>指向应用程序和 DLL 可访问的最高内存地址的指针。</p>
</li>
<li>
<p>在64位下寻找一块距离参数<code>pOrigin</code>最近的内存地址，作者这里对这种内存自行进行了管理，用的单链表（Windows的内存管理）</p>
</li>
</ul>
<p>接着再回到创建Hook中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pBuffer != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    TRAMPOLINE ct;</span><br><span class="line"></span><br><span class="line">    ct.pTarget     = pTarget;</span><br><span class="line">    ct.pDetour     = pDetour;</span><br><span class="line">    ct.pTrampoline = pBuffer;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">CreateTrampolineFunction</span>(&amp;ct))</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CreateTrampolineFunction</span><span class="params">(PTRAMPOLINE ct)</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="keyword">if</span> defined(_M_X64) || defined(__x86_64__)    </span></span></span><br><span class="line"><span class="function">    CALL_ABS call </span>= &#123;</span><br><span class="line">        <span class="number">0xFF</span>, <span class="number">0x15</span>, <span class="number">0x00000002</span>, <span class="comment">// FF15 00000002: CALL [RIP+8]</span></span><br><span class="line">        <span class="number">0xEB</span>, <span class="number">0x08</span>,             <span class="comment">// EB 08:         JMP +10</span></span><br><span class="line">        <span class="number">0x0000000000000000</span>ULL   <span class="comment">// Absolute destination address</span></span><br><span class="line">    &#125;;</span><br><span class="line">    JMP_ABS jmp = &#123;</span><br><span class="line">        <span class="number">0xFF</span>, <span class="number">0x25</span>, <span class="number">0x00000000</span>, <span class="comment">// FF25 00000000: JMP [RIP+6]</span></span><br><span class="line">        <span class="number">0x0000000000000000</span>ULL   <span class="comment">// Absolute destination address</span></span><br><span class="line">    &#125;;</span><br><span class="line">    JCC_ABS jcc = &#123;</span><br><span class="line">        <span class="number">0x70</span>, <span class="number">0x0E</span>,             <span class="comment">// 7* 0E:         J** +16</span></span><br><span class="line">        <span class="number">0xFF</span>, <span class="number">0x25</span>, <span class="number">0x00000000</span>, <span class="comment">// FF25 00000000: JMP [RIP+6]</span></span><br><span class="line">        <span class="number">0x0000000000000000</span>ULL   <span class="comment">// Absolute destination address</span></span><br><span class="line">    &#125;;    </span><br><span class="line"><span class="comment">/*...*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算汇编指令长度</span></span><br><span class="line">        copySize = <span class="built_in">HDE_DISASM</span>((LPVOID)pOldInst, &amp;hs);</span><br><span class="line">        </span><br><span class="line">	    <span class="comment">/*...*/</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (oldPos &gt;= <span class="built_in">sizeof</span>(JMP_REL))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// The trampoline function is long enough.</span></span><br><span class="line">            <span class="comment">// Complete the function with the jump to the target function.</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(_M_X64) || defined(__x86_64__)</span></span><br><span class="line">            jmp.address = pOldInst;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">            jmp.operand = (UINT32)(pOldInst - (pNewInst + <span class="built_in">sizeof</span>(jmp)));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            pCopySrc = &amp;jmp;</span><br><span class="line">            copySize = <span class="built_in">sizeof</span>(jmp);</span><br><span class="line"></span><br><span class="line">            finished = TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">/*...*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ALLOW_INTRINSICS</span></span><br><span class="line">        <span class="built_in">memcpy</span>((LPBYTE)ct-&gt;pTrampoline + newPos, pCopySrc, copySize);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        __movsb((LPBYTE)ct-&gt;pTrampoline + newPos, (LPBYTE)pCopySrc, copySize);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        newPos += copySize;</span><br><span class="line">        oldPos += hs.len;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!finished);	</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*...*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(_M_X64) || defined(__x86_64__)</span></span><br><span class="line">    <span class="comment">// Create a relay function.</span></span><br><span class="line">    jmp.address = (ULONG_PTR)ct-&gt;pDetour;</span><br><span class="line"></span><br><span class="line">    ct-&gt;pRelay = (LPBYTE)ct-&gt;pTrampoline + newPos;</span><br><span class="line">    <span class="built_in">memcpy</span>(ct-&gt;pRelay, &amp;jmp, <span class="built_in">sizeof</span>(jmp));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>HDE_DISASM</code>：跟进去是解析汇编指令，计算出当前函数的汇编指令长度。使用的是作者改进过的<code>Hacker Disassembler Engine 64</code>，看了下版权信息还挺古早的</li>
<li><code>pCopySrc</code>：如果相差很近，能使用<code>jmp</code>则使用<code>jmp</code>，根据条件得到对应的跳转指令</li>
<li><code>ct-&gt;pRelay</code>：存放跳转的指令</li>
</ul>
<p>这边感觉作者写的有点复杂，不过确实是好用的，解析反汇编的方法又学到一些，这里看不懂的可以看看后面的动调的解释</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">////////   MH_CreateHook</span></span><br><span class="line">        PHOOK_ENTRY pHook = <span class="built_in">AddHookEntry</span>();</span><br><span class="line">        <span class="keyword">if</span> (pHook != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">memcpy</span>(pHook-&gt;oldIPs, ct.oldIPs, <span class="built_in">ARRAYSIZE</span>(ct.oldIPs));</span><br><span class="line">            <span class="built_in">memcpy</span>(pHook-&gt;newIPs, ct.newIPs, <span class="built_in">ARRAYSIZE</span>(ct.newIPs));</span><br></pre></td></tr></table></figure>
<p>这里就存储计算出的指令和原始汇编，便于后续启用hook的时候使用<br />
这里的<code>AddHookEntry</code>的时候就已经将返回地<code>pHook</code>加入到<code>g_hook</code>中管理了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">////////   MH_CreateHook</span></span><br><span class="line">		<span class="keyword">if</span> (ct.patchAbove)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(</span><br><span class="line">                pHook-&gt;backup,</span><br><span class="line">                (LPBYTE)pTarget - <span class="built_in">sizeof</span>(JMP_REL),</span><br><span class="line">                <span class="built_in">sizeof</span>(JMP_REL) + <span class="built_in">sizeof</span>(JMP_REL_SHORT));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(pHook-&gt;backup, pTarget, <span class="built_in">sizeof</span>(JMP_REL));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ppOriginal != <span class="literal">NULL</span>)</span><br><span class="line">            *ppOriginal = pHook-&gt;pTrampoline;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/f3362dda366faccd859c9ca71a309e89.png" alt="image-20240724181309357" /></p>
<p><strong>pHook-&gt;pTrampoline</strong>：这里指向的是旧的Sleep的jmp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00007FFAD228B0B0  jmp         qword ptr [7FFAD22F0A10h]  </span><br></pre></td></tr></table></figure>
<p>hook的时候变了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00007FFAD228B0B0  jmp         00007FFAD2260FC7</span><br></pre></td></tr></table></figure>
<p>但是要hook的地址不是jmp呢？这里用到最开始的hello的例子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;minhook/MinHook.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*myhello)</span><span class="params">()</span></span>;</span><br><span class="line">myhello lpOldHello = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;123\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">newhello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;This is New hello\n&quot;</span>;</span><br><span class="line">	<span class="built_in">reinterpret_cast</span>&lt;myhello&gt;(lpOldHello)();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">hello</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">MH_Initialize</span>();</span><br><span class="line">	<span class="built_in">MH_CreateHook</span>(hello, newhello, <span class="built_in">reinterpret_cast</span>&lt;LPVOID*&gt;(&amp;lpOldHello));</span><br><span class="line">	<span class="built_in">MH_EnableHook</span>(hello);</span><br><span class="line">	<span class="built_in">hello</span>();</span><br><span class="line">	<span class="built_in">MH_DisableHook</span>(hello);</span><br><span class="line">	<span class="built_in">hello</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正常调用<code>hello</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00007FF7F1953E64  call        hello (07FF7F1953E10h)  </span><br><span class="line"></span><br><span class="line">void hello() &#123;</span><br><span class="line">00007FF7F1953E10  sub         rsp,28h</span><br></pre></td></tr></table></figure>
<p>hook过后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00007FF6D2C13E47  call        qword ptr [lpOldHello (07FF6D2C18898h)] </span><br><span class="line"></span><br><span class="line">void hello() &#123;</span><br><span class="line">00007FF7F1953E10  jmp         00007FF7F1940FD9  </span><br></pre></td></tr></table></figure>
<p>在hook中调用原始函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00007FF7F1953E47  call        qword ptr [lpOldHello (07FF7F1958898h)]</span><br><span class="line"></span><br><span class="line">00007FF7F1940FC0  sub         rsp,28h  </span><br><span class="line">00007FF7F1940FC4  lea         rdx,[__xmm@ffffffffffffffffffffffffffffffff+10h (07FF7F1956370h)]  </span><br><span class="line">00007FF7F1940FCB  jmp         qword ptr [7FF7F1940FD1h] </span><br><span class="line"></span><br><span class="line">00007FF7F1953E22  call        std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; (07FF7F1953F40h) </span><br></pre></td></tr></table></figure>
<p>这里就已经说明的很清楚了，<strong>我们覆盖前几个字节会污染汇编指令，MinHook会把收到污染的汇编指令复制到一个地方A，A的尾部跳转到原有函数中没有收到污染的部分。</strong></p>
<p><strong>启用hook后修改原始函数的指针到A，这样A执行完后就会执行原函数没有污染的部分</strong></p>
<h2 id="mh_enablehook-enablehook"><a class="markdownIt-Anchor" href="#mh_enablehook-enablehook"></a> MH_EnableHook || EnableHook</h2>
<p>其实调用的是<code>EnableHook</code>，参数为true</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (g_hooks.pItems[pos].isEnabled != enable)</span><br><span class="line">&#123;</span><br><span class="line">    FROZEN_THREADS threads;</span><br><span class="line">    status = <span class="built_in">Freeze</span>(&amp;threads, pos, ACTION_ENABLE);</span><br><span class="line">    <span class="keyword">if</span> (status == MH_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        status = <span class="built_in">EnableHookLL</span>(pos, enable);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Unfreeze</span>(&amp;threads);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>EnableHookLL：不管是不是启用全部hook，最终都会来到这里</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">LPBYTE pPatchTarget = (LPBYTE)pHook-&gt;pTarget;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">VirtualProtect</span>(pPatchTarget, patchSize, PAGE_EXECUTE_READWRITE, &amp;oldProtect))</span><br><span class="line">    <span class="keyword">return</span> MH_ERROR_MEMORY_PROTECT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (enable)</span><br><span class="line">&#123;</span><br><span class="line">    PJMP_REL pJmp = (PJMP_REL)pPatchTarget;</span><br><span class="line">    pJmp-&gt;opcode = <span class="number">0xE9</span>;</span><br><span class="line">    pJmp-&gt;operand = (UINT32)((LPBYTE)pHook-&gt;pDetour - (pPatchTarget + <span class="built_in">sizeof</span>(JMP_REL)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pHook-&gt;patchAbove)</span><br><span class="line">    &#123;</span><br><span class="line">        PJMP_REL_SHORT pShortJmp = (PJMP_REL_SHORT)pHook-&gt;pTarget;</span><br><span class="line">        pShortJmp-&gt;opcode = <span class="number">0xEB</span>;</span><br><span class="line">        pShortJmp-&gt;operand = (UINT8)(<span class="number">0</span> - (<span class="built_in">sizeof</span>(JMP_REL_SHORT) + <span class="built_in">sizeof</span>(JMP_REL)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>首先确保有足够权限，然后转为<code>PJMP_REL</code>类型的结构体，通过该结构体修改位对应的<code>jmp</code>跳转</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/fecdbf44839af6ff24e2c61e4aabea63.png" alt="image-20240724184129018" /></p>
<p>第一次jmp后的地址还有一个jmp到指针，这里的指令就是<code>MH_CreateHook</code>时创造出来的</p>
<p>后续的就是取消hook和释放一些全局变量，取消hook用到的是<code>EnableHook</code>，参数为false，因为两个都需要修改函数的汇编指令码。</p>
</div></article><section class="comments"><div id="disqus_thread"></div><script>var disqus_shortname = 'disqus';
(function () {
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//#{theme.disqus}.disqus.com/count.js" async></script></section><div class="pagination"><a class="pagination__link pagination__prev" href="/2024/10/01/dll-inject/">prev_post</a><a class="pagination__link pagination__next" href="/2024/06/01/crackme-cs2-entity-controller/">next_post</a></div></main><footer class="footer metadata"><p class="footer__text">© 2025 Joe1sn</p><p class="footer__text">Powered by <a class="footer__text__link" href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a class="footer__text__link" href="https://pages.github.com/" target="_blank">Github Page</a></p></footer></div></body></html>