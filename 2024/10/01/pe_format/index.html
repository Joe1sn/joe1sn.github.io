<!DOCTYPE html><html lang="zh"><head><meta charset="UTF-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Joe1sn's Cabinet | 【免杀】PE文件格式解析</title><meta name="description" content="&lt;p&gt;公众号：&lt;a href=&quot;https://mp.weixin.qq.com/s/RrEZJDeKXdVqtjZPDs7AyQ&quot;&gt;https://mp.weixin.qq.com/s/RrEZJDeKXdVqtjZPDs7AyQ&lt;/a&gt;&lt;/p&gt;"><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700"><link rel="stylesheet" href="/css/highlights/darkula.css"><link rel="stylesheet" href="/css/main.css"><link rel="search" type="application/opensearchdescription+xml" href="https://joe1sn.eu.org/atom.xml" title="Joe1sn's Cabinet"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Joe1sn's Cabinet" type="application/atom+xml">
</head><body><div class="container"><header class="main-header"><h1 class="main-header__title uplize"><a class="main-header__title__link" href="/">Joe1sn's Cabinet</a></h1><nav class="main-header__nav"><ul class="main-nav"><li class="main-nav__list"><a class="main-nav__list__link" href="/" target="_self">HOME</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/archives/" target="_self">ARCHIVE</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="https://github.com/Joe1sn" target="_blank">GITHUB</a></li></ul></nav></header><main class="container__wrapper"><article class="article post"><h3 class="article__title">【免杀】PE文件格式解析</h3><div class="article__date metadata"><div class="post-info">2024/10/01</div></div><div class="article__tags metadata">Tags:
<a class="article__tags__link metadata" href="/tags/bypass/">bypass</a></div><div class="article__body"><p>公众号：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/RrEZJDeKXdVqtjZPDs7AyQ">https://mp.weixin.qq.com/s/RrEZJDeKXdVqtjZPDs7AyQ</a></p>
<span id="more"></span>
<p>或许我们的公众号会有更多你感兴趣的内容</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/a0d42261f5e0b243c214f5af9049fc29.jpg" alt="img" /></p>
<h1 id="pe文件格式解析"><a class="markdownIt-Anchor" href="#pe文件格式解析"></a> PE文件格式解析</h1>
<p>假如说我们要自己写一个exe文件的加载器，或者你曾好奇过反汇编软件的原理，这就需要对exe对应的PE(Portable Executable)文件格式加以理解。这里以windows10中自带的notepad.exe进行讲解。</p>
<p>​	这里：<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/debug/pe-format">https://learn.microsoft.com/zh-cn/windows/win32/debug/pe-format</a><br />
是微软官方对PE格式的官方文档，读者可自行了解。</p>
<h2 id="如何确定是一个pe文件-dos头"><a class="markdownIt-Anchor" href="#如何确定是一个pe文件-dos头"></a> 如何确定是一个PE文件-DOS头</h2>
<p>对于一个PE文件，首先是他的文件头，也叫DOS 头，结构体定义如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_DOS_HEADER &#123;      // DOS .EXE header</span><br><span class="line">    WORD   e_magic;                     // Magic number</span><br><span class="line">	//....</span><br><span class="line">    LONG   e_lfanew;                    // File address of new exe header</span><br><span class="line">  &#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>e_magic</code>：魔数，如果为<code>MZ</code>这个值说明DOS头正确</li>
<li><code>e_lfanew</code>：指向下一个头，即<code>NT</code>头的位置，计算方式：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>T</mi><mi mathvariant="normal">_</mi><mi>H</mi><mi>E</mi><mi>A</mi><mi>D</mi><mi>E</mi><mi>R</mi><mo>=</mo><mi>F</mi><mi>i</mi><mi>l</mi><mi>e</mi><mi>S</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi><mo>+</mo><mi>e</mi><mi mathvariant="normal">_</mi><mi>l</mi><mi>f</mi><mi>a</mi><mi>n</mi><mi>e</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">NT\_HEADER = FileStart+e\_lfanew</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.99333em;vertical-align:-0.31em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord mathnormal">e</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">a</span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span></li>
</ul>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250103095435314.png" alt="image-20250103095435314" /></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> filePath = <span class="string">&quot;notepad.exe&quot;</span>;</span><br><span class="line"><span class="built_in">std</span>::ifstream <span class="title function_">inputFile</span><span class="params">(filePath, <span class="built_in">std</span>::ios::in | <span class="built_in">std</span>::ios::binary)</span>;</span><br><span class="line"><span class="keyword">if</span> (!inputFile.is_open()) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;cant open: &quot;</span> &lt;&lt; filePath &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">ostringstream</span> peFileString;</span><br><span class="line">peFileString &lt;&lt; inputFile.rdbuf();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> fileContent = peFileString.str();</span><br><span class="line">inputFile.close();</span><br><span class="line"></span><br><span class="line">IMAGE_DOS_HEADER* dosHeader = \</span><br><span class="line">    (PIMAGE_DOS_HEADER)(DWORD64)(&amp;fileContent[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::hex;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;PE e_magic  : 0x&quot;</span> &lt;&lt; dosHeader-&gt;e_magic &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;PE e_lfanew : 0x&quot;</span> &lt;&lt; dosHeader-&gt;e_lfanew &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure>
<h2 id="如何判断程序位数找到代码段等"><a class="markdownIt-Anchor" href="#如何判断程序位数找到代码段等"></a> 如何判断程序位数,找到代码段等</h2>
<p>上面说到我们通过<code>e_lfanew</code>找到了<code>NT Header</code>，这里我们先假设他是一个64位程序的PE文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS64</span> &#123;</span></span><br><span class="line">    DWORD Signature;					<span class="comment">//标签，说明这是NT头</span></span><br><span class="line">    IMAGE_FILE_HEADER FileHeader;		<span class="comment">//文件头,重要</span></span><br><span class="line">    IMAGE_OPTIONAL_HEADER64 OptionalHeader;	<span class="comment">//可选项头</span></span><br><span class="line">&#125; IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;</span><br></pre></td></tr></table></figure>
<p>这里主要功能是通过<code>FileHeader</code>来实现的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_FILE_HEADER</span> &#123;</span></span><br><span class="line">    WORD    Machine;</span><br><span class="line">    WORD    NumberOfSections;</span><br><span class="line">    DWORD   TimeDateStamp;</span><br><span class="line">    DWORD   PointerToSymbolTable;</span><br><span class="line">    DWORD   NumberOfSymbols;</span><br><span class="line">    WORD    SizeOfOptionalHeader;</span><br><span class="line">    WORD    Characteristics;</span><br><span class="line">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure>
<h3 id="判断程序位数-nt头"><a class="markdownIt-Anchor" href="#判断程序位数-nt头"></a> 判断程序位数-NT头</h3>
<p>首先，使用<code>IMAGE_FILE_HEADER.Machine</code>可以很轻松的判断</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IMAGE_NT_HEADERS64* ntTempHeader = \</span><br><span class="line">    (PIMAGE_NT_HEADERS64)(DWORD64)(&amp;fileContent[dosHeader-&gt;e_lfanew]);</span><br><span class="line"><span class="built_in">SetConsoleOutputCP</span>(CP_UTF8);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;程序位数    : &quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (ntTempHeader-&gt;FileHeader.Machine == <span class="number">0x8664</span>)</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;64位\n&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ntTempHeader-&gt;FileHeader.Machine == <span class="number">0x014c</span>)</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;32位\n&quot;</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250103100814694.png" alt="image-20250103100814694" /></p>
<p>更多架构的类型说明在：<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/debug/pe-format#machine-types">https://learn.microsoft.com/zh-cn/windows/win32/debug/pe-format#machine-types</a></p>
<h3 id="解析代码段-段头部"><a class="markdownIt-Anchor" href="#解析代码段-段头部"></a> 解析代码段-段头部</h3>
<p>这里由于已知是64位程序继续按照64位的讲下去</p>
<ol>
<li>使用<code>IMAGE_FILE_HEADER.NumberOfSections</code>获得区段数量</li>
<li>找到各个<code>section</code>的位置，计算公式：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>N</mi><mi>T</mi><mi mathvariant="normal">_</mi><mi>H</mi><mi>E</mi><mi>A</mi><mi>D</mi><mi>E</mi><mi>R</mi><mo>+</mo><mi>n</mi><mi>t</mi><mi>H</mi><mi>e</mi><mi>a</mi><mi>d</mi><mi>S</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo>+</mo><mi>i</mi><mo>∗</mo><mi>s</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mi>H</mi><mi>e</mi><mi>a</mi><mi>d</mi><mi>S</mi><mi>i</mi><mi>z</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">section[i]=NT\_HEADER+ntHeadSize+i*sectionHeadSize</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">e</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.99333em;vertical-align:-0.31em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">e</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mord mathnormal">e</span></span></span></span></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;区段数量: &quot;</span> &lt;&lt; ntTempHeader-&gt;FileHeader.NumberOfSections &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="type">int</span> nt_head_file_start = dosHeader-&gt;e_lfanew;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; ntTempHeader-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; Section[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] address: 0x&quot;</span> &lt;&lt; </span><br><span class="line">        nt_head_file_start \</span><br><span class="line">        + <span class="keyword">sizeof</span>(IMAGE_NT_HEADERS64) \</span><br><span class="line">        + i * <span class="title function_">sizeof</span><span class="params">(IMAGE_SECTION_HEADER)</span> </span><br><span class="line">        &lt;&lt; &quot;\n&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250103101928624.png" alt="image-20250103101928624" /></p>
<p>再对每个<code>IMAGE_SECTION_HEADER</code>进行解析就能得到相关信息</p>
<p>那么关于<code>IMAGE_SECTION_HEADER</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_SECTION_HEADER</span> &#123;</span></span><br><span class="line">    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">            DWORD   PhysicalAddress;</span><br><span class="line">            DWORD   VirtualSize;</span><br><span class="line">    &#125; Misc;</span><br><span class="line">    DWORD   VirtualAddress;</span><br><span class="line">    DWORD   SizeOfRawData;</span><br><span class="line">    DWORD   PointerToRawData;</span><br><span class="line">    DWORD   PointerToRelocations;</span><br><span class="line">    DWORD   PointerToLinenumbers;</span><br><span class="line">    WORD    NumberOfRelocations;</span><br><span class="line">    WORD    NumberOfLinenumbers;</span><br><span class="line">    DWORD   Characteristics;</span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure>
<p>这里来到第一个难点：<code>VirtualAddress</code>，简称 <strong>VA</strong>，这里用<code>.text</code>段也即第一个section来探索</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> nt_head_file_start = dosHeader-&gt;e_lfanew;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; ntTempHeader-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">&#123;</span><br><span class="line">    DWORD64 sectionFileAddr = \</span><br><span class="line">        nt_head_file_start \</span><br><span class="line">        + <span class="built_in">sizeof</span>(IMAGE_NT_HEADERS64) \</span><br><span class="line">        + i * <span class="built_in">sizeof</span>(IMAGE_SECTION_HEADER);</span><br><span class="line">    </span><br><span class="line">    IMAGE_SECTION_HEADER* sectionHeader = \</span><br><span class="line">        (PIMAGE_SECTION_HEADER)(DWORD64)(&amp;fileContent[sectionFileAddr]);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; Section[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] address: 0x&quot;</span> &lt;&lt; \</span><br><span class="line">        sectionFileAddr &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;   Section[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] name : &quot;</span> &lt;&lt; \</span><br><span class="line">        sectionHeader-&gt;Name &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;   Section[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] VA   : &quot;</span> &lt;&lt; \</span><br><span class="line">        sectionHeader-&gt;VirtualAddress &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250103104342974.png" alt="image-20250103104342974" /></p>
<p>在CFF Explorer中，这些区段的低位和我们解析的地址是相同的，说明：<strong>VA是程序运行后，相对于rebase的偏移</strong>，在微软的文档中是这样说明的：</p>
<blockquote>
<p>加载到内存中的节的第一个字节的地址，相对于映像基。 对于对象文件，这是应用重定位之前第一个字节的地址。</p>
</blockquote>
<p>同样的<code>VirtualSize</code>选项可以得到改区段的大小，从而得到区段结束位置</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Misc.VirtualSize</span><br></pre></td></tr></table></figure>
<p>加载到内存中的节的总大小（以字节为单位）。 如果此值大于 <strong>SizeOfRawData</strong> 成员，则节将填充零。 此字段仅对可执行映像有效，对于对象文件，应设置为 0。</p>
</blockquote>
<p>利用在<code>IMAGE_SECTION_HEADER</code>中有一个<code>PointerToRawData</code>可以找到相关数据在文件中的位置，</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>i</mi><mi>l</mi><mi>e</mi><mi>A</mi><mi>d</mi><mi>d</mi><mi>r</mi><mo>=</mo><mi>s</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mi mathvariant="normal">.</mi><mi>P</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>T</mi><mi>o</mi><mi>R</mi><mi>a</mi><mi>w</mi><mi>D</mi><mi>a</mi><mi>t</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">FileAddr=section.PointerToRawData</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">A</span><span class="mord mathnormal">d</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">e</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">o</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span></span></span></span>，就是直接从文件最开始相加就得到位置了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;区段数量: &quot;</span> &lt;&lt; ntTempHeader-&gt;FileHeader.NumberOfSections &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="type">int</span> nt_head_file_start = dosHeader-&gt;e_lfanew;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; ntTempHeader-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">&#123;</span><br><span class="line">    DWORD64 sectionFileAddr = nt_head_file_start + <span class="built_in">sizeof</span>(IMAGE_NT_HEADERS64) + i * <span class="built_in">sizeof</span>(IMAGE_SECTION_HEADER);</span><br><span class="line">    IMAGE_SECTION_HEADER* sectionHeader = (PIMAGE_SECTION_HEADER)(DWORD64)(&amp;fileContent[sectionFileAddr]);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; Section[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] address: 0x&quot;</span> &lt;&lt; sectionFileAddr &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;            name        : &quot;</span> &lt;&lt; sectionHeader-&gt;Name &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;            VA          : 0x&quot;</span> &lt;&lt; sectionHeader-&gt;VirtualAddress &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;            ptr2RawData : 0x&quot;</span> &lt;&lt; sectionHeader-&gt;PointerToRawData &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250103113642421.png" alt="image-20250103113642421" /></p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151302092.png" alt="image-20250103113625530" /></p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151309430.png" alt="image-20250103113815257" /></p>
<h2 id="如何找到导入的函数和dll-导入表"><a class="markdownIt-Anchor" href="#如何找到导入的函数和dll-导入表"></a> 如何找到导入的函数和DLL-导入表</h2>
<p>在编程中会使用到其他dll文件的函数，例如<code>kernel.dll</code>、<code>CRuntimeLib.dll</code>，PE文件通过一个导入目录（<strong>IAT</strong>）进行索引</p>
<p>在编写程序时，我们往往需要在程序中内置部分资源，甚至在上述的section遍历中我们也发现了许多的section，每一个不同的section都会存储不同类型的数据，比如</p>
<ul>
<li>代码段：包含可执行的程序代码。</li>
<li>数据段：包含初始化数据。</li>
<li>导入表：指定外部符号，告诉操作系统需要哪些外部函数。</li>
<li>导出表：列出了程序导出的函数，供其他程序调用。</li>
<li>资源表：包含程序使用的各种资源，如图标、对话框、字符串等。</li>
</ul>
<p>回到一开始 NT头的<code>OptionalHeader</code>部分</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER64</span> &#123;</span></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">    DWORD       AddressOfEntryPoint;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>AddressOfEntryPoint</code>：指向入口点函数（相对于图像基址）的指针</li>
<li><code>DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]</code>：指向数据目录中第一 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winnt/ns-winnt-image_data_directory">个IMAGE_DATA_DIRECTORY</a> 结构的指针</li>
</ul>
<p><code>DataDirectory</code> 存储了这些不同区域在文件中的位置和大小，因此它是一个“目录”或“索引”，指示每个数据段的位置。关于具体类型在该数组下的取值可以参考：<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/winnt/ns-winnt-image_optional_header32">https://learn.microsoft.com/zh-cn/windows/win32/api/winnt/ns-winnt-image_optional_header32</a></p>
<p>具体的<code>IMAGE_DATA_DIRECTORY</code>结构体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DATA_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD   VirtualAddress;</span><br><span class="line">    DWORD   Size;</span><br><span class="line">&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;</span><br></pre></td></tr></table></figure>
<p>选择几个查看一下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;---OptionalHeader.DataDirectories\n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;基本重定位表           : 0x&quot;</span> &lt;&lt; ntTempHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;全局指针的相对虚拟地址   : 0x&quot;</span> &lt;&lt; ntTempHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_GLOBALPTR].VirtualAddress &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;导入地址表             : 0x&quot;</span> &lt;&lt; ntTempHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151315999.png" alt="image-20250103111009787" /></p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151319181.png" alt="image-20250103120523637" /></p>
<p>**注意：**这里的<code>IMAGE_DIRECTORY_ENTRY_IAT</code>和<code>IMAGE_DIRECTORY_ENTRY_IMPORT</code>是两个东西</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151323839.png" alt="image-20250103125031177" /></p>
<p><strong>后续使用的是<code>IMAGE_DIRECTORY_ENTRY_IMPORT</code></strong></p>
<p>貌似依然是在内存中的虚拟地址，我们姑且将其称为<code>DVA</code>（datadirectory virtual adresss）。</p>
<p>那么如何通过<code>IMAGE_OPTIONAL_HEADER64</code>找到IAT呢？首先<code>IAT</code>的相关信息是一定存在文件中的，就不可避免地要计算偏移，将这个偏移设置为<code>RVA</code></p>
<p>结合<code>IMAGE_SECTION_HEADER</code>中有一个<code>PointerToRawData</code></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>V</mi><mi>A</mi><mo>=</mo><mi>D</mi><mi>V</mi><mi>A</mi><mo>−</mo><mi>V</mi><mi>A</mi><mo>+</mo><mi>P</mi><mi>t</mi><mi>r</mi><mi>T</mi><mi>o</mi><mi>R</mi><mi>a</mi><mi>w</mi><mi>D</mi><mi>a</mi><mi>t</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">RVA=DVA-VA+PtrToRawData</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span></span></span></span></p>
<p>这里以导入地址表为例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DWORD64 iatDVA = ntTempHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;</span><br><span class="line"></span><br><span class="line">DWORD64 iatVA = <span class="number">0</span>;</span><br><span class="line">DWORD64 iatRVA = <span class="number">0</span>;</span><br><span class="line">DWORD64 sectionFileAddr;</span><br><span class="line">IMAGE_SECTION_HEADER* sectionHeader;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; ntTempHeader-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">&#123;</span><br><span class="line">    sectionFileAddr = nt_head_file_start + <span class="built_in">sizeof</span>(IMAGE_NT_HEADERS64) + i * <span class="built_in">sizeof</span>(IMAGE_SECTION_HEADER);</span><br><span class="line">    sectionHeader = (PIMAGE_SECTION_HEADER)(DWORD64)(&amp;fileContent[sectionFileAddr]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sectionHeader-&gt;VirtualAddress &gt; iatDVA)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    iatVA = sectionHeader-&gt;VirtualAddress;</span><br><span class="line">    iatRVA = iatDVA - iatVA + sectionHeader-&gt;PointerToRawData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>如何使用RVA？</strong></p>
<p>RVA就是从文件开始IAT的基地址，所有<code>IMAGE_IMPORT_DESCRIPTOR</code>结构体都是从此开始找的。但是并没有相关变量说明了总数，那么只能依靠<code>IMAGE_IMPORT_DESCRIPTOR</code>的变量名来查找了，自然想到的就是Name为0就退出</p>
<p>对于<code>IMAGE_IMPORT_DESCRIPTOR</code>结构体</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        DWORD   Characteristics;            <span class="comment">// 0 for terminating null import descriptor</span></span><br><span class="line">        DWORD   OriginalFirstThunk;         <span class="comment">// RVA to original unbound IAT (PIMAGE_THUNK_DATA)</span></span><br><span class="line">    &#125; DUMMYUNIONNAME;</span><br><span class="line">    DWORD   TimeDateStamp; </span><br><span class="line">    DWORD   ForwarderChain;                 <span class="comment">// -1 if no forwarders</span></span><br><span class="line">    DWORD   Name;</span><br><span class="line">    DWORD   FirstThunk;                     <span class="comment">// RVA to IAT (if bound this IAT has actual addresses)</span></span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure>
<p>那么想办法打印<code>IMAGE_IMPORT_DESCRIPTOR</code>的结构体名称，可以由公式<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>a</mi><mi>m</mi><mi>e</mi><mi>O</mi><mi>f</mi><mi>f</mi><mi>s</mi><mi>e</mi><mi>t</mi><mo>=</mo><mi>N</mi><mi>a</mi><mi>m</mi><mi>e</mi><mo>−</mo><mi>V</mi><mi>A</mi><mo>+</mo><mi>P</mi><mi>t</mi><mi>r</mi><mi>T</mi><mi>o</mi><mi>R</mi><mi>a</mi><mi>w</mi><mi>D</mi><mi>a</mi><mi>t</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">NameOffset = Name -VA+PtrToRawData</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal">a</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">s</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal">a</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span></span></span></span>，**这个公式很重要，**直接打印文件<code>NameOffset</code>偏移的数据即可</p>
<p>首先重新编写从VA到RVA的函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD64 <span class="title">dwVAToRVA</span><span class="params">(DWORD64 StartVA, DWORD64 nt_head_file_start, std::string&amp; fileContent, PIMAGE_NT_HEADERS64 ntTempHeader)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    DWORD64 iatDVA = StartVA;</span><br><span class="line"></span><br><span class="line">    DWORD64 iatVA = <span class="number">0</span>;</span><br><span class="line">    DWORD64 RVA = <span class="number">0</span>;</span><br><span class="line">    DWORD64 sectionFileAddr;</span><br><span class="line">    IMAGE_SECTION_HEADER* sectionHeader;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; ntTempHeader-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sectionFileAddr = nt_head_file_start + <span class="built_in">sizeof</span>(IMAGE_NT_HEADERS64) + i * <span class="built_in">sizeof</span>(IMAGE_SECTION_HEADER);</span><br><span class="line">        sectionHeader = (PIMAGE_SECTION_HEADER)(DWORD64)(&amp;fileContent[sectionFileAddr]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sectionHeader-&gt;VirtualAddress &gt; iatDVA)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        iatVA = sectionHeader-&gt;VirtualAddress;</span><br><span class="line">        RVA = iatDVA - iatVA + sectionHeader-&gt;PointerToRawData;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> RVA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在main函数中打印</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">PIMAGE_IMPORT_DESCRIPTOR temp = <span class="built_in">PIMAGE_IMPORT_DESCRIPTOR</span>((DWORD64)&amp;fileContent[<span class="number">0</span>] + iatRVA + i * <span class="built_in">sizeof</span>(IMAGE_IMPORT_DESCRIPTOR));</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; temp-&gt;Name != <span class="number">0</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    DWORD64 VA = <span class="built_in">dwVAToRVA</span>(temp-&gt;Name, nt_head_file_start, fileContent, ntTempHeader);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;  DLL: &quot;</span> &lt;&lt; (<span class="type">char</span>*)(&amp;fileContent[VA]) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    temp = <span class="built_in">PIMAGE_IMPORT_DESCRIPTOR</span>(&amp;fileContent[<span class="number">0</span>] + iatRVA + i * <span class="built_in">sizeof</span>(IMAGE_IMPORT_DESCRIPTOR));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151330424.png" alt="image-20250103132758136" /></p>
<p>同理，<code>IMAGE_IMPORT_DESCRIPTOR</code>中的<code>FirstThunk</code>也可以用于打印导入的函数名，也是将<code>FirstThunk</code>转为RVA，然后直接在源文件中查找RVA位置的字符串即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">PIMAGE_IMPORT_DESCRIPTOR temp = <span class="built_in">PIMAGE_IMPORT_DESCRIPTOR</span>((DWORD64)&amp;fileContent[<span class="number">0</span>] + iatRVA + i * <span class="built_in">sizeof</span>(IMAGE_IMPORT_DESCRIPTOR));</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; temp-&gt;Name != <span class="number">0</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    DWORD64 VA = <span class="built_in">dwVAToRVA</span>(temp-&gt;Name, nt_head_file_start, fileContent, ntTempHeader);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;  DLL: &quot;</span> &lt;&lt; (<span class="type">char</span>*)(&amp;fileContent[VA]) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    VA = *<span class="built_in">PDWORD64</span>(&amp;fileContent[<span class="number">0</span>] + <span class="built_in">dwVAToRVA</span>(temp-&gt;FirstThunk, nt_head_file_start, fileContent, ntTempHeader));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; VA != <span class="number">0</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        PIMAGE_IMPORT_BY_NAME IatName = <span class="built_in">PIMAGE_IMPORT_BY_NAME</span>(&amp;fileContent[<span class="number">0</span>] + <span class="built_in">dwVAToRVA</span>(VA, nt_head_file_start, fileContent, ntTempHeader));</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;    -Function &quot;</span> &lt;&lt; IatName-&gt;Name &lt;&lt; std::endl;</span><br><span class="line">        VA = *<span class="built_in">PDWORD64</span>(&amp;fileContent[<span class="number">0</span>] + <span class="built_in">dwVAToRVA</span>(temp-&gt;FirstThunk, nt_head_file_start, fileContent, ntTempHeader) + i * <span class="built_in">sizeof</span>(DWORD64));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    temp = <span class="built_in">PIMAGE_IMPORT_DESCRIPTOR</span>(&amp;fileContent[<span class="number">0</span>] + iatRVA + i * <span class="built_in">sizeof</span>(IMAGE_IMPORT_DESCRIPTOR));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/20250227151337251.png" alt="image-20250103133415024" /></p>
<p>其他类型的<code>IMAGE_DATA_DIRECTORY</code>也是使用类似的方法就可以找到在静态二进制文件中的位置</p>
<h2 id="最后"><a class="markdownIt-Anchor" href="#最后"></a> 最后</h2>
<p>完整code:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD64 <span class="title">dwVAToRVA</span><span class="params">(DWORD64 StartVA, DWORD64 nt_head_file_start, std::string&amp; fileContent, PIMAGE_NT_HEADERS64 ntTempHeader)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    DWORD64 iatDVA = StartVA;</span><br><span class="line"></span><br><span class="line">    DWORD64 iatVA = <span class="number">0</span>;</span><br><span class="line">    DWORD64 RVA = <span class="number">0</span>;</span><br><span class="line">    DWORD64 sectionFileAddr;</span><br><span class="line">    IMAGE_SECTION_HEADER* sectionHeader;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; ntTempHeader-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sectionFileAddr = nt_head_file_start + <span class="built_in">sizeof</span>(IMAGE_NT_HEADERS64) + i * <span class="built_in">sizeof</span>(IMAGE_SECTION_HEADER);</span><br><span class="line">        sectionHeader = (PIMAGE_SECTION_HEADER)(DWORD64)(&amp;fileContent[sectionFileAddr]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sectionHeader-&gt;VirtualAddress &gt; iatDVA)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        iatVA = sectionHeader-&gt;VirtualAddress;</span><br><span class="line">        RVA = iatDVA - iatVA + sectionHeader-&gt;PointerToRawData;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> RVA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> std::string filePath = <span class="string">&quot;notepad.exe&quot;</span>;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">inputFile</span><span class="params">(filePath, std::ios::in | std::ios::binary)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!inputFile.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;cant open: &quot;</span> &lt;&lt; filePath &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::ostringstream peFileString;</span><br><span class="line">    peFileString &lt;&lt; inputFile.<span class="built_in">rdbuf</span>();</span><br><span class="line">    std::string fileContent = peFileString.<span class="built_in">str</span>();</span><br><span class="line">    inputFile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    IMAGE_DOS_HEADER* dosHeader = (PIMAGE_DOS_HEADER)(DWORD64)(&amp;fileContent[<span class="number">0</span>]);</span><br><span class="line">    std::cout &lt;&lt; std::hex;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;PE e_magic  : 0x&quot;</span> &lt;&lt; dosHeader-&gt;e_magic &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;PE e_lfanew : 0x&quot;</span> &lt;&lt; dosHeader-&gt;e_lfanew &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    IMAGE_NT_HEADERS64* ntTempHeader = (PIMAGE_NT_HEADERS64)(DWORD64)(&amp;fileContent[dosHeader-&gt;e_lfanew]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SetConsoleOutputCP</span>(CP_UTF8);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;程序位数    : &quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (ntTempHeader-&gt;FileHeader.Machine == <span class="number">0x8664</span>)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;64位\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ntTempHeader-&gt;FileHeader.Machine == <span class="number">0x014c</span>)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;32位\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;区段数量: &quot;</span> &lt;&lt; ntTempHeader-&gt;FileHeader.NumberOfSections &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="type">int</span> nt_head_file_start = dosHeader-&gt;e_lfanew;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; ntTempHeader-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        DWORD64 sectionFileAddr = nt_head_file_start + <span class="built_in">sizeof</span>(IMAGE_NT_HEADERS64) + i * <span class="built_in">sizeof</span>(IMAGE_SECTION_HEADER);</span><br><span class="line">        IMAGE_SECTION_HEADER* sectionHeader = (PIMAGE_SECTION_HEADER)(DWORD64)(&amp;fileContent[sectionFileAddr]);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; Section[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] address: 0x&quot;</span> &lt;&lt; sectionFileAddr &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;            name        : &quot;</span> &lt;&lt; sectionHeader-&gt;Name &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;            VA          : 0x&quot;</span> &lt;&lt; sectionHeader-&gt;VirtualAddress &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;            ptr2RawData : 0x&quot;</span> &lt;&lt; sectionHeader-&gt;PointerToRawData &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;---OptionalHeader.DataDirectories\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;基本重定位表           : 0x&quot;</span> &lt;&lt; ntTempHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;全局指针的相对虚拟地址   : 0x&quot;</span> &lt;&lt; ntTempHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_GLOBALPTR].VirtualAddress &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;导入地址表             : 0x&quot;</span> &lt;&lt; ntTempHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    DWORD64 iatDVA = ntTempHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;</span><br><span class="line"></span><br><span class="line">    DWORD64 iatVA = <span class="number">0</span>;</span><br><span class="line">    DWORD64 iatRVA = <span class="number">0</span>;</span><br><span class="line">    DWORD64 sectionFileAddr;</span><br><span class="line">    IMAGE_SECTION_HEADER* sectionHeader;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; ntTempHeader-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sectionFileAddr = nt_head_file_start + <span class="built_in">sizeof</span>(IMAGE_NT_HEADERS64) + i * <span class="built_in">sizeof</span>(IMAGE_SECTION_HEADER);</span><br><span class="line">        sectionHeader = (PIMAGE_SECTION_HEADER)(DWORD64)(&amp;fileContent[sectionFileAddr]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sectionHeader-&gt;VirtualAddress &gt; iatDVA)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        iatVA = sectionHeader-&gt;VirtualAddress;</span><br><span class="line">        iatRVA = iatDVA - iatVA + sectionHeader-&gt;PointerToRawData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">    PIMAGE_IMPORT_DESCRIPTOR temp = <span class="built_in">PIMAGE_IMPORT_DESCRIPTOR</span>((DWORD64)&amp;fileContent[<span class="number">0</span>] + iatRVA + i * <span class="built_in">sizeof</span>(IMAGE_IMPORT_DESCRIPTOR));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; temp-&gt;Name != <span class="number">0</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        DWORD64 VA = <span class="built_in">dwVAToRVA</span>(temp-&gt;Name, nt_head_file_start, fileContent, ntTempHeader);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;  DLL: &quot;</span> &lt;&lt; (<span class="type">char</span>*)(&amp;fileContent[VA]) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">        VA = *<span class="built_in">PDWORD64</span>(&amp;fileContent[<span class="number">0</span>] + <span class="built_in">dwVAToRVA</span>(temp-&gt;FirstThunk, nt_head_file_start, fileContent, ntTempHeader));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; VA != <span class="number">0</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            PIMAGE_IMPORT_BY_NAME IatName = <span class="built_in">PIMAGE_IMPORT_BY_NAME</span>(&amp;fileContent[<span class="number">0</span>] + <span class="built_in">dwVAToRVA</span>(VA, nt_head_file_start, fileContent, ntTempHeader));</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;    -Function &quot;</span> &lt;&lt; IatName-&gt;Name &lt;&lt; std::endl;</span><br><span class="line">            VA = *<span class="built_in">PDWORD64</span>(&amp;fileContent[<span class="number">0</span>] + <span class="built_in">dwVAToRVA</span>(temp-&gt;FirstThunk, nt_head_file_start, fileContent, ntTempHeader) + i * <span class="built_in">sizeof</span>(DWORD64));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        temp = <span class="built_in">PIMAGE_IMPORT_DESCRIPTOR</span>(&amp;fileContent[<span class="number">0</span>] + iatRVA + i * <span class="built_in">sizeof</span>(IMAGE_IMPORT_DESCRIPTOR));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></article><div class="pagination"><a class="pagination__link pagination__prev" href="/2024/10/01/dll-inject/">prev_post</a><a class="pagination__link pagination__next" href="/2024/10/01/reflect_dll/">next_post</a></div></main><footer class="footer metadata"><p class="footer__text">© 2025 Joe1sn</p><p class="footer__text">Powered by <a class="footer__text__link" href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a class="footer__text__link" href="https://pages.github.com/" target="_blank">Github Page</a></p></footer></div></body></html>