<!DOCTYPE html><html lang="zh"><head><meta charset="UTF-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Joe1sn's Cabinet | 【Win Pwn】Windows内核池笔记</title><meta name="description" content="&lt;p&gt;文章来自blackhat 2021的文章《Windows-Heap-Backed-Pool-The-Good-The-Bad-And-The-Encoded》&lt;/p&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://i.blackhat.com/USA21/Wednesday-Handouts/us-21-Windows-Heap-Backed-Pool-The-Good-The-Bad-And-The-Encoded.pdf&quot;&gt;https://i.blackhat.com/USA21/Wednesday-Handouts/us-21-Windows-Heap-Backed-Pool-The-Good-The-Bad-And-The-Encoded.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Youtube：&lt;a href=&quot;https://www.youtube.com/watch?v=VvxNc8GTFfk&quot;&gt;https://www.youtube.com/watch?v=VvxNc8GTFfk&lt;/a&gt;&lt;/p&gt;"><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700"><link rel="stylesheet" href="/css/highlights/darkula.css"><link rel="stylesheet" href="/css/main.css"><link rel="search" type="application/opensearchdescription+xml" href="https://joe1sn.eu.org/atom.xml" title="Joe1sn's Cabinet"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Joe1sn's Cabinet" type="application/atom+xml">
</head><body><div class="container"><header class="main-header"><h1 class="main-header__title uplize"><a class="main-header__title__link" href="/">Joe1sn's Cabinet</a></h1><nav class="main-header__nav"><ul class="main-nav"><li class="main-nav__list"><a class="main-nav__list__link" href="/" target="_self">HOME</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/archives/" target="_self">ARCHIVE</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="https://github.com/Joe1sn" target="_blank">GITHUB</a></li></ul></nav></header><main class="container__wrapper"><article class="article post"><h3 class="article__title">【Win Pwn】Windows内核池笔记</h3><div class="article__date metadata"><div class="post-info">2024/03/17</div></div><div class="article__tags metadata">Tags:
<a class="article__tags__link metadata" href="/tags/kernel/">kernel</a><a class="article__tags__link metadata" href="/tags/windows/">windows</a></div><div class="article__body"><p>文章来自blackhat 2021的文章《Windows-Heap-Backed-Pool-The-Good-The-Bad-And-The-Encoded》</p>
<p>原文链接：<a target="_blank" rel="noopener" href="https://i.blackhat.com/USA21/Wednesday-Handouts/us-21-Windows-Heap-Backed-Pool-The-Good-The-Bad-And-The-Encoded.pdf">https://i.blackhat.com/USA21/Wednesday-Handouts/us-21-Windows-Heap-Backed-Pool-The-Good-The-Bad-And-The-Encoded.pdf</a></p>
<p>Youtube：<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=VvxNc8GTFfk">https://www.youtube.com/watch?v=VvxNc8GTFfk</a></p>
<span id="more"></span>
<h1 id="粗略的分配"><a class="markdownIt-Anchor" href="#粗略的分配"></a> 粗略的分配</h1>
<p>内核动态内存：和R3中的对差不多</p>
<p>类型为可分页和不可分页，程序按照4KB分页，之前写过一点相关的：<a href="https://joe1sn.eu.org/2023/02/17/windows_kernel_driver_2/">Joe1sn’s Cabinet | windows内核驱动 2-页表探索</a></p>
<p>旧API初始化中不会将内存置零，导致信息泄露</p>
<p>一些API</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/f1d91b71f507bed8db8d8849de7e6bff.png" alt="image-20240317095459904" /></p>
<p>在RS5（Redstone 5）版本前（及Windows 1809，在2018年10月前的版本）</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/f364e47d4cdcab7796144a5b39a53f85.png" alt="image-20240317095835831" /></p>
<p>没有任何校验、加密等等，但是之后就变得复杂得多了（严重怀疑微软借鉴了glibc的内存管理）</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/170fbb2877774bded875232a3a8c3128.png" alt="image-20240317100321871" /></p>
<ul>
<li>新版本的池设计管理和R3下是同一个库</li>
<li><strong>每一个独立的池由<code>SEGMENT_HEAP</code>结构体管理</strong>，后文简写为<code>SEG_HEAP</code></li>
<li>池的申请根据其大小进行不同的处理
<ul>
<li>不同大小申请机制不同</li>
<li>大内存池仍然由<code>VA</code>管理</li>
</ul>
</li>
</ul>
<p><strong>SEGMENT_HEAP</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt nt!_SEGMENT_HEAP</span><br><span class="line">   +<span class="number">0x000</span> EnvHandle        : RTL_HP_ENV_HANDLE</span><br><span class="line">   +<span class="number">0x010</span> Signature        : Uint4B</span><br><span class="line">   +<span class="number">0x014</span> GlobalFlags      : Uint4B</span><br><span class="line">   +<span class="number">0x018</span> Interceptor      : Uint4B</span><br><span class="line">   +<span class="number">0x01c</span> ProcessHeapListIndex : Uint2B</span><br><span class="line">   +<span class="number">0x01e</span> AllocatedFromMetadata : Pos <span class="number">0</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x020</span> CommitLimitData  : _RTL_HEAP_MEMORY_LIMIT_DATA</span><br><span class="line">   +<span class="number">0x020</span> ReservedMustBeZero1 : Uint8B</span><br><span class="line">   +<span class="number">0x028</span> UserContext      : Ptr64 Void</span><br><span class="line">   +<span class="number">0x030</span> ReservedMustBeZero2 : Uint8B</span><br><span class="line">   +<span class="number">0x038</span> Spare            : Ptr64 Void</span><br><span class="line">   +<span class="number">0x040</span> LargeMetadataLock : Uint8B</span><br><span class="line">   +<span class="number">0x048</span> LargeAllocMetadata : _RTL_RB_TREE</span><br><span class="line">   +<span class="number">0x058</span> LargeReservedPages : Uint8B</span><br><span class="line">   +<span class="number">0x060</span> LargeCommittedPages : Uint8B</span><br><span class="line">   +<span class="number">0x068</span> StackTraceInitVar : _RTL_RUN_ONCE</span><br><span class="line">   +<span class="number">0x080</span> MemStats         : _HEAP_RUNTIME_MEMORY_STATS</span><br><span class="line">   +<span class="number">0x0d8</span> GlobalLockCount  : Uint2B</span><br><span class="line">   +<span class="number">0x0dc</span> GlobalLockOwner  : Uint4B</span><br><span class="line">   +<span class="number">0x0e0</span> ContextExtendLock : Uint8B</span><br><span class="line">   +<span class="number">0x0e8</span> AllocatedBase    : Ptr64 UChar</span><br><span class="line">   +<span class="number">0x0f0</span> UncommittedBase  : Ptr64 UChar</span><br><span class="line">   +<span class="number">0x0f8</span> ReservedLimit    : Ptr64 UChar</span><br><span class="line">   +<span class="number">0x100</span> SegContexts      : [<span class="number">2</span>] _HEAP_SEG_CONTEXT</span><br><span class="line">   +<span class="number">0x280</span> VsContext        : _HEAP_VS_CONTEXT</span><br><span class="line">   +<span class="number">0x340</span> LfhContext       : _HEAP_LFH_CONTEXT</span><br></pre></td></tr></table></figure>
<p>文章选了一些重点来</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/ed29af21efa3768777ad12bffd6c222e.png" alt="image-20240317101151659" /></p>
<p>根据上图缩略结构体</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt nt!_SEGMENT_HEAP</span><br><span class="line">  ....</span><br><span class="line">   +<span class="number">0x048</span> LargeAllocMetadata : _RTL_RB_TREE</span><br><span class="line">  ....</span><br><span class="line">   +<span class="number">0x080</span> MemStats         : _HEAP_RUNTIME_MEMORY_STATS	<span class="comment">//大内存页状态</span></span><br><span class="line">  ....</span><br><span class="line">   +<span class="number">0x0e8</span> AllocatedBase    : Ptr64 UChar			<span class="comment">//已分配内存</span></span><br><span class="line">   +<span class="number">0x0f0</span> UncommittedBase  : Ptr64 UChar			<span class="comment">//未提交内存</span></span><br><span class="line">   +<span class="number">0x0f8</span> ReservedLimit    : Ptr64 UChar			</span><br><span class="line">   +<span class="number">0x100</span> SegContexts      : [<span class="number">2</span>] _HEAP_SEG_CONTEXT</span><br><span class="line">   +<span class="number">0x280</span> VsContext        : _HEAP_VS_CONTEXT		<span class="comment">//VS类型堆管理链表</span></span><br><span class="line">   +<span class="number">0x340</span> LfhContext       : _HEAP_LFH_CONTEXT		<span class="comment">//KLFH类型堆管理链表</span></span><br></pre></td></tr></table></figure>
<p>根据文章，<code>SEG_HEAP</code>通过两个<code>SegContexts</code>来处理前两种大小的内存（小堆和中堆）</p>
<ul>
<li>0~508KB（0-0x7F000）</li>
<li>508KB~8128KB（0x7F000-0x7F0000）</li>
<li>大于8128KB（大堆处理）</li>
</ul>
<p>内核通过位图（bitmap，做过算法的应该知道吧）保存每次申请的大小的类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nt!ExPoolState‐&gt;HeapManager‐&gt;AllocTracker‐&gt;AllocTrackerBitma</span><br></pre></td></tr></table></figure>
<p>关于位图</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/d5acbdc61a3cace2b43c3a2f3b0e104e.png" alt="image-20240317102907777" /></p>
<ul>
<li>每两字节（2Byte）表示在内核内存中的地址</li>
<li>位图存在三层</li>
</ul>
<p><code>_HEAP_SEG_CONTEXT</code>结构体：</p>
<p>在<code>SEG_HEAP</code>中</p>
<ul>
<li><code>_HEAP_SEG_CONTEXT[0]</code>：以 1 页的基本单位处理 1MB 段</li>
<li><code>_HEAP_SEG_CONTEXT[1]</code>：以 16 页的基本单位处理 16MB 段</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: kd&gt; dt nt!_HEAP_SEG_CONTEXT</span><br><span class="line">   +<span class="number">0x000</span> SegmentMask      : Uint8B</span><br><span class="line">   +<span class="number">0x008</span> UnitShift        : UChar</span><br><span class="line">   +<span class="number">0x009</span> PagesPerUnitShift : UChar</span><br><span class="line">   +<span class="number">0x00a</span> FirstDescriptorIndex : UChar</span><br><span class="line">   +<span class="number">0x00b</span> CachedCommitSoftShift : UChar</span><br><span class="line">   +<span class="number">0x00c</span> CachedCommitHighShift : UChar</span><br><span class="line">   +<span class="number">0x00d</span> Flags            : &lt;anonymous-tag&gt;</span><br><span class="line">   +<span class="number">0x010</span> MaxAllocationSize : Uint4B</span><br><span class="line">   +<span class="number">0x014</span> OlpStatsOffset   : Int2B</span><br><span class="line">   +<span class="number">0x016</span> MemStatsOffset   : Int2B</span><br><span class="line">   +<span class="number">0x018</span> LfhContext       : Ptr64 Void</span><br><span class="line">   +<span class="number">0x020</span> VsContext        : Ptr64 Void</span><br><span class="line">   +<span class="number">0x028</span> EnvHandle        : RTL_HP_ENV_HANDLE</span><br><span class="line">   +<span class="number">0x038</span> Heap             : Ptr64 Void</span><br><span class="line">   +<span class="number">0x040</span> SegmentLock      : Uint8B</span><br><span class="line">   +<span class="number">0x048</span> SegmentListHead  : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x058</span> SegmentCount     : Uint8B</span><br><span class="line">   +<span class="number">0x060</span> FreePageRanges   : _RTL_RB_TREE</span><br><span class="line">   +<span class="number">0x070</span> FreeSegmentListLock : Uint8B</span><br><span class="line">   +<span class="number">0x078</span> FreeSegmentList  : [<span class="number">2</span>] _SINGLE_LIST_ENTRY</span><br></pre></td></tr></table></figure>
<p>简化一下重要信息</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: kd&gt; dt nt!_HEAP_SEG_CONTEXT</span><br><span class="line">   +<span class="number">0x000</span> SegmentMask      : Uint8B			<span class="comment">//如何从池内存到当前段</span></span><br><span class="line">.....</span><br><span class="line">   +<span class="number">0x048</span> SegmentListHead  : _LIST_ENTRY	<span class="comment">//连接所有已分配的堆</span></span><br><span class="line">.....</span><br><span class="line">   +<span class="number">0x078</span> FreeSegmentList  : [<span class="number">2</span>] _SINGLE_LIST_ENTRY	<span class="comment">//链接所有已释放的堆</span></span><br></pre></td></tr></table></figure>
<p>段(segment)链接的结构体为`HEAP_PAGE_SEGMENT</p>
<p><code>_HEAP_PAGE_SEGMENT</code>结构体</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt; dt nt!_HEAP_PAGE_SEGMENT</span><br><span class="line">   +<span class="number">0x000</span> ListEntry        : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x010</span> Signature        : Uint8B</span><br><span class="line">   +<span class="number">0x018</span> SegmentCommitState : Ptr64 _HEAP_SEGMENT_MGR_COMMIT_STATE</span><br><span class="line">   +<span class="number">0x020</span> UnusedWatermark  : UChar</span><br><span class="line">   +<span class="number">0x000</span> DescArray        : [<span class="number">256</span>] _HEAP_PAGE_RANGE_DESCRIPTOR</span><br></pre></td></tr></table></figure>
<p>这里抹除类型，给点注释</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt; dt nt!_HEAP_PAGE_SEGMENT</span><br><span class="line">   +<span class="number">0x000</span> ListEntry        :       <span class="comment">//结构体`SEG_CONTECT`指向，可参考下面的图</span></span><br><span class="line">   +<span class="number">0x010</span> Signature        :       <span class="comment">//可以找到`SEG_CONTEXT`，但是被异或加密了</span></span><br><span class="line">			<span class="comment">//解密方法 `段地址 ^ 堆密钥(heap key) ^ 魔数`</span></span><br><span class="line">........</span><br><span class="line">   +<span class="number">0x000</span> DescArray        : [<span class="number">256</span>] <span class="comment">//每个保存一个单元，还有子段(subseg)类型和偏移</span></span><br><span class="line">   <span class="comment">//  +0x000 TreeNode         : _RTL_BALANCED_NODE</span></span><br><span class="line">   <span class="comment">//  +0x000 TreeSignature    : Uint4B</span></span><br><span class="line">   <span class="comment">//  +0x004 UnusedBytes      : Uint4B</span></span><br><span class="line">   <span class="comment">//  +0x008 ExtraPresent     : Pos 0, 1 Bit</span></span><br><span class="line">   <span class="comment">//  +0x008 Spare0           : Pos 1, 15 Bits</span></span><br><span class="line">   <span class="comment">//  +0x018 RangeFlags       : UChar</span></span><br><span class="line">   <span class="comment">//  +0x019 CommittedPageCount : UChar</span></span><br><span class="line">   <span class="comment">//  +0x01a Spare            : Uint2B</span></span><br><span class="line">   <span class="comment">//  +0x01c Key              : _HEAP_DESCRIPTOR_KEY</span></span><br><span class="line">   <span class="comment">//  +0x01c Align            : [3] UChar</span></span><br><span class="line">   <span class="comment">//  +0x01f UnitOffset       : UChar</span></span><br><span class="line">   <span class="comment">//  +0x01f UnitSize         : UChar</span></span><br></pre></td></tr></table></figure>
<p>总结下当前的内核相关信息，从<code>SEG_HEAP</code>开始</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/271ff260bccb87ea153b8e49dc8db2bd.png" alt="image-20240317103818286" /></p>
<h1 id="关于两种大小的内存管理"><a class="markdownIt-Anchor" href="#关于两种大小的内存管理"></a> 关于两种大小的内存管理</h1>
<h2 id="两种子段-vs和lfh"><a class="markdownIt-Anchor" href="#两种子段-vs和lfh"></a> 两种子段 VS和LFH</h2>
<p><strong>1. LFH - Low Fragmentation Heap</strong></p>
<p><code>_HEAP_LFH_SUBSEGMENT</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt; dt nt!_HEAP_LFH_SUBSEGMENT</span><br><span class="line">   +<span class="number">0x000</span> ListEntry        : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x010</span> Owner            : Ptr64 _HEAP_LFH_SUBSEGMENT_OWNER</span><br><span class="line">   +<span class="number">0x010</span> DelayFree        : _HEAP_LFH_SUBSEGMENT_DELAY_FREE</span><br><span class="line">   +<span class="number">0x018</span> CommitLock       : Uint8B</span><br><span class="line">   +<span class="number">0x020</span> FreeCount        : Uint2B</span><br><span class="line">   +<span class="number">0x022</span> BlockCount       : Uint2B</span><br><span class="line">   +<span class="number">0x020</span> InterlockedShort : Int2B</span><br><span class="line">   +<span class="number">0x020</span> InterlockedLong  : Int4B</span><br><span class="line">   +<span class="number">0x024</span> FreeHint         : Uint2B</span><br><span class="line">   +<span class="number">0x026</span> Location         : UChar</span><br><span class="line">   +<span class="number">0x027</span> WitheldBlockCount : UChar</span><br><span class="line">   +<span class="number">0x028</span> BlockOffsets     : _HEAP_LFH_SUBSEGMENT_ENCODED_OFFSETS</span><br><span class="line">   +<span class="number">0x02c</span> CommitUnitShift  : UChar</span><br><span class="line">   +<span class="number">0x02d</span> CommitUnitCount  : UChar</span><br><span class="line">   +<span class="number">0x02e</span> CommitStateOffset : Uint2B</span><br><span class="line">   +<span class="number">0x030</span> BlockBitmap      : [<span class="number">1</span>] Uint8B</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>用于 129 种常见大小的分配</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/e6e613b9c73ef4cfdf6469218064d5db.png" alt="image-20240317112023052" /></p>
</li>
<li>
<p>所有分配的子段有一样的大小</p>
</li>
<li>
<p>最大大小是<code>0x4000</code></p>
</li>
<li>
<p>为了节省空间，没有独特的head</p>
</li>
<li>
<p>堆块的状态由head中的位图决定</p>
</li>
</ul>
<p><strong>2. VS - Variable Size</strong></p>
<p><code>_HEAP_VS_SUBSEGMENT</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt; dt nt!_HEAP_VS_SUBSEGMENT</span><br><span class="line">   +<span class="number">0x000</span> ListEntry        : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x010</span> CommitBitmap     : Uint8B</span><br><span class="line">   +<span class="number">0x018</span> CommitLock       : Uint8B</span><br><span class="line">   +<span class="number">0x020</span> Size             : Uint2B</span><br><span class="line">   +<span class="number">0x022</span> Signature        : Pos <span class="number">0</span>, <span class="number">15</span> Bits</span><br><span class="line">   +<span class="number">0x022</span> FullCommit       : Pos <span class="number">15</span>, <span class="number">1</span> Bit</span><br></pre></td></tr></table></figure>
<ul>
<li>处理所有LFH不能处理的bucket</li>
<li>没有个块(block)都有一个自己的头描述</li>
</ul>
<p>两者的对比</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/47b7aed371bc8f6e9464a64b014f0ec9.png" alt="image-20240317110710922" /></p>
<ul>
<li>VS头中的大小使用<code>heap key</code>加密（其实是编码，这里为了语义通顺），LFH使用自己的<code>LFH Key</code> 加密。（这显然让堆利用变得困难，你猜为啥我要反过来读这篇文章而不是直接做HEVD）</li>
<li>子段大小不固定</li>
<li>子段包含多个页，必须从头开始计算偏移去寻找（单独寻找某个页已经几乎不可能）</li>
<li>已分配的块仍然会存在<code>POOL_HEAD</code>，但是释放掉的不会</li>
</ul>
<p><strong>相关的“加密&quot;</strong></p>
<ul>
<li>HEAP_LFH_SUBSEGMENT
<ol>
<li>块大小和偏移量位于编码的 BlockOffsets 字段中</li>
<li>数据（Data） = <code> EncodedData ^ LfhKey ^ ((ULONG)(Subsegment) &gt;&gt; 12)</code></li>
<li>子段列表没被加密</li>
</ol>
</li>
<li>HEAP_VS_SUBSEGMENT
<ol>
<li>用于链接子段的列表被当前子段地址加密了</li>
</ol>
</li>
<li>HEAP_VS_CHUNK_HEADER
<ol>
<li>每一个VS子段中头存在</li>
<li>块大小和分配状态在<code>Size</code>头中被加密</li>
<li>数据（Data）= <code>Sizes.HeaderBits ^ HeapKey ^ ChunkHeader</code></li>
</ol>
</li>
</ul>
<h2 id="两种上下文"><a class="markdownIt-Anchor" href="#两种上下文"></a> 两种上下文</h2>
<p>最开始的<code>SEG_HEAP</code>中有</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+<span class="number">0x280</span> VsContext        : _HEAP_VS_CONTEXT</span><br><span class="line">+<span class="number">0x340</span> LfhContext       : _HEAP_LFH_CONTEXT</span><br></pre></td></tr></table></figure>
<p><strong>_HEAP_LFH_CONTEXT</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt; dt nt!_HEAP_LFH_CONTEXT</span><br><span class="line">   +<span class="number">0x000</span> BackendCtx       : Ptr64 Void</span><br><span class="line">   +<span class="number">0x008</span> Callbacks        : _HEAP_SUBALLOCATOR_CALLBACKS</span><br><span class="line">   +<span class="number">0x030</span> AffinityModArray : Ptr64 UChar</span><br><span class="line">   +<span class="number">0x038</span> MaxAffinity      : UChar</span><br><span class="line">   +<span class="number">0x039</span> LockType         : UChar</span><br><span class="line">   +<span class="number">0x03a</span> MemStatsOffset   : Int2B</span><br><span class="line">   +<span class="number">0x03c</span> Config           : _RTL_HP_LFH_CONFIG</span><br><span class="line">   +<span class="number">0x040</span> BucketStats      : _HEAP_LFH_SUBSEGMENT_STATS</span><br><span class="line">   +<span class="number">0x048</span> SubsegmentCreationLock : Uint8B</span><br><span class="line">   +<span class="number">0x080</span> Buckets          : [<span class="number">129</span>] Ptr64 _HEAP_LFH_BUCKET</span><br></pre></td></tr></table></figure>
<p>注释关键信息</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt; dt nt!_HEAP_LFH_CONTEXT</span><br><span class="line">...</span><br><span class="line">   +<span class="number">0x008</span> Callbacks        : <span class="comment">//子堆分配回调函数</span></span><br><span class="line">......</span><br><span class="line">   +<span class="number">0x080</span> Buckets          : [<span class="number">129</span>] <span class="comment">//前面提到过LFH处理常见129种堆</span></span><br><span class="line">								<span class="comment">//这里的bucket就存放每个堆的列表</span></span><br><span class="line">								<span class="comment">//保存有关块大小、子段计数、块计数的数据</span></span><br></pre></td></tr></table></figure>
<p><strong>_HEAP_VS_CONTEXT</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt; dt nt!_HEAP_VS_CONTEXT</span><br><span class="line">   +<span class="number">0x000</span> Lock             : Uint8B</span><br><span class="line">   +<span class="number">0x008</span> LockType         : _RTLP_HP_LOCK_TYPE</span><br><span class="line">   +<span class="number">0x010</span> FreeChunkTree    : _RTL_RB_TREE</span><br><span class="line">   +<span class="number">0x020</span> SubsegmentList   : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x030</span> TotalCommittedUnits : Uint8B</span><br><span class="line">   +<span class="number">0x038</span> FreeCommittedUnits : Uint8B</span><br><span class="line">   +<span class="number">0x040</span> DelayFreeContext : _HEAP_VS_DELAY_FREE_CONTEXT</span><br><span class="line">   +<span class="number">0x080</span> BackendCtx       : Ptr64 Void</span><br><span class="line">   +<span class="number">0x088</span> Callbacks        : _HEAP_SUBALLOCATOR_CALLBACKS</span><br><span class="line">   +<span class="number">0x0b0</span> Config           : _RTL_HP_VS_CONFIG</span><br><span class="line">   +<span class="number">0x0b4</span> Flags            : Uint4B</span><br></pre></td></tr></table></figure>
<p>注释关键信息</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt; dt nt!_HEAP_VS_CONTEXT</span><br><span class="line">......</span><br><span class="line">   +<span class="number">0x020</span> SubsegmentList   : <span class="comment">//所有VS类型的子段</span></span><br><span class="line">   +<span class="number">0x030</span> TotalCommittedUnits : <span class="comment">//计数</span></span><br><span class="line">   +<span class="number">0x038</span> FreeCommittedUnits : <span class="comment">//计数</span></span><br><span class="line">......</span><br><span class="line">   +<span class="number">0x088</span> Callbacks        : <span class="comment">//allocate, free, commit等子段回调函数</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>总结下两种上下文</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/09b816568e627599cec85957350f2d0c.png" alt="image-20240317112721755" /></p>
</div></article><section class="comments"><div id="disqus_thread"></div><script>var disqus_shortname = 'disqus';
(function () {
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//#{theme.disqus}.disqus.com/count.js" async></script></section><div class="pagination"><a class="pagination__link pagination__prev" href="/2024/03/17/windows-kernel-driver-3/">prev_post</a><a class="pagination__link pagination__next" href="/2024/03/15/little-hook/">next_post</a></div></main><footer class="footer metadata"><p class="footer__text">© 2025 Joe1sn</p><p class="footer__text">Powered by <a class="footer__text__link" href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a class="footer__text__link" href="https://pages.github.com/" target="_blank">Github Page</a></p></footer></div></body></html>